diff --git a/checkstyle.xml b/checkstyle.xml
index 665f784..79e74e8 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -4,7 +4,7 @@
     "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
 
 <module name="Checker">
-    <module name="NewlineAtEndOfFile"/>
+    <!--module name="NewlineAtEndOfFile"/-->
     <module name="FileLength"/>
     <module name="FileTabCharacter"/>
 
@@ -20,9 +20,9 @@
         <!-- Checks for Javadoc comments.                     -->
         <!-- See http://checkstyle.sf.net/config_javadoc.html -->
         <!--module name="JavadocMethod"/-->
-        <module name="JavadocType"/>
+        <!--module name="JavadocType"/-->
         <!--module name="JavadocVariable"/-->
-        <module name="JavadocStyle"/>
+        <!--module name="JavadocStyle"/-->
 
 
         <!-- Checks for Naming Conventions.                  -->
@@ -51,20 +51,20 @@
         <module name="LineLength">
             <property name="max" value="120"/>
         </module>
-        <module name="MethodLength"/>
-        <module name="ParameterNumber"/>
+        <!--module name="MethodLength"/-->
+        <!--module name="ParameterNumber"/-->
 
 
         <!-- Checks for whitespace                               -->
         <!-- See http://checkstyle.sf.net/config_whitespace.html -->
         <module name="GenericWhitespace"/>
-        <module name="EmptyForIteratorPad"/>
+        <!--<module name="EmptyForIteratorPad"/>-->
         <module name="MethodParamPad"/>
         <module name="NoWhitespaceAfter"/>
         <module name="NoWhitespaceBefore"/>
         <module name="OperatorWrap"/>
         <module name="ParenPad"/>
-        <module name="TypecastParenPad"/>
+        <!--module name="TypecastParenPad"/-->
         <module name="WhitespaceAfter"/>
         <module name="WhitespaceAround"/>
 
@@ -77,10 +77,10 @@
 
         <!-- Checks for blocks. You know, those {}'s         -->
         <!-- See http://checkstyle.sf.net/config_blocks.html -->
-        <module name="AvoidNestedBlocks"/>
+        <!--module name="AvoidNestedBlocks"/-->
         <!--module name="EmptyBlock"/-->
         <module name="LeftCurly"/>
-        <module name="NeedBraces"/>
+        <!--module name="NeedBraces"/-->
         <module name="RightCurly"/>
 
 
@@ -94,7 +94,7 @@
         <module name="EqualsHashCode"/>
         <!--module name="HiddenField"/-->
         <module name="IllegalInstantiation"/>
-        <module name="InnerAssignment"/>
+        <!--<module name="InnerAssignment"/>-->
         <!--module name="MagicNumber"/-->
         <module name="MissingSwitchDefault"/>
         <module name="RedundantThrows"/>
@@ -104,17 +104,17 @@
         <!-- Checks for class design                         -->
         <!-- See http://checkstyle.sf.net/config_design.html -->
         <!--module name="DesignForExtension"/-->
-        <module name="FinalClass"/>
-        <module name="HideUtilityClassConstructor"/>
-        <module name="InterfaceIsType"/>
-        <!--s/module name="VisibilityModifier"/-->
+        <!--module name="FinalClass"/-->
+        <!--module name="HideUtilityClassConstructor"/-->
+        <!--module name="InterfaceIsType"/-->
+        <!--module name="VisibilityModifier"/-->
 
 
         <!-- Miscellaneous other checks.                   -->
         <!-- See http://checkstyle.sf.net/config_misc.html -->
-        <module name="ArrayTypeStyle"/>
+        <!--module name="ArrayTypeStyle"/-->
         <!--module name="FinalParameters"/-->
-        <module name="TodoComment"/>
+        <!--module name="TodoComment"/-->
         <module name="UpperEll"/>
     </module>
 </module>
/Fim/
diff --git a/src/main/java/com/squareup/codegen/JavaWriter.java b/src/main/java/com/squareup/codegen/JavaWriter.java
index a9aa974..898363b 100644
--- a/src/main/java/com/squareup/codegen/JavaWriter.java
+++ b/src/main/java/com/squareup/codegen/JavaWriter.java
@@ -147,7 +147,7 @@
   }
 
   /**
-   * Emits a method declaration.
+   * Emit a method declaration.
    *
    * @param returnType the method's return type, or null for constructors.
    * @param parameters alternating parameter types and names.
/Fim/
diff --git a/src/main/java/com/squareup/injector/Injector.java b/src/main/java/com/squareup/injector/Injector.java
index ba47305..bd0cad0 100644
--- a/src/main/java/com/squareup/injector/Injector.java
+++ b/src/main/java/com/squareup/injector/Injector.java
@@ -15,12 +15,10 @@
  */
 package com.squareup.injector;
 
-import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import javax.inject.Provider;
 
 /**
  * Dependency injector.
@@ -37,7 +35,7 @@
  *   <li>Injection of {@code @Provides} method parameters.
  *   <li>{@code @Provides} methods annotated {@code @Singleton}.
  *   <li>Constructor-injected classes annotated {@code @Singleton}.
- *   <li>Injection of {@link Provider}s.
+ *   <li>Injection of {@link javax.inject.Provider}s.
  *   <li>Qualifier annotations on injected parameters and fields.
  *   <li>JSR 330 annotations.
  * </ul>
@@ -73,12 +71,9 @@
       throw new IllegalStateException("Injectors may only inject once.");
     }
 
-    for (Object module : modules) {
-      try {
-        install(module);
-      } catch (Exception e) {
-        errors.add(e.getMessage());
-      }
+    Map<Key<?>, Binding<?>> combined = Modules.moduleToMap(Modules.combine(modules));
+    for (Binding<?> binding : combined.values()) {
+      putBinding(binding);
     }
 
     Linker linker = new Linker(this);
@@ -98,34 +93,15 @@
     return root.get(); // Linker.link() guarantees that this will be non-null.
   }
 
-  private void install(Object module) {
-    boolean hasProvidesMethods = false;
-    for (Class<?> c = module.getClass(); c != Object.class; c = c.getSuperclass()) {
-      for (Method method : c.getDeclaredMethods()) {
-        if (method.getAnnotation(Provides.class) != null) {
-          install(module, method);
-          hasProvidesMethods = true;
-        }
-      }
-    }
-    if (!hasProvidesMethods) {
-      throw new IllegalArgumentException("No @Provides methods on " + module);
-    }
-  }
-
-  private <T> void install(Object module, Method method) {
-    Key<T> key = Key.get(method.getGenericReturnType(), method.getAnnotations(), method);
-    putBinding(new ProviderMethodBinding<T>(method, key, module));
-  }
-
   @SuppressWarnings("unchecked") // Typesafe heterogeneous container.
   <T> Binding<T> getBinding(Key<T> key) {
     return (Binding<T>) bindings.get(key);
   }
 
   <T> void putBinding(final Binding<T> binding) {
+    Binding<T> toInsert = binding;
     if (binding.isSingleton()) {
-      bindings.put(binding.key, new Binding<T>(binding.requiredBy, binding.key) {
+      toInsert = new Binding<T>(binding.requiredBy, binding.key) {
         private Object onlyInstance = UNINITIALIZED;
         @Override void attach(Linker linker) {
           binding.attach(linker);
@@ -142,9 +118,11 @@
         @Override public boolean isSingleton() {
           return binding.isSingleton();
         }
-      });
-    } else {
-      bindings.put(binding.key, binding);
+      };
+    }
+
+    if (bindings.put(toInsert.key, toInsert) != null) {
+      throw new IllegalArgumentException("Duplicate binding: " + toInsert.key);
     }
   }
 
/Fim/
diff --git a/src/main/java/com/squareup/injector/Linker.java b/src/main/java/com/squareup/injector/Linker.java
index adda65c..26e5a85 100644
--- a/src/main/java/com/squareup/injector/Linker.java
+++ b/src/main/java/com/squareup/injector/Linker.java
@@ -72,6 +72,10 @@
    * attached until its own dependencies have been satisfied.
    */
   private <T> void promoteDeferredBinding(DeferredBinding<T> deferred) {
+    if (injector.getBinding(deferred.key) != null) {
+      return; // A binding for this key has already been promoted.
+    }
+
     try {
       Binding<T> promoted;
       if (deferred.key.type instanceof ParameterizedType) {
/Fim/
diff --git a/src/main/java/com/squareup/injector/LruCache.java b/src/main/java/com/squareup/injector/LruCache.java
index e12b0de..44480c9 100644
--- a/src/main/java/com/squareup/injector/LruCache.java
+++ b/src/main/java/com/squareup/injector/LruCache.java
@@ -201,7 +201,8 @@
    *     this removal was caused by a {@link #put}. Otherwise it was caused by
    *     an eviction or a {@link #remove}.
    */
-  protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}
+  protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {
+  }
 
   /**
    * Called after a cache miss to compute a value for the corresponding key.
/Fim/
diff --git a/src/main/java/com/squareup/injector/Modules.java b/src/main/java/com/squareup/injector/Modules.java
new file mode 100644
index 0000000..5e36c48
--- /dev/null
+++ b/src/main/java/com/squareup/injector/Modules.java
@@ -0,0 +1,101 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import java.lang.reflect.Method;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Helper methods for dealing with collections of bindings. Any object whose
+ * declaring class defines one or more {@code @Provides} is considered to be a
+ * collection of bindings.
+ *
+ * @author Jesse Wilson
+ */
+public final class Modules {
+  private Modules() {
+  }
+
+  /**
+   * Returns a map containing the bindings in {@code object}.
+   *
+   * @param  module either a {@code map} of bindings, or an instance of a class
+   *     that declares one or more {@code @Provides} methods.
+   */
+  static Map<Key<?>, Binding<?>> moduleToMap(Object module) {
+    if (module instanceof Map) {
+      return (Map<Key<?>, Binding<?>>) module;
+    }
+    return extractBindings(module);
+  }
+
+  /**
+   * Creates bindings for the {@code @Provides} methods of {@code module}. The
+   * returned bindings are not attached to a particular injector and cannot be
+   * used to inject values.
+   */
+  private static Map<Key<?>, Binding<?>> extractBindings(Object module) {
+    Map<Key<?>, Binding<?>> result = new HashMap<Key<?>, Binding<?>>();
+    for (Class<?> c = module.getClass(); c != Object.class; c = c.getSuperclass()) {
+      for (Method method : c.getDeclaredMethods()) {
+        if (method.getAnnotation(Provides.class) == null) {
+          continue;
+        }
+        Binding<Object> binding = methodToBinding(module, method);
+        result.put(binding.key, binding);
+      }
+    }
+    if (result.isEmpty()) {
+      throw new IllegalArgumentException("No @Provides methods on " + module);
+    }
+    return result;
+  }
+
+  private static <T> Binding<T> methodToBinding(Object module, Method method) {
+    Key<T> key = Key.get(method.getGenericReturnType(), method.getAnnotations(), method);
+    return new ProviderMethodBinding<T>(method, key, module);
+  }
+
+  /**
+   * Returns a module containing the union of the bindings of {@code base} and
+   * the bindings of {@code overrides}. If any key is represented in both
+   * modules, the binding from {@code overrides} is retained.
+   */
+  public static Object override(Object base, Object overrides) {
+    Map<Key<?>, Binding<?>> result = new HashMap<Key<?>, Binding<?>>();
+    result.putAll(moduleToMap(base));
+    result.putAll(moduleToMap(overrides));
+    return result;
+  }
+
+  /**
+   * Returns a module containing all bindings in {@code modules}.
+   */
+  public static Object combine(Object... modules) {
+    Map<Key<?>, Binding<?>> result = new HashMap<Key<?>, Binding<?>>();
+    int expectedSize = 0;
+    for (Object module : modules) {
+      Map<Key<?>, Binding<?>> moduleBindings = moduleToMap(module);
+      expectedSize += moduleBindings.size();
+      result.putAll(moduleBindings);
+    }
+    if (result.size() != expectedSize) {
+      throw new IllegalArgumentException("Duplicate bindings!");
+    }
+    return result;
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/Provides.java b/src/main/java/com/squareup/injector/Provides.java
index 13dd77d..fbb7e1f 100644
--- a/src/main/java/com/squareup/injector/Provides.java
+++ b/src/main/java/com/squareup/injector/Provides.java
@@ -31,4 +31,5 @@
  * @author Bob Lee
  */
 @Documented @Target(METHOD) @Retention(RUNTIME)
-public @interface Provides {}
+public @interface Provides {
+}
/Fim/
diff --git a/src/test/java/com/squareup/injector/InjectorTest.java b/src/test/java/com/squareup/injector/InjectorTest.java
index 4331856..60431b7 100644
--- a/src/test/java/com/squareup/injector/InjectorTest.java
+++ b/src/test/java/com/squareup/injector/InjectorTest.java
@@ -303,4 +303,25 @@
     });
     assertThat(h.aProvider.get()).isSameAs(h.aProvider.get());
   }
+
+  @Test public void moduleOverrides() {
+    Object base = new Object() {
+      @Provides F provideF() {
+        throw new AssertionError();
+      }
+      @Provides E provideE(F f) {
+        return new E(f);
+      }
+    };
+
+    Object overrides = new Object() {
+      @Provides F provideF() {
+        return new F();
+      }
+    };
+
+    E e = new Injector().inject(E.class, Modules.override(base, overrides));
+    assertThat(e).isNotNull();
+    assertThat(e.f).isNotNull();
+  }
 }
/Fim/
diff --git a/src/main/java/com/squareup/codegen/JavaWriter.java b/src/main/java/com/squareup/codegen/JavaWriter.java
index 898363b..3584773 100644
--- a/src/main/java/com/squareup/codegen/JavaWriter.java
+++ b/src/main/java/com/squareup/codegen/JavaWriter.java
@@ -255,6 +255,10 @@
     }
   }
 
+  public void close() throws IOException {
+    out.close();
+  }
+
   /**
    * Emit modifier names.
    */
/Fim/
diff --git a/src/main/java/com/squareup/injector/Injector.java b/src/main/java/com/squareup/injector/Injector.java
index bd0cad0..ca1d450 100644
--- a/src/main/java/com/squareup/injector/Injector.java
+++ b/src/main/java/com/squareup/injector/Injector.java
@@ -15,9 +15,9 @@
  */
 package com.squareup.injector;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
+import com.squareup.injector.internal.Binding;
+import com.squareup.injector.internal.InternalInjector;
+import com.squareup.injector.internal.Keys;
 import java.util.Map;
 
 /**
@@ -49,84 +49,17 @@
  * @author Jesse Wilson
  */
 public final class Injector {
-  private static final Object UNINITIALIZED = new Object();
-
-  /** All errors encountered during injection. */
-  private final List<String> errors = new ArrayList<String>();
-
-  /** All of the injector's bindings. */
-  private final Map<Key<?>, Binding<?>> bindings = new HashMap<Key<?>, Binding<?>>();
-
   /**
    * Creates an injector defined by {@code modules} and immediately uses it to
    * create an instance of {@code type}. The modules can be of any type, and
    * must contain {@code @Provides} methods.
    */
   public <T> T inject(Class<T> type, Object... modules) {
-    return inject(new Key<T>(type, null), modules);
-  }
-
-  private <T> T inject(Key<T> key, Object[] modules) {
-    if (!bindings.isEmpty()) {
-      throw new IllegalStateException("Injectors may only inject once.");
-    }
-
-    Map<Key<?>, Binding<?>> combined = Modules.moduleToMap(Modules.combine(modules));
+    InternalInjector injector = new InternalInjector();
+    Map<String, Binding<?>> combined = Modules.moduleToMap(Modules.combine(modules));
     for (Binding<?> binding : combined.values()) {
-      putBinding(binding);
+      injector.putBinding(binding);
     }
-
-    Linker linker = new Linker(this);
-    linker.requestBinding(key, "root injection"); // Seed this requirement early.
-    linker.link(bindings.values());
-
-    if (!errors.isEmpty()) {
-      StringBuilder message = new StringBuilder();
-      message.append("Errors creating injector:");
-      for (String error : errors) {
-        message.append("\n  ").append(error);
-      }
-      throw new IllegalArgumentException(message.toString());
-    }
-
-    Binding<T> root = linker.requestBinding(key, "root injection");
-    return root.get(); // Linker.link() guarantees that this will be non-null.
-  }
-
-  @SuppressWarnings("unchecked") // Typesafe heterogeneous container.
-  <T> Binding<T> getBinding(Key<T> key) {
-    return (Binding<T>) bindings.get(key);
-  }
-
-  <T> void putBinding(final Binding<T> binding) {
-    Binding<T> toInsert = binding;
-    if (binding.isSingleton()) {
-      toInsert = new Binding<T>(binding.requiredBy, binding.key) {
-        private Object onlyInstance = UNINITIALIZED;
-        @Override void attach(Linker linker) {
-          binding.attach(linker);
-        }
-        @Override public void injectMembers(T t) {
-          binding.injectMembers(t);
-        }
-        @Override public T get() {
-          if (onlyInstance == UNINITIALIZED) {
-            onlyInstance = binding.get();
-          }
-          return (T) onlyInstance;
-        }
-        @Override public boolean isSingleton() {
-          return binding.isSingleton();
-        }
-      };
-    }
-
-    if (bindings.put(toInsert.key, toInsert) != null) {
-      throw new IllegalArgumentException("Duplicate binding: " + toInsert.key);
-    }
-  }
-
-  void addError(String message) {
-    errors.add(message);
+    return (T) injector.inject(Keys.get(type));
   }
 }
/Fim/
/Fim/
diff --git a/src/main/java/com/squareup/injector/Modules.java b/src/main/java/com/squareup/injector/Modules.java
index 5e36c48..03e0479 100644
--- a/src/main/java/com/squareup/injector/Modules.java
+++ b/src/main/java/com/squareup/injector/Modules.java
@@ -15,6 +15,8 @@
  */
 package com.squareup.injector;
 
+import com.squareup.injector.internal.Binding;
+import com.squareup.injector.internal.Keys;
 import java.lang.reflect.Method;
 import java.util.HashMap;
 import java.util.Map;
@@ -36,9 +38,9 @@
    * @param  module either a {@code map} of bindings, or an instance of a class
    *     that declares one or more {@code @Provides} methods.
    */
-  static Map<Key<?>, Binding<?>> moduleToMap(Object module) {
+  static Map<String, Binding<?>> moduleToMap(Object module) {
     if (module instanceof Map) {
-      return (Map<Key<?>, Binding<?>>) module;
+      return (Map<String, Binding<?>>) module;
     }
     return extractBindings(module);
   }
@@ -48,8 +50,8 @@
    * returned bindings are not attached to a particular injector and cannot be
    * used to inject values.
    */
-  private static Map<Key<?>, Binding<?>> extractBindings(Object module) {
-    Map<Key<?>, Binding<?>> result = new HashMap<Key<?>, Binding<?>>();
+  private static Map<String, Binding<?>> extractBindings(Object module) {
+    Map<String, Binding<?>> result = new HashMap<String, Binding<?>>();
     for (Class<?> c = module.getClass(); c != Object.class; c = c.getSuperclass()) {
       for (Method method : c.getDeclaredMethods()) {
         if (method.getAnnotation(Provides.class) == null) {
@@ -66,7 +68,7 @@
   }
 
   private static <T> Binding<T> methodToBinding(Object module, Method method) {
-    Key<T> key = Key.get(method.getGenericReturnType(), method.getAnnotations(), method);
+    String key = Keys.get(method.getGenericReturnType(), method.getAnnotations(), method);
     return new ProviderMethodBinding<T>(method, key, module);
   }
 
@@ -76,7 +78,7 @@
    * modules, the binding from {@code overrides} is retained.
    */
   public static Object override(Object base, Object overrides) {
-    Map<Key<?>, Binding<?>> result = new HashMap<Key<?>, Binding<?>>();
+    Map<String, Binding<?>> result = new HashMap<String, Binding<?>>();
     result.putAll(moduleToMap(base));
     result.putAll(moduleToMap(overrides));
     return result;
@@ -86,10 +88,10 @@
    * Returns a module containing all bindings in {@code modules}.
    */
   public static Object combine(Object... modules) {
-    Map<Key<?>, Binding<?>> result = new HashMap<Key<?>, Binding<?>>();
+    Map<String, Binding<?>> result = new HashMap<String, Binding<?>>();
     int expectedSize = 0;
     for (Object module : modules) {
-      Map<Key<?>, Binding<?>> moduleBindings = moduleToMap(module);
+      Map<String, Binding<?>> moduleBindings = moduleToMap(module);
       expectedSize += moduleBindings.size();
       result.putAll(moduleBindings);
     }
/Fim/
diff --git a/src/main/java/com/squareup/injector/ProviderMethodBinding.java b/src/main/java/com/squareup/injector/ProviderMethodBinding.java
index f91953b..33ee791 100644
--- a/src/main/java/com/squareup/injector/ProviderMethodBinding.java
+++ b/src/main/java/com/squareup/injector/ProviderMethodBinding.java
@@ -15,6 +15,9 @@
  */
 package com.squareup.injector;
 
+import com.squareup.injector.internal.Binding;
+import com.squareup.injector.internal.Keys;
+import com.squareup.injector.internal.Linker;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -31,20 +34,20 @@
   private final Method method;
   private final Object instance;
 
-  public ProviderMethodBinding(Method method, Key<T> key, Object instance) {
+  public ProviderMethodBinding(Method method, String key, Object instance) {
     super(method, key);
     this.method = method;
     this.instance = instance;
     method.setAccessible(true);
   }
 
-  @Override void attach(Linker linker) {
+  @Override public void attach(Linker linker) {
     Type[] types = method.getGenericParameterTypes();
     Annotation[][] annotations = method.getParameterAnnotations();
     parameters = new Binding[types.length];
     for (int i = 0; i < parameters.length; i++) {
       String name = method + " parameter " + i;
-      parameters[i] = linker.requestBinding(Key.get(types[i], annotations[i], name), method);
+      parameters[i] = linker.requestBinding(Keys.get(types[i], annotations[i], name), method);
     }
   }
 
/Fim/
diff --git a/src/main/java/com/squareup/injector/Binding.java b/src/main/java/com/squareup/injector/internal/Binding.java
similarity index 79%
rename from src/main/java/com/squareup/injector/Binding.java
rename to src/main/java/com/squareup/injector/internal/Binding.java
index 10dec08..710fdc3 100644
--- a/src/main/java/com/squareup/injector/Binding.java
+++ b/src/main/java/com/squareup/injector/internal/Binding.java
@@ -13,8 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector;
+package com.squareup.injector.internal;
 
+import com.squareup.injector.MembersInjector;
 import javax.inject.Provider;
 
 /**
@@ -22,11 +23,11 @@
  *
  * @author Jesse Wilson
  */
-abstract class Binding<T> implements Provider<T>, MembersInjector<T> {
+public abstract class Binding<T> implements Provider<T>, MembersInjector<T> {
   final Object requiredBy;
-  final Key<T> key;
+  public final String key;
 
-  protected Binding(Object requiredBy, Key<T> key) {
+  protected Binding(Object requiredBy, String key) {
     this.requiredBy = requiredBy;
     this.key = key;
   }
@@ -34,7 +35,7 @@
   /**
    * Links this binding to its dependencies.
    */
-  void attach(Linker linker) {
+  public void attach(Linker linker) {
   }
 
   @Override public void injectMembers(T t) {
/Fim/
diff --git a/src/main/java/com/squareup/injector/BuiltInBinding.java b/src/main/java/com/squareup/injector/internal/BuiltInBinding.java
similarity index 72%
rename from src/main/java/com/squareup/injector/BuiltInBinding.java
rename to src/main/java/com/squareup/injector/internal/BuiltInBinding.java
index 0f1d5ef..b9e4b70 100644
--- a/src/main/java/com/squareup/injector/BuiltInBinding.java
+++ b/src/main/java/com/squareup/injector/internal/BuiltInBinding.java
@@ -13,10 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector;
-
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
+package com.squareup.injector.internal;
 
 /**
  * Injects a Provider or a MembersInjector.
@@ -24,15 +21,16 @@
  * @author Jesse Wilson
  */
 final class BuiltInBinding<T> extends Binding<T> {
+  private String delegateKey;
   private Binding<?> delegate;
 
-  public BuiltInBinding(Key<T> key, Object requiredBy) {
+  public BuiltInBinding(String key, Object requiredBy, String delegateKey) {
     super(requiredBy, key);
+    this.delegateKey = delegateKey;
   }
 
-  @Override void attach(Linker linker) {
-    Type providedType = ((ParameterizedType) key.type).getActualTypeArguments()[0];
-    delegate = linker.requestBinding(new Key<T>(providedType, key.annotation), requiredBy);
+  @Override public void attach(Linker linker) {
+    delegate = linker.requestBinding(delegateKey, requiredBy);
   }
 
   @Override public void injectMembers(T t) {
/Fim/
diff --git a/src/main/java/com/squareup/injector/ConstructorBinding.java b/src/main/java/com/squareup/injector/internal/ConstructorBinding.java
similarity index 84%
rename from src/main/java/com/squareup/injector/ConstructorBinding.java
rename to src/main/java/com/squareup/injector/internal/ConstructorBinding.java
index b631b28..41b7893 100644
--- a/src/main/java/com/squareup/injector/ConstructorBinding.java
+++ b/src/main/java/com/squareup/injector/internal/ConstructorBinding.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector;
+package com.squareup.injector.internal;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
@@ -36,18 +36,19 @@
   private Binding<?>[] parameters;
   private Binding<?>[] fieldBindings;
 
-  private ConstructorBinding(Class<?> type, Key<T> key, Constructor<T> constructor, Field[] fields) {
+  private ConstructorBinding(Class<?> type, String key,
+      Constructor<T> constructor, Field[] fields) {
     super(type, key);
     this.constructor = constructor;
     this.fields = fields;
   }
 
-  @Override void attach(Linker linker) {
+  @Override public void attach(Linker linker) {
     // Field bindings.
     fieldBindings = new Binding<?>[fields.length];
     for (int i = 0; i < fields.length; i++) {
       Field field = fields[i];
-      Key<Object> fieldKey = Key.get(field.getGenericType(), field.getAnnotations(), field);
+      String fieldKey = Keys.get(field.getGenericType(), field.getAnnotations(), field);
       fieldBindings[i] = linker.requestBinding(fieldKey, field);
     }
 
@@ -57,7 +58,7 @@
     parameters = new Binding[types.length];
     for (int i = 0; i < parameters.length; i++) {
       String name = constructor + " parameter " + i;
-      parameters[i] = linker.requestBinding(Key.get(types[i], annotations[i], name), constructor);
+      parameters[i] = linker.requestBinding(Keys.get(types[i], annotations[i], name), constructor);
     }
   }
 
@@ -94,14 +95,7 @@
     return constructor.getDeclaringClass().isAnnotationPresent(Singleton.class);
   }
 
-  public static <T> Binding<T> create(Key<T> key) {
-    if (!(key.type instanceof Class) || key.annotation != null) {
-      throw new IllegalArgumentException("No binding for " + key);
-    }
-
-    @SuppressWarnings("unchecked") // The key type implies the class type.
-    Class<T> type = (Class<T>) key.type;
-
+  public static <T> Binding<T> create(Class<T> type) {
     /*
      * Lookup the injectable fields and their corresponding keys.
      */
@@ -142,7 +136,7 @@
       }
     }
 
-    return new ConstructorBinding<T>(type, key, injectedConstructor,
+    return new ConstructorBinding<T>(type, Keys.get(type, null), injectedConstructor,
         injectedFields.toArray(new Field[injectedFields.size()]));
   }
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/InternalInjector.java b/src/main/java/com/squareup/injector/internal/InternalInjector.java
new file mode 100644
index 0000000..9e93ce1
--- /dev/null
+++ b/src/main/java/com/squareup/injector/internal/InternalInjector.java
@@ -0,0 +1,92 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Implementation of the injector, with internal APIs for use by the reflective
+ * and code gen implementation.
+ *
+ * @author Jesse Wilson
+ */
+public final class InternalInjector {
+  private static final Object UNINITIALIZED = new Object();
+
+  /** All errors encountered during injection. */
+  private final List<String> errors = new ArrayList<String>();
+
+  /** All of the injector's bindings. */
+  private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
+
+  public Object inject(String key) {
+    Linker linker = new Linker(this);
+    linker.requestBinding(key, "root injection"); // Seed this requirement early.
+    linker.link(bindings.values());
+
+    if (!errors.isEmpty()) {
+      StringBuilder message = new StringBuilder();
+      message.append("Errors creating injector:");
+      for (String error : errors) {
+        message.append("\n  ").append(error);
+      }
+      throw new IllegalArgumentException(message.toString());
+    }
+
+    Binding<?> root = linker.requestBinding(key, "root injection");
+    return root.get(); // Linker.link() guarantees that this will be non-null.
+  }
+
+  Binding<?> getBinding(String key) {
+    return bindings.get(key);
+  }
+
+  public <T> void putBinding(final Binding<T> binding) {
+    Binding<T> toInsert = binding;
+    if (binding.isSingleton()) {
+      toInsert = new Binding<T>(binding.requiredBy, binding.key) {
+        private Object onlyInstance = UNINITIALIZED;
+        @Override public void attach(Linker linker) {
+          binding.attach(linker);
+        }
+        @Override public void injectMembers(T t) {
+          binding.injectMembers(t);
+        }
+        @SuppressWarnings("unchecked") // 'onlyInstance is either UNINITIALIZED' or a 'T'.
+        @Override public T get() {
+          if (onlyInstance == UNINITIALIZED) {
+            onlyInstance = binding.get();
+          }
+          return (T) onlyInstance;
+        }
+        @Override public boolean isSingleton() {
+          return binding.isSingleton();
+        }
+      };
+    }
+
+    if (bindings.put(toInsert.key, toInsert) != null) {
+      throw new IllegalArgumentException("Duplicate binding: " + toInsert.key);
+    }
+  }
+
+  void addError(String message) {
+    errors.add(message);
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Keys.java b/src/main/java/com/squareup/injector/internal/Keys.java
new file mode 100644
index 0000000..4b6bbb6
--- /dev/null
+++ b/src/main/java/com/squareup/injector/internal/Keys.java
@@ -0,0 +1,198 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import com.squareup.injector.MembersInjector;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.GenericArrayType;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+/**
+ * Formats strings that identify the value to be injected.
+ *
+ * <h3>Implementation Note</h3>
+ * This currently formats keys by concatenating the annotation name, a slash
+ * "/", and the type name. Parameterized types are formatted with ", " between
+ * type parameters. The exact key format may change in a future release.
+ *
+ * @author Jesse Wilson
+ */
+public final class Keys {
+  private static final String PROVIDER_PREFIX = Provider.class.getName() + "<";
+  private static final String MEMBERS_INJECTOR_PREFIX = MembersInjector.class.getName() + "<";
+  private static final LruCache<Class<? extends Annotation>, Boolean> IS_QUALIFIER_ANNOTATION
+      = new LruCache<Class<? extends Annotation>, Boolean>(Integer.MAX_VALUE) {
+    @Override protected Boolean create(Class<? extends Annotation> annotationType) {
+      return annotationType.isAnnotationPresent(Qualifier.class);
+    }
+  };
+
+  Keys() {
+  }
+
+  /**
+   * Returns a key for {@code type} with no annotation.
+   */
+  public static String get(Type type) {
+    return get(type, null);
+  }
+
+  /**
+   * Returns a key for {@code type} annotated by {@code annotation}.
+   */
+  public static String get(Type type, Annotation annotation) {
+    type = boxIfPrimitive(type);
+    if (annotation == null
+        && type instanceof Class
+        && !((Class<?>) type).isArray()) {
+      return ((Class<?>) type).getName();
+    }
+
+    StringBuilder result = new StringBuilder();
+    if (annotation != null) {
+      result.append(annotation).append("/");
+    }
+    typeToString(type, result);
+    return result.toString();
+  }
+
+  /**
+   * Returns a key for {@code type} annotated with {@code annotations},
+   * reporting failures against {@code subject}.
+   *
+   * @param annotations the annotations on a single method, field or parameter.
+   *     This array may contain at most one qualifier annotation.
+   */
+  public static String get(Type type, Annotation[] annotations, Object subject) {
+    Annotation bindingAnnotation = null;
+    for (Annotation a : annotations) {
+      if (!IS_QUALIFIER_ANNOTATION.get(a.annotationType())) {
+        continue;
+      }
+      if (bindingAnnotation != null) {
+        throw new IllegalArgumentException("Too many binding annotations on " + subject);
+      }
+      bindingAnnotation = a;
+    }
+    return get(type, bindingAnnotation);
+  }
+
+  private static void typeToString(Type type, StringBuilder result) {
+    if (type instanceof Class) {
+      Class<?> c = (Class<?>) type;
+      if (c.isArray()) {
+        result.append(c.getComponentType().getName());
+        result.append("[]");
+      } else if (c.isPrimitive()) {
+        // TODO: support this?
+        throw new UnsupportedOperationException("Uninjectable type " + type);
+      } else {
+        result.append(c.getName());
+      }
+    } else if (type instanceof ParameterizedType) {
+      ParameterizedType parameterizedType = (ParameterizedType) type;
+      typeToString(parameterizedType.getRawType(), result);
+      Type[] arguments = parameterizedType.getActualTypeArguments();
+      result.append("<");
+      for (int i = 0; i < arguments.length; i++) {
+        if (i != 0) {
+          result.append(", ");
+        }
+        typeToString(arguments[i], result);
+      }
+      result.append(">");
+    } else if (type instanceof GenericArrayType) {
+      GenericArrayType genericArrayType = (GenericArrayType) type;
+      result.append(((Class<?>) genericArrayType.getGenericComponentType()).getName());
+      result.append("[]");
+    } else {
+      throw new UnsupportedOperationException("Uninjectable type " + type);
+    }
+  }
+
+  /**
+   * Returns a key for the type provided by, or injected by this key. For
+   * example, if this is a key for a {@code Provider<Foo>}, this returns the
+   * key for {@code Foo}. This retains annotations and supports both Provider
+   * keys and MembersInjector keys.
+   */
+  public static String getDelegateKey(String key) {
+    int start = 0;
+    if (key.startsWith("@")) {
+      start = key.lastIndexOf('/') + 1;
+    }
+
+    String wrapperPrefix;
+    if (key.regionMatches(start, PROVIDER_PREFIX, 0, PROVIDER_PREFIX.length())) {
+      wrapperPrefix = PROVIDER_PREFIX;
+    } else if (key.regionMatches(start, MEMBERS_INJECTOR_PREFIX, 0, MEMBERS_INJECTOR_PREFIX.length())) {
+      wrapperPrefix = MEMBERS_INJECTOR_PREFIX;
+    } else {
+      return null;
+    }
+    return key.substring(0, start)
+        + key.substring(start + wrapperPrefix.length(), key.length() - 1);
+  }
+
+  /**
+   * Returns true if {@code key} has a qualifier annotation.
+   */
+  public static boolean isAnnotated(String key) {
+    return key.startsWith("@");
+  }
+
+  /**
+   * Returns the class name for {@code key}, if {@code key} was created with a
+   * class instance. Returns null if {@code key} represents a parameterized type
+   * or an array type.
+   */
+  public static String getClassName(String key) {
+    int start = 0;
+    if (key.startsWith("@")) {
+      start = key.lastIndexOf('/') + 1;
+    }
+    return (key.indexOf('<', start) == -1 && key.indexOf('[') == -1)
+        ? key.substring(start)
+        : null;
+  }
+
+  private static Type boxIfPrimitive(Type type) {
+    if (type == byte.class) {
+      return Byte.class;
+    } if (type == short.class) {
+      return Short.class;
+    } if (type == int.class) {
+      return Integer.class;
+    } else if (type == long.class) {
+      return Long.class;
+    } else if (type == char.class) {
+      return Character.class;
+    } else if (type == boolean.class) {
+      return Boolean.class;
+    } else if (type == float.class) {
+      return Float.class;
+    } else if (type == double.class) {
+      return Double.class;
+    } else if (type == void.class) {
+      return Void.class;
+    } else {
+      return type;
+    }
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/Linker.java b/src/main/java/com/squareup/injector/internal/Linker.java
similarity index 61%
rename from src/main/java/com/squareup/injector/Linker.java
rename to src/main/java/com/squareup/injector/internal/Linker.java
index 26e5a85..0bb3c8d 100644
--- a/src/main/java/com/squareup/injector/Linker.java
+++ b/src/main/java/com/squareup/injector/internal/Linker.java
@@ -13,22 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector;
+package com.squareup.injector.internal;
 
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
 import java.util.Collection;
 import java.util.LinkedList;
 import java.util.Queue;
-import javax.inject.Provider;
 
 /**
  * Links bindings to their dependencies.
  *
  * @author Jesse Wilson
  */
-final class Linker {
-  private final Injector injector;
+public final class Linker {
+  private final InternalInjector injector;
 
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
   private final Queue<Binding<?>> unattachedBindings = new LinkedList<Binding<?>>();
@@ -36,7 +33,7 @@
   /** True unless calls to requestBinding() were unable to satisfy the binding. */
   private boolean currentAttachSuccess = true;
 
-  public Linker(Injector injector) {
+  public Linker(InternalInjector injector) {
     this.injector = injector;
   }
 
@@ -51,7 +48,18 @@
     Binding binding;
     while ((binding = unattachedBindings.poll()) != null) {
       if (binding instanceof DeferredBinding) {
-        promoteDeferredBinding((DeferredBinding<?>) binding);
+        if (injector.getBinding(binding.key) != null) {
+          continue; // A binding for this key has already been promoted.
+        }
+        try {
+          Binding<?> jitBinding = createJitBinding((DeferredBinding<?>) binding);
+          // Enqueue the JIT binding so its own dependencies can be linked.
+          unattachedBindings.add(jitBinding);
+          injector.putBinding(jitBinding);
+        } catch (Exception e) {
+          injector.addError(e.getMessage() + " required by " + binding.requiredBy);
+          injector.putBinding(new UnresolvedBinding<Object>(binding.requiredBy, binding.key));
+        }
       } else {
         attachBinding(binding);
       }
@@ -68,34 +76,20 @@
    *   <li>Injections of other types will use the injectable constructors of
    *       those classes.
    * </ul>
-   * Once the just-in-time binding has been created, it is enqueued to be
-   * attached until its own dependencies have been satisfied.
    */
-  private <T> void promoteDeferredBinding(DeferredBinding<T> deferred) {
-    if (injector.getBinding(deferred.key) != null) {
-      return; // A binding for this key has already been promoted.
+  private Binding<?> createJitBinding(DeferredBinding<?> deferred) throws ClassNotFoundException {
+    String delegateKey = Keys.getDelegateKey(deferred.key);
+    if (delegateKey != null) {
+      return new BuiltInBinding<Object>(deferred.key, deferred.requiredBy, delegateKey);
     }
 
-    try {
-      Binding<T> promoted;
-      if (deferred.key.type instanceof ParameterizedType) {
-        Type rawType = ((ParameterizedType) deferred.key.type).getRawType();
-        if (rawType == Provider.class || rawType == MembersInjector.class) {
-          // Handle injections like Provider<Foo> and MembersInjector<Foo> by delegating.
-          promoted = new BuiltInBinding<T>(deferred.key, deferred.requiredBy);
-        } else {
-          throw new IllegalArgumentException("No binding for " + deferred.key);
-        }
-      } else {
-        // Handle all other injections with constructor bindings.
-        promoted = ConstructorBinding.create(deferred.key);
-      }
-      unattachedBindings.add(promoted);
-      injector.putBinding(promoted);
-    } catch (Exception e) {
-      injector.addError(e.getMessage() + " required by " + deferred.requiredBy);
-      injector.putBinding(new UnresolvedBinding<T>(deferred.requiredBy, deferred.key));
+    String className = Keys.getClassName(deferred.key);
+    if (className != null && !Keys.isAnnotated(deferred.key)) {
+      // Handle all other injections with constructor bindings.
+      return ConstructorBinding.create(Class.forName(className));
     }
+
+    throw new IllegalArgumentException("No binding for " + deferred.key);
   }
 
   /**
@@ -116,24 +110,24 @@
    * null. The injector will create that binding later and reattach the
    * caller's binding.
    */
-  public <T> Binding<T> requestBinding(final Key<T> key, final Object requiredBy) {
-    Binding<T> binding = injector.getBinding(key);
+  public Binding<?> requestBinding(String key, final Object requiredBy) {
+    Binding<?> binding = injector.getBinding(key);
     if (binding == null) {
       // We can't satisfy this binding. Make sure it'll work next time!
-      unattachedBindings.add(new DeferredBinding<T>(requiredBy, key));
+      unattachedBindings.add(new DeferredBinding<Object>(requiredBy, key));
       currentAttachSuccess = false;
     }
     return binding;
   }
 
   private static class DeferredBinding<T> extends Binding<T> {
-    private DeferredBinding(Object requiredBy, Key<T> key) {
+    private DeferredBinding(Object requiredBy, String key) {
       super(requiredBy, key);
     }
   }
 
   private static class UnresolvedBinding<T> extends Binding<T> {
-    private UnresolvedBinding(Object definedBy, Key<T> key) {
+    private UnresolvedBinding(Object definedBy, String key) {
       super(definedBy, key);
     }
   }
/Fim/
diff --git a/src/main/java/com/squareup/injector/LruCache.java b/src/main/java/com/squareup/injector/internal/LruCache.java
similarity index 99%
rename from src/main/java/com/squareup/injector/LruCache.java
rename to src/main/java/com/squareup/injector/internal/LruCache.java
index 44480c9..35f93d8 100644
--- a/src/main/java/com/squareup/injector/LruCache.java
+++ b/src/main/java/com/squareup/injector/internal/LruCache.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.squareup.injector;
+package com.squareup.injector.internal;
 
 import java.util.LinkedHashMap;
 import java.util.Map;
/Fim/
diff --git a/src/test/java/com/squareup/injector/internal/KeysTest.java b/src/test/java/com/squareup/injector/internal/KeysTest.java
new file mode 100644
index 0000000..bed93cd
--- /dev/null
+++ b/src/test/java/com/squareup/injector/internal/KeysTest.java
@@ -0,0 +1,113 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import com.squareup.injector.MembersInjector;
+import java.lang.reflect.Field;
+import java.util.List;
+import java.util.Map;
+import javax.inject.Named;
+import javax.inject.Provider;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+/**
+ * @author Jesse Wilson
+ */
+public final class KeysTest {
+  int primitive;
+  @Test public void lonePrimitiveGetsBoxed() throws NoSuchFieldException {
+    assertThat(fieldKey("primitive"))
+        .isEqualTo("java.lang.Integer");
+  }
+
+  Map<String, List<Integer>> mapStringListInteger;
+  @Test public void parameterizedTypes() throws NoSuchFieldException {
+    assertThat(fieldKey("mapStringListInteger"))
+        .isEqualTo("java.util.Map<java.lang.String, java.util.List<java.lang.Integer>>");
+  }
+
+  Map<String, int[]> mapStringArrayInt;
+  @Test public void parameterizedTypeOfPrimitiveArray() throws NoSuchFieldException {
+    assertThat(fieldKey("mapStringArrayInt"))
+        .isEqualTo("java.util.Map<java.lang.String, int[]>");
+  }
+
+  @Named("foo") String annotatedType;
+  @Test public void annotatedType() throws NoSuchFieldException {
+    assertThat(fieldKey("annotatedType"))
+        .isEqualTo("@javax.inject.Named(value=foo)/java.lang.String");
+  }
+
+  String className;
+  @Test public void testGetClassName() throws NoSuchFieldException {
+    assertThat(Keys.getClassName(fieldKey("className")))
+        .isEqualTo("java.lang.String");
+  }
+
+  @Named("foo") String classNameWithAnnotation;
+  @Test public void testGetClassNameWithoutAnnotation() throws NoSuchFieldException {
+    assertThat(Keys.getClassName(fieldKey("classNameWithAnnotation")))
+        .isEqualTo("java.lang.String");
+  }
+
+  String[] classNameArray;
+  @Test public void testGetClassNameArray() throws NoSuchFieldException {
+    assertThat(Keys.getClassName(fieldKey("classNameArray"))).isNull();
+  }
+
+  List<String> classNameParameterized;
+  @Test public void testGetClassParameterized() throws NoSuchFieldException {
+    assertThat(Keys.getClassName(fieldKey("classNameParameterized"))).isNull();
+  }
+
+  @Named("foo") String annotated;
+  @Test public void testIsAnnotatedTrue() throws NoSuchFieldException {
+    assertThat(Keys.isAnnotated(fieldKey("annotated"))).isTrue();
+  }
+
+  String notAnnotated;
+  @Test public void testIsAnnotatedFalse() throws NoSuchFieldException {
+    assertThat(Keys.isAnnotated(fieldKey("notAnnotated"))).isFalse();
+  }
+
+  Provider<String> providerOfType;
+  String providedType;
+  @Test public void testGetDelegateKey() throws NoSuchFieldException {
+    assertThat(Keys.getDelegateKey(fieldKey("providerOfType")))
+        .isEqualTo(fieldKey("providedType"));
+  }
+
+  @Named("/@") Provider<String> providerOfTypeAnnotated;
+  @Named("/@") String providedTypeAnnotated;
+  @Test public void testGetDelegateKeyWithAnnotation() throws NoSuchFieldException {
+    assertThat(Keys.getDelegateKey(fieldKey("providerOfTypeAnnotated")))
+        .isEqualTo(fieldKey("providedTypeAnnotated"));
+  }
+
+  @Named("/@") MembersInjector<String> membersInjectorOfType;
+  @Named("/@") String injectedType;
+  @Test public void testGetDelegateKeyWithMembersInjector() throws NoSuchFieldException {
+    assertThat(Keys.getDelegateKey(fieldKey("membersInjectorOfType")))
+        .isEqualTo(fieldKey("injectedType"));
+  }
+
+  private String fieldKey(String fieldName) throws NoSuchFieldException {
+    Field field = KeysTest.class.getDeclaredField(fieldName);
+    return Keys.get(field.getGenericType(), field.getAnnotations(), field);
+  }
+}
/Fim/
diff --git a/pom.xml b/pom.xml
index 6d0c9b1..4af38b8 100644
--- a/pom.xml
+++ b/pom.xml
@@ -93,6 +93,7 @@
                 <configuration>
                     <source>${java.version}</source>
                     <target>${java.version}</target>
+                    <compilerArgument>-proc:none</compilerArgument>
                 </configuration>
             </plugin>
 
/Fim/
diff --git a/src/main/java/com/squareup/codegen/CodeGen.java b/src/main/java/com/squareup/codegen/CodeGen.java
index d6d1fef..b875612 100644
--- a/src/main/java/com/squareup/codegen/CodeGen.java
+++ b/src/main/java/com/squareup/codegen/CodeGen.java
@@ -24,7 +24,7 @@
  *
  * @author Jesse Wilson
  */
-public final class CodeGen {
+final class CodeGen {
   private CodeGen() {
   }
 
/Fim/
diff --git a/src/main/java/com/squareup/codegen/InjectProcessor.java b/src/main/java/com/squareup/codegen/InjectProcessor.java
new file mode 100644
index 0000000..988fdd1
--- /dev/null
+++ b/src/main/java/com/squareup/codegen/InjectProcessor.java
@@ -0,0 +1,180 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.codegen;
+
+import com.squareup.injector.internal.Binding;
+import com.squareup.injector.internal.Linker;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.annotation.processing.SupportedAnnotationTypes;
+import javax.annotation.processing.SupportedSourceVersion;
+import javax.inject.Inject;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic;
+import javax.tools.JavaFileObject;
+
+import static java.lang.reflect.Modifier.FINAL;
+import static java.lang.reflect.Modifier.PRIVATE;
+import static java.lang.reflect.Modifier.PUBLIC;
+
+/**
+ * Generates an implementation of {@link Binding} that binds an injectable
+ * class.
+ *
+ * @author Jesse Wilson
+ */
+@SupportedAnnotationTypes("javax.inject.Inject")
+@SupportedSourceVersion(SourceVersion.RELEASE_6)
+public final class InjectProcessor extends AbstractProcessor {
+  @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
+    try {
+      Map<TypeElement, InjectedClass> injectedClasses = getInjectedClasses(env);
+      for (Map.Entry<TypeElement, InjectedClass> entry : injectedClasses.entrySet()) {
+        InjectedClass injectedClass = entry.getValue();
+        writeInjectAdapter(entry.getKey(), injectedClass.constructor, injectedClass.fields);
+      }
+    } catch (IOException e) {
+      processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "Code gen failed: " + e);
+    }
+    return !types.isEmpty();
+  }
+
+  private Map<TypeElement, InjectedClass> getInjectedClasses(RoundEnvironment env) {
+    Map<TypeElement, InjectedClass> classes = new HashMap<TypeElement, InjectedClass>();
+    for (Element element : env.getElementsAnnotatedWith(Inject.class)) {
+      TypeElement declaringType = (TypeElement) element.getEnclosingElement();
+      InjectedClass injectedClass = classes.get(declaringType);
+      if (injectedClass == null) {
+        injectedClass = new InjectedClass();
+        classes.put(declaringType, injectedClass);
+      }
+      if (element.getKind() == ElementKind.FIELD) {
+        injectedClass.fields.add(element);
+      }
+      if (element.getKind() == ElementKind.CONSTRUCTOR) {
+        injectedClass.constructor = (ExecutableElement) element;
+      }
+    }
+    return classes;
+  }
+
+  /**
+   * Write a companion class for {@code type} that implements {@link
+   * com.squareup.injector.internal.ModuleAdapter} to expose its provider methods.
+   */
+  private void writeInjectAdapter(TypeElement type, ExecutableElement constructor,
+      List<Element> fields) throws IOException {
+    String key = GeneratorKeys.get(type);
+    String typeName = type.getQualifiedName().toString();
+    String adapterName = typeName + "$InjectAdapter";
+    JavaFileObject sourceFile = processingEnv.getFiler()
+        .createSourceFile(adapterName, type);
+    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
+
+    writer.addPackage(CodeGen.getPackage(type).getQualifiedName().toString());
+    writer.addImport(Binding.class);
+    writer.addImport(Linker.class);
+
+    writer.beginType(adapterName, "class", FINAL,
+        CodeGen.parameterizedType(Binding.class, typeName));
+
+    List<? extends VariableElement> parameters = constructor.getParameters();
+    for (int p = 0; p < parameters.size(); p++) {
+      TypeMirror parameterType = parameters.get(p).asType();
+      writer.field(CodeGen.parameterizedType(Binding.class, parameterType.toString()),
+          "c" + p, PRIVATE);
+    }
+    for (int f = 0; f < fields.size(); f++) {
+      TypeMirror fieldType = fields.get(f).asType();
+      writer.field(CodeGen.parameterizedType(Binding.class, fieldType.toString()),
+          "f" + f, PRIVATE);
+    }
+
+    writer.beginMethod(null, type.getSimpleName() + "$InjectAdapter", PUBLIC);
+    writer.statement("super(%s.class, %s)", typeName, JavaWriter.stringLiteral(key));
+    writer.endMethod();
+
+    writer.annotation(Override.class);
+    writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
+    for (int p = 0; p < constructor.getParameters().size(); p++) {
+      TypeMirror parameterType = constructor.getParameters().get(p).asType();
+      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
+          "c" + p,
+          CodeGen.parameterizedType(Binding.class, parameterType.toString()),
+          JavaWriter.stringLiteral(GeneratorKeys.get(constructor.getParameters().get(p))),
+          typeName);
+    }
+    for (int p = 0; p < fields.size(); p++) {
+      TypeMirror parameterType = fields.get(p).asType();
+      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
+          "f" + p,
+          CodeGen.parameterizedType(Binding.class, parameterType.toString()),
+          JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) fields.get(p))),
+          typeName);
+    }
+    writer.endMethod();
+
+    writer.annotation(Override.class);
+    writer.beginMethod(typeName, "get", PUBLIC);
+    StringBuilder newInstance = new StringBuilder();
+    newInstance.append(typeName).append(" result = new ").append(typeName).append('(');
+    for (int p = 0; p < constructor.getParameters().size(); p++) {
+      if (p != 0) {
+        newInstance.append(", ");
+      }
+      newInstance.append("c").append(p).append(".get()");
+    }
+    newInstance.append(')');
+    writer.statement(newInstance.toString());
+    writer.statement("injectMembers(result)");
+    writer.statement("return result");
+    writer.endMethod();
+
+    writer.annotation(Override.class);
+    writer.beginMethod("void", "injectMembers", PUBLIC, typeName, "object");
+    for (int f = 0; f < fields.size(); f++) {
+      writer.statement("object.%s = %s.get()",
+          fields.get(f).getSimpleName().toString(),
+          "f" + f);
+    }
+    writer.endMethod();
+
+    writer.annotation(Override.class);
+    writer.beginMethod(boolean.class.getName(), "isSingleton", PUBLIC);
+    writer.statement("return true");
+    writer.endMethod();
+
+    writer.endType();
+    writer.close();
+  }
+
+  static class InjectedClass {
+    ExecutableElement constructor;
+    List<Element> fields = new ArrayList<Element>();
+  }
+}
/Fim/
diff --git a/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/src/main/resources/META-INF/services/javax.annotation.processing.Processor
index 60b652d..a453d47 100644
--- a/src/main/resources/META-INF/services/javax.annotation.processing.Processor
+++ b/src/main/resources/META-INF/services/javax.annotation.processing.Processor
@@ -1 +1,2 @@
+com.squareup.codegen.InjectProcessor
 com.squareup.codegen.ProvidesProcessor
/Fim/
/Fim/
diff --git a/src/main/java/com/squareup/codegen/CodeGen.java b/src/main/java/com/squareup/codegen/CodeGen.java
index 42688ed..0d6bad5 100644
--- a/src/main/java/com/squareup/codegen/CodeGen.java
+++ b/src/main/java/com/squareup/codegen/CodeGen.java
@@ -20,9 +20,12 @@
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
+import javax.lang.model.util.SimpleTypeVisitor6;
 
 /**
  * Support for annotation processors.
@@ -74,26 +77,39 @@
     return result.toString();
   }
 
-  public static void typeToString(TypeMirror type, StringBuilder result) {
-    if (type instanceof DeclaredType) {
-      DeclaredType declaredType = (DeclaredType) type;
-      result.append(((TypeElement) declaredType.asElement()).getQualifiedName().toString());
-      List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
-      if (!typeArguments.isEmpty()) {
-        result.append("<");
-        for (int i = 0; i < typeArguments.size(); i++) {
-          if (i != 0) {
-            result.append(", ");
+  public static void typeToString(final TypeMirror type, final StringBuilder result) {
+    type.accept(new SimpleTypeVisitor6<Void, Void>() {
+      @Override public Void visitDeclared(DeclaredType declaredType, Void v) {
+        result.append(((TypeElement) declaredType.asElement()).getQualifiedName().toString());
+        List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+        if (!typeArguments.isEmpty()) {
+          result.append("<");
+          for (int i = 0; i < typeArguments.size(); i++) {
+            if (i != 0) {
+              result.append(", ");
+            }
+            typeToString(typeArguments.get(i), result);
           }
-          typeToString(typeArguments.get(i), result);
+          result.append(">");
         }
-        result.append(">");
+        return null;
       }
-    } else if (type instanceof PrimitiveType) {
-      result.append(box((PrimitiveType) type).getName());
-    } else {
-      throw new UnsupportedOperationException("Uninjectable type " + type);
-    }
+      @Override public Void visitPrimitive(PrimitiveType primitiveType, Void aVoid) {
+        result.append(box((PrimitiveType) type).getName());
+        return null;
+      }
+      @Override public Void visitArray(ArrayType arrayType, Void aVoid) {
+        typeToString(arrayType.getComponentType(), result);
+        result.append("[]");
+        return null;
+      }
+      @Override public Void visitTypeVariable(TypeVariable typeVariable, Void v) {
+        return null;
+      }
+      @Override protected Void defaultAction(TypeMirror typeMirror, Void aVoid) {
+        throw new UnsupportedOperationException("Unexpected type " + typeMirror);
+      }
+    }, null);
   }
 
   private static Class<?> box(PrimitiveType primitiveType) {
/Fim/
diff --git a/src/main/java/com/squareup/injector/ObjectGraph.java b/src/main/java/com/squareup/injector/ObjectGraph.java
index cb39367..98acbc4 100644
--- a/src/main/java/com/squareup/injector/ObjectGraph.java
+++ b/src/main/java/com/squareup/injector/ObjectGraph.java
@@ -18,6 +18,7 @@
 import com.squareup.injector.internal.Binding;
 import com.squareup.injector.internal.Keys;
 import com.squareup.injector.internal.Linker;
+import com.squareup.injector.internal.ProblemDetector;
 import com.squareup.injector.internal.StaticInjection;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -128,6 +129,10 @@
     return new ObjectGraph(staticInjections, entryPointsMap);
   }
 
+  public void detectProblems() {
+    new ProblemDetector().detectProblems(bindings.values());
+  }
+
   /**
    * Returns a map from class to entry point.
    *
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Binding.java b/src/main/java/com/squareup/injector/internal/Binding.java
index 70d941b..fd766c8 100644
--- a/src/main/java/com/squareup/injector/internal/Binding.java
+++ b/src/main/java/com/squareup/injector/internal/Binding.java
@@ -51,4 +51,8 @@
   @Override public T get() {
     throw new UnsupportedOperationException();
   }
+
+  public Binding<?>[] getDependencies() {
+    throw new UnsupportedOperationException();
+  }
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/BuiltInBinding.java b/src/main/java/com/squareup/injector/internal/BuiltInBinding.java
index 118e7c9..63be6cd 100644
--- a/src/main/java/com/squareup/injector/internal/BuiltInBinding.java
+++ b/src/main/java/com/squareup/injector/internal/BuiltInBinding.java
@@ -41,4 +41,8 @@
   @Override public T get() {
     return (T) delegate;
   }
+
+  public Binding<?> getDelegate() {
+    return delegate;
+  }
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ConstructorBinding.java b/src/main/java/com/squareup/injector/internal/ConstructorBinding.java
index f2a70ad..c186e30 100644
--- a/src/main/java/com/squareup/injector/internal/ConstructorBinding.java
+++ b/src/main/java/com/squareup/injector/internal/ConstructorBinding.java
@@ -99,6 +99,20 @@
     }
   }
 
+  @Override public Binding<?>[] getDependencies() {
+    if (parameters == null) {
+      return fieldBindings;
+    }
+    Binding<?>[] result = new Binding<?>[parameters.length + fieldBindings.length];
+    System.arraycopy(parameters, 0, result, 0, parameters.length);
+    System.arraycopy(fieldBindings, 0, result, parameters.length, fieldBindings.length);
+    return result;
+  }
+
+  @Override public String toString() {
+    return key;
+  }
+
   public static <T> Binding<T> create(Class<T> type) {
     /*
      * Lookup the injectable fields and their corresponding keys.
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Linker.java b/src/main/java/com/squareup/injector/internal/Linker.java
index b998903..67dc6a5 100644
--- a/src/main/java/com/squareup/injector/internal/Linker.java
+++ b/src/main/java/com/squareup/injector/internal/Linker.java
@@ -172,6 +172,12 @@
           }
           return (T) onlyInstance;
         }
+        @Override public Binding<?>[] getDependencies() {
+          return binding.getDependencies();
+        }
+        @Override public String toString() {
+          return binding.toString();
+        }
       };
     }
 
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ProblemDetector.java b/src/main/java/com/squareup/injector/internal/ProblemDetector.java
new file mode 100644
index 0000000..a36dea7
--- /dev/null
+++ b/src/main/java/com/squareup/injector/internal/ProblemDetector.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+import java.util.Set;
+
+/**
+ * Detects problems like cyclic dependencies.
+ */
+public final class ProblemDetector {
+  // TODO: perform 2-phase injection to avoid some circular dependency problems
+
+  Set<Binding<?>> done = new HashSet<Binding<?>>();
+  Queue<Binding<?>> roots = new LinkedList<Binding<?>>();
+  List<Binding<?>> path = new LinkedList<Binding<?>>();
+
+  public void detectProblems(Collection<Binding<?>> bindings) {
+    roots.addAll(bindings);
+
+    StringBuilder message = null;
+    Binding<?> root;
+    while ((root = roots.poll()) != null) {
+      if (done.add(root)) {
+        try {
+          detectCircularDependencies(root);
+        } catch (Exception e) {
+          if (message == null) {
+            message = new StringBuilder().append("Graph problems:");
+          }
+          message.append("\n  ").append(e.getMessage());
+        }
+      }
+    }
+
+    if (message != null) {
+      throw new RuntimeException(message.toString());
+    }
+  }
+
+  private void detectCircularDependencies(Binding<?> binding) {
+    int index = path.indexOf(binding);
+    if (index != -1) {
+      StringBuilder message = new StringBuilder()
+          .append("Dependency cycle:");
+      for (int i = index; i < path.size(); i++) {
+        message.append("\n    ").append(i - index).append(". ")
+            .append(path.get(i).key).append(" bound by ").append(path.get(i));
+      }
+      message.append("\n    ").append(0).append(". ").append(binding.key);
+      throw new RuntimeException(message.toString());
+    }
+
+    path.add(binding);
+    try {
+      for (Binding<?> dependency : binding.getDependencies()) {
+        if (dependency instanceof BuiltInBinding) {
+          roots.add(((BuiltInBinding<?>) dependency).getDelegate());
+        } else {
+          detectCircularDependencies(dependency);
+        }
+      }
+    } finally {
+      path.remove(path.size() - 1);
+    }
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java b/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
index 7d80337..865f833 100644
--- a/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
+++ b/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
@@ -61,6 +61,10 @@
     }
   }
 
+  @Override public Binding<?>[] getDependencies() {
+    return parameters;
+  }
+
   @Override public String toString() {
     return method.toString();
   }
/Fim/
diff --git a/src/test/java/com/squareup/injector/InjectionTest.java b/src/test/java/com/squareup/injector/InjectionTest.java
index ef9945f..1e1ddf1 100644
--- a/src/test/java/com/squareup/injector/InjectionTest.java
+++ b/src/test/java/com/squareup/injector/InjectionTest.java
@@ -385,14 +385,14 @@
     }
 
     @Module(entryPoints = TestEntryPoint.class)
-    class BaseModule {
+    class TestModule {
       @Provides Object unused() {
         throw new AssertionError();
       }
     }
 
     try {
-      ObjectGraph.get(new BaseModule());
+      ObjectGraph.get(new TestModule());
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -404,16 +404,20 @@
     }
 
     @Module(entryPoints = TestEntryPoint.class)
-    class BaseModule {
+    class TestModule {
       @Provides Object unused() {
         throw new AssertionError();
       }
     }
 
     try {
-      ObjectGraph.get(new BaseModule());
+      ObjectGraph.get(new TestModule());
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
+
+  // TODO: test injecting parameterized types
+  // TODO: test injecting wildcard types
+  // TODO: test constructor binding for a class that has a type parameter
 }
/Fim/
diff --git a/src/test/java/com/squareup/injector/ProblemDetectorTest.java b/src/test/java/com/squareup/injector/ProblemDetectorTest.java
new file mode 100644
index 0000000..def029e
--- /dev/null
+++ b/src/test/java/com/squareup/injector/ProblemDetectorTest.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import javax.inject.Inject;
+import org.junit.Test;
+
+import static org.junit.Assert.fail;
+
+public final class ProblemDetectorTest {
+  @Test public void circularDependenciesDetected() {
+    class TestEntryPoint {
+      @Inject Rock rock;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides Object unused() {
+        throw new AssertionError();
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    try {
+      graph.detectProblems();
+      fail();
+    } catch (RuntimeException expected) {
+    }
+  }
+
+  static class Rock {
+    @Inject Scissors scissors;
+  }
+
+  static class Scissors {
+    @Inject Paper paper;
+  }
+
+  static class Paper {
+    @Inject Rock rock;
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/codegen/CodeGen.java b/src/main/java/com/squareup/codegen/CodeGen.java
index 0d6bad5..4df4354 100644
--- a/src/main/java/com/squareup/codegen/CodeGen.java
+++ b/src/main/java/com/squareup/codegen/CodeGen.java
@@ -42,17 +42,28 @@
   }
 
   /**
-   * Returns a fully qualified class name to complement {@code type}. The
-   * returned class is in the same package as {@code type}. This supports nested
-   * classes by using a '$' instead of '.' for nesting:  "java.util.Map.Entry"
-   * becomes "java.util.Map$Entry".
+   * Returns the supertype, or {@code null} if the supertype is a platform
+   * class. This is intended for annotation processors that assume platform
+   * classes will never be annotated with application annotations.
    */
-  public static String adapterName(TypeElement typeName, String suffix) {
-    String packageName = CodeGen.getPackage(typeName).getQualifiedName().toString();
-    String qualifiedName = typeName.getQualifiedName().toString();
-    return packageName + '.'
-        + qualifiedName.substring(packageName.length() + 1).replace('.', '$')
-        + suffix;
+  public static TypeMirror getApplicationSupertype(TypeElement type) {
+    TypeMirror supertype = type.getSuperclass();
+    String supertypeName = supertype.toString();
+    if (supertypeName.startsWith("android.")
+        || supertypeName.startsWith("java.")
+        || supertypeName.startsWith("javax.")) {
+      return null;
+    } else {
+      return supertype;
+    }
+  }
+
+  /** Returns a fully qualified class name to complement {@code type}. */
+  public static String adapterName(TypeElement typeElement, String suffix) {
+    StringBuilder builder = new StringBuilder();
+    rawTypeToString(builder, typeElement, '$');
+    builder.append(suffix);
+    return builder.toString();
   }
 
   /** Returns a string like {@code java.util.List<java.lang.String>}. */
@@ -73,14 +84,25 @@
   /** Returns a string for {@code type}. Primitive types are always boxed. */
   public static String typeToString(TypeMirror type) {
     StringBuilder result = new StringBuilder();
-    typeToString(type, result);
+    typeToString(type, result, '.');
     return result.toString();
   }
 
-  public static void typeToString(final TypeMirror type, final StringBuilder result) {
+  /**
+   * Appends a string for {@code type} to {@code result}. Primitive types are
+   * always boxed.
+   *
+   * @param innerClassSeparator either '.' or '$', which will appear in a
+   *     class name like "java.lang.Map.Entry" or "java.lang.Map$Entry".
+   *     Use '.' for references to existing types in code. Use '$' to define new
+   *     class names and for strings that will be used by runtime reflection.
+   */
+  public static void typeToString(final TypeMirror type, final StringBuilder result,
+      final char innerClassSeparator) {
     type.accept(new SimpleTypeVisitor6<Void, Void>() {
       @Override public Void visitDeclared(DeclaredType declaredType, Void v) {
-        result.append(((TypeElement) declaredType.asElement()).getQualifiedName().toString());
+        TypeElement typeElement = (TypeElement) declaredType.asElement();
+        rawTypeToString(result, typeElement, innerClassSeparator);
         List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
         if (!typeArguments.isEmpty()) {
           result.append("<");
@@ -88,7 +110,7 @@
             if (i != 0) {
               result.append(", ");
             }
-            typeToString(typeArguments.get(i), result);
+            typeToString(typeArguments.get(i), result, innerClassSeparator);
           }
           result.append(">");
         }
@@ -99,7 +121,7 @@
         return null;
       }
       @Override public Void visitArray(ArrayType arrayType, Void aVoid) {
-        typeToString(arrayType.getComponentType(), result);
+        typeToString(arrayType.getComponentType(), result, innerClassSeparator);
         result.append("[]");
         return null;
       }
@@ -112,6 +134,16 @@
     }, null);
   }
 
+  private static void rawTypeToString(StringBuilder result, TypeElement type,
+      char innerClassSeparator) {
+    String packageName = getPackage(type).getQualifiedName().toString();
+    String qualifiedName = type.getQualifiedName().toString();
+    result.append(packageName);
+    result.append('.');
+    result.append(
+        qualifiedName.substring(packageName.length() + 1).replace('.', innerClassSeparator));
+  }
+
   private static Class<?> box(PrimitiveType primitiveType) {
     switch (primitiveType.getKind()) {
       case BYTE:
/Fim/
diff --git a/src/main/java/com/squareup/codegen/GeneratorKeys.java b/src/main/java/com/squareup/codegen/GeneratorKeys.java
index 01ae538..6f98c06 100644
--- a/src/main/java/com/squareup/codegen/GeneratorKeys.java
+++ b/src/main/java/com/squareup/codegen/GeneratorKeys.java
@@ -23,6 +23,7 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * Creates keys using javac's mirror APIs. Unlike {@code Keys}, this class uses
@@ -33,8 +34,17 @@
   }
 
   public static String get(TypeElement type) {
+    return get(type.asType());
+  }
+
+
+  public static String getMembersKey(TypeMirror type) {
+    return "members/" + get(type);
+  }
+
+  public static String get(TypeMirror type) {
     StringBuilder result = new StringBuilder();
-    CodeGen.typeToString(type.asType(), result);
+    CodeGen.typeToString(type, result, '$');
     return result.toString();
   }
 
@@ -44,7 +54,7 @@
     if (qualifier != null) {
       qualifierToString(qualifier, result);
     }
-    CodeGen.typeToString(method.getReturnType(), result);
+    CodeGen.typeToString(method.getReturnType(), result, '$');
     return result.toString();
   }
 
@@ -54,7 +64,7 @@
     if (qualifier != null) {
       qualifierToString(qualifier, result);
     }
-    CodeGen.typeToString(parameter.asType(), result);
+    CodeGen.typeToString(parameter.asType(), result, '$');
     return result.toString();
   }
 
/Fim/
diff --git a/src/main/java/com/squareup/codegen/InjectProcessor.java b/src/main/java/com/squareup/codegen/InjectProcessor.java
index 1a42c28..c9e2927 100644
--- a/src/main/java/com/squareup/codegen/InjectProcessor.java
+++ b/src/main/java/com/squareup/codegen/InjectProcessor.java
@@ -19,15 +19,15 @@
 import com.squareup.injector.internal.Linker;
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.HashMap;
+import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
 import javax.annotation.processing.SupportedSourceVersion;
 import javax.inject.Inject;
+import javax.inject.Singleton;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
@@ -44,69 +44,82 @@
 import static java.lang.reflect.Modifier.PUBLIC;
 
 /**
- * Generates an implementation of {@link Binding} that binds an injectable
- * class.
+ * Generates an implementation of {@link Binding} that injects the
+ * {@literal @}{@code Inject}-annotated members of a class.
  */
 @SupportedAnnotationTypes("javax.inject.Inject")
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class InjectProcessor extends AbstractProcessor {
   @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
     try {
-      // TODO: inject superclass fields
-      Map<TypeElement, InjectedClass> injectedClasses = getInjectedClasses(env);
-      for (Map.Entry<TypeElement, InjectedClass> entry : injectedClasses.entrySet()) {
-        InjectedClass injectedClass = entry.getValue();
-        writeInjectAdapter(entry.getKey(), injectedClass.constructor, injectedClass.fields);
+      for (InjectedClass injectedClass : getInjectedClasses(env)) {
+        writeInjectAdapter(injectedClass.type, injectedClass.constructor, injectedClass.fields);
       }
     } catch (IOException e) {
-      processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "Code gen failed: " + e);
+      error("Code gen failed: %s", e);
     }
     return true;
   }
 
-  private Map<TypeElement, InjectedClass> getInjectedClasses(RoundEnvironment env) {
-    Map<TypeElement, InjectedClass> classes = new HashMap<TypeElement, InjectedClass>();
+  private Set<InjectedClass> getInjectedClasses(RoundEnvironment env) {
+    // First gather the set of classes that have @Inject-annotated members.
+    Set<TypeElement> injectedTypes = new LinkedHashSet<TypeElement>();
     for (Element element : env.getElementsAnnotatedWith(Inject.class)) {
-      TypeElement declaringType = (TypeElement) element.getEnclosingElement();
-      InjectedClass injectedClass = classes.get(declaringType);
-      if (injectedClass == null) {
-        injectedClass = new InjectedClass();
-        classes.put(declaringType, injectedClass);
-      }
-      if (element.getKind() == ElementKind.FIELD) {
-        injectedClass.fields.add(element);
-      }
-      if (element.getKind() == ElementKind.CONSTRUCTOR) {
-        // TODO: explode if there are multiple @Inject-annotated constructors
-        injectedClass.constructor = (ExecutableElement) element;
-      }
+      injectedTypes.add((TypeElement) element.getEnclosingElement());
     }
 
-    // Find no-args constructors for non-abstract classes that don't have @Inject constructors.
-    for (Map.Entry<TypeElement, InjectedClass> entry : classes.entrySet()) {
-      TypeElement typeElement = entry.getKey();
-      InjectedClass injectedClass = entry.getValue();
-      if (typeElement.getModifiers().contains(Modifier.ABSTRACT)) {
-        if (injectedClass.constructor != null) {
-          processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "Abstract class "
-              + typeElement.getQualifiedName() + " must not have an @Injectable constructor.");
-          injectedClass.constructor = null;
-        }
+    // Next get the InjectedClass for each of those.
+    Set<InjectedClass> result = new LinkedHashSet<InjectedClass>();
+    for (TypeElement type : injectedTypes) {
+      result.add(getInjectedClass(type));
+    }
+
+    return result;
+  }
+
+  /**
+   * @param type a type with an @Inject-annotated member.
+   */
+  private InjectedClass getInjectedClass(TypeElement type) {
+    boolean isAbstract = type.getModifiers().contains(Modifier.ABSTRACT);
+    ExecutableElement constructor = null;
+    List<Element> fields = new ArrayList<Element>();
+    for (Element member : type.getEnclosedElements()) {
+      if (member.getAnnotation(Inject.class) == null) {
         continue;
       }
-      if (injectedClass.constructor == null) {
-        injectedClass.constructor = getNoArgsConstructor(typeElement);
+
+      switch (member.getKind()) {
+        case FIELD:
+          fields.add(member);
+          break;
+        case CONSTRUCTOR:
+          if (constructor != null) {
+            error("Too many injectable constructors on %s.", type.getQualifiedName());
+          } else if (isAbstract) {
+            error("Abstract class %s must not have an @Inject-annotated constructor.",
+                type.getQualifiedName());
+          }
+          constructor = (ExecutableElement) member;
+          break;
+        default:
+          error("Cannot inject %s", member);
+          break;
       }
     }
 
-    return classes;
+    if (constructor == null && !isAbstract) {
+      constructor = findNoArgsConstructor(type);
+    }
+
+    return new InjectedClass(type, constructor, fields);
   }
 
   /**
    * Returns the no args constructor for {@code typeElement}, or null if no such
    * constructor exists.
    */
-  private ExecutableElement getNoArgsConstructor(TypeElement typeElement) {
+  private ExecutableElement findNoArgsConstructor(TypeElement typeElement) {
     for (Element element : typeElement.getEnclosedElements()) {
       if (element.getKind() != ElementKind.CONSTRUCTOR) {
         continue;
@@ -119,6 +132,10 @@
     return null;
   }
 
+  private void error(String format, Object... args) {
+    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, String.format(format, args));
+  }
+
   /**
    * Write a companion class for {@code type} that extends {@link Binding}.
    *
@@ -127,8 +144,8 @@
    */
   private void writeInjectAdapter(TypeElement type, ExecutableElement constructor,
       List<Element> fields) throws IOException {
-    String key = GeneratorKeys.get(type);
     String typeName = type.getQualifiedName().toString();
+    TypeMirror supertype = CodeGen.getApplicationSupertype(type);
     String adapterName = CodeGen.adapterName(type, "$InjectAdapter");
     JavaFileObject sourceFile = processingEnv.getFiler()
         .createSourceFile(adapterName, type);
@@ -154,12 +171,19 @@
       writer.field(CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(fieldType)),
           fieldName(f), PRIVATE);
     }
+    if (supertype != null) {
+      writer.field(CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(supertype)),
+          "supertype", PRIVATE);
+    }
 
     writer.beginMethod(null, adapterName, PUBLIC);
-    boolean singleton = true; // TODO
-    boolean injectMembersOnly = constructor == null;
-    writer.statement("super(%s, %s, %s, %s.class)",
-        JavaWriter.stringLiteral(key), singleton, injectMembersOnly, typeName);
+    String key = (constructor != null)
+        ? JavaWriter.stringLiteral(GeneratorKeys.get(type))
+        : null;
+    String membersKey = JavaWriter.stringLiteral(GeneratorKeys.getMembersKey(type.asType()));
+    boolean singleton = type.getAnnotation(Singleton.class) != null;
+    writer.statement("super(%s, %s, %s /*singleton*/, %s.class)",
+        key, membersKey, singleton, typeName);
     writer.endMethod();
 
     writer.annotation(Override.class);
@@ -167,7 +191,7 @@
     if (constructor != null) {
       for (int p = 0; p < constructor.getParameters().size(); p++) {
         TypeMirror parameterType = constructor.getParameters().get(p).asType();
-        writer.statement("%s = (%s) linker.requestBinding(%s, %s.class, false)",
+        writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
             constructorParameterName(p),
             CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(parameterType)),
             JavaWriter.stringLiteral(GeneratorKeys.get(constructor.getParameters().get(p))),
@@ -176,12 +200,19 @@
     }
     for (int f = 0; f < fields.size(); f++) {
       TypeMirror fieldType = fields.get(f).asType();
-      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class, false)",
+      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
           fieldName(f),
           CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(fieldType)),
           JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) fields.get(f))),
           typeName);
     }
+    if (supertype != null) {
+      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
+          "supertype",
+          CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(supertype)),
+          JavaWriter.stringLiteral(GeneratorKeys.getMembersKey(supertype)),
+          typeName);
+    }
     writer.endMethod();
 
     writer.annotation(Override.class);
@@ -211,6 +242,9 @@
           fields.get(f).getSimpleName().toString(),
           fieldName(f));
     }
+    if (supertype != null) {
+      writer.statement("supertype.injectMembers(object)");
+    }
     writer.endMethod();
 
     writer.endType();
@@ -226,7 +260,14 @@
   }
 
   static class InjectedClass {
-    ExecutableElement constructor;
-    List<Element> fields = new ArrayList<Element>();
+    final TypeElement type;
+    final ExecutableElement constructor;
+    final List<Element> fields;
+
+    InjectedClass(TypeElement type, ExecutableElement constructor, List<Element> fields) {
+      this.type = type;
+      this.constructor = constructor;
+      this.fields = fields;
+    }
   }
 }
/Fim/
diff --git a/src/main/java/com/squareup/codegen/ProvidesProcessor.java b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
index d9e5ef4..c4e0e3d 100644
--- a/src/main/java/com/squareup/codegen/ProvidesProcessor.java
+++ b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
@@ -30,6 +30,7 @@
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
 import javax.annotation.processing.SupportedSourceVersion;
+import javax.inject.Singleton;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
@@ -50,13 +51,18 @@
  * Generates an implementation of {@link ModuleAdapter} that includes a binding
  * for each {@code @Provides} method of a target class.
  */
-@SupportedAnnotationTypes("com.squareup.injector.Provides")
+@SupportedAnnotationTypes(
+    value = {
+        "com.squareup.injector.Provides",
+        "com.google.inject.Provides"
+    }
+)
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class ProvidesProcessor extends AbstractProcessor {
   private static final String BINDINGS_MAP = CodeGen.parameterizedType(
       Map.class, String.class.getName(), Binding.class.getName() + "<?>");
-  private static final String BINDINGS_HASH_MAP = CodeGen.parameterizedType(
-      HashMap.class, String.class.getName(), Binding.class.getName() + "<?>");
+
+  // TODO: include @Provides methods from the superclass
 
   @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
     try {
@@ -141,14 +147,12 @@
         CodeGen.parameterizedType(ModuleAdapter.class, typeName));
 
     writer.annotation(Override.class);
-    writer.beginMethod(BINDINGS_MAP, "getBindings", PUBLIC, typeName, "module");
-    writer.statement("%s result = new %s()", BINDINGS_MAP, BINDINGS_HASH_MAP);
+    writer.beginMethod("void", "getBindings", PUBLIC, typeName, "module", BINDINGS_MAP, "map");
     for (ExecutableElement providerMethod : providerMethods) {
       String key = GeneratorKeys.get(providerMethod);
-      writer.statement("result.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
+      writer.statement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
           providerMethod.getSimpleName().toString() + "Binding");
     }
-    writer.statement("return result");
     writer.endMethod();
 
     for (ExecutableElement providerMethod : providerMethods) {
@@ -162,7 +166,6 @@
   private void writeBindingClass(JavaWriter writer, ExecutableElement providerMethod)
       throws IOException {
     String methodName = providerMethod.getSimpleName().toString();
-    String key = GeneratorKeys.get(providerMethod);
     String moduleType = CodeGen.typeToString(providerMethod.getEnclosingElement().asType());
     String className = providerMethod.getSimpleName() + "Binding";
     String returnType = CodeGen.typeToString(providerMethod.getReturnType());
@@ -178,10 +181,11 @@
     }
 
     writer.beginMethod(null, className, PUBLIC, moduleType, "module");
-    boolean singleton = true; // TODO
-    boolean injectMembersOnly = false;
-    writer.statement("super(%s, %s, %s, %s.class)", JavaWriter.stringLiteral(key), singleton,
-        injectMembersOnly, moduleType);
+    boolean singleton = providerMethod.getAnnotation(Singleton.class) != null;
+    String key = JavaWriter.stringLiteral(GeneratorKeys.get(providerMethod));
+    String membersKey = null;
+    writer.statement("super(%s, %s, %s /*singleton*/, %s.class)",
+        key, membersKey, singleton, moduleType);
     writer.statement("this.module = module");
     writer.endMethod();
 
@@ -190,7 +194,7 @@
     for (int p = 0; p < parameters.size(); p++) {
       VariableElement parameter = parameters.get(p);
       String parameterKey = GeneratorKeys.get(parameter);
-      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class, false)",
+      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
           parameterName(p),
           CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(parameter.asType())),
           JavaWriter.stringLiteral(parameterKey), moduleType);
/Fim/
diff --git a/src/main/java/com/squareup/injector/ObjectGraph.java b/src/main/java/com/squareup/injector/ObjectGraph.java
index 7a889f2..c652580 100644
--- a/src/main/java/com/squareup/injector/ObjectGraph.java
+++ b/src/main/java/com/squareup/injector/ObjectGraph.java
@@ -137,7 +137,7 @@
 
   private void linkEntryPoints() {
     for (Map.Entry<Class<?>, Class<?>> entry : entryPoints.entrySet()) {
-      linker.requestBinding(Keys.get(entry.getKey()), entry.getValue(), true);
+      linker.requestBinding(Keys.getMembersKey(entry.getKey()), entry.getValue());
     }
   }
 
@@ -182,14 +182,14 @@
     Class<?> type = instance.getClass();
     Class<?> moduleClass = entryPoints.get(type);
     if (moduleClass == null) {
-      throw new IllegalArgumentException("No binding for " + type.getName() + ". "
-          + "You must explicitly add it as an entry point.");
+      throw new IllegalArgumentException("No entry point for " + type.getName() + ". "
+          + "You must explicitly add an entry point to one of your modules.");
     }
-    String key = Keys.get(type);
-    Binding<?> binding = linker.requestBinding(key, moduleClass, true);
+    String key = Keys.getMembersKey(type);
+    Binding<?> binding = linker.requestBinding(key, moduleClass);
     if (binding == null || !binding.linked) {
       linker.linkRequested();
-      binding = linker.requestBinding(key, moduleClass, true);
+      binding = linker.requestBinding(key, moduleClass);
     }
     ((Binding<Object>) binding).injectMembers(instance);
   }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ConstructorBinding.java b/src/main/java/com/squareup/injector/internal/AtInjectBinding.java
similarity index 80%
rename from src/main/java/com/squareup/injector/internal/ConstructorBinding.java
rename to src/main/java/com/squareup/injector/internal/AtInjectBinding.java
index 6733408..7300fda 100644
--- a/src/main/java/com/squareup/injector/internal/ConstructorBinding.java
+++ b/src/main/java/com/squareup/injector/internal/AtInjectBinding.java
@@ -27,21 +27,22 @@
 import javax.inject.Singleton;
 
 /**
- * A binding that uses the constructor of a concrete class.
+ * A binding that injects the constructor and fields of a class.
  */
-final class ConstructorBinding<T> extends Binding<T> {
+final class AtInjectBinding<T> extends Binding<T> {
   private final Constructor<T> constructor;
   private final Field[] fields;
   private Binding<?>[] parameters;
   private Binding<?>[] fieldBindings;
+  // TODO: delegate to supertype members injector (which may be generated)
 
   /**
    * @param constructor the injectable constructor, or null if this binding
    *     supports members injection only.
    */
-  private ConstructorBinding(String key, boolean singleton, Class<?> type,
+  private AtInjectBinding(String key, String membersKey, boolean singleton, Class<?> type,
       Constructor<T> constructor, Field[] fields) {
-    super(key, singleton, constructor == null, type);
+    super(key, membersKey, singleton, type);
     this.constructor = constructor;
     this.fields = fields;
   }
@@ -52,7 +53,7 @@
     for (int i = 0; i < fields.length; i++) {
       Field field = fields[i];
       String fieldKey = Keys.get(field.getGenericType(), field.getAnnotations(), field);
-      fieldBindings[i] = linker.requestBinding(fieldKey, field, false);
+      fieldBindings[i] = linker.requestBinding(fieldKey, field);
     }
 
     // Constructor bindings.
@@ -62,7 +63,7 @@
       parameters = new Binding[types.length];
       for (int i = 0; i < parameters.length; i++) {
         String key = Keys.get(types[i], annotations[i], constructor + " parameter " + i);
-        parameters[i] = linker.requestBinding(key, constructor, false);
+        parameters[i] = linker.requestBinding(key, constructor);
       }
     }
   }
@@ -110,10 +111,15 @@
   }
 
   @Override public String toString() {
-    return key;
+    return provideKey != null ? provideKey : membersKey;
   }
 
-  public static <T> Binding<T> create(Class<T> type) {
+  /**
+   * @param forMembersInjection true if the binding is being created to inject
+   *     members only. Such injections do not require {@code @Inject}
+   *     annotations.
+   */
+  public static <T> Binding<T> create(Class<T> type, boolean forMembersInjection) {
     /*
      * Lookup the injectable fields and their corresponding keys.
      */
@@ -143,29 +149,33 @@
       }
       injectedConstructor = constructor;
     }
+
     if (injectedConstructor == null) {
-      if (injectedFields.isEmpty()) {
+      if (injectedFields.isEmpty() && !forMembersInjection) {
         throw new IllegalArgumentException("No injectable members on " + type.getName()
             + ". Do you want to add an injectable constructor?");
       }
       try {
         injectedConstructor = type.getDeclaredConstructor();
-      } catch (NoSuchMethodException e) {
-        injectedConstructor = null;
+      } catch (NoSuchMethodException ignored) {
       }
     }
 
-    if (injectedConstructor != null) {
-      injectedConstructor.setAccessible(true);
-    }
-
+    String key;
     boolean singleton = type.isAnnotationPresent(Singleton.class);
-    if (singleton && injectedConstructor == null) {
-      throw new IllegalArgumentException(
-          "No injectable constructor on @Singleton " + type.getName());
+    if (injectedConstructor != null) {
+      key = Keys.get(type);
+      injectedConstructor.setAccessible(true);
+    } else {
+      key = null;
+      if (singleton) {
+        throw new IllegalArgumentException(
+            "No injectable constructor on @Singleton " + type.getName());
+      }
     }
 
-    return new ConstructorBinding<T>(Keys.get(type, null), singleton, type, injectedConstructor,
+    String membersKey = Keys.getMembersKey(type);
+    return new AtInjectBinding<T>(key, membersKey, singleton, type, injectedConstructor,
         injectedFields.toArray(new Field[injectedFields.size()]));
   }
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Binding.java b/src/main/java/com/squareup/injector/internal/Binding.java
index 799f820..0001752 100644
--- a/src/main/java/com/squareup/injector/internal/Binding.java
+++ b/src/main/java/com/squareup/injector/internal/Binding.java
@@ -21,22 +21,30 @@
 /**
  * Injects a value of a specific type.
  */
-public abstract class Binding<T> implements Provider<T>, MembersInjector<T>,
+public class Binding<T> implements Provider<T>, MembersInjector<T>,
     com.google.inject.Provider<T>, com.google.inject.MembersInjector<T> {
-  public final String key;
+  public static final Binding<Object> UNRESOLVED = new Binding<Object>(null, null, false, null);
+
+  /** The key used to provide instances of 'T', or null if this binding cannot provide instances. */
+  public final String provideKey;
+
+  /** The key used to inject members of 'T', or null if this binding cannot inject members. */
+  public final String membersKey;
+
+  /** True if the provided instance is always the same object. */
   public final boolean singleton;
-  public final boolean injectMembersOnly;
+
   public final Object requiredBy;
   public boolean linked;
 
-  protected Binding(String key, boolean singleton, boolean injectMembersOnly, Object requiredBy) {
-    if (singleton && injectMembersOnly) {
+  protected Binding(String provideKey, String membersKey, boolean singleton, Object requiredBy) {
+    if (singleton && provideKey == null) {
       throw new IllegalArgumentException();
     }
-    this.requiredBy = requiredBy;
+    this.provideKey = provideKey;
+    this.membersKey = membersKey;
     this.singleton = singleton;
-    this.injectMembersOnly = injectMembersOnly;
-    this.key = key;
+    this.requiredBy = requiredBy;
   }
 
   /**
@@ -46,14 +54,15 @@
   }
 
   @Override public void injectMembers(T t) {
-    throw new UnsupportedOperationException();
+    throw new UnsupportedOperationException(getClass().getName());
   }
 
   @Override public T get() {
-    throw new UnsupportedOperationException();
+    throw new UnsupportedOperationException(getClass().getName());
   }
 
+  // TODO: split up dependencies for get() and injectMembers().
   public Binding<?>[] getDependencies() {
-    throw new UnsupportedOperationException();
+    throw new UnsupportedOperationException(getClass().getName());
   }
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/BuiltInBinding.java b/src/main/java/com/squareup/injector/internal/BuiltInBinding.java
index 63be6cd..7018014 100644
--- a/src/main/java/com/squareup/injector/internal/BuiltInBinding.java
+++ b/src/main/java/com/squareup/injector/internal/BuiltInBinding.java
@@ -20,17 +20,15 @@
  */
 final class BuiltInBinding<T> extends Binding<T> {
   private final String delegateKey;
-  private final boolean needMembersOnly;
   private Binding<?> delegate;
 
   public BuiltInBinding(String key, Object requiredBy, String delegateKey) {
-    super(key, false, false, requiredBy);
+    super(key, null, false, requiredBy);
     this.delegateKey = delegateKey;
-    this.needMembersOnly = Keys.isMembersInjector(key);
   }
 
   @Override public void attach(Linker linker) {
-    delegate = linker.requestBinding(delegateKey, requiredBy, needMembersOnly);
+    delegate = linker.requestBinding(delegateKey, requiredBy);
   }
 
   @Override public void injectMembers(T t) {
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Keys.java b/src/main/java/com/squareup/injector/internal/Keys.java
index 04bdd23..8e355ec 100644
--- a/src/main/java/com/squareup/injector/internal/Keys.java
+++ b/src/main/java/com/squareup/injector/internal/Keys.java
@@ -24,12 +24,17 @@
 import javax.inject.Qualifier;
 
 /**
- * Formats strings that identify the value to be injected.
- *
- * <h3>Implementation Note</h3>
- * This currently formats keys by concatenating the annotation name, a slash
- * "/", and the type name. Parameterized types are formatted with ", " between
- * type parameters. The exact key format may change in a future release.
+ * Formats strings that identify the value to be injected. Keys are of one of
+ * three forms:
+ * <ol>
+ *   <li>{@code com.square.Foo}: provides instances of Foo.
+ *   <li>{@code @com.square.Bar/com.square.Foo}: provides instances of Foo
+ *       qualified by the annotation.
+ *   <li>{@code members/com.square.Foo}: injects members of Foo.
+ * </ol>
+ * Bindings from {@code @Provides} methods are of the first two types. Bindings
+ * created from {@code @Inject}-annotated members of a class are of the first
+ * and last types.
  */
 public final class Keys {
   private static final String PROVIDER_PREFIX = Provider.class.getName() + "<";
@@ -54,6 +59,12 @@
     return get(type, null);
   }
 
+
+  /** Returns a key for the members of {@code type}. */
+  public static String getMembersKey(Class<?> key) {
+    return "members/" + get(key);
+  }
+
   /** Returns a key for {@code type} annotated by {@code annotation}. */
   public static String get(Type type, Annotation annotation) {
     type = boxIfPrimitive(type);
@@ -137,19 +148,24 @@
       start = key.lastIndexOf('/') + 1;
     }
 
+    String delegatePrefix;
     String wrapperPrefix;
     if (substringStartsWith(key, start, PROVIDER_PREFIX)) {
+      delegatePrefix = key.substring(0, start);
       wrapperPrefix = PROVIDER_PREFIX;
     } else if (substringStartsWith(key, start, GUICE_PROVIDER_PREFIX)) {
+      delegatePrefix = key.substring(0, start);
       wrapperPrefix = GUICE_PROVIDER_PREFIX;
     } else if (substringStartsWith(key, start, MEMBERS_INJECTOR_PREFIX)) {
+      delegatePrefix = "members/";
       wrapperPrefix = MEMBERS_INJECTOR_PREFIX;
     } else if (substringStartsWith(key, start, GUICE_MEMBERS_INJECTOR_PREFIX)) {
+      delegatePrefix = "members/";
       wrapperPrefix = GUICE_MEMBERS_INJECTOR_PREFIX;
     } else {
       return null;
     }
-    return key.substring(0, start)
+    return delegatePrefix
         + key.substring(start + wrapperPrefix.length(), key.length() - 1);
   }
 
@@ -158,14 +174,9 @@
     return string.regionMatches(offset, substring, 0, substring.length());
   }
 
-  /** Returns true if {@code key} is a binding to a {@code MembersInjector}. */
-  public static boolean isMembersInjector(String key) {
-    int start = 0;
-    if (key.startsWith("@")) {
-      start = key.lastIndexOf('/') + 1;
-    }
-    return substringStartsWith(key, start, MEMBERS_INJECTOR_PREFIX)
-        || substringStartsWith(key, start, GUICE_MEMBERS_INJECTOR_PREFIX);
+  /** Returns true if {@code key} is a binding that supports members injection. */
+  public static boolean isMembersInjection(String key) {
+    return key.startsWith("members/");
   }
 
   /** Returns true if {@code key} has a qualifier annotation. */
@@ -180,7 +191,7 @@
    */
   public static String getClassName(String key) {
     int start = 0;
-    if (key.startsWith("@")) {
+    if (key.startsWith("@") || key.startsWith("members/")) {
       start = key.lastIndexOf('/') + 1;
     }
     return (key.indexOf('<', start) == -1 && key.indexOf('[') == -1)
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Linker.java b/src/main/java/com/squareup/injector/internal/Linker.java
index 0f62f20..641bbc9 100644
--- a/src/main/java/com/squareup/injector/internal/Linker.java
+++ b/src/main/java/com/squareup/injector/internal/Linker.java
@@ -15,7 +15,7 @@
  */
 package com.squareup.injector.internal;
 
-import java.lang.reflect.Modifier;
+import java.lang.reflect.Constructor;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -49,7 +49,7 @@
    */
   public void installModules(Iterable<Object> modules) {
     for (Binding<?> binding : Modules.getBindings(modules).values()) {
-      putBinding(binding);
+      bindings.put(binding.provideKey, scope(binding));
     }
   }
 
@@ -78,17 +78,22 @@
     Binding binding;
     while ((binding = toLink.poll()) != null) {
       if (binding instanceof DeferredBinding) {
-        if (bindings.get(binding.key) != null) {
+        String key = ((DeferredBinding<?>) binding).deferredKey;
+        if (bindings.get(key) != null) {
           continue; // A binding for this key has since been linked.
         }
         try {
-          Binding<?> jitBinding = createJitBinding((DeferredBinding<?>) binding);
+          Binding<?> jitBinding = createJitBinding(key, binding.requiredBy);
+          // Fail if the type of binding we got wasn't capable of what was requested.
+          if (!key.equals(jitBinding.provideKey) && !key.equals(jitBinding.membersKey)) {
+            throw new IllegalStateException("Unable to create binding for " + key);
+          }
           // Enqueue the JIT binding so its own dependencies can be linked.
           toLink.add(jitBinding);
           putBinding(jitBinding);
         } catch (Exception e) {
           addError(e.getMessage() + " required by " + binding.requiredBy);
-          putBinding(new UnresolvedBinding<Object>(binding.requiredBy, binding.key));
+          bindings.put(key, Binding.UNRESOLVED);
         }
       } else {
         // Attempt to attach the binding to its dependencies. If any dependency
@@ -125,22 +130,32 @@
    *       those classes.
    * </ul>
    */
-  private Binding<?> createJitBinding(DeferredBinding<?> deferred) throws ClassNotFoundException {
-    String delegateKey = Keys.getDelegateKey(deferred.key);
+  private Binding<?> createJitBinding(String key, Object requiredBy) throws ClassNotFoundException {
+    String delegateKey = Keys.getDelegateKey(key);
     if (delegateKey != null) {
-      return new BuiltInBinding<Object>(deferred.key, deferred.requiredBy, delegateKey);
+      return new BuiltInBinding<Object>(key, requiredBy, delegateKey);
     }
 
-    String className = Keys.getClassName(deferred.key);
-    if (className != null && !Keys.isAnnotated(deferred.key)) {
-      // Handle concrete class injections with constructor bindings.
+    String className = Keys.getClassName(key);
+    if (className != null && !Keys.isAnnotated(key)) {
+      // First look for a generated InjectAdapter.
+      try {
+        Class<?> c = Class.forName(className + "$InjectAdapter");
+        Constructor<?> constructor = c.getConstructor();
+        constructor.setAccessible(true);
+        return (Binding<?>) constructor.newInstance();
+      } catch (Exception ignored) {
+        // TODO: verbose log that code gen isn't enabled for this class
+      }
+
+      // Handle class bindings by injecting @Inject-annotated members.
       Class<?> c = Class.forName(className);
-      if (!c.isInterface() && !Modifier.isAbstract(c.getModifiers())) {
-        return ConstructorBinding.create(c);
+      if (!c.isInterface()) {
+        return AtInjectBinding.create(c, Keys.isMembersInjection(key));
       }
     }
 
-    throw new IllegalArgumentException("No binding for " + deferred.key);
+    throw new IllegalArgumentException("No binding for " + key);
   }
 
   /**
@@ -148,11 +163,12 @@
    * null. If the returned binding didn't exist or was unlinked, it will be
    * enqueued to be linked.
    */
-  public Binding<?> requestBinding(String key, Object requiredBy, boolean needMembersOnly) {
+  public Binding<?> requestBinding(String key, Object requiredBy) {
     Binding<?> binding = bindings.get(key);
     if (binding == null) {
       // We can't satisfy this binding. Make sure it'll work next time!
-      toLink.add(new DeferredBinding<Object>(requiredBy, key));
+      DeferredBinding<Object> deferredBinding = new DeferredBinding<Object>(key, requiredBy);
+      toLink.add(deferredBinding);
       attachSuccess = false;
       return null;
     }
@@ -161,43 +177,64 @@
       toLink.add(binding); // This binding was never linked; link it now!
     }
 
-    if (!needMembersOnly && binding.injectMembersOnly) {
-      errors.add(requiredBy + " injects " + binding.key
-          + ", but that type supports members injection only");
-      return null;
-    }
-
     return binding;
   }
 
-  private <T> void putBinding(final Binding<T> binding) {
-    Binding<T> toInsert = binding;
-    if (binding.singleton) {
-      toInsert = new Binding<T>(binding.key, true, binding.injectMembersOnly, binding.requiredBy) {
-        private Object onlyInstance = UNINITIALIZED;
-        @Override public void attach(Linker linker) {
-          binding.attach(linker);
-        }
-        @Override public void injectMembers(T t) {
-          binding.injectMembers(t);
-        }
-        @SuppressWarnings("unchecked") // onlyInstance is either 'UNINITIALIZED' or a 'T'.
-        @Override public T get() {
-          if (onlyInstance == UNINITIALIZED) {
-            onlyInstance = binding.get();
-          }
-          return (T) onlyInstance;
-        }
-        @Override public Binding<?>[] getDependencies() {
-          return binding.getDependencies();
-        }
-        @Override public String toString() {
-          return binding.toString();
-        }
-      };
+  private <T> void putBinding(Binding<T> binding) {
+    binding = scope(binding);
+
+    // At binding insertion time it's possible that another binding for the same
+    // key to already exist. This occurs when an @Provides method returns a type T
+    // and we also inject the members of that type.
+    if (binding.provideKey != null) {
+      putIfAbsent(bindings, binding.provideKey, binding);
+    }
+    if (binding.membersKey != null) {
+      putIfAbsent(bindings, binding.membersKey, binding);
+    }
+  }
+
+  /**
+   * Returns a scoped binding for {@code binding}.
+   */
+  private <T> Binding<T> scope(final Binding<T> binding) {
+    if (!binding.singleton) {
+      return binding;
     }
 
-    bindings.put(toInsert.key, toInsert);
+    return new Binding<T>(binding.provideKey, binding.membersKey, true, binding.requiredBy) {
+      private Object onlyInstance = UNINITIALIZED;
+      @Override public void attach(Linker linker) {
+        binding.attach(linker);
+      }
+      @Override public void injectMembers(T t) {
+        binding.injectMembers(t);
+      }
+      @SuppressWarnings("unchecked") // onlyInstance is either 'UNINITIALIZED' or a 'T'.
+      @Override public T get() {
+        if (onlyInstance == UNINITIALIZED) {
+          onlyInstance = binding.get();
+        }
+        return (T) onlyInstance;
+      }
+      @Override public Binding<?>[] getDependencies() {
+        return binding.getDependencies();
+      }
+      @Override public String toString() {
+        return binding.toString();
+      }
+    };
+  }
+
+  /**
+   * Puts the mapping {@code key, value} in {@code map} if no mapping for {@code
+   * key} already exists.
+   */
+  private <K, V> void putIfAbsent(Map<K, V> map, K key, V value) {
+    V replaced = map.put(key, value); // Optimistic: prefer only one hash operation lookup.
+    if (replaced != null) {
+      map.put(key, replaced);
+    }
   }
 
   private void addError(String message) {
@@ -205,14 +242,10 @@
   }
 
   private static class DeferredBinding<T> extends Binding<T> {
-    private DeferredBinding(Object requiredBy, String key) {
-      super(key, false, false, requiredBy);
-    }
-  }
-
-  private static class UnresolvedBinding<T> extends Binding<T> {
-    private UnresolvedBinding(Object definedBy, String key) {
-      super(key, false, false, definedBy);
+    final String deferredKey;
+    private DeferredBinding(String deferredKey, Object requiredBy) {
+      super(null, null, false, requiredBy);
+      this.deferredKey = deferredKey;
     }
   }
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ModuleAdapter.java b/src/main/java/com/squareup/injector/internal/ModuleAdapter.java
index 00fbd51..e84831f 100644
--- a/src/main/java/com/squareup/injector/internal/ModuleAdapter.java
+++ b/src/main/java/com/squareup/injector/internal/ModuleAdapter.java
@@ -23,5 +23,5 @@
  * @author Jesse Wilson
  */
 public interface ModuleAdapter<T> {
-  Map<String, Binding<?>> getBindings(T t);
+  void getBindings(T t, Map<String, Binding<?>> map);
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Modules.java b/src/main/java/com/squareup/injector/internal/Modules.java
index 45b2246..bd18050 100644
--- a/src/main/java/com/squareup/injector/internal/Modules.java
+++ b/src/main/java/com/squareup/injector/internal/Modules.java
@@ -16,8 +16,9 @@
 package com.squareup.injector.internal;
 
 import com.squareup.injector.Provides;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.Map;
 
 /**
@@ -37,7 +38,7 @@
    * @throws IllegalArgumentException if any bindings are duplicated.
    */
   public static Map<String, Binding<?>> getBindings(Iterable<Object> modules) {
-    Map<String, Binding<?>> result = new HashMap<String, Binding<?>>();
+    UniqueMap<String, Binding<?>> result = new UniqueMap<String, Binding<?>>();
     for (Object module : modules) {
       extractBindings(module, result);
     }
@@ -49,21 +50,32 @@
    * returned bindings are not attached to a particular injector and cannot be
    * used to inject values.
    */
-  private static void extractBindings(Object module, Map<String, Binding<?>> result) {
+  private static void extractBindings(Object module, UniqueMap<String, Binding<?>> bindings) {
+    // First look for a generated ModuleAdapter.
+    try {
+      String adapter = module.getClass().getName() + "$ModuleAdapter";
+      Class<?> c = Class.forName(adapter);
+      Constructor<?> constructor = c.getConstructor();
+      constructor.setAccessible(true);
+      @SuppressWarnings("unchecked") // We only generate matching module adapters.
+      ModuleAdapter<Object> moduleAdapter = (ModuleAdapter) constructor.newInstance();
+      moduleAdapter.getBindings(module, bindings);
+      return;
+    } catch (Exception ignored) {
+      // TODO: verbose log that code gen isn't enabled for this module
+    }
+
+    // Fall back to runtime reflection.
     int count = 0;
     for (Class<?> c = module.getClass(); c != Object.class; c = c.getSuperclass()) {
       for (Method method : c.getDeclaredMethods()) {
-        if (method.getAnnotation(Provides.class) == null
-            && method.getAnnotation(com.google.inject.Provides.class) == null) {
+        if (!method.isAnnotationPresent(Provides.class)
+            && !method.isAnnotationPresent(com.google.inject.Provides.class)) {
           continue;
         }
         count++;
         Binding<?> binding = methodToBinding(module, method);
-        Binding<?> clobbered = result.put(binding.key, binding);
-        if (clobbered != null) {
-          throw new IllegalArgumentException("Duplicate bindings:\n    "
-              + clobbered + "\n    " + binding);
-        }
+        bindings.put(binding.provideKey, binding);
       }
     }
     if (count == 0) {
@@ -75,4 +87,22 @@
     String key = Keys.get(method.getGenericReturnType(), method.getAnnotations(), method);
     return new ProviderMethodBinding<T>(method, key, module);
   }
+
+  /**
+   * A map that fails when existing values are clobbered.
+   */
+  private static class UniqueMap<K, V> extends LinkedHashMap<K, V> {
+    @Override public V put(K key, V value) {
+      V clobbered = super.put(key, value);
+      if (clobbered != null) {
+        throw new IllegalArgumentException("Duplicate:\n    " + clobbered + "\n    " + value);
+      }
+      return null;
+    }
+    @Override public void putAll(Map<? extends K, ? extends V> map) {
+      for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {
+        put(entry.getKey(), entry.getValue());
+      }
+    }
+  }
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ProblemDetector.java b/src/main/java/com/squareup/injector/internal/ProblemDetector.java
index a36dea7..f564e99 100644
--- a/src/main/java/com/squareup/injector/internal/ProblemDetector.java
+++ b/src/main/java/com/squareup/injector/internal/ProblemDetector.java
@@ -41,7 +41,7 @@
       if (done.add(root)) {
         try {
           detectCircularDependencies(root);
-        } catch (Exception e) {
+        } catch (IllegalStateException e) {
           if (message == null) {
             message = new StringBuilder().append("Graph problems:");
           }
@@ -62,10 +62,10 @@
           .append("Dependency cycle:");
       for (int i = index; i < path.size(); i++) {
         message.append("\n    ").append(i - index).append(". ")
-            .append(path.get(i).key).append(" bound by ").append(path.get(i));
+            .append(path.get(i).provideKey).append(" bound by ").append(path.get(i));
       }
-      message.append("\n    ").append(0).append(". ").append(binding.key);
-      throw new RuntimeException(message.toString());
+      message.append("\n    ").append(0).append(". ").append(binding.provideKey);
+      throw new IllegalStateException(message.toString());
     }
 
     path.add(binding);
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java b/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
index 865f833..21c3210 100644
--- a/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
+++ b/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
@@ -30,7 +30,7 @@
   private final Object instance;
 
   public ProviderMethodBinding(Method method, String key, Object instance) {
-    super(key, method.isAnnotationPresent(Singleton.class), false, method);
+    super(key, null, method.isAnnotationPresent(Singleton.class), method);
     this.method = method;
     this.instance = instance;
     method.setAccessible(true);
@@ -42,7 +42,7 @@
     parameters = new Binding[types.length];
     for (int i = 0; i < parameters.length; i++) {
       String key = Keys.get(types[i], annotations[i], method + " parameter " + i);
-      parameters[i] = linker.requestBinding(key, method, false);
+      parameters[i] = linker.requestBinding(key, method);
     }
   }
 
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/StaticInjection.java b/src/main/java/com/squareup/injector/internal/StaticInjection.java
index 1e9b8b6..93a8398 100644
--- a/src/main/java/com/squareup/injector/internal/StaticInjection.java
+++ b/src/main/java/com/squareup/injector/internal/StaticInjection.java
@@ -55,7 +55,7 @@
     for (int i = 0; i < fields.length; i++) {
       Field field = fields[i];
       String key = Keys.get(field.getGenericType(), field.getAnnotations(), field);
-      bindings[i] = linker.requestBinding(key, field, false);
+      bindings[i] = linker.requestBinding(key, field);
     }
   }
 
/Fim/
diff --git a/src/test/java/com/squareup/injector/MembersInjectorTest.java b/src/test/java/com/squareup/injector/MembersInjectorTest.java
index 8f357ce..9e0df2f 100644
--- a/src/test/java/com/squareup/injector/MembersInjectorTest.java
+++ b/src/test/java/com/squareup/injector/MembersInjectorTest.java
@@ -188,4 +188,37 @@
     } catch (IllegalArgumentException expected) {
     }
   }
+
+  @Test public void providesMethodsAndMembersInjectionDoNotConflict() {
+    class InjectsString {
+      @Inject String value;
+    }
+
+    class TestEntryPoint {
+      @Inject Provider<InjectsString> provider;
+      @Inject MembersInjector<InjectsString> membersInjector;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides InjectsString provideInjectsString() {
+        InjectsString result = new InjectsString();
+        result.value = "provides";
+        return result;
+      }
+      @Provides String provideString() {
+        return "members";
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+
+    InjectsString provided = entryPoint.provider.get();
+    assertThat(provided.value).isEqualTo("provides");
+
+    InjectsString membersInjected = new InjectsString();
+    entryPoint.membersInjector.injectMembers(membersInjected);
+    assertThat(membersInjected.value).isEqualTo("members");
+  }
 }
\ No newline at end of file
/Fim/
diff --git a/src/test/java/com/squareup/injector/internal/KeysTest.java b/src/test/java/com/squareup/injector/internal/KeysTest.java
index 680a8be..39a6b46 100644
--- a/src/test/java/com/squareup/injector/internal/KeysTest.java
+++ b/src/test/java/com/squareup/injector/internal/KeysTest.java
@@ -104,7 +104,7 @@
   @Named("/@") String injectedType;
   @Test public void testGetDelegateKeyWithMembersInjector() throws NoSuchFieldException {
     assertThat(Keys.getDelegateKey(fieldKey("membersInjectorOfType")))
-        .isEqualTo(fieldKey("injectedType"));
+        .isEqualTo("members/java.lang.String");
   }
 
   private String fieldKey(String fieldName) throws NoSuchFieldException {
/Fim/
diff --git a/src/main/java/com/squareup/codegen/CodeGen.java b/src/main/java/com/squareup/codegen/CodeGen.java
index 7c09347..bcdad2b 100644
--- a/src/main/java/com/squareup/codegen/CodeGen.java
+++ b/src/main/java/com/squareup/codegen/CodeGen.java
@@ -16,9 +16,16 @@
 package com.squareup.codegen;
 
 import com.squareup.injector.internal.Keys;
+import java.lang.reflect.Method;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
@@ -26,6 +33,7 @@
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVariable;
+import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
 /**
@@ -139,6 +147,48 @@
     }, null);
   }
 
+  private static final AnnotationValueVisitor<Object, Void> VALUE_EXTRACTOR
+      = new SimpleAnnotationValueVisitor6<Object, Void>() {
+    @Override protected Object defaultAction(Object o, Void v) {
+      return o;
+    }
+    @Override public Object visitArray(List<? extends AnnotationValue> values, Void v) {
+      Object[] result = new Object[values.size()];
+      for (int i = 0; i < values.size(); i++) {
+        result[i] = values.get(i).accept(this, null);
+      }
+      return result;
+    }
+  };
+
+  /**
+   * Returns the annotation on {@code element} formatted as a Map. This returns
+   * a Map rather than an instance of the annotation interface to work-around
+   * the fact that Class and Class[] fields won't work at code generation time.
+   * See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5089128
+   */
+  public static Map<String, Object> getAnnotation(Class<?> annotationType, Element element) {
+    for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
+      if (!annotation.getAnnotationType().toString().equals(annotationType.getName())) {
+        continue;
+      }
+
+      Map<String, Object> result = new LinkedHashMap<String, Object>();
+      for (Method m : annotationType.getMethods()) {
+        result.put(m.getName(), m.getDefaultValue());
+      }
+      for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> e
+          : annotation.getElementValues().entrySet()) {
+        String name = e.getKey().getSimpleName().toString();
+        Object value = e.getValue().accept(VALUE_EXTRACTOR, null);
+        result.put(name, value);
+      }
+      return result;
+    }
+
+    return null; // Annotation not found.
+  }
+
   static void rawTypeToString(StringBuilder result, TypeElement type,
       char innerClassSeparator) {
     String packageName = getPackage(type).getQualifiedName().toString();
/Fim/
diff --git a/src/main/java/com/squareup/codegen/ProvidesProcessor.java b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
index e130b82..641c223 100644
--- a/src/main/java/com/squareup/codegen/ProvidesProcessor.java
+++ b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.codegen;
 
+import com.squareup.injector.Module;
 import com.squareup.injector.Provides;
 import com.squareup.injector.internal.Binding;
 import com.squareup.injector.internal.Linker;
@@ -71,11 +72,15 @@
         writeModuleAdapter(module.getKey(), module.getValue());
       }
     } catch (IOException e) {
-      processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "Code gen failed: " + e);
+      error("Code gen failed: " + e);
     }
     return true;
   }
 
+  private void error(String message) {
+    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message);
+  }
+
   /**
    * Returns a map containing all {@code @Provides} methods, indexed by class.
    */
@@ -131,6 +136,16 @@
    */
   private void writeModuleAdapter(TypeElement type, List<ExecutableElement> providerMethods)
       throws IOException {
+    Map<String, Object> module = CodeGen.getAnnotation(Module.class, type);
+    if (module == null) {
+      error(type + " has @Provides methods but no @Module annotation");
+      return;
+    }
+
+    Object[] staticInjections = (Object[]) module.get("staticInjections");
+    Object[] entryPoints = (Object[]) module.get("entryPoints");
+    boolean overrides = (Boolean) module.get("overrides");
+
     String adapterName = CodeGen.adapterName(type, "$ModuleAdapter");
     JavaFileObject sourceFile = processingEnv.getFiler()
         .createSourceFile(adapterName, type);
@@ -143,9 +158,32 @@
     writer.addImport(Linker.class);
 
     String typeName = type.getQualifiedName().toString();
-    writer.beginType(adapterName, "class", PUBLIC | FINAL, null,
+    writer.beginType(adapterName, "class", PUBLIC | FINAL,
         CodeGen.parameterizedType(ModuleAdapter.class, typeName));
 
+    StringBuilder entryPointsField = new StringBuilder().append("{ ");
+    for (Object entryPoint : entryPoints) {
+      TypeMirror typeMirror = (TypeMirror) entryPoint;
+      String key = GeneratorKeys.rawMembersKey(typeMirror);
+      entryPointsField.append(JavaWriter.stringLiteral(key)).append(", ");
+    }
+    entryPointsField.append("}");
+    writer.field("String[]", "ENTRY_POINTS", PRIVATE | STATIC | FINAL,
+        entryPointsField.toString());
+
+    StringBuilder staticInjectionsField = new StringBuilder().append("{ ");
+    for (Object staticInjection : staticInjections) {
+      TypeMirror typeMirror = (TypeMirror) staticInjection;
+      staticInjectionsField.append(CodeGen.typeToString(typeMirror)).append(".class, ");
+    }
+    staticInjectionsField.append("}");
+    writer.field("Class<?>[]", "STATIC_INJECTIONS", PRIVATE | STATIC | FINAL,
+        staticInjectionsField.toString());
+
+    writer.beginMethod(null, adapterName, PUBLIC);
+    writer.statement("super(ENTRY_POINTS, STATIC_INJECTIONS, %s)", overrides);
+    writer.endMethod();
+
     writer.annotation(Override.class);
     writer.beginMethod("void", "getBindings", PUBLIC, typeName, "module", BINDINGS_MAP, "map");
     for (ExecutableElement providerMethod : providerMethods) {
/Fim/
diff --git a/src/main/java/com/squareup/injector/ObjectGraph.java b/src/main/java/com/squareup/injector/ObjectGraph.java
index 6979eed..217e27a 100644
--- a/src/main/java/com/squareup/injector/ObjectGraph.java
+++ b/src/main/java/com/squareup/injector/ObjectGraph.java
@@ -18,12 +18,12 @@
 import com.squareup.injector.internal.Binding;
 import com.squareup.injector.internal.Keys;
 import com.squareup.injector.internal.Linker;
+import com.squareup.injector.internal.ModuleAdapter;
 import com.squareup.injector.internal.ProblemDetector;
 import com.squareup.injector.internal.StaticInjection;
-import java.util.ArrayList;
+import com.squareup.injector.internal.UniqueMap;
 import java.util.Collection;
 import java.util.LinkedHashMap;
-import java.util.List;
 import java.util.Map;
 
 /**
@@ -56,10 +56,10 @@
 public final class ObjectGraph {
   private final Linker linker;
   private final Map<Class<?>, StaticInjection> staticInjections;
-  private final Map<Class<?>, Class<?>> entryPoints;
+  private final Map<String, Class<?>> entryPoints;
 
   private ObjectGraph(Linker linker, Map<Class<?>, StaticInjection> staticInjections,
-      Map<Class<?>, Class<?>> entryPoints) {
+      Map<String, Class<?>> entryPoints) {
     this.linker = linker;
     this.staticInjections = staticInjections;
     this.entryPoints = entryPoints;
@@ -82,36 +82,31 @@
   }
 
   private static ObjectGraph get(boolean lazy, Object... modules) {
-    Map<Class<?>, Class<?>> entryPoints = new LinkedHashMap<Class<?>, Class<?>>();
+    Map<String, Class<?>> entryPoints = new LinkedHashMap<String, Class<?>>();
     Map<Class<?>, StaticInjection> staticInjections
         = new LinkedHashMap<Class<?>, StaticInjection>();
 
-    List<Object> baseModules = new ArrayList<Object>();
-    List<Object> overrideModules = new ArrayList<Object>();
+    // Extract bindings in the 'base' and 'overrides' set. Within each set no
+    // duplicates are permitted.
+    Map<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>();
+    Map<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>();
     for (Object module : modules) {
       Class<?> moduleClass = module.getClass();
-      Module annotation = moduleClass.getAnnotation(Module.class);
-      if (annotation == null) {
-        throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
+      ModuleAdapter<Object> adapter = ModuleAdapter.get(module);
+      for (String key : adapter.entryPoints) {
+        entryPoints.put(key, moduleClass);
       }
-      for (Class<?> c : annotation.entryPoints()) {
-        entryPoints.put(c, moduleClass);
-      }
-      for (Class<?> c : annotation.staticInjections()) {
+      for (Class<?> c : adapter.staticInjections) {
         staticInjections.put(c, lazy ? null : StaticInjection.get(c));
       }
-      if (annotation.overrides()) {
-        overrideModules.add(module);
-      } else {
-        baseModules.add(module);
-      }
+      Map<String, Binding<?>> addTo = adapter.overrides ? overrideBindings : baseBindings;
+      adapter.getBindings(module, addTo);
     }
 
-    // Create a linker and install all of the user's modules. Modules provided
-    // at runtime may override modules provided in the @Module annotation.
+    // Create a linker and install all of the user's bindings.
     Linker linker = new Linker();
-    linker.installModules(baseModules);
-    linker.installModules(overrideModules);
+    linker.installBindings(baseBindings);
+    linker.installBindings(overrideBindings);
 
     ObjectGraph result = new ObjectGraph(linker, staticInjections, entryPoints);
 
@@ -137,8 +132,8 @@
   }
 
   private void linkEntryPoints() {
-    for (Map.Entry<Class<?>, Class<?>> entry : entryPoints.entrySet()) {
-      linker.requestBinding(Keys.getMembersKey(entry.getKey()), entry.getValue());
+    for (Map.Entry<String, Class<?>> entry : entryPoints.entrySet()) {
+      linker.requestBinding(entry.getKey(), entry.getValue());
     }
   }
 
@@ -180,13 +175,12 @@
    */
   @SuppressWarnings("unchecked") // the linker matches keys to bindings by their type
   public void inject(Object instance) {
-    Class<?> type = instance.getClass();
-    Class<?> moduleClass = entryPoints.get(type);
+    String key = Keys.getMembersKey(instance.getClass());
+    Class<?> moduleClass = entryPoints.get(key);
     if (moduleClass == null) {
-      throw new IllegalArgumentException("No entry point for " + type.getName() + ". "
-          + "You must explicitly add an entry point to one of your modules.");
+      throw new IllegalArgumentException("No entry point for " + instance.getClass().getName()
+          + ". You must explicitly add an entry point to one of your modules.");
     }
-    String key = Keys.getMembersKey(type);
     Binding<?> binding = linker.requestBinding(key, moduleClass);
     if (binding == null || !binding.linked) {
       linker.linkRequested();
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/AtInjectBinding.java b/src/main/java/com/squareup/injector/internal/AtInjectBinding.java
index 8a7818e..4109e6c 100644
--- a/src/main/java/com/squareup/injector/internal/AtInjectBinding.java
+++ b/src/main/java/com/squareup/injector/internal/AtInjectBinding.java
@@ -31,49 +31,52 @@
  * A binding that injects the constructor and fields of a class.
  */
 final class AtInjectBinding<T> extends Binding<T> {
-  private final Constructor<T> constructor;
   private final Field[] fields;
+  private final Constructor<T> constructor;
   private final Class<?> supertype;
-  private Binding<?>[] parameters;
+  private final String[] keys;
   private Binding<?>[] fieldBindings;
+  private Binding<?>[] parameterBindings;
   private Binding<? super T> supertypeBinding;
 
   /**
+   * @param keys keys for the fields, constructor parameters and supertype in
+   *     that order. These are precomputed to minimize reflection when {@code
+   *     attach} is called multiple times.
    * @param constructor the injectable constructor, or null if this binding
    *     supports members injection only.
+   * @param supertype the injectable supertype, or null if the supertype is a
    */
-  private AtInjectBinding(String key, String membersKey, boolean singleton, Class<?> type,
-      Constructor<T> constructor, Field[] fields, Class<?> supertype) {
-    super(key, membersKey, singleton, type);
+  private AtInjectBinding(String provideKey, String membersKey, boolean singleton, Class<?> type,
+      Field[] fields, Constructor<T> constructor, int parameterCount, Class<?> supertype,
+      String[] keys) {
+    super(provideKey, membersKey, singleton, type);
     this.constructor = constructor;
     this.fields = fields;
     this.supertype = supertype;
+    this.keys = keys;
+    this.parameterBindings = new Binding<?>[parameterCount];
+    this.fieldBindings = new Binding<?>[fields.length];
   }
 
   @Override public void attach(Linker linker) {
-    // Field bindings.
-    fieldBindings = new Binding<?>[fields.length];
+    int k = 0;
     for (int i = 0; i < fields.length; i++) {
-      Field field = fields[i];
-      String fieldKey = Keys.get(field.getGenericType(), field.getAnnotations(), field);
-      fieldBindings[i] = linker.requestBinding(fieldKey, field);
+      if (fieldBindings[i] == null) {
+        fieldBindings[i] = linker.requestBinding(keys[k], fields[i]);
+      }
+      k++;
     }
-
-    // Constructor bindings.
     if (constructor != null) {
-      Type[] types = constructor.getGenericParameterTypes();
-      Annotation[][] annotations = constructor.getParameterAnnotations();
-      parameters = new Binding[types.length];
-      for (int i = 0; i < parameters.length; i++) {
-        String key = Keys.get(types[i], annotations[i], constructor + " parameter " + i);
-        parameters[i] = linker.requestBinding(key, constructor);
+      for (int i = 0; i < parameterBindings.length; i++) {
+        if (parameterBindings[i] == null) {
+          parameterBindings[i] = linker.requestBinding(keys[k], constructor);
+        }
+        k++;
       }
     }
-
-    // Supertype binding.
-    if (supertype != null && !Keys.isPlatformType(supertype.getName())) {
-      supertypeBinding = (Binding<? super T>) linker.requestBinding(
-          Keys.getMembersKey(supertype), membersKey);
+    if (supertype != null && supertypeBinding == null) {
+      supertypeBinding = (Binding<? super T>) linker.requestBinding(keys[k], membersKey);
     }
   }
 
@@ -81,9 +84,9 @@
     if (constructor == null) {
       throw new UnsupportedOperationException();
     }
-    Object[] args = new Object[parameters.length];
-    for (int i = 0; i < parameters.length; i++) {
-      args[i] = parameters[i].get();
+    Object[] args = new Object[parameterBindings.length];
+    for (int i = 0; i < parameterBindings.length; i++) {
+      args[i] = parameterBindings[i].get();
     }
     T result;
     try {
@@ -113,8 +116,8 @@
   }
 
   @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-    if (parameters != null) {
-      for (Binding<?> binding : parameters) {
+    if (parameterBindings != null) {
+      for (Binding<?> binding : parameterBindings) {
         get.add(binding);
       }
     }
@@ -136,10 +139,11 @@
    *     annotations.
    */
   public static <T> Binding<T> create(Class<T> type, boolean forMembersInjection) {
-    /*
-     * Lookup the injectable fields and their corresponding keys.
-     */
-    final List<Field> injectedFields = new ArrayList<Field>();
+    boolean singleton = type.isAnnotationPresent(Singleton.class);
+    List<String> keys = new ArrayList<String>();
+
+    // Lookup the injectable fields and their corresponding keys.
+    List<Field> injectedFields = new ArrayList<Field>();
     for (Class<?> c = type; c != Object.class; c = c.getSuperclass()) {
       for (Field field : c.getDeclaredFields()) {
         if (!field.isAnnotationPresent(Inject.class) || Modifier.isStatic(field.getModifiers())) {
@@ -147,14 +151,13 @@
         }
         field.setAccessible(true);
         injectedFields.add(field);
+        keys.add(Keys.get(field.getGenericType(), field.getAnnotations(), field));
       }
     }
 
-    /*
-     * Lookup @Inject-annotated constructors. If there's no @Inject-annotated
-     * constructor, use a default public constructor if the class has other
-     * injections. Otherwise treat the class as non-injectable.
-     */
+    // Look up @Inject-annotated constructors. If there's no @Inject-annotated
+    // constructor, use a default public constructor if the class has other
+    // injections. Otherwise treat the class as non-injectable.
     Constructor<T> injectedConstructor = null;
     for (Constructor<T> constructor : (Constructor<T>[]) type.getDeclaredConstructors()) {
       if (!constructor.isAnnotationPresent(Inject.class)) {
@@ -165,7 +168,6 @@
       }
       injectedConstructor = constructor;
     }
-
     if (injectedConstructor == null) {
       if (injectedFields.isEmpty() && !forMembersInjection) {
         throw new IllegalArgumentException("No injectable members on " + type.getName()
@@ -177,21 +179,40 @@
       }
     }
 
-    String key;
-    boolean singleton = type.isAnnotationPresent(Singleton.class);
+    int parameterCount;
+    String provideKey;
     if (injectedConstructor != null) {
-      key = Keys.get(type);
+      provideKey = Keys.get(type);
       injectedConstructor.setAccessible(true);
+      Type[] types = injectedConstructor.getGenericParameterTypes();
+      parameterCount = types.length;
+      if (parameterCount != 0) {
+        Annotation[][] annotations = injectedConstructor.getParameterAnnotations();
+        for (int p = 0; p < types.length; p++) {
+          keys.add(Keys.get(types[p], annotations[p], injectedConstructor));
+        }
+      }
     } else {
-      key = null;
+      provideKey = null;
+      parameterCount = 0;
       if (singleton) {
         throw new IllegalArgumentException(
             "No injectable constructor on @Singleton " + type.getName());
       }
     }
 
+    Class<? super T> supertype = type.getSuperclass();
+    if (supertype != null) {
+      if (Keys.isPlatformType(supertype.getName())) {
+        supertype = null;
+      } else {
+        keys.add(Keys.getMembersKey(supertype));
+      }
+    }
+
     String membersKey = Keys.getMembersKey(type);
-    return new AtInjectBinding<T>(key, membersKey, singleton, type, injectedConstructor,
-        injectedFields.toArray(new Field[injectedFields.size()]), type.getSuperclass());
+    return new AtInjectBinding<T>(provideKey, membersKey, singleton, type,
+        injectedFields.toArray(new Field[injectedFields.size()]), injectedConstructor,
+        parameterCount, supertype, keys.toArray(new String[keys.size()]));
   }
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Linker.java b/src/main/java/com/squareup/injector/internal/Linker.java
index be18cfa..0dbe48b 100644
--- a/src/main/java/com/squareup/injector/internal/Linker.java
+++ b/src/main/java/com/squareup/injector/internal/Linker.java
@@ -48,12 +48,11 @@
   private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
 
   /**
-   * Adds the {@code @Provides} bindings from {@code modules}. There may not
-   * be any duplicated bindings in {@code modules}, though multiple calls to
-   * this method may contain duplicates: last installed wins.
+   * Adds all the bindings from {@code toInstall}. The bindings must be linked
+   * before they can be used.
    */
-  public void installModules(Iterable<Object> modules) {
-    for (Binding<?> binding : Modules.getBindings(modules).values()) {
+  public void installBindings(Map<String, Binding<?>> toInstall) {
+    for (Binding<?> binding : toInstall.values()) {
       bindings.put(binding.provideKey, scope(binding));
     }
   }
@@ -84,7 +83,7 @@
     while ((binding = toLink.poll()) != null) {
       if (binding instanceof DeferredBinding) {
         String key = ((DeferredBinding<?>) binding).deferredKey;
-        if (bindings.get(key) != null) {
+        if (bindings.containsKey(key)) {
           continue; // A binding for this key has since been linked.
         }
         try {
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ModuleAdapter.java b/src/main/java/com/squareup/injector/internal/ModuleAdapter.java
index e84831f..33241a0 100644
--- a/src/main/java/com/squareup/injector/internal/ModuleAdapter.java
+++ b/src/main/java/com/squareup/injector/internal/ModuleAdapter.java
@@ -15,13 +15,96 @@
  */
 package com.squareup.injector.internal;
 
+import com.squareup.injector.Module;
+import com.squareup.injector.ObjectGraph;
+import com.squareup.injector.Provides;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
 import java.util.Map;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 /**
- * Interface implemented by generated module classes.
- *
- * @author Jesse Wilson
+ * Extracts bindings from an {@code @Module}-annotated class.
  */
-public interface ModuleAdapter<T> {
-  void getBindings(T t, Map<String, Binding<?>> map);
+public abstract class ModuleAdapter<T> {
+  private static final Logger LOGGER = Logger.getLogger(ObjectGraph.class.getName());
+
+  public final String[] entryPoints;
+  public final Class<?>[] staticInjections;
+  public final boolean overrides;
+
+  protected ModuleAdapter(String[] entryPoints, Class<?>[] staticInjections, boolean overrides) {
+    this.entryPoints = entryPoints;
+    this.staticInjections = staticInjections;
+    this.overrides = overrides;
+  }
+
+  /**
+   * Returns bindings for the {@code @Provides} methods of {@code module}. The
+   * returned bindings must be linked before they can be used to inject values.
+   */
+  public abstract void getBindings(T module, Map<String, Binding<?>> map);
+
+  /**
+   * Returns a module adapter for {@code module}, preferring a code-generated
+   * implementation and falling back to a reflective implementation.
+   */
+  @SuppressWarnings("unchecked") // Runtime checks validate that the result type matches 'T'.
+  public static <T> ModuleAdapter<T> get(T module) {
+    Class<?> moduleClass = module.getClass();
+    try {
+      String adapter = moduleClass.getName() + "$ModuleAdapter";
+      Class<?> c = Class.forName(adapter);
+      Constructor<?> constructor = c.getConstructor();
+      constructor.setAccessible(true);
+      return (ModuleAdapter) constructor.newInstance();
+    } catch (Exception e) {
+      LOGGER.log(Level.FINE, "No generated module for " + moduleClass.getName()
+          + ". Falling back to reflection.", e);
+    }
+
+    Module annotation = moduleClass.getAnnotation(Module.class);
+    if (annotation == null) {
+      throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
+    }
+    return (ModuleAdapter) new ReflectiveModuleAdapter(moduleClass, annotation);
+  }
+
+  static class ReflectiveModuleAdapter extends ModuleAdapter<Object> {
+    final Class<?> moduleClass;
+
+    ReflectiveModuleAdapter(Class<?> moduleClass, Module annotation) {
+      super(toMemberKeys(annotation.entryPoints()), annotation.staticInjections(),
+          annotation.overrides());
+      this.moduleClass = moduleClass;
+    }
+
+    private static String[] toMemberKeys(Class<?>[] entryPoints) {
+      String[] result = new String[entryPoints.length];
+      for (int i = 0; i < entryPoints.length; i++) {
+        result[i] = Keys.getMembersKey(entryPoints[i]);
+      }
+      return result;
+    }
+
+    @Override public void getBindings(Object module, Map<String, Binding<?>> bindings) {
+      // Fall back to runtime reflection.
+      for (Class<?> c = moduleClass; c != Object.class; c = c.getSuperclass()) {
+        for (Method method : c.getDeclaredMethods()) {
+          if (!method.isAnnotationPresent(Provides.class)
+              && !method.isAnnotationPresent(com.google.inject.Provides.class)) {
+            continue;
+          }
+          Binding<?> binding = methodToBinding(module, method);
+          bindings.put(binding.provideKey, binding);
+        }
+      }
+    }
+
+    private <T> Binding<T> methodToBinding(Object module, Method method) {
+      String key = Keys.get(method.getGenericReturnType(), method.getAnnotations(), method);
+      return new ProviderMethodBinding<T>(method, key, module);
+    }
+  }
 }
/Fim/
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/UniqueMap.java b/src/main/java/com/squareup/injector/internal/UniqueMap.java
new file mode 100644
index 0000000..b369005
--- /dev/null
+++ b/src/main/java/com/squareup/injector/internal/UniqueMap.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+/**
+ * A map that fails when existing values are clobbered.
+ */
+public class UniqueMap<K, V> extends LinkedHashMap<K, V> {
+  @Override public V put(K key, V value) {
+    V clobbered = super.put(key, value);
+    if (clobbered != null) {
+      super.put(key, clobbered); // Put things back as they were.
+      throw new IllegalArgumentException("Duplicate:\n    " + clobbered + "\n    " + value);
+    }
+    return null;
+  }
+  @Override public void putAll(Map<? extends K, ? extends V> map) {
+    for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {
+      put(entry.getKey(), entry.getValue());
+    }
+  }
+}
/Fim/
diff --git a/README.md b/README.md
index 3ef0375..f50c87e 100644
--- a/README.md
+++ b/README.md
@@ -1,8 +1,25 @@
-Square Injector
-===============
+ObjectGraph
+===========
 
 A JSR-330 dependency injector for Android and Java.
 
+
+Contributing
+------------
+
+If you would like to contribute code to ObjectGraph you can do so through
+GitHub by forking the repository and sending a pull request.
+
+When submitting code, please make every effort to follow existing conventions
+and style in order to keep the code as readable as possible. Please also make
+sure your code compiles by running `mvn clean verify`. Checkstyle failures
+during compilation indicate errors in your style and can be viewed in the
+`checkstyle-result.xml` file.
+
+Before your code can be accepted into the project you must also sign the
+[Individual Contributor License Agreement (CLA)][1].
+
+
 License
 =======
 
@@ -19,3 +36,5 @@
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
+
+ [1]: https://spreadsheets.google.com/spreadsheet/viewform?formkey=dDViT2xzUHAwRkI3X3k5Z0lQM091OGc6MQ&ndplr=1
/Fim/
/Fim/
diff --git a/pom.xml b/pom.xml
index 4af38b8..f3ad495 100644
--- a/pom.xml
+++ b/pom.xml
@@ -18,13 +18,13 @@
     <modelVersion>4.0.0</modelVersion>
 
     <groupId>com.squareup</groupId>
-    <artifactId>injector</artifactId>
+    <artifactId>objectgraph</artifactId>
     <version>1.0-SNAPSHOT</version>
     <packaging>jar</packaging>
 
-    <name>Injector</name>
-    <description>A JSR-330 dependency injector.</description>
-    <url>http://git.squareup.com/square/injector/</url>
+    <name>ObjectGraph</name>
+    <description>A JSR-330 dependency injector for Android and Java.</description>
+    <url>https://github.com/square/objectgraph</url>
 
 
     <properties>
@@ -40,14 +40,14 @@
     </properties>
 
     <scm>
-        <url>http://git.squareup.com/square/injector/</url>
-        <connection>scm:git:git://git.squareup.com/square/injector.git</connection>
-        <developerConnection>scm:git:ssh://git@git.squareup.com/square/injector.git</developerConnection>
+        <url>http://github.com/square/objectgraph/</url>
+        <connection>scm:git:git://github.com/square/objectgraph.git</connection>
+        <developerConnection>scm:git:ssh://git@github.com/square/objectgraph.git</developerConnection>
     </scm>
 
     <issueManagement>
         <system>GitHub Issues</system>
-        <url>http://git.squareup.com/square/injector/issues</url>
+        <url>http://github.com/square/objectgraph/issues</url>
     </issueManagement>
 
     <licenses>
/Fim/
diff --git a/src/main/java/com/squareup/injector/MembersInjector.java b/src/main/java/com/squareup/objectgraph/MembersInjector.java
similarity index 77%
rename from src/main/java/com/squareup/injector/MembersInjector.java
rename to src/main/java/com/squareup/objectgraph/MembersInjector.java
index 3767d39..5712c7d 100644
--- a/src/main/java/com/squareup/injector/MembersInjector.java
+++ b/src/main/java/com/squareup/objectgraph/MembersInjector.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2009 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector;
+package com.squareup.objectgraph;
 
 /**
  * Injects dependencies into the fields and methods on instances of type
@@ -30,10 +31,10 @@
    * Injects dependencies into the fields and methods of {@code instance}.
    * Ignores the presence or absence of an injectable constructor.
    *
-   * <p>Whenever the injector creates an instance, it performs this injection
-   * automatically (after first performing constructor injection), so if you're
-   * able to let the injector create all your objects for you, you'll never need
-   * to use this method.
+   * <p>Whenever the object graph creates an instance, it performs this
+   * injection automatically (after first performing constructor injection), so
+   * if you're able to let the object graph create all your objects for you,
+   * you'll never need to use this method.
    *
    * @param instance to inject members on. May be {@code null}.
    */
/Fim/
diff --git a/src/main/java/com/squareup/injector/Module.java b/src/main/java/com/squareup/objectgraph/Module.java
similarity index 97%
rename from src/main/java/com/squareup/injector/Module.java
rename to src/main/java/com/squareup/objectgraph/Module.java
index ae76826..1e78f74 100644
--- a/src/main/java/com/squareup/injector/Module.java
+++ b/src/main/java/com/squareup/objectgraph/Module.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector;
+package com.squareup.objectgraph;
 
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
/Fim/
diff --git a/src/main/java/com/squareup/injector/ObjectGraph.java b/src/main/java/com/squareup/objectgraph/ObjectGraph.java
similarity index 90%
rename from src/main/java/com/squareup/injector/ObjectGraph.java
rename to src/main/java/com/squareup/objectgraph/ObjectGraph.java
index 217e27a..74e6d6a 100644
--- a/src/main/java/com/squareup/injector/ObjectGraph.java
+++ b/src/main/java/com/squareup/objectgraph/ObjectGraph.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector;
+package com.squareup.objectgraph;
 
-import com.squareup.injector.internal.Binding;
-import com.squareup.injector.internal.Keys;
-import com.squareup.injector.internal.Linker;
-import com.squareup.injector.internal.ModuleAdapter;
-import com.squareup.injector.internal.ProblemDetector;
-import com.squareup.injector.internal.StaticInjection;
-import com.squareup.injector.internal.UniqueMap;
+import com.squareup.objectgraph.internal.Binding;
+import com.squareup.objectgraph.internal.Keys;
+import com.squareup.objectgraph.internal.Linker;
+import com.squareup.objectgraph.internal.ModuleAdapter;
+import com.squareup.objectgraph.internal.ProblemDetector;
+import com.squareup.objectgraph.internal.StaticInjection;
+import com.squareup.objectgraph.internal.UniqueMap;
 import java.util.Collection;
 import java.util.LinkedHashMap;
 import java.util.Map;
@@ -110,7 +110,7 @@
 
     ObjectGraph result = new ObjectGraph(linker, staticInjections, entryPoints);
 
-    // Link all bindings (unless this injector is lazy).
+    // Link all bindings (unless this object graph is lazy).
     if (!lazy) {
       result.linkStaticInjections();
       result.linkEntryPoints();
@@ -148,8 +148,8 @@
   }
 
   /**
-   * Injects the static fields of the classes listed in the injector's {@code
-   * staticInjections} property.
+   * Injects the static fields of the classes listed in the object graph's
+   * {@code staticInjections} property.
    */
   public void injectStatics() {
     // We call linkStaticInjections() twice on purpose. The first time through
@@ -171,7 +171,7 @@
    * inherited from its supertypes.
    *
    * @throws IllegalArgumentException if the runtime type of {@code instance} is
-   *     not the injector's type or one of its entry point types.
+   *     not the object graph's type or one of its entry point types.
    */
   @SuppressWarnings("unchecked") // the linker matches keys to bindings by their type
   public void inject(Object instance) {
/Fim/
diff --git a/src/main/java/com/squareup/injector/Provides.java b/src/main/java/com/squareup/objectgraph/Provides.java
similarity index 86%
rename from src/main/java/com/squareup/injector/Provides.java
rename to src/main/java/com/squareup/objectgraph/Provides.java
index fb0b4f7..d67ec33 100644
--- a/src/main/java/com/squareup/injector/Provides.java
+++ b/src/main/java/com/squareup/objectgraph/Provides.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector;
+package com.squareup.objectgraph;
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
@@ -25,8 +25,8 @@
 
 /**
  * Annotates methods of a module to create a provider method binding. The
- * method's return type is bound to it's returned value. The injector will pass
- * dependencies to the method as parameters.
+ * method's return type is bound to it's returned value. The object graph will
+ * pass dependencies to the method as parameters.
  *
  * @author Bob Lee
  */
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/AtInjectBinding.java b/src/main/java/com/squareup/objectgraph/internal/AtInjectBinding.java
similarity index 99%
rename from src/main/java/com/squareup/injector/internal/AtInjectBinding.java
rename to src/main/java/com/squareup/objectgraph/internal/AtInjectBinding.java
index 2bc960d..886bdf6 100644
--- a/src/main/java/com/squareup/injector/internal/AtInjectBinding.java
+++ b/src/main/java/com/squareup/objectgraph/internal/AtInjectBinding.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector.internal;
+package com.squareup.objectgraph.internal;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Binding.java b/src/main/java/com/squareup/objectgraph/internal/Binding.java
similarity index 96%
rename from src/main/java/com/squareup/injector/internal/Binding.java
rename to src/main/java/com/squareup/objectgraph/internal/Binding.java
index bccc0ee..634bb25 100644
--- a/src/main/java/com/squareup/injector/internal/Binding.java
+++ b/src/main/java/com/squareup/objectgraph/internal/Binding.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector.internal;
+package com.squareup.objectgraph.internal;
 
-import com.squareup.injector.MembersInjector;
+import com.squareup.objectgraph.MembersInjector;
 import java.util.Set;
 import javax.inject.Provider;
 
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/BuiltInBinding.java b/src/main/java/com/squareup/objectgraph/internal/BuiltInBinding.java
similarity index 97%
rename from src/main/java/com/squareup/injector/internal/BuiltInBinding.java
rename to src/main/java/com/squareup/objectgraph/internal/BuiltInBinding.java
index 2b089e1..2e39a13 100644
--- a/src/main/java/com/squareup/injector/internal/BuiltInBinding.java
+++ b/src/main/java/com/squareup/objectgraph/internal/BuiltInBinding.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector.internal;
+package com.squareup.objectgraph.internal;
 
 import java.util.Set;
 
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Keys.java b/src/main/java/com/squareup/objectgraph/internal/Keys.java
similarity index 98%
rename from src/main/java/com/squareup/injector/internal/Keys.java
rename to src/main/java/com/squareup/objectgraph/internal/Keys.java
index 4aab693..e92c3b7 100644
--- a/src/main/java/com/squareup/injector/internal/Keys.java
+++ b/src/main/java/com/squareup/objectgraph/internal/Keys.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector.internal;
+package com.squareup.objectgraph.internal;
 
-import com.squareup.injector.MembersInjector;
+import com.squareup.objectgraph.MembersInjector;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.ParameterizedType;
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Linker.java b/src/main/java/com/squareup/objectgraph/internal/Linker.java
similarity index 97%
rename from src/main/java/com/squareup/injector/internal/Linker.java
rename to src/main/java/com/squareup/objectgraph/internal/Linker.java
index 0dbe48b..4e20ced 100644
--- a/src/main/java/com/squareup/injector/internal/Linker.java
+++ b/src/main/java/com/squareup/objectgraph/internal/Linker.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector.internal;
+package com.squareup.objectgraph.internal;
 
-import com.squareup.injector.ObjectGraph;
+import com.squareup.objectgraph.ObjectGraph;
 import java.lang.reflect.Constructor;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -44,7 +44,7 @@
   /** All errors encountered during injection. */
   private final List<String> errors = new ArrayList<String>();
 
-  /** All of the injector's bindings. This may contain unlinked bindings. */
+  /** All of the object graph's bindings. This may contain unlinked bindings. */
   private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
 
   /**
@@ -115,7 +115,7 @@
 
     if (!errors.isEmpty()) {
       StringBuilder message = new StringBuilder();
-      message.append("Errors creating injector:");
+      message.append("Errors creating object graph:");
       for (String error : errors) {
         message.append("\n  ").append(error);
       }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/LruCache.java b/src/main/java/com/squareup/objectgraph/internal/LruCache.java
similarity index 99%
rename from src/main/java/com/squareup/injector/internal/LruCache.java
rename to src/main/java/com/squareup/objectgraph/internal/LruCache.java
index f00d6c2..5cdfb99 100644
--- a/src/main/java/com/squareup/injector/internal/LruCache.java
+++ b/src/main/java/com/squareup/objectgraph/internal/LruCache.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector.internal;
+package com.squareup.objectgraph.internal;
 
 import java.util.LinkedHashMap;
 import java.util.Map;
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ModuleAdapter.java b/src/main/java/com/squareup/objectgraph/internal/ModuleAdapter.java
similarity index 95%
rename from src/main/java/com/squareup/injector/internal/ModuleAdapter.java
rename to src/main/java/com/squareup/objectgraph/internal/ModuleAdapter.java
index b1ffc9b..e1c59e4 100644
--- a/src/main/java/com/squareup/injector/internal/ModuleAdapter.java
+++ b/src/main/java/com/squareup/objectgraph/internal/ModuleAdapter.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector.internal;
+package com.squareup.objectgraph.internal;
 
-import com.squareup.injector.Module;
-import com.squareup.injector.ObjectGraph;
-import com.squareup.injector.Provides;
+import com.squareup.objectgraph.Module;
+import com.squareup.objectgraph.ObjectGraph;
+import com.squareup.objectgraph.Provides;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 import java.util.Map;
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ProblemDetector.java b/src/main/java/com/squareup/objectgraph/internal/ProblemDetector.java
similarity index 98%
rename from src/main/java/com/squareup/injector/internal/ProblemDetector.java
rename to src/main/java/com/squareup/objectgraph/internal/ProblemDetector.java
index 41127d9..3479fdf 100644
--- a/src/main/java/com/squareup/injector/internal/ProblemDetector.java
+++ b/src/main/java/com/squareup/objectgraph/internal/ProblemDetector.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector.internal;
+package com.squareup.objectgraph.internal;
 
 import java.util.Collection;
 import java.util.HashSet;
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java b/src/main/java/com/squareup/objectgraph/internal/ProviderMethodBinding.java
similarity index 97%
rename from src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
rename to src/main/java/com/squareup/objectgraph/internal/ProviderMethodBinding.java
index f475269..47d54c7 100644
--- a/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
+++ b/src/main/java/com/squareup/objectgraph/internal/ProviderMethodBinding.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector.internal;
+package com.squareup.objectgraph.internal;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationTargetException;
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/StaticInjection.java b/src/main/java/com/squareup/objectgraph/internal/StaticInjection.java
similarity index 97%
rename from src/main/java/com/squareup/injector/internal/StaticInjection.java
rename to src/main/java/com/squareup/objectgraph/internal/StaticInjection.java
index 93a8398..ec7b10b 100644
--- a/src/main/java/com/squareup/injector/internal/StaticInjection.java
+++ b/src/main/java/com/squareup/objectgraph/internal/StaticInjection.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector.internal;
+package com.squareup.objectgraph.internal;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/UniqueMap.java b/src/main/java/com/squareup/objectgraph/internal/UniqueMap.java
similarity index 96%
rename from src/main/java/com/squareup/injector/internal/UniqueMap.java
rename to src/main/java/com/squareup/objectgraph/internal/UniqueMap.java
index b369005..21d190f 100644
--- a/src/main/java/com/squareup/injector/internal/UniqueMap.java
+++ b/src/main/java/com/squareup/objectgraph/internal/UniqueMap.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector.internal;
+package com.squareup.objectgraph.internal;
 
 import java.util.LinkedHashMap;
 import java.util.Map;
/Fim/
diff --git a/src/main/java/com/squareup/codegen/CodeGen.java b/src/main/java/com/squareup/objectgraph/internal/codegen/CodeGen.java
similarity index 98%
rename from src/main/java/com/squareup/codegen/CodeGen.java
rename to src/main/java/com/squareup/objectgraph/internal/codegen/CodeGen.java
index bcdad2b..84db86c 100644
--- a/src/main/java/com/squareup/codegen/CodeGen.java
+++ b/src/main/java/com/squareup/objectgraph/internal/codegen/CodeGen.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.codegen;
+package com.squareup.objectgraph.internal.codegen;
 
-import com.squareup.injector.internal.Keys;
+import com.squareup.objectgraph.internal.Keys;
 import java.lang.reflect.Method;
 import java.util.LinkedHashMap;
 import java.util.List;
/Fim/
diff --git a/src/main/java/com/squareup/codegen/GeneratorKeys.java b/src/main/java/com/squareup/objectgraph/internal/codegen/GeneratorKeys.java
similarity index 98%
rename from src/main/java/com/squareup/codegen/GeneratorKeys.java
rename to src/main/java/com/squareup/objectgraph/internal/codegen/GeneratorKeys.java
index 3293299..e3cbad7 100644
--- a/src/main/java/com/squareup/codegen/GeneratorKeys.java
+++ b/src/main/java/com/squareup/objectgraph/internal/codegen/GeneratorKeys.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.codegen;
+package com.squareup.objectgraph.internal.codegen;
 
 import java.util.List;
 import java.util.Map;
/Fim/
diff --git a/src/main/java/com/squareup/codegen/InjectProcessor.java b/src/main/java/com/squareup/objectgraph/internal/codegen/InjectProcessor.java
similarity index 98%
rename from src/main/java/com/squareup/codegen/InjectProcessor.java
rename to src/main/java/com/squareup/objectgraph/internal/codegen/InjectProcessor.java
index 1671b26..5ddc116 100644
--- a/src/main/java/com/squareup/codegen/InjectProcessor.java
+++ b/src/main/java/com/squareup/objectgraph/internal/codegen/InjectProcessor.java
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.codegen;
+package com.squareup.objectgraph.internal.codegen;
 
-import com.squareup.injector.internal.Binding;
-import com.squareup.injector.internal.Linker;
+import com.squareup.objectgraph.internal.Binding;
+import com.squareup.objectgraph.internal.Linker;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.LinkedHashSet;
/Fim/
diff --git a/src/main/java/com/squareup/codegen/JavaWriter.java b/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
similarity index 99%
rename from src/main/java/com/squareup/codegen/JavaWriter.java
rename to src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
index 688e52e..ebe1067 100644
--- a/src/main/java/com/squareup/codegen/JavaWriter.java
+++ b/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.codegen;
+package com.squareup.objectgraph.internal.codegen;
 
 import java.io.IOException;
 import java.io.Writer;
/Fim/
diff --git a/src/main/java/com/squareup/codegen/ProvidesProcessor.java b/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java
similarity index 96%
rename from src/main/java/com/squareup/codegen/ProvidesProcessor.java
rename to src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java
index 2a82aeb..04d2c9e 100644
--- a/src/main/java/com/squareup/codegen/ProvidesProcessor.java
+++ b/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java
@@ -13,13 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.codegen;
+package com.squareup.objectgraph.internal.codegen;
 
-import com.squareup.injector.Module;
-import com.squareup.injector.Provides;
-import com.squareup.injector.internal.Binding;
-import com.squareup.injector.internal.Linker;
-import com.squareup.injector.internal.ModuleAdapter;
+import com.squareup.objectgraph.Module;
+import com.squareup.objectgraph.Provides;
+import com.squareup.objectgraph.internal.Binding;
+import com.squareup.objectgraph.internal.Linker;
+import com.squareup.objectgraph.internal.ModuleAdapter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -52,7 +52,7 @@
  * Generates an implementation of {@link ModuleAdapter} that includes a binding
  * for each {@code @Provides} method of a target class.
  */
-@SupportedAnnotationTypes("com.squareup.injector.Provides")
+@SupportedAnnotationTypes("com.squareup.objectgraph.Provides")
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class ProvidesProcessor extends AbstractProcessor {
   private static final String BINDINGS_MAP = CodeGen.parameterizedType(
/Fim/
diff --git a/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/src/main/resources/META-INF/services/javax.annotation.processing.Processor
index a453d47..31c0e88 100644
--- a/src/main/resources/META-INF/services/javax.annotation.processing.Processor
+++ b/src/main/resources/META-INF/services/javax.annotation.processing.Processor
@@ -1,2 +1,2 @@
-com.squareup.codegen.InjectProcessor
-com.squareup.codegen.ProvidesProcessor
+com.squareup.objectgraph.internal.codegen.InjectProcessor
+com.squareup.objectgraph.internal.codegen.ProvidesProcessor
/Fim/
diff --git a/src/test/java/com/squareup/injector/InjectStaticsTest.java b/src/test/java/com/squareup/objectgraph/InjectStaticsTest.java
similarity index 98%
rename from src/test/java/com/squareup/injector/InjectStaticsTest.java
rename to src/test/java/com/squareup/objectgraph/InjectStaticsTest.java
index 5a1f735..3bc7f71 100644
--- a/src/test/java/com/squareup/injector/InjectStaticsTest.java
+++ b/src/test/java/com/squareup/objectgraph/InjectStaticsTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector;
+package com.squareup.objectgraph;
 
 import javax.inject.Inject;
 import org.junit.Before;
/Fim/
diff --git a/src/test/java/com/squareup/injector/InjectionTest.java b/src/test/java/com/squareup/objectgraph/InjectionTest.java
similarity index 99%
rename from src/test/java/com/squareup/injector/InjectionTest.java
rename to src/test/java/com/squareup/objectgraph/InjectionTest.java
index 379f8e2..0452031 100644
--- a/src/test/java/com/squareup/injector/InjectionTest.java
+++ b/src/test/java/com/squareup/objectgraph/InjectionTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector;
+package com.squareup.objectgraph;
 
 import java.util.AbstractList;
 import java.util.Arrays;
/Fim/
diff --git a/src/test/java/com/squareup/injector/LazyInjectionTest.java b/src/test/java/com/squareup/objectgraph/LazyInjectionTest.java
similarity index 98%
rename from src/test/java/com/squareup/injector/LazyInjectionTest.java
rename to src/test/java/com/squareup/objectgraph/LazyInjectionTest.java
index 430acbd..5be487b 100644
--- a/src/test/java/com/squareup/injector/LazyInjectionTest.java
+++ b/src/test/java/com/squareup/objectgraph/LazyInjectionTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector;
+package com.squareup.objectgraph;
 
 import javax.inject.Inject;
 import org.junit.Test;
/Fim/
diff --git a/src/test/java/com/squareup/injector/MembersInjectorTest.java b/src/test/java/com/squareup/objectgraph/MembersInjectorTest.java
similarity index 97%
rename from src/test/java/com/squareup/injector/MembersInjectorTest.java
rename to src/test/java/com/squareup/objectgraph/MembersInjectorTest.java
index 962cfcc..4ecda2a 100644
--- a/src/test/java/com/squareup/injector/MembersInjectorTest.java
+++ b/src/test/java/com/squareup/objectgraph/MembersInjectorTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector;
+package com.squareup.objectgraph;
 
 import javax.inject.Inject;
 import javax.inject.Provider;
@@ -24,7 +24,7 @@
 import static org.junit.Assert.fail;
 
 /**
- * Tests MembersInjector injection, and how injector features interact with
+ * Tests MembersInjector injection, and how object graph features interact with
  * types unconstructable types (types that support members injection only).
  */
 @SuppressWarnings("unused")
/Fim/
diff --git a/src/test/java/com/squareup/injector/ProblemDetectorTest.java b/src/test/java/com/squareup/objectgraph/ProblemDetectorTest.java
similarity index 97%
rename from src/test/java/com/squareup/injector/ProblemDetectorTest.java
rename to src/test/java/com/squareup/objectgraph/ProblemDetectorTest.java
index 55a1b7b..a8d0ae5 100644
--- a/src/test/java/com/squareup/injector/ProblemDetectorTest.java
+++ b/src/test/java/com/squareup/objectgraph/ProblemDetectorTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector;
+package com.squareup.objectgraph;
 
 import javax.inject.Inject;
 import org.junit.Test;
/Fim/
diff --git a/src/test/java/com/squareup/injector/internal/KeysTest.java b/src/test/java/com/squareup/objectgraph/internal/KeysTest.java
similarity index 97%
rename from src/test/java/com/squareup/injector/internal/KeysTest.java
rename to src/test/java/com/squareup/objectgraph/internal/KeysTest.java
index 39a6b46..bb5e2ab 100644
--- a/src/test/java/com/squareup/injector/internal/KeysTest.java
+++ b/src/test/java/com/squareup/objectgraph/internal/KeysTest.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector.internal;
+package com.squareup.objectgraph.internal;
 
-import com.squareup.injector.MembersInjector;
+import com.squareup.objectgraph.MembersInjector;
 import java.lang.reflect.Field;
 import java.util.List;
 import java.util.Map;
/Fim/
diff --git a/src/test/java/com/squareup/codegen/JavaWriterTest.java b/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java
similarity index 99%
rename from src/test/java/com/squareup/codegen/JavaWriterTest.java
rename to src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java
index 379998f..365b322 100644
--- a/src/test/java/com/squareup/codegen/JavaWriterTest.java
+++ b/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.codegen;
+package com.squareup.objectgraph.internal.codegen;
 
 import java.io.IOException;
 import java.io.StringWriter;
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
new file mode 100644
index 0000000..596314e
--- /dev/null
+++ b/core/pom.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2012 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+        xmlns="http://maven.apache.org/POM/4.0.0"
+        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+        xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <groupId>com.squareup</groupId>
+        <artifactId>objectgraph-parent</artifactId>
+        <version>1.0-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
+    <artifactId>objectgraph</artifactId>
+    <packaging>jar</packaging>
+    <name>ObjectGraph</name>
+</project>
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/MembersInjector.java b/core/src/main/java/com/squareup/objectgraph/MembersInjector.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/MembersInjector.java
rename to core/src/main/java/com/squareup/objectgraph/MembersInjector.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/Module.java b/core/src/main/java/com/squareup/objectgraph/Module.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/Module.java
rename to core/src/main/java/com/squareup/objectgraph/Module.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/ObjectGraph.java b/core/src/main/java/com/squareup/objectgraph/ObjectGraph.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/ObjectGraph.java
rename to core/src/main/java/com/squareup/objectgraph/ObjectGraph.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/Provides.java b/core/src/main/java/com/squareup/objectgraph/Provides.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/Provides.java
rename to core/src/main/java/com/squareup/objectgraph/Provides.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/internal/AtInjectBinding.java b/core/src/main/java/com/squareup/objectgraph/internal/AtInjectBinding.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/internal/AtInjectBinding.java
rename to core/src/main/java/com/squareup/objectgraph/internal/AtInjectBinding.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/internal/Binding.java b/core/src/main/java/com/squareup/objectgraph/internal/Binding.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/internal/Binding.java
rename to core/src/main/java/com/squareup/objectgraph/internal/Binding.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/internal/BuiltInBinding.java b/core/src/main/java/com/squareup/objectgraph/internal/BuiltInBinding.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/internal/BuiltInBinding.java
rename to core/src/main/java/com/squareup/objectgraph/internal/BuiltInBinding.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/internal/Keys.java b/core/src/main/java/com/squareup/objectgraph/internal/Keys.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/internal/Keys.java
rename to core/src/main/java/com/squareup/objectgraph/internal/Keys.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/internal/Linker.java b/core/src/main/java/com/squareup/objectgraph/internal/Linker.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/internal/Linker.java
rename to core/src/main/java/com/squareup/objectgraph/internal/Linker.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/internal/LruCache.java b/core/src/main/java/com/squareup/objectgraph/internal/LruCache.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/internal/LruCache.java
rename to core/src/main/java/com/squareup/objectgraph/internal/LruCache.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/internal/ModuleAdapter.java b/core/src/main/java/com/squareup/objectgraph/internal/ModuleAdapter.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/internal/ModuleAdapter.java
rename to core/src/main/java/com/squareup/objectgraph/internal/ModuleAdapter.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/internal/ProblemDetector.java b/core/src/main/java/com/squareup/objectgraph/internal/ProblemDetector.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/internal/ProblemDetector.java
rename to core/src/main/java/com/squareup/objectgraph/internal/ProblemDetector.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/internal/ProviderMethodBinding.java b/core/src/main/java/com/squareup/objectgraph/internal/ProviderMethodBinding.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/internal/ProviderMethodBinding.java
rename to core/src/main/java/com/squareup/objectgraph/internal/ProviderMethodBinding.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/internal/StaticInjection.java b/core/src/main/java/com/squareup/objectgraph/internal/StaticInjection.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/internal/StaticInjection.java
rename to core/src/main/java/com/squareup/objectgraph/internal/StaticInjection.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/internal/UniqueMap.java b/core/src/main/java/com/squareup/objectgraph/internal/UniqueMap.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/internal/UniqueMap.java
rename to core/src/main/java/com/squareup/objectgraph/internal/UniqueMap.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/internal/codegen/CodeGen.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/CodeGen.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/internal/codegen/CodeGen.java
rename to core/src/main/java/com/squareup/objectgraph/internal/codegen/CodeGen.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/internal/codegen/GeneratorKeys.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/GeneratorKeys.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/internal/codegen/GeneratorKeys.java
rename to core/src/main/java/com/squareup/objectgraph/internal/codegen/GeneratorKeys.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/internal/codegen/InjectProcessor.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/InjectProcessor.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/internal/codegen/InjectProcessor.java
rename to core/src/main/java/com/squareup/objectgraph/internal/codegen/InjectProcessor.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
rename to core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
/Fim/
diff --git a/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java
similarity index 100%
rename from src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java
rename to core/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java
/Fim/
diff --git a/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/core/src/main/resources/META-INF/services/javax.annotation.processing.Processor
similarity index 100%
rename from src/main/resources/META-INF/services/javax.annotation.processing.Processor
rename to core/src/main/resources/META-INF/services/javax.annotation.processing.Processor
/Fim/
diff --git a/src/test/java/com/squareup/objectgraph/InjectStaticsTest.java b/core/src/test/java/com/squareup/objectgraph/InjectStaticsTest.java
similarity index 100%
rename from src/test/java/com/squareup/objectgraph/InjectStaticsTest.java
rename to core/src/test/java/com/squareup/objectgraph/InjectStaticsTest.java
/Fim/
diff --git a/src/test/java/com/squareup/objectgraph/InjectionTest.java b/core/src/test/java/com/squareup/objectgraph/InjectionTest.java
similarity index 100%
rename from src/test/java/com/squareup/objectgraph/InjectionTest.java
rename to core/src/test/java/com/squareup/objectgraph/InjectionTest.java
/Fim/
diff --git a/src/test/java/com/squareup/objectgraph/LazyInjectionTest.java b/core/src/test/java/com/squareup/objectgraph/LazyInjectionTest.java
similarity index 100%
rename from src/test/java/com/squareup/objectgraph/LazyInjectionTest.java
rename to core/src/test/java/com/squareup/objectgraph/LazyInjectionTest.java
/Fim/
diff --git a/src/test/java/com/squareup/objectgraph/MembersInjectorTest.java b/core/src/test/java/com/squareup/objectgraph/MembersInjectorTest.java
similarity index 100%
rename from src/test/java/com/squareup/objectgraph/MembersInjectorTest.java
rename to core/src/test/java/com/squareup/objectgraph/MembersInjectorTest.java
/Fim/
diff --git a/src/test/java/com/squareup/objectgraph/ProblemDetectorTest.java b/core/src/test/java/com/squareup/objectgraph/ProblemDetectorTest.java
similarity index 100%
rename from src/test/java/com/squareup/objectgraph/ProblemDetectorTest.java
rename to core/src/test/java/com/squareup/objectgraph/ProblemDetectorTest.java
/Fim/
diff --git a/src/test/java/com/squareup/objectgraph/internal/KeysTest.java b/core/src/test/java/com/squareup/objectgraph/internal/KeysTest.java
similarity index 100%
rename from src/test/java/com/squareup/objectgraph/internal/KeysTest.java
rename to core/src/test/java/com/squareup/objectgraph/internal/KeysTest.java
/Fim/
diff --git a/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java b/core/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java
similarity index 100%
rename from src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java
rename to core/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java
/Fim/
diff --git a/pom.xml b/pom.xml
index f3ad495..cf40f89 100644
--- a/pom.xml
+++ b/pom.xml
@@ -14,18 +14,23 @@
   See the License for the specific language governing permissions and
   limitations under the License.
 -->
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+<project
+        xmlns="http://maven.apache.org/POM/4.0.0"
+        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+        xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
     <modelVersion>4.0.0</modelVersion>
 
     <groupId>com.squareup</groupId>
-    <artifactId>objectgraph</artifactId>
+    <artifactId>objectgraph-parent</artifactId>
+    <packaging>pom</packaging>
     <version>1.0-SNAPSHOT</version>
-    <packaging>jar</packaging>
-
-    <name>ObjectGraph</name>
+    <name>ObjectGraph (Parent)</name>
     <description>A JSR-330 dependency injector for Android and Java.</description>
     <url>https://github.com/square/objectgraph</url>
 
+    <modules>
+        <module>core</module>
+    </modules>
 
     <properties>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
/Fim/
diff --git a/checkstyle.xml b/checkstyle.xml
index 79e74e8..5430c55 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -90,7 +90,7 @@
         <module name="CovariantEquals"/>
         <module name="DoubleCheckedLocking"/>
         <module name="EmptyStatement"/>
-        <module name="EqualsAvoidNull"/>
+        <!--<module name="EqualsAvoidNull"/>-->
         <module name="EqualsHashCode"/>
         <!--module name="HiddenField"/-->
         <module name="IllegalInstantiation"/>
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/Module.java b/core/src/main/java/com/squareup/objectgraph/Module.java
index 1e78f74..c93bfcd 100644
--- a/core/src/main/java/com/squareup/objectgraph/Module.java
+++ b/core/src/main/java/com/squareup/objectgraph/Module.java
@@ -30,10 +30,24 @@
   Class<?>[] staticInjections() default { };
 
   /**
-   * True if @Provides methods from this module are permitted to override those
-   * of other modules. This is a dangerous feature as it permits binding
-   * conflicts to go unnoticed. It should only be used in test and development
-   * modules.
+   * True if {@code @Provides} methods from this module are permitted to
+   * override those of other modules. This is a dangerous feature as it permits
+   * binding conflicts to go unnoticed. It should only be used in test and
+   * development modules.
    */
   boolean overrides() default false;
+
+  /**
+   * Additional {@code @Module}-annotated classes that this module is composed
+   * of. The contributions of the modules in {@code children}, and of their
+   * children recursively, are all contributed to the object graph.
+   */
+  Class<?>[] children() default { };
+
+  /**
+   * True if all of the bindings required by this module can also be satisfied
+   * by this module. If a module is complete it is eligible for additional
+   * static checking: tools can detect if required bindings are not available.
+   */
+  boolean complete() default false;
 }
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/ObjectGraph.java b/core/src/main/java/com/squareup/objectgraph/ObjectGraph.java
index b3a236e..c3a712a 100644
--- a/core/src/main/java/com/squareup/objectgraph/ObjectGraph.java
+++ b/core/src/main/java/com/squareup/objectgraph/ObjectGraph.java
@@ -23,6 +23,7 @@
 import com.squareup.objectgraph.internal.RuntimeLinker;
 import com.squareup.objectgraph.internal.StaticInjection;
 import com.squareup.objectgraph.internal.UniqueMap;
+import java.lang.reflect.Constructor;
 import java.util.Collection;
 import java.util.LinkedHashMap;
 import java.util.Map;
@@ -83,6 +84,7 @@
   }
 
   private static ObjectGraph get(boolean lazy, Object... modules) {
+    modules = getAllModules(modules);
     Map<String, Class<?>> entryPoints = new LinkedHashMap<String, Class<?>>();
     Map<Class<?>, StaticInjection> staticInjections
         = new LinkedHashMap<Class<?>, StaticInjection>();
@@ -121,6 +123,56 @@
     return result;
   }
 
+  /** Returns a full set of modules, including child modules. */
+  private static Object[] getAllModules(Object... modules) {
+    // TODO: move this work to ModuleAdapter to avoid runtime reflection.
+    Map<Class<?>, Object> modulesByType = new LinkedHashMap<Class<?>, Object>();
+
+    // First add all of the modules that we have instances for. This way we
+    // won't instantiate module types that the user has supplied.
+    for (Object module : modules) {
+      modulesByType.put(module.getClass(), module);
+    }
+
+    // Next add 'Class<?>' keys for the modules that we need to construct. This
+    // creates default instances when necessary.
+    for (Object module : modules) {
+      collectChildModulesRecursively(module.getClass(), modulesByType);
+    }
+
+    return modulesByType.values().toArray();
+  }
+
+  /**
+   * Fills {@code result} with the child modules of {@code c}, and their child
+   * modules recursively. Creates default instances for module types if
+   * necessary.
+   */
+  private static void collectChildModulesRecursively(Class<?> c, Map<Class<?>, Object> result) {
+    Module annotation = c.getAnnotation(Module.class);
+    if (annotation == null) {
+      throw new IllegalArgumentException("Expected @Module on " + c.getName());
+    }
+
+    for (Class<?> childClass : annotation.children()) {
+      if (!result.containsKey(childClass)) {
+        result.put(childClass, newInstance(childClass));
+        collectChildModulesRecursively(childClass, result);
+      }
+    }
+  }
+
+  /** Returns an instance of {@code c} by invoking its 0-arg constructor. */
+  private static Object newInstance(Class<?> c) {
+    try {
+      Constructor<?> childConstructor = c.getDeclaredConstructor();
+      childConstructor.setAccessible(true);
+      return childConstructor.newInstance();
+    } catch (Exception e) {
+      throw new IllegalArgumentException("Unable to instantiate " + c.getName(), e);
+    }
+  }
+
   private void linkStaticInjections() {
     for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
       StaticInjection staticInjection = entry.getValue();
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/AtInjectBinding.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/AtInjectBinding.java
index 82ce212..532244b 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/AtInjectBinding.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/codegen/AtInjectBinding.java
@@ -98,7 +98,7 @@
   }
 
   private static boolean hasAtInject(Element enclosed) {
-    return enclosed.getAnnotation(Inject.class) == null;
+    return enclosed.getAnnotation(Inject.class) != null;
   }
 
   @Override public void attach(Linker linker) {
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/BuildTimeLinker.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/BuildTimeLinker.java
index abe1d07..e166c31 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/BuildTimeLinker.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/codegen/BuildTimeLinker.java
@@ -17,7 +17,6 @@
 
 import com.squareup.objectgraph.internal.Binding;
 import com.squareup.objectgraph.internal.Linker;
-import java.util.ArrayList;
 import java.util.List;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.ElementKind;
@@ -33,20 +32,19 @@
 final class BuildTimeLinker extends Linker {
   private final ProcessingEnvironment processingEnv;
 
-  /** Classes the compiler was unable to introspect. */
-  private final List<String> unavailableClasses = new ArrayList<String>();
-
   BuildTimeLinker(ProcessingEnvironment processingEnv) {
     this.processingEnv = processingEnv;
   }
 
   @Override protected Binding<?> createAtInjectBinding(String key, String className) {
-    TypeElement type = processingEnv.getElementUtils().getTypeElement(className);
+    String sourceClassName = className.replace('$', '.');
+    TypeElement type = processingEnv.getElementUtils().getTypeElement(sourceClassName);
     if (type == null) {
-      // We've encountered a type that the compiler can't introspect. Remember
-      // the class name so we can warn about it later.
-      unavailableClasses.add(className);
-      return Binding.UNRESOLVED;
+      // We've encountered a type that the compiler can't introspect. If this
+      // causes problems in practice (due to incremental compiles, etc.) we
+      // should return a new unresolved binding and warn about the possibility
+      // of runtime failures.
+      return null;
     }
     if (type.getKind() == ElementKind.INTERFACE) {
       return null;
@@ -55,11 +53,6 @@
   }
 
   @Override protected void reportErrors(List<String> errors) {
-    if (!unavailableClasses.isEmpty()) {
-      String warning = String.format("%s and %d other classes were not available. Runtime failures "
-          + "are possible!", unavailableClasses.get(0), unavailableClasses.size() - 1);
-      processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING, warning);
-    }
     for (String error : errors) {
       processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, error);
     }
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java
index ca07f84..5ccf45d 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java
@@ -19,6 +19,7 @@
 import com.squareup.objectgraph.Provides;
 import com.squareup.objectgraph.internal.Binding;
 import com.squareup.objectgraph.internal.Linker;
+import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
@@ -32,6 +33,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
 
 /**
  * Performs full graph analysis on a module.
@@ -39,23 +41,39 @@
 @SupportedAnnotationTypes("com.squareup.objectgraph.Module")
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class FullGraphProcessor extends AbstractProcessor {
+  /**
+   * Perform full-graph analysis on complete modules. This checks that all of
+   * the module's dependencies are satisfied.
+   */
   @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
-    Linker linker = new BuildTimeLinker(processingEnv);
-
     for (Element moduleType : env.getElementsAnnotatedWith(Module.class)) {
       Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, moduleType);
+      if (annotation.get("complete").equals(Boolean.TRUE)) {
+        validateComplete((TypeElement) moduleType);
+      }
+    }
+    return true;
+  }
+
+  private void validateComplete(TypeElement rootModule) {
+    Map<String, TypeElement> allModules = new LinkedHashMap<String, TypeElement>();
+    collectChildModulesRecursively(rootModule, allModules);
+
+    Linker linker = new BuildTimeLinker(processingEnv);
+    for (TypeElement module : allModules.values()) {
+      Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
 
       // Gather the entry points from the annotation.
       for (Object entryPoint : (Object[]) annotation.get("entryPoints")) {
         linker.requestBinding(GeneratorKeys.rawMembersKey((TypeMirror) entryPoint),
-            ((TypeElement) moduleType).getQualifiedName().toString());
+            module.getQualifiedName().toString());
       }
 
       // Gather the static injections.
       // TODO.
 
       // Gather the enclosed @Provides methods.
-      for (Element enclosed : moduleType.getEnclosedElements()) {
+      for (Element enclosed : module.getEnclosedElements()) {
         if (enclosed.getAnnotation(Provides.class) == null) {
           continue;
         }
@@ -68,8 +86,19 @@
     // Link the bindings. This will traverse the dependency graph, and report
     // errors if any dependencies are missing.
     linker.linkAll();
+  }
 
-    return true;
+  private void collectChildModulesRecursively(TypeElement module, Map<String, TypeElement> result) {
+    // Add the module.
+    result.put(module.getQualifiedName().toString(), module);
+
+    // Recurse for each child module.
+    Types typeUtils = processingEnv.getTypeUtils();
+    Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
+    for (Object child : (Object[]) annotation.get("children")) {
+      TypeElement childModule = (TypeElement) typeUtils.asElement((TypeMirror) child);
+      collectChildModulesRecursively(childModule, result);
+    }
   }
 
   static class ProviderMethodBinding extends Binding<Object> {
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
index 14bf329..62d2bf3 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
@@ -257,7 +257,7 @@
   /**
    * Equivalent to {@code annotation(annotationType.getName(), attributes)}.
    */
-  public void annotation(Class<? extends Annotation> annotationType,Map<String, ?> attributes)
+  public void annotation(Class<? extends Annotation> annotationType, Map<String, ?> attributes)
       throws IOException {
     annotation(annotationType.getName(), attributes);
   }
/Fim/
diff --git a/core/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/core/src/main/resources/META-INF/services/javax.annotation.processing.Processor
index e81ca7b..58136b0 100644
--- a/core/src/main/resources/META-INF/services/javax.annotation.processing.Processor
+++ b/core/src/main/resources/META-INF/services/javax.annotation.processing.Processor
@@ -1,4 +1,3 @@
 com.squareup.objectgraph.internal.codegen.InjectProcessor
 com.squareup.objectgraph.internal.codegen.ProvidesProcessor
-# TODO: Enable full graph processing.
-#com.squareup.objectgraph.internal.codegen.FullGraphProcessor
\ No newline at end of file
+com.squareup.objectgraph.internal.codegen.FullGraphProcessor
\ No newline at end of file
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/ChildModuleTest.java b/core/src/test/java/com/squareup/objectgraph/ChildModuleTest.java
new file mode 100644
index 0000000..8f655f3
--- /dev/null
+++ b/core/src/test/java/com/squareup/objectgraph/ChildModuleTest.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2012 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.objectgraph;
+
+import javax.inject.Inject;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+@SuppressWarnings("unused")
+public final class ChildModuleTest {
+  static class TestEntryPoint {
+    @Inject String s;
+  }
+
+  @Module(entryPoints = TestEntryPoint.class)
+  static class ModuleWithEntryPoint {
+  }
+
+  @Test public void childModuleWithEntryPoint() {
+    @Module(children = ModuleWithEntryPoint.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.get(new TestModule());
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    objectGraph.inject(entryPoint);
+    assertThat(entryPoint.s).isEqualTo("injected");
+  }
+
+  static class TestStaticInjection {
+    @Inject static String s;
+  }
+
+  @Module(staticInjections = TestStaticInjection.class)
+  static class ModuleWithStaticInjection {
+  }
+
+  @Test public void childModuleWithStaticInjection() {
+    @Module(children = ModuleWithStaticInjection.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.get(new TestModule());
+    TestStaticInjection.s = null;
+    objectGraph.injectStatics();
+    assertThat(TestStaticInjection.s).isEqualTo("injected");
+  }
+
+  @Module
+  static class ModuleWithBinding {
+    @Provides String provideString() {
+      return "injected";
+    }
+  }
+
+  @Test public void childModuleWithBinding() {
+    class TestEntryPoint {
+      @Inject String s;
+    }
+
+    @Module(
+        entryPoints = TestEntryPoint.class,
+        children = ModuleWithBinding.class
+    )
+    class TestModule {
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.get(new TestModule());
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    objectGraph.inject(entryPoint);
+    assertThat(entryPoint.s).isEqualTo("injected");
+  }
+
+  @Module(children = ModuleWithBinding.class)
+  static class ModuleWithChildModule {
+  }
+
+  @Test public void childModuleWithChildModule() {
+    class TestEntryPoint {
+      @Inject String s;
+    }
+
+    @Module(
+        entryPoints = TestEntryPoint.class,
+        children = ModuleWithChildModule.class
+    )
+    class TestModule {
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.get(new TestModule());
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    objectGraph.inject(entryPoint);
+    assertThat(entryPoint.s).isEqualTo("injected");
+  }
+
+  @Module
+  static class ModuleWithConstructor {
+    private final String value;
+
+    ModuleWithConstructor(String value) {
+      this.value = value;
+    }
+
+    @Provides String provideString() {
+      return value;
+    }
+  }
+
+  @Test public void childModuleMissingManualConstruction() {
+    @Module(children = ModuleWithConstructor.class)
+    class TestModule {
+    }
+
+    try {
+      ObjectGraph.get(new TestModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void childModuleWithManualConstruction() {
+    class TestEntryPoint {
+      @Inject String s;
+    }
+
+    @Module(
+        entryPoints = TestEntryPoint.class,
+        children = ModuleWithConstructor.class
+    )
+    class TestModule {
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.get(new ModuleWithConstructor("a"), new TestModule());
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    objectGraph.inject(entryPoint);
+    assertThat(entryPoint.s).isEqualTo("a");
+  }
+}
/Fim/
diff --git a/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java b/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
index dc656da..e17dd7e 100644
--- a/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
+++ b/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
@@ -54,11 +54,19 @@
    * @param baseDir the directory where generated files are to be created.
    */
   public File path(Document manifest, String moduleName, File baseDir) {
-    String packageName = packageName(manifest);
+    String packageName = packageName(manifest, moduleName);
+    int dot = moduleName.lastIndexOf('.');
+    if (dot != -1) {
+      moduleName = moduleName.substring(dot + 1);
+    }
     return new File(baseDir, packageName.replace('.', '/') + "/" + moduleName + ".java");
   }
 
-  String packageName(Document manifest) {
+  String packageName(Document manifest, String moduleName) {
+    int dot = moduleName.lastIndexOf('.');
+    if (dot != -1) {
+      return moduleName.substring(0, dot);
+    }
     Element root = manifest.getDocumentElement();
     if (!root.getTagName().equals("manifest")) {
       throw new IllegalArgumentException("Expected <manifest> but was <" + root.getTagName() + ">");
@@ -71,14 +79,16 @@
   }
 
   public void generate(Document manifest, String moduleName, JavaWriter out) throws IOException {
-    String packageName = packageName(manifest);
+    String packageName = packageName(manifest, moduleName);
     List<String> nameReferences = getNameReferences(manifest);
     generate(packageName, nameReferences, moduleName, out);
   }
 
   void generate(String packageName, List<String> nameReferences, String moduleName, JavaWriter out)
       throws IOException {
-    String className = packageName + "." + moduleName;
+    String className = moduleName.contains(".")
+        ? moduleName
+        : packageName + "." + moduleName;
     out.addPackage(packageName);
     out.addImport(Module.class);
 
@@ -190,7 +200,8 @@
   private static void printUsage() {
     System.out.println("Usage: ModuleGenerator manifest module out");
     System.out.println("  manifest: path to AndroidManifest.xml");
-    System.out.println("    module: name of the generated class, like 'ManifestModule'");
+    System.out.println("    module: name of the generated class, like 'ActivitiesModule'.");
+    System.out.println("            May be fully-qualified like 'com.squareup.ActivitiesModule'.");
     System.out.println("       out: base directory for generated .java source files");
   }
 }
/Fim/
diff --git a/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java b/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java
index b6af824..2fbee77 100644
--- a/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java
+++ b/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java
@@ -20,6 +20,7 @@
 import java.io.StringReader;
 import java.io.StringWriter;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import org.junit.Test;
 import org.w3c.dom.Document;
@@ -63,13 +64,14 @@
         + "    android:versionCode=\"42\"\n"
         + "    android:versionName=\"42.0\">\n"
         + "</manifest>");
-    assertThat(generator.packageName(document)).isEqualTo("com.squareup.badhorse");
+    assertThat(generator.packageName(document, "ActivitiesModule"))
+        .isEqualTo("com.squareup.badhorse");
   }
 
   @Test public void packageNameWrongDocumentType() throws Exception {
     Document document = document("<html package=\"com.squareup.badhorse\"/>");
     try {
-      generator.packageName(document);
+      generator.packageName(document, "ActivitiesModule");
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -78,12 +80,18 @@
   @Test public void packageNameNoPackage() throws Exception {
     Document document = document("<manifest/>");
     try {
-      generator.packageName(document);
+      generator.packageName(document, "ActivitiesModule");
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
 
+  @Test public void packageNameUserSpecified() throws Exception {
+    Document document = document("<manifest package=\"com.squareup.badhorse\"/>");
+    assertThat(generator.packageName(document, "com.squareup.captainhammer.Module"))
+        .isEqualTo("com.squareup.captainhammer");
+  }
+
   @Test public void extractEntryPointNames() throws Exception {
     Document document = document(MANIFEST_XML);
     assertThat(generator.getNameReferences(document)).isEqualTo(Arrays.asList(
@@ -94,7 +102,8 @@
     String packageName = "com.squareup.badhorse";
     List<String> nameReferences = Arrays.asList(
         "com.squareup.badhorse.SinActivity", "com.squareup.badhorse.LeagueOfEvilActivity");
-    generator.generate(packageName, nameReferences, "ManifestModule", new JavaWriter(stringWriter));
+    generator.generate(packageName, nameReferences, "ActivitiesModule",
+        new JavaWriter(stringWriter));
     assertCode(""
         + "package com.squareup.badhorse;\n"
         + "import com.squareup.objectgraph.Module;\n"
@@ -104,7 +113,23 @@
         + "    com.squareup.badhorse.SinActivity.class\n"
         + "  }\n"
         + ")\n"
-        + "public final class ManifestModule {\n"
+        + "public final class ActivitiesModule {\n"
+        + "}\n");
+  }
+
+  @Test public void generateWithUserSpecifiedPackageName() throws IOException {
+    String packageName = "com.squareup.badhorse";
+    List<String> nameReferences = Collections.emptyList();
+    generator.generate(packageName, nameReferences, packageName + ".ActivitiesModule",
+        new JavaWriter(stringWriter));
+    assertCode(""
+        + "package com.squareup.badhorse;\n"
+        + "import com.squareup.objectgraph.Module;\n"
+        + "@Module(\n"
+        + "  entryPoints = {\n"
+        + "  }\n"
+        + ")\n"
+        + "public final class ActivitiesModule {\n"
         + "}\n");
   }
 
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java
index 0101eb3..ecf7f64 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java
@@ -118,6 +118,11 @@
     Types typeUtils = processingEnv.getTypeUtils();
     Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
     for (Object child : (Object[]) annotation.get("children")) {
+      if (!(child instanceof TypeMirror)) {
+        processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
+            "Unexpected value for child: " + child + " in " + module);
+        continue;
+      }
       TypeElement childModule = (TypeElement) typeUtils.asElement((TypeMirror) child);
       collectChildModulesRecursively(childModule, result);
     }
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java
index 1ec8350..db88bc3 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java
@@ -176,6 +176,11 @@
 
     StringBuilder childrenField = new StringBuilder().append("{ ");
     for (Object child : children) {
+      if (!(child instanceof TypeMirror)) {
+        processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
+            "Unexpected value: " + child + " in children attribute of " + type);
+        continue;
+      }
       TypeMirror typeMirror = (TypeMirror) child;
       childrenField.append(CodeGen.typeToString(typeMirror)).append(".class, ");
     }
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index dbc9996..2035c64 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -167,7 +167,7 @@
 
   private void linkEntryPoints() {
     for (Map.Entry<String, Class<?>> entry : entryPoints.entrySet()) {
-      linker.requestBinding(entry.getKey(), entry.getValue());
+      linker.requestEntryPoint(entry.getKey(), entry.getValue());
     }
   }
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/AtInjectBinding.java b/core/src/main/java/dagger/internal/AtInjectBinding.java
index c05c358..d9d545d 100644
--- a/core/src/main/java/dagger/internal/AtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/AtInjectBinding.java
@@ -135,11 +135,10 @@
   }
 
   /**
-   * @param forMembersInjection true if the binding is being created to inject
-   *     members only. Such injections do not require {@code @Inject}
+   * @param mustBeInjectable true if the binding must have {@code @Inject}
    *     annotations.
    */
-  public static <T> Binding<T> create(Class<T> type, boolean forMembersInjection) {
+  public static <T> Binding<T> create(Class<T> type, boolean mustBeInjectable) {
     boolean singleton = type.isAnnotationPresent(Singleton.class);
     List<String> keys = new ArrayList<String>();
 
@@ -170,7 +169,7 @@
       injectedConstructor = constructor;
     }
     if (injectedConstructor == null) {
-      if (injectedFields.isEmpty() && !forMembersInjection) {
+      if (injectedFields.isEmpty() && mustBeInjectable) {
         throw new IllegalArgumentException("No injectable members on " + type.getName()
             + ". Do you want to add an injectable constructor?");
       }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index c580225..8a63824 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -78,12 +78,14 @@
     Binding binding;
     while ((binding = toLink.poll()) != null) {
       if (binding instanceof DeferredBinding) {
-        String key = ((DeferredBinding<?>) binding).deferredKey;
+        DeferredBinding deferredBinding = (DeferredBinding) binding;
+        String key = deferredBinding.deferredKey;
+        boolean mustBeInjectable = deferredBinding.mustBeInjectable;
         if (bindings.containsKey(key)) {
           continue; // A binding for this key has since been linked.
         }
         try {
-          Binding<?> jitBinding = createJitBinding(key, binding.requiredBy);
+          Binding<?> jitBinding = createJitBinding(key, binding.requiredBy, mustBeInjectable);
           // Fail if the type of binding we got wasn't capable of what was requested.
           if (!key.equals(jitBinding.provideKey) && !key.equals(jitBinding.membersKey)) {
             throw new IllegalStateException("Unable to create binding for " + key);
@@ -126,7 +128,8 @@
    *   <li>Injections of other types will use the injectable constructors of those classes.
    * </ul>
    */
-  private Binding<?> createJitBinding(String key, Object requiredBy) throws ClassNotFoundException {
+  private Binding<?> createJitBinding(String key, Object requiredBy, boolean mustBeInjectable)
+      throws ClassNotFoundException {
     String builtInBindingsKey = Keys.getBuiltInBindingsKey(key);
     if (builtInBindingsKey != null) {
       return new BuiltInBinding<Object>(key, requiredBy, builtInBindingsKey);
@@ -138,7 +141,7 @@
 
     String className = Keys.getClassName(key);
     if (className != null && !Keys.isAnnotated(key)) {
-      Binding<?> atInjectBinding = createAtInjectBinding(key, className);
+      Binding<?> atInjectBinding = createAtInjectBinding(key, className, mustBeInjectable);
       if (atInjectBinding != null) {
         return atInjectBinding;
       }
@@ -151,8 +154,8 @@
    * Returns a binding that uses {@code @Inject} annotations, or null if no such
    * binding can be created.
    */
-  protected abstract Binding<?> createAtInjectBinding(String key, String className)
-      throws ClassNotFoundException;
+  protected abstract Binding<?> createAtInjectBinding(
+      String key, String className, boolean mustBeInjectable) throws ClassNotFoundException;
 
   /**
    * Returns the binding if it exists immediately. Otherwise this returns
@@ -160,10 +163,24 @@
    * enqueued to be linked.
    */
   public final Binding<?> requestBinding(String key, Object requiredBy) {
+    return requestBinding(key, true, requiredBy);
+  }
+
+  /**
+   * Like {@link #requestBinding}, but this doesn't require the referenced key
+   * to be injectable. This is necessary so that generic framework code can
+   * inject arbitrary entry points (like JUnit test cases or Android activities)
+   * without concern for whether the specific entry point is injectable.
+   */
+  public final Binding<?> requestEntryPoint(String key, Class<?> requiredByModule) {
+    return requestBinding(key, false, requiredByModule);
+  }
+
+  private Binding<?> requestBinding(String key, boolean mustBeInjectable, Object requiredBy) {
     Binding<?> binding = bindings.get(key);
     if (binding == null) {
       // We can't satisfy this binding. Make sure it'll work next time!
-      DeferredBinding<Object> deferredBinding = new DeferredBinding<Object>(key, requiredBy);
+      Binding<?> deferredBinding = new DeferredBinding(key, requiredBy, mustBeInjectable);
       toLink.add(deferredBinding);
       attachSuccess = false;
       return null;
@@ -264,11 +281,13 @@
     }
   }
 
-  private static class DeferredBinding<T> extends Binding<T> {
+  private static class DeferredBinding extends Binding<Object> {
     final String deferredKey;
-    private DeferredBinding(String deferredKey, Object requiredBy) {
+    final boolean mustBeInjectable;
+    private DeferredBinding(String deferredKey, Object requiredBy, boolean mustBeInjectable) {
       super(null, null, false, requiredBy);
       this.deferredKey = deferredKey;
+      this.mustBeInjectable = mustBeInjectable;
     }
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/RuntimeLinker.java b/core/src/main/java/dagger/internal/RuntimeLinker.java
index df92ac8..3ab5a22 100644
--- a/core/src/main/java/dagger/internal/RuntimeLinker.java
+++ b/core/src/main/java/dagger/internal/RuntimeLinker.java
@@ -23,8 +23,8 @@
  * and falls back to reflection.
  */
 public final class RuntimeLinker extends Linker {
-  @Override protected Binding<?> createAtInjectBinding(String key, String className)
-      throws ClassNotFoundException {
+  @Override protected Binding<?> createAtInjectBinding(
+      String key, String className, boolean mustBeInjectable) throws ClassNotFoundException {
     try {
       Class<?> c = Class.forName(className + "$InjectAdapter");
       Constructor<?> constructor = c.getConstructor();
@@ -40,7 +40,7 @@
       return null;
     }
 
-    return AtInjectBinding.create(c, Keys.isMembersInjection(key));
+    return AtInjectBinding.create(c, mustBeInjectable);
   }
 
   @Override protected void reportErrors(List<String> errors) {
@@ -52,6 +52,6 @@
     for (String error : errors) {
       message.append("\n  ").append(error);
     }
-    throw new IllegalArgumentException(message.toString());
+    throw new IllegalStateException(message.toString());
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/AtInjectBinding.java b/core/src/main/java/dagger/internal/codegen/AtInjectBinding.java
index a50170c..e2a3f9c 100644
--- a/core/src/main/java/dagger/internal/codegen/AtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/codegen/AtInjectBinding.java
@@ -44,11 +44,10 @@
   }
 
   /**
-   * @param forMembersInjection true if the binding is being created to inject
-   *     members only. Such injections do not require {@code @Inject}
+   * @param mustBeInjectable true if the binding must have {@code @Inject}
    *     annotations.
    */
-  static AtInjectBinding create(TypeElement type, boolean forMembersInjection) {
+  static AtInjectBinding create(TypeElement type, boolean mustBeInjectable) {
     List<String> requiredKeys = new ArrayList<String>();
     boolean hasInjectAnnotatedConstructor = false;
     boolean isConstructable = false;
@@ -87,7 +86,7 @@
       }
     }
 
-    if (!hasInjectAnnotatedConstructor && requiredKeys.isEmpty() && !forMembersInjection) {
+    if (!hasInjectAnnotatedConstructor && requiredKeys.isEmpty() && mustBeInjectable) {
       throw new IllegalArgumentException("No injectable members on "
           + type.getQualifiedName().toString() + ". Do you want to add an injectable constructor?");
     }
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/BuildTimeLinker.java b/core/src/main/java/dagger/internal/codegen/BuildTimeLinker.java
index 94610ad..a0c7808 100644
--- a/core/src/main/java/dagger/internal/codegen/BuildTimeLinker.java
+++ b/core/src/main/java/dagger/internal/codegen/BuildTimeLinker.java
@@ -16,7 +16,6 @@
 package dagger.internal.codegen;
 
 import dagger.internal.Binding;
-import dagger.internal.Keys;
 import dagger.internal.Linker;
 import java.util.List;
 import javax.annotation.processing.ProcessingEnvironment;
@@ -39,7 +38,8 @@
     this.moduleName = moduleName;
   }
 
-  @Override protected Binding<?> createAtInjectBinding(String key, String className) {
+  @Override protected Binding<?> createAtInjectBinding(
+      String key, String className, boolean mustBeInjectable) {
     String sourceClassName = className.replace('$', '.');
     TypeElement type = processingEnv.getElementUtils().getTypeElement(sourceClassName);
     if (type == null) {
@@ -52,7 +52,7 @@
     if (type.getKind() == ElementKind.INTERFACE) {
       return null;
     }
-    return AtInjectBinding.create(type, Keys.isMembersInjection(key));
+    return AtInjectBinding.create(type, mustBeInjectable);
   }
 
   @Override protected void reportErrors(List<String> errors) {
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index 9993e83..6de4fed 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -247,7 +247,7 @@
     try {
       graph.validate();
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (IllegalStateException expected) {
     }
   }
 
@@ -391,7 +391,7 @@
     try {
       graph.validate();
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (IllegalStateException expected) {
     }
   }
 
@@ -408,7 +408,7 @@
     try {
       graph.validate();
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (IllegalStateException expected) {
     }
   }
 
@@ -499,7 +499,7 @@
     try {
       graph.validate();
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (IllegalStateException expected) {
     }
   }
 
@@ -593,4 +593,31 @@
     graph.inject(membersInjected);
     assertEquals("Coke", membersInjected.s);
   }
+
+  static class NoInjections {
+  }
+
+  @Test public void entryPointNeedsNoInjectAnnotation() {
+    @Module(entryPoints = NoInjections.class)
+    class TestModule {
+    }
+
+    ObjectGraph.get(new TestModule()).validate();
+  }
+
+  @Test public void nonEntryPointNeedsInjectAnnotation() {
+    @Module
+    class TestModule {
+      @Provides String provideString(NoInjections noInjections) {
+        throw new AssertionError();
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    try {
+      graph.validate();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
 }
/Fim/
diff --git a/core/src/test/java/dagger/MembersInjectorTest.java b/core/src/test/java/dagger/MembersInjectorTest.java
index b48cb1b..767bfd0 100644
--- a/core/src/test/java/dagger/MembersInjectorTest.java
+++ b/core/src/test/java/dagger/MembersInjectorTest.java
@@ -94,7 +94,7 @@
     try {
       graph.getInstance(TestEntryPoint.class);
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (IllegalStateException expected) {
     }
   }
 
@@ -111,7 +111,7 @@
     try {
       graph.getInstance(TestEntryPoint.class);
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (IllegalStateException expected) {
     }
   }
 
@@ -128,7 +128,7 @@
     try {
       graph.getInstance(TestEntryPoint.class);
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (IllegalStateException expected) {
     }
   }
 
@@ -177,7 +177,7 @@
     try {
       graph.getInstance(TestEntryPoint.class);
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (IllegalStateException expected) {
     }
   }
 
/Fim/
diff --git a/androidmanifest/pom.xml b/androidmanifest/pom.xml
index 3916e36..f253ac1 100644
--- a/androidmanifest/pom.xml
+++ b/androidmanifest/pom.xml
@@ -62,4 +62,16 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-plugin-plugin</artifactId>
+        <configuration>
+          <goalPrefix>dagger</goalPrefix>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
/Fim/
diff --git a/pom.xml b/pom.xml
index 81edc56..ec0a86d 100644
--- a/pom.xml
+++ b/pom.xml
@@ -140,5 +140,15 @@
         </executions>
       </plugin>
     </plugins>
+
+    <pluginManagement>
+      <plugins>
+        <plugin>
+          <groupId>org.apache.maven.plugins</groupId>
+          <artifactId>maven-plugin-plugin</artifactId>
+          <version>2.8</version>
+        </plugin>
+      </plugins>
+    </pluginManagement>
   </build>
 </project>
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
index 272f631..9bc1740 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
@@ -96,10 +96,13 @@
     T result;
     try {
       result = constructor.newInstance(args);
+    } catch (InvocationTargetException e) {
+      Throwable cause = e.getCause();
+      throw cause instanceof RuntimeException
+          ? (RuntimeException) cause
+          : new RuntimeException(cause);
     } catch (IllegalAccessException e) {
       throw new AssertionError(e);
-    } catch (InvocationTargetException e) {
-      throw new RuntimeException(e.getCause());
     } catch (InstantiationException e) {
       throw new RuntimeException(e);
     }
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
index 60d6bd0..2d3efe8 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
@@ -132,10 +132,13 @@
       }
       try {
         return (T) method.invoke(instance, args);
+      } catch (InvocationTargetException e) {
+        Throwable cause = e.getCause();
+        throw cause instanceof RuntimeException
+            ? (RuntimeException) cause
+            : new RuntimeException(cause);
       } catch (IllegalAccessException e) {
         throw new RuntimeException(e);
-      } catch (InvocationTargetException e) {
-        throw new RuntimeException(e.getCause());
       }
     }
 
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index 40e1e6c..abd6c6b 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -689,4 +689,43 @@
     } catch (IllegalStateException expected) {
     }
   }
+
+  @Test public void runtimeProvidesMethodsExceptionsAreNotWrapped() {
+    class TestEntryPoint {
+      @Inject String string;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides String provideString() {
+        throw new ClassCastException("foo");
+      }
+    }
+
+    try {
+      ObjectGraph.create(new TestModule()).inject(new TestEntryPoint());
+      fail();
+    } catch (ClassCastException e) {
+      assertThat(e.getMessage()).isEqualTo("foo");
+    }
+  }
+
+  static class ThrowsOnConstruction {
+    @Inject ThrowsOnConstruction() {
+      throw new ClassCastException("foo");
+    }
+  }
+
+  @Test public void runtimeConstructorExceptionsAreNotWrapped() {
+    @Module(entryPoints = ThrowsOnConstruction.class)
+    class TestModule {
+    }
+
+    try {
+      ObjectGraph.create(new TestModule()).get(ThrowsOnConstruction.class);
+      fail();
+    } catch (ClassCastException e) {
+      assertThat(e.getMessage()).isEqualTo("foo");
+    }
+  }
 }
/Fim/
diff --git a/checkstyle.xml b/checkstyle.xml
index 2820b2a..4f5575c 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -14,6 +14,18 @@
         <property name="message" value="Line has trailing spaces."/>
     </module>
 
+    <!-- Space after 'for' and 'if' -->
+    <module name="RegexpSingleline">
+        <property name="format" value="^\s*(for|if)[^ ]"/>
+        <property name="message" value="Space needed before opening parenthesis."/>
+    </module>
+
+    <!-- For each spacing -->
+    <module name="RegexpSingleline">
+        <property name="format" value="^\s*for \(.*?([^ ]:|:[^ ])"/>
+        <property name="message" value="Space needed around ':' character."/>
+    </module>
+
     <module name="TreeWalker">
         <property name="cacheFile" value="${checkstyle.cache.file}"/>
 
@@ -51,20 +63,20 @@
         <module name="LineLength">
             <property name="max" value="100"/>
         </module>
-        <!--module name="MethodLength"/-->
+        <module name="MethodLength"/>
         <!--module name="ParameterNumber"/-->
 
 
         <!-- Checks for whitespace                               -->
         <!-- See http://checkstyle.sf.net/config_whitespace.html -->
         <module name="GenericWhitespace"/>
-        <!--<module name="EmptyForIteratorPad"/>-->
+        <module name="EmptyForIteratorPad"/>
         <module name="MethodParamPad"/>
         <module name="NoWhitespaceAfter"/>
         <module name="NoWhitespaceBefore"/>
         <module name="OperatorWrap"/>
         <module name="ParenPad"/>
-        <!--module name="TypecastParenPad"/-->
+        <module name="TypecastParenPad"/>
         <module name="WhitespaceAfter"/>
         <module name="WhitespaceAround"/>
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
index 59aae6b..978f3f7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
@@ -227,7 +227,7 @@
       type(name);
     }
     out.write("(");
-    for (int p = 0; p < parameters.length; ) {
+    for (int p = 0; p < parameters.length;) {
       if (p != 0) {
         out.write(", ");
       }
/Fim/
diff --git a/website/index.html b/website/index.html
index d8957e5..5aa5899 100644
--- a/website/index.html
+++ b/website/index.html
@@ -14,6 +14,8 @@
 
 <p>Dependency injection isn't just for testing. It also makes it easy to create <strong>reusable, interchangeable modules</strong>. You can share the same <code>AuthenticationModule</code>  across all of your apps. And you can run <code>DevLoggingModule</code> during development and <code>ProdLoggingModule</code> in production to get the right behavior in each situation.</p>
 
+<p>For more information, <a href="http://www.infoq.com/presentations/Dagger">watch an introductory talk</a> by Jesse Wilson at QCon 2012.</p>
+
 <h3>Using Dagger</h3>
 <p>We'll demonstrate dependency injection and Dagger by building a coffee maker. For complete sample code that you can compile and run, see Dagger's <a href="https://github.com/square/dagger/tree/master/example/src/main/java/coffee">coffee example</a>.</p>
 
/Fim/
diff --git a/website/static/app.css b/website/static/app.css
index 3c3f53a..9a479d1 100644
--- a/website/static/app.css
+++ b/website/static/app.css
@@ -68,7 +68,7 @@
 }
 
 a:link, a:visited, a:active, a:hover {
-    color: #72A4B4;
+    color: #89B8C7;
 }
 a:hover {
     text-decoration: underline;
/Fim/
