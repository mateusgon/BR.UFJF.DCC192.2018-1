diff --git a/README.md b/README.md
index 9a98c59..1f0bcf3 100644
--- a/README.md
+++ b/README.md
@@ -172,7 +172,7 @@
 
   public void brew() {
     while (needsGrinding()) {
-	  // Grinder created once on first call to .get() and cached.
+      // Grinder created once on first call to .get() and cached.
       lazyGrinder.get().grind();
     }
   }
@@ -181,7 +181,7 @@
 
 ### Provider injections
 
-Sometimes you need multiple instances to be returned instead of just injecting a single value.  In this case, if you are dealing with data objects (value objects) you might want to create and bind a Factory of some sort to manage these objects.  However, sometimes you need new instances of an object, e.g. if the object relies on volatile configuration and may change between calls.  In this case, you can inject a `Provider<T>` instead of just `T`, and you will get an object which creates a new instance each time `.get()` is called.
+Sometimes you need multiple instances to be returned instead of just injecting a single value.  While you have many options (Factories, Builders, etc.)   sometimes you need new instances of a collaborator if, for example, the object relies on volatile configuration or a piece of local context may change between calls.  In this case, you can inject a `Provider<T>` instead of just `T`, and you will get an object which creates a new instance each time `.get()` is called.
 
 ```java
 
@@ -200,7 +200,7 @@
 }
 ```
 
-***Note:*** *Generally, injecting Provider<T> is not preferred, as most cases should use a Factory or a Lazy<T>.  But it can be invaluable in cases where legacy architecture doesn't line up with your ObjectGraph's object lifetimes (e.g. servlets are singletons by design, but only are valid in the context of request-specfic data).*
+***Note:*** *Generally, injecting `Provider<T>` is not preferred, as most cases should use a `Factory<T>` or a `Lazy<T>` or re-organize the lifetimes and structure of your code to be able to just inject a `T`.  Injecting `Provider<T>` can, however, be invaluable in cases where legacy architecture doesn't line up with your ObjectGraph's object lifetimes (e.g. servlets are singletons by design, but only are valid in the context of request-specfic data).*
 
 ### Qualifiers
 
/Fim/
diff --git a/README.md b/README.md
index 1f0bcf3..be8b779 100644
--- a/README.md
+++ b/README.md
@@ -181,7 +181,7 @@
 
 ### Provider injections
 
-Sometimes you need multiple instances to be returned instead of just injecting a single value.  While you have many options (Factories, Builders, etc.)   sometimes you need new instances of a collaborator if, for example, the object relies on volatile configuration or a piece of local context may change between calls.  In this case, you can inject a `Provider<T>` instead of just `T`, and you will get an object which creates a new instance each time `.get()` is called.
+Sometimes you need multiple instances to be returned instead of just injecting a single value.  While you have several options (Factories, Builders, etc.)   one option is to inject a `Provider<T>` instead of just `T`.  A `Provider<T>` creates a new instance of `T` each time `.get()` is called.
 
 ```java
 
@@ -200,7 +200,7 @@
 }
 ```
 
-***Note:*** *Generally, injecting `Provider<T>` is not preferred, as most cases should use a `Factory<T>` or a `Lazy<T>` or re-organize the lifetimes and structure of your code to be able to just inject a `T`.  Injecting `Provider<T>` can, however, be invaluable in cases where legacy architecture doesn't line up with your ObjectGraph's object lifetimes (e.g. servlets are singletons by design, but only are valid in the context of request-specfic data).*
+***Note:*** *Injecting `Provider<T>` has the possibility of creating confusing code, and may be a design smell of mis-scoped or mis-structured objects in your graph.  Often you will want to use a `Factory<T>` or a `Lazy<T>` or re-organize the lifetimes and structure of your code to be able to just inject a `T`.  Injecting `Provider<T>` can, however, be a life saver in some cases.  A common use is when you must use a legacy architecture that doesn't line up with your object's natural lifetimes (e.g. servlets are singletons by design, but only are valid in the context of request-specfic data).*
 
 ### Qualifiers
 
/Fim/
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 0000000..1b2a751
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,17 @@
+Contributing
+============
+
+If you would like to contribute code to Dagger you can do so through GitHub by
+forking the repository and sending a pull request.
+
+When submitting code, please make every effort to follow existing conventions
+and style in order to keep the code as readable as possible. Please also make
+sure your code compiles by running `mvn clean verify`. Checkstyle failures
+during compilation indicate errors in your style and can be viewed in the
+`checkstyle-result.xml` file.
+
+Before your code can be accepted into the project you must also sign the
+[Individual Contributor License Agreement (CLA)][1].
+
+
+ [1]: https://spreadsheets.google.com/spreadsheet/viewform?formkey=dDViT2xzUHAwRkI3X3k5Z0lQM091OGc6MQ&ndplr=1
/Fim/
diff --git a/README.md b/README.md
index be8b779..9e7ed32 100644
--- a/README.md
+++ b/README.md
@@ -1,5 +1,5 @@
-ObjectGraph
-===========
+Dagger
+======
 
 A fast dependency injector for Android and Java.
 
@@ -9,7 +9,7 @@
 
 To contrast, the worst classes in any application are the ones that take up space without doing much at all: the `BarcodeDecoderFactory`, the `CameraServiceLoader`, and the `MutableContextWrapper`. These classes are the clumsy duct tape that wires the interesting stuff together.
 
-ObjectGraph is a replacement for these `FactoryFactory` classes. It allows you to focus on the interesting classes. Declare dependencies, specify how to satisfy them, and ship your app.
+Dagger is a replacement for these `FactoryFactory` classes. It allows you to focus on the interesting classes. Declare dependencies, specify how to satisfy them, and ship your app.
 
 By building on standard [javax.inject][1] annotations (JSR-330), each class is **easy to test**. You don't need a bunch of boilerplate just to swap the `RpcCreditCardService` out for a `FakeCreditCardService`.
 
@@ -17,9 +17,9 @@
 
 ### Declaring Dependencies
 
-ObjectGraph constructs instances of your application classes and satisfies their dependencies. It uses the `javax.inject.Inject` annotation to identify which constructors and fields it is interested in.
+Dagger constructs instances of your application classes and satisfies their dependencies. It uses the `javax.inject.Inject` annotation to identify which constructors and fields it is interested in.
 
-Use `@Inject` to annotate the constructor that ObjectGraph should use to create instances of a class. When a new instance is requested, ObjectGraph will obtain the required parameters values and invoke this constructor.
+Use `@Inject` to annotate the constructor that Dagger should use to create instances of a class. When a new instance is requested, Dagger will obtain the required parameters values and invoke this constructor.
 
 ```java
 class Thermosiphon implements Pump {
@@ -34,7 +34,7 @@
 }
 ```
 
-ObjectGraph can inject fields directly. In this example it obtains a `Heater` instance for the `heater` field and a `Pump` instance for the `pump` field.
+Dagger can inject fields directly. In this example it obtains a `Heater` instance for the `heater` field and a `Pump` instance for the `pump` field.
 
 ```java
 class CoffeeMaker {
@@ -45,13 +45,13 @@
 }
 ```
 
-If your class has `@Inject`-annotated fields but no `@Inject`-annotated constructor, ObjectGraph will use a no-argument constructor if it exists. Classes that lack `@Inject` annotations cannot be constructed by ObjectGraph.
+If your class has `@Inject`-annotated fields but no `@Inject`-annotated constructor, Dagger will use a no-argument constructor if it exists. Classes that lack `@Inject` annotations cannot be constructed by Dagger.
 
-ObjectGraph does not support method injection.
+Dagger does not support method injection.
 
 ### Satisfying Dependencies
 
-By default, ObjectGraph satisfies each dependency by constructing an instance of the requested type as described above. When you request a `CoffeeMaker`, it'll obtain one by calling `new CoffeeMaker()` and setting its injectable fields.
+By default, Dagger satisfies each dependency by constructing an instance of the requested type as described above. When you request a `CoffeeMaker`, it'll obtain one by calling `new CoffeeMaker()` and setting its injectable fields.
 
 But `@Inject` doesn't work everywhere:
 
@@ -245,7 +245,7 @@
 
 **Warning:** This feature should be used sparingly because static dependencies are difficult to test and reuse.
 
-ObjectGraph can inject static fields. Classes that declare static fields with `@Inject` annotations must be listed as `staticInjections` in a module annotation.
+Dagger can inject static fields. Classes that declare static fields with `@Inject` annotations must be listed as `staticInjections` in a module annotation.
 
 ```java
 @Module(
@@ -264,7 +264,7 @@
 
 ### Compile-time Validation
 
-ObjectGraph includes an [annotation processor][2] that validates modules and injections. This processor is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is missing a binding for `Executor`:
+Dagger includes an [annotation processor][2] that validates modules and injections. This processor is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is missing a binding for `Executor`:
 
 ```java
 @Module
@@ -278,7 +278,7 @@
 When compiling it, `javac` rejects the missing binding:
 
 ```
-[ERROR] COMPILATION ERROR : 
+[ERROR] COMPILATION ERROR :
 [ERROR] error: No binding for java.util.concurrent.Executor
                required by provideHeater(java.util.concurrent.Executor)
 ```
@@ -307,15 +307,15 @@
 }
 ```
 
-The annotation processor is enabled automatically when you include ObjectGraph's jar file on your compile classpath.
+The annotation processor is enabled automatically when you include Dagger's jar file on your compile classpath.
 
 ### Compile-time Code Generation
 
-ObjectGraph's annotation processor may also generate source files with names like `CoffeeMaker$InjectAdapter.java` or `DripCoffeeModule$ModuleAdapter`. These files are ObjectGraph implementation details. You shouldn't need to use them directly, though they can be handy when step-debugging through an injection.
+Dagger's annotation processor may also generate source files with names like `CoffeeMaker$InjectAdapter.java` or `DripCoffeeModule$ModuleAdapter`. These files are Dagger implementation details. You shouldn't need to use them directly, though they can be handy when step-debugging through an injection.
 
 ### Module overrides
 
-ObjectGraph will fail with an error if there are multiple competing `@Provides` methods for the same dependency. But sometimes it's necessary to replace production code with a substitute for development or testing. Using `overrides = true` in a module annotation lets you take precedence over the bindings of other modules.
+Dagger will fail with an error if there are multiple competing `@Provides` methods for the same dependency. But sometimes it's necessary to replace production code with a substitute for development or testing. Using `overrides = true` in a module annotation lets you take precedence over the bindings of other modules.
 
 This JUnit test overrides `DripCoffeeModule`'s binding for `Heater` with a mock object from [Mockito][3]. The mock gets injected into the `CoffeeMaker` and also into the test.
 
@@ -359,28 +359,12 @@
 Upgrading from Guice
 ====================
 
-Some notable Guice features that ObjectGraph doesn't support:
+Some notable Guice features that Dagger doesn't support:
 
-* Injecting `final` fields and `private` members. For best performance `ObjectGraph` generates code. Work around this by using constructor injection.
+* Injecting `final` fields and `private` members. For best performance Dagger generates code. Work around this by using constructor injection.
 * Eager singletons. Work around this by creating an `EagerSingletons` class that declares static fields for each eager singleton.
 * Method injection.
-* Classes that lack `@Inject` annotations cannot be constructed by ObjectGraph, even if they have a no-argument constructor.
-
-
-Contributing
-============
-
-If you would like to contribute code to ObjectGraph you can do so through
-GitHub by forking the repository and sending a pull request.
-
-When submitting code, please make every effort to follow existing conventions
-and style in order to keep the code as readable as possible. Please also make
-sure your code compiles by running `mvn clean verify`. Checkstyle failures
-during compilation indicate errors in your style and can be viewed in the
-`checkstyle-result.xml` file.
-
-Before your code can be accepted into the project you must also sign the
-[Individual Contributor License Agreement (CLA)][4].
+* Classes that lack `@Inject` annotations cannot be constructed by Dagger, even if they have a no-argument constructor.
 
 
 License
@@ -403,4 +387,3 @@
  [1]: http://atinject.googlecode.com/svn/trunk/javadoc/javax/inject/package-summary.html
  [2]: http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html
  [3]: http://mockito.googlecode.com/
- [4]: https://spreadsheets.google.com/spreadsheet/viewform?formkey=dDViT2xzUHAwRkI3X3k5Z0lQM091OGc6MQ&ndplr=1
/Fim/
diff --git a/androidmanifest/pom.xml b/androidmanifest/pom.xml
index 6a52004..2f8f492 100644
--- a/androidmanifest/pom.xml
+++ b/androidmanifest/pom.xml
@@ -20,19 +20,19 @@
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
     <modelVersion>4.0.0</modelVersion>
     <parent>
-        <groupId>com.squareup</groupId>
-        <artifactId>objectgraph-parent</artifactId>
+        <groupId>org.u2020</groupId>
+        <artifactId>dagger-parent</artifactId>
         <version>1.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
-    <artifactId>objectgraph-androidmanifest</artifactId>
+    <artifactId>dagger-androidmanifest</artifactId>
     <packaging>jar</packaging>
-    <name>ObjectGraph AndroidManifest.xml Module Generator</name>
+    <name>Dagger AndroidManifest.xml Module Generator</name>
 
     <dependencies>
         <dependency>
-            <groupId>com.squareup</groupId>
-            <artifactId>objectgraph</artifactId>
+            <groupId>org.u2020</groupId>
+            <artifactId>dagger</artifactId>
             <version>${project.version}</version>
         </dependency>
     </dependencies>
/Fim/
diff --git a/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
similarity index 95%
rename from androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
rename to androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
index 7c5e061..6a0e079 100644
--- a/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
+++ b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.androidmanifest;
+package dagger.androidmanifest;
 
-import com.squareup.objectgraph.Module;
-import com.squareup.objectgraph.internal.codegen.JavaWriter;
+import dagger.Module;
+import dagger.internal.codegen.JavaWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
@@ -47,7 +47,7 @@
  */
 public final class ModuleGenerator {
   private static final String ANDROID_NS = "http://schemas.android.com/apk/res/android";
-  private static final String OBJECTGRAPH_NS = "http://github.com/square/objectgraph";
+  private static final String DAGGER_NS = "https://github.com/u2020/dagger";
 
   /**
    * Returns the path of the generated ManifestModule.java for {@code manifest}.
@@ -141,7 +141,7 @@
           if (nameAttr == null) {
             throw new IllegalArgumentException("Expected a name attribute on " + ee);
           }
-          Attr entryPointAttr = ee.getAttributeNodeNS(OBJECTGRAPH_NS, "entryPoint");
+          Attr entryPointAttr = ee.getAttributeNodeNS(DAGGER_NS, "entryPoint");
           if (entryPointAttr != null && !Boolean.valueOf(entryPointAttr.getValue())) {
             continue;
           }
/Fim/
diff --git a/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java b/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
similarity index 92%
rename from androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java
rename to androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
index 8d3a64c..a6fc08f 100644
--- a/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java
+++ b/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.androidmanifest;
+package dagger.androidmanifest;
 
-import com.squareup.objectgraph.internal.codegen.JavaWriter;
+import dagger.internal.codegen.JavaWriter;
 import java.io.IOException;
 import java.io.StringReader;
 import java.io.StringWriter;
@@ -102,11 +102,11 @@
     String manifestXml = ""
         + "<manifest"
         + "    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n"
-        + "    xmlns:objectgraph=\"http://github.com/square/objectgraph\"\n"
+        + "    xmlns:dagger=\"https://github.com/u2020/dagger\"\n"
         + "    package=\"com.squareup.badhorse\">\n"
         + "  <application>\n"
-        + "    <activity android:name=\"false.Activity\" objectgraph:entryPoint=\"false\"/>\n"
-        + "    <activity android:name=\"true.Activity\" objectgraph:entryPoint=\"true\"/>\n"
+        + "    <activity android:name=\"false.Activity\" dagger:entryPoint=\"false\"/>\n"
+        + "    <activity android:name=\"true.Activity\" dagger:entryPoint=\"true\"/>\n"
         + "    <activity android:name=\"default.Activity\"/>\n"
         + "  </application>\n"
         + "</manifest>\n";
@@ -123,7 +123,7 @@
         new JavaWriter(stringWriter));
     assertCode(""
         + "package com.squareup.badhorse;\n"
-        + "import com.squareup.objectgraph.Module;\n"
+        + "import dagger.Module;\n"
         + "@Module(\n"
         + "  entryPoints = {\n"
         + "    com.squareup.badhorse.LeagueOfEvilActivity.class,\n"
@@ -142,7 +142,7 @@
         new JavaWriter(stringWriter));
     assertCode(""
         + "package com.squareup.badhorse;\n"
-        + "import com.squareup.objectgraph.Module;\n"
+        + "import dagger.Module;\n"
         + "@Module(\n"
         + "  entryPoints = {\n"
         + "  },\n"
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index e79a9c6..5f32219 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,14 +20,14 @@
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
     <modelVersion>4.0.0</modelVersion>
     <parent>
-        <groupId>com.squareup</groupId>
-        <artifactId>objectgraph-parent</artifactId>
+        <groupId>org.u2020</groupId>
+        <artifactId>dagger-parent</artifactId>
         <version>1.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
-    <artifactId>objectgraph</artifactId>
+    <artifactId>dagger</artifactId>
     <packaging>jar</packaging>
-    <name>ObjectGraph</name>
+    <name>Dagger</name>
 
     <build>
         <plugins>
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/Lazy.java b/core/src/main/java/dagger/Lazy.java
similarity index 96%
rename from core/src/main/java/com/squareup/objectgraph/Lazy.java
rename to core/src/main/java/dagger/Lazy.java
index ac61f60..df18973 100644
--- a/core/src/main/java/com/squareup/objectgraph/Lazy.java
+++ b/core/src/main/java/dagger/Lazy.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 /**
  * A value that is lazily returned. A {@code Lazy<T>} creates or obtains its underlying
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/MembersInjector.java b/core/src/main/java/dagger/MembersInjector.java
similarity index 97%
rename from core/src/main/java/com/squareup/objectgraph/MembersInjector.java
rename to core/src/main/java/dagger/MembersInjector.java
index 5712c7d..372c9f5 100644
--- a/core/src/main/java/com/squareup/objectgraph/MembersInjector.java
+++ b/core/src/main/java/dagger/MembersInjector.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 /**
  * Injects dependencies into the fields and methods on instances of type
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/Module.java b/core/src/main/java/dagger/Module.java
similarity index 81%
rename from core/src/main/java/com/squareup/objectgraph/Module.java
rename to core/src/main/java/dagger/Module.java
index 842d555..9f6e174 100644
--- a/core/src/main/java/com/squareup/objectgraph/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
@@ -38,13 +38,20 @@
   boolean overrides() default false;
 
   /**
-   * Additional {@code @Module}-annotated classes that this module is composed
-   * of. The contributions of the modules in {@code children}, and of their
-   * children recursively, are all contributed to the object graph.
+   * @deprecated Use module includes vs. children
    */
+  @Deprecated
   Class<?>[] children() default { };
 
   /**
+   * Additional {@code @Module}-annotated classes from which this module is
+   * composed. The de-duplicated contributions of the modules in
+   * {@code includes}, and of their inclusions recursively, are all contributed
+   * to the object graph.
+   */
+  Class<?>[] includes() default { };
+
+  /**
    * True if all of the bindings required by this module can also be satisfied
    * by this module. If a module is complete it is eligible for additional
    * static checking: tools can detect if required bindings are not available.
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
similarity index 88%
rename from core/src/main/java/com/squareup/objectgraph/ObjectGraph.java
rename to core/src/main/java/dagger/ObjectGraph.java
index 669544c..d61db8d 100644
--- a/core/src/main/java/com/squareup/objectgraph/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -13,16 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
-import com.squareup.objectgraph.internal.Binding;
-import com.squareup.objectgraph.internal.Keys;
-import com.squareup.objectgraph.internal.Linker;
-import com.squareup.objectgraph.internal.ModuleAdapter;
-import com.squareup.objectgraph.internal.ProblemDetector;
-import com.squareup.objectgraph.internal.RuntimeLinker;
-import com.squareup.objectgraph.internal.StaticInjection;
-import com.squareup.objectgraph.internal.UniqueMap;
+import dagger.internal.Binding;
+import dagger.internal.Keys;
+import dagger.internal.Linker;
+import dagger.internal.ModuleAdapter;
+import dagger.internal.ProblemDetector;
+import dagger.internal.RuntimeLinker;
+import dagger.internal.StaticInjection;
+import dagger.internal.UniqueMap;
 import java.util.Collection;
 import java.util.LinkedHashMap;
 import java.util.Map;
@@ -122,7 +122,7 @@
   }
 
   /**
-   * Returns a full set of module adapters, including module adapters for child
+   * Returns a full set of module adapters, including module adapters for included
    * modules.
    */
   private static ModuleAdapter<?>[] getAllModuleAdapters(Object[] seedModules) {
@@ -145,7 +145,7 @@
     // Next add adapters for the modules that we need to construct. This creates
     // instances of modules as necessary.
     for (ModuleAdapter<?> adapter : seedAdapters) {
-      collectChildModulesRecursively(adapter, adaptersByModuleType);
+      collectIncludedModulesRecursively(adapter, adaptersByModuleType);
     }
 
     return adaptersByModuleType.values().toArray(
@@ -153,16 +153,16 @@
   }
 
   /**
-   * Fills {@code result} with the module adapters for the children of {@code
-   * adapter}, and their children recursively.
+   * Fills {@code result} with the module adapters for the includes of {@code
+   * adapter}, and their includes recursively.
    */
-  private static void collectChildModulesRecursively(ModuleAdapter<?> adapter,
+  private static void collectIncludedModulesRecursively(ModuleAdapter<?> adapter,
       Map<Class<?>, ModuleAdapter<?>> result) {
-    for (Class<?> child : adapter.children) {
-      if (!result.containsKey(child)) {
-        ModuleAdapter<Object> childAdapter = ModuleAdapter.get(child, null);
-        result.put(child, childAdapter);
-        collectChildModulesRecursively(childAdapter, result);
+    for (Class<?> include : adapter.includes) {
+      if (!result.containsKey(include)) {
+        ModuleAdapter<Object> includedModuleAdapter = ModuleAdapter.get(include, null);
+        result.put(include, includedModuleAdapter);
+        collectIncludedModulesRecursively(includedModuleAdapter, result);
       }
     }
   }
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/Provides.java b/core/src/main/java/dagger/Provides.java
similarity index 96%
rename from core/src/main/java/com/squareup/objectgraph/Provides.java
rename to core/src/main/java/dagger/Provides.java
index d67ec33..629819b 100644
--- a/core/src/main/java/com/squareup/objectgraph/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/AtInjectBinding.java b/core/src/main/java/dagger/internal/AtInjectBinding.java
similarity index 99%
rename from core/src/main/java/com/squareup/objectgraph/internal/AtInjectBinding.java
rename to core/src/main/java/dagger/internal/AtInjectBinding.java
index f222d0c..c05c358 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/AtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/AtInjectBinding.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/Binding.java b/core/src/main/java/dagger/internal/Binding.java
similarity index 96%
rename from core/src/main/java/com/squareup/objectgraph/internal/Binding.java
rename to core/src/main/java/dagger/internal/Binding.java
index 634bb25..ac299ca 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/Binding.java
+++ b/core/src/main/java/dagger/internal/Binding.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
-import com.squareup.objectgraph.MembersInjector;
+import dagger.MembersInjector;
 import java.util.Set;
 import javax.inject.Provider;
 
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/BuiltInBinding.java b/core/src/main/java/dagger/internal/BuiltInBinding.java
similarity index 96%
rename from core/src/main/java/com/squareup/objectgraph/internal/BuiltInBinding.java
rename to core/src/main/java/dagger/internal/BuiltInBinding.java
index 2e39a13..8388190 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/BuiltInBinding.java
+++ b/core/src/main/java/dagger/internal/BuiltInBinding.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
 import java.util.Set;
 
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
similarity index 98%
rename from core/src/main/java/com/squareup/objectgraph/internal/Keys.java
rename to core/src/main/java/dagger/internal/Keys.java
index 1853033..606abce 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/Keys.java
+++ b/core/src/main/java/dagger/internal/Keys.java
@@ -14,10 +14,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
-import com.squareup.objectgraph.Lazy;
-import com.squareup.objectgraph.MembersInjector;
+import dagger.Lazy;
+import dagger.MembersInjector;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.ParameterizedType;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/LazyBinding.java b/core/src/main/java/dagger/internal/LazyBinding.java
similarity index 95%
rename from core/src/main/java/com/squareup/objectgraph/internal/LazyBinding.java
rename to core/src/main/java/dagger/internal/LazyBinding.java
index 369031b..44fabaf 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/LazyBinding.java
+++ b/core/src/main/java/dagger/internal/LazyBinding.java
@@ -14,9 +14,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
-import com.squareup.objectgraph.Lazy;
+import dagger.Lazy;
 
 /**
  * Injects a Lazy wrapper for a type T
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
similarity index 99%
rename from core/src/main/java/com/squareup/objectgraph/internal/Linker.java
rename to core/src/main/java/dagger/internal/Linker.java
index c29e6c4..c00570b 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
 import java.util.ArrayList;
 import java.util.Collection;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/LruCache.java b/core/src/main/java/dagger/internal/LruCache.java
similarity index 99%
rename from core/src/main/java/com/squareup/objectgraph/internal/LruCache.java
rename to core/src/main/java/dagger/internal/LruCache.java
index 5cdfb99..6ca5062 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/LruCache.java
+++ b/core/src/main/java/dagger/internal/LruCache.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
 import java.util.LinkedHashMap;
 import java.util.Map;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
similarity index 77%
rename from core/src/main/java/com/squareup/objectgraph/internal/ModuleAdapter.java
rename to core/src/main/java/dagger/internal/ModuleAdapter.java
index d44bfef..445e429 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
-import com.squareup.objectgraph.Module;
-import com.squareup.objectgraph.ObjectGraph;
-import com.squareup.objectgraph.Provides;
+import dagger.Module;
+import dagger.ObjectGraph;
+import dagger.Provides;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 import java.util.Map;
@@ -33,16 +33,16 @@
   public final String[] entryPoints;
   public final Class<?>[] staticInjections;
   public final boolean overrides;
-  public final Class<?>[] children;
+  public final Class<?>[] includes;
   public final boolean complete;
   protected T module;
 
   protected ModuleAdapter(String[] entryPoints, Class<?>[] staticInjections, boolean overrides,
-      Class<?>[] children, boolean complete) {
+      Class<?>[] includes, boolean complete) {
     this.entryPoints = entryPoints;
     this.staticInjections = staticInjections;
     this.overrides = overrides;
-    this.children = children;
+    this.includes = includes;
     this.complete = complete;
   }
 
@@ -91,12 +91,32 @@
   static class ReflectiveModuleAdapter extends ModuleAdapter<Object> {
     final Class<?> moduleClass;
 
+    @SuppressWarnings("deprecation") // explicitly handles deprecated case
     ReflectiveModuleAdapter(Class<?> moduleClass, Module annotation) {
-      super(toMemberKeys(annotation.entryPoints()), annotation.staticInjections(),
-          annotation.overrides(), annotation.children(), annotation.complete());
+      super(toMemberKeys(
+          annotation.entryPoints()),
+          annotation.staticInjections(),
+          annotation.overrides(),
+          concatenate(annotation.includes(), annotation.children()),
+          annotation.complete());
       this.moduleClass = moduleClass;
     }
 
+    /**
+     * Returns the concatenation of two {@code Class<T>[]}s.
+     *
+     * TODO(cgruber): Remove this method when module children are removed.
+     *
+     * @deprecated this method exists only to support a legacy deprecation case
+     */
+    @Deprecated
+    private static Class<?>[] concatenate(Class<?>[] first, Class<?>[] second) {
+      final Class<?>[] result = new Class<?>[second.length + first.length];
+      System.arraycopy(second, 0, result, 0, second.length);
+      System.arraycopy(first, 0, result, second.length, first.length);
+      return result;
+    }
+
     private static String[] toMemberKeys(Class<?>[] entryPoints) {
       String[] result = new String[entryPoints.length];
       for (int i = 0; i < entryPoints.length; i++) {
@@ -125,9 +145,9 @@
 
     @Override protected Object newModule() {
       try {
-        Constructor<?> childConstructor = moduleClass.getDeclaredConstructor();
-        childConstructor.setAccessible(true);
-        return childConstructor.newInstance();
+        Constructor<?> includeConstructor = moduleClass.getDeclaredConstructor();
+        includeConstructor.setAccessible(true);
+        return includeConstructor.newInstance();
       } catch (Exception e) {
         throw new IllegalArgumentException("Unable to instantiate " + moduleClass.getName(), e);
       }
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/ProblemDetector.java b/core/src/main/java/dagger/internal/ProblemDetector.java
similarity index 98%
rename from core/src/main/java/com/squareup/objectgraph/internal/ProblemDetector.java
rename to core/src/main/java/dagger/internal/ProblemDetector.java
index 3479fdf..0742bae 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/ProblemDetector.java
+++ b/core/src/main/java/dagger/internal/ProblemDetector.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
 import java.util.Collection;
 import java.util.HashSet;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/ProviderMethodBinding.java b/core/src/main/java/dagger/internal/ProviderMethodBinding.java
similarity index 97%
rename from core/src/main/java/com/squareup/objectgraph/internal/ProviderMethodBinding.java
rename to core/src/main/java/dagger/internal/ProviderMethodBinding.java
index 47d54c7..6c95705 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/ProviderMethodBinding.java
+++ b/core/src/main/java/dagger/internal/ProviderMethodBinding.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationTargetException;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/RuntimeLinker.java b/core/src/main/java/dagger/internal/RuntimeLinker.java
similarity index 89%
rename from core/src/main/java/com/squareup/objectgraph/internal/RuntimeLinker.java
rename to core/src/main/java/dagger/internal/RuntimeLinker.java
index a90ca9a..df92ac8 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/RuntimeLinker.java
+++ b/core/src/main/java/dagger/internal/RuntimeLinker.java
@@ -13,20 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
-import com.squareup.objectgraph.ObjectGraph;
 import java.lang.reflect.Constructor;
 import java.util.List;
-import java.util.logging.Logger;
 
 /**
  * Linker suitable for application use at runtime. This looks for generated code
  * and falls back to reflection.
  */
 public final class RuntimeLinker extends Linker {
-  private static final Logger LOGGER = Logger.getLogger(ObjectGraph.class.getName());
-
   @Override protected Binding<?> createAtInjectBinding(String key, String className)
       throws ClassNotFoundException {
     try {
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/StaticInjection.java b/core/src/main/java/dagger/internal/StaticInjection.java
similarity index 97%
rename from core/src/main/java/com/squareup/objectgraph/internal/StaticInjection.java
rename to core/src/main/java/dagger/internal/StaticInjection.java
index ec7b10b..19bea23 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/StaticInjection.java
+++ b/core/src/main/java/dagger/internal/StaticInjection.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/UniqueMap.java b/core/src/main/java/dagger/internal/UniqueMap.java
similarity index 96%
rename from core/src/main/java/com/squareup/objectgraph/internal/UniqueMap.java
rename to core/src/main/java/dagger/internal/UniqueMap.java
index 21d190f..04a42a7 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/UniqueMap.java
+++ b/core/src/main/java/dagger/internal/UniqueMap.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
 import java.util.LinkedHashMap;
 import java.util.Map;
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/ArrayUtil.java b/core/src/main/java/dagger/internal/codegen/ArrayUtil.java
new file mode 100644
index 0000000..4ab60f3
--- /dev/null
+++ b/core/src/main/java/dagger/internal/codegen/ArrayUtil.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2012 Google, Inc.
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+
+/**
+ * A utility to provide Array utilities above and beyond what are provided in the
+ * java.util.Arrays class.
+ */
+class ArrayUtil {
+  /**
+   * A class that returns the concatenation of two {@code Class<T>[]}s.
+   *
+   * TODO(cgruber): Remove this method when module children are removed if no other callers.
+   *
+   * @deprecated this method exists only to support a legacy deprecation case
+   */
+  @Deprecated
+  static Object[] concatenate(Object[] first, Object[] second) {
+    final Object[] result = new Object[second.length + first.length];
+    System.arraycopy(second, 0, result, 0, second.length);
+    System.arraycopy(first, 0, result, second.length, first.length);
+    return result;
+  }
+}
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/AtInjectBinding.java b/core/src/main/java/dagger/internal/codegen/AtInjectBinding.java
similarity index 96%
rename from core/src/main/java/com/squareup/objectgraph/internal/codegen/AtInjectBinding.java
rename to core/src/main/java/dagger/internal/codegen/AtInjectBinding.java
index 4f4a442..a50170c 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/AtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/codegen/AtInjectBinding.java
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
-import com.squareup.objectgraph.internal.Binding;
-import com.squareup.objectgraph.internal.Linker;
+import dagger.internal.Binding;
+import dagger.internal.Linker;
 import java.util.ArrayList;
 import java.util.List;
 import javax.inject.Inject;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/BuildTimeLinker.java b/core/src/main/java/dagger/internal/codegen/BuildTimeLinker.java
similarity index 91%
rename from core/src/main/java/com/squareup/objectgraph/internal/codegen/BuildTimeLinker.java
rename to core/src/main/java/dagger/internal/codegen/BuildTimeLinker.java
index 317dbfe..94610ad 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/BuildTimeLinker.java
+++ b/core/src/main/java/dagger/internal/codegen/BuildTimeLinker.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
-import com.squareup.objectgraph.internal.Binding;
-import com.squareup.objectgraph.internal.Keys;
-import com.squareup.objectgraph.internal.Linker;
+import dagger.internal.Binding;
+import dagger.internal.Keys;
+import dagger.internal.Linker;
 import java.util.List;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.ElementKind;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/CodeGen.java b/core/src/main/java/dagger/internal/codegen/CodeGen.java
similarity index 98%
rename from core/src/main/java/com/squareup/objectgraph/internal/codegen/CodeGen.java
rename to core/src/main/java/dagger/internal/codegen/CodeGen.java
index 020dd12..83a42cf 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/CodeGen.java
+++ b/core/src/main/java/dagger/internal/codegen/CodeGen.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
-import com.squareup.objectgraph.internal.Keys;
+import dagger.internal.Keys;
 import java.lang.reflect.Method;
 import java.util.LinkedHashMap;
 import java.util.List;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java b/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
similarity index 84%
rename from core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java
rename to core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 3230563..1fe6c45 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java
+++ b/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
-import com.squareup.objectgraph.Module;
-import com.squareup.objectgraph.Provides;
-import com.squareup.objectgraph.internal.Binding;
-import com.squareup.objectgraph.internal.Linker;
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.Binding;
+import dagger.internal.Linker;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
@@ -39,7 +39,7 @@
 /**
  * Performs full graph analysis on a module.
  */
-@SupportedAnnotationTypes("com.squareup.objectgraph.Module")
+@SupportedAnnotationTypes("dagger.Module")
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class FullGraphProcessor extends AbstractProcessor {
   /**
@@ -58,7 +58,7 @@
 
   private void validateComplete(TypeElement rootModule) {
     Map<String, TypeElement> allModules = new LinkedHashMap<String, TypeElement>();
-    collectChildModulesRecursively(rootModule, allModules);
+    collectIncludesRecursively(rootModule, allModules);
 
     Linker linker = new BuildTimeLinker(processingEnv, rootModule.getQualifiedName().toString());
     Map<String, ProviderMethodBinding> baseBindings
@@ -110,21 +110,25 @@
         + "." + method.getSimpleName() + "()";
   }
 
-  private void collectChildModulesRecursively(TypeElement module, Map<String, TypeElement> result) {
+  private void collectIncludesRecursively(TypeElement module, Map<String, TypeElement> result) {
     // Add the module.
     result.put(module.getQualifiedName().toString(), module);
 
-    // Recurse for each child module.
+    // Recurse for each included module.
     Types typeUtils = processingEnv.getTypeUtils();
     Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
-    for (Object child : (Object[]) annotation.get("children")) {
-      if (!(child instanceof TypeMirror)) {
+    @SuppressWarnings("deprecation") // Use known deprecated method. TODO(cgruber): remove.
+    Object[] includes = ArrayUtil.concatenate(
+        (Object[]) annotation.get("includes"),
+        (Object[]) annotation.get("children"));
+    for (Object include : includes) {
+      if (!(include instanceof TypeMirror)) {
         processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
-            "Unexpected value for child: " + child + " in " + module);
+            "Unexpected value for include: " + include + " in " + module);
         continue;
       }
-      TypeElement childModule = (TypeElement) typeUtils.asElement((TypeMirror) child);
-      collectChildModulesRecursively(childModule, result);
+      TypeElement includedModule = (TypeElement) typeUtils.asElement((TypeMirror) include);
+      collectIncludesRecursively(includedModule, result);
     }
   }
 
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/GeneratorKeys.java b/core/src/main/java/dagger/internal/codegen/GeneratorKeys.java
similarity index 98%
rename from core/src/main/java/com/squareup/objectgraph/internal/codegen/GeneratorKeys.java
rename to core/src/main/java/dagger/internal/codegen/GeneratorKeys.java
index 115ebdf..a16961a 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/GeneratorKeys.java
+++ b/core/src/main/java/dagger/internal/codegen/GeneratorKeys.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
 import java.util.List;
 import java.util.Map;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/InjectProcessor.java b/core/src/main/java/dagger/internal/codegen/InjectProcessor.java
similarity index 98%
rename from core/src/main/java/com/squareup/objectgraph/internal/codegen/InjectProcessor.java
rename to core/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 5ddc116..1b6de4d 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/InjectProcessor.java
+++ b/core/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
-import com.squareup.objectgraph.internal.Binding;
-import com.squareup.objectgraph.internal.Linker;
+import dagger.internal.Binding;
+import dagger.internal.Linker;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.LinkedHashSet;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java b/core/src/main/java/dagger/internal/codegen/JavaWriter.java
similarity index 99%
rename from core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
rename to core/src/main/java/dagger/internal/codegen/JavaWriter.java
index ad3b4db..fa0dce3 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
+++ b/core/src/main/java/dagger/internal/codegen/JavaWriter.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
 import java.io.IOException;
 import java.io.Writer;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java b/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
similarity index 91%
rename from core/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java
rename to core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 83d0586..acc2fcb 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java
+++ b/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -13,13 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
-import com.squareup.objectgraph.Module;
-import com.squareup.objectgraph.Provides;
-import com.squareup.objectgraph.internal.Binding;
-import com.squareup.objectgraph.internal.Linker;
-import com.squareup.objectgraph.internal.ModuleAdapter;
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.Binding;
+import dagger.internal.Linker;
+import dagger.internal.ModuleAdapter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -53,7 +53,7 @@
  * Generates an implementation of {@link ModuleAdapter} that includes a binding
  * for each {@code @Provides} method of a target class.
  */
-@SupportedAnnotationTypes("com.squareup.objectgraph.Provides")
+@SupportedAnnotationTypes("dagger.Provides")
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class ProvidesProcessor extends AbstractProcessor {
   private static final String BINDINGS_MAP = CodeGen.parameterizedType(
@@ -137,7 +137,11 @@
 
     Object[] staticInjections = (Object[]) module.get("staticInjections");
     Object[] entryPoints = (Object[]) module.get("entryPoints");
-    Object[] children = (Object[]) module.get("children");
+    @SuppressWarnings("deprecation") // use deprecated until children removed.
+    Object[] includes = ArrayUtil.concatenate(
+        (Object[]) module.get("includes"),
+        (Object[]) module.get("children"));
+
     boolean overrides = (Boolean) module.get("overrides");
     boolean complete = (Boolean) module.get("complete");
 
@@ -175,22 +179,22 @@
     writer.field("Class<?>[]", "STATIC_INJECTIONS", PRIVATE | STATIC | FINAL,
         staticInjectionsField.toString());
 
-    StringBuilder childrenField = new StringBuilder().append("{ ");
-    for (Object child : children) {
-      if (!(child instanceof TypeMirror)) {
+    StringBuilder includesField = new StringBuilder().append("{ ");
+    for (Object include : includes) {
+      if (!(include instanceof TypeMirror)) {
         processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
-            "Unexpected value: " + child + " in children attribute of " + type);
+            "Unexpected value: " + include + " in includes or children attribute of " + type);
         continue;
       }
-      TypeMirror typeMirror = (TypeMirror) child;
-      childrenField.append(CodeGen.typeToString(typeMirror)).append(".class, ");
+      TypeMirror typeMirror = (TypeMirror) include;
+      includesField.append(CodeGen.typeToString(typeMirror)).append(".class, ");
     }
-    childrenField.append("}");
-    writer.field("Class<?>[]", "CHILDREN", PRIVATE | STATIC | FINAL, childrenField.toString());
+    includesField.append("}");
+    writer.field("Class<?>[]", "INCLUDES", PRIVATE | STATIC | FINAL, includesField.toString());
 
     writer.beginMethod(null, adapterName, PUBLIC);
     writer.statement("super(ENTRY_POINTS, STATIC_INJECTIONS, %s /*overrides*/, "
-        + "CHILDREN, %s /*complete*/)", overrides, complete);
+        + "INCLUDES, %s /*complete*/)", overrides, complete);
     writer.endMethod();
 
     writer.annotation(Override.class);
/Fim/
diff --git a/core/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/core/src/main/resources/META-INF/services/javax.annotation.processing.Processor
index 58136b0..db38935 100644
--- a/core/src/main/resources/META-INF/services/javax.annotation.processing.Processor
+++ b/core/src/main/resources/META-INF/services/javax.annotation.processing.Processor
@@ -1,3 +1,3 @@
-com.squareup.objectgraph.internal.codegen.InjectProcessor
-com.squareup.objectgraph.internal.codegen.ProvidesProcessor
-com.squareup.objectgraph.internal.codegen.FullGraphProcessor
\ No newline at end of file
+dagger.internal.codegen.InjectProcessor
+dagger.internal.codegen.ProvidesProcessor
+dagger.internal.codegen.FullGraphProcessor
\ No newline at end of file
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/InjectStaticsTest.java b/core/src/test/java/dagger/InjectStaticsTest.java
similarity index 98%
rename from core/src/test/java/com/squareup/objectgraph/InjectStaticsTest.java
rename to core/src/test/java/dagger/InjectStaticsTest.java
index 3bc7f71..e26122f 100644
--- a/core/src/test/java/com/squareup/objectgraph/InjectStaticsTest.java
+++ b/core/src/test/java/dagger/InjectStaticsTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 import javax.inject.Inject;
 import org.junit.Before;
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/InjectionOfLazyTest.java b/core/src/test/java/dagger/InjectionOfLazyTest.java
similarity index 98%
rename from core/src/test/java/com/squareup/objectgraph/InjectionOfLazyTest.java
rename to core/src/test/java/dagger/InjectionOfLazyTest.java
index be06173..d969b21 100644
--- a/core/src/test/java/com/squareup/objectgraph/InjectionOfLazyTest.java
+++ b/core/src/test/java/dagger/InjectionOfLazyTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 import java.util.concurrent.atomic.AtomicInteger;
 import javax.inject.Inject;
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
similarity index 99%
rename from core/src/test/java/com/squareup/objectgraph/InjectionTest.java
rename to core/src/test/java/dagger/InjectionTest.java
index 0452031..18c2eee 100644
--- a/core/src/test/java/com/squareup/objectgraph/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 import java.util.AbstractList;
 import java.util.Arrays;
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/LazyInjectionTest.java b/core/src/test/java/dagger/LazyInjectionTest.java
similarity index 98%
rename from core/src/test/java/com/squareup/objectgraph/LazyInjectionTest.java
rename to core/src/test/java/dagger/LazyInjectionTest.java
index 5be487b..5a5890a 100644
--- a/core/src/test/java/com/squareup/objectgraph/LazyInjectionTest.java
+++ b/core/src/test/java/dagger/LazyInjectionTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 import javax.inject.Inject;
 import org.junit.Test;
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/MembersInjectorTest.java b/core/src/test/java/dagger/MembersInjectorTest.java
similarity index 99%
rename from core/src/test/java/com/squareup/objectgraph/MembersInjectorTest.java
rename to core/src/test/java/dagger/MembersInjectorTest.java
index 4ecda2a..e8d25c2 100644
--- a/core/src/test/java/com/squareup/objectgraph/MembersInjectorTest.java
+++ b/core/src/test/java/dagger/MembersInjectorTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 import javax.inject.Inject;
 import javax.inject.Provider;
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/ChildModuleTest.java b/core/src/test/java/dagger/ModuleIncludesTest.java
similarity index 69%
rename from core/src/test/java/com/squareup/objectgraph/ChildModuleTest.java
rename to core/src/test/java/dagger/ModuleIncludesTest.java
index 8f655f3..da6ce41 100644
--- a/core/src/test/java/com/squareup/objectgraph/ChildModuleTest.java
+++ b/core/src/test/java/dagger/ModuleIncludesTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 import javax.inject.Inject;
 import org.junit.Test;
@@ -22,7 +22,7 @@
 import static org.junit.Assert.fail;
 
 @SuppressWarnings("unused")
-public final class ChildModuleTest {
+public final class ModuleIncludesTest {
   static class TestEntryPoint {
     @Inject String s;
   }
@@ -32,7 +32,7 @@
   }
 
   @Test public void childModuleWithEntryPoint() {
-    @Module(children = ModuleWithEntryPoint.class)
+    @Module(includes = ModuleWithEntryPoint.class)
     class TestModule {
       @Provides String provideString() {
         return "injected";
@@ -54,7 +54,7 @@
   }
 
   @Test public void childModuleWithStaticInjection() {
-    @Module(children = ModuleWithStaticInjection.class)
+    @Module(includes = ModuleWithStaticInjection.class)
     class TestModule {
       @Provides String provideString() {
         return "injected";
@@ -81,7 +81,7 @@
 
     @Module(
         entryPoints = TestEntryPoint.class,
-        children = ModuleWithBinding.class
+        includes = ModuleWithBinding.class
     )
     class TestModule {
     }
@@ -92,7 +92,7 @@
     assertThat(entryPoint.s).isEqualTo("injected");
   }
 
-  @Module(children = ModuleWithBinding.class)
+  @Module(includes = ModuleWithBinding.class)
   static class ModuleWithChildModule {
   }
 
@@ -103,7 +103,7 @@
 
     @Module(
         entryPoints = TestEntryPoint.class,
-        children = ModuleWithChildModule.class
+        includes = ModuleWithChildModule.class
     )
     class TestModule {
     }
@@ -128,7 +128,7 @@
   }
 
   @Test public void childModuleMissingManualConstruction() {
-    @Module(children = ModuleWithConstructor.class)
+    @Module(includes = ModuleWithConstructor.class)
     class TestModule {
     }
 
@@ -146,7 +146,7 @@
 
     @Module(
         entryPoints = TestEntryPoint.class,
-        children = ModuleWithConstructor.class
+        includes = ModuleWithConstructor.class
     )
     class TestModule {
     }
@@ -156,4 +156,48 @@
     objectGraph.inject(entryPoint);
     assertThat(entryPoint.s).isEqualTo("a");
   }
+
+  // Legacy Tests //
+
+  @Test public void childrenButNoIncludes() {
+    class TestEntryPoint {
+      @Inject String s;
+    }
+    @Module(entryPoints = TestEntryPoint.class, children = ModuleWithBinding.class)
+    class TestModule {
+    }
+
+    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
+    assertThat(ep.s).isEqualTo("injected");
+  }
+
+  @Module(complete = false)
+  static class ModuleWithInteger {
+    @Provides Integer provideString() { return 1; }
+  }
+
+  @Test public void bothIncludesAndChildren() {
+    class TestEntryPoint {
+      @Inject String s;
+      @Inject Integer i;
+    }
+    @Module(
+        entryPoints = TestEntryPoint.class,
+        includes = ModuleWithInteger.class,
+        children = ModuleWithBinding.class)
+    class TestModule {
+    }
+
+    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
+    assertThat(ep.s).isEqualTo("injected");
+    assertThat(ep.i).isEqualTo(1);
+  }
+
+  private <T> T injectWithModule(T ep, Object ... modules) {
+    // TODO(cgruber): Make og.inject(foo) return foo properly.
+    ObjectGraph og = ObjectGraph.get(modules);
+    og.inject(ep);
+    return ep;
+  }
+
 }
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/ProblemDetectorTest.java b/core/src/test/java/dagger/ProblemDetectorTest.java
similarity index 96%
rename from core/src/test/java/com/squareup/objectgraph/ProblemDetectorTest.java
rename to core/src/test/java/dagger/ProblemDetectorTest.java
index a8d0ae5..3c68c6a 100644
--- a/core/src/test/java/com/squareup/objectgraph/ProblemDetectorTest.java
+++ b/core/src/test/java/dagger/ProblemDetectorTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 import javax.inject.Inject;
 import org.junit.Test;
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/internal/KeysTest.java b/core/src/test/java/dagger/internal/KeysTest.java
similarity index 97%
rename from core/src/test/java/com/squareup/objectgraph/internal/KeysTest.java
rename to core/src/test/java/dagger/internal/KeysTest.java
index b2425be..dd4a34d 100644
--- a/core/src/test/java/com/squareup/objectgraph/internal/KeysTest.java
+++ b/core/src/test/java/dagger/internal/KeysTest.java
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
-import com.squareup.objectgraph.Lazy;
-import com.squareup.objectgraph.MembersInjector;
+import dagger.Lazy;
+import dagger.MembersInjector;
 import java.lang.reflect.Field;
 import java.util.List;
 import java.util.Map;
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java b/core/src/test/java/dagger/internal/codegen/JavaWriterTest.java
similarity index 99%
rename from core/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java
rename to core/src/test/java/dagger/internal/codegen/JavaWriterTest.java
index ac414b4..5a10cfd 100644
--- a/core/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java
+++ b/core/src/test/java/dagger/internal/codegen/JavaWriterTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
 import java.io.IOException;
 import java.io.StringWriter;
/Fim/
diff --git a/example/pom.xml b/example/pom.xml
index e55ddc7..40d560f 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -20,19 +20,19 @@
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
     <modelVersion>4.0.0</modelVersion>
     <parent>
-        <groupId>com.squareup</groupId>
-        <artifactId>objectgraph-parent</artifactId>
+        <groupId>org.u2020</groupId>
+        <artifactId>dagger-parent</artifactId>
         <version>1.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
-    <artifactId>objectgraph-example</artifactId>
+    <artifactId>dagger-example</artifactId>
     <packaging>jar</packaging>
-    <name>ObjectGraph Example</name>
+    <name>Dagger Example</name>
 
     <dependencies>
         <dependency>
-            <groupId>com.squareup</groupId>
-            <artifactId>objectgraph</artifactId>
+            <groupId>org.u2020</groupId>
+            <artifactId>dagger</artifactId>
             <version>${project.version}</version>
         </dependency>
     </dependencies>
/Fim/
diff --git a/example/src/main/java/coffee/CoffeeApp.java b/example/src/main/java/coffee/CoffeeApp.java
index 831c9ff..aebbb3e 100644
--- a/example/src/main/java/coffee/CoffeeApp.java
+++ b/example/src/main/java/coffee/CoffeeApp.java
@@ -1,6 +1,6 @@
 package coffee;
 
-import com.squareup.objectgraph.ObjectGraph;
+import dagger.ObjectGraph;
 import javax.inject.Inject;
 
 class CoffeeApp implements Runnable {
/Fim/
diff --git a/example/src/main/java/coffee/CoffeeMaker.java b/example/src/main/java/coffee/CoffeeMaker.java
index 233917c..a4e8180 100644
--- a/example/src/main/java/coffee/CoffeeMaker.java
+++ b/example/src/main/java/coffee/CoffeeMaker.java
@@ -1,9 +1,8 @@
 package coffee;
 
+import dagger.Lazy;
 import javax.inject.Inject;
 
-import com.squareup.objectgraph.Lazy;
-
 class CoffeeMaker {
   @Inject Lazy<Heater> heater; // Don't want to create a possibly costly heater until we need it.
   @Inject Pump pump;
/Fim/
diff --git a/example/src/main/java/coffee/DripCoffeeModule.java b/example/src/main/java/coffee/DripCoffeeModule.java
index 9102afd..1b1d3fe 100644
--- a/example/src/main/java/coffee/DripCoffeeModule.java
+++ b/example/src/main/java/coffee/DripCoffeeModule.java
@@ -1,17 +1,15 @@
 package coffee;
 
-import com.squareup.objectgraph.Module;
-import com.squareup.objectgraph.Provides;
+import dagger.Module;
+import dagger.Provides;
 import javax.inject.Singleton;
 
 @Module(
-    entryPoints = CoffeeApp.class
+    entryPoints = CoffeeApp.class,
+    includes = PumpModule.class
 )
 class DripCoffeeModule {
   @Provides @Singleton Heater provideHeater() {
     return new ElectricHeater();
   }
-  @Provides Pump providePump(Thermosiphon pump) {
-    return pump;
-  }
 }
/Fim/
diff --git a/example/src/main/java/coffee/PumpModule.java b/example/src/main/java/coffee/PumpModule.java
new file mode 100644
index 0000000..3324b84
--- /dev/null
+++ b/example/src/main/java/coffee/PumpModule.java
@@ -0,0 +1,11 @@
+package coffee;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module(complete = false)
+class PumpModule {
+  @Provides Pump providePump(Thermosiphon pump) {
+    return pump;
+  }
+}
/Fim/
diff --git a/pom.xml b/pom.xml
index 6f7d9c2..842cd78 100644
--- a/pom.xml
+++ b/pom.xml
@@ -20,13 +20,13 @@
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
     <modelVersion>4.0.0</modelVersion>
 
-    <groupId>com.squareup</groupId>
-    <artifactId>objectgraph-parent</artifactId>
+    <groupId>org.u2020</groupId>
+    <artifactId>dagger-parent</artifactId>
     <packaging>pom</packaging>
     <version>1.0-SNAPSHOT</version>
-    <name>ObjectGraph (Parent)</name>
+    <name>Dagger (Parent)</name>
     <description>A JSR-330 dependency injector for Android and Java.</description>
-    <url>https://github.com/square/objectgraph</url>
+    <url>https://github.com/u2020/dagger</url>
 
     <modules>
         <module>core</module>
@@ -47,14 +47,14 @@
     </properties>
 
     <scm>
-        <url>http://github.com/square/objectgraph/</url>
-        <connection>scm:git:git://github.com/square/objectgraph.git</connection>
-        <developerConnection>scm:git:ssh://git@github.com/square/objectgraph.git</developerConnection>
+        <url>http://github.com/u2020/dagger/</url>
+        <connection>scm:git:git://github.com/u2020/dagger.git</connection>
+        <developerConnection>scm:git:ssh://git@github.com/u2020/dagger.git</developerConnection>
     </scm>
 
     <issueManagement>
         <system>GitHub Issues</system>
-        <url>http://github.com/square/objectgraph/issues</url>
+        <url>http://github.com/u2020/dagger/issues</url>
     </issueManagement>
 
     <licenses>
@@ -90,7 +90,7 @@
     </dependencies>
 
     <build>
-        <finalName>square-${project.artifactId}-${project.version}</finalName>
+        <finalName>u2020-${project.artifactId}-${project.version}</finalName>
 
         <plugins>
             <plugin>
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index d61db8d..0dfa389 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -73,16 +73,12 @@
    * <p>This <strong>does not</strong> inject any members. Most applications
    * should call {@link #injectStatics} to inject static members and/or {@link
    * #inject} to inject instance members when this method has returned.
+   *
+   * <p>This <strong>does not</strong> validate the graph. Rely on build time
+   * tools for graph validation, or call {@link #validate} to find problems in
+   * the graph at runtime.
    */
   public static ObjectGraph get(Object... modules) {
-    return get(false, modules);
-  }
-
-  public static ObjectGraph getLazy(Object... modules) {
-    return get(true, modules);
-  }
-
-  private static ObjectGraph get(boolean lazy, Object... modules) {
     ModuleAdapter<?>[] moduleAdapters = getAllModuleAdapters(modules);
 
     Map<String, Class<?>> entryPoints = new LinkedHashMap<String, Class<?>>();
@@ -98,7 +94,7 @@
         entryPoints.put(key, adapter.getModule().getClass());
       }
       for (Class<?> c : adapter.staticInjections) {
-        staticInjections.put(c, lazy ? null : StaticInjection.get(c));
+        staticInjections.put(c, null);
       }
       Map<String, Binding<?>> addTo = adapter.overrides ? overrideBindings : baseBindings;
       adapter.getBindings(addTo);
@@ -110,14 +106,6 @@
     linker.installBindings(overrideBindings);
 
     ObjectGraph result = new ObjectGraph(linker, staticInjections, entryPoints);
-
-    // Link all bindings (unless this object graph is lazy).
-    if (!lazy) {
-      result.linkStaticInjections();
-      result.linkEntryPoints();
-      linker.linkAll();
-    }
-
     return result;
   }
 
@@ -185,9 +173,12 @@
   }
 
   /**
-   * Do full graph problem detection.
+   * Do runtime graph problem detection. For fastest graph creation, rely on
+   * build time tools for graph validation.
+   *
+   * @throws IllegalStateException if this graph has problems.
    */
-  public void detectProblems() {
+  public void validate() {
     linkStaticInjections();
     linkEntryPoints();
     Collection<Binding<?>> allBindings = linker.linkAll();
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index 18c2eee..53bc71a 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -241,8 +241,9 @@
     class TestModule {
     }
 
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
     try {
-      ObjectGraph.get(new TestModule());
+      graph.validate();
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -384,8 +385,9 @@
     class TestModule {
     }
 
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
     try {
-      ObjectGraph.get(new TestModule());
+      graph.validate();
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -400,8 +402,9 @@
     class TestModule {
     }
 
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
     try {
-      ObjectGraph.get(new TestModule());
+      graph.validate();
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -490,8 +493,9 @@
       }
     }
 
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
     try {
-      ObjectGraph.get(new TestModule());
+      graph.validate();
       fail();
     } catch (IllegalArgumentException expected) {
     }
/Fim/
diff --git a/core/src/test/java/dagger/LazyInjectionTest.java b/core/src/test/java/dagger/LazyInjectionTest.java
index 5a5890a..a16e1a9 100644
--- a/core/src/test/java/dagger/LazyInjectionTest.java
+++ b/core/src/test/java/dagger/LazyInjectionTest.java
@@ -26,7 +26,7 @@
     class TestModule {
     }
 
-    ObjectGraph.getLazy(new TestModule());
+    ObjectGraph.get(new TestModule());
     assertThat(lazyEntryPointLoaded).isFalse();
   }
 
@@ -45,7 +45,7 @@
       }
     }
 
-    ObjectGraph.getLazy(new TestModule());
+    ObjectGraph.get(new TestModule());
     assertThat(lazyProvidesParameterLoaded).isFalse();
   }
 
@@ -64,7 +64,7 @@
       }
     }
 
-    ObjectGraph.getLazy(new TestModule());
+    ObjectGraph.get(new TestModule());
     assertThat(lazyProvidesResultLoaded).isFalse();
   }
 
@@ -80,7 +80,7 @@
     class TestModule {
     }
 
-    ObjectGraph.getLazy(new TestModule());
+    ObjectGraph.get(new TestModule());
     assertThat(LazyInjectStaticsLoaded).isFalse();
   }
 
@@ -106,7 +106,7 @@
       }
     }
 
-    ObjectGraph objectGraph = ObjectGraph.getLazy(new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.get(new TestModule());
     TestEntryPoint entryPoint = new TestEntryPoint();
     objectGraph.inject(entryPoint);
     assertThat(entryPoint.injected).isEqualTo("5");
/Fim/
diff --git a/core/src/test/java/dagger/MembersInjectorTest.java b/core/src/test/java/dagger/MembersInjectorTest.java
index e8d25c2..e7b913f 100644
--- a/core/src/test/java/dagger/MembersInjectorTest.java
+++ b/core/src/test/java/dagger/MembersInjectorTest.java
@@ -90,8 +90,9 @@
     class TestModule {
     }
 
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
     try {
-      ObjectGraph.get(new TestModule());
+      graph.inject(new TestEntryPoint());
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -106,8 +107,9 @@
     class TestModule {
     }
 
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
     try {
-      ObjectGraph.get(new TestModule());
+      graph.inject(new TestEntryPoint());
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -122,8 +124,9 @@
     class TestModule {
     }
 
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
     try {
-      ObjectGraph.get(new TestModule());
+      graph.inject(new TestEntryPoint());
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -170,8 +173,9 @@
     class TestModule {
     }
 
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
     try {
-      ObjectGraph.get(new TestModule());
+      graph.inject(new TestEntryPoint());
       fail();
     } catch (IllegalArgumentException expected) {
     }
/Fim/
diff --git a/core/src/test/java/dagger/ProblemDetectorTest.java b/core/src/test/java/dagger/ProblemDetectorTest.java
index 3c68c6a..ed01721 100644
--- a/core/src/test/java/dagger/ProblemDetectorTest.java
+++ b/core/src/test/java/dagger/ProblemDetectorTest.java
@@ -32,7 +32,7 @@
 
     ObjectGraph graph = ObjectGraph.get(new TestModule());
     try {
-      graph.detectProblems();
+      graph.validate();
       fail();
     } catch (RuntimeException expected) {
     }
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/CodeGen.java b/core/src/main/java/dagger/internal/codegen/CodeGen.java
index 3d50c9d..f941070 100644
--- a/core/src/main/java/dagger/internal/codegen/CodeGen.java
+++ b/core/src/main/java/dagger/internal/codegen/CodeGen.java
@@ -17,6 +17,7 @@
 
 import dagger.internal.Keys;
 import java.lang.reflect.Method;
+import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -183,6 +184,13 @@
           : annotation.getElementValues().entrySet()) {
         String name = e.getKey().getSimpleName().toString();
         Object value = e.getValue().accept(VALUE_EXTRACTOR, null);
+        Object defaultValue = result.get(name);
+        if (!lenientIsInstance(defaultValue.getClass(), value)) {
+          throw new IllegalStateException(String.format(
+              "Value of %s.%s is a %s but expected a %s\n    value: %s",
+              annotationType, name, value.getClass().getName(), defaultValue.getClass().getName(),
+              value instanceof Object[] ? Arrays.toString((Object[]) value) : value));
+        }
         result.put(name, value);
       }
       return result;
@@ -191,6 +199,27 @@
     return null; // Annotation not found.
   }
 
+  /**
+   * Returns true if {@code value} can be assigned to {@code expectedClass}.
+   * Like {@link Class#isInstance} but more lenient for {@code Class<?>} values.
+   */
+  private static boolean lenientIsInstance(Class<?> expectedClass, Object value) {
+    if (expectedClass.isArray()) {
+      Class<?> componentType = expectedClass.getComponentType();
+      if (!(value instanceof Object[])) {
+        return false;
+      }
+      for (Object element : (Object[]) value) {
+        if (!lenientIsInstance(componentType, element)) return false;
+      }
+      return true;
+    } else if (expectedClass == Class.class) {
+      return value instanceof TypeMirror;
+    } else {
+      return expectedClass == value.getClass();
+    }
+  }
+
   static void rawTypeToString(StringBuilder result, TypeElement type,
       char innerClassSeparator) {
     String packageName = getPackage(type).getQualifiedName().toString();
/Fim/
diff --git a/README.md b/README.md
index 9e7ed32..5e2aa27 100644
--- a/README.md
+++ b/README.md
@@ -102,7 +102,7 @@
 ObjectGraph objectGraph = ObjectGraph.get(new DripCoffeeModule());
 ```
 
-In order to put the graph to use we need to create an **entry point**. This is usually the main class that starts the application. In this example, the `CoffeeApp` class serves as the entry point. We construct an instance of this type and then ask the object graph to inject its fields.
+In order to put the graph to use we need to create an **entry point**. This is usually the main class that starts the application. In this example, the `CoffeeApp` class serves as the entry point. We ask the graph to provide an injected instance of this type:
 
 ```java
 class CoffeeApp implements Runnable {
@@ -114,8 +114,7 @@
 
   public static void main(String[] args) {
     ObjectGraph objectGraph = ObjectGraph.get(new DripCoffeeModule());
-    CoffeeApp coffeeApp = new CoffeeApp();
-    objectGraph.inject(coffeeApp);
+    CoffeeApp coffeeApp = objectGraph.getInstance(CoffeeApp.class);
     ...
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index c4bf664..dbc9996 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -105,8 +105,7 @@
     linker.installBindings(baseBindings);
     linker.installBindings(overrideBindings);
 
-    ObjectGraph result = new ObjectGraph(linker, staticInjections, entryPoints);
-    return result;
+    return new ObjectGraph(linker, staticInjections, entryPoints);
   }
 
   /**
@@ -205,18 +204,43 @@
   }
 
   /**
+   * Returns an instance of {@code type}.
+   *
+   * @throws IllegalArgumentException if {@code type} is not one of this object
+   *     graph's entry point types.
+   */
+  public <T> T getInstance(Class<T> type) {
+    String key = Keys.get(type);
+    @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
+    Binding<T> binding = (Binding<T>) getEntryPointBinding(key, key);
+    return binding.get();
+  }
+
+  /**
    * Injects the members of {@code instance}, including injectable members
    * inherited from its supertypes.
    *
    * @throws IllegalArgumentException if the runtime type of {@code instance} is
-   *     not the object graph's type or one of its entry point types.
+   *     not one of this object graph's entry point types.
    */
-  @SuppressWarnings("unchecked") // the linker matches keys to bindings by their type
   public void inject(Object instance) {
-    String key = Keys.getMembersKey(instance.getClass());
-    Class<?> moduleClass = entryPoints.get(key);
+    String entryPointKey = Keys.get(instance.getClass());
+    String membersKey = Keys.getMembersKey(instance.getClass());
+    @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
+    Binding<Object> binding = (Binding<Object>) getEntryPointBinding(entryPointKey, membersKey);
+    binding.injectMembers(instance);
+  }
+
+  /**
+   * @param entryPointKey the key used to store the entry point. This is always
+   *     a regular (provider) key.
+   * @param key the key to use when retrieving the binding. This may be a
+   *     regular (provider) key or a members key.
+   */
+  private Binding<?> getEntryPointBinding(String entryPointKey, String key) {
+    Class<?> moduleClass = entryPoints.get(entryPointKey);
     if (moduleClass == null) {
-      throw new IllegalArgumentException("No entry point for " + instance.getClass().getName()
+      throw new IllegalArgumentException("No entry point for " + entryPointKey
           + ". You must explicitly add an entry point to one of your modules.");
     }
     Binding<?> binding = linker.requestBinding(key, moduleClass);
@@ -224,6 +248,6 @@
       linker.linkRequested();
       binding = linker.requestBinding(key, moduleClass);
     }
-    ((Binding<Object>) binding).injectMembers(instance);
+    return binding;
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index 3597fa2..45fb8a3 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -17,9 +17,9 @@
 package dagger.internal;
 
 
-import dagger.OneOf;
 import dagger.Module;
 import dagger.ObjectGraph;
+import dagger.OneOf;
 import dagger.Provides;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
@@ -96,8 +96,8 @@
 
     @SuppressWarnings("deprecation") // explicitly handles deprecated case
     ReflectiveModuleAdapter(Class<?> moduleClass, Module annotation) {
-      super(toMemberKeys(
-          annotation.entryPoints()),
+      super(
+          toKeys(annotation.entryPoints()),
           annotation.staticInjections(),
           annotation.overrides(),
           annotation.includes(),
@@ -105,10 +105,10 @@
       this.moduleClass = moduleClass;
     }
 
-    private static String[] toMemberKeys(Class<?>[] entryPoints) {
+    private static String[] toKeys(Class<?>[] entryPoints) {
       String[] result = new String[entryPoints.length];
       for (int i = 0; i < entryPoints.length; i++) {
-        result[i] = Keys.getMembersKey(entryPoints[i]);
+        result[i] = Keys.get(entryPoints[i]);
       }
       return result;
     }
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 7064965..7d9ae82 100644
--- a/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -163,7 +163,7 @@
     StringBuilder entryPointsField = new StringBuilder().append("{ ");
     for (Object entryPoint : entryPoints) {
       TypeMirror typeMirror = (TypeMirror) entryPoint;
-      String key = GeneratorKeys.rawMembersKey(typeMirror);
+      String key = GeneratorKeys.get(typeMirror);
       entryPointsField.append(JavaWriter.stringLiteral(key)).append(", ");
     }
     entryPointsField.append("}");
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index 53bc71a..9993e83 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -20,6 +20,7 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.RandomAccess;
+import java.util.concurrent.atomic.AtomicInteger;
 import javax.inject.Inject;
 import javax.inject.Named;
 import javax.inject.Provider;
@@ -27,6 +28,7 @@
 import org.junit.Test;
 
 import static org.fest.assertions.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 @SuppressWarnings("unused")
@@ -508,4 +510,87 @@
 
     ObjectGraph.get(new TestModule());
   }
+
+  @Test public void getInstance() {
+    final AtomicInteger next = new AtomicInteger(0);
+
+    @Module(entryPoints = Integer.class)
+    class TestModule {
+      @Provides Integer provideInteger() {
+        return next.getAndIncrement();
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    assertEquals(0, (int) graph.getInstance(Integer.class));
+    assertEquals(1, (int) graph.getInstance(Integer.class));
+  }
+
+  @Test public void getInstanceRequiresEntryPoint() {
+    @Module
+    class TestModule {
+      @Provides Integer provideInteger() {
+        throw new AssertionError();
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    try {
+      graph.getInstance(Integer.class);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void getInstanceOfPrimitive() {
+    @Module(entryPoints = int.class)
+    class TestModule {
+      @Provides int provideInt() {
+        return 1;
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    assertEquals(1, (int) graph.getInstance(int.class));
+  }
+
+  @Test public void getInstanceOfArray() {
+    @Module(entryPoints = int[].class)
+    class TestModule {
+      @Provides int[] provideIntArray() {
+        return new int[] { 1, 2, 3 };
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    assertEquals("[1, 2, 3]", Arrays.toString(graph.getInstance(int[].class)));
+  }
+
+  @Test public void getInstanceAndInjectMembersUseDifferentKeys() {
+    class BoundTwoWays {
+      @Inject String s;
+    }
+
+    @Module(entryPoints = BoundTwoWays.class)
+    class TestModule {
+      @Provides
+      BoundTwoWays provideBoundTwoWays() {
+        BoundTwoWays result = new BoundTwoWays();
+        result.s = "Pepsi";
+        return result;
+      }
+
+      @Provides String provideString() {
+        return "Coke";
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    BoundTwoWays provided = graph.getInstance(BoundTwoWays.class);
+    assertEquals("Pepsi", provided.s);
+
+    BoundTwoWays membersInjected = new BoundTwoWays();
+    graph.inject(membersInjected);
+    assertEquals("Coke", membersInjected.s);
+  }
 }
/Fim/
diff --git a/core/src/test/java/dagger/MembersInjectorTest.java b/core/src/test/java/dagger/MembersInjectorTest.java
index e7b913f..b48cb1b 100644
--- a/core/src/test/java/dagger/MembersInjectorTest.java
+++ b/core/src/test/java/dagger/MembersInjectorTest.java
@@ -92,7 +92,7 @@
 
     ObjectGraph graph = ObjectGraph.get(new TestModule());
     try {
-      graph.inject(new TestEntryPoint());
+      graph.getInstance(TestEntryPoint.class);
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -109,7 +109,7 @@
 
     ObjectGraph graph = ObjectGraph.get(new TestModule());
     try {
-      graph.inject(new TestEntryPoint());
+      graph.getInstance(TestEntryPoint.class);
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -126,7 +126,7 @@
 
     ObjectGraph graph = ObjectGraph.get(new TestModule());
     try {
-      graph.inject(new TestEntryPoint());
+      graph.getInstance(TestEntryPoint.class);
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -175,7 +175,7 @@
 
     ObjectGraph graph = ObjectGraph.get(new TestModule());
     try {
-      graph.inject(new TestEntryPoint());
+      graph.getInstance(TestEntryPoint.class);
       fail();
     } catch (IllegalArgumentException expected) {
     }
/Fim/
diff --git a/core/src/test/java/dagger/ModuleIncludesTest.java b/core/src/test/java/dagger/ModuleIncludesTest.java
index fecc6c5..c608940 100644
--- a/core/src/test/java/dagger/ModuleIncludesTest.java
+++ b/core/src/test/java/dagger/ModuleIncludesTest.java
@@ -40,8 +40,7 @@
     }
 
     ObjectGraph objectGraph = ObjectGraph.get(new TestModule());
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    objectGraph.inject(entryPoint);
+    TestEntryPoint entryPoint = objectGraph.getInstance(TestEntryPoint.class);
     assertThat(entryPoint.s).isEqualTo("injected");
   }
 
@@ -156,11 +155,4 @@
     objectGraph.inject(entryPoint);
     assertThat(entryPoint.s).isEqualTo("a");
   }
-
-  private <T> T injectWithModule(T ep, Object ... modules) {
-    // TODO(cgruber): Make og.inject(foo) return foo properly.
-    ObjectGraph og = ObjectGraph.get(modules);
-    og.inject(ep);
-    return ep;
-  }
 }
/Fim/
diff --git a/example/src/main/java/coffee/CoffeeApp.java b/example/src/main/java/coffee/CoffeeApp.java
index aebbb3e..0553308 100644
--- a/example/src/main/java/coffee/CoffeeApp.java
+++ b/example/src/main/java/coffee/CoffeeApp.java
@@ -12,8 +12,7 @@
 
   public static void main(String[] args) {
     ObjectGraph objectGraph = ObjectGraph.get(new DripCoffeeModule());
-    CoffeeApp coffeeApp = new CoffeeApp();
-    objectGraph.inject(coffeeApp);
+    CoffeeApp coffeeApp = objectGraph.getInstance(CoffeeApp.class);
     coffeeApp.run();
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 2035c64..7a3fe30 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -23,7 +23,6 @@
 import dagger.internal.RuntimeLinker;
 import dagger.internal.StaticInjection;
 import dagger.internal.UniqueMap;
-import java.util.Collection;
 import java.util.LinkedHashMap;
 import java.util.Map;
 
@@ -180,8 +179,8 @@
   public void validate() {
     linkStaticInjections();
     linkEntryPoints();
-    Collection<Binding<?>> allBindings = linker.linkAll();
-    new ProblemDetector().detectProblems(allBindings);
+    Map<String, Binding<?>> allBindings = linker.linkAll();
+    new ProblemDetector().detectProblems(allBindings.values());
   }
 
   /**
/Fim/
diff --git a/core/src/main/java/dagger/internal/GraphVisualizer.java b/core/src/main/java/dagger/internal/GraphVisualizer.java
new file mode 100644
index 0000000..eaa51b9
--- /dev/null
+++ b/core/src/main/java/dagger/internal/GraphVisualizer.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.internal.codegen.DotWriter;
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Emits an object graph in dot format.
+ */
+public final class GraphVisualizer {
+  private static final Pattern KEY_PATTERN = Pattern.compile(""
+      + "(?:@"            // Full annotation start.
+      + "(?:[\\w$]+\\.)*" // Annotation package
+      + "([\\w$]+)"       // Annotation simple name. Group 1.
+      + "(?:\\(.*\\))?"   // Annotation arguments
+      + "/)?"             // Full annotation end.
+      + "(?:members/)?"   // Members prefix.
+      + "(?:[\\w$]+\\.)*" // Type package.
+      + "([\\w$]+)"       // Type simple name. Group 2.
+      + "(\\<[^/]+\\>)?"  // Type parameters. Group 3.
+      + "((\\[\\])*)"     // Arrays. Group 4.
+      + "");
+
+  public void write(Map<String, Binding<?>> bindings, DotWriter writer) throws IOException {
+    Map<Binding<?>, String> namesIndex = buildNamesIndex(bindings);
+
+    writer.beginGraph("concentrate", "true");
+    for (Map.Entry<Binding<?>, String> entry : namesIndex.entrySet()) {
+      Binding<?> sourceBinding = entry.getKey();
+      String sourceName = entry.getValue();
+      Set<Binding<?>> dependencies = new HashSet<Binding<?>>();
+      sourceBinding.getDependencies(dependencies, dependencies);
+      for (Binding<?> targetBinding : dependencies) {
+        String targetName = namesIndex.get(targetBinding);
+        writer.edge(sourceName, targetName);
+      }
+    }
+    writer.endGraph();
+  }
+
+  private Map<Binding<?>, String> buildNamesIndex(Map<String, Binding<?>> bindings) {
+    // Optimistically shorten each binding to the class short name; remembering collisions.
+    Map<String, Binding<?>> shortNameToBinding = new TreeMap<String, Binding<?>>();
+    Set<Binding<?>> collisions = new HashSet<Binding<?>>();
+    for (Map.Entry<String, Binding<?>> entry : bindings.entrySet()) {
+      String key = entry.getKey();
+      Binding<?> binding = entry.getValue();
+      String shortName = shortName(key);
+      Binding<?> collision = shortNameToBinding.put(shortName, binding);
+      if (collision != null && collision != binding) {
+        collisions.add(binding);
+        collisions.add(collision);
+      }
+    }
+
+    // Replace collisions with full names.
+    for (Map.Entry<String, Binding<?>> entry : bindings.entrySet()) {
+      Binding<?> binding = entry.getValue();
+      if (collisions.contains(binding)) {
+        String key = entry.getKey();
+        String shortName = shortName(key);
+        shortNameToBinding.remove(shortName);
+        shortNameToBinding.put(key, binding);
+      }
+    }
+
+    // Reverse the map.
+    Map<Binding<?>, String> bindingToName = new LinkedHashMap<Binding<?>, String>();
+    for (Map.Entry<String, Binding<?>> entry : shortNameToBinding.entrySet()) {
+      bindingToName.put(entry.getValue(), entry.getKey());
+    }
+
+    return bindingToName;
+  }
+
+  String shortName(String key) {
+    Matcher matcher = KEY_PATTERN.matcher(key);
+    if (!matcher.matches()) throw new IllegalArgumentException("Unexpected key: " + key);
+    StringBuilder result = new StringBuilder();
+
+    String annotationSimpleName = matcher.group(1);
+    if (annotationSimpleName != null) {
+      result.append('@').append(annotationSimpleName).append(' ');
+    }
+
+    String simpleName = matcher.group(2);
+    result.append(simpleName);
+
+    String typeParameters = matcher.group(3);
+    if (typeParameters != null) {
+      result.append(typeParameters);
+    }
+
+    String arrays = matcher.group(4);
+    if (arrays != null) {
+      result.append(arrays);
+    }
+
+    return result.toString();
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
index 3f23309..71fa9b2 100644
--- a/core/src/main/java/dagger/internal/Keys.java
+++ b/core/src/main/java/dagger/internal/Keys.java
@@ -76,7 +76,7 @@
     if (annotation != null) {
       result.append(annotation).append("/");
     }
-    typeToString(type, result);
+    typeToString(type, result, true);
     return result.toString();
   }
 
@@ -95,7 +95,7 @@
       result.append(qualifier).append("/");
     }
     result.append(SET_PREFIX);
-    typeToString(type, result);
+    typeToString(type, result, true);
     result.append(">");
     return result.toString();
   }
@@ -130,33 +130,40 @@
     return qualifier;
   }
 
-  private static void typeToString(Type type, StringBuilder result) {
+  /**
+   * @param topLevel true if this is a top-level type where primitive types
+   *     like 'int' are forbidden. Recursive calls pass 'false' to support
+   *     arrays like {@code int[]}.
+   */
+  private static void typeToString(Type type, StringBuilder result, boolean topLevel) {
     if (type instanceof Class) {
       Class<?> c = (Class<?>) type;
       if (c.isArray()) {
-        result.append(c.getComponentType().getName());
+        typeToString(c.getComponentType(), result, false);
         result.append("[]");
       } else if (c.isPrimitive()) {
-        // TODO: support this?
-        throw new UnsupportedOperationException("Uninjectable type " + type);
+        if (topLevel) {
+          throw new UnsupportedOperationException("Uninjectable type " + type);
+        }
+        result.append(c.getName());
       } else {
         result.append(c.getName());
       }
     } else if (type instanceof ParameterizedType) {
       ParameterizedType parameterizedType = (ParameterizedType) type;
-      typeToString(parameterizedType.getRawType(), result);
+      typeToString(parameterizedType.getRawType(), result, true);
       Type[] arguments = parameterizedType.getActualTypeArguments();
       result.append("<");
       for (int i = 0; i < arguments.length; i++) {
         if (i != 0) {
           result.append(", ");
         }
-        typeToString(arguments[i], result);
+        typeToString(arguments[i], result, true);
       }
       result.append(">");
     } else if (type instanceof GenericArrayType) {
       GenericArrayType genericArrayType = (GenericArrayType) type;
-      result.append(((Class<?>) genericArrayType.getGenericComponentType()).getName());
+      typeToString(genericArrayType.getGenericComponentType(), result, false);
       result.append("[]");
     } else {
       throw new UnsupportedOperationException("Uninjectable type " + type);
@@ -245,7 +252,7 @@
     if (key.startsWith("@") || key.startsWith("members/")) {
       start = key.lastIndexOf('/') + 1;
     }
-    return (key.indexOf('<', start) == -1 && key.indexOf('[') == -1)
+    return (key.indexOf('<', start) == -1 && key.indexOf('[', start) == -1)
         ? key.substring(start)
         : null;
   }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 8a63824..b9a1952 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -16,7 +16,6 @@
 package dagger.internal;
 
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
@@ -60,14 +59,14 @@
    *
    * @return all bindings known by this linker, which will all be linked.
    */
-  public final Collection<Binding<?>> linkAll() {
+  public final Map<String, Binding<?>> linkAll() {
     for (Binding<?> binding : bindings.values()) {
       if (!binding.isLinked()) {
         toLink.add(binding);
       }
     }
     linkRequested();
-    return bindings.values();
+    return bindings;
   }
 
   /**
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/AtInjectBinding.java b/core/src/main/java/dagger/internal/codegen/AtInjectBinding.java
index e2a3f9c..8af0e19 100644
--- a/core/src/main/java/dagger/internal/codegen/AtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/codegen/AtInjectBinding.java
@@ -19,6 +19,7 @@
 import dagger.internal.Linker;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 import javax.inject.Inject;
 import javax.inject.Singleton;
 import javax.lang.model.element.Element;
@@ -34,6 +35,7 @@
 final class AtInjectBinding extends Binding<Object> {
   private final TypeElement type;
   private final List<String> keys;
+  private final Binding<?>[] bindings;
 
   private AtInjectBinding(String provideKey, String membersKey,
       TypeElement type, List<String> keys) {
@@ -41,6 +43,7 @@
         type.getQualifiedName().toString());
     this.type = type;
     this.keys = keys;
+    this.bindings = new Binding<?>[keys.size()];
   }
 
   /**
@@ -108,8 +111,14 @@
 
   @Override public void attach(Linker linker) {
     String requiredBy = type.getQualifiedName().toString();
-    for (String key : keys) {
-      linker.requestBinding(key, requiredBy);
+    for (int i = 0; i < keys.size(); i++) {
+      bindings[i] = linker.requestBinding(keys.get(i), requiredBy);
+    }
+  }
+
+  @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+    for (Binding binding : bindings) {
+      get.add(binding);
     }
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/DotWriter.java b/core/src/main/java/dagger/internal/codegen/DotWriter.java
new file mode 100644
index 0000000..4fb8c92
--- /dev/null
+++ b/core/src/main/java/dagger/internal/codegen/DotWriter.java
@@ -0,0 +1,146 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+/**
+ * Emits dot graphs.
+ */
+public final class DotWriter implements Closeable {
+  private static final String INDENT = "  ";
+  private final Writer out;
+  private int indent = 0;
+  private int nextName = 1;
+  private final Map<String, String> generatedNames = new LinkedHashMap<String, String>();
+
+  /**
+   * @param out the stream to which dot data will be written. This should be a
+   *     buffered stream.
+   */
+  public DotWriter(Writer out) {
+    this.out = out;
+  }
+
+  public void beginGraph(String... attributes) throws IOException {
+    indent();
+    String type = indent == 0 ? "digraph " : "subgraph ";
+    String name = nextName(indent == 0 ? "G" : "cluster");
+    out.write(type);
+    out.write(name);
+    out.write(" {\n");
+    indent++;
+    attributes(attributes);
+  }
+
+  public void endGraph() throws IOException {
+    indent--;
+    indent();
+    out.write("}\n");
+  }
+
+  public void node(String name, String... attributes) throws IOException {
+    name = nodeName(name);
+    indent();
+    out.write(name);
+    inlineAttributes(attributes);
+    out.write(";\n");
+  }
+
+  public void edge(String source, String target, String... attributes) throws IOException {
+    source = nodeName(source);
+    target = nodeName(target);
+    indent();
+    out.write(source);
+    out.write(" -> ");
+    out.write(target);
+    inlineAttributes(attributes);
+    out.write(";\n");
+  }
+
+  public void nodeDefaults(String... attributes) throws IOException {
+    if (attributes.length == 0) return;
+    indent();
+    out.write("node");
+    inlineAttributes(attributes);
+    out.write(";\n");
+  }
+
+  public void edgeDefaults(String... attributes) throws IOException {
+    if (attributes.length == 0) return;
+    indent();
+    out.write("edge");
+    inlineAttributes(attributes);
+    out.write(";\n");
+  }
+
+  private void attributes(String[] attributes) throws IOException {
+    if (attributes.length == 0) return;
+    if (attributes.length % 2 != 0) throw new IllegalArgumentException();
+    for (int i = 0; i < attributes.length; i += 2) {
+      indent();
+      out.write(attributes[i]);
+      out.write(" = ");
+      out.write(literal(attributes[i + 1]));
+      out.write(";\n");
+    }
+  }
+
+  private void inlineAttributes(String[] attributes) throws IOException {
+    if (attributes.length == 0) return;
+    if (attributes.length % 2 != 0) throw new IllegalArgumentException();
+    out.write(" [");
+    for (int i = 0; i < attributes.length; i += 2) {
+      if (i != 0) out.write(";");
+      out.write(attributes[i]);
+      out.write("=");
+      out.write(literal(attributes[i + 1]));
+    }
+    out.write("]");
+  }
+
+  private String nodeName(String name) throws IOException {
+    if (name.matches("\\w+")) return name;
+    String generatedName = generatedNames.get(name);
+    if (generatedName != null) return generatedName;
+    generatedName = nextName("n");
+    generatedNames.put(name, generatedName);
+    node(generatedName, "label", name);
+    return generatedName;
+  }
+
+  private String literal(String raw) {
+    return raw.matches("\\w+") ? raw : JavaWriter.stringLiteral(raw);
+  }
+
+  private void indent() throws IOException {
+    for (int i = 0; i < indent; i++) {
+      out.write(INDENT);
+    }
+  }
+
+  private String nextName(String prefix) {
+    return prefix + (nextName++);
+  }
+
+  @Override public void close() throws IOException {
+    out.close();
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index fdeda8b..b44080a 100644
--- a/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -19,8 +19,11 @@
 import dagger.OneOf;
 import dagger.Provides;
 import dagger.internal.Binding;
+import dagger.internal.GraphVisualizer;
 import dagger.internal.Linker;
 import dagger.internal.SetBinding;
+import java.io.IOException;
+import java.io.Writer;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
@@ -37,6 +40,9 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
+import javax.tools.FileObject;
+import javax.tools.JavaFileManager;
+import javax.tools.StandardLocation;
 
 /**
  * Performs full graph analysis on a module.
@@ -49,16 +55,27 @@
    * the module's dependencies are satisfied.
    */
   @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
-    for (Element moduleType : env.getElementsAnnotatedWith(Module.class)) {
-      Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, moduleType);
-      if (annotation.get("complete").equals(Boolean.TRUE)) {
-        validateComplete((TypeElement) moduleType);
+    try {
+      for (Element element : env.getElementsAnnotatedWith(Module.class)) {
+        Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, element);
+        if (!annotation.get("complete").equals(Boolean.TRUE)) {
+          continue;
+        }
+        TypeElement moduleType = (TypeElement) element;
+        Map<String, Binding<?>> bindings = processCompleteModule(moduleType);
+        writeDotFile(moduleType, bindings);
       }
+    } catch (IOException e) {
+      error("Graph processing failed: " + e);
     }
     return true;
   }
 
-  private void validateComplete(TypeElement rootModule) {
+  private void error(String message) {
+    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message);
+  }
+
+  private Map<String, Binding<?>> processCompleteModule(TypeElement rootModule) {
     Map<String, TypeElement> allModules = new LinkedHashMap<String, TypeElement>();
     collectIncludesRecursively(rootModule, allModules);
 
@@ -107,7 +124,7 @@
 
     // Link the bindings. This will traverse the dependency graph, and report
     // errors if any dependencies are missing.
-    linker.linkAll();
+    return linker.linkAll();
   }
 
   private String shortMethodName(ExecutableElement method) {
@@ -136,15 +153,38 @@
 
   static class ProviderMethodBinding extends Binding<Object> {
     private final ExecutableElement method;
+    private final Binding<?>[] parameters;
+
     protected ProviderMethodBinding(String provideKey, ExecutableElement method) {
       super(provideKey, null, method.getAnnotation(Singleton.class) != null, method.toString());
       this.method = method;
+      this.parameters = new Binding[method.getParameters().size()];
     }
+
     @Override public void attach(Linker linker) {
-      for (VariableElement parameter : method.getParameters()) {
+      for (int i = 0; i < method.getParameters().size(); i++) {
+        VariableElement parameter = method.getParameters().get(i);
         String parameterKey = GeneratorKeys.get(parameter);
-        linker.requestBinding(parameterKey, method.toString());
+        parameters[i] = linker.requestBinding(parameterKey, method.toString());
       }
     }
+
+    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+      for (Binding binding : parameters) {
+        get.add(binding);
+      }
+    }
+  }
+
+  void writeDotFile(TypeElement module, Map<String, Binding<?>> bindings) throws IOException {
+    JavaFileManager.Location location = StandardLocation.SOURCE_OUTPUT;
+    String path = CodeGen.getPackage(module).getQualifiedName().toString();
+    String file = module.getQualifiedName().toString().substring(path.length() + 1) + ".dot";
+    FileObject resource = processingEnv.getFiler().createResource(location, path, file, module);
+
+    Writer writer = resource.openWriter();
+    DotWriter dotWriter = new DotWriter(writer);
+    new GraphVisualizer().write(bindings, dotWriter);
+    dotWriter.close();
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/JavaWriter.java b/core/src/main/java/dagger/internal/codegen/JavaWriter.java
index fa0dce3..7c928ea 100644
--- a/core/src/main/java/dagger/internal/codegen/JavaWriter.java
+++ b/core/src/main/java/dagger/internal/codegen/JavaWriter.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import java.io.Closeable;
 import java.io.IOException;
 import java.io.Writer;
 import java.lang.annotation.Annotation;
@@ -32,7 +33,7 @@
  *
  * @author Jesse Wilson
  */
-public final class JavaWriter {
+public final class JavaWriter implements Closeable {
   private static final Pattern TYPE_PATTERN = Pattern.compile("(?:[\\w$]+\\.)*([\\w$]+)");
   private static final String INDENT = "  ";
 
@@ -434,7 +435,7 @@
     return result.toString();
   }
 
-  public void close() throws IOException {
+  @Override public void close() throws IOException {
     out.close();
   }
 
/Fim/
diff --git a/core/src/test/java/dagger/internal/GraphVisualizerTest.java b/core/src/test/java/dagger/internal/GraphVisualizerTest.java
new file mode 100644
index 0000000..46832be
--- /dev/null
+++ b/core/src/test/java/dagger/internal/GraphVisualizerTest.java
@@ -0,0 +1,77 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.lang.reflect.Field;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Named;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+public final class GraphVisualizerTest {
+  private final GraphVisualizer graphVisualizer = new GraphVisualizer();
+
+  String simpleKey;
+  @Test public void testSimpleKey() throws Exception {
+    String key = fieldKey("simpleKey");
+    assertThat(graphVisualizer.shortName(key)).isEqualTo("String");
+  }
+
+  @Named String annotatedKey;
+  @Test public void testAnnotatedKey() throws Exception {
+    String key = fieldKey("annotatedKey");
+    assertThat(graphVisualizer.shortName(key)).isEqualTo("@Named String");
+  }
+
+  @Named("/@<>[]()") String annotatedKeyWithParameters;
+  @Test public void testAnnotatedKeyWithParameters() throws Exception {
+    String key = fieldKey("annotatedKeyWithParameters");
+    // We intentionally omit parameters on annotated keys!
+    assertThat(graphVisualizer.shortName(key)).isEqualTo("@Named String");
+  }
+
+  String[][] arrayKey;
+  @Test public void testArrayKey() throws Exception {
+    String key = fieldKey("arrayKey");
+    assertThat(graphVisualizer.shortName(key)).isEqualTo("String[][]");
+  }
+
+  Map<String, Set<Object>> typeParameterKey;
+  @Test public void testTypeParameterKey() throws Exception {
+    String key = fieldKey("typeParameterKey");
+    assertThat(graphVisualizer.shortName(key))
+        .isEqualTo("Map<java.lang.String, java.util.Set<java.lang.Object>>");
+  }
+
+  @Named("/@<>[]()") Map<String, Set<Object>>[] everythingKey;
+  @Test public void testEverythingKey() throws Exception {
+    String key = fieldKey("everythingKey");
+    assertThat(graphVisualizer.shortName(key))
+        .isEqualTo("@Named Map<java.lang.String, java.util.Set<java.lang.Object>>[]");
+  }
+
+  @Test public void testMembersKey() throws Exception {
+    String key = Keys.getMembersKey(String.class);
+    assertThat(graphVisualizer.shortName(key)).isEqualTo("String");
+  }
+
+  private String fieldKey(String fieldName) throws NoSuchFieldException {
+    Field field = GraphVisualizerTest.class.getDeclaredField(fieldName);
+    return Keys.get(field.getGenericType(), field.getAnnotations(), field);
+  }
+}
/Fim/
diff --git a/core/src/test/java/dagger/internal/codegen/DotWriterTest.java b/core/src/test/java/dagger/internal/codegen/DotWriterTest.java
new file mode 100644
index 0000000..f7a7c58
--- /dev/null
+++ b/core/src/test/java/dagger/internal/codegen/DotWriterTest.java
@@ -0,0 +1,94 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+public final class DotWriterTest {
+  private final StringWriter stringWriter = new StringWriter();
+  private final DotWriter dotWriter = new DotWriter(stringWriter);
+
+  @Test public void graphWithAttributes() throws IOException {
+    dotWriter.beginGraph();
+    dotWriter.edge("CoffeeMaker", "Heater", "style", "dotted", "color", "red");
+    dotWriter.edge("CoffeeMaker", "Pump");
+    dotWriter.node("CoffeeMaker", "shape", "box");
+    dotWriter.endGraph();
+    assertGraph(""
+        + "digraph G1 {\n"
+        + "  CoffeeMaker -> Heater [style=dotted;color=red];\n"
+        + "  CoffeeMaker -> Pump;\n"
+        + "  CoffeeMaker [shape=box];\n"
+        + "}\n");
+  }
+
+  @Test public void subgraph() throws IOException {
+    dotWriter.beginGraph("label", "10\" tall");
+    dotWriter.beginGraph("style", "filled", "color", "lightgrey");
+    dotWriter.edge("ElectricHeater", "Heater");
+    dotWriter.endGraph();
+    dotWriter.edge("CoffeeMaker", "Heater");
+    dotWriter.edge("CoffeeMaker", "Pump");
+    dotWriter.endGraph();
+    assertGraph(""
+        + "digraph G1 {\n"
+        + "  label = \"10\\\" tall\";\n"
+        + "  subgraph cluster2 {\n"
+        + "    style = filled;\n"
+        + "    color = lightgrey;\n"
+        + "    ElectricHeater -> Heater;\n"
+        + "  }\n"
+        + "  CoffeeMaker -> Heater;\n"
+        + "  CoffeeMaker -> Pump;\n"
+        + "}\n");
+  }
+
+  @Test public void defaultAttributes() throws IOException {
+    dotWriter.beginGraph();
+    dotWriter.nodeDefaults("color", "red");
+    dotWriter.edgeDefaults("style", "dotted");
+    dotWriter.edge("CoffeeMaker", "Heater");
+    dotWriter.endGraph();
+    assertGraph(""
+        + "digraph G1 {\n"
+        + "  node [color=red];\n"
+        + "  edge [style=dotted];\n"
+        + "  CoffeeMaker -> Heater;\n"
+        + "}\n");
+  }
+
+  @Test public void invalidNodeNames() throws IOException {
+    dotWriter.beginGraph();
+    dotWriter.edge("a.b", "a c");
+    dotWriter.edge("a c", "a_d");
+    dotWriter.endGraph();
+    assertGraph(""
+        + "digraph G1 {\n"
+        + "  n2 [label=\"a.b\"];\n"
+        + "  n3 [label=\"a c\"];\n"
+        + "  n2 -> n3;\n"
+        + "  n3 -> a_d;\n"
+        + "}\n");
+  }
+
+  private void assertGraph(String expected) {
+    assertThat(stringWriter.toString()).isEqualTo(expected);
+  }
+}
/Fim/
diff --git a/androidmanifest/pom.xml b/androidmanifest/pom.xml
index 8626432..201423f 100644
--- a/androidmanifest/pom.xml
+++ b/androidmanifest/pom.xml
@@ -15,44 +15,46 @@
   limitations under the License.
 -->
 <project
-        xmlns="http://maven.apache.org/POM/4.0.0"
-        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-        xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-    <parent>
-        <groupId>com.squareup</groupId>
-        <artifactId>dagger-parent</artifactId>
-        <version>1.0-SNAPSHOT</version>
-        <relativePath>../pom.xml</relativePath>
-    </parent>
-    <artifactId>dagger-androidmanifest-plugin</artifactId>
-    <packaging>maven-plugin</packaging>
-    <name>Dagger AndroidManifest.xml Module Generator</name>
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
 
-    <dependencies>
-        <dependency>
-            <groupId>com.squareup</groupId>
-            <artifactId>dagger</artifactId>
-            <version>${project.version}</version>
-        </dependency>
-        <dependency>
-            <groupId>org.apache.maven</groupId>
-            <artifactId>maven-core</artifactId>
-        </dependency>
-        <dependency>
-            <groupId>org.apache.maven</groupId>
-            <artifactId>maven-plugin-api</artifactId>
-        </dependency>
+  <parent>
+    <groupId>com.squareup</groupId>
+    <artifactId>dagger-parent</artifactId>
+    <version>1.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
 
-        <dependency>
-            <groupId>junit</groupId>
-            <artifactId>junit</artifactId>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>org.easytesting</groupId>
-            <artifactId>fest-assert</artifactId>
-            <scope>test</scope>
-        </dependency>
-    </dependencies>
+  <artifactId>dagger-androidmanifest-plugin</artifactId>
+  <packaging>maven-plugin</packaging>
+  <name>Dagger AndroidManifest.xml Module Generator</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.maven</groupId>
+      <artifactId>maven-core</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.maven</groupId>
+      <artifactId>maven-plugin-api</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.easytesting</groupId>
+      <artifactId>fest-assert</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
 </project>
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 88e61fd..55eddcd 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -15,73 +15,77 @@
   limitations under the License.
 -->
 <project
-        xmlns="http://maven.apache.org/POM/4.0.0"
-        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-        xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-    <parent>
-        <groupId>com.squareup</groupId>
-        <artifactId>dagger-parent</artifactId>
-        <version>1.0-SNAPSHOT</version>
-        <relativePath>../pom.xml</relativePath>
-    </parent>
-    <artifactId>dagger</artifactId>
-    <packaging>jar</packaging>
-    <name>Dagger</name>
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
 
-    <dependencies>
-        <dependency>
-            <groupId>javax.inject</groupId>
-            <artifactId>javax.inject</artifactId>
-        </dependency>
+  <parent>
+    <groupId>com.squareup</groupId>
+    <artifactId>dagger-parent</artifactId>
+    <version>1.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
 
-        <dependency>
-            <groupId>junit</groupId>
-            <artifactId>junit</artifactId>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>org.easytesting</groupId>
-            <artifactId>fest-assert</artifactId>
-            <scope>test</scope>
-        </dependency>
-    </dependencies>
+  <artifactId>dagger</artifactId>
+  <packaging>jar</packaging>
+  <name>Dagger</name>
 
-    <build>
-        <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-compiler-plugin</artifactId>
-                <version>2.5</version>
-                <configuration>
-                    <source>${java.version}</source>
-                    <target>${java.version}</target>
-                    <compilerArgument>-proc:none</compilerArgument>
-                </configuration>
-            </plugin>
-            <plugin>
-                <artifactId>maven-invoker-plugin</artifactId>
-                <version>1.7</version>
-                <configuration>
-                    <addTestClassPath>true</addTestClassPath>
-                    <cloneProjectsTo>${project.build.directory}/it</cloneProjectsTo>
-                    <pomIncludes><pomInclude>*/pom.xml</pomInclude></pomIncludes>
-                    <localRepositoryPath>${project.build.directory}/local-repo</localRepositoryPath>
-                    <postBuildHookScript>verify</postBuildHookScript>
-		            <filterProperties>
-		              <dagger.version>${project.version}</dagger.version>
-		            </filterProperties>
-                </configuration>
-                <executions>
-                    <execution>
-                        <id>integration-test</id>
-                        <goals>
-                            <goal>install</goal>
-                            <goal>run</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-        </plugins>
-    </build>
+  <dependencies>
+    <dependency>
+      <groupId>javax.inject</groupId>
+      <artifactId>javax.inject</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.easytesting</groupId>
+      <artifactId>fest-assert</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>2.5</version>
+        <configuration>
+          <source>${java.version}</source>
+          <target>${java.version}</target>
+          <compilerArgument>-proc:none</compilerArgument>
+        </configuration>
+      </plugin>
+      <plugin>
+        <artifactId>maven-invoker-plugin</artifactId>
+        <version>1.7</version>
+        <configuration>
+          <addTestClassPath>true</addTestClassPath>
+          <cloneProjectsTo>${project.build.directory}/it</cloneProjectsTo>
+          <pomIncludes>
+            <pomInclude>*/pom.xml</pomInclude>
+          </pomIncludes>
+          <localRepositoryPath>${project.build.directory}/local-repo</localRepositoryPath>
+          <postBuildHookScript>verify</postBuildHookScript>
+          <filterProperties>
+            <dagger.version>${project.version}</dagger.version>
+          </filterProperties>
+        </configuration>
+        <executions>
+          <execution>
+            <id>integration-test</id>
+            <goals>
+              <goal>install</goal>
+              <goal>run</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
 </project>
/Fim/
diff --git a/example/pom.xml b/example/pom.xml
index aba70d1..9ad2390 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -15,25 +15,27 @@
   limitations under the License.
 -->
 <project
-        xmlns="http://maven.apache.org/POM/4.0.0"
-        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-        xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-    <parent>
-        <groupId>com.squareup</groupId>
-        <artifactId>dagger-parent</artifactId>
-        <version>1.0-SNAPSHOT</version>
-        <relativePath>../pom.xml</relativePath>
-    </parent>
-    <artifactId>dagger-example</artifactId>
-    <packaging>jar</packaging>
-    <name>Dagger Example</name>
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
 
-    <dependencies>
-        <dependency>
-            <groupId>com.squareup</groupId>
-            <artifactId>dagger</artifactId>
-            <version>${project.version}</version>
-        </dependency>
-    </dependencies>
+  <parent>
+    <groupId>com.squareup</groupId>
+    <artifactId>dagger-parent</artifactId>
+    <version>1.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>dagger-example</artifactId>
+  <packaging>jar</packaging>
+  <name>Dagger Example</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+  </dependencies>
 </project>
/Fim/
diff --git a/pom.xml b/pom.xml
index 43074fe..d0c61bb 100644
--- a/pom.xml
+++ b/pom.xml
@@ -15,128 +15,128 @@
   limitations under the License.
 -->
 <project
-        xmlns="http://maven.apache.org/POM/4.0.0"
-        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-        xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-    <modelVersion>4.0.0</modelVersion>
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
 
-    <parent>
-        <groupId>org.sonatype.oss</groupId>
-        <artifactId>oss-parent</artifactId>
-        <version>7</version>
-    </parent>
+  <parent>
+    <groupId>org.sonatype.oss</groupId>
+    <artifactId>oss-parent</artifactId>
+    <version>7</version>
+  </parent>
 
-    <groupId>com.squareup</groupId>
-    <artifactId>dagger-parent</artifactId>
-    <packaging>pom</packaging>
-    <version>1.0-SNAPSHOT</version>
-    <name>Dagger (Parent)</name>
-    <description>A JSR-330 dependency injector for Android and Java.</description>
-    <url>https://github.com/square/dagger</url>
+  <groupId>com.squareup</groupId>
+  <artifactId>dagger-parent</artifactId>
+  <packaging>pom</packaging>
+  <version>1.0-SNAPSHOT</version>
+  <name>Dagger (Parent)</name>
+  <description>A JSR-330 dependency injector for Android and Java.</description>
+  <url>https://github.com/square/dagger</url>
 
-    <modules>
-        <module>core</module>
-        <module>androidmanifest</module>
-        <module>example</module>
-    </modules>
+  <modules>
+    <module>core</module>
+    <module>androidmanifest</module>
+    <module>example</module>
+  </modules>
 
-    <properties>
-        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 
-        <!-- Compilation -->
-        <java.version>1.6</java.version>
-        <javax.inject.version>1</javax.inject.version>
-        <maven.version>2.0.6</maven.version>
+    <!-- Compilation -->
+    <java.version>1.6</java.version>
+    <javax.inject.version>1</javax.inject.version>
+    <maven.version>2.0.6</maven.version>
 
-        <!-- Test Dependencies -->
-        <junit.version>4.10</junit.version>
-        <fest.version>1.4</fest.version>
-    </properties>
+    <!-- Test Dependencies -->
+    <junit.version>4.10</junit.version>
+    <fest.version>1.4</fest.version>
+  </properties>
 
-    <scm>
-        <url>http://github.com/square/dagger/</url>
-        <connection>scm:git:git://github.com/square/dagger.git</connection>
-        <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    </scm>
+  <scm>
+    <url>http://github.com/square/dagger/</url>
+    <connection>scm:git:git://github.com/square/dagger.git</connection>
+    <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
+  </scm>
 
-    <issueManagement>
-        <system>GitHub Issues</system>
-        <url>http://github.com/square/dagger/issues</url>
-    </issueManagement>
+  <issueManagement>
+    <system>GitHub Issues</system>
+    <url>http://github.com/square/dagger/issues</url>
+  </issueManagement>
 
-    <licenses>
-        <license>
-            <name>Apache 2.0</name>
-            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-        </license>
-    </licenses>
+  <licenses>
+    <license>
+      <name>Apache 2.0</name>
+      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+    </license>
+  </licenses>
 
-    <organization>
-        <name>Square, Inc.</name>
-        <url>http://squareup.com</url>
-    </organization>
+  <organization>
+    <name>Square, Inc.</name>
+    <url>http://squareup.com</url>
+  </organization>
 
-    <dependencyManagement>
-        <dependencies>
-            <dependency>
-                <groupId>javax.inject</groupId>
-                <artifactId>javax.inject</artifactId>
-                <version>${javax.inject.version}</version>
-            </dependency>
-            <dependency>
-                <groupId>org.apache.maven</groupId>
-                <artifactId>maven-plugin-api</artifactId>
-                <version>${maven.version}</version>
-            </dependency>
-            <dependency>
-                <groupId>org.apache.maven</groupId>
-                <artifactId>maven-core</artifactId>
-                <version>${maven.version}</version>
-            </dependency>
-            <dependency>
-                <groupId>junit</groupId>
-                <artifactId>junit</artifactId>
-                <version>${junit.version}</version>
-            </dependency>
-            <dependency>
-                <groupId>org.easytesting</groupId>
-                <artifactId>fest-assert</artifactId>
-                <version>${fest.version}</version>
-            </dependency>
-        </dependencies>
-    </dependencyManagement>
+  <dependencyManagement>
+    <dependencies>
+      <dependency>
+        <groupId>javax.inject</groupId>
+        <artifactId>javax.inject</artifactId>
+        <version>${javax.inject.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.apache.maven</groupId>
+        <artifactId>maven-plugin-api</artifactId>
+        <version>${maven.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.apache.maven</groupId>
+        <artifactId>maven-core</artifactId>
+        <version>${maven.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>junit</groupId>
+        <artifactId>junit</artifactId>
+        <version>${junit.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.easytesting</groupId>
+        <artifactId>fest-assert</artifactId>
+        <version>${fest.version}</version>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
 
-    <build>
-        <finalName>square-${project.artifactId}-${project.version}</finalName>
+  <build>
+    <finalName>square-${project.artifactId}-${project.version}</finalName>
 
-        <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-compiler-plugin</artifactId>
-                <version>2.5</version>
-                <configuration>
-                    <source>${java.version}</source>
-                    <target>${java.version}</target>
-                </configuration>
-            </plugin>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>2.5</version>
+        <configuration>
+          <source>${java.version}</source>
+          <target>${java.version}</target>
+        </configuration>
+      </plugin>
 
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-checkstyle-plugin</artifactId>
-                <version>2.9.1</version>
-                <configuration>
-                    <failsOnError>true</failsOnError>
-                    <configLocation>checkstyle.xml</configLocation>
-                </configuration>
-                <executions>
-                    <execution>
-                        <phase>verify</phase>
-                        <goals>
-                            <goal>checkstyle</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-        </plugins>
-    </build>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-checkstyle-plugin</artifactId>
+        <version>2.9.1</version>
+        <configuration>
+          <failsOnError>true</failsOnError>
+          <configLocation>checkstyle.xml</configLocation>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>verify</phase>
+            <goals>
+              <goal>checkstyle</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
 </project>
/Fim/
diff --git a/checkstyle.xml b/checkstyle.xml
index 5430c55..658a417 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -27,7 +27,7 @@
 
         <!-- Checks for Naming Conventions.                  -->
         <!-- See http://checkstyle.sf.net/config_naming.html -->
-        <module name="ConstantName"/>
+        <!--<module name="ConstantName"/>-->
         <module name="LocalFinalVariableName"/>
         <module name="LocalVariableName"/>
         <module name="MemberName"/>
/Fim/
diff --git a/compiler/src/it/extension-graph/src/main/java/test/TestApp.java b/compiler/src/it/extension-graph/src/main/java/test/TestApp.java
index ddebdfe..b26e098 100644
--- a/compiler/src/it/extension-graph/src/main/java/test/TestApp.java
+++ b/compiler/src/it/extension-graph/src/main/java/test/TestApp.java
@@ -30,14 +30,14 @@
 
   public static void main(String[] args) {
     ObjectGraph root = ObjectGraph.create(new RootModule());
-    ObjectGraph extension = root.extend(new ExtensionModule());
+    ObjectGraph extension = root.plus(new ExtensionModule());
     extension.get(TestApp.class).run();
   }
   
   @Module(entryPoints = { A.class, B.class })
   static class RootModule { }
 
-  @Module(augments=RootModule.class, entryPoints = { C.class, TestApp.class })
+  @Module(addsTo=RootModule.class, entryPoints = { C.class, TestApp.class })
   static class ExtensionModule { }
 
   @Singleton
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java b/compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java
index 5702f15..61e0f4a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java
@@ -37,8 +37,8 @@
     this.processingEnv = processingEnv;
   }
 
-  @Override public Binding<?> getAtInjectBinding(String key, String className,
-      boolean mustBeInjectable) throws ClassNotFoundException {
+  @Override public Binding<?> getAtInjectBinding(
+      String key, String className, boolean mustBeInjectable) {
     String sourceClassName = className.replace('$', '.');
     TypeElement type = processingEnv.getElementUtils().getTypeElement(sourceClassName);
     if (type == null) {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 11640d2..6780fdd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -144,7 +144,7 @@
     Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
     List<Object> seedModules = new ArrayList<Object>();
     seedModules.addAll(Arrays.asList((Object[]) annotation.get("includes")));
-    if (!annotation.get("augments").equals(Void.class)) seedModules.add(annotation.get("augments"));
+    if (!annotation.get("addsTo").equals(Void.class)) seedModules.add(annotation.get("addsTo"));
     for (Object include : seedModules) {
       if (!(include instanceof TypeMirror)) {
         processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
/Fim/
diff --git a/core/src/main/java/dagger/Lazy.java b/core/src/main/java/dagger/Lazy.java
index df18973..6b06466 100644
--- a/core/src/main/java/dagger/Lazy.java
+++ b/core/src/main/java/dagger/Lazy.java
@@ -17,16 +17,137 @@
 package dagger;
 
 /**
- * A value that is lazily returned. A {@code Lazy<T>} creates or obtains its underlying
- * value once, and caches that value thereafter.
- * <p>
- * Despite the similarity of these interfaces, {@code Lazy<T>} is semantically quite
- * distinct from {@code Provider<T>} which provides a new value on each call.
+ * A handle to a lazily-computed value. Each {@code Lazy} computes its value on
+ * the first call to {@code get()} and remembers that same value for all
+ * subsequent calls to {@code get()}.
+ *
+ * <h2>Example</h2>
+ * The differences between <strong>direct injection</strong>, <strong>provider
+ * injection</strong> and <strong>lazy injection</strong> are best demonstrated
+ * with an example. Start with a module that computes a different integer for
+ * each use:<pre><code>
+ *   &#64;Module
+ *   public class CounterModule {
+ *
+ *     int next = 100;
+ *
+ *     &#64;Provides Integer provideInteger() {
+ *       System.out.println("computing...");
+ *       return next++;
+ *     }
+ *   }
+ * </code></pre>
+ *
+ * <h3>Direct Injection</h3>
+ * This class injects that integer and prints it 3 times:<pre><code>
+ *   public class DirectCounter {
+ *
+ *     &#64Inject Integer value;
+ *
+ *     public void print() {
+ *       System.out.println("printing...");
+ *       System.out.println(value);
+ *       System.out.println(value);
+ *       System.out.println(value);
+ *     }
+ *   }
+ * </code></pre>
+ * Injecting a {@code DirectCounter} and invoking {@code print()} reveals that
+ * the value is computed <i>before</i> it is required:<pre><code>
+ *   computing...
+ *   printing...
+ *   100
+ *   100
+ *   100
+ * </code></pre>
+ *
+ * <h3>Provider Injection</h3>
+ * This class injects a {@linkplain javax.inject.Provider provider} for the
+ * integer. It calls {@code Provider.get()} 3 times and prints each result:
+ * <pre><code>
+ *   public class ProviderCounter {
+ *
+ *     &#64;Inject Provider<Integer> provider;
+ *
+ *     public void print() {
+ *       System.out.println("printing...");
+ *       System.out.println(provider.get());
+ *       System.out.println(provider.get());
+ *       System.out.println(provider.get());
+ *     }
+ *   }
+ * </code></pre>
+ * Injecting a {@code ProviderCounter} and invoking {@code print()} shows that
+ * a new value is computed each time {@code Provider.get()} is used:<pre><code>
+ *   printing...
+ *   computing...
+ *   100
+ *   computing...
+ *   101
+ *   computing...
+ *   102
+ * </code></pre>
+ *
+ * <h3>Lazy Injection</h3>
+ * This class injects a {@code Lazy} for the integer. Like the provider above,
+ * it calls {@code Lazy.get()} 3 times and prints each result:<pre><code>
+ *   public static class LazyCounter {
+ *
+ *     &#64;Inject Lazy<Integer> lazy;
+ *
+ *     public void print() {
+ *       System.out.println("printing...");
+ *       System.out.println(lazy.get());
+ *       System.out.println(lazy.get());
+ *       System.out.println(lazy.get());
+ *     }
+ *   }
+ * </code></pre>
+ * Injecting a {@code LazyCounter} and invoking {@code print()} shows that a new
+ * value is computed immediately before it is needed. The same value is returned
+ * for all subsequent uses:<pre><code>
+ *   printing...
+ *   computing...
+ *   100
+ *   100
+ *   100
+ * </code></pre>
+ *
+ * <h3>Lazy != Singleton</h3>
+ * Note that each injected {@code Lazy} is independent, and remembers its value
+ * in isolation of other {@code Lazy} instances. In this example, two {@code
+ * LazyCounter} objects are created and {@code print()} is called on each:
+ * <pre><code>
+ *     public void run() {
+ *       ObjectGraph graph = ObjectGraph.create(new CounterModule());
+ *
+ *       LazyCounter counter1 = graph.get(LazyCounter.class);
+ *       counter1.print();
+ *
+ *       LazyCounter counter2 = graph.get(LazyCounter.class);
+ *       counter2.print();
+ *     }
+ * </code></pre>
+ * The program's output demonstrates that each {@code Lazy} works independently:
+ * <pre><code>
+ *   printing...
+ *   computing...
+ *   100
+ *   100
+ *   100
+ *   printing...
+ *   computing...
+ *   101
+ *   101
+ *   101
+ * </code></pre>
+ * Use {@linkplain javax.inject.Singleton @Singleton} to share one instance
+ * among all clients, and {@code Lazy} for lazy computation in a single client.
  */
 public interface Lazy<T> {
   /**
-   * Return the underlying value, creating the value (once) if needed. Any two calls will
-   * return the same instance.
+   * Return the underlying value, computing the value if necessary. All calls to
+   * the same {@code Lazy} instance will return the same result.
    */
   T get();
 }
/Fim/
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
index 4263481..075210d 100644
--- a/core/src/main/java/dagger/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -46,17 +46,17 @@
   Class<?>[] includes() default { };
 
   /**
-   * An optional, {@code @Module}-annotated class whose abstract object graph
-   * this module extends.  At run-time, this module should be supplied to an
-   * existing graph to extend it with {@link ObjectGraph#extend(Object...)}
+   * An optional {@code @Module}-annotated class upon which this module can be
+   * {@link ObjectGraph#plus added} to form a complete graph.
    */
-  Class<?> augments() default Void.class;
+  Class<?> addsTo() default Void.class;
 
   /**
    * True if all of the bindings required by this module can also be satisfied
-   * by this module. If a module is complete it is eligible for additional
-   * static checking: tools can detect if required bindings are not available.
-   * Modules that have external dependencies must use {@code complete = false}.
+   * by this module, its {@link #includes} and its {@link #addsTo}. If a module
+   * is complete it is eligible for additional static checking: tools can detect
+   * if required bindings are not available. Modules that have external
+   * dependencies must use {@code complete = false}.
    */
   boolean complete() default true;
 
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index d837d31..e4f6f60 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -43,13 +43,13 @@
  *       time an instance is injected.
  *   <li>Constructor injection. A class may have a single
  *       {@code @Inject}-annotated constructor. Classes that have fields
- *       injected may omit the {@link @Inject} annotation if they have a public
+ *       injected may omit the {@code @Inject} annotation if they have a public
  *       no-arguments constructor.
  *   <li>Injection of {@code @Provides} method parameters.
  *   <li>{@code @Provides} methods annotated {@code @Singleton}.
  *   <li>Constructor-injected classes annotated {@code @Singleton}.
- *   <li>Injection of {@link javax.inject.Provider}s.
- *   <li>Injection of {@link MembersInjector}s.
+ *   <li>Injection of {@code Provider}s.
+ *   <li>Injection of {@code MembersInjector}s.
  *   <li>Qualifier annotations on injected parameters and fields.
  *   <li>JSR 330 annotations.
  * </ul>
@@ -61,13 +61,13 @@
  * </ul>
  */
 public final class ObjectGraph {
-  private final ObjectGraph augmented;
+  private final ObjectGraph base;
   private final Linker linker;
   private final Map<Class<?>, StaticInjection> staticInjections;
   private final Map<String, Class<?>> entryPoints;
   private final Plugin plugin;
 
-  ObjectGraph(ObjectGraph augmented,
+  ObjectGraph(ObjectGraph base,
       Linker linker,
       Plugin plugin,
       Map<Class<?>, StaticInjection> staticInjections,
@@ -77,7 +77,7 @@
     if (staticInjections == null) throw new NullPointerException("staticInjections");
     if (entryPoints == null) throw new NullPointerException("entryPoints");
 
-    this.augmented = augmented;
+    this.base = base;
     this.linker = linker;
     this.plugin = plugin;
     this.staticInjections = staticInjections;
@@ -103,8 +103,7 @@
     return makeGraph(null, plugin, modules);
   }
 
-  private static ObjectGraph makeGraph(ObjectGraph root, Plugin plugin, Object... modules) {
-
+  private static ObjectGraph makeGraph(ObjectGraph base, Plugin plugin, Object... modules) {
     Map<String, Class<?>> entryPoints = new LinkedHashMap<String, Class<?>>();
     Map<Class<?>, StaticInjection> staticInjections
         = new LinkedHashMap<Class<?>, StaticInjection>();
@@ -125,25 +124,28 @@
     }
 
     // Create a linker and install all of the user's bindings
-    Linker linker = new Linker((root != null) ? root.linker : null, plugin,
+    Linker linker = new Linker((base != null) ? base.linker : null, plugin,
         new ThrowingErrorHandler());
     linker.installBindings(baseBindings);
     linker.installBindings(overrideBindings);
 
-    return new ObjectGraph(root, linker, plugin, staticInjections, entryPoints);
+    return new ObjectGraph(base, linker, plugin, staticInjections, entryPoints);
   }
 
   /**
-   * Returns a new object graph which delegates any dependency satisfaction that
-   * it cannot perform to the graph it extends, based on supplied
-   * {@code @Module} annotated objects.
+   * Returns a new object graph that includes all of the objects in this graph,
+   * plus additional objects in the {@literal @}{@link Module}-annotated
+   * modules. This graph is a subgraph of the returned graph.
    *
-   * <p>
-   * This <strong>does not</strong> validate the graph. Rely on build time tools
-   * for graph validation, or call {@link #validate} to find problems in the
-   * graph at runtime.
+   * <p>The current graph is not modified by this operation: its objects and the
+   * dependency links between them are unchanged. But this graph's objects may
+   * be shared by both graphs. For example, the singletons of this graph may be
+   * injected and used by the returned graph.
+   *
+   * <p>This <strong>does not</strong> inject any members or validate the graph.
+   * See {@link #create} for guidance on injection and validation.
    */
-  public ObjectGraph extend(Object... modules) {
+  public ObjectGraph plus(Object... modules) {
     linker.linkAll();
     return makeGraph(this, plugin, modules);
   }
@@ -234,8 +236,9 @@
    */
   private Binding<?> getEntryPointBinding(String entryPointKey, String key) {
     Class<?> moduleClass = null;
-    for (ObjectGraph node = this; moduleClass == null && node != null; node = node.augmented) {
-      moduleClass = node.entryPoints.get(entryPointKey);
+    for (ObjectGraph graph = this; graph != null; graph = graph.base) {
+      moduleClass = graph.entryPoints.get(entryPointKey);
+      if (moduleClass != null) break;
     }
     if (moduleClass == null) {
       throw new IllegalArgumentException("No entry point for " + entryPointKey
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 4d125f3..2e00e15 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -30,11 +30,11 @@
   private static final Object UNINITIALIZED = new Object();
 
   /**
-   * The root {@code Linker} which will be consulted to satisfy bindings not
+   * The base {@code Linker} which will be consulted to satisfy bindings not
    * otherwise satisfiable from this {@code Linker}. The top-most {@code Linker}
-   * in a chain will have a null root linker.
+   * in a chain will have a null base linker.
    */
-  private final Linker root;
+  private final Linker base;
 
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
   private final Queue<Binding<?>> toLink = new LinkedList<Binding<?>>();
@@ -52,11 +52,11 @@
 
   private final ErrorHandler errorHandler;
 
-  public Linker(Linker root, Plugin plugin, ErrorHandler errorHandler) {
+  public Linker(Linker base, Plugin plugin, ErrorHandler errorHandler) {
     if (plugin == null) throw new NullPointerException("plugin");
     if (errorHandler == null) throw new NullPointerException("errorHandler");
 
-    this.root = root;
+    this.base = base;
     this.plugin = plugin;
     this.errorHandler = errorHandler;
   }
@@ -191,9 +191,14 @@
 
   private Binding<?> requestBinding(String key, boolean mustBeInjectable, Object requiredBy) {
     Binding<?> binding = null;
-    for (Linker node = this; binding == null && node != null; node = node.root) {
-      binding = node.bindings.get(key);
+    for (Linker linker = this; linker != null; linker = linker.base) {
+      binding = linker.bindings.get(key);
+      if (binding != null) {
+        if (linker != this && !binding.isLinked()) throw new AssertionError();
+        break;
+      }
     }
+
     if (binding == null) {
       // We can't satisfy this binding. Make sure it'll work next time!
       Binding<?> deferredBinding = new DeferredBinding(key, requiredBy, mustBeInjectable);
/Fim/
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index f59175c..d4eafb4 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -23,7 +23,6 @@
  * Extracts bindings from an {@code @Module}-annotated class.
  */
 public abstract class ModuleAdapter<T> {
-
   public final String[] entryPoints;
   public final Class<?>[] staticInjections;
   public final boolean overrides;
/Fim/
diff --git a/core/src/main/java/dagger/internal/Plugin.java b/core/src/main/java/dagger/internal/Plugin.java
index 37963f6..db803a3 100644
--- a/core/src/main/java/dagger/internal/Plugin.java
+++ b/core/src/main/java/dagger/internal/Plugin.java
@@ -21,13 +21,10 @@
  * provide all resolution methods
  */
 public interface Plugin {
-
   /**
-   * Returns a binding that uses {@code @Inject} annotations, or null if no such
-   * binding can be located or created.
+   * Returns a binding that uses {@code @Inject} annotations.
    */
-  Binding<?> getAtInjectBinding(String key, String className, boolean mustBeInjectable)
-      throws ClassNotFoundException;
+  Binding<?> getAtInjectBinding(String key, String className, boolean mustBeInjectable);
 
   /**
    * Returns a module adapter for {@code module}.
@@ -38,5 +35,4 @@
    * Returns the static injection for {@code injectedClass}.
    */
   StaticInjection getStaticInjection(Class<?> injectedClass);
-
 }
\ No newline at end of file
/Fim/
diff --git a/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java b/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
index 886f39b..75b0253 100644
--- a/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
+++ b/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
@@ -16,14 +16,18 @@
  */
 package dagger.internal;
 
+import dagger.ObjectGraph;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 /**
  * Aggregates provided plugins and delegates its operations to them in order.  Also provides some
  * specific runtime facilities needed by the runtime.
  */
-public class RuntimeAggregatingPlugin implements Plugin {
+public final class RuntimeAggregatingPlugin implements Plugin {
+  private static final Logger logger = Logger.getLogger(ObjectGraph.class.getName());
 
   /** A list of {@code Linker.Plugin}s which will be consulted in-order to resolve requests. */
   private final Plugin[] plugins;
@@ -89,41 +93,47 @@
    * Obtains a module adapter for {@code module} from the first responding resolver.
    */
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
-    for (Plugin plugin : plugins) {
-      ModuleAdapter<T> result = plugin.getModuleAdapter(moduleClass, module);
-      if (result != null) {
+    for (int i = 0; i < plugins.length; i++) {
+      try {
+        ModuleAdapter<T> result = plugins[i].getModuleAdapter(moduleClass, module);
         result.module = (module != null) ? module : result.newModule();
         return result;
+      } catch (RuntimeException e) {
+        if (i == plugins.length - 1) throw e;
+        logNotFound("Module adapter", moduleClass.getName(), e);
       }
     }
-    throw new IllegalStateException("Could not find any valid ModuleAdapter for "
-        + ((module != null) ? module.getClass().getName() : moduleClass.getName()));
+    throw new AssertionError();
   }
 
   @Override public Binding<?> getAtInjectBinding(String key, String className,
       boolean mustBeInjectable) {
-    for (Plugin plugin : plugins) {
+    for (int i = 0; i < plugins.length; i++) {
       try {
-        Binding<?> binding = plugin.getAtInjectBinding(key, className, mustBeInjectable);
-        if (binding != null) {
-          return binding;
-        }
-      } catch (Exception e) {
-        // Let later resolvers try to fulfill this.
+        return plugins[i].getAtInjectBinding(key, className, mustBeInjectable);
+      } catch (RuntimeException e) {
+        if (i == plugins.length - 1) throw e;
+        logNotFound("Binding", className, e);
       }
     }
-    throw new IllegalStateException("No available @Inject handlers could be found "
-        + "for key " + key + " in class " + className);
+    throw new AssertionError();
   }
 
   @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    for (Plugin plugin : plugins) {
-      StaticInjection injection = plugin.getStaticInjection(injectedClass);
-      if (injection != null) {
-        return injection;
+    for (int i = 0; i < plugins.length; i++) {
+      try {
+        return plugins[i].getStaticInjection(injectedClass);
+      } catch (RuntimeException e) {
+        if (i == plugins.length - 1) throw e;
+        logNotFound("Static injection", injectedClass.getName(), e);
       }
     }
-    throw new IllegalStateException("No available static injection handlers could be found "
-        + "for requested class " + injectedClass.getName());
+    throw new AssertionError();
+  }
+
+  private void logNotFound(String type, String name, RuntimeException e) {
+    if (logger.isLoggable(Level.FINE)) {
+      logger.log(Level.FINE, String.format("%s for %s not found.", type, name), e);
+    }
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/StaticInjection.java b/core/src/main/java/dagger/internal/StaticInjection.java
index 85e3cbb..92a73a4 100644
--- a/core/src/main/java/dagger/internal/StaticInjection.java
+++ b/core/src/main/java/dagger/internal/StaticInjection.java
@@ -19,8 +19,6 @@
 
 /**
  * Injects the static fields of a class.
- *
- * @author Jesse Wilson
  */
 public abstract class StaticInjection {
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java b/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java
index b9ba40d..c6646a2 100644
--- a/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java
+++ b/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java
@@ -15,57 +15,43 @@
  */
 package dagger.internal.plugins.loading;
 
-import dagger.ObjectGraph;
 import dagger.internal.Binding;
 import dagger.internal.ModuleAdapter;
 import dagger.internal.Plugin;
 import dagger.internal.StaticInjection;
 import java.lang.reflect.Constructor;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 /**
- * A run-time {@code Binding.Resolver} which finds bindings by loading appropriately named adapter
- * classes.
+ * A runtime {@link Plugin} that loads generated classes.
  */
 public final class ClassloadingPlugin implements Plugin {
-  private static final Logger LOGGER = Logger.getLogger(ObjectGraph.class.getName());
-
   public static final String INJECT_ADAPTER_SUFFIX = "$InjectAdapter";
   public static final String MODULE_ADAPTER_SUFFIX = "$ModuleAdapter";
   public static final String STATIC_INJECTION_SUFFIX = "$StaticInjection";
 
-  /**
-   * Returns a module adapter loaded from the appropriately named class.
-   */
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
-    return instantiate(moduleClass.getName(), MODULE_ADAPTER_SUFFIX, "module");
+    return instantiate(moduleClass.getName(), MODULE_ADAPTER_SUFFIX);
   }
 
-  /**
-   * Returns an {@code @Inject} binding loaded from the appropriately named class.
-   */
-  @Override public Binding<?> getAtInjectBinding(String key, String className,
-      boolean mustBeInjectable) throws ClassNotFoundException {
-    return instantiate(className, INJECT_ADAPTER_SUFFIX, "@Inject");
+  @Override public Binding<?> getAtInjectBinding(
+      String key, String className, boolean mustBeInjectable) {
+    return instantiate(className, INJECT_ADAPTER_SUFFIX);
   }
 
-  /**
-   * Returns a {@code StaticInjection} binding loaded from the appropriately named class.
-   */
   @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    return instantiate(injectedClass.getName(), STATIC_INJECTION_SUFFIX, "static injection");
+    return instantiate(injectedClass.getName(), STATIC_INJECTION_SUFFIX);
   }
 
-  private <T> T instantiate(String className, String suffix, String kind) {
+  @SuppressWarnings("unchecked") // We use a naming convention to defend against mismatches.
+  private <T> T instantiate(String className, String suffix) {
+    String name = className + suffix;
     try {
-      Class<?> c = Class.forName(className + suffix);
-      Constructor<?> constructor = c.getConstructor();
+      Class<?> generatedClass = Class.forName(name);
+      Constructor<?> constructor = generatedClass.getConstructor();
       constructor.setAccessible(true);
       return (T) constructor.newInstance();
     } catch (Exception e) {
-      LOGGER.log(Level.FINE, String.format("No %s adapter for %s found.", kind, className), e);
-      return null;
+      throw new RuntimeException("Unexpected failure loading " + name, e);
     }
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
index 6593e74..edbca82 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
@@ -31,9 +31,10 @@
 import javax.inject.Singleton;
 
 /**
- * A runtime binding that injects the constructor and fields of a class.
+ * Injects the {@code @Inject}-annotated fields and constructors of a class
+ * using reflection.
  */
-public final class ReflectiveAtInjectBinding<T> extends Binding<T> {
+final class ReflectiveAtInjectBinding<T> extends Binding<T> {
   private final Field[] fields;
   private final Constructor<T> constructor;
   private final Class<?> supertype;
@@ -50,9 +51,9 @@
    *     supports members injection only.
    * @param supertype the injectable supertype, or null if the supertype is a
    */
-  private ReflectiveAtInjectBinding(String provideKey, String membersKey, boolean singleton, Class<?> type,
-      Field[] fields, Constructor<T> constructor, int parameterCount, Class<?> supertype,
-      String[] keys) {
+  private ReflectiveAtInjectBinding(String provideKey, String membersKey, boolean singleton,
+      Class<?> type, Field[] fields, Constructor<T> constructor, int parameterCount,
+      Class<?> supertype, String[] keys) {
     super(provideKey, membersKey, singleton, type);
     this.constructor = constructor;
     this.fields = fields;
@@ -62,6 +63,7 @@
     this.fieldBindings = new Binding<?>[fields.length];
   }
 
+  @SuppressWarnings("unchecked") // We're careful to make keys and bindings match up.
   @Override public void attach(Linker linker) {
     int k = 0;
     for (int i = 0; i < fields.length; i++) {
@@ -218,6 +220,7 @@
         parameterCount, supertype, keys.toArray(new String[keys.size()]));
   }
 
+  @SuppressWarnings("unchecked") // Class.getDeclaredConstructors is an unsafe API.
   private static <T> Constructor<T>[] getConstructorsForType(Class<T> type) {
     return (Constructor<T>[]) type.getDeclaredConstructors();
   }
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
index ee38ce4..881b0cf 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
@@ -32,7 +32,7 @@
 import java.util.Set;
 import javax.inject.Singleton;
 
-public class ReflectiveModuleAdapter extends ModuleAdapter<Object> {
+final class ReflectiveModuleAdapter extends ModuleAdapter<Object> {
   final Class<?> moduleClass;
 
   public ReflectiveModuleAdapter(Class<?> moduleClass, Module annotation) {
@@ -54,7 +54,6 @@
   }
 
   @Override public void getBindings(Map<String, Binding<?>> bindings) {
-    // Fall back to runtime reflection.
     for (Class<?> c = moduleClass; c != Object.class; c = c.getSuperclass()) {
       for (Method method : c.getDeclaredMethods()) {
         if (method.isAnnotationPresent(Provides.class)) {
@@ -80,19 +79,18 @@
   }
 
   @Override protected Object newModule() {
-    if (moduleClass.isInterface()) {
-      throw new IllegalStateException(moduleClass.getSimpleName() + " is an interface.");
-    }
     try {
-      try {
-        Constructor<?> includeConstructor = moduleClass.getDeclaredConstructor();
-        includeConstructor.setAccessible(true);
-        return includeConstructor.newInstance();
-      } catch (NoSuchMethodException e) {
-        return moduleClass.newInstance();
-      }
-    } catch (Exception e) {
-      throw new IllegalArgumentException("Unable to instantiate " + moduleClass.getName(), e);
+      Constructor<?> constructor = moduleClass.getDeclaredConstructor();
+      constructor.setAccessible(true);
+      return constructor.newInstance();
+    } catch (InvocationTargetException e) {
+      throw new IllegalArgumentException(e.getCause());
+    } catch (NoSuchMethodException e) {
+      throw new IllegalArgumentException("Failed to construct " + moduleClass.getName(), e);
+    } catch (InstantiationException e) {
+      throw new IllegalArgumentException("Failed to construct " + moduleClass.getName(), e);
+    } catch (IllegalAccessException e) {
+      throw new AssertionError();
     }
   }
 
@@ -121,6 +119,7 @@
       }
     }
 
+    @SuppressWarnings("unchecked") // We defined 'T' in terms of the method's return type.
     @Override public T get() {
       Object[] args = new Object[parameters.length];
       for (int i = 0; i < parameters.length; i++) {
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
index e70d4ea..7a1b6ee 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
@@ -27,48 +27,36 @@
 import javax.inject.Inject;
 
 /**
- * Resolves a {@code ModuleAdapter<T>} for a given module T
+ * Uses reflection to create bindings, module adapters and static injections.
  */
-public class ReflectivePlugin implements Plugin {
-
-  @Override
-  public Binding<?> getAtInjectBinding(String key, String className, boolean mustBeInjectable)
-      throws ClassNotFoundException {
+public final class ReflectivePlugin implements Plugin {
+  @Override public Binding<?> getAtInjectBinding(
+      String key, String className, boolean mustBeInjectable) {
+    Class<?> c;
     try {
-      Class<?> c = Class.forName(className);
-      if (c.isInterface()) {
-        return null;
-      }
-      return ReflectiveAtInjectBinding.create(c, mustBeInjectable);
-    } catch (Exception ignored) {
-      return null;
+      c = Class.forName(className);
+    } catch (ClassNotFoundException e) {
+      throw new RuntimeException(e);
     }
+    return ReflectiveAtInjectBinding.create(c, mustBeInjectable);
   }
 
-  /**
-   * Returns a module adapter that processes modules via reflection.
-   */
-  @Override
   @SuppressWarnings("unchecked") // Runtime checks validate that the result type matches 'T'.
-  public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
+  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
     Module annotation = moduleClass.getAnnotation(Module.class);
     if (annotation == null) {
-      // TODO(cgruber): Should we throw, or just return no module adapter?
       throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
     }
     return (ModuleAdapter<T>) new ReflectiveModuleAdapter(moduleClass, annotation);
   }
 
-  @Override
-  public StaticInjection getStaticInjection(Class<?> injectedClass) {
+  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
     List<Field> fields = new ArrayList<Field>();
     for (Field field : injectedClass.getDeclaredFields()) {
-      if (field.getAnnotation(Inject.class) == null
-          || !Modifier.isStatic(field.getModifiers())) {
-        continue;
+      if (Modifier.isStatic(field.getModifiers()) && field.isAnnotationPresent(Inject.class)) {
+        field.setAccessible(true);
+        fields.add(field);
       }
-      field.setAccessible(true);
-      fields.add(field);
     }
     if (fields.isEmpty()) {
       throw new IllegalArgumentException("No static injections: " + injectedClass.getName());
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveStaticInjection.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveStaticInjection.java
index 0cdb02b..519d7ce 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveStaticInjection.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveStaticInjection.java
@@ -21,8 +21,10 @@
 import dagger.internal.StaticInjection;
 import java.lang.reflect.Field;
 
-/** Performs static injection on a class by means of reflection. */
-public  class ReflectiveStaticInjection extends StaticInjection {
+/**
+ * Uses reflection to inject the static fields of a class.
+ */
+final class ReflectiveStaticInjection extends StaticInjection {
   private final Field[] fields;
   private Binding<?>[] bindings;
 
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionTest.java b/core/src/test/java/dagger/ExtensionTest.java
index 24c65ad..a4b9c97 100644
--- a/core/src/test/java/dagger/ExtensionTest.java
+++ b/core/src/test/java/dagger/ExtensionTest.java
@@ -48,11 +48,11 @@
 
   @Module(entryPoints = { A.class, B.class }) static class RootModule { }
 
-  @Module(augments = RootModule.class, entryPoints = { C.class, D.class })
+  @Module(addsTo = RootModule.class, entryPoints = { C.class, D.class })
   static class ExtensionModule { }
 
   @Test public void basicExtension() {
-    assertNotNull(ObjectGraph.create(new RootModule()).extend(new ExtensionModule()));
+    assertNotNull(ObjectGraph.create(new RootModule()).plus(new ExtensionModule()));
   }
 
   @Test public void basicInjection() {
@@ -64,7 +64,7 @@
     assertFailNoEntryPoint(root, D.class); // Not declared in RootModule.
 
     // Extension graph behaves as the root graph would for root-ish things.
-    ObjectGraph extension = root.extend(new ExtensionModule());
+    ObjectGraph extension = root.plus(new ExtensionModule());
     assertThat(root.get(A.class)).isSameAs(extension.get(A.class));
     assertThat(root.get(B.class)).isNotSameAs(extension.get(B.class));
     assertThat(root.get(B.class).a).isSameAs(extension.get(B.class).a);
@@ -81,8 +81,8 @@
     assertFailNoEntryPoint(app, C.class);
     assertFailNoEntryPoint(app, D.class);
 
-    ObjectGraph request1 = app.extend(new ExtensionModule());
-    ObjectGraph request2 = app.extend(new ExtensionModule());
+    ObjectGraph request1 = app.plus(new ExtensionModule());
+    ObjectGraph request2 = app.plus(new ExtensionModule());
     for (ObjectGraph request : Arrays.asList(request1, request2)) {
       assertThat(request.get(A.class)).isNotNull();
       assertThat(request.get(A.class)).isSameAs(request.get(A.class));
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index 2349045..99a3d56 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -459,7 +459,7 @@
     assertThat(entryPoint.listOfStrings).isEqualTo(Arrays.asList("a", "b"));
   }
 
-  @Test public void injectWilcardType() {
+  @Test public void injectWildcardType() {
     class TestEntryPoint {
       @Inject List<? extends Number> listOfNumbers;
     }
@@ -619,4 +619,27 @@
     } catch (IllegalStateException expected) {
     }
   }
+
+  static class TwoAtInjectConstructors {
+    @Inject TwoAtInjectConstructors() {
+    }
+    @Inject TwoAtInjectConstructors(String s) {
+    }
+  }
+
+  @Test public void twoAtInjectConstructorsIsRejected() {
+    @Module(entryPoints = TwoAtInjectConstructors.class)
+    class TestModule {
+      @Provides String provideString() {
+        throw new AssertionError();
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    try {
+      graph.validate();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
 }
/Fim/
diff --git a/core/src/test/java/dagger/internal/KeysTest.java b/core/src/test/java/dagger/internal/KeysTest.java
index b1de562..fe2b85f 100644
--- a/core/src/test/java/dagger/internal/KeysTest.java
+++ b/core/src/test/java/dagger/internal/KeysTest.java
@@ -29,9 +29,6 @@
 
 import static org.fest.assertions.Assertions.assertThat;
 
-/**
- * @author Jesse Wilson
- */
 public final class KeysTest {
   int primitive;
   @Test public void lonePrimitiveGetsBoxed() throws NoSuchFieldException {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index a0a404a..c079f81 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -22,7 +22,15 @@
 import dagger.internal.Linker;
 import dagger.internal.ModuleAdapter;
 import dagger.internal.SetBinding;
-
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicInteger;
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
@@ -38,15 +46,6 @@
 import javax.lang.model.type.TypeMirror;
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicInteger;
 
 import static dagger.internal.plugins.loading.ClassloadingPlugin.MODULE_ADAPTER_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
@@ -167,7 +166,7 @@
     StringBuilder entryPointsField = new StringBuilder().append("{ ");
     for (Object entryPoint : entryPoints) {
       TypeMirror typeMirror = (TypeMirror) entryPoint;
-      String key = GeneratorKeys.get(typeMirror);
+      String key = GeneratorKeys.rawMembersKey(typeMirror);
       entryPointsField.append(JavaWriter.stringLiteral(key)).append(", ");
     }
     entryPointsField.append("}");
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index e1225d3..349213c 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -219,8 +219,9 @@
    */
   public <T> T get(Class<T> type) {
     String key = Keys.get(type);
+    String entryPointKey = Keys.getMembersKey(type);
     @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
-    Binding<T> binding = (Binding<T>) getEntryPointBinding(key, key);
+    Binding<T> binding = (Binding<T>) getEntryPointBinding(entryPointKey, key);
     return binding.get();
   }
 
@@ -232,16 +233,16 @@
    *     not one of this object graph's entry point types.
    */
   public void inject(Object instance) {
-    String entryPointKey = Keys.get(instance.getClass());
     String membersKey = Keys.getMembersKey(instance.getClass());
     @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
-    Binding<Object> binding = (Binding<Object>) getEntryPointBinding(entryPointKey, membersKey);
+    Binding<Object> binding = (Binding<Object>) getEntryPointBinding(membersKey, membersKey);
     binding.injectMembers(instance);
   }
 
   /**
    * @param entryPointKey the key used to store the entry point. This is always
-   *     a regular (provider) key.
+   *     a members injection key because those keys can always be created, even
+   *     if the type has no injectable constructor.
    * @param key the key to use when retrieving the binding. This may be a
    *     regular (provider) key or a members key.
    */
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
index 881b0cf..b0317bc 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
@@ -37,7 +37,7 @@
 
   public ReflectiveModuleAdapter(Class<?> moduleClass, Module annotation) {
     super(
-        toKeys(annotation.entryPoints()),
+        toMemberKeys(annotation.entryPoints()),
         annotation.staticInjections(),
         annotation.overrides(),
         annotation.includes(),
@@ -45,10 +45,10 @@
     this.moduleClass = moduleClass;
   }
 
-  private static String[] toKeys(Class<?>[] entryPoints) {
+  private static String[] toMemberKeys(Class<?>[] entryPoints) {
     String[] result = new String[entryPoints.length];
     for (int i = 0; i < entryPoints.length; i++) {
-      result[i] = Keys.get(entryPoints[i]);
+      result[i] = Keys.getMembersKey(entryPoints[i]);
     }
     return result;
   }
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index b158132..fab618f 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -613,6 +613,8 @@
   }
 
   static class NoInjections {
+    NoInjections(Void noDefaultConstructorEither) {
+    }
   }
 
   @Test public void entryPointNeedsNoInjectAnnotation() {
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index fab618f..40e1e6c 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -625,6 +625,32 @@
     ObjectGraph.create(new TestModule()).validate();
   }
 
+  static class InjectMembersOnly {
+    InjectMembersOnly(Void noInjectableConstructor) {
+    }
+    @Inject String string;
+  }
+
+  @Test public void cannotGetOnMembersOnlyInjectionPoint() {
+    @Module(entryPoints = InjectMembersOnly.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    try {
+      graph.get(InjectMembersOnly.class);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    InjectMembersOnly instance = new InjectMembersOnly(null);
+    graph.inject(instance);
+    assertThat(instance.string).isEqualTo("injected");
+  }
+
   @Test public void nonEntryPointNeedsInjectAnnotation() {
     @Module
     class TestModule {
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index d9cdaaf..faad259 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -115,8 +115,14 @@
           toLink.add(jitBinding);
           putBinding(jitBinding);
         } catch (Exception e) {
-          addError(e.getMessage() + " required by " + binding.requiredBy);
-          bindings.put(key, Binding.UNRESOLVED);
+          if (e.getMessage() != null) {
+            addError(e.getMessage() + " required by " + binding.requiredBy);
+            bindings.put(key, Binding.UNRESOLVED);
+          } else if (e instanceof RuntimeException) {
+            throw (RuntimeException) e;
+          } else {
+            throw new RuntimeException(e);
+          }
         }
       } else {
         // Attempt to attach the binding to its dependencies. If any dependency
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
index 7a1b6ee..99ead70 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
@@ -38,6 +38,11 @@
     } catch (ClassNotFoundException e) {
       throw new RuntimeException(e);
     }
+
+    if (c.isInterface()) {
+      return null;
+    }
+
     return ReflectiveAtInjectBinding.create(c, mustBeInjectable);
   }
 
/Fim/
diff --git a/compiler/src/it/uninjectable-supertype/pom.xml b/compiler/src/it/uninjectable-supertype/pom.xml
new file mode 100644
index 0000000..ad161b5
--- /dev/null
+++ b/compiler/src/it/uninjectable-supertype/pom.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2012 Square, Inc.
+ Copyright (C) 2012 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.squareup.dagger.tests</groupId>
+  <artifactId>uninjectable-supertype</artifactId>
+  <version>@dagger.version@</version>
+  <packaging>jar</packaging>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <scope>provided</scope>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/uninjectable-supertype/src/main/java/test/TestApp.java b/compiler/src/it/uninjectable-supertype/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..71b29f0
--- /dev/null
+++ b/compiler/src/it/uninjectable-supertype/src/main/java/test/TestApp.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Inject;
+
+class TestApp {
+  static class NotInjectable {
+  }
+
+  static class InjectableSubclass extends NotInjectable {
+    @Inject String string;
+  }
+
+  @Module(entryPoints = InjectableSubclass.class)
+  static class TestModule {
+    @Provides String provideString() {
+      return "string";
+    }
+  }
+}
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index c42eab1..594e485 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -221,7 +221,7 @@
           typeName);
     }
     if (supertype != null) {
-      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
+      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class, false)",
           "supertype",
           CodeGen.parameterizedType(Binding.class, CodeGen.rawTypeToString(supertype, '.')),
           JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(supertype)),
/Fim/
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index 83e20a5..9c47111 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -59,6 +59,11 @@
     return Collections.unmodifiableSet(result);
   }
 
+  @Override public void getDependencies(
+      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
+    getBindings.addAll(contributors);
+  }
+
   @Override public String toString() {
     return "SetBinding" + contributors;
   }
/Fim/
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index a69615f..7e39135 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -170,6 +170,21 @@
     assertThat(logoutput.get()).contains("NullPointerException");
   }
 
+  @Test public void validateSetBinding() {
+    class TestEntryPoint {
+      @Inject Set<String> strings;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides(type=SET) String provideString1() { return "string1"; }
+      @Provides(type=SET) String provideString2() { return "string2"; }
+    }
+
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    graph.validate();
+  }
+
   static class Logger {
     @Inject Set<LogSink> loggers;
     public void log(String text, Throwable error) {
/Fim/
diff --git a/compiler/src/it/multiple-provides-methods/pom.xml b/compiler/src/it/multiple-provides-methods/pom.xml
new file mode 100644
index 0000000..db65c51
--- /dev/null
+++ b/compiler/src/it/multiple-provides-methods/pom.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2012 Square, Inc.
+ Copyright (C) 2012 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.squareup.dagger.tests</groupId>
+  <artifactId>multiple-provides-methods</artifactId>
+  <version>@dagger.version@</version>
+  <packaging>jar</packaging>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/multiple-provides-methods/src/main/java/test/TestApp.java b/compiler/src/it/multiple-provides-methods/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..5955bd6
--- /dev/null
+++ b/compiler/src/it/multiple-provides-methods/src/main/java/test/TestApp.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Inject;
+
+class TestApp {
+  static class NotInjectable {
+  }
+
+  static class InjectableSubclass extends NotInjectable {
+    @Inject String string;
+    @Inject Integer integer;
+  }
+
+  @Module(entryPoints = InjectableSubclass.class)
+  static class TestModule {
+    @Provides String string() {
+      return "string";
+    }
+    @Provides Integer integer() {
+      return 5;
+    }
+  }
+}
/Fim/
diff --git a/compiler/src/it/multiple-provides-methods/verify.bsh b/compiler/src/it/multiple-provides-methods/verify.bsh
new file mode 100644
index 0000000..065faf2
--- /dev/null
+++ b/compiler/src/it/multiple-provides-methods/verify.bsh
@@ -0,0 +1,12 @@
+import java.io.File;
+
+File classes = new File(basedir, "target/classes/test/");
+
+File moduleAdapter = new File(classes, "TestApp$TestModule$ModuleAdapter.class");
+if (!moduleAdapter.exists()) throw new Exception("No binding generated for module"); 
+
+File integerBinding = new File(classes, "TestApp$TestModule$ModuleAdapter$IntegerBinding.class");
+if (!integerBinding.exists()) throw new Exception("No binding generated for integer()"); 
+
+File stringBinding = new File(classes, "TestApp$TestModule$ModuleAdapter$StringBinding.class");
+if (!stringBinding.exists()) throw new Exception("No binding generated for string()"); 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 73ea3ed..e8ba3e0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -15,13 +15,12 @@
  */
 package dagger.internal.codegen;
 
-import static dagger.internal.plugins.loading.ClassloadingPlugin.MODULE_ADAPTER_SUFFIX;
-import static java.lang.reflect.Modifier.FINAL;
-import static java.lang.reflect.Modifier.PRIVATE;
-import static java.lang.reflect.Modifier.PROTECTED;
-import static java.lang.reflect.Modifier.PUBLIC;
-import static java.lang.reflect.Modifier.STATIC;
-
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.Binding;
+import dagger.internal.Linker;
+import dagger.internal.ModuleAdapter;
+import dagger.internal.SetBinding;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -32,7 +31,6 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
-
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
@@ -49,12 +47,12 @@
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
-import dagger.Module;
-import dagger.Provides;
-import dagger.internal.Binding;
-import dagger.internal.Linker;
-import dagger.internal.ModuleAdapter;
-import dagger.internal.SetBinding;
+import static dagger.internal.plugins.loading.ClassloadingPlugin.MODULE_ADAPTER_SUFFIX;
+import static java.lang.reflect.Modifier.FINAL;
+import static java.lang.reflect.Modifier.PRIVATE;
+import static java.lang.reflect.Modifier.PROTECTED;
+import static java.lang.reflect.Modifier.PUBLIC;
+import static java.lang.reflect.Modifier.STATIC;
 
 /**
  * Generates an implementation of {@link ModuleAdapter} that includes a binding
@@ -129,7 +127,7 @@
         continue;
       }
 
-      List<ExecutableElement> methods = result.get(type);
+      List<ExecutableElement> methods = result.get(type.toString());
       if (methods == null) {
         methods = new ArrayList<ExecutableElement>();
         result.put(type.toString(), methods);
/Fim/
diff --git a/compiler/src/it/inject-parameterized-type/pom.xml b/compiler/src/it/inject-parameterized-type/pom.xml
new file mode 100644
index 0000000..45b685c
--- /dev/null
+++ b/compiler/src/it/inject-parameterized-type/pom.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2013 Square, Inc.
+ Copyright (C) 2013 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.squareup.dagger.tests</groupId>
+  <artifactId>inject-parameterized-type</artifactId>
+  <version>@dagger.version@</version>
+  <packaging>jar</packaging>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/inject-parameterized-type/src/main/java/test/TestApp.java b/compiler/src/it/inject-parameterized-type/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..08243f2
--- /dev/null
+++ b/compiler/src/it/inject-parameterized-type/src/main/java/test/TestApp.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import dagger.Provides;
+import javax.inject.Inject;
+
+class TestApp {
+  public static void main(String[] args) {
+    Subtype subtype = ObjectGraph.create(new TestModule()).get(Subtype.class);
+  }
+
+  static class Supertype<T> {
+    @Inject String s;
+  }
+
+  static class Subtype extends Supertype<Integer> {
+  }
+
+  @Module(entryPoints = Subtype.class)
+  static class TestModule {
+    @Provides String provideString() {
+      return "a";
+    }
+  }
+}
/Fim/
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java b/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
index 21444f6..d4ab7df 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
@@ -143,6 +143,7 @@
         return null;
       }
       @Override public Void visitTypeVariable(TypeVariable typeVariable, Void v) {
+        result.append(typeVariable); // TypeVariable.toString() returns the name, like 'T'.
         return null;
       }
       @Override protected Void defaultAction(TypeMirror typeMirror, Void v) {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 9e285d7..48fd287 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -112,7 +112,8 @@
     // First gather the set of classes that have @Inject-annotated members.
     Set<String> injectedTypeNames = new LinkedHashSet<String>();
     for (Element element : env.getElementsAnnotatedWith(Inject.class)) {
-      injectedTypeNames.add(element.getEnclosingElement().asType().toString());
+      TypeMirror type = element.getEnclosingElement().asType();
+      injectedTypeNames.add(CodeGen.rawTypeToString(type, '.'));
     }
     return injectedTypeNames;
   }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
index 5ffb5ce..e18cb91 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
@@ -122,6 +122,14 @@
     }
   }
 
+  @Override public Object get() {
+    throw new AssertionError("Compile-time binding should never be called to inject.");
+  }
+
+  @Override public void injectMembers(Object t) {
+    throw new AssertionError("Compile-time binding should never be called to inject.");
+  }
+
   @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
     for (Binding<?> binding : bindings) {
       get.add(binding);
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 98c2573..3a1385e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -203,6 +203,10 @@
       }
     }
 
+    @Override public void injectMembers(Object t) {
+      throw new UnsupportedOperationException(); // not a member injection binding.
+    }
+
     @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
       for (Binding<?> binding : parameters) {
         get.add(binding);
/Fim/
diff --git a/core/src/main/java/dagger/internal/Binding.java b/core/src/main/java/dagger/internal/Binding.java
index ee5873c..1fe88a6 100644
--- a/core/src/main/java/dagger/internal/Binding.java
+++ b/core/src/main/java/dagger/internal/Binding.java
@@ -23,7 +23,14 @@
  * Injects a value of a specific type.
  */
 public abstract class Binding<T> implements Provider<T>, MembersInjector<T> {
-  public static final Binding<Object> UNRESOLVED = new Binding<Object>(null, null, false, null) { };
+  public static final Binding<Object> UNRESOLVED = new Binding<Object>(null, null, false, null) {
+    @Override public Object get() {
+      throw new AssertionError("Unresolved binding should never be called to inject.");
+    }
+    @Override public void injectMembers(Object t) {
+      throw new AssertionError("Unresolved binding should never be called to inject.");
+    }
+  };
   protected static final boolean IS_SINGLETON = true;
   protected static final boolean NOT_SINGLETON = false;
 
@@ -67,7 +74,8 @@
   }
 
   @Override public void injectMembers(T t) {
-    throw new UnsupportedOperationException("No injectable members on " + getClass().getName());
+    // If no members to inject, no-op.  Some classes will have no injectable members even
+    // if their supertypes do.
   }
 
   @Override public T get() {
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 042dbbe..6a016eb 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -332,6 +332,9 @@
       this.deferredKey = deferredKey;
       this.mustBeInjectable = mustBeInjectable;
     }
+    @Override public void injectMembers(Object t) {
+      throw new UnsupportedOperationException("Deferred bindings must resolve first.");
+    }
     @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
       throw new UnsupportedOperationException("Deferred bindings must resolve first.");
     }
/Fim/
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index 9c47111..afb040c 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -64,6 +64,10 @@
     getBindings.addAll(contributors);
   }
 
+  @Override public void injectMembers(Set<T> t) {
+    throw new UnsupportedOperationException(); // not a member injection binding.
+  }
+
   @Override public String toString() {
     return "SetBinding" + contributors;
   }
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
index 2d3efe8..9b8d1aa 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
@@ -148,6 +148,10 @@
       }
     }
 
+    @Override public void injectMembers(T t) {
+      throw new UnsupportedOperationException(); // not a member injection binding.
+    }
+
     @Override public String toString() {
       return method.toString();
     }
/Fim/
diff --git a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
index eb05c40..250e08a 100644
--- a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
+++ b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
@@ -15,8 +15,8 @@
  */
 package dagger.androidmanifest;
 
+import com.squareup.java.JavaWriter;
 import dagger.Module;
-import dagger.internal.codegen.JavaWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
/Fim/
diff --git a/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java b/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
index e7de2ac..3e1cf68 100644
--- a/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
+++ b/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
@@ -15,7 +15,7 @@
  */
 package dagger.androidmanifest;
 
-import dagger.internal.codegen.JavaWriter;
+import com.squareup.java.JavaWriter;
 import java.io.IOException;
 import java.io.StringReader;
 import java.io.StringWriter;
@@ -137,8 +137,8 @@
         new JavaWriter(stringWriter));
     assertCode(""
         + "package com.squareup.badhorse;\n"
-        + "import dagger.Module;\n"
         + "\n"
+        + "import dagger.Module;\n"
         + "@Module(\n"
         + "  entryPoints = {\n"
         + "    com.squareup.badhorse.LeagueOfEvilActivity.class,\n"
@@ -157,8 +157,8 @@
         new JavaWriter(stringWriter));
     assertCode(""
         + "package com.squareup.badhorse;\n"
-        + "import dagger.Module;\n"
         + "\n"
+        + "import dagger.Module;\n"
         + "@Module(\n"
         + "  entryPoints = {\n"
         + "  },\n"
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index b9e29a3..bbd57a4 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -37,6 +37,10 @@
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>javawriter</artifactId>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/DotWriter.java b/compiler/src/main/java/dagger/internal/codegen/DotWriter.java
index 4fb8c92..51b7978 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DotWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DotWriter.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.squareup.java.JavaWriter;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.Writer;
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 0165fd9..57e68c3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.squareup.java.JavaWriter;
 import dagger.MembersInjector;
 import dagger.internal.Binding;
 import dagger.internal.Linker;
/Fim/
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 211845b..8f1f05e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.squareup.java.JavaWriter;
 import dagger.Module;
 import dagger.Provides;
 import dagger.internal.Binding;
@@ -191,7 +192,7 @@
       entryPointsField.append(JavaWriter.stringLiteral(key)).append(", ");
     }
     entryPointsField.append("}");
-    writer.field("String[]", "ENTRY_POINTS", PRIVATE | STATIC | FINAL,
+    writer.emitField("String[]", "ENTRY_POINTS", PRIVATE | STATIC | FINAL,
         entryPointsField.toString());
 
     StringBuilder staticInjectionsField = new StringBuilder().append("{ ");
@@ -200,7 +201,7 @@
       staticInjectionsField.append(CodeGen.typeToString(typeMirror)).append(".class, ");
     }
     staticInjectionsField.append("}");
-    writer.field("Class<?>[]", "STATIC_INJECTIONS", PRIVATE | STATIC | FINAL,
+    writer.emitField("Class<?>[]", "STATIC_INJECTIONS", PRIVATE | STATIC | FINAL,
         staticInjectionsField.toString());
 
     StringBuilder includesField = new StringBuilder().append("{ ");
@@ -215,7 +216,7 @@
       includesField.append(CodeGen.typeToString(typeMirror)).append(".class, ");
     }
     includesField.append("}");
-    writer.field("Class<?>[]", "INCLUDES", PRIVATE | STATIC | FINAL, includesField.toString());
+    writer.emitField("Class<?>[]", "INCLUDES", PRIVATE | STATIC | FINAL, includesField.toString());
 
     writer.emitEmptyLine();
     writer.beginMethod(null, adapterName, PUBLIC);
/Fim/
/Fim/
diff --git a/pom.xml b/pom.xml
index d9b59a8..d488e12 100644
--- a/pom.xml
+++ b/pom.xml
@@ -46,6 +46,7 @@
     <javax.inject.version>1</javax.inject.version>
     <maven.version>2.0.6</maven.version>
     <ant.version>1.8.2</ant.version>
+    <javawriter.version>1.0.1</javawriter.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
@@ -99,6 +100,11 @@
         <version>${ant.version}</version>
       </dependency>
       <dependency>
+        <groupId>com.squareup</groupId>
+        <artifactId>javawriter</artifactId>
+        <version>${javawriter.version}</version>
+      </dependency>
+      <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
         <version>${junit.version}</version>
/Fim/
diff --git a/compiler/src/it/cyclic-deps/invoker.properties b/compiler/src/it/cyclic-deps/invoker.properties
new file mode 100644
index 0000000..324b5fb
--- /dev/null
+++ b/compiler/src/it/cyclic-deps/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
\ No newline at end of file
/Fim/
diff --git a/compiler/src/it/cyclic-deps/pom.xml b/compiler/src/it/cyclic-deps/pom.xml
new file mode 100644
index 0000000..c0d5ee7
--- /dev/null
+++ b/compiler/src/it/cyclic-deps/pom.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2013 Square, Inc.
+ Copyright (C) 2013 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.squareup.dagger.tests</groupId>
+  <version>@dagger.version@</version>
+  <packaging>jar</packaging>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
+      </plugin>
+    </plugins>
+  </build>
+  <artifactId>cyclic-deps</artifactId>
+</project>
/Fim/
diff --git a/compiler/src/it/cyclic-deps/src/main/java/test/TestApp.java b/compiler/src/it/cyclic-deps/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..82741d2
--- /dev/null
+++ b/compiler/src/it/cyclic-deps/src/main/java/test/TestApp.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import dagger.Provides;
+import javax.inject.Inject;
+
+class TestApp implements Runnable {
+  
+  static class Foo {
+    @Inject Foo(@SuppressWarnings("unused") Bar b) { }
+  }
+  
+  static class Bar {
+    @Inject Bar(@SuppressWarnings("unused") Blah b) { }
+  }
+  
+  static class Blah {
+    @Inject Blah(@SuppressWarnings("unused") Foo f) { }
+  }
+  
+  static class EntryPoint {
+    @Inject Foo f;
+  }
+
+  @Module(entryPoints = EntryPoint.class)
+  static class TestModule {
+    
+  }
+  
+  static class A { }
+  static class B { }
+  static class C { }
+  static class D { }
+  @Module(entryPoints = D.class)
+  static class CyclicModule {
+    @Provides A a(@SuppressWarnings("unused") D d) { }
+    @Provides B b(@SuppressWarnings("unused") A a) { }
+    @Provides C c(@SuppressWarnings("unused") B b) { }
+    @Provides D d(@SuppressWarnings("unused") C c) { }
+  }
+}
/Fim/
diff --git a/compiler/src/it/cyclic-deps/verify.bsh b/compiler/src/it/cyclic-deps/verify.bsh
new file mode 100644
index 0000000..43b8f75
--- /dev/null
+++ b/compiler/src/it/cyclic-deps/verify.bsh
@@ -0,0 +1,9 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "TestApp.java:", "[43", "error:", "Graph validation failed:", "Dependency cycle:"});
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "TestApp.java:", "[52", "error:", "Graph validation failed:", "Dependency cycle:"});
+    
\ No newline at end of file
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index ffc3489..3cfb746 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -19,6 +19,7 @@
 import dagger.Provides;
 import dagger.internal.Binding;
 import dagger.internal.Linker;
+import dagger.internal.ProblemDetector;
 import dagger.internal.SetBinding;
 import java.io.IOException;
 import java.io.Writer;
@@ -64,6 +65,10 @@
       // Storing module names for later retrieval as the element instance is invalidated across
       // passes.
       for (Element e : env.getElementsAnnotatedWith(Module.class)) {
+        if (!(e instanceof TypeElement)) {
+          error("@Module applies to a type, " + e.getSimpleName() + " is a " + e.getKind(), e);
+          continue;
+        }
         delayedModuleNames.add(((TypeElement) e).getQualifiedName().toString());
       }
       return true;
@@ -82,9 +87,14 @@
       TypeElement moduleType = (TypeElement) element;
       Map<String, Binding<?>> bindings = processCompleteModule(moduleType);
       try {
+        new ProblemDetector().detectProblems(bindings.values());
+      } catch (IllegalStateException e) {
+        error("Graph validation failed: " + e.getMessage(), moduleType);
+      }
+      try {
         writeDotFile(moduleType, bindings);
       } catch (IOException e) {
-        error("Graph processing failed: " + e, moduleType);
+        error("Graph visualization failed: " + e, moduleType);
       }
     }
     return true;
/Fim/
diff --git a/core/src/main/java/dagger/internal/ProblemDetector.java b/core/src/main/java/dagger/internal/ProblemDetector.java
index e58b51f..42323c9 100644
--- a/core/src/main/java/dagger/internal/ProblemDetector.java
+++ b/core/src/main/java/dagger/internal/ProblemDetector.java
@@ -62,7 +62,7 @@
   }
 
   static class ArraySet<T> extends AbstractSet<T> {
-    private ArrayList<T> list = new ArrayList<T>();
+    private final ArrayList<T> list = new ArrayList<T>();
 
     @Override public boolean add(T t) {
       list.add(t);
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 3cfb746..c3cbb3e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -90,6 +90,7 @@
         new ProblemDetector().detectProblems(bindings.values());
       } catch (IllegalStateException e) {
         error("Graph validation failed: " + e.getMessage(), moduleType);
+        continue;
       }
       try {
         writeDotFile(moduleType, bindings);
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
new file mode 100644
index 0000000..cd81b36
--- /dev/null
+++ b/examples/pom.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2012 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup</groupId>
+    <artifactId>dagger-parent</artifactId>
+    <version>1.0-SNAPSHOT</version>
+  </parent>
+
+  <groupId>com.squareup.dagger.example</groupId>
+  <artifactId>dagger-example-parent</artifactId>
+  <packaging>pom</packaging>
+  <name>Dagger Example (Parent)</name>
+
+  <modules>
+    <module>simple</module>
+  </modules>
+
+</project>
/Fim/
diff --git a/example/pom.xml b/examples/simple/pom.xml
similarity index 84%
rename from example/pom.xml
rename to examples/simple/pom.xml
index c6cd863..bc17f01 100644
--- a/example/pom.xml
+++ b/examples/simple/pom.xml
@@ -18,24 +18,23 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup</groupId>
-    <artifactId>dagger-parent</artifactId>
+    <groupId>com.squareup.dagger.example</groupId>
+    <artifactId>dagger-example-parent</artifactId>
     <version>1.0-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
   </parent>
 
-  <artifactId>dagger-example</artifactId>
+  <artifactId>simple-dagger-example</artifactId>
   <packaging>jar</packaging>
-  <name>Dagger Example</name>
+  <name>Dagger Example - Simple</name>
 
   <dependencies>
     <dependency>
-      <groupId>${project.groupId}</groupId>
+      <groupId>com.squareup</groupId>
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>${project.groupId}</groupId>
+      <groupId>com.squareup</groupId>
       <artifactId>dagger-compiler</artifactId>
       <version>${project.version}</version>
       <optional>true</optional>
/Fim/
diff --git a/example/src/main/java/coffee/CoffeeApp.java b/examples/simple/src/main/java/coffee/CoffeeApp.java
similarity index 100%
rename from example/src/main/java/coffee/CoffeeApp.java
rename to examples/simple/src/main/java/coffee/CoffeeApp.java
/Fim/
diff --git a/example/src/main/java/coffee/CoffeeMaker.java b/examples/simple/src/main/java/coffee/CoffeeMaker.java
similarity index 100%
rename from example/src/main/java/coffee/CoffeeMaker.java
rename to examples/simple/src/main/java/coffee/CoffeeMaker.java
/Fim/
diff --git a/example/src/main/java/coffee/DripCoffeeModule.java b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
similarity index 100%
rename from example/src/main/java/coffee/DripCoffeeModule.java
rename to examples/simple/src/main/java/coffee/DripCoffeeModule.java
/Fim/
diff --git a/example/src/main/java/coffee/ElectricHeater.java b/examples/simple/src/main/java/coffee/ElectricHeater.java
similarity index 100%
rename from example/src/main/java/coffee/ElectricHeater.java
rename to examples/simple/src/main/java/coffee/ElectricHeater.java
/Fim/
diff --git a/example/src/main/java/coffee/Heater.java b/examples/simple/src/main/java/coffee/Heater.java
similarity index 100%
rename from example/src/main/java/coffee/Heater.java
rename to examples/simple/src/main/java/coffee/Heater.java
/Fim/
diff --git a/example/src/main/java/coffee/Pump.java b/examples/simple/src/main/java/coffee/Pump.java
similarity index 100%
rename from example/src/main/java/coffee/Pump.java
rename to examples/simple/src/main/java/coffee/Pump.java
/Fim/
diff --git a/example/src/main/java/coffee/PumpModule.java b/examples/simple/src/main/java/coffee/PumpModule.java
similarity index 100%
rename from example/src/main/java/coffee/PumpModule.java
rename to examples/simple/src/main/java/coffee/PumpModule.java
/Fim/
diff --git a/example/src/main/java/coffee/Thermosiphon.java b/examples/simple/src/main/java/coffee/Thermosiphon.java
similarity index 100%
rename from example/src/main/java/coffee/Thermosiphon.java
rename to examples/simple/src/main/java/coffee/Thermosiphon.java
/Fim/
diff --git a/pom.xml b/pom.xml
index c9720c4..260a858 100644
--- a/pom.xml
+++ b/pom.xml
@@ -35,7 +35,7 @@
     <module>androidmanifest</module>
     <module>compiler</module>
     <module>core</module>
-    <module>example</module>
+    <module>examples</module>
   </modules>
 
   <properties>
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 1ebece3..bf57d63 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -146,6 +146,15 @@
       methods.add(providerMethodAsExecutable);
     }
 
+    // catch any stray modules without @Provides since their entry points
+    // should still be registered and a ModuleAdapter should still be written.
+    for (Element type : env.getElementsAnnotatedWith(Module.class)) {
+      if (type.getKind().equals(ElementKind.CLASS)) {
+        String moduleType = ((TypeElement) type).getQualifiedName().toString();
+        if (result.containsKey(moduleType)) continue;
+        result.put(moduleType, new ArrayList<ExecutableElement>());
+      }
+    }
     return result;
   }
 
@@ -184,7 +193,8 @@
     writer.emitEndOfLineComment(ProcessorJavadocs.GENERATED_BY_DAGGER);
     writer.emitPackage(CodeGen.getPackage(type).getQualifiedName().toString());
     writer.emitEmptyLine();
-    writer.emitImports(getImports(multibindings, providerMethodDependencies));
+    writer.emitImports(
+        getImports(multibindings, !providerMethods.isEmpty(), providerMethodDependencies));
 
     String typeName = type.getQualifiedName().toString();
     writer.emitEmptyLine();
@@ -231,47 +241,47 @@
         + "INCLUDES, %s /*complete*/)", overrides, complete);
     writer.endMethod();
 
-    writer.emitEmptyLine();
-    writer.emitJavadoc(ProcessorJavadocs.GET_DEPENDENCIES_METHOD);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod("void", "getBindings", PUBLIC, BINDINGS_MAP, "map");
-
+    ExecutableElement noArgsConstructor = CodeGen.getNoArgsConstructor(type);
+    if (noArgsConstructor != null && CodeGen.isCallableConstructor(noArgsConstructor)) {
+      writer.emitEmptyLine();
+      writer.emitAnnotation(Override.class);
+      writer.beginMethod(typeName, "newModule", PROTECTED);
+      writer.emitStatement("return new %s()", typeName);
+      writer.endMethod();
+    }
+    // caches
     Map<ExecutableElement, String> methodToClassName
         = new LinkedHashMap<ExecutableElement, String>();
     Map<String, AtomicInteger> methodNameToNextId = new LinkedHashMap<String, AtomicInteger>();
-    for (ExecutableElement providerMethod : providerMethods) {
-      Provides provides = providerMethod.getAnnotation(Provides.class);
-      switch (provides.type()) {
-        case UNIQUE: {
-          String key = GeneratorKeys.get(providerMethod);
-          writer.emitStatement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
-              bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
-          break;
-        }
-        case SET: {
-          String key = GeneratorKeys.getElementKey(providerMethod);
-          writer.emitStatement("SetBinding.add(map, %s, new %s(module))",
-              JavaWriter.stringLiteral(key),
-              bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
-          break;
-        }
-        default:
-          throw new AssertionError("Unknown @Provides type " + provides.type());
-      }
-    }
-    writer.endMethod();
 
-    writer.emitEmptyLine();
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod(typeName, "newModule", PROTECTED);
-    ExecutableElement noArgsConstructor = CodeGen.getNoArgsConstructor(type);
-    if (noArgsConstructor != null && CodeGen.isCallableConstructor(noArgsConstructor)) {
-      writer.emitStatement("return new %s()", typeName);
-    } else {
-      writer.emitStatement("throw new UnsupportedOperationException(%s)",
-          JavaWriter.stringLiteral("No no-args constructor on " + type));
+    if (!providerMethods.isEmpty()) {
+      writer.emitEmptyLine();
+      writer.emitJavadoc(ProcessorJavadocs.GET_DEPENDENCIES_METHOD);
+      writer.emitAnnotation(Override.class);
+      writer.beginMethod("void", "getBindings", PUBLIC, BINDINGS_MAP, "map");
+
+      for (ExecutableElement providerMethod : providerMethods) {
+        Provides provides = providerMethod.getAnnotation(Provides.class);
+        switch (provides.type()) {
+          case UNIQUE: {
+            String key = GeneratorKeys.get(providerMethod);
+            writer.emitStatement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
+                bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
+            break;
+          }
+          case SET: {
+            String key = GeneratorKeys.getElementKey(providerMethod);
+            writer.emitStatement("SetBinding.add(map, %s, new %s(module))",
+                JavaWriter.stringLiteral(key),
+                bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
+            break;
+          }
+          default:
+            throw new AssertionError("Unknown @Provides type " + provides.type());
+        }
+      }
+      writer.endMethod();
     }
-    writer.endMethod();
 
     for (ExecutableElement providerMethod : providerMethods) {
       writeProvidesAdapter(writer, providerMethod, methodToClassName, methodNameToNextId);
@@ -281,12 +291,14 @@
     writer.close();
   }
 
-  private Set<String> getImports(boolean multibindings, boolean dependencies) {
+  private Set<String> getImports(boolean multibindings, boolean providers, boolean dependencies) {
     Set<String> imports = new LinkedHashSet<String>();
-    imports.add(Binding.class.getCanonicalName());
-    imports.add(Map.class.getCanonicalName());
-    imports.add(Provider.class.getCanonicalName());
     imports.add(ModuleAdapter.class.getCanonicalName());
+    if (providers) {
+      imports.add(Binding.class.getCanonicalName());
+      imports.add(Map.class.getCanonicalName());
+      imports.add(Provider.class.getCanonicalName());
+    }
     if (dependencies) {
       imports.add(Linker.class.getCanonicalName());
       imports.add(Set.class.getCanonicalName());
/Fim/
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index d4eafb4..c516be1 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -43,13 +43,17 @@
    * Returns bindings for the {@code @Provides} methods of {@code module}. The
    * returned bindings must be linked before they can be used to inject values.
    */
-  public abstract void getBindings(Map<String, Binding<?>> map);
+  public void getBindings(@SuppressWarnings("unused") Map<String, Binding<?>> map) {
+    // no-op;
+  }
 
   /**
    * Returns a new instance of the module class created using a no-args
    * constructor. Only used when a manually-constructed module is not supplied.
    */
-  protected abstract T newModule();
+  protected T newModule() {
+    throw new UnsupportedOperationException("No no-args constructor on " + getClass().getName());
+  }
 
   public T getModule() {
     return module;
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
index ab1e8ec..2e13917 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
@@ -91,7 +91,11 @@
     } catch (InvocationTargetException e) {
       throw new IllegalArgumentException(e.getCause());
     } catch (NoSuchMethodException e) {
-      throw new IllegalArgumentException("Failed to construct " + moduleClass.getName(), e);
+      throw new IllegalArgumentException("Could not construct " + moduleClass.getName()
+          + " as it lacks a no-args constructor.  If this was an upstream module of an extension"
+          + " graph then it should be noted by \"addsTo=\" and not \"includes=\".  Otherwise,"
+          + " this module must be passed in as an instance, or a no-args constructor must be"
+          + " added.", e);
     } catch (InstantiationException e) {
       throw new IllegalArgumentException("Failed to construct " + moduleClass.getName(), e);
     } catch (IllegalAccessException e) {
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionWithStateTest.java b/core/src/test/java/dagger/ExtensionWithStateTest.java
new file mode 100644
index 0000000..a5ce26b
--- /dev/null
+++ b/core/src/test/java/dagger/ExtensionWithStateTest.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2012 Google Inc.
+ * Copyright (C) 2012 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import javax.inject.Inject;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+import static org.junit.Assert.assertNotNull;
+
+public final class ExtensionWithStateTest {
+  static class A { }
+
+  static class B {
+    @Inject A a;
+  }
+
+  @Module(
+      entryPoints = A.class, // for testing
+      complete = false
+  )
+  static class RootModule {
+    final A a;
+    RootModule(A a) {
+      this.a = a;
+    }
+    @Provides A giveA() { return a; }
+  }
+
+  @Module(addsTo = RootModule.class, entryPoints = { B.class })
+  static class ExtensionModule { }
+
+  @Test public void basicExtension() {
+    A a = new A();
+    assertNotNull(ObjectGraph.create(new RootModule(a)).plus(new ExtensionModule()));
+  }
+
+  @Test public void basicInjection() {
+    A a = new A();
+    ObjectGraph root = ObjectGraph.create(new RootModule(a));
+    assertThat(root.get(A.class)).isSameAs(a);
+
+    // Extension graph behaves as the root graph would for root-ish things.
+    ObjectGraph extension = root.plus(new ExtensionModule());
+    assertThat(extension.get(A.class)).isSameAs(a);
+    assertThat(extension.get(B.class).a).isSameAs(a);
+  }
+
+}
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index bf57d63..910e0f3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -61,7 +61,7 @@
  * Generates an implementation of {@link ModuleAdapter} that includes a binding
  * for each {@code @Provides} method of a target class.
  */
-@SupportedAnnotationTypes("dagger.Provides")
+@SupportedAnnotationTypes({"dagger.Provides", "dagger.Module"})
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class ProvidesProcessor extends AbstractProcessor {
   private final LinkedHashMap<String, List<ExecutableElement>> remainingTypes =
@@ -94,7 +94,7 @@
       processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
           "Could not find types required by provides methods for " + remainingTypes.keySet());
     }
-    return true;
+    return false; // FullGraphProcessor needs an opportunity to process.
   }
 
   private void error(String msg, Element element) {
@@ -146,7 +146,7 @@
       methods.add(providerMethodAsExecutable);
     }
 
-    // catch any stray modules without @Provides since their entry points
+    // Catch any stray modules without @Provides since their entry points
     // should still be registered and a ModuleAdapter should still be written.
     for (Element type : env.getElementsAnnotatedWith(Module.class)) {
       if (type.getKind().equals(ElementKind.CLASS)) {
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionWithStateTest.java b/core/src/test/java/dagger/ExtensionWithStateTest.java
index a5ce26b..de5217b 100644
--- a/core/src/test/java/dagger/ExtensionWithStateTest.java
+++ b/core/src/test/java/dagger/ExtensionWithStateTest.java
@@ -1,6 +1,6 @@
 /*
- * Copyright (C) 2012 Google Inc.
- * Copyright (C) 2012 Square Inc.
+ * Copyright (C) 2013 Google Inc.
+ * Copyright (C) 2013 Square Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 910e0f3..ece3c52 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -61,7 +61,7 @@
  * Generates an implementation of {@link ModuleAdapter} that includes a binding
  * for each {@code @Provides} method of a target class.
  */
-@SupportedAnnotationTypes({"dagger.Provides", "dagger.Module"})
+@SupportedAnnotationTypes({ "dagger.Provides", "dagger.Module" })
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class ProvidesProcessor extends AbstractProcessor {
   private final LinkedHashMap<String, List<ExecutableElement>> remainingTypes =
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 6a016eb..fb6dc3b 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -307,6 +307,10 @@
       binding.getDependencies(get, injectMembers);
     }
 
+    @Override public boolean isLinked() {
+      return binding.isLinked();
+    }
+
     @Override public String toString() {
       return "@Singleton/" + binding.toString();
     }
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index abd6c6b..5d38d75 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -728,4 +728,23 @@
       assertThat(e.getMessage()).isEqualTo("foo");
     }
   }
+
+  static class SingletonLinkedFromExtension {
+    @Inject C c; //singleton
+  }
+
+  @Module(complete=false, entryPoints=C.class)
+  static class RootModule { }
+
+  @Module(addsTo=RootModule.class, entryPoints=SingletonLinkedFromExtension.class)
+  static class ExtensionModule { }
+
+  // Regression
+  @Test public void testSingletonLinkingThroughExtensionGraph() {
+    ObjectGraph root = ObjectGraph.create(new RootModule());
+    // DO NOT CALL root.get(C.class)) HERE to get forced-linking behaviour from plus();
+    ObjectGraph extension = root.plus(new ExtensionModule());
+    assertThat(extension.get(SingletonLinkedFromExtension.class).c).isSameAs(root.get(C.class));
+  }
+
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
index 2e13917..3c54320 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
@@ -92,14 +92,14 @@
       throw new IllegalArgumentException(e.getCause());
     } catch (NoSuchMethodException e) {
       throw new IllegalArgumentException("Could not construct " + moduleClass.getName()
-          + " as it lacks a no-args constructor.  If this was an upstream module of an extension"
-          + " graph then it should be noted by \"addsTo=\" and not \"includes=\".  Otherwise,"
-          + " this module must be passed in as an instance, or a no-args constructor must be"
-          + " added.", e);
+          + " as it lacks an accessible no-args constructor. This module must be passed"
+          + " in as an instance, or an accessible no-args constructor must be added.", e);
     } catch (InstantiationException e) {
       throw new IllegalArgumentException("Failed to construct " + moduleClass.getName(), e);
     } catch (IllegalAccessException e) {
-      throw new AssertionError();
+      throw new IllegalArgumentException("Could not construct " + moduleClass.getName()
+          + " as it lacks an accessible no-args constructor. This module must be passed"
+          + " in as an instance, or the no-args constructor must be made public.", e);
     }
   }
 
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionWithStateTest.java b/core/src/test/java/dagger/ExtensionWithStateTest.java
index de5217b..2c17f85 100644
--- a/core/src/test/java/dagger/ExtensionWithStateTest.java
+++ b/core/src/test/java/dagger/ExtensionWithStateTest.java
@@ -20,7 +20,6 @@
 import org.junit.Test;
 
 import static org.fest.assertions.Assertions.assertThat;
-import static org.junit.Assert.assertNotNull;
 
 public final class ExtensionWithStateTest {
   static class A { }
@@ -38,18 +37,13 @@
     RootModule(A a) {
       this.a = a;
     }
-    @Provides A giveA() { return a; }
+    @Provides A provideA() { return a; }
   }
 
   @Module(addsTo = RootModule.class, entryPoints = { B.class })
   static class ExtensionModule { }
 
-  @Test public void basicExtension() {
-    A a = new A();
-    assertNotNull(ObjectGraph.create(new RootModule(a)).plus(new ExtensionModule()));
-  }
-
-  @Test public void basicInjection() {
+  @Test public void basicInjectionWithExtension() {
     A a = new A();
     ObjectGraph root = ObjectGraph.create(new RootModule(a));
     assertThat(root.get(A.class)).isSameAs(a);
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index fb6dc3b..18115ca 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -112,8 +112,9 @@
             throw new IllegalStateException("Unable to create binding for " + key);
           }
           // Enqueue the JIT binding so its own dependencies can be linked.
-          toLink.add(jitBinding);
-          putBinding(jitBinding);
+          Binding<?> scopedJitBinding = scope(jitBinding);
+          toLink.add(scopedJitBinding);
+          putBinding(scopedJitBinding);
         } catch (Exception e) {
           if (e.getMessage() != null) {
             addError(e.getMessage() + " required by " + binding.requiredBy);
@@ -233,8 +234,7 @@
     return binding;
   }
 
-  private <T> void putBinding(Binding<T> binding) {
-    binding = scope(binding);
+  private <T> void putBinding(final Binding<T> binding) {
 
     // At binding insertion time it's possible that another binding for the same
     // key to already exist. This occurs when an @Provides method returns a type T
@@ -307,10 +307,34 @@
       binding.getDependencies(get, injectMembers);
     }
 
+    @Override public boolean isCycleFree() {
+      return binding.isCycleFree();
+    }
+
     @Override public boolean isLinked() {
       return binding.isLinked();
     }
 
+    @Override public boolean isVisiting() {
+      return binding.isVisiting();
+    }
+
+    @Override public void setCycleFree(final boolean cycleFree) {
+      binding.setCycleFree(cycleFree);
+    }
+
+    @Override public void setVisiting(final boolean visiting) {
+      binding.setVisiting(visiting);
+    }
+
+    @Override protected boolean isSingleton() {
+      return true;
+    }
+
+    @Override protected void setLinked() {
+      binding.setLinked();
+    }
+
     @Override public String toString() {
       return "@Singleton/" + binding.toString();
     }
/Fim/
diff --git a/core/src/test/java/dagger/internal/SingletonBindingTest.java b/core/src/test/java/dagger/internal/SingletonBindingTest.java
new file mode 100644
index 0000000..8c6154c
--- /dev/null
+++ b/core/src/test/java/dagger/internal/SingletonBindingTest.java
@@ -0,0 +1,76 @@
+/**
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import static org.fest.assertions.Assertions.assertThat;
+
+@RunWith(JUnit4.class)
+public final class SingletonBindingTest {
+  private Binding<String> wrappedBinding;
+  private Binding<String> singletonBinding;
+
+  @Before public void setUp() {
+    wrappedBinding = new StringBinding();
+    singletonBinding = Linker.scope(wrappedBinding);
+  }
+
+  @Test public void testSingletonBindingIsSingleton() {
+    assertThat(singletonBinding.isSingleton()).isTrue();
+  }
+
+  // This next batch of tests validates that SingletonBinding consistently delegates to the wrapped binding for state.
+  @Test public void testSingletonBindingDelegatesSetLinked() {
+    singletonBinding.setLinked();
+    assertThat(wrappedBinding.isLinked()).isTrue();
+  }
+
+  @Test public void testSingletonBindingDelegatesIsLinked() {
+    wrappedBinding.setLinked();
+    assertThat(singletonBinding.isLinked()).isTrue();
+  }
+
+  @Test public void testSingletonBindingDelegatesSetVisiting() {
+    singletonBinding.setVisiting(true);
+    assertThat(wrappedBinding.isVisiting()).isTrue();
+  }
+
+  @Test public void testSingletonBindingDelegatesIsVisiting() {
+    wrappedBinding.setVisiting(true);
+    assertThat(singletonBinding.isVisiting()).isTrue();
+  }
+
+  @Test public void testSingletonBindingDelegatesSetCycleFree() {
+    singletonBinding.setCycleFree(true);
+    assertThat(wrappedBinding.isCycleFree()).isTrue();
+  }
+
+  @Test public void testSingletonBindingDelegatesIsCycleFree() {
+    wrappedBinding.setCycleFree(true);
+    assertThat(singletonBinding.isCycleFree()).isTrue();
+  }
+
+  private static class StringBinding extends Binding<String> {
+    private StringBinding() {
+      super("dummy", "dummy", true, "dummy"); // 3rd arg true => singleton
+    }
+
+  }
+}
/Fim/
diff --git a/androidmanifest/pom.xml b/androidmanifest/pom.xml
index c3d3ef7..8287abe 100644
--- a/androidmanifest/pom.xml
+++ b/androidmanifest/pom.xml
@@ -18,7 +18,7 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup</groupId>
+    <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
     <version>1.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index bbd57a4..ec7434c 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -19,7 +19,7 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup</groupId>
+    <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
     <version>1.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
@@ -77,6 +77,7 @@
           <postBuildHookScript>verify</postBuildHookScript>
           <filterProperties>
             <dagger.version>${project.version}</dagger.version>
+            <dagger.groupId>${project.groupId}</dagger.groupId>
           </filterProperties>
         </configuration>
         <executions>
/Fim/
diff --git a/compiler/src/it/cyclic-deps/pom.xml b/compiler/src/it/cyclic-deps/pom.xml
index c0d5ee7..d213a7a 100644
--- a/compiler/src/it/cyclic-deps/pom.xml
+++ b/compiler/src/it/cyclic-deps/pom.xml
@@ -20,20 +20,20 @@
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
-  <version>@dagger.version@</version>
-  <packaging>jar</packaging>
-  <name>Dagger Integration Test Basic</name>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>cyclic-deps</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <name>Cyclic Dependencies</name>
   <dependencies>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
       <optional>true</optional>
     </dependency>
   </dependencies>
@@ -45,5 +45,4 @@
       </plugin>
     </plugins>
   </build>
-  <artifactId>cyclic-deps</artifactId>
 </project>
/Fim/
diff --git a/compiler/src/it/default-package-injected-type/pom.xml b/compiler/src/it/default-package-injected-type/pom.xml
index a0f1ea2..ee7e557 100644
--- a/compiler/src/it/default-package-injected-type/pom.xml
+++ b/compiler/src/it/default-package-injected-type/pom.xml
@@ -20,19 +20,20 @@
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
+  <groupId>com.example.dagger.tests</groupId>
   <artifactId>default-package-injected-type</artifactId>
-  <version>@dagger.version@</version>
+  <version>HEAD-SNAPSHOT</version>
+  <name>Default Package Injected Type</name>
   <dependencies>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
       <optional>true</optional>
     </dependency>
   </dependencies>
/Fim/
diff --git a/compiler/src/it/extension-graph/pom.xml b/compiler/src/it/extension-graph/pom.xml
index ddd9b44..76bde1e 100644
--- a/compiler/src/it/extension-graph/pom.xml
+++ b/compiler/src/it/extension-graph/pom.xml
@@ -20,21 +20,20 @@
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
+  <groupId>com.example.dagger.tests</groupId>
   <artifactId>extension-graph</artifactId>
-  <version>@dagger.version@</version>
-  <packaging>jar</packaging>
+  <version>HEAD-SNAPSHOT</version>
   <name>Dagger Integration Test Basic</name>
   <dependencies>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
       <optional>true</optional>
     </dependency>
   </dependencies>
/Fim/
diff --git a/compiler/src/it/include-non-module/pom.xml b/compiler/src/it/include-non-module/pom.xml
index 4a0d2a9..7d2993d 100644
--- a/compiler/src/it/include-non-module/pom.xml
+++ b/compiler/src/it/include-non-module/pom.xml
@@ -20,21 +20,20 @@
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
+  <groupId>com.example.dagger.tests</groupId>
   <artifactId>include-non-module</artifactId>
-  <version>@dagger.version@</version>
-  <packaging>jar</packaging>
+  <version>HEAD-SNAPSHOT</version>
   <name>Dagger Integration Test Basic</name>
   <dependencies>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
       <optional>true</optional>
     </dependency>
   </dependencies>
/Fim/
diff --git a/compiler/src/it/inject-parameterized-type/pom.xml b/compiler/src/it/inject-parameterized-type/pom.xml
index 45b685c..7b6bc48 100644
--- a/compiler/src/it/inject-parameterized-type/pom.xml
+++ b/compiler/src/it/inject-parameterized-type/pom.xml
@@ -20,21 +20,20 @@
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
+  <groupId>com.example.dagger.tests</groupId>
   <artifactId>inject-parameterized-type</artifactId>
-  <version>@dagger.version@</version>
-  <packaging>jar</packaging>
+  <version>HEAD-SNAPSHOT</version>
   <name>Dagger Integration Test Basic</name>
   <dependencies>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
       <optional>true</optional>
     </dependency>
   </dependencies>
/Fim/
diff --git a/compiler/src/it/inner-classes-complaint-injection/pom.xml b/compiler/src/it/inner-classes-complaint-injection/pom.xml
index 534def8..ff2dd01 100644
--- a/compiler/src/it/inner-classes-complaint-injection/pom.xml
+++ b/compiler/src/it/inner-classes-complaint-injection/pom.xml
@@ -19,21 +19,20 @@
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
+  <groupId>com.example.dagger.tests</groupId>
   <artifactId>inner-classes-complaint-injection</artifactId>
-  <version>@dagger.version@</version>
-  <packaging>jar</packaging>
+  <version>HEAD-SNAPSHOT</version>
   <name>Dagger Integration Test Basic</name>
   <dependencies>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
       <optional>true</optional>
     </dependency>
   </dependencies>
/Fim/
diff --git a/compiler/src/it/missing-at-inject-constructor/pom.xml b/compiler/src/it/missing-at-inject-constructor/pom.xml
index 6e15355..4d9e947 100644
--- a/compiler/src/it/missing-at-inject-constructor/pom.xml
+++ b/compiler/src/it/missing-at-inject-constructor/pom.xml
@@ -20,21 +20,20 @@
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
-  <version>@dagger.version@</version>
-  <packaging>jar</packaging>
+  <groupId>com.example.dagger.tests</groupId>
   <artifactId>missing-at-inject-constructor</artifactId>
+  <version>HEAD-SNAPSHOT</version>
   <name>Dagger Integration Test Basic</name>
   <dependencies>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
       <optional>true</optional>
     </dependency>
   </dependencies>
/Fim/
diff --git a/compiler/src/it/multiple-provides-methods/pom.xml b/compiler/src/it/multiple-provides-methods/pom.xml
index a796c6e..45fcba0 100644
--- a/compiler/src/it/multiple-provides-methods/pom.xml
+++ b/compiler/src/it/multiple-provides-methods/pom.xml
@@ -20,21 +20,20 @@
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
+  <groupId>com.example.dagger.tests</groupId>
   <artifactId>multiple-provides-methods</artifactId>
-  <version>@dagger.version@</version>
-  <packaging>jar</packaging>
+  <version>HEAD-SNAPSHOT</version>
   <name>Dagger Integration Test Basic</name>
   <dependencies>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
       <optional>true</optional>
     </dependency>
   </dependencies>
/Fim/
diff --git a/compiler/src/it/provides-method-with-throws-clause/pom.xml b/compiler/src/it/provides-method-with-throws-clause/pom.xml
index f175615..7063ecc 100644
--- a/compiler/src/it/provides-method-with-throws-clause/pom.xml
+++ b/compiler/src/it/provides-method-with-throws-clause/pom.xml
@@ -20,21 +20,20 @@
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
+  <groupId>com.example.dagger.tests</groupId>
   <artifactId>provides-method-with-throws-clause</artifactId>
-  <version>@dagger.version@</version>
-  <packaging>jar</packaging>
+  <version>HEAD-SNAPSHOT</version>
   <name>Dagger Integration Test Basic</name>
   <dependencies>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
       <optional>true</optional>
     </dependency>
   </dependencies>
/Fim/
diff --git a/compiler/src/it/same-provides-method-name/pom.xml b/compiler/src/it/same-provides-method-name/pom.xml
index 7a21a8b..2c41239 100644
--- a/compiler/src/it/same-provides-method-name/pom.xml
+++ b/compiler/src/it/same-provides-method-name/pom.xml
@@ -20,21 +20,20 @@
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
+  <groupId>com.example.dagger.tests</groupId>
   <artifactId>same-provides-method-name</artifactId>
-  <version>@dagger.version@</version>
-  <packaging>jar</packaging>
+  <version>HEAD-SNAPSHOT</version>
   <name>Dagger Integration Test Basic</name>
   <dependencies>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
       <optional>true</optional>
     </dependency>
   </dependencies>
/Fim/
diff --git a/compiler/src/it/simple-missing-dependency-failure/pom.xml b/compiler/src/it/simple-missing-dependency-failure/pom.xml
index 92d27e8..1ec794d 100644
--- a/compiler/src/it/simple-missing-dependency-failure/pom.xml
+++ b/compiler/src/it/simple-missing-dependency-failure/pom.xml
@@ -20,19 +20,19 @@
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
+  <groupId>@dagger.groupId@.tests</groupId>
   <artifactId>missing-dependency</artifactId>
   <version>@dagger.version@</version>
   <packaging>jar</packaging>
   <name>Dagger Integration Test Basic</name>
   <dependencies>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger-compiler</artifactId>
       <version>${project.version}</version>
       <optional>true</optional>
/Fim/
diff --git a/compiler/src/it/uninjectable-supertype/pom.xml b/compiler/src/it/uninjectable-supertype/pom.xml
index a1440c6..451108d 100644
--- a/compiler/src/it/uninjectable-supertype/pom.xml
+++ b/compiler/src/it/uninjectable-supertype/pom.xml
@@ -20,21 +20,20 @@
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
+  <groupId>com.example.dagger.tests</groupId>
   <artifactId>uninjectable-supertype</artifactId>
-  <version>@dagger.version@</version>
-  <packaging>jar</packaging>
+  <version>HEAD-SNAPSHOT</version>
   <name>Dagger Integration Test Basic</name>
   <dependencies>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
+      <version>@dagger.version@</version>
       <optional>true</optional>
     </dependency>
   </dependencies>
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 209c49a..63515f8 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -18,14 +18,13 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup</groupId>
+    <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
     <version>1.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
   <artifactId>dagger</artifactId>
-  <packaging>jar</packaging>
   <name>Dagger</name>
 
   <dependencies>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index 293b6b9..fe0346f 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -19,7 +19,7 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup</groupId>
+    <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
     <version>1.0-SNAPSHOT</version>
   </parent>
@@ -32,5 +32,4 @@
   <modules>
     <module>simple</module>
   </modules>
-
 </project>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index bc17f01..0a25a1a 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -24,17 +24,16 @@
   </parent>
 
   <artifactId>simple-dagger-example</artifactId>
-  <packaging>jar</packaging>
   <name>Dagger Example - Simple</name>
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>com.squareup.dagger</groupId>
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>com.squareup.dagger</groupId>
       <artifactId>dagger-compiler</artifactId>
       <version>${project.version}</version>
       <optional>true</optional>
/Fim/
diff --git a/pom.xml b/pom.xml
index 260a858..cdee511 100644
--- a/pom.xml
+++ b/pom.xml
@@ -23,7 +23,7 @@
     <version>7</version>
   </parent>
 
-  <groupId>com.squareup</groupId>
+  <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
   <version>1.0-SNAPSHOT</version>
/Fim/
diff --git a/compiler/src/it/cyclic-module-includes/invoker.properties b/compiler/src/it/cyclic-module-includes/invoker.properties
new file mode 100644
index 0000000..324b5fb
--- /dev/null
+++ b/compiler/src/it/cyclic-module-includes/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
\ No newline at end of file
/Fim/
diff --git a/compiler/src/it/cyclic-module-includes/pom.xml b/compiler/src/it/cyclic-module-includes/pom.xml
new file mode 100644
index 0000000..21e1490
--- /dev/null
+++ b/compiler/src/it/cyclic-module-includes/pom.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2013 Square, Inc.
+ Copyright (C) 2013 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>cyclic-module-includes</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <name>Cyclic Dependencies</name>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/cyclic-module-includes/src/main/java/test/TestApp.java b/compiler/src/it/cyclic-module-includes/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..559a04d
--- /dev/null
+++ b/compiler/src/it/cyclic-module-includes/src/main/java/test/TestApp.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+
+class TestApp {
+  
+  @Module(includes = SelfReferencingModule.class)
+  static class SelfReferencingModule { }
+
+  @Module(includes = C.class)
+  static class A {}
+
+  @Module(includes = A.class)
+  static class B {}
+
+  @Module(includes = B.class)
+  static class C {}
+
+}
/Fim/
diff --git a/compiler/src/it/cyclic-module-includes/verify.bsh b/compiler/src/it/cyclic-module-includes/verify.bsh
new file mode 100644
index 0000000..1540ba3
--- /dev/null
+++ b/compiler/src/it/cyclic-module-includes/verify.bsh
@@ -0,0 +1,9 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Graph validation failed", "test.TestApp.SelfReferencingModule includes itself directly"});
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Graph validation failed", "test.TestApp.A includes itself by way of:", "====>test.TestApp.A"});
+    
\ No newline at end of file
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 88dceac..117efbb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -26,8 +26,11 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.Deque;
+import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -87,9 +90,13 @@
         continue;
       }
       TypeElement moduleType = (TypeElement) element;
-      Map<String, Binding<?>> bindings = processCompleteModule(moduleType);
+      Map<String, Binding<?>> bindings = null;
       try {
+        bindings = processCompleteModule(moduleType);
         new ProblemDetector().detectProblems(bindings.values());
+      } catch (GraphValidationException e) {
+        error("Graph validation failed: " + e.getMessage(), e.getSource());
+        continue;
       } catch (IllegalStateException e) {
         error("Graph validation failed: " + e.getMessage(), moduleType);
         continue;
@@ -109,7 +116,7 @@
 
   private Map<String, Binding<?>> processCompleteModule(TypeElement rootModule) {
     Map<String, TypeElement> allModules = new LinkedHashMap<String, TypeElement>();
-    collectIncludesRecursively(rootModule, allModules);
+    collectIncludesRecursively(rootModule, allModules, new LinkedList<String>());
 
     Linker linker = new Linker(null, new CompileTimePlugin(processingEnv),
         new ReportingErrorHandler(processingEnv, rootModule.getQualifiedName().toString()));
@@ -179,16 +186,37 @@
         + "." + method.getSimpleName() + "()";
   }
 
-  private void collectIncludesRecursively(TypeElement module, Map<String, TypeElement> result) {
+  void collectIncludesRecursively(
+      TypeElement module, Map<String, TypeElement> result, Deque<String> path) {
     Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
     if (annotation == null) {
       // TODO(tbroyer): pass annotation information
-      error("No @Module on " + module, module);
-      return;
+      throw new GraphValidationException("No @Module on " + module, module);
     }
 
     // Add the module.
-    result.put(module.getQualifiedName().toString(), module);
+    String name = module.getQualifiedName().toString();
+    if (path.contains(name)) {
+      StringBuilder message = new StringBuilder("Cycle: ")
+          .append(name)
+          .append(" includes itself");
+
+      if (path.size() == 1) {
+        message.append(" directly.");
+      } else {
+        message.append(" by way of:");
+        Iterator<String> pathIterator = path.descendingIterator();
+        while (pathIterator.hasNext()) {
+          String pathElement = pathIterator.next();
+          message.append("\n->").append(pathElement).append(" includes");
+        }
+        message.append("\n====>").append(name);
+      }
+      throw new GraphValidationException(message.toString(), module);
+    } else {
+      path.push(name);
+    }
+    result.put(name, module);
 
     // Recurse for each included module.
     Types typeUtils = processingEnv.getTypeUtils();
@@ -203,7 +231,7 @@
         continue;
       }
       TypeElement includedModule = (TypeElement) typeUtils.asElement((TypeMirror) include);
-      collectIncludesRecursively(includedModule, result);
+      collectIncludesRecursively(includedModule, result, path);
     }
   }
 
@@ -249,4 +277,19 @@
     new GraphVisualizer().write(bindings, dotWriter);
     dotWriter.close();
   }
+
+  static class GraphValidationException extends IllegalStateException {
+
+    private final TypeElement source;
+
+    public GraphValidationException(String message, TypeElement source) {
+      super(message);
+      this.source = source;
+    }
+
+    public TypeElement getSource() {
+      return source;
+    }
+
+  }
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 117efbb..2abd937 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -95,7 +95,7 @@
         bindings = processCompleteModule(moduleType);
         new ProblemDetector().detectProblems(bindings.values());
       } catch (GraphValidationException e) {
-        error("Graph validation failed: " + e.getMessage(), e.getSource());
+        error("Graph validation failed: " + e.getMessage(), e.source);
         continue;
       } catch (IllegalStateException e) {
         error("Graph validation failed: " + e.getMessage(), moduleType);
@@ -279,17 +279,11 @@
   }
 
   static class GraphValidationException extends IllegalStateException {
-
-    private final TypeElement source;
+    final TypeElement source;
 
     public GraphValidationException(String message, TypeElement source) {
       super(message);
       this.source = source;
     }
-
-    public TypeElement getSource() {
-      return source;
-    }
-
   }
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 2abd937..285d317 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -94,7 +94,7 @@
       try {
         bindings = processCompleteModule(moduleType);
         new ProblemDetector().detectProblems(bindings.values());
-      } catch (GraphValidationException e) {
+      } catch (ModuleValidationException e) {
         error("Graph validation failed: " + e.getMessage(), e.source);
         continue;
       } catch (IllegalStateException e) {
@@ -191,7 +191,7 @@
     Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
     if (annotation == null) {
       // TODO(tbroyer): pass annotation information
-      throw new GraphValidationException("No @Module on " + module, module);
+      throw new ModuleValidationException("No @Module on " + module, module);
     }
 
     // Add the module.
@@ -212,7 +212,7 @@
         }
         message.append("\n====>").append(name);
       }
-      throw new GraphValidationException(message.toString(), module);
+      throw new ModuleValidationException(message.toString(), module);
     } else {
       path.push(name);
     }
@@ -278,10 +278,10 @@
     dotWriter.close();
   }
 
-  static class GraphValidationException extends IllegalStateException {
+  static class ModuleValidationException extends IllegalStateException {
     final TypeElement source;
 
-    public GraphValidationException(String message, TypeElement source) {
+    public ModuleValidationException(String message, TypeElement source) {
       super(message);
       this.source = source;
     }
/Fim/
diff --git a/checkstyle.xml b/checkstyle.xml
index 4f5575c..40c2b1c 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -100,7 +100,6 @@
         <!-- See http://checkstyle.sf.net/config_coding.html -->
         <!--module name="AvoidInlineConditionals"/-->
         <module name="CovariantEquals"/>
-        <module name="DoubleCheckedLocking"/>
         <module name="EmptyStatement"/>
         <!--<module name="EqualsAvoidNull"/>-->
         <module name="EqualsHashCode"/>
/Fim/
diff --git a/core/src/main/java/dagger/internal/LazyBinding.java b/core/src/main/java/dagger/internal/LazyBinding.java
index a3bacc3..0c7603d 100644
--- a/core/src/main/java/dagger/internal/LazyBinding.java
+++ b/core/src/main/java/dagger/internal/LazyBinding.java
@@ -40,18 +40,26 @@
   }
 
   @Override public void injectMembers(Lazy<T> t) {
-    throw new UnsupportedOperationException(); // not a member injection binding.
+    throw new UnsupportedOperationException(); // Injecting into a custom Lazy not supported.
   }
 
   @Override
   public Lazy<T> get() {
     return new Lazy<T>() {
-      private Object cacheValue = NOT_PRESENT;
+      private final Object lock = new Object();
+      private volatile Object cacheValue = NOT_PRESENT;
 
       @SuppressWarnings("unchecked") // Delegate is of type T
       @Override
       public T get() {
-        return (T) ((cacheValue != NOT_PRESENT) ? cacheValue : (cacheValue = delegate.get()));
+        if (cacheValue == NOT_PRESENT) {
+          synchronized (lock) {
+            if (cacheValue == NOT_PRESENT) {
+              cacheValue = delegate.get();
+            }
+          }
+        }
+        return (T) cacheValue;
       }
     };
   }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 18115ca..651a06f 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -278,8 +278,9 @@
    * A Binding that implements singleton behaviour around an existing binding.
    */
   private static class SingletonBinding<T> extends Binding<T> {
+    private final Object lock = new Object(); // 1 object vs. ReentrantLock's cloud of pointers.
     private final Binding<T> binding;
-    private Object onlyInstance = UNINITIALIZED;
+    private volatile Object onlyInstance = UNINITIALIZED;
 
     private SingletonBinding(Binding<T> binding) {
       super(binding.provideKey, binding.membersKey, true, binding.requiredBy);
@@ -296,9 +297,12 @@
 
     @SuppressWarnings("unchecked") // onlyInstance is either 'UNINITIALIZED' or a 'T'.
     @Override public T get() {
-      // TODO (cgruber): Fix concurrency risk.
       if (onlyInstance == UNINITIALIZED) {
-        onlyInstance = binding.get();
+        synchronized (lock) {
+          if (onlyInstance == UNINITIALIZED) {
+            onlyInstance = binding.get();
+          }
+        }
       }
       return (T) onlyInstance;
     }
/Fim/
diff --git a/core/src/test/java/dagger/ThreadSafetyTest.java b/core/src/test/java/dagger/ThreadSafetyTest.java
new file mode 100644
index 0000000..3b26f79
--- /dev/null
+++ b/core/src/test/java/dagger/ThreadSafetyTest.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2013 Google Inc.
+ * Copyright (C) 2013 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+/**
+ * Test Singleton and Lazy bindings for thread-safety.
+ */
+@RunWith(JUnit4.class)
+public final class ThreadSafetyTest {
+  private static final Integer FIRST_VALUE = 0;
+  private static final int PERCALE = 100;
+
+  private final ExecutorService es = Executors.newFixedThreadPool(PERCALE);
+  private final CountDownLatch latch = new CountDownLatch(PERCALE + 1);
+
+
+  static class LazyEntryPoint {
+    @Inject Lazy<Integer> lazy;
+  }
+
+  @Module(entryPoints = { Long.class, LazyEntryPoint.class })
+  static class LatchingModule {
+    private final AtomicInteger count = new AtomicInteger(FIRST_VALUE);
+    private final CountDownLatch latch;
+    LatchingModule(CountDownLatch latch) {
+      this.latch = latch;
+    }
+
+    @Provides @Singleton Long provideLong() {
+      return Long.valueOf(provideInteger());
+    }
+
+    @Provides Integer provideInteger() {
+      try {
+        latch.await();
+      } catch (InterruptedException e) {
+        throw new AssertionError("Interrupted Thread!!");
+      }
+      return count.getAndIncrement();
+    }
+  }
+
+  @Test public void concurrentSingletonAccess() throws Exception {
+    final List<Future<Long>> futures = new ArrayList<Future<Long>>();
+    final ObjectGraph graph = ObjectGraph.create(new LatchingModule(latch));
+    for (int i = 0 ; i < PERCALE ; i++) {
+      futures.add(es.submit(new Callable<Long>() {
+        @Override public Long call() {
+          latch.countDown();
+          return graph.get(Long.class);
+        }
+      }));
+    }
+    latch.countDown();
+    for (Future<Long> future : futures) {
+      assertThat(future.get(1, TimeUnit.SECONDS))
+          .overridingErrorMessage("Lock failure - count should never increment")
+          .isEqualTo(0);
+    }
+  }
+
+  @Test public void concurrentLazyAccess() throws Exception {
+    final List<Future<Integer>> futures = new ArrayList<Future<Integer>>();
+    final ObjectGraph graph = ObjectGraph.create(new LatchingModule(latch));
+    final LazyEntryPoint lep = graph.get(LazyEntryPoint.class);
+    for (int i = 0 ; i < PERCALE ; i++) {
+      futures.add(es.submit(new Callable<Integer>() {
+        @Override public Integer call() {
+          latch.countDown();
+          return lep.lazy.get();
+        }
+      }));
+    }
+    latch.countDown();
+    for (Future<Integer> future : futures) {
+      assertThat(future.get(1, TimeUnit.SECONDS))
+          .overridingErrorMessage("Lock failure - count should never increment")
+          .isEqualTo(0);
+    }
+  }
+}
/Fim/
diff --git a/pom.xml b/pom.xml
index cdee511..ef91b87 100644
--- a/pom.xml
+++ b/pom.xml
@@ -144,7 +144,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.9.1</version>
+        <version>2.10</version>
         <configuration>
           <failsOnError>true</failsOnError>
           <consoleOutput>true</consoleOutput>
/Fim/
diff --git a/core/src/test/java/dagger/ThreadSafetyTest.java b/core/src/test/java/dagger/ThreadSafetyTest.java
index 3b26f79..c30a580 100644
--- a/core/src/test/java/dagger/ThreadSafetyTest.java
+++ b/core/src/test/java/dagger/ThreadSafetyTest.java
@@ -39,10 +39,10 @@
 @RunWith(JUnit4.class)
 public final class ThreadSafetyTest {
   private static final Integer FIRST_VALUE = 0;
-  private static final int PERCALE = 100;
+  private static final int THREAD_COUNT = 100;
 
-  private final ExecutorService es = Executors.newFixedThreadPool(PERCALE);
-  private final CountDownLatch latch = new CountDownLatch(PERCALE + 1);
+  private final ExecutorService es = Executors.newFixedThreadPool(THREAD_COUNT);
+  private final CountDownLatch latch = new CountDownLatch(THREAD_COUNT + 1);
 
 
   static class LazyEntryPoint {
@@ -74,7 +74,7 @@
   @Test public void concurrentSingletonAccess() throws Exception {
     final List<Future<Long>> futures = new ArrayList<Future<Long>>();
     final ObjectGraph graph = ObjectGraph.create(new LatchingModule(latch));
-    for (int i = 0 ; i < PERCALE ; i++) {
+    for (int i = 0; i < THREAD_COUNT; i++) {
       futures.add(es.submit(new Callable<Long>() {
         @Override public Long call() {
           latch.countDown();
@@ -94,7 +94,7 @@
     final List<Future<Integer>> futures = new ArrayList<Future<Integer>>();
     final ObjectGraph graph = ObjectGraph.create(new LatchingModule(latch));
     final LazyEntryPoint lep = graph.get(LazyEntryPoint.class);
-    for (int i = 0 ; i < PERCALE ; i++) {
+    for (int i = 0; i < THREAD_COUNT; i++) {
       futures.add(es.submit(new Callable<Integer>() {
         @Override public Integer call() {
           latch.countDown();
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
diff --git a/pom.xml b/pom.xml
index ef91b87..67689a0 100644
--- a/pom.xml
+++ b/pom.xml
@@ -32,7 +32,6 @@
   <url>https://github.com/square/dagger</url>
 
   <modules>
-    <module>androidmanifest</module>
     <module>compiler</module>
     <module>core</module>
     <module>examples</module>
@@ -44,8 +43,6 @@
     <!-- Compilation -->
     <java.version>1.6</java.version>
     <javax.inject.version>1</javax.inject.version>
-    <maven.version>2.0.6</maven.version>
-    <ant.version>1.8.2</ant.version>
     <javawriter.version>1.0.2</javawriter.version>
 
     <!-- Test Dependencies -->
@@ -85,21 +82,6 @@
         <version>${javax.inject.version}</version>
       </dependency>
       <dependency>
-        <groupId>org.apache.maven</groupId>
-        <artifactId>maven-plugin-api</artifactId>
-        <version>${maven.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.apache.maven</groupId>
-        <artifactId>maven-core</artifactId>
-        <version>${maven.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.apache.ant</groupId>
-        <artifactId>ant</artifactId>
-        <version>${ant.version}</version>
-      </dependency>
-      <dependency>
         <groupId>com.squareup</groupId>
         <artifactId>javawriter</artifactId>
         <version>${javawriter.version}</version>
@@ -165,12 +147,6 @@
       <plugins>
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-plugin-plugin</artifactId>
-          <version>2.8</version>
-        </plugin>
-
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-invoker-plugin</artifactId>
           <version>1.7</version>
         </plugin>
/Fim/
diff --git a/compiler/src/it/inject-on-class/invoker.properties b/compiler/src/it/inject-on-class/invoker.properties
new file mode 100644
index 0000000..324b5fb
--- /dev/null
+++ b/compiler/src/it/inject-on-class/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
\ No newline at end of file
/Fim/
diff --git a/compiler/src/it/inject-on-class/pom.xml b/compiler/src/it/inject-on-class/pom.xml
new file mode 100644
index 0000000..e0f80c4
--- /dev/null
+++ b/compiler/src/it/inject-on-class/pom.xml
@@ -0,0 +1,50 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>method-injection</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/inject-on-class/src/main/java/test/TestApp.java b/compiler/src/it/inject-on-class/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..75df331
--- /dev/null
+++ b/compiler/src/it/inject-on-class/src/main/java/test/TestApp.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+@Inject
+class TestApp {
+}
/Fim/
diff --git a/compiler/src/it/inject-on-class/verify.bsh b/compiler/src/it/inject-on-class/verify.bsh
new file mode 100644
index 0000000..03031dd
--- /dev/null
+++ b/compiler/src/it/inject-on-class/verify.bsh
@@ -0,0 +1,6 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "@Inject is not valid on a class: test.TestApp"});
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index c8bebb5..66af1f9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -127,6 +127,11 @@
   private boolean validateInjectable(Element injectable) {
     Element injectableType = injectable.getEnclosingElement();
 
+    if (injectable.getKind() == ElementKind.CLASS) {
+      error("@Inject is not valid on a class: " + injectable, injectable);
+      return false;
+    }
+
     if (injectable.getKind() == ElementKind.METHOD) {
       error("Method injection is not supported: " + injectableType + "." + injectable, injectable);
       return false;
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index b80751c..4fd4152 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -118,13 +118,16 @@
 
     Map<String, List<ExecutableElement>> result = new HashMap<String, List<ExecutableElement>>();
     for (Element providerMethod : providesMethods(env)) {
+      switch (providerMethod.getEnclosingElement().getKind()) {
+        case CLASS:
+            break; // valid, move along
+        default:
+            // TODO(tbroyer): pass annotation information
+            error("Unexpected @Provides on " + providerMethod, providerMethod);
+            continue;
+      }
       TypeElement type = (TypeElement) providerMethod.getEnclosingElement();
       Set<Modifier> typeModifiers = type.getModifiers();
-      if (type.getKind() != ElementKind.CLASS) {
-        // TODO(tbroyer): pass annotation information
-        error("Unexpected @Provides on " + providerMethod, providerMethod);
-        continue;
-      }
       if (typeModifiers.contains(Modifier.PRIVATE)
           || typeModifiers.contains(Modifier.ABSTRACT)) {
         error("Classes declaring @Provides methods must not be private or abstract: "
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index b80751c..7ee63c1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -118,13 +118,16 @@
 
     Map<String, List<ExecutableElement>> result = new HashMap<String, List<ExecutableElement>>();
     for (Element providerMethod : providesMethods(env)) {
+      switch (providerMethod.getEnclosingElement().getKind()) {
+        case CLASS:
+          break; // valid, move along
+        default:
+          // TODO(tbroyer): pass annotation information
+          error("Unexpected @Provides on " + providerMethod, providerMethod);
+          continue;
+      }
       TypeElement type = (TypeElement) providerMethod.getEnclosingElement();
       Set<Modifier> typeModifiers = type.getModifiers();
-      if (type.getKind() != ElementKind.CLASS) {
-        // TODO(tbroyer): pass annotation information
-        error("Unexpected @Provides on " + providerMethod, providerMethod);
-        continue;
-      }
       if (typeModifiers.contains(Modifier.PRIVATE)
           || typeModifiers.contains(Modifier.ABSTRACT)) {
         error("Classes declaring @Provides methods must not be private or abstract: "
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java b/compiler/src/main/java/dagger/internal/codegen/CompileTimeLoader.java
similarity index 93%
rename from compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java
rename to compiler/src/main/java/dagger/internal/codegen/CompileTimeLoader.java
index 30d364e..81ceb27 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CompileTimeLoader.java
@@ -16,8 +16,8 @@
 package dagger.internal.codegen;
 
 import dagger.internal.Binding;
+import dagger.internal.Loader;
 import dagger.internal.ModuleAdapter;
-import dagger.internal.Plugin;
 import dagger.internal.StaticInjection;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.ElementKind;
@@ -29,11 +29,11 @@
  * {@link Binding#get} or {@link Binding#injectMembers} methods. They are only suitable
  * for graph analysis and error detection.
  */
-public final class CompileTimePlugin implements Plugin {
+public final class CompileTimeLoader implements Loader {
 
   private final ProcessingEnvironment processingEnv;
 
-  public CompileTimePlugin(ProcessingEnvironment processingEnv) {
+  public CompileTimeLoader(ProcessingEnvironment processingEnv) {
     this.processingEnv = processingEnv;
   }
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 7ca3756..181ed9b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -136,7 +136,7 @@
 
     Linker.ErrorHandler errorHandler = ignoreCompletenessErrors ? Linker.ErrorHandler.NULL
         : new ReportingErrorHandler(processingEnv, rootModule.getQualifiedName().toString());
-    Linker linker = new Linker(null, new CompileTimePlugin(processingEnv), errorHandler);
+    Linker linker = new Linker(null, new CompileTimeLoader(processingEnv), errorHandler);
     // Linker requires synchronization for calls to requestBinding and linkAll.
     // We know statically that we're single threaded, but we synchronize anyway
     // to make the linker happy.
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 66af1f9..c7be46d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -46,8 +46,8 @@
 import javax.tools.JavaFileObject;
 
 import static dagger.internal.codegen.ProcessorJavadocs.binderTypeDocs;
-import static dagger.internal.plugins.loading.ClassloadingPlugin.INJECT_ADAPTER_SUFFIX;
-import static dagger.internal.plugins.loading.ClassloadingPlugin.STATIC_INJECTION_SUFFIX;
+import static dagger.internal.loaders.generated.GeneratedAdapterLoader.INJECT_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.generated.GeneratedAdapterLoader.STATIC_INJECTION_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
 import static java.lang.reflect.Modifier.PRIVATE;
 import static java.lang.reflect.Modifier.PUBLIC;
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 7ee63c1..e1d2662 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -51,7 +51,7 @@
 import javax.tools.JavaFileObject;
 
 import static dagger.internal.codegen.ProcessorJavadocs.binderTypeDocs;
-import static dagger.internal.plugins.loading.ClassloadingPlugin.MODULE_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.generated.GeneratedAdapterLoader.MODULE_ADAPTER_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
 import static java.lang.reflect.Modifier.PRIVATE;
 import static java.lang.reflect.Modifier.PROTECTED;
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index db91c37..79fc36d 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -19,19 +19,19 @@
 import dagger.internal.Binding;
 import dagger.internal.Keys;
 import dagger.internal.Linker;
+import dagger.internal.Loader;
 import dagger.internal.ModuleAdapter;
-import dagger.internal.Plugin;
 import dagger.internal.ProblemDetector;
-import dagger.internal.RuntimeAggregatingPlugin;
+import dagger.internal.RuntimeAggregatingLoader;
 import dagger.internal.StaticInjection;
 import dagger.internal.ThrowingErrorHandler;
 import dagger.internal.UniqueMap;
-import dagger.internal.plugins.loading.ClassloadingPlugin;
-import dagger.internal.plugins.reflect.ReflectivePlugin;
+import dagger.internal.loaders.generated.GeneratedAdapterLoader;
+import dagger.internal.loaders.reflect.ReflectiveLoader;
 import java.util.LinkedHashMap;
 import java.util.Map;
 
-import static dagger.internal.RuntimeAggregatingPlugin.getAllModuleAdapters;
+import static dagger.internal.RuntimeAggregatingLoader.getAllModuleAdapters;
 
 /**
  * A graph of objects linked by their dependencies.
@@ -124,8 +124,8 @@
    * the graph at runtime.
    */
   public static ObjectGraph create(Object... modules) {
-    RuntimeAggregatingPlugin plugin = new RuntimeAggregatingPlugin(
-            new ClassloadingPlugin(), new ReflectivePlugin());
+    RuntimeAggregatingLoader plugin = new RuntimeAggregatingLoader(
+            new GeneratedAdapterLoader(), new ReflectiveLoader());
     return DaggerObjectGraph.makeGraph(null, plugin, modules);
   }
 
@@ -135,11 +135,11 @@
     private final Linker linker;
     private final Map<Class<?>, StaticInjection> staticInjections;
     private final Map<String, Class<?>> injectableTypes;
-    private final Plugin plugin;
+    private final Loader plugin;
 
     DaggerObjectGraph(DaggerObjectGraph base,
         Linker linker,
-        Plugin plugin,
+        Loader plugin,
         Map<Class<?>, StaticInjection> staticInjections,
         Map<String, Class<?>> injectableTypes) {
       if (linker == null) throw new NullPointerException("linker");
@@ -154,7 +154,7 @@
       this.injectableTypes = injectableTypes;
     }
 
-    private static ObjectGraph makeGraph(DaggerObjectGraph base, Plugin plugin, Object... modules) {
+    private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Object... modules) {
       Map<String, Class<?>> injectableTypes = new LinkedHashMap<String, Class<?>>();
       Map<Class<?>, StaticInjection> staticInjections
           = new LinkedHashMap<Class<?>, StaticInjection>();
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index cd0c507..65f407a 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -48,11 +48,11 @@
   /** All of the object graph's bindings. This may contain unlinked bindings. */
   private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
 
-  private final Plugin plugin;
+  private final Loader plugin;
 
   private final ErrorHandler errorHandler;
 
-  public Linker(Linker base, Plugin plugin, ErrorHandler errorHandler) {
+  public Linker(Linker base, Loader plugin, ErrorHandler errorHandler) {
     if (plugin == null) throw new NullPointerException("plugin");
     if (errorHandler == null) throw new NullPointerException("errorHandler");
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/Plugin.java b/core/src/main/java/dagger/internal/Loader.java
similarity index 95%
rename from core/src/main/java/dagger/internal/Plugin.java
rename to core/src/main/java/dagger/internal/Loader.java
index 24fdf92..841f91b 100644
--- a/core/src/main/java/dagger/internal/Plugin.java
+++ b/core/src/main/java/dagger/internal/Loader.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,7 +21,7 @@
  * that of Module handling, injection binding creation, and static injection.  A plugin must
  * provide all resolution methods
  */
-public interface Plugin {
+public interface Loader {
   /**
    * Returns a binding that uses {@code @Inject} annotations.
    */
/Fim/
diff --git a/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java b/core/src/main/java/dagger/internal/RuntimeAggregatingLoader.java
similarity index 94%
rename from core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
rename to core/src/main/java/dagger/internal/RuntimeAggregatingLoader.java
index 93514e9..ba1be82 100644
--- a/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
+++ b/core/src/main/java/dagger/internal/RuntimeAggregatingLoader.java
@@ -26,13 +26,13 @@
  * Aggregates provided plugins and delegates its operations to them in order.  Also provides some
  * specific runtime facilities needed by the runtime.
  */
-public final class RuntimeAggregatingPlugin implements Plugin {
+public final class RuntimeAggregatingLoader implements Loader {
   private static final Logger logger = Logger.getLogger(ObjectGraph.class.getName());
 
   /** A list of {@code Linker.Plugin}s which will be consulted in-order to resolve requests. */
-  private final Plugin[] plugins;
+  private final Loader[] plugins;
 
-  public RuntimeAggregatingPlugin(Plugin ... plugins) {
+  public RuntimeAggregatingLoader(Loader ... plugins) {
     if (plugins == null || plugins.length == 0) {
       throw new IllegalArgumentException("Must provide at least one plugin.");
     }
@@ -43,14 +43,14 @@
    * Returns a full set of module adapters, including module adapters for included
    * modules.
    */
-  public static Map<Class<?>, ModuleAdapter<?>> getAllModuleAdapters(Plugin plugin,
+  public static Map<Class<?>, ModuleAdapter<?>> getAllModuleAdapters(Loader plugin,
       Object[] seedModules) {
     // Create a module adapter for each seed module.
     ModuleAdapter<?>[] seedAdapters = new ModuleAdapter<?>[seedModules.length];
     int s = 0;
     for (Object module : seedModules) {
       if (module instanceof Class) {
-        seedAdapters[s++] = plugin.getModuleAdapter((Class<?>) module, null); // Plugin constructs.
+        seedAdapters[s++] = plugin.getModuleAdapter((Class<?>) module, null); // Loader constructs.
       } else {
         seedAdapters[s++] = plugin.getModuleAdapter(module.getClass(), module);
       }
@@ -78,7 +78,7 @@
    * Fills {@code result} with the module adapters for the includes of {@code
    * adapter}, and their includes recursively.
    */
-  private static void collectIncludedModulesRecursively(Plugin plugin, ModuleAdapter<?> adapter,
+  private static void collectIncludedModulesRecursively(Loader plugin, ModuleAdapter<?> adapter,
       Map<Class<?>, ModuleAdapter<?>> result) {
     for (Class<?> include : adapter.includes) {
       if (!result.containsKey(include)) {
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java b/core/src/main/java/dagger/internal/loaders/generated/GeneratedAdapterLoader.java
similarity index 90%
rename from core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java
rename to core/src/main/java/dagger/internal/loaders/generated/GeneratedAdapterLoader.java
index 93cf1a8..dd71ecf 100644
--- a/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java
+++ b/core/src/main/java/dagger/internal/loaders/generated/GeneratedAdapterLoader.java
@@ -13,18 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.plugins.loading;
+package dagger.internal.loaders.generated;
 
 import dagger.internal.Binding;
+import dagger.internal.Loader;
 import dagger.internal.ModuleAdapter;
-import dagger.internal.Plugin;
 import dagger.internal.StaticInjection;
 import java.lang.reflect.Constructor;
 
 /**
- * A runtime {@link Plugin} that loads generated classes.
+ * A runtime {@link Loader} that loads generated classes.
  */
-public final class ClassloadingPlugin implements Plugin {
+public final class GeneratedAdapterLoader implements Loader {
   public static final String INJECT_ADAPTER_SUFFIX = "$$InjectAdapter";
   public static final String MODULE_ADAPTER_SUFFIX = "$$ModuleAdapter";
   public static final String STATIC_INJECTION_SUFFIX = "$$StaticInjection";
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveAtInjectBinding.java
similarity index 99%
rename from core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
rename to core/src/main/java/dagger/internal/loaders/reflect/ReflectiveAtInjectBinding.java
index 4fce92c..28e9e65 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveAtInjectBinding.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.plugins.reflect;
+package dagger.internal.loaders.reflect;
 
 import dagger.internal.Binding;
 import dagger.internal.Keys;
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveLoader.java
similarity index 94%
rename from core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
rename to core/src/main/java/dagger/internal/loaders/reflect/ReflectiveLoader.java
index d5ad9de..f091e21 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
+++ b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveLoader.java
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.plugins.reflect;
+package dagger.internal.loaders.reflect;
 
 import dagger.Module;
 import dagger.internal.Binding;
 import dagger.internal.ModuleAdapter;
-import dagger.internal.Plugin;
+import dagger.internal.Loader;
 import dagger.internal.StaticInjection;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
@@ -29,7 +29,7 @@
 /**
  * Uses reflection to create bindings, module adapters and static injections.
  */
-public final class ReflectivePlugin implements Plugin {
+public final class ReflectiveLoader implements Loader {
   @Override public Binding<?> getAtInjectBinding(
       String key, String className, boolean mustHaveInjections) {
     Class<?> c;
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveModuleAdapter.java
similarity index 99%
rename from core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
rename to core/src/main/java/dagger/internal/loaders/reflect/ReflectiveModuleAdapter.java
index 2745001..36a8d18 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveModuleAdapter.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.plugins.reflect;
+package dagger.internal.loaders.reflect;
 
 import dagger.Lazy;
 import dagger.Module;
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveStaticInjection.java b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveStaticInjection.java
similarity index 97%
rename from core/src/main/java/dagger/internal/plugins/reflect/ReflectiveStaticInjection.java
rename to core/src/main/java/dagger/internal/loaders/reflect/ReflectiveStaticInjection.java
index 519d7ce..0098687 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveStaticInjection.java
+++ b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveStaticInjection.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.plugins.reflect;
+package dagger.internal.loaders.reflect;
 
 import dagger.internal.Binding;
 import dagger.internal.Keys;
/Fim/
diff --git a/checkstyle.xml b/checkstyle.xml
index 40c2b1c..7dfd69c 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -63,7 +63,10 @@
         <module name="LineLength">
             <property name="max" value="100"/>
         </module>
-        <module name="MethodLength"/>
+        <module name="MethodLength">
+            <property name="max" value="200"/>
+        </module>
+            
         <!--module name="ParameterNumber"/-->
 
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
index d5c5903..40488d3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
@@ -113,10 +113,12 @@
   @Override public void attach(Linker linker) {
     String requiredBy = type.getQualifiedName().toString();
     for (int i = 0; i < keys.size(); i++) {
-      bindings[i] = linker.requestBinding(keys.get(i), requiredBy);
+      bindings[i] = linker.requestBinding(keys.get(i), requiredBy,
+          getClass().getClassLoader());
     }
     if (supertypeKey != null) {
-      supertypeBinding = linker.requestBinding(supertypeKey, requiredBy, false, true);
+      supertypeBinding = linker.requestBinding(supertypeKey, requiredBy,
+          getClass().getClassLoader(), false, true);
     }
   }
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeGenStaticInjection.java b/compiler/src/main/java/dagger/internal/codegen/CodeGenStaticInjection.java
index 7d6c6de..8615319 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeGenStaticInjection.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeGenStaticInjection.java
@@ -34,7 +34,8 @@
         Inject injectAnnotation = enclosedElement.getAnnotation(Inject.class);
         if (injectAnnotation != null) {
           String key = GeneratorKeys.get(enclosedElement.asType());
-          linker.requestBinding(key, enclosingClass.toString());
+          linker.requestBinding(key, enclosingClass.toString(),
+              getClass().getClassLoader());
         }
       }
     }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CompileTimeLoader.java b/compiler/src/main/java/dagger/internal/codegen/CompileTimeLoader.java
index 81ceb27..a7b4058 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CompileTimeLoader.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CompileTimeLoader.java
@@ -38,7 +38,7 @@
   }
 
   @Override public Binding<?> getAtInjectBinding(
-      String key, String className, boolean mustHaveInjections) {
+      String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
     String sourceClassName = className.replace('$', '.');
     TypeElement type = processingEnv.getElementUtils().getTypeElement(sourceClassName);
     if (type == null) {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 181ed9b..512e75f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -155,7 +155,8 @@
           String key = CodeGen.isInterface(injectableType)
               ? GeneratorKeys.get(injectableType)
               : GeneratorKeys.rawMembersKey(injectableType);
-          linker.requestBinding(key, module.getQualifiedName().toString(), false, true);
+          linker.requestBinding(key, module.getQualifiedName().toString(),
+              getClass().getClassLoader(), false, true);
         }
 
         // Gather the static injections.
@@ -286,7 +287,8 @@
       for (int i = 0; i < method.getParameters().size(); i++) {
         VariableElement parameter = method.getParameters().get(i);
         String parameterKey = GeneratorKeys.get(parameter);
-        parameters[i] = linker.requestBinding(parameterKey, method.toString());
+        parameters[i] = linker.requestBinding(parameterKey, method.toString(),
+            getClass().getClassLoader());
       }
     }
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index c7be46d..4ab1a8d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -45,6 +45,7 @@
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
+import static dagger.internal.codegen.CodeGen.typeToString;
 import static dagger.internal.codegen.ProcessorJavadocs.binderTypeDocs;
 import static dagger.internal.loaders.generated.GeneratedAdapterLoader.INJECT_ADAPTER_SUFFIX;
 import static dagger.internal.loaders.generated.GeneratedAdapterLoader.STATIC_INJECTION_SUFFIX;
@@ -277,24 +278,26 @@
       writer.beginMethod("void", "attach", PUBLIC, Linker.class.getCanonicalName(), "linker");
       if (constructor != null) {
         for (VariableElement parameter : constructor.getParameters()) {
-          writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
+          writer.emitStatement(
+              "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
               parameterName(disambiguateFields, parameter),
-              writer.compressType(JavaWriter.type(Binding.class,
-                  CodeGen.typeToString(parameter.asType()))),
+              writer.compressType(JavaWriter.type(Binding.class, typeToString(parameter.asType()))),
               JavaWriter.stringLiteral(GeneratorKeys.get(parameter)),
               strippedTypeName);
         }
       }
       for (Element field : fields) {
-        writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
+        writer.emitStatement(
+            "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
             fieldName(disambiguateFields, field),
-            writer.compressType(JavaWriter.type(Binding.class,
-                CodeGen.typeToString(field.asType()))),
+            writer.compressType(JavaWriter.type(Binding.class, typeToString(field.asType()))),
             JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) field)),
             strippedTypeName);
       }
       if (supertype != null) {
-        writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class, false, true)",
+        writer.emitStatement(
+            "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader()"
+                + ", false, true)", // Yep.  This is a dumb line-length violation otherwise.
             "supertype",
             writer.compressType(JavaWriter.type(Binding.class,
                 CodeGen.rawTypeToString(supertype, '.'))),
@@ -427,10 +430,10 @@
     writer.emitAnnotation(Override.class);
     writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
     for (Element field : fields) {
-      writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
+      writer.emitStatement(
+          "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
           fieldName(false, field),
-          writer.compressType(JavaWriter.type(Binding.class,
-              CodeGen.typeToString(field.asType()))),
+          writer.compressType(JavaWriter.type(Binding.class, typeToString(field.asType()))),
           JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) field)),
           typeName);
     }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index e1d2662..32a9386 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -438,7 +438,8 @@
       writer.beginMethod("void", "attach", PUBLIC, Linker.class.getCanonicalName(), "linker");
       for (VariableElement parameter : parameters) {
         String parameterKey = GeneratorKeys.get(parameter);
-        writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
+        writer.emitStatement(
+            "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
             parameterName(parameter),
             writer.compressType(JavaWriter.type(Binding.class,
                 CodeGen.typeToString(parameter.asType()))),
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 79fc36d..1f0d8dd 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -202,7 +202,8 @@
 
     private void linkInjectableTypes() {
       for (Map.Entry<String, Class<?>> entry : injectableTypes.entrySet()) {
-        linker.requestBinding(entry.getKey(), entry.getValue(), false, true);
+        linker.requestBinding(entry.getKey(), entry.getValue(), entry.getValue().getClassLoader(),
+            false, true);
       }
     }
 
@@ -242,43 +243,49 @@
     @Override public <T> T get(Class<T> type) {
       String key = Keys.get(type);
       String injectableTypeKey = type.isInterface() ? key : Keys.getMembersKey(type);
+      ClassLoader classLoader = type.getClassLoader();
       @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
-      Binding<T> binding = (Binding<T>) getInjectableTypeBinding(injectableTypeKey, key);
+      Binding<T> binding =
+          (Binding<T>) getInjectableTypeBinding(classLoader, injectableTypeKey, key);
       return binding.get();
     }
 
     @Override public <T> T inject(T instance) {
       String membersKey = Keys.getMembersKey(instance.getClass());
+      ClassLoader classLoader = instance.getClass().getClassLoader();
       @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
-      Binding<Object> binding = (Binding<Object>) getInjectableTypeBinding(membersKey, membersKey);
+      Binding<T> binding =
+          (Binding<T>) getInjectableTypeBinding(classLoader, membersKey, membersKey);
       binding.injectMembers(instance);
       return instance;
     }
 
     /**
-     * @param injectableTypeKey the key used to store the injectable type. This
+     * @param classLoader the {@code ClassLoader} used to load dependent bindings.
+     * @param injectableKey the key used to store the injectable type. This
      *     is a provides key for interfaces and a members injection key for
      *     other types. That way keys can always be created, even if the type
      *     has no injectable constructor.
      * @param key the key to use when retrieving the binding. This may be a
      *     regular (provider) key or a members key.
      */
-    private Binding<?> getInjectableTypeBinding(String injectableTypeKey, String key) {
+    private Binding<?> getInjectableTypeBinding(
+        ClassLoader classLoader, String injectableKey, String key) {
       Class<?> moduleClass = null;
       for (DaggerObjectGraph graph = this; graph != null; graph = graph.base) {
-        moduleClass = graph.injectableTypes.get(injectableTypeKey);
+        moduleClass = graph.injectableTypes.get(injectableKey);
         if (moduleClass != null) break;
       }
       if (moduleClass == null) {
-        throw new IllegalArgumentException("No inject registered for " + injectableTypeKey
+        throw new IllegalArgumentException("No inject registered for " + injectableKey
             + ". You must explicitly add it to the 'injects' option in one of your modules.");
       }
 
       synchronized (linker) {
-        Binding<?> binding = linker.requestBinding(key, moduleClass, false, true);
+        Binding<?> binding = linker.requestBinding(key, moduleClass, classLoader, false, true);
         if (binding == null || !binding.isLinked()) {
           linker.linkRequested();
-          binding = linker.requestBinding(key, moduleClass, false, true);
+          binding = linker.requestBinding(key, moduleClass, classLoader, false, true);
         }
         return binding;
       }
/Fim/
diff --git a/core/src/main/java/dagger/internal/BuiltInBinding.java b/core/src/main/java/dagger/internal/BuiltInBinding.java
index d6787bc..0991c7a 100644
--- a/core/src/main/java/dagger/internal/BuiltInBinding.java
+++ b/core/src/main/java/dagger/internal/BuiltInBinding.java
@@ -21,15 +21,18 @@
  */
 final class BuiltInBinding<T> extends Binding<T> {
   private final String delegateKey;
+  private final ClassLoader classLoader;
   private Binding<?> delegate;
 
-  public BuiltInBinding(String key, Object requiredBy, String delegateKey) {
+  public BuiltInBinding(
+      String key, Object requiredBy, ClassLoader classLoader, String delegateKey) {
     super(key, null, false, requiredBy);
+    this.classLoader = classLoader;
     this.delegateKey = delegateKey;
   }
 
   @Override public void attach(Linker linker) {
-    delegate = linker.requestBinding(delegateKey, requiredBy);
+    delegate = linker.requestBinding(delegateKey, requiredBy, classLoader);
   }
 
   @Override public void injectMembers(T t) {
/Fim/
diff --git a/core/src/main/java/dagger/internal/LazyBinding.java b/core/src/main/java/dagger/internal/LazyBinding.java
index 0bcbc97..c1e1c71 100644
--- a/core/src/main/java/dagger/internal/LazyBinding.java
+++ b/core/src/main/java/dagger/internal/LazyBinding.java
@@ -26,17 +26,19 @@
   private final static Object NOT_PRESENT = new Object();
 
   private final String lazyKey;
+  private final ClassLoader loader;
   private Binding<T> delegate;
 
-  public LazyBinding(String key, Object requiredBy, String lazyKey) {
+  public LazyBinding(String key, Object requiredBy, ClassLoader loader, String lazyKey) {
     super(key, null, false, requiredBy);
+    this.loader = loader;
     this.lazyKey = lazyKey;
   }
 
   @SuppressWarnings("unchecked") // At runtime we know it's a Binding<Lazy<T>>.
   @Override
   public void attach(Linker linker) {
-    delegate = (Binding<T>) linker.requestBinding(lazyKey, requiredBy);
+    delegate = (Binding<T>) linker.requestBinding(lazyKey, requiredBy, loader);
   }
 
   @Override public void injectMembers(Lazy<T> t) {
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 65f407a..cad087b 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -99,14 +99,15 @@
     Binding<?> binding;
     while ((binding = toLink.poll()) != null) {
       if (binding instanceof DeferredBinding) {
-        DeferredBinding deferredBinding = (DeferredBinding) binding;
-        String key = deferredBinding.deferredKey;
-        boolean mustHaveInjections = deferredBinding.mustHaveInjections;
+        DeferredBinding deferred = (DeferredBinding) binding;
+        String key = deferred.deferredKey;
+        boolean mustHaveInjections = deferred.mustHaveInjections;
         if (bindings.containsKey(key)) {
           continue; // A binding for this key has since been linked.
         }
         try {
-          Binding<?> jitBinding = createJitBinding(key, binding.requiredBy, mustHaveInjections);
+          Binding<?> jitBinding =
+              createJitBinding(key, binding.requiredBy, deferred.classLoader, mustHaveInjections);
           jitBinding.setLibrary(binding.library());
           jitBinding.setDependedOn(binding.dependedOn());
           // Fail if the type of binding we got wasn't capable of what was requested.
@@ -167,35 +168,51 @@
    *   <li>Injections of other types will use the injectable constructors of those classes.
    * </ul>
    */
-  private Binding<?> createJitBinding(String key, Object requiredBy, boolean mustHaveInjections)
-      throws ClassNotFoundException {
+  private Binding<?> createJitBinding(String key, Object requiredBy, ClassLoader classLoader,
+      boolean mustHaveInjections) {
     String builtInBindingsKey = Keys.getBuiltInBindingsKey(key);
     if (builtInBindingsKey != null) {
-      return new BuiltInBinding<Object>(key, requiredBy, builtInBindingsKey);
+      return new BuiltInBinding<Object>(key, requiredBy, classLoader, builtInBindingsKey);
     }
     String lazyKey = Keys.getLazyKey(key);
     if (lazyKey != null) {
-      return new LazyBinding<Object>(key, requiredBy, lazyKey);
+      return new LazyBinding<Object>(key, requiredBy, classLoader, lazyKey);
     }
 
     String className = Keys.getClassName(key);
     if (className != null && !Keys.isAnnotated(key)) {
-      Binding<?> atInjectBinding = plugin.getAtInjectBinding(key, className, mustHaveInjections);
-      if (atInjectBinding != null) {
-        return atInjectBinding;
+      Binding<?> binding =
+          plugin.getAtInjectBinding(key, className, classLoader, mustHaveInjections);
+      if (binding != null) {
+        return binding;
       }
     }
 
     throw new IllegalArgumentException("No binding for " + key);
   }
 
+  /** @Deprectated Older, generated code still using this should be re-generated. */
+  @Deprecated
+  public Binding<?> requestBinding(String key, Object requiredBy) {
+    return requestBinding(
+        key, requiredBy, getClass().getClassLoader(), true, true);
+  }
+
   /**
    * Returns the binding if it exists immediately. Otherwise this returns
    * null. If the returned binding didn't exist or was unlinked, it will be
    * enqueued to be linked.
    */
-  public Binding<?> requestBinding(String key, Object requiredBy) {
-    return requestBinding(key, requiredBy, true, true);
+  public Binding<?> requestBinding(String key, Object requiredBy, ClassLoader classLoader) {
+    return requestBinding(key, requiredBy, classLoader, true, true);
+  }
+
+  /** @Deprectated Older, generated code still using this should be re-generated. */
+  @Deprecated
+  public Binding<?> requestBinding(String key, Object requiredBy,
+      boolean mustHaveInjections, boolean library) {
+    return requestBinding(key, requiredBy, getClass().getClassLoader(),
+        mustHaveInjections, library);
   }
 
   /**
@@ -209,8 +226,8 @@
    *     to inject arbitrary classes like JUnit test cases and Android
    *     activities. It also isn't necessary for supertypes.
    */
-  public Binding<?> requestBinding(String key, Object requiredBy, boolean mustHaveInjections,
-      boolean library) {
+  public Binding<?> requestBinding(String key, Object requiredBy, ClassLoader classLoader,
+      boolean mustHaveInjections, boolean library) {
     assertLockHeld();
 
     Binding<?> binding = null;
@@ -224,7 +241,8 @@
 
     if (binding == null) {
       // We can't satisfy this binding. Make sure it'll work next time!
-      Binding<?> deferredBinding = new DeferredBinding(key, requiredBy, mustHaveInjections);
+      Binding<?> deferredBinding =
+          new DeferredBinding(key, classLoader, requiredBy, mustHaveInjections);
       deferredBinding.setLibrary(library);
       deferredBinding.setDependedOn(true);
       toLink.add(deferredBinding);
@@ -384,12 +402,16 @@
   }
 
   private static class DeferredBinding extends Binding<Object> {
+    /** Loader originally intended to load this binding, to be used in loading the actual one */
+    final ClassLoader classLoader;
     final String deferredKey;
     final boolean mustHaveInjections;
 
-    private DeferredBinding(String deferredKey, Object requiredBy, boolean mustHaveInjections) {
+    private DeferredBinding(String deferredKey, ClassLoader classLoader, Object requiredBy,
+        boolean mustHaveInjections) {
       super(null, null, false, requiredBy);
       this.deferredKey = deferredKey;
+      this.classLoader = classLoader;
       this.mustHaveInjections = mustHaveInjections;
     }
     @Override public void injectMembers(Object t) {
/Fim/
diff --git a/core/src/main/java/dagger/internal/Loader.java b/core/src/main/java/dagger/internal/Loader.java
index 841f91b..beb7fde 100644
--- a/core/src/main/java/dagger/internal/Loader.java
+++ b/core/src/main/java/dagger/internal/Loader.java
@@ -25,7 +25,8 @@
   /**
    * Returns a binding that uses {@code @Inject} annotations.
    */
-  Binding<?> getAtInjectBinding(String key, String className, boolean mustHaveInjections);
+  Binding<?> getAtInjectBinding(
+      String key, String className, ClassLoader classLoader, boolean mustHaveInjections);
 
   /**
    * Returns a module adapter for {@code module}.
/Fim/
diff --git a/core/src/main/java/dagger/internal/RuntimeAggregatingLoader.java b/core/src/main/java/dagger/internal/RuntimeAggregatingLoader.java
index ba1be82..e2fba3a 100644
--- a/core/src/main/java/dagger/internal/RuntimeAggregatingLoader.java
+++ b/core/src/main/java/dagger/internal/RuntimeAggregatingLoader.java
@@ -107,10 +107,10 @@
   }
 
   @Override public Binding<?> getAtInjectBinding(String key, String className,
-      boolean mustHaveInjections) {
+      ClassLoader classLoader, boolean mustHaveInjections) {
     for (int i = 0; i < plugins.length; i++) {
       try {
-        return plugins[i].getAtInjectBinding(key, className, mustHaveInjections);
+        return plugins[i].getAtInjectBinding(key, className, classLoader, mustHaveInjections);
       } catch (RuntimeException e) {
         if (i == plugins.length - 1) throw e;
         logNotFound("Binding", className, e);
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/generated/GeneratedAdapterLoader.java b/core/src/main/java/dagger/internal/loaders/generated/GeneratedAdapterLoader.java
index dd71ecf..a5eafbc 100644
--- a/core/src/main/java/dagger/internal/loaders/generated/GeneratedAdapterLoader.java
+++ b/core/src/main/java/dagger/internal/loaders/generated/GeneratedAdapterLoader.java
@@ -30,23 +30,26 @@
   public static final String STATIC_INJECTION_SUFFIX = "$$StaticInjection";
 
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
-    return instantiate(moduleClass.getName(), MODULE_ADAPTER_SUFFIX);
+    return instantiate(moduleClass.getName(), MODULE_ADAPTER_SUFFIX, moduleClass.getClassLoader());
   }
 
   @Override public Binding<?> getAtInjectBinding(
-      String key, String className, boolean mustHaveInjections) {
-    return instantiate(className, INJECT_ADAPTER_SUFFIX);
+      String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
+    return instantiate(className, INJECT_ADAPTER_SUFFIX, classLoader);
   }
 
   @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    return instantiate(injectedClass.getName(), STATIC_INJECTION_SUFFIX);
+    return instantiate(injectedClass.getName(), STATIC_INJECTION_SUFFIX,
+        injectedClass.getClassLoader());
   }
 
   @SuppressWarnings("unchecked") // We use a naming convention to defend against mismatches.
-  private <T> T instantiate(String className, String suffix) {
+  private <T> T instantiate(String className, String suffix, ClassLoader classLoader) {
     String name = className + suffix;
     try {
-      Class<?> generatedClass = Class.forName(name);
+      // A null classloader is the system classloader.
+      classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
+      Class<?> generatedClass = classLoader.loadClass(name);
       Constructor<?> constructor = generatedClass.getConstructor();
       constructor.setAccessible(true);
       return (T) constructor.newInstance();
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveAtInjectBinding.java b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveAtInjectBinding.java
index 28e9e65..1f74c38 100644
--- a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveAtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveAtInjectBinding.java
@@ -37,6 +37,7 @@
  */
 final class ReflectiveAtInjectBinding<T> extends Binding<T> {
   private final Field[] fields;
+  private final ClassLoader loader;
   private final Constructor<T> constructor;
   private final Class<?> supertype;
   private final String[] keys;
@@ -62,6 +63,7 @@
     this.keys = keys;
     this.parameterBindings = new Binding<?>[parameterCount];
     this.fieldBindings = new Binding<?>[fields.length];
+    this.loader = type.getClassLoader();
   }
 
   @SuppressWarnings("unchecked") // We're careful to make keys and bindings match up.
@@ -69,21 +71,21 @@
     int k = 0;
     for (int i = 0; i < fields.length; i++) {
       if (fieldBindings[i] == null) {
-        fieldBindings[i] = linker.requestBinding(keys[k], fields[i]);
+        fieldBindings[i] = linker.requestBinding(keys[k], fields[i], loader);
       }
       k++;
     }
     if (constructor != null) {
       for (int i = 0; i < parameterBindings.length; i++) {
         if (parameterBindings[i] == null) {
-          parameterBindings[i] = linker.requestBinding(keys[k], constructor);
+          parameterBindings[i] = linker.requestBinding(keys[k], constructor, loader);
         }
         k++;
       }
     }
     if (supertype != null && supertypeBinding == null) {
       supertypeBinding =
-          (Binding<? super T>) linker.requestBinding(keys[k], membersKey, false, true);
+          (Binding<? super T>) linker.requestBinding(keys[k], membersKey, loader, false, true);
     }
   }
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveLoader.java b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveLoader.java
index f091e21..2a11ef3 100644
--- a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveLoader.java
+++ b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveLoader.java
@@ -17,8 +17,8 @@
 
 import dagger.Module;
 import dagger.internal.Binding;
-import dagger.internal.ModuleAdapter;
 import dagger.internal.Loader;
+import dagger.internal.ModuleAdapter;
 import dagger.internal.StaticInjection;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
@@ -31,10 +31,12 @@
  */
 public final class ReflectiveLoader implements Loader {
   @Override public Binding<?> getAtInjectBinding(
-      String key, String className, boolean mustHaveInjections) {
+      String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
     Class<?> c;
     try {
-      c = Class.forName(className);
+      // A null classloader is the system classloader.
+      classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
+      c = classLoader.loadClass(className);
     } catch (ClassNotFoundException e) {
       throw new RuntimeException(e);
     }
@@ -70,6 +72,7 @@
     if (fields.isEmpty()) {
       throw new IllegalArgumentException("No static injections: " + injectedClass.getName());
     }
-    return new ReflectiveStaticInjection(fields.toArray(new Field[fields.size()]));
+    return new ReflectiveStaticInjection(injectedClass.getClassLoader(),
+        fields.toArray(new Field[fields.size()]));
   }
 }
\ No newline at end of file
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveModuleAdapter.java
index 36a8d18..3fce068 100644
--- a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveModuleAdapter.java
@@ -152,7 +152,7 @@
       parameters = new Binding[types.length];
       for (int i = 0; i < parameters.length; i++) {
         String key = Keys.get(types[i], annotations[i], method + " parameter " + i);
-        parameters[i] = linker.requestBinding(key, method);
+        parameters[i] = linker.requestBinding(key, method, instance.getClass().getClassLoader());
       }
     }
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveStaticInjection.java b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveStaticInjection.java
index 0098687..df3deb0 100644
--- a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveStaticInjection.java
+++ b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveStaticInjection.java
@@ -25,11 +25,13 @@
  * Uses reflection to inject the static fields of a class.
  */
 final class ReflectiveStaticInjection extends StaticInjection {
+  private final ClassLoader loader;
   private final Field[] fields;
   private Binding<?>[] bindings;
 
-  public ReflectiveStaticInjection(Field[] fields) {
+  public ReflectiveStaticInjection(ClassLoader loader, Field[] fields) {
     this.fields = fields;
+    this.loader = loader;
   }
 
   @Override public void attach(Linker linker) {
@@ -37,7 +39,7 @@
     for (int i = 0; i < fields.length; i++) {
       Field field = fields[i];
       String key = Keys.get(field.getGenericType(), field.getAnnotations(), field);
-      bindings[i] = linker.requestBinding(key, field);
+      bindings[i] = linker.requestBinding(key, field, loader);
     }
   }
 
/Fim/
diff --git a/checkstyle.xml b/checkstyle.xml
index 40c2b1c..7dfd69c 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -63,7 +63,10 @@
         <module name="LineLength">
             <property name="max" value="100"/>
         </module>
-        <module name="MethodLength"/>
+        <module name="MethodLength">
+            <property name="max" value="200"/>
+        </module>
+            
         <!--module name="ParameterNumber"/-->
 
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
index d5c5903..40488d3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
@@ -113,10 +113,12 @@
   @Override public void attach(Linker linker) {
     String requiredBy = type.getQualifiedName().toString();
     for (int i = 0; i < keys.size(); i++) {
-      bindings[i] = linker.requestBinding(keys.get(i), requiredBy);
+      bindings[i] = linker.requestBinding(keys.get(i), requiredBy,
+          getClass().getClassLoader());
     }
     if (supertypeKey != null) {
-      supertypeBinding = linker.requestBinding(supertypeKey, requiredBy, false, true);
+      supertypeBinding = linker.requestBinding(supertypeKey, requiredBy,
+          getClass().getClassLoader(), false, true);
     }
   }
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeGenStaticInjection.java b/compiler/src/main/java/dagger/internal/codegen/CodeGenStaticInjection.java
index 7d6c6de..8615319 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeGenStaticInjection.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeGenStaticInjection.java
@@ -34,7 +34,8 @@
         Inject injectAnnotation = enclosedElement.getAnnotation(Inject.class);
         if (injectAnnotation != null) {
           String key = GeneratorKeys.get(enclosedElement.asType());
-          linker.requestBinding(key, enclosingClass.toString());
+          linker.requestBinding(key, enclosingClass.toString(),
+              getClass().getClassLoader());
         }
       }
     }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CompileTimeLoader.java b/compiler/src/main/java/dagger/internal/codegen/CompileTimeLoader.java
index 81ceb27..a7b4058 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CompileTimeLoader.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CompileTimeLoader.java
@@ -38,7 +38,7 @@
   }
 
   @Override public Binding<?> getAtInjectBinding(
-      String key, String className, boolean mustHaveInjections) {
+      String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
     String sourceClassName = className.replace('$', '.');
     TypeElement type = processingEnv.getElementUtils().getTypeElement(sourceClassName);
     if (type == null) {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 181ed9b..512e75f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -155,7 +155,8 @@
           String key = CodeGen.isInterface(injectableType)
               ? GeneratorKeys.get(injectableType)
               : GeneratorKeys.rawMembersKey(injectableType);
-          linker.requestBinding(key, module.getQualifiedName().toString(), false, true);
+          linker.requestBinding(key, module.getQualifiedName().toString(),
+              getClass().getClassLoader(), false, true);
         }
 
         // Gather the static injections.
@@ -286,7 +287,8 @@
       for (int i = 0; i < method.getParameters().size(); i++) {
         VariableElement parameter = method.getParameters().get(i);
         String parameterKey = GeneratorKeys.get(parameter);
-        parameters[i] = linker.requestBinding(parameterKey, method.toString());
+        parameters[i] = linker.requestBinding(parameterKey, method.toString(),
+            getClass().getClassLoader());
       }
     }
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index c7be46d..4ab1a8d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -45,6 +45,7 @@
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
+import static dagger.internal.codegen.CodeGen.typeToString;
 import static dagger.internal.codegen.ProcessorJavadocs.binderTypeDocs;
 import static dagger.internal.loaders.generated.GeneratedAdapterLoader.INJECT_ADAPTER_SUFFIX;
 import static dagger.internal.loaders.generated.GeneratedAdapterLoader.STATIC_INJECTION_SUFFIX;
@@ -277,24 +278,26 @@
       writer.beginMethod("void", "attach", PUBLIC, Linker.class.getCanonicalName(), "linker");
       if (constructor != null) {
         for (VariableElement parameter : constructor.getParameters()) {
-          writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
+          writer.emitStatement(
+              "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
               parameterName(disambiguateFields, parameter),
-              writer.compressType(JavaWriter.type(Binding.class,
-                  CodeGen.typeToString(parameter.asType()))),
+              writer.compressType(JavaWriter.type(Binding.class, typeToString(parameter.asType()))),
               JavaWriter.stringLiteral(GeneratorKeys.get(parameter)),
               strippedTypeName);
         }
       }
       for (Element field : fields) {
-        writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
+        writer.emitStatement(
+            "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
             fieldName(disambiguateFields, field),
-            writer.compressType(JavaWriter.type(Binding.class,
-                CodeGen.typeToString(field.asType()))),
+            writer.compressType(JavaWriter.type(Binding.class, typeToString(field.asType()))),
             JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) field)),
             strippedTypeName);
       }
       if (supertype != null) {
-        writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class, false, true)",
+        writer.emitStatement(
+            "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader()"
+                + ", false, true)", // Yep.  This is a dumb line-length violation otherwise.
             "supertype",
             writer.compressType(JavaWriter.type(Binding.class,
                 CodeGen.rawTypeToString(supertype, '.'))),
@@ -427,10 +430,10 @@
     writer.emitAnnotation(Override.class);
     writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
     for (Element field : fields) {
-      writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
+      writer.emitStatement(
+          "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
           fieldName(false, field),
-          writer.compressType(JavaWriter.type(Binding.class,
-              CodeGen.typeToString(field.asType()))),
+          writer.compressType(JavaWriter.type(Binding.class, typeToString(field.asType()))),
           JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) field)),
           typeName);
     }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index e1d2662..32a9386 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -438,7 +438,8 @@
       writer.beginMethod("void", "attach", PUBLIC, Linker.class.getCanonicalName(), "linker");
       for (VariableElement parameter : parameters) {
         String parameterKey = GeneratorKeys.get(parameter);
-        writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
+        writer.emitStatement(
+            "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
             parameterName(parameter),
             writer.compressType(JavaWriter.type(Binding.class,
                 CodeGen.typeToString(parameter.asType()))),
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 79fc36d..1f0d8dd 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -202,7 +202,8 @@
 
     private void linkInjectableTypes() {
       for (Map.Entry<String, Class<?>> entry : injectableTypes.entrySet()) {
-        linker.requestBinding(entry.getKey(), entry.getValue(), false, true);
+        linker.requestBinding(entry.getKey(), entry.getValue(), entry.getValue().getClassLoader(),
+            false, true);
       }
     }
 
@@ -242,43 +243,49 @@
     @Override public <T> T get(Class<T> type) {
       String key = Keys.get(type);
       String injectableTypeKey = type.isInterface() ? key : Keys.getMembersKey(type);
+      ClassLoader classLoader = type.getClassLoader();
       @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
-      Binding<T> binding = (Binding<T>) getInjectableTypeBinding(injectableTypeKey, key);
+      Binding<T> binding =
+          (Binding<T>) getInjectableTypeBinding(classLoader, injectableTypeKey, key);
       return binding.get();
     }
 
     @Override public <T> T inject(T instance) {
       String membersKey = Keys.getMembersKey(instance.getClass());
+      ClassLoader classLoader = instance.getClass().getClassLoader();
       @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
-      Binding<Object> binding = (Binding<Object>) getInjectableTypeBinding(membersKey, membersKey);
+      Binding<T> binding =
+          (Binding<T>) getInjectableTypeBinding(classLoader, membersKey, membersKey);
       binding.injectMembers(instance);
       return instance;
     }
 
     /**
-     * @param injectableTypeKey the key used to store the injectable type. This
+     * @param classLoader the {@code ClassLoader} used to load dependent bindings.
+     * @param injectableKey the key used to store the injectable type. This
      *     is a provides key for interfaces and a members injection key for
      *     other types. That way keys can always be created, even if the type
      *     has no injectable constructor.
      * @param key the key to use when retrieving the binding. This may be a
      *     regular (provider) key or a members key.
      */
-    private Binding<?> getInjectableTypeBinding(String injectableTypeKey, String key) {
+    private Binding<?> getInjectableTypeBinding(
+        ClassLoader classLoader, String injectableKey, String key) {
       Class<?> moduleClass = null;
       for (DaggerObjectGraph graph = this; graph != null; graph = graph.base) {
-        moduleClass = graph.injectableTypes.get(injectableTypeKey);
+        moduleClass = graph.injectableTypes.get(injectableKey);
         if (moduleClass != null) break;
       }
       if (moduleClass == null) {
-        throw new IllegalArgumentException("No inject registered for " + injectableTypeKey
+        throw new IllegalArgumentException("No inject registered for " + injectableKey
             + ". You must explicitly add it to the 'injects' option in one of your modules.");
       }
 
       synchronized (linker) {
-        Binding<?> binding = linker.requestBinding(key, moduleClass, false, true);
+        Binding<?> binding = linker.requestBinding(key, moduleClass, classLoader, false, true);
         if (binding == null || !binding.isLinked()) {
           linker.linkRequested();
-          binding = linker.requestBinding(key, moduleClass, false, true);
+          binding = linker.requestBinding(key, moduleClass, classLoader, false, true);
         }
         return binding;
       }
/Fim/
diff --git a/core/src/main/java/dagger/internal/BuiltInBinding.java b/core/src/main/java/dagger/internal/BuiltInBinding.java
index d6787bc..0991c7a 100644
--- a/core/src/main/java/dagger/internal/BuiltInBinding.java
+++ b/core/src/main/java/dagger/internal/BuiltInBinding.java
@@ -21,15 +21,18 @@
  */
 final class BuiltInBinding<T> extends Binding<T> {
   private final String delegateKey;
+  private final ClassLoader classLoader;
   private Binding<?> delegate;
 
-  public BuiltInBinding(String key, Object requiredBy, String delegateKey) {
+  public BuiltInBinding(
+      String key, Object requiredBy, ClassLoader classLoader, String delegateKey) {
     super(key, null, false, requiredBy);
+    this.classLoader = classLoader;
     this.delegateKey = delegateKey;
   }
 
   @Override public void attach(Linker linker) {
-    delegate = linker.requestBinding(delegateKey, requiredBy);
+    delegate = linker.requestBinding(delegateKey, requiredBy, classLoader);
   }
 
   @Override public void injectMembers(T t) {
/Fim/
diff --git a/core/src/main/java/dagger/internal/LazyBinding.java b/core/src/main/java/dagger/internal/LazyBinding.java
index 0bcbc97..c1e1c71 100644
--- a/core/src/main/java/dagger/internal/LazyBinding.java
+++ b/core/src/main/java/dagger/internal/LazyBinding.java
@@ -26,17 +26,19 @@
   private final static Object NOT_PRESENT = new Object();
 
   private final String lazyKey;
+  private final ClassLoader loader;
   private Binding<T> delegate;
 
-  public LazyBinding(String key, Object requiredBy, String lazyKey) {
+  public LazyBinding(String key, Object requiredBy, ClassLoader loader, String lazyKey) {
     super(key, null, false, requiredBy);
+    this.loader = loader;
     this.lazyKey = lazyKey;
   }
 
   @SuppressWarnings("unchecked") // At runtime we know it's a Binding<Lazy<T>>.
   @Override
   public void attach(Linker linker) {
-    delegate = (Binding<T>) linker.requestBinding(lazyKey, requiredBy);
+    delegate = (Binding<T>) linker.requestBinding(lazyKey, requiredBy, loader);
   }
 
   @Override public void injectMembers(Lazy<T> t) {
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 65f407a..59de824 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -99,14 +99,15 @@
     Binding<?> binding;
     while ((binding = toLink.poll()) != null) {
       if (binding instanceof DeferredBinding) {
-        DeferredBinding deferredBinding = (DeferredBinding) binding;
-        String key = deferredBinding.deferredKey;
-        boolean mustHaveInjections = deferredBinding.mustHaveInjections;
+        DeferredBinding deferred = (DeferredBinding) binding;
+        String key = deferred.deferredKey;
+        boolean mustHaveInjections = deferred.mustHaveInjections;
         if (bindings.containsKey(key)) {
           continue; // A binding for this key has since been linked.
         }
         try {
-          Binding<?> jitBinding = createJitBinding(key, binding.requiredBy, mustHaveInjections);
+          Binding<?> jitBinding =
+              createJitBinding(key, binding.requiredBy, deferred.classLoader, mustHaveInjections);
           jitBinding.setLibrary(binding.library());
           jitBinding.setDependedOn(binding.dependedOn());
           // Fail if the type of binding we got wasn't capable of what was requested.
@@ -167,35 +168,51 @@
    *   <li>Injections of other types will use the injectable constructors of those classes.
    * </ul>
    */
-  private Binding<?> createJitBinding(String key, Object requiredBy, boolean mustHaveInjections)
-      throws ClassNotFoundException {
+  private Binding<?> createJitBinding(String key, Object requiredBy, ClassLoader classLoader,
+      boolean mustHaveInjections) {
     String builtInBindingsKey = Keys.getBuiltInBindingsKey(key);
     if (builtInBindingsKey != null) {
-      return new BuiltInBinding<Object>(key, requiredBy, builtInBindingsKey);
+      return new BuiltInBinding<Object>(key, requiredBy, classLoader, builtInBindingsKey);
     }
     String lazyKey = Keys.getLazyKey(key);
     if (lazyKey != null) {
-      return new LazyBinding<Object>(key, requiredBy, lazyKey);
+      return new LazyBinding<Object>(key, requiredBy, classLoader, lazyKey);
     }
 
     String className = Keys.getClassName(key);
     if (className != null && !Keys.isAnnotated(key)) {
-      Binding<?> atInjectBinding = plugin.getAtInjectBinding(key, className, mustHaveInjections);
-      if (atInjectBinding != null) {
-        return atInjectBinding;
+      Binding<?> binding =
+          plugin.getAtInjectBinding(key, className, classLoader, mustHaveInjections);
+      if (binding != null) {
+        return binding;
       }
     }
 
     throw new IllegalArgumentException("No binding for " + key);
   }
 
+  /** @deprecated Older, generated code still using this should be re-generated. */
+  @Deprecated
+  public Binding<?> requestBinding(String key, Object requiredBy) {
+    return requestBinding(
+        key, requiredBy, getClass().getClassLoader(), true, true);
+  }
+
   /**
    * Returns the binding if it exists immediately. Otherwise this returns
    * null. If the returned binding didn't exist or was unlinked, it will be
    * enqueued to be linked.
    */
-  public Binding<?> requestBinding(String key, Object requiredBy) {
-    return requestBinding(key, requiredBy, true, true);
+  public Binding<?> requestBinding(String key, Object requiredBy, ClassLoader classLoader) {
+    return requestBinding(key, requiredBy, classLoader, true, true);
+  }
+
+  /** @deprecated Older, generated code still using this should be re-generated. */
+  @Deprecated
+  public Binding<?> requestBinding(String key, Object requiredBy,
+      boolean mustHaveInjections, boolean library) {
+    return requestBinding(key, requiredBy, getClass().getClassLoader(),
+        mustHaveInjections, library);
   }
 
   /**
@@ -209,8 +226,8 @@
    *     to inject arbitrary classes like JUnit test cases and Android
    *     activities. It also isn't necessary for supertypes.
    */
-  public Binding<?> requestBinding(String key, Object requiredBy, boolean mustHaveInjections,
-      boolean library) {
+  public Binding<?> requestBinding(String key, Object requiredBy, ClassLoader classLoader,
+      boolean mustHaveInjections, boolean library) {
     assertLockHeld();
 
     Binding<?> binding = null;
@@ -224,7 +241,8 @@
 
     if (binding == null) {
       // We can't satisfy this binding. Make sure it'll work next time!
-      Binding<?> deferredBinding = new DeferredBinding(key, requiredBy, mustHaveInjections);
+      Binding<?> deferredBinding =
+          new DeferredBinding(key, classLoader, requiredBy, mustHaveInjections);
       deferredBinding.setLibrary(library);
       deferredBinding.setDependedOn(true);
       toLink.add(deferredBinding);
@@ -384,12 +402,16 @@
   }
 
   private static class DeferredBinding extends Binding<Object> {
+    /** Loader originally intended to load this binding, to be used in loading the actual one */
+    final ClassLoader classLoader;
     final String deferredKey;
     final boolean mustHaveInjections;
 
-    private DeferredBinding(String deferredKey, Object requiredBy, boolean mustHaveInjections) {
+    private DeferredBinding(String deferredKey, ClassLoader classLoader, Object requiredBy,
+        boolean mustHaveInjections) {
       super(null, null, false, requiredBy);
       this.deferredKey = deferredKey;
+      this.classLoader = classLoader;
       this.mustHaveInjections = mustHaveInjections;
     }
     @Override public void injectMembers(Object t) {
/Fim/
diff --git a/core/src/main/java/dagger/internal/Loader.java b/core/src/main/java/dagger/internal/Loader.java
index 841f91b..beb7fde 100644
--- a/core/src/main/java/dagger/internal/Loader.java
+++ b/core/src/main/java/dagger/internal/Loader.java
@@ -25,7 +25,8 @@
   /**
    * Returns a binding that uses {@code @Inject} annotations.
    */
-  Binding<?> getAtInjectBinding(String key, String className, boolean mustHaveInjections);
+  Binding<?> getAtInjectBinding(
+      String key, String className, ClassLoader classLoader, boolean mustHaveInjections);
 
   /**
    * Returns a module adapter for {@code module}.
/Fim/
diff --git a/core/src/main/java/dagger/internal/RuntimeAggregatingLoader.java b/core/src/main/java/dagger/internal/RuntimeAggregatingLoader.java
index ba1be82..e2fba3a 100644
--- a/core/src/main/java/dagger/internal/RuntimeAggregatingLoader.java
+++ b/core/src/main/java/dagger/internal/RuntimeAggregatingLoader.java
@@ -107,10 +107,10 @@
   }
 
   @Override public Binding<?> getAtInjectBinding(String key, String className,
-      boolean mustHaveInjections) {
+      ClassLoader classLoader, boolean mustHaveInjections) {
     for (int i = 0; i < plugins.length; i++) {
       try {
-        return plugins[i].getAtInjectBinding(key, className, mustHaveInjections);
+        return plugins[i].getAtInjectBinding(key, className, classLoader, mustHaveInjections);
       } catch (RuntimeException e) {
         if (i == plugins.length - 1) throw e;
         logNotFound("Binding", className, e);
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/generated/GeneratedAdapterLoader.java b/core/src/main/java/dagger/internal/loaders/generated/GeneratedAdapterLoader.java
index dd71ecf..a5eafbc 100644
--- a/core/src/main/java/dagger/internal/loaders/generated/GeneratedAdapterLoader.java
+++ b/core/src/main/java/dagger/internal/loaders/generated/GeneratedAdapterLoader.java
@@ -30,23 +30,26 @@
   public static final String STATIC_INJECTION_SUFFIX = "$$StaticInjection";
 
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
-    return instantiate(moduleClass.getName(), MODULE_ADAPTER_SUFFIX);
+    return instantiate(moduleClass.getName(), MODULE_ADAPTER_SUFFIX, moduleClass.getClassLoader());
   }
 
   @Override public Binding<?> getAtInjectBinding(
-      String key, String className, boolean mustHaveInjections) {
-    return instantiate(className, INJECT_ADAPTER_SUFFIX);
+      String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
+    return instantiate(className, INJECT_ADAPTER_SUFFIX, classLoader);
   }
 
   @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    return instantiate(injectedClass.getName(), STATIC_INJECTION_SUFFIX);
+    return instantiate(injectedClass.getName(), STATIC_INJECTION_SUFFIX,
+        injectedClass.getClassLoader());
   }
 
   @SuppressWarnings("unchecked") // We use a naming convention to defend against mismatches.
-  private <T> T instantiate(String className, String suffix) {
+  private <T> T instantiate(String className, String suffix, ClassLoader classLoader) {
     String name = className + suffix;
     try {
-      Class<?> generatedClass = Class.forName(name);
+      // A null classloader is the system classloader.
+      classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
+      Class<?> generatedClass = classLoader.loadClass(name);
       Constructor<?> constructor = generatedClass.getConstructor();
       constructor.setAccessible(true);
       return (T) constructor.newInstance();
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveAtInjectBinding.java b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveAtInjectBinding.java
index 28e9e65..1f74c38 100644
--- a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveAtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveAtInjectBinding.java
@@ -37,6 +37,7 @@
  */
 final class ReflectiveAtInjectBinding<T> extends Binding<T> {
   private final Field[] fields;
+  private final ClassLoader loader;
   private final Constructor<T> constructor;
   private final Class<?> supertype;
   private final String[] keys;
@@ -62,6 +63,7 @@
     this.keys = keys;
     this.parameterBindings = new Binding<?>[parameterCount];
     this.fieldBindings = new Binding<?>[fields.length];
+    this.loader = type.getClassLoader();
   }
 
   @SuppressWarnings("unchecked") // We're careful to make keys and bindings match up.
@@ -69,21 +71,21 @@
     int k = 0;
     for (int i = 0; i < fields.length; i++) {
       if (fieldBindings[i] == null) {
-        fieldBindings[i] = linker.requestBinding(keys[k], fields[i]);
+        fieldBindings[i] = linker.requestBinding(keys[k], fields[i], loader);
       }
       k++;
     }
     if (constructor != null) {
       for (int i = 0; i < parameterBindings.length; i++) {
         if (parameterBindings[i] == null) {
-          parameterBindings[i] = linker.requestBinding(keys[k], constructor);
+          parameterBindings[i] = linker.requestBinding(keys[k], constructor, loader);
         }
         k++;
       }
     }
     if (supertype != null && supertypeBinding == null) {
       supertypeBinding =
-          (Binding<? super T>) linker.requestBinding(keys[k], membersKey, false, true);
+          (Binding<? super T>) linker.requestBinding(keys[k], membersKey, loader, false, true);
     }
   }
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveLoader.java b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveLoader.java
index f091e21..2a11ef3 100644
--- a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveLoader.java
+++ b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveLoader.java
@@ -17,8 +17,8 @@
 
 import dagger.Module;
 import dagger.internal.Binding;
-import dagger.internal.ModuleAdapter;
 import dagger.internal.Loader;
+import dagger.internal.ModuleAdapter;
 import dagger.internal.StaticInjection;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
@@ -31,10 +31,12 @@
  */
 public final class ReflectiveLoader implements Loader {
   @Override public Binding<?> getAtInjectBinding(
-      String key, String className, boolean mustHaveInjections) {
+      String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
     Class<?> c;
     try {
-      c = Class.forName(className);
+      // A null classloader is the system classloader.
+      classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
+      c = classLoader.loadClass(className);
     } catch (ClassNotFoundException e) {
       throw new RuntimeException(e);
     }
@@ -70,6 +72,7 @@
     if (fields.isEmpty()) {
       throw new IllegalArgumentException("No static injections: " + injectedClass.getName());
     }
-    return new ReflectiveStaticInjection(fields.toArray(new Field[fields.size()]));
+    return new ReflectiveStaticInjection(injectedClass.getClassLoader(),
+        fields.toArray(new Field[fields.size()]));
   }
 }
\ No newline at end of file
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveModuleAdapter.java
index 36a8d18..3fce068 100644
--- a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveModuleAdapter.java
@@ -152,7 +152,7 @@
       parameters = new Binding[types.length];
       for (int i = 0; i < parameters.length; i++) {
         String key = Keys.get(types[i], annotations[i], method + " parameter " + i);
-        parameters[i] = linker.requestBinding(key, method);
+        parameters[i] = linker.requestBinding(key, method, instance.getClass().getClassLoader());
       }
     }
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveStaticInjection.java b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveStaticInjection.java
index 0098687..df3deb0 100644
--- a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveStaticInjection.java
+++ b/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveStaticInjection.java
@@ -25,11 +25,13 @@
  * Uses reflection to inject the static fields of a class.
  */
 final class ReflectiveStaticInjection extends StaticInjection {
+  private final ClassLoader loader;
   private final Field[] fields;
   private Binding<?>[] bindings;
 
-  public ReflectiveStaticInjection(Field[] fields) {
+  public ReflectiveStaticInjection(ClassLoader loader, Field[] fields) {
     this.fields = fields;
+    this.loader = loader;
   }
 
   @Override public void attach(Linker linker) {
@@ -37,7 +39,7 @@
     for (int i = 0; i < fields.length; i++) {
       Field field = fields[i];
       String key = Keys.get(field.getGenericType(), field.getAnnotations(), field);
-      bindings[i] = linker.requestBinding(key, field);
+      bindings[i] = linker.requestBinding(key, field, loader);
     }
   }
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProcessorJavadocs.java b/compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java
similarity index 96%
rename from compiler/src/main/java/dagger/internal/codegen/ProcessorJavadocs.java
rename to compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java
index 51bc228..3312f1e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProcessorJavadocs.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java
@@ -16,10 +16,10 @@
 package dagger.internal.codegen;
 
 /**
- * Utility class providing some commonly used boilerplate between {@code InjectProcessor}
- * and {@code ProvidesProcessor}.
+ * Utility class providing some commonly used boilerplate between {@code InjectAdapterProcessor}
+ * and {@code ModuleAdapterProcessor}.
  */
-public final class ProcessorJavadocs {
+public final class AdapterJavadocs {
   static final String GENERATED_BY_DAGGER = "Code generated by dagger-compiler.  Do not edit.";
   static final String MEMBERS_INJECT_METHOD = ""
       + "Injects any {@code @Inject} annotated fields in the given instance,\n"
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java b/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
index 75c9e7f..838fa9c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
@@ -25,6 +25,9 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
 
+import static dagger.internal.codegen.TypeUtils.rawTypeToString;
+import static dagger.internal.codegen.TypeUtils.typeToString;
+
 /**
  * Creates keys using javac's mirror APIs. Unlike {@code Keys}, this class uses
  * APIs not available on Android.
@@ -41,13 +44,13 @@
    * generated code.
    */
   public static String rawMembersKey(TypeMirror type) {
-    return "members/" + CodeGen.rawTypeToString(type, '$');
+    return "members/" + rawTypeToString(type, '$');
   }
 
   /** Returns the provider key for {@code type}. */
   public static String get(TypeMirror type) {
     StringBuilder result = new StringBuilder();
-    CodeGen.typeToString(type, result, '$');
+    typeToString(type, result, '$');
     return result.toString();
   }
 
@@ -58,7 +61,7 @@
     if (qualifier != null) {
       qualifierToString(qualifier, result);
     }
-    CodeGen.typeToString(method.getReturnType(), result, '$');
+    typeToString(method.getReturnType(), result, '$');
     return result.toString();
   }
 
@@ -70,7 +73,7 @@
       qualifierToString(qualifier, result);
     }
     result.append(SET_PREFIX);
-    CodeGen.typeToString(method.getReturnType(), result, '$');
+    typeToString(method.getReturnType(), result, '$');
     result.append(">");
     return result.toString();
   }
@@ -82,14 +85,14 @@
     if (qualifier != null) {
       qualifierToString(qualifier, result);
     }
-    CodeGen.typeToString(variable.asType(), result, '$');
+    typeToString(variable.asType(), result, '$');
     return result.toString();
   }
 
   private static void qualifierToString(AnnotationMirror qualifier, StringBuilder result) {
     // TODO: guarantee that element values are sorted by name (if there are multiple)
     result.append('@');
-    CodeGen.typeToString(qualifier.getAnnotationType(), result, '$');
+    typeToString(qualifier.getAnnotationType(), result, '$');
     result.append('(');
     for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry
         : qualifier.getElementValues().entrySet()) {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ReportingErrorHandler.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisErrorHandler.java
similarity index 89%
rename from compiler/src/main/java/dagger/internal/codegen/ReportingErrorHandler.java
rename to compiler/src/main/java/dagger/internal/codegen/GraphAnalysisErrorHandler.java
index 74b98fb..121bbae 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ReportingErrorHandler.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisErrorHandler.java
@@ -25,11 +25,11 @@
  * A {@code Linker.ErrorHandler} which gathers errors and reports them via a processing
  * environment.
  */
-final class ReportingErrorHandler implements Linker.ErrorHandler {
+final class GraphAnalysisErrorHandler implements Linker.ErrorHandler {
   private final ProcessingEnvironment processingEnv;
   private final String moduleName;
 
-  ReportingErrorHandler(ProcessingEnvironment processingEnv, String moduleName) {
+  GraphAnalysisErrorHandler(ProcessingEnvironment processingEnv, String moduleName) {
     this.processingEnv = processingEnv;
     this.moduleName = moduleName;
   }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
similarity index 88%
rename from compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
rename to compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
index 40488d3..d4e073f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
@@ -30,17 +30,18 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
 
+import static dagger.internal.codegen.TypeUtils.getApplicationSupertype;
+
 /**
  * A build time binding that injects the constructor and fields of a class.
  */
-final class AtInjectBinding extends Binding<Object> {
+final class GraphAnalysisInjectBinding extends Binding<Object> {
   private final TypeElement type;
   private final List<String> keys;
   private final Binding<?>[] bindings;
   private final String supertypeKey;
-  private Binding supertypeBinding;
 
-  private AtInjectBinding(String provideKey, String membersKey,
+  private GraphAnalysisInjectBinding(String provideKey, String membersKey,
       TypeElement type, List<String> keys, String supertypeKey) {
     super(provideKey, membersKey, type.getAnnotation(Singleton.class) != null,
         type.getQualifiedName().toString());
@@ -50,7 +51,7 @@
     this.supertypeKey = supertypeKey;
   }
 
-  static AtInjectBinding create(TypeElement type, boolean mustHaveInjections) {
+  static GraphAnalysisInjectBinding create(TypeElement type, boolean mustHaveInjections) {
     List<String> requiredKeys = new ArrayList<String>();
     boolean hasInjectConstructor = false;
     boolean hasNoArgsConstructor = false;
@@ -94,7 +95,7 @@
     }
 
     // Attach the supertype.
-    TypeMirror supertype = CodeGen.getApplicationSupertype(type);
+    TypeMirror supertype = getApplicationSupertype(type);
     String supertypeKey = supertype != null
         ? GeneratorKeys.rawMembersKey(supertype)
         : null;
@@ -103,7 +104,7 @@
         ? GeneratorKeys.get(type.asType())
         : null;
     String membersKey = GeneratorKeys.rawMembersKey(type.asType());
-    return new AtInjectBinding(provideKey, membersKey, type, requiredKeys, supertypeKey);
+    return new GraphAnalysisInjectBinding(provideKey, membersKey, type, requiredKeys, supertypeKey);
   }
 
   private static boolean hasAtInject(Element enclosed) {
@@ -117,8 +118,8 @@
           getClass().getClassLoader());
     }
     if (supertypeKey != null) {
-      supertypeBinding = linker.requestBinding(supertypeKey, requiredBy,
-          getClass().getClassLoader(), false, true);
+      // Force the binding lookup.
+      linker.requestBinding(supertypeKey, requiredBy, getClass().getClassLoader(), false, true);
     }
   }
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CompileTimeLoader.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
similarity index 91%
rename from compiler/src/main/java/dagger/internal/codegen/CompileTimeLoader.java
rename to compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
index a7b4058..e35e84d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CompileTimeLoader.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
@@ -29,11 +29,11 @@
  * {@link Binding#get} or {@link Binding#injectMembers} methods. They are only suitable
  * for graph analysis and error detection.
  */
-public final class CompileTimeLoader implements Loader {
+public final class GraphAnalysisLoader implements Loader {
 
   private final ProcessingEnvironment processingEnv;
 
-  public CompileTimeLoader(ProcessingEnvironment processingEnv) {
+  public GraphAnalysisLoader(ProcessingEnvironment processingEnv) {
     this.processingEnv = processingEnv;
   }
 
@@ -51,7 +51,7 @@
     if (type.getKind() == ElementKind.INTERFACE) {
       return null;
     }
-    return AtInjectBinding.create(type, mustHaveInjections);
+    return GraphAnalysisInjectBinding.create(type, mustHaveInjections);
   }
 
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
similarity index 89%
rename from compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
rename to compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index 512e75f..0c70f96 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -51,11 +51,16 @@
 import javax.tools.JavaFileManager;
 import javax.tools.StandardLocation;
 
+import static dagger.internal.codegen.TypeUtils.getAnnotation;
+import static dagger.internal.codegen.TypeUtils.getPackage;
+import static dagger.internal.codegen.TypeUtils.isInterface;
+import static dagger.internal.codegen.TypeUtils.methodName;
+
 /**
  * Performs full graph analysis on a module.
  */
 @SupportedAnnotationTypes("dagger.Module")
-public final class FullGraphProcessor extends AbstractProcessor {
+public final class GraphAnalysisProcessor extends AbstractProcessor {
   private final Set<String> delayedModuleNames = new LinkedHashSet<String>();
 
   @Override public SourceVersion getSupportedSourceVersion() {
@@ -86,7 +91,7 @@
     }
 
     for (Element element : modules) {
-      Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, element);
+      Map<String, Object> annotation = getAnnotation(Module.class, element);
       TypeElement moduleType = (TypeElement) element;
 
       if (annotation.get("complete").equals(Boolean.TRUE)) {
@@ -132,11 +137,12 @@
       boolean ignoreCompletenessErrors) {
     Map<String, TypeElement> allModules = new LinkedHashMap<String, TypeElement>();
     collectIncludesRecursively(rootModule, allModules, new LinkedList<String>());
-    ArrayList<CodeGenStaticInjection> staticInjections = new ArrayList<CodeGenStaticInjection>();
+    ArrayList<GraphAnalysisStaticInjection> staticInjections =
+        new ArrayList<GraphAnalysisStaticInjection>();
 
     Linker.ErrorHandler errorHandler = ignoreCompletenessErrors ? Linker.ErrorHandler.NULL
-        : new ReportingErrorHandler(processingEnv, rootModule.getQualifiedName().toString());
-    Linker linker = new Linker(null, new CompileTimeLoader(processingEnv), errorHandler);
+        : new GraphAnalysisErrorHandler(processingEnv, rootModule.getQualifiedName().toString());
+    Linker linker = new Linker(null, new GraphAnalysisLoader(processingEnv), errorHandler);
     // Linker requires synchronization for calls to requestBinding and linkAll.
     // We know statically that we're single threaded, but we synchronize anyway
     // to make the linker happy.
@@ -144,7 +150,7 @@
       Map<String, Binding<?>> baseBindings = new LinkedHashMap<String, Binding<?>>();
       Map<String, Binding<?>> overrideBindings = new LinkedHashMap<String, Binding<?>>();
       for (TypeElement module : allModules.values()) {
-        Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
+        Map<String, Object> annotation = getAnnotation(Module.class, module);
         boolean overrides = (Boolean) annotation.get("overrides");
         boolean library = (Boolean) annotation.get("library");
         Map<String, Binding<?>> addTo = overrides ? overrideBindings : baseBindings;
@@ -152,7 +158,7 @@
         // Gather the injectable types from the annotation.
         for (Object injectableTypeObject : (Object[]) annotation.get("injects")) {
           TypeMirror injectableType = (TypeMirror) injectableTypeObject;
-          String key = CodeGen.isInterface(injectableType)
+          String key = isInterface(injectableType)
               ? GeneratorKeys.get(injectableType)
               : GeneratorKeys.rawMembersKey(injectableType);
           linker.requestBinding(key, module.getQualifiedName().toString(),
@@ -163,7 +169,7 @@
         for (Object staticInjection : (Object[]) annotation.get("staticInjections")) {
           TypeMirror staticInjectionTypeMirror = (TypeMirror) staticInjection;
           Element element = processingEnv.getTypeUtils().asElement(staticInjectionTypeMirror);
-          staticInjections.add(new CodeGenStaticInjection(element));
+          staticInjections.add(new GraphAnalysisStaticInjection(element));
         }
 
         // Gather the enclosed @Provides methods.
@@ -208,7 +214,7 @@
 
       linker.installBindings(baseBindings);
       linker.installBindings(overrideBindings);
-      for (CodeGenStaticInjection staticInjection : staticInjections) {
+      for (GraphAnalysisStaticInjection staticInjection : staticInjections) {
         staticInjection.attach(linker);
       }
 
@@ -225,7 +231,7 @@
 
   void collectIncludesRecursively(
       TypeElement module, Map<String, TypeElement> result, Deque<String> path) {
-    Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
+    Map<String, Object> annotation = getAnnotation(Module.class, module);
     if (annotation == null) {
       // TODO(tbroyer): pass annotation information
       throw new ModuleValidationException("No @Module on " + module, module);
@@ -253,7 +259,7 @@
     result.put(name, module);
 
     // Recurse for each included module.
-    Types typeUtils = processingEnv.getTypeUtils();
+    Types types = processingEnv.getTypeUtils();
     List<Object> seedModules = new ArrayList<Object>();
     seedModules.addAll(Arrays.asList((Object[]) annotation.get("includes")));
     if (!annotation.get("addsTo").equals(Void.class)) seedModules.add(annotation.get("addsTo"));
@@ -264,7 +270,7 @@
             "Unexpected value for include: " + include + " in " + module, module);
         continue;
       }
-      TypeElement includedModule = (TypeElement) typeUtils.asElement((TypeMirror) include);
+      TypeElement includedModule = (TypeElement) types.asElement((TypeMirror) include);
       path.push(name);
       collectIncludesRecursively(includedModule, result, path);
       path.pop();
@@ -276,8 +282,7 @@
     private final Binding<?>[] parameters;
 
     protected ProviderMethodBinding(String provideKey, ExecutableElement method, boolean library) {
-      super(provideKey, null, method.getAnnotation(Singleton.class) != null,
-          CodeGen.methodName(method));
+      super(provideKey, null, method.getAnnotation(Singleton.class) != null, methodName(method));
       this.method = method;
       this.parameters = new Binding[method.getParameters().size()];
       setLibrary(library);
@@ -307,12 +312,12 @@
 
   void writeDotFile(TypeElement module, Map<String, Binding<?>> bindings) throws IOException {
     JavaFileManager.Location location = StandardLocation.SOURCE_OUTPUT;
-    String path = CodeGen.getPackage(module).getQualifiedName().toString();
+    String path = getPackage(module).getQualifiedName().toString();
     String file = module.getQualifiedName().toString().substring(path.length() + 1) + ".dot";
     FileObject resource = processingEnv.getFiler().createResource(location, path, file, module);
 
     Writer writer = resource.openWriter();
-    DotWriter dotWriter = new DotWriter(writer);
+    GraphVizWriter dotWriter = new GraphVizWriter(writer);
     new GraphVisualizer().write(bindings, dotWriter);
     dotWriter.close();
   }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeGenStaticInjection.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisStaticInjection.java
similarity index 83%
rename from compiler/src/main/java/dagger/internal/codegen/CodeGenStaticInjection.java
rename to compiler/src/main/java/dagger/internal/codegen/GraphAnalysisStaticInjection.java
index 8615319..5f4b96a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeGenStaticInjection.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisStaticInjection.java
@@ -20,17 +20,19 @@
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 
-public final class CodeGenStaticInjection extends StaticInjection {
+import static dagger.internal.codegen.TypeUtils.isStatic;
+
+public final class GraphAnalysisStaticInjection extends StaticInjection {
 
   private final Element enclosingClass;
 
-  public CodeGenStaticInjection(Element enclosingClass) {
+  public GraphAnalysisStaticInjection(Element enclosingClass) {
     this.enclosingClass = enclosingClass;
   }
 
   @Override public void attach(Linker linker) {
     for (Element enclosedElement : enclosingClass.getEnclosedElements()) {
-      if (enclosedElement.getKind().isField() && CodeGen.isStatic(enclosedElement)) {
+      if (enclosedElement.getKind().isField() && isStatic(enclosedElement)) {
         Inject injectAnnotation = enclosedElement.getAnnotation(Inject.class);
         if (injectAnnotation != null) {
           String key = GeneratorKeys.get(enclosedElement.asType());
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
index 8d8070b..a9a90fe 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
@@ -42,7 +42,7 @@
       + "((\\[\\])*)"     // Arrays. Group 4.
       + "");
 
-  public void write(Map<String, Binding<?>> bindings, DotWriter writer) throws IOException {
+  public void write(Map<String, Binding<?>> bindings, GraphVizWriter writer) throws IOException {
     Map<Binding<?>, String> namesIndex = buildNamesIndex(bindings);
 
     writer.beginGraph("concentrate", "true");
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/DotWriter.java b/compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java
similarity index 97%
rename from compiler/src/main/java/dagger/internal/codegen/DotWriter.java
rename to compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java
index 51b7978..519309e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DotWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java
@@ -25,7 +25,7 @@
 /**
  * Emits dot graphs.
  */
-public final class DotWriter implements Closeable {
+public final class GraphVizWriter implements Closeable {
   private static final String INDENT = "  ";
   private final Writer out;
   private int indent = 0;
@@ -36,7 +36,7 @@
    * @param out the stream to which dot data will be written. This should be a
    *     buffered stream.
    */
-  public DotWriter(Writer out) {
+  public GraphVizWriter(Writer out) {
     this.out = out;
   }
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
similarity index 88%
rename from compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
rename to compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
index 4ab1a8d..1c61996 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
@@ -22,6 +22,7 @@
 import dagger.internal.StaticInjection;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
@@ -45,8 +46,14 @@
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
-import static dagger.internal.codegen.CodeGen.typeToString;
-import static dagger.internal.codegen.ProcessorJavadocs.binderTypeDocs;
+import static dagger.internal.codegen.AdapterJavadocs.binderTypeDocs;
+import static dagger.internal.codegen.TypeUtils.adapterName;
+import static dagger.internal.codegen.TypeUtils.getApplicationSupertype;
+import static dagger.internal.codegen.TypeUtils.getNoArgsConstructor;
+import static dagger.internal.codegen.TypeUtils.getPackage;
+import static dagger.internal.codegen.TypeUtils.isCallableConstructor;
+import static dagger.internal.codegen.TypeUtils.rawTypeToString;
+import static dagger.internal.codegen.TypeUtils.typeToString;
 import static dagger.internal.loaders.generated.GeneratedAdapterLoader.INJECT_ADAPTER_SUFFIX;
 import static dagger.internal.loaders.generated.GeneratedAdapterLoader.STATIC_INJECTION_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
@@ -58,7 +65,7 @@
  * {@literal @}{@code Inject}-annotated members of a class.
  */
 @SupportedAnnotationTypes("javax.inject.Inject")
-public final class InjectProcessor extends AbstractProcessor {
+public final class InjectAdapterProcessor extends AbstractProcessor {
   private final Set<String> remainingTypeNames = new LinkedHashSet<String>();
 
   @Override public SourceVersion getSupportedSourceVersion() {
@@ -120,7 +127,7 @@
       if (!validateInjectable(element)) {
         continue;
       }
-      injectedTypeNames.add(CodeGen.rawTypeToString(element.getEnclosingElement().asType(), '.'));
+      injectedTypeNames.add(rawTypeToString(element.getEnclosingElement().asType(), '.'));
     }
     return injectedTypeNames;
   }
@@ -196,8 +203,8 @@
     }
 
     if (constructor == null && !isAbstract) {
-      constructor = CodeGen.getNoArgsConstructor(type);
-      if (constructor != null && !CodeGen.isCallableConstructor(constructor)) {
+      constructor = getNoArgsConstructor(type);
+      if (constructor != null && !isCallableConstructor(constructor)) {
         constructor = null;
       }
     }
@@ -218,10 +225,10 @@
    */
   private void writeInjectAdapter(TypeElement type, ExecutableElement constructor,
       List<Element> fields) throws IOException {
-    String packageName = CodeGen.getPackage(type).getQualifiedName().toString();
+    String packageName = getPackage(type).getQualifiedName().toString();
     String strippedTypeName = strippedTypeName(type.getQualifiedName().toString(), packageName);
-    TypeMirror supertype = CodeGen.getApplicationSupertype(type);
-    String adapterName = CodeGen.adapterName(type, INJECT_ADAPTER_SUFFIX);
+    TypeMirror supertype = getApplicationSupertype(type);
+    String adapterName = adapterName(type, INJECT_ADAPTER_SUFFIX);
     JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(adapterName, type);
     JavaWriter writer = new JavaWriter(sourceFile.openWriter());
     boolean isAbstract = type.getModifiers().contains(Modifier.ABSTRACT);
@@ -232,7 +239,7 @@
     boolean dependent = injectMembers
         || ((constructor != null) && !constructor.getParameters().isEmpty());
 
-    writer.emitEndOfLineComment(ProcessorJavadocs.GENERATED_BY_DAGGER);
+    writer.emitEndOfLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
     writer.emitPackage(packageName);
     writer.emitEmptyLine();
     writer.emitImports(getImports(dependent, injectMembers, constructor != null));
@@ -246,18 +253,18 @@
     if (constructor != null) {
       for (VariableElement parameter : constructor.getParameters()) {
         writer.emitField(JavaWriter.type(Binding.class,
-            CodeGen.typeToString(parameter.asType())),
+            typeToString(parameter.asType())),
             parameterName(disambiguateFields, parameter), PRIVATE);
       }
     }
     for (Element field : fields) {
       writer.emitField(JavaWriter.type(Binding.class,
-          CodeGen.typeToString(field.asType())),
+          typeToString(field.asType())),
           fieldName(disambiguateFields, field), PRIVATE);
     }
     if (supertype != null) {
       writer.emitField(JavaWriter.type(Binding.class,
-          CodeGen.rawTypeToString(supertype, '.')), "supertype", PRIVATE);
+          rawTypeToString(supertype, '.')), "supertype", PRIVATE);
     }
 
     writer.emitEmptyLine();
@@ -272,7 +279,7 @@
     writer.endMethod();
     if (dependent) {
       writer.emitEmptyLine();
-      writer.emitJavadoc(ProcessorJavadocs.ATTACH_METHOD);
+      writer.emitJavadoc(AdapterJavadocs.ATTACH_METHOD);
       writer.emitAnnotation(Override.class);
       writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
       writer.beginMethod("void", "attach", PUBLIC, Linker.class.getCanonicalName(), "linker");
@@ -299,15 +306,14 @@
             "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader()"
                 + ", false, true)", // Yep.  This is a dumb line-length violation otherwise.
             "supertype",
-            writer.compressType(JavaWriter.type(Binding.class,
-                CodeGen.rawTypeToString(supertype, '.'))),
+            writer.compressType(JavaWriter.type(Binding.class, rawTypeToString(supertype, '.'))),
             JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(supertype)),
             strippedTypeName);
       }
       writer.endMethod();
 
       writer.emitEmptyLine();
-      writer.emitJavadoc(ProcessorJavadocs.GET_DEPENDENCIES_METHOD);
+      writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
       writer.emitAnnotation(Override.class);
       String setOfBindings = JavaWriter.type(Set.class, "Binding<?>");
       writer.beginMethod("void", "getDependencies", PUBLIC, setOfBindings, "getBindings",
@@ -328,7 +334,7 @@
 
     if (constructor != null) {
       writer.emitEmptyLine();
-      writer.emitJavadoc(ProcessorJavadocs.GET_METHOD, strippedTypeName);
+      writer.emitJavadoc(AdapterJavadocs.GET_METHOD, strippedTypeName);
       writer.emitAnnotation(Override.class);
       writer.beginMethod(strippedTypeName, "get", PUBLIC);
       StringBuilder newInstance = new StringBuilder();
@@ -351,7 +357,7 @@
 
     if (injectMembers) {
       writer.emitEmptyLine();
-      writer.emitJavadoc(ProcessorJavadocs.MEMBERS_INJECT_METHOD, strippedTypeName);
+      writer.emitJavadoc(AdapterJavadocs.MEMBERS_INJECT_METHOD, strippedTypeName);
       writer.emitAnnotation(Override.class);
       writer.beginMethod("void", "injectMembers", PUBLIC, strippedTypeName, "object");
       for (Element field : fields) {
@@ -400,33 +406,32 @@
    */
   private void writeStaticInjection(TypeElement type, List<Element> fields) throws IOException {
     String typeName = type.getQualifiedName().toString();
-    String adapterName = CodeGen.adapterName(type, STATIC_INJECTION_SUFFIX);
+    String adapterName = adapterName(type, STATIC_INJECTION_SUFFIX);
     JavaFileObject sourceFile = processingEnv.getFiler()
         .createSourceFile(adapterName, type);
     JavaWriter writer = new JavaWriter(sourceFile.openWriter());
 
-    writer.emitEndOfLineComment(ProcessorJavadocs.GENERATED_BY_DAGGER);
-    writer.emitPackage(CodeGen.getPackage(type).getQualifiedName().toString());
+    writer.emitEndOfLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
+    writer.emitPackage(getPackage(type).getQualifiedName().toString());
 
     writer.emitEmptyLine();
-    writer.emitImports(CodeGen.setOf(
+    writer.emitImports(Arrays.asList(
         StaticInjection.class.getName(),
         Binding.class.getName(),
         Linker.class.getName()));
 
     writer.emitEmptyLine();
 
-    writer.emitJavadoc(ProcessorJavadocs.STATIC_INJECTION_TYPE, type.getSimpleName());
+    writer.emitJavadoc(AdapterJavadocs.STATIC_INJECTION_TYPE, type.getSimpleName());
     writer.beginType(adapterName, "class", PUBLIC | FINAL, StaticInjection.class.getSimpleName());
 
     for (Element field : fields) {
-      writer.emitField(JavaWriter.type(Binding.class,
-          CodeGen.typeToString(field.asType())),
+      writer.emitField(JavaWriter.type(Binding.class, typeToString(field.asType())),
           fieldName(false, field), PRIVATE);
     }
 
     writer.emitEmptyLine();
-    writer.emitJavadoc(ProcessorJavadocs.ATTACH_METHOD);
+    writer.emitJavadoc(AdapterJavadocs.ATTACH_METHOD);
     writer.emitAnnotation(Override.class);
     writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
     for (Element field : fields) {
@@ -440,7 +445,7 @@
     writer.endMethod();
 
     writer.emitEmptyLine();
-    writer.emitJavadoc(ProcessorJavadocs.STATIC_INJECT_METHOD);
+    writer.emitJavadoc(AdapterJavadocs.STATIC_INJECT_METHOD);
     writer.emitAnnotation(Override.class);
     writer.beginMethod("void", "inject", PUBLIC);
     for (Element field : fields) {
@@ -477,4 +482,5 @@
       this.fields = fields;
     }
   }
+
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
similarity index 89%
rename from compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
rename to compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 32a9386..bafbe5f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -50,7 +50,14 @@
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
-import static dagger.internal.codegen.ProcessorJavadocs.binderTypeDocs;
+import static dagger.internal.codegen.AdapterJavadocs.binderTypeDocs;
+import static dagger.internal.codegen.TypeUtils.adapterName;
+import static dagger.internal.codegen.TypeUtils.getAnnotation;
+import static dagger.internal.codegen.TypeUtils.getNoArgsConstructor;
+import static dagger.internal.codegen.TypeUtils.getPackage;
+import static dagger.internal.codegen.TypeUtils.isCallableConstructor;
+import static dagger.internal.codegen.TypeUtils.isInterface;
+import static dagger.internal.codegen.TypeUtils.typeToString;
 import static dagger.internal.loaders.generated.GeneratedAdapterLoader.MODULE_ADAPTER_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
 import static java.lang.reflect.Modifier.PRIVATE;
@@ -63,7 +70,7 @@
  * for each {@code @Provides} method of a target class.
  */
 @SupportedAnnotationTypes({ "dagger.Provides", "dagger.Module" })
-public final class ProvidesProcessor extends AbstractProcessor {
+public final class ModuleAdapterProcessor extends AbstractProcessor {
   private final LinkedHashMap<String, List<ExecutableElement>> remainingTypes =
       new LinkedHashMap<String, List<ExecutableElement>>();
   private static final String BINDINGS_MAP = JavaWriter.type(
@@ -82,7 +89,7 @@
       try {
         // Attempt to get the annotation. If types are missing, this will throw
         // IllegalStateException.
-        Map<String, Object> parsedAnnotation = CodeGen.getAnnotation(Module.class, type);
+        Map<String, Object> parsedAnnotation = getAnnotation(Module.class, type);
         try {
           writeModuleAdapter(type, parsedAnnotation, providesTypes);
         } catch (IOException e) {
@@ -109,12 +116,12 @@
    */
   private Map<String, List<ExecutableElement>> providerMethodsByClass(RoundEnvironment env) {
     Elements elementUtils = processingEnv.getElementUtils();
-    Types typeUtils = processingEnv.getTypeUtils();
+    Types types = processingEnv.getTypeUtils();
 
     TypeElement providerElement = elementUtils.getTypeElement("javax.inject.Provider");
-    TypeMirror providerType = typeUtils.erasure(providerElement.asType());
+    TypeMirror providerType = types.erasure(providerElement.asType());
     TypeElement lazyElement = elementUtils.getTypeElement("dagger.Lazy");
-    TypeMirror lazyType = typeUtils.erasure(lazyElement.asType());
+    TypeMirror lazyType = types.erasure(lazyElement.asType());
 
     Map<String, List<ExecutableElement>> result = new HashMap<String, List<ExecutableElement>>();
     for (Element providerMethod : providesMethods(env)) {
@@ -151,15 +158,15 @@
         continue;
       }
 
-      TypeMirror returnType = typeUtils.erasure(providerMethodAsExecutable.getReturnType());
-      if (typeUtils.isSameType(returnType, providerType)) {
+      TypeMirror returnType = types.erasure(providerMethodAsExecutable.getReturnType());
+      if (types.isSameType(returnType, providerType)) {
         error("@Provides method must not return Provider directly: "
             + type.getQualifiedName()
             + "."
             + providerMethod, providerMethod);
         continue;
       }
-      if (typeUtils.isSameType(returnType, lazyType)) {
+      if (types.isSameType(returnType, lazyType)) {
         error("@Provides method must not return Lazy directly: "
             + type.getQualifiedName()
             + "."
@@ -224,7 +231,7 @@
     boolean complete = (Boolean) module.get("complete");
     boolean library = (Boolean) module.get("library");
 
-    String adapterName = CodeGen.adapterName(type, MODULE_ADAPTER_SUFFIX);
+    String adapterName = adapterName(type, MODULE_ADAPTER_SUFFIX);
     JavaFileObject sourceFile = processingEnv.getFiler()
         .createSourceFile(adapterName, type);
     JavaWriter writer = new JavaWriter(sourceFile.openWriter());
@@ -232,22 +239,22 @@
     boolean multibindings = checkForMultibindings(providerMethods);
     boolean providerMethodDependencies = checkForDependencies(providerMethods);
 
-    writer.emitEndOfLineComment(ProcessorJavadocs.GENERATED_BY_DAGGER);
-    writer.emitPackage(CodeGen.getPackage(type).getQualifiedName().toString());
+    writer.emitEndOfLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
+    writer.emitPackage(getPackage(type).getQualifiedName().toString());
     writer.emitEmptyLine();
     writer.emitImports(
         getImports(multibindings, !providerMethods.isEmpty(), providerMethodDependencies));
 
     String typeName = type.getQualifiedName().toString();
     writer.emitEmptyLine();
-    writer.emitJavadoc(ProcessorJavadocs.MODULE_TYPE);
+    writer.emitJavadoc(AdapterJavadocs.MODULE_TYPE);
     writer.beginType(adapterName, "class", PUBLIC | FINAL,
         JavaWriter.type(ModuleAdapter.class, typeName));
 
     StringBuilder injectsField = new StringBuilder().append("{ ");
     for (Object injectableType : injects) {
       TypeMirror typeMirror = (TypeMirror) injectableType;
-      String key = CodeGen.isInterface(typeMirror)
+      String key = isInterface(typeMirror)
           ? GeneratorKeys.get(typeMirror)
           : GeneratorKeys.rawMembersKey(typeMirror);
       injectsField.append(JavaWriter.stringLiteral(key)).append(", ");
@@ -259,7 +266,7 @@
     StringBuilder staticInjectionsField = new StringBuilder().append("{ ");
     for (Object staticInjection : staticInjections) {
       TypeMirror typeMirror = (TypeMirror) staticInjection;
-      staticInjectionsField.append(CodeGen.typeToString(typeMirror)).append(".class, ");
+      staticInjectionsField.append(typeToString(typeMirror)).append(".class, ");
     }
     staticInjectionsField.append("}");
     writer.emitField("Class<?>[]", "STATIC_INJECTIONS", PRIVATE | STATIC | FINAL,
@@ -274,7 +281,7 @@
         continue;
       }
       TypeMirror typeMirror = (TypeMirror) include;
-      includesField.append(CodeGen.typeToString(typeMirror)).append(".class, ");
+      includesField.append(typeToString(typeMirror)).append(".class, ");
     }
     includesField.append("}");
     writer.emitField("Class<?>[]", "INCLUDES", PRIVATE | STATIC | FINAL, includesField.toString());
@@ -285,8 +292,8 @@
         + "INCLUDES, %s /*complete*/, %s /*library*/)", overrides, complete, library);
     writer.endMethod();
 
-    ExecutableElement noArgsConstructor = CodeGen.getNoArgsConstructor(type);
-    if (noArgsConstructor != null && CodeGen.isCallableConstructor(noArgsConstructor)) {
+    ExecutableElement noArgsConstructor = getNoArgsConstructor(type);
+    if (noArgsConstructor != null && isCallableConstructor(noArgsConstructor)) {
       writer.emitEmptyLine();
       writer.emitAnnotation(Override.class);
       writer.beginMethod(typeName, "newModule", PROTECTED);
@@ -300,7 +307,7 @@
 
     if (!providerMethods.isEmpty()) {
       writer.emitEmptyLine();
-      writer.emitJavadoc(ProcessorJavadocs.GET_DEPENDENCIES_METHOD);
+      writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
       writer.emitAnnotation(Override.class);
       writer.beginMethod("void", "getBindings", PUBLIC, BINDINGS_MAP, "map");
 
@@ -399,9 +406,9 @@
       Map<String, AtomicInteger> methodNameToNextId, boolean library)
       throws IOException {
     String methodName = providerMethod.getSimpleName().toString();
-    String moduleType = CodeGen.typeToString(providerMethod.getEnclosingElement().asType());
+    String moduleType = typeToString(providerMethod.getEnclosingElement().asType());
     String className = bindingClassName(providerMethod, methodToClassName, methodNameToNextId);
-    String returnType = CodeGen.typeToString(providerMethod.getReturnType());
+    String returnType = typeToString(providerMethod.getReturnType());
     List<? extends VariableElement> parameters = providerMethod.getParameters();
     boolean dependent = !parameters.isEmpty();
 
@@ -413,8 +420,7 @@
     writer.emitField(moduleType, "module", PRIVATE | FINAL);
     for (Element parameter : parameters) {
       TypeMirror parameterType = parameter.asType();
-      writer.emitField(JavaWriter.type(Binding.class,
-          CodeGen.typeToString(parameterType)),
+      writer.emitField(JavaWriter.type(Binding.class, typeToString(parameterType)),
           parameterName(parameter), PRIVATE);
     }
 
@@ -432,7 +438,7 @@
 
     if (dependent) {
       writer.emitEmptyLine();
-      writer.emitJavadoc(ProcessorJavadocs.ATTACH_METHOD);
+      writer.emitJavadoc(AdapterJavadocs.ATTACH_METHOD);
       writer.emitAnnotation(Override.class);
       writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
       writer.beginMethod("void", "attach", PUBLIC, Linker.class.getCanonicalName(), "linker");
@@ -441,15 +447,14 @@
         writer.emitStatement(
             "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
             parameterName(parameter),
-            writer.compressType(JavaWriter.type(Binding.class,
-                CodeGen.typeToString(parameter.asType()))),
+            writer.compressType(JavaWriter.type(Binding.class, typeToString(parameter.asType()))),
             JavaWriter.stringLiteral(parameterKey),
             writer.compressType(moduleType));
       }
       writer.endMethod();
 
       writer.emitEmptyLine();
-      writer.emitJavadoc(ProcessorJavadocs.GET_DEPENDENCIES_METHOD);
+      writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
       writer.emitAnnotation(Override.class);
       String setOfBindings = JavaWriter.type(Set.class, "Binding<?>");
       writer.beginMethod("void", "getDependencies", PUBLIC, setOfBindings, "getBindings",
@@ -461,7 +466,7 @@
     }
 
     writer.emitEmptyLine();
-    writer.emitJavadoc(ProcessorJavadocs.GET_METHOD, returnType);
+    writer.emitJavadoc(AdapterJavadocs.GET_METHOD, returnType);
     writer.emitAnnotation(Override.class);
     writer.beginMethod(returnType, "get", PUBLIC);
     StringBuilder args = new StringBuilder();
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java b/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
similarity index 96%
rename from compiler/src/main/java/dagger/internal/codegen/CodeGen.java
rename to compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
index d765e80..39e6191 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
@@ -19,10 +19,8 @@
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.AnnotationValueVisitor;
@@ -41,10 +39,10 @@
 import javax.lang.model.util.SimpleTypeVisitor6;
 
 /**
- * Support for annotation processors.
+ * Utilities for handling types in annotation processors
  */
-final class CodeGen {
-  private CodeGen() {
+final class TypeUtils {
+  private TypeUtils() {
   }
 
   public static PackageElement getPackage(Element type) {
@@ -160,7 +158,7 @@
    */
   public static Map<String, Object> getAnnotation(Class<?> annotationType, Element element) {
     for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
-      if (!CodeGen.rawTypeToString(annotation.getAnnotationType(), '$')
+      if (!rawTypeToString(annotation.getAnnotationType(), '$')
           .equals(annotationType.getName())) {
         continue;
       }
@@ -280,15 +278,6 @@
   }
 
   /**
-   * Returns a set comprised of the given items
-   */
-  public static <T> Set<T> setOf(T ... items) {
-    Set<T> set = new LinkedHashSet<T>();
-    set.addAll(Arrays.asList(items));
-    return set;
-  }
-
-  /**
    * Returns a user-presentable string like {@code
    * coffee.CoffeeModule#provideHeater()}.
    */
/Fim/
diff --git a/compiler/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/compiler/src/main/resources/META-INF/services/javax.annotation.processing.Processor
index db38935..dce5a84 100644
--- a/compiler/src/main/resources/META-INF/services/javax.annotation.processing.Processor
+++ b/compiler/src/main/resources/META-INF/services/javax.annotation.processing.Processor
@@ -1,3 +1,3 @@
-dagger.internal.codegen.InjectProcessor
-dagger.internal.codegen.ProvidesProcessor
-dagger.internal.codegen.FullGraphProcessor
\ No newline at end of file
+dagger.internal.codegen.InjectAdapterProcessor
+dagger.internal.codegen.ModuleAdapterProcessor
+dagger.internal.codegen.GraphAnalysisProcessor
\ No newline at end of file
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java
index 69a5be4..e1ce8e2 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java
@@ -26,7 +26,7 @@
 @RunWith(JUnit4.class)
 public final class DotWriterTest {
   private final StringWriter stringWriter = new StringWriter();
-  private final DotWriter dotWriter = new DotWriter(stringWriter);
+  private final GraphVizWriter dotWriter = new GraphVizWriter(stringWriter);
 
   @Test public void graphWithAttributes() throws IOException {
     dotWriter.beginGraph();
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
index d4e073f..dddd6e6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
@@ -69,6 +69,11 @@
         ExecutableElement constructor = (ExecutableElement) enclosed;
         List<? extends VariableElement> parameters = constructor.getParameters();
         if (hasAtInject(enclosed)) {
+          if (hasAtSingleton(enclosed)) {
+            throw new IllegalArgumentException("Singleton annotations have no effect on " +
+                "constructors. Did you mean to annotate the class? " +
+                type.getQualifiedName().toString());
+          }
           if (hasInjectConstructor) {
             throw new IllegalArgumentException("Too many injectable constructors on "
                 + type.getQualifiedName().toString());
@@ -111,6 +116,10 @@
     return enclosed.getAnnotation(Inject.class) != null;
   }
 
+  private static boolean hasAtSingleton(Element enclosed) {
+    return enclosed.getAnnotation(Singleton.class) != null;
+  }
+
   @Override public void attach(Linker linker) {
     String requiredBy = type.getQualifiedName().toString();
     for (int i = 0; i < keys.size(); i++) {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
index dddd6e6..aafa6c7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
@@ -70,9 +70,9 @@
         List<? extends VariableElement> parameters = constructor.getParameters();
         if (hasAtInject(enclosed)) {
           if (hasAtSingleton(enclosed)) {
-            throw new IllegalArgumentException("Singleton annotations have no effect on " +
-                "constructors. Did you mean to annotate the class? " +
-                type.getQualifiedName().toString());
+            throw new IllegalArgumentException("Singleton annotations have no effect on "
+                + "constructors. Did you mean to annotate the class? "
+                + type.getQualifiedName().toString());
           }
           if (hasInjectConstructor) {
             throw new IllegalArgumentException("Too many injectable constructors on "
/Fim/
diff --git a/compiler/src/it/singleton-on-constructor/invoker.properties b/compiler/src/it/singleton-on-constructor/invoker.properties
new file mode 100644
index 0000000..324b5fb
--- /dev/null
+++ b/compiler/src/it/singleton-on-constructor/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
\ No newline at end of file
/Fim/
diff --git a/compiler/src/it/singleton-on-constructor/pom.xml b/compiler/src/it/singleton-on-constructor/pom.xml
new file mode 100644
index 0000000..6b23686
--- /dev/null
+++ b/compiler/src/it/singleton-on-constructor/pom.xml
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Google, Inc.
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>singleton-on-constructor</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/singleton-on-constructor/src/main/java/test/TestApp.java b/compiler/src/it/singleton-on-constructor/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..96b1020
--- /dev/null
+++ b/compiler/src/it/singleton-on-constructor/src/main/java/test/TestApp.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+class TestApp {
+  @Singleton
+  @Inject 
+  public TestApp() { }
+
+  @Module(injects=TestApp.class)
+  static class TestAppModule { }
+}
/Fim/
diff --git a/compiler/src/it/singleton-on-constructor/verify.bsh b/compiler/src/it/singleton-on-constructor/verify.bsh
new file mode 100644
index 0000000..f7751cf
--- /dev/null
+++ b/compiler/src/it/singleton-on-constructor/verify.bsh
@@ -0,0 +1,7 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Singleton annotations have no effect on constructors.",
+    "Did you mean to annotate the class? test.TestApp"});
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
index d4e073f..aafa6c7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
@@ -69,6 +69,11 @@
         ExecutableElement constructor = (ExecutableElement) enclosed;
         List<? extends VariableElement> parameters = constructor.getParameters();
         if (hasAtInject(enclosed)) {
+          if (hasAtSingleton(enclosed)) {
+            throw new IllegalArgumentException("Singleton annotations have no effect on "
+                + "constructors. Did you mean to annotate the class? "
+                + type.getQualifiedName().toString());
+          }
           if (hasInjectConstructor) {
             throw new IllegalArgumentException("Too many injectable constructors on "
                 + type.getQualifiedName().toString());
@@ -111,6 +116,10 @@
     return enclosed.getAnnotation(Inject.class) != null;
   }
 
+  private static boolean hasAtSingleton(Element enclosed) {
+    return enclosed.getAnnotation(Singleton.class) != null;
+  }
+
   @Override public void attach(Linker linker) {
     String requiredBy = type.getQualifiedName().toString();
     for (int i = 0; i < keys.size(); i++) {
/Fim/
diff --git a/.travis.yml b/.travis.yml
index bbfcc54..611369b 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,7 +1,22 @@
 language: java
 
-install: mvn install clean -P!android --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
-script: mvn verify -P!android
+jdk:
+  - oraclejdk7
+  - openjdk7 
+
+before_install:
+  - sudo apt-get update -qq
+  - if [ `uname -m` = x86_64 ]; then sudo apt-get install -qq --force-yes libgd2-xpm ia32-libs ia32-libs-multiarch; fi
+  - wget http://dl.google.com/android/android-sdk_r21.0.1-linux.tgz
+  - echo "Installing android SDK into ${PWD}/android-sdk-linux"
+  - tar -xzf android-sdk_r21.0.1-linux.tgz
+  - export ANDROID_HOME=${PWD}/android-sdk-linux
+  - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
+  - android update sdk --filter platform-tools,android-16,extra-android-support,android-17,sysimg-17 --no-ui --force
+
+install: mvn install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
+
+script: mvn verify 
 
 notifications:
   email: false
/Fim/
diff --git a/.travis.yml b/.travis.yml
index bbfcc54..2420f98 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,7 +1,22 @@
 language: java
 
-install: mvn install clean -P!android --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
-script: mvn verify -P!android
+jdk:
+  - oraclejdk7
+  - openjdk7 
+
+before_install:
+  - sudo apt-get update -qq
+  - if [ `uname -m` = x86_64 ]; then sudo apt-get install -qq --force-yes libgd2-xpm ia32-libs ia32-libs-multiarch; fi
+  - wget http://dl.google.com/android/android-sdk_r21.0.1-linux.tgz
+  - echo "Installing android SDK into ${PWD}/android-sdk-linux"
+  - tar -xzf android-sdk_r21.0.1-linux.tgz
+  - export ANDROID_HOME=${PWD}/android-sdk-linux
+  - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
+  - android update sdk --filter platform-tools,android-16 --no-ui --force
+
+install: mvn install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
+
+script: mvn verify 
 
 notifications:
   email: false
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
index 1c61996..30b2b68 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
@@ -15,6 +15,9 @@
  */
 package dagger.internal.codegen;
 
+import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
+
 import com.squareup.java.JavaWriter;
 import dagger.MembersInjector;
 import dagger.internal.Binding;
@@ -54,8 +57,6 @@
 import static dagger.internal.codegen.TypeUtils.isCallableConstructor;
 import static dagger.internal.codegen.TypeUtils.rawTypeToString;
 import static dagger.internal.codegen.TypeUtils.typeToString;
-import static dagger.internal.loaders.generated.GeneratedAdapterLoader.INJECT_ADAPTER_SUFFIX;
-import static dagger.internal.loaders.generated.GeneratedAdapterLoader.STATIC_INJECTION_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
 import static java.lang.reflect.Modifier.PRIVATE;
 import static java.lang.reflect.Modifier.PUBLIC;
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index bafbe5f..66e18c4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -58,10 +58,9 @@
 import static dagger.internal.codegen.TypeUtils.isCallableConstructor;
 import static dagger.internal.codegen.TypeUtils.isInterface;
 import static dagger.internal.codegen.TypeUtils.typeToString;
-import static dagger.internal.loaders.generated.GeneratedAdapterLoader.MODULE_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
 import static java.lang.reflect.Modifier.PRIVATE;
-import static java.lang.reflect.Modifier.PROTECTED;
 import static java.lang.reflect.Modifier.PUBLIC;
 import static java.lang.reflect.Modifier.STATIC;
 
@@ -296,7 +295,7 @@
     if (noArgsConstructor != null && isCallableConstructor(noArgsConstructor)) {
       writer.emitEmptyLine();
       writer.emitAnnotation(Override.class);
-      writer.beginMethod(typeName, "newModule", PROTECTED);
+      writer.beginMethod(typeName, "newModule", PUBLIC);
       writer.emitStatement("return new %s()", typeName);
       writer.endMethod();
     }
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 1f0d8dd..3e56f2e 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -16,22 +16,22 @@
  */
 package dagger;
 
+import dagger.internal.FailoverLoader;
+
 import dagger.internal.Binding;
 import dagger.internal.Keys;
 import dagger.internal.Linker;
 import dagger.internal.Loader;
 import dagger.internal.ModuleAdapter;
 import dagger.internal.ProblemDetector;
-import dagger.internal.RuntimeAggregatingLoader;
 import dagger.internal.StaticInjection;
 import dagger.internal.ThrowingErrorHandler;
 import dagger.internal.UniqueMap;
-import dagger.internal.loaders.generated.GeneratedAdapterLoader;
-import dagger.internal.loaders.reflect.ReflectiveLoader;
 import java.util.LinkedHashMap;
 import java.util.Map;
 
-import static dagger.internal.RuntimeAggregatingLoader.getAllModuleAdapters;
+import static dagger.internal.Modules.getAllModuleAdapters;
+
 
 /**
  * A graph of objects linked by their dependencies.
@@ -124,13 +124,10 @@
    * the graph at runtime.
    */
   public static ObjectGraph create(Object... modules) {
-    RuntimeAggregatingLoader plugin = new RuntimeAggregatingLoader(
-            new GeneratedAdapterLoader(), new ReflectiveLoader());
-    return DaggerObjectGraph.makeGraph(null, plugin, modules);
+    return DaggerObjectGraph.makeGraph(null, new FailoverLoader(), modules);
   }
 
   static class DaggerObjectGraph extends ObjectGraph {
-
     private final DaggerObjectGraph base;
     private final Linker linker;
     private final Map<Class<?>, StaticInjection> staticInjections;
/Fim/
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
new file mode 100644
index 0000000..c8c16a5
--- /dev/null
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+
+import dagger.internal.loaders.GeneratedAdapters;
+import dagger.internal.loaders.ReflectiveAtInjectBinding;
+import dagger.internal.loaders.ReflectiveModuleAdapter;
+import dagger.internal.loaders.ReflectiveStaticInjection;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Handles loading/finding of modules, injection bindings, and static injections by use of a
+ * strategy of "load the appropriate generaged code" or, if no such code is found, create a
+ * reflective equivalent.
+ */
+public final class FailoverLoader implements Loader {
+  private static final Logger logger = Logger.getLogger(Loader.class.getName());
+
+  /**
+   * Obtains a module adapter for {@code module} from the first responding resolver.
+   */
+  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
+    try {
+      ModuleAdapter<T> result = GeneratedAdapters.initModuleAdapter(type);
+      if (result == null) {
+        result = ReflectiveModuleAdapter.createAdaptor(type);
+      }
+      result.module = (instance == null) ? result.newModule() : instance;
+      return result;
+    } catch (RuntimeException e) {
+      logNotFound("Module adapter", type.getName(), e);
+      throw e;
+    }
+  }
+
+  @Override public Binding<?> getAtInjectBinding(String key, String className,
+      ClassLoader classLoader, boolean mustHaveInjections) {
+    try {
+      Binding<?> result = GeneratedAdapters.initInjectAdapter(className, classLoader);
+      if (result == null) {
+        // A null classloader is the system classloader.
+        classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
+        Class<?> c = classLoader.loadClass(className);
+        if (!c.isInterface()) {
+          result = ReflectiveAtInjectBinding.create(c, mustHaveInjections);
+        }
+      }
+      return result;
+    } catch (ClassNotFoundException e) {
+      throw new RuntimeException("Could not find " + className + " needed for binding " + key, e);
+    } catch (RuntimeException e) {
+      logNotFound("Binding", className, e);
+      throw e;
+    }
+  }
+
+  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
+    try {
+      StaticInjection result = GeneratedAdapters.initStaticInjection(injectedClass);
+      if (result == null) {
+        result = ReflectiveStaticInjection.create(injectedClass);
+      }
+      return result;
+    } catch (RuntimeException e) {
+      logNotFound("Static injection", injectedClass.getName(), e);
+      throw e;
+    }
+  }
+
+  private void logNotFound(String type, String name, RuntimeException e) {
+    if (logger.isLoggable(Level.FINE)) {
+      logger.log(Level.FINE, String.format("Could not initialize a %s for %s.", type, name), e);
+    }
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/Loader.java b/core/src/main/java/dagger/internal/Loader.java
index beb7fde..c2016a5 100644
--- a/core/src/main/java/dagger/internal/Loader.java
+++ b/core/src/main/java/dagger/internal/Loader.java
@@ -23,7 +23,8 @@
  */
 public interface Loader {
   /**
-   * Returns a binding that uses {@code @Inject} annotations.
+   * Returns a binding that uses {@code @Inject} annotations, or null if no valid binding can
+   * be found or created.
    */
   Binding<?> getAtInjectBinding(
       String key, String className, ClassLoader classLoader, boolean mustHaveInjections);
/Fim/
diff --git a/core/src/main/java/dagger/internal/Modules.java b/core/src/main/java/dagger/internal/Modules.java
new file mode 100644
index 0000000..ef994cd
--- /dev/null
+++ b/core/src/main/java/dagger/internal/Modules.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+/**
+ * Static helper for organizing modules.
+ */
+public final class Modules {
+
+  private Modules() { }
+
+  /**
+   * Returns a full set of module adapters, including module adapters for included
+   * modules.
+   */
+  public static Map<Class<?>, ModuleAdapter<?>> getAllModuleAdapters(Loader plugin,
+      Object[] seedModules) {
+    // Create a module adapter for each seed module.
+    ModuleAdapter<?>[] seedAdapters = new ModuleAdapter<?>[seedModules.length];
+    int s = 0;
+    for (Object module : seedModules) {
+      if (module instanceof Class) {
+        seedAdapters[s++] = plugin.getModuleAdapter((Class<?>) module, null); // Loader constructs.
+      } else {
+        seedAdapters[s++] = plugin.getModuleAdapter(module.getClass(), module);
+      }
+    }
+
+    Map<Class<?>, ModuleAdapter<?>> adaptersByModuleType
+        = new LinkedHashMap<Class<?>, ModuleAdapter<?>>();
+
+    // Add the adapters that we have module instances for. This way we won't
+    // construct module objects when we have a user-supplied instance.
+    for (ModuleAdapter<?> adapter : seedAdapters) {
+      adaptersByModuleType.put(adapter.getModule().getClass(), adapter);
+    }
+
+    // Next add adapters for the modules that we need to construct. This creates
+    // instances of modules as necessary.
+    for (ModuleAdapter<?> adapter : seedAdapters) {
+      collectIncludedModulesRecursively(plugin, adapter, adaptersByModuleType);
+    }
+
+    return adaptersByModuleType;
+  }
+
+  /**
+   * Fills {@code result} with the module adapters for the includes of {@code
+   * adapter}, and their includes recursively.
+   */
+  private static void collectIncludedModulesRecursively(Loader plugin, ModuleAdapter<?> adapter,
+      Map<Class<?>, ModuleAdapter<?>> result) {
+    for (Class<?> include : adapter.includes) {
+      if (!result.containsKey(include)) {
+        ModuleAdapter<Object> includedModuleAdapter = plugin.getModuleAdapter(include, null);
+        result.put(include, includedModuleAdapter);
+        collectIncludedModulesRecursively(plugin, includedModuleAdapter, result);
+      }
+    }
+  }
+
+}
/Fim/
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
new file mode 100644
index 0000000..2682da0
--- /dev/null
+++ b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.loaders;
+
+import dagger.internal.Binding;
+import dagger.internal.ModuleAdapter;
+import dagger.internal.StaticInjection;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * A utility for loading and initializing generated adapters.
+ */
+public final class GeneratedAdapters {
+  private static final String SEPARATOR = "$$";
+  public static final String INJECT_ADAPTER_SUFFIX = SEPARATOR + "InjectAdapter";
+  public static final String MODULE_ADAPTER_SUFFIX = SEPARATOR + "ModuleAdapter";
+  public static final String STATIC_INJECTION_SUFFIX = SEPARATOR + "StaticInjection";
+  private static final Logger logger = Logger.getLogger(GeneratedAdapters.class.getName());
+
+  private GeneratedAdapters() { }
+
+  public static <T> ModuleAdapter<T> initModuleAdapter(Class<? extends T> moduleClass) {
+    return instantiate(moduleClass.getName() + MODULE_ADAPTER_SUFFIX, moduleClass.getClassLoader());
+  }
+
+  public static Binding<?> initInjectAdapter(String className, ClassLoader classLoader) {
+    return instantiate(className + INJECT_ADAPTER_SUFFIX, classLoader);
+  }
+
+  public static StaticInjection initStaticInjection(Class<?> injectedClass) {
+    return instantiate(injectedClass.getName() + STATIC_INJECTION_SUFFIX,
+        injectedClass.getClassLoader());
+  }
+
+  private static <T> T instantiate(String name, ClassLoader classLoader) {
+    try {
+      // A null classloader is the system classloader.
+      classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
+      Class<?> generatedClass = classLoader.loadClass(name);
+      Constructor<?> constructor = generatedClass.getDeclaredConstructor();
+      constructor.setAccessible(true);
+      return (T) constructor.newInstance();
+    } catch (ClassNotFoundException e) {
+      if (logger.isLoggable(Level.FINE)) {
+        logger.log(Level.FINE, name + " could not be found.", e);
+      }
+      return null; // Not finding a class is not inherently an error, unlike finding a bad class.
+    } catch (NoSuchMethodException e) {
+      throw new RuntimeException("No default constructor found on " + name, e);
+    } catch (InstantiationException e) {
+      throw new RuntimeException("Failed to initialize " + name, e);
+    } catch (IllegalAccessException e) {
+      throw new RuntimeException("Failed to initialize " + name, e);
+    } catch (InvocationTargetException e) {
+      throw new RuntimeException("Error while initializing " + name, e.getCause());
+    }
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveAtInjectBinding.java b/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
similarity index 98%
rename from core/src/main/java/dagger/internal/loaders/reflect/ReflectiveAtInjectBinding.java
rename to core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
index 1f74c38..ed84a89 100644
--- a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveAtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.loaders.reflect;
+package dagger.internal.loaders;
 
 import dagger.internal.Binding;
 import dagger.internal.Keys;
@@ -35,7 +35,7 @@
  * Injects the {@code @Inject}-annotated fields and constructors of a class
  * using reflection.
  */
-final class ReflectiveAtInjectBinding<T> extends Binding<T> {
+public final class ReflectiveAtInjectBinding<T> extends Binding<T> {
   private final Field[] fields;
   private final ClassLoader loader;
   private final Constructor<T> constructor;
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
similarity index 87%
rename from core/src/main/java/dagger/internal/loaders/reflect/ReflectiveModuleAdapter.java
rename to core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
index 3fce068..1ed3ee9 100644
--- a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.loaders.reflect;
+package dagger.internal.loaders;
 
 import dagger.Lazy;
 import dagger.Module;
@@ -34,7 +34,7 @@
 import javax.inject.Provider;
 import javax.inject.Singleton;
 
-final class ReflectiveModuleAdapter extends ModuleAdapter<Object> {
+public final class ReflectiveModuleAdapter extends ModuleAdapter<Object> {
   final Class<?> moduleClass;
 
   public ReflectiveModuleAdapter(Class<?> moduleClass, Module annotation) {
@@ -60,7 +60,7 @@
   }
 
   @Override public void getBindings(Map<String, Binding<?>> bindings) {
-    for (Class<?> c = moduleClass; c != Object.class; c = c.getSuperclass()) {
+    for (Class<?> c = moduleClass; !c.equals(Object.class); c = c.getSuperclass()) {
       for (Method method : c.getDeclaredMethods()) {
         Provides provides = method.getAnnotation(Provides.class);
         if (provides != null) {
@@ -111,7 +111,7 @@
         library));
   }
 
-  @Override protected Object newModule() {
+  @Override public Object newModule() {
     try {
       Constructor<?> constructor = moduleClass.getDeclaredConstructor();
       constructor.setAccessible(true);
@@ -130,6 +130,22 @@
   }
 
   /**
+   * Creates a ReflectiveModuleAdapter or throws an {@code IllegalArgumentException}.
+   */
+  @SuppressWarnings("unchecked") // Runtime checks validate that the result type matches 'T'.
+  public static <T> ModuleAdapter<T> createAdaptor(Class<? extends T> moduleClass) {
+    Module annotation = moduleClass.getAnnotation(Module.class);
+    if (annotation == null) {
+      throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
+    }
+    if (!moduleClass.getSuperclass().equals(Object.class)) {
+      throw new IllegalArgumentException(
+          "Modules must not extend from other classes: " + moduleClass.getName());
+    }
+    return (ModuleAdapter<T>) new ReflectiveModuleAdapter(moduleClass, annotation);
+  }
+
+  /**
    * Invokes a method to provide a value. The method's parameters are injected.
    */
   private final class ProviderMethodBinding<T> extends Binding<T> {
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveStaticInjection.java b/core/src/main/java/dagger/internal/loaders/ReflectiveStaticInjection.java
similarity index 63%
rename from core/src/main/java/dagger/internal/loaders/reflect/ReflectiveStaticInjection.java
rename to core/src/main/java/dagger/internal/loaders/ReflectiveStaticInjection.java
index df3deb0..1150eed 100644
--- a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveStaticInjection.java
+++ b/core/src/main/java/dagger/internal/loaders/ReflectiveStaticInjection.java
@@ -13,23 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.loaders.reflect;
+package dagger.internal.loaders;
 
 import dagger.internal.Binding;
 import dagger.internal.Keys;
 import dagger.internal.Linker;
 import dagger.internal.StaticInjection;
 import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.List;
+import javax.inject.Inject;
 
 /**
  * Uses reflection to inject the static fields of a class.
  */
-final class ReflectiveStaticInjection extends StaticInjection {
+public final class ReflectiveStaticInjection extends StaticInjection {
   private final ClassLoader loader;
   private final Field[] fields;
   private Binding<?>[] bindings;
 
-  public ReflectiveStaticInjection(ClassLoader loader, Field[] fields) {
+  private ReflectiveStaticInjection(ClassLoader loader, Field[] fields) {
     this.fields = fields;
     this.loader = loader;
   }
@@ -52,4 +56,19 @@
       throw new AssertionError(e);
     }
   }
+
+  public static StaticInjection create(Class<?> injectedClass) {
+    List<Field> fields = new ArrayList<Field>();
+    for (Field field : injectedClass.getDeclaredFields()) {
+      if (Modifier.isStatic(field.getModifiers()) && field.isAnnotationPresent(Inject.class)) {
+        field.setAccessible(true);
+        fields.add(field);
+      }
+    }
+    if (fields.isEmpty()) {
+      throw new IllegalArgumentException("No static injections: " + injectedClass.getName());
+    }
+    return new ReflectiveStaticInjection(injectedClass.getClassLoader(),
+        fields.toArray(new Field[fields.size()]));
+  }
 }
\ No newline at end of file
/Fim/
/Fim/
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
index 1c61996..de890dc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
@@ -54,8 +54,8 @@
 import static dagger.internal.codegen.TypeUtils.isCallableConstructor;
 import static dagger.internal.codegen.TypeUtils.rawTypeToString;
 import static dagger.internal.codegen.TypeUtils.typeToString;
-import static dagger.internal.loaders.generated.GeneratedAdapterLoader.INJECT_ADAPTER_SUFFIX;
-import static dagger.internal.loaders.generated.GeneratedAdapterLoader.STATIC_INJECTION_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
 import static java.lang.reflect.Modifier.PRIVATE;
 import static java.lang.reflect.Modifier.PUBLIC;
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index bafbe5f..66e18c4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -58,10 +58,9 @@
 import static dagger.internal.codegen.TypeUtils.isCallableConstructor;
 import static dagger.internal.codegen.TypeUtils.isInterface;
 import static dagger.internal.codegen.TypeUtils.typeToString;
-import static dagger.internal.loaders.generated.GeneratedAdapterLoader.MODULE_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
 import static java.lang.reflect.Modifier.PRIVATE;
-import static java.lang.reflect.Modifier.PROTECTED;
 import static java.lang.reflect.Modifier.PUBLIC;
 import static java.lang.reflect.Modifier.STATIC;
 
@@ -296,7 +295,7 @@
     if (noArgsConstructor != null && isCallableConstructor(noArgsConstructor)) {
       writer.emitEmptyLine();
       writer.emitAnnotation(Override.class);
-      writer.beginMethod(typeName, "newModule", PROTECTED);
+      writer.beginMethod(typeName, "newModule", PUBLIC);
       writer.emitStatement("return new %s()", typeName);
       writer.endMethod();
     }
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 1f0d8dd..9c62140 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -17,21 +17,20 @@
 package dagger;
 
 import dagger.internal.Binding;
+import dagger.internal.FailoverLoader;
 import dagger.internal.Keys;
 import dagger.internal.Linker;
 import dagger.internal.Loader;
 import dagger.internal.ModuleAdapter;
 import dagger.internal.ProblemDetector;
-import dagger.internal.RuntimeAggregatingLoader;
 import dagger.internal.StaticInjection;
 import dagger.internal.ThrowingErrorHandler;
 import dagger.internal.UniqueMap;
-import dagger.internal.loaders.generated.GeneratedAdapterLoader;
-import dagger.internal.loaders.reflect.ReflectiveLoader;
 import java.util.LinkedHashMap;
 import java.util.Map;
 
-import static dagger.internal.RuntimeAggregatingLoader.getAllModuleAdapters;
+import static dagger.internal.Modules.getAllModuleAdapters;
+
 
 /**
  * A graph of objects linked by their dependencies.
@@ -124,13 +123,10 @@
    * the graph at runtime.
    */
   public static ObjectGraph create(Object... modules) {
-    RuntimeAggregatingLoader plugin = new RuntimeAggregatingLoader(
-            new GeneratedAdapterLoader(), new ReflectiveLoader());
-    return DaggerObjectGraph.makeGraph(null, plugin, modules);
+    return DaggerObjectGraph.makeGraph(null, new FailoverLoader(), modules);
   }
 
   static class DaggerObjectGraph extends ObjectGraph {
-
     private final DaggerObjectGraph base;
     private final Linker linker;
     private final Map<Class<?>, StaticInjection> staticInjections;
/Fim/
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
new file mode 100644
index 0000000..674b259
--- /dev/null
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+
+import dagger.internal.loaders.GeneratedAdapters;
+import dagger.internal.loaders.ReflectiveAtInjectBinding;
+import dagger.internal.loaders.ReflectiveModuleAdapter;
+import dagger.internal.loaders.ReflectiveStaticInjection;
+
+/**
+ * Handles loading/finding of modules, injection bindings, and static injections by use of a
+ * strategy of "load the appropriate generated code" or, if no such code is found, create a
+ * reflective equivalent.
+ */
+public final class FailoverLoader implements Loader {
+
+  /**
+   * Obtains a module adapter for {@code module} from the first responding resolver.
+   */
+  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
+    ModuleAdapter<T> result = GeneratedAdapters.initModuleAdapter(type);
+    if (result == null) {
+      result = ReflectiveModuleAdapter.create(type);
+    }
+    result.module = (instance != null) ? instance : result.newModule();
+    return result;
+  }
+
+  @Override public Binding<?> getAtInjectBinding(String key, String className,
+      ClassLoader classLoader, boolean mustHaveInjections) {
+    try {
+      Binding<?> result = GeneratedAdapters.initInjectAdapter(className, classLoader);
+      if (result == null) {
+        // A null classloader is the system classloader.
+        classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
+        Class<?> c = classLoader.loadClass(className);
+        if (!c.isInterface()) {
+          result = ReflectiveAtInjectBinding.create(c, mustHaveInjections);
+        }
+      }
+      return result;
+    } catch (ClassNotFoundException e) {
+      throw new RuntimeException("Could not find " + className + " needed for binding " + key, e);
+    }
+  }
+
+  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
+    StaticInjection result = GeneratedAdapters.initStaticInjection(injectedClass);
+    if (result == null) {
+      result = ReflectiveStaticInjection.create(injectedClass);
+    }
+    return result;
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/Loader.java b/core/src/main/java/dagger/internal/Loader.java
index beb7fde..c2016a5 100644
--- a/core/src/main/java/dagger/internal/Loader.java
+++ b/core/src/main/java/dagger/internal/Loader.java
@@ -23,7 +23,8 @@
  */
 public interface Loader {
   /**
-   * Returns a binding that uses {@code @Inject} annotations.
+   * Returns a binding that uses {@code @Inject} annotations, or null if no valid binding can
+   * be found or created.
    */
   Binding<?> getAtInjectBinding(
       String key, String className, ClassLoader classLoader, boolean mustHaveInjections);
/Fim/
diff --git a/core/src/main/java/dagger/internal/Modules.java b/core/src/main/java/dagger/internal/Modules.java
new file mode 100644
index 0000000..ef994cd
--- /dev/null
+++ b/core/src/main/java/dagger/internal/Modules.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+/**
+ * Static helper for organizing modules.
+ */
+public final class Modules {
+
+  private Modules() { }
+
+  /**
+   * Returns a full set of module adapters, including module adapters for included
+   * modules.
+   */
+  public static Map<Class<?>, ModuleAdapter<?>> getAllModuleAdapters(Loader plugin,
+      Object[] seedModules) {
+    // Create a module adapter for each seed module.
+    ModuleAdapter<?>[] seedAdapters = new ModuleAdapter<?>[seedModules.length];
+    int s = 0;
+    for (Object module : seedModules) {
+      if (module instanceof Class) {
+        seedAdapters[s++] = plugin.getModuleAdapter((Class<?>) module, null); // Loader constructs.
+      } else {
+        seedAdapters[s++] = plugin.getModuleAdapter(module.getClass(), module);
+      }
+    }
+
+    Map<Class<?>, ModuleAdapter<?>> adaptersByModuleType
+        = new LinkedHashMap<Class<?>, ModuleAdapter<?>>();
+
+    // Add the adapters that we have module instances for. This way we won't
+    // construct module objects when we have a user-supplied instance.
+    for (ModuleAdapter<?> adapter : seedAdapters) {
+      adaptersByModuleType.put(adapter.getModule().getClass(), adapter);
+    }
+
+    // Next add adapters for the modules that we need to construct. This creates
+    // instances of modules as necessary.
+    for (ModuleAdapter<?> adapter : seedAdapters) {
+      collectIncludedModulesRecursively(plugin, adapter, adaptersByModuleType);
+    }
+
+    return adaptersByModuleType;
+  }
+
+  /**
+   * Fills {@code result} with the module adapters for the includes of {@code
+   * adapter}, and their includes recursively.
+   */
+  private static void collectIncludedModulesRecursively(Loader plugin, ModuleAdapter<?> adapter,
+      Map<Class<?>, ModuleAdapter<?>> result) {
+    for (Class<?> include : adapter.includes) {
+      if (!result.containsKey(include)) {
+        ModuleAdapter<Object> includedModuleAdapter = plugin.getModuleAdapter(include, null);
+        result.put(include, includedModuleAdapter);
+        collectIncludedModulesRecursively(plugin, includedModuleAdapter, result);
+      }
+    }
+  }
+
+}
/Fim/
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
new file mode 100644
index 0000000..2682da0
--- /dev/null
+++ b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.loaders;
+
+import dagger.internal.Binding;
+import dagger.internal.ModuleAdapter;
+import dagger.internal.StaticInjection;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * A utility for loading and initializing generated adapters.
+ */
+public final class GeneratedAdapters {
+  private static final String SEPARATOR = "$$";
+  public static final String INJECT_ADAPTER_SUFFIX = SEPARATOR + "InjectAdapter";
+  public static final String MODULE_ADAPTER_SUFFIX = SEPARATOR + "ModuleAdapter";
+  public static final String STATIC_INJECTION_SUFFIX = SEPARATOR + "StaticInjection";
+  private static final Logger logger = Logger.getLogger(GeneratedAdapters.class.getName());
+
+  private GeneratedAdapters() { }
+
+  public static <T> ModuleAdapter<T> initModuleAdapter(Class<? extends T> moduleClass) {
+    return instantiate(moduleClass.getName() + MODULE_ADAPTER_SUFFIX, moduleClass.getClassLoader());
+  }
+
+  public static Binding<?> initInjectAdapter(String className, ClassLoader classLoader) {
+    return instantiate(className + INJECT_ADAPTER_SUFFIX, classLoader);
+  }
+
+  public static StaticInjection initStaticInjection(Class<?> injectedClass) {
+    return instantiate(injectedClass.getName() + STATIC_INJECTION_SUFFIX,
+        injectedClass.getClassLoader());
+  }
+
+  private static <T> T instantiate(String name, ClassLoader classLoader) {
+    try {
+      // A null classloader is the system classloader.
+      classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
+      Class<?> generatedClass = classLoader.loadClass(name);
+      Constructor<?> constructor = generatedClass.getDeclaredConstructor();
+      constructor.setAccessible(true);
+      return (T) constructor.newInstance();
+    } catch (ClassNotFoundException e) {
+      if (logger.isLoggable(Level.FINE)) {
+        logger.log(Level.FINE, name + " could not be found.", e);
+      }
+      return null; // Not finding a class is not inherently an error, unlike finding a bad class.
+    } catch (NoSuchMethodException e) {
+      throw new RuntimeException("No default constructor found on " + name, e);
+    } catch (InstantiationException e) {
+      throw new RuntimeException("Failed to initialize " + name, e);
+    } catch (IllegalAccessException e) {
+      throw new RuntimeException("Failed to initialize " + name, e);
+    } catch (InvocationTargetException e) {
+      throw new RuntimeException("Error while initializing " + name, e.getCause());
+    }
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveAtInjectBinding.java b/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
similarity index 98%
rename from core/src/main/java/dagger/internal/loaders/reflect/ReflectiveAtInjectBinding.java
rename to core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
index 1f74c38..ed84a89 100644
--- a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveAtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.loaders.reflect;
+package dagger.internal.loaders;
 
 import dagger.internal.Binding;
 import dagger.internal.Keys;
@@ -35,7 +35,7 @@
  * Injects the {@code @Inject}-annotated fields and constructors of a class
  * using reflection.
  */
-final class ReflectiveAtInjectBinding<T> extends Binding<T> {
+public final class ReflectiveAtInjectBinding<T> extends Binding<T> {
   private final Field[] fields;
   private final ClassLoader loader;
   private final Constructor<T> constructor;
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
similarity index 87%
rename from core/src/main/java/dagger/internal/loaders/reflect/ReflectiveModuleAdapter.java
rename to core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
index 3fce068..1bb36f7 100644
--- a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.loaders.reflect;
+package dagger.internal.loaders;
 
 import dagger.Lazy;
 import dagger.Module;
@@ -34,7 +34,7 @@
 import javax.inject.Provider;
 import javax.inject.Singleton;
 
-final class ReflectiveModuleAdapter extends ModuleAdapter<Object> {
+public final class ReflectiveModuleAdapter extends ModuleAdapter<Object> {
   final Class<?> moduleClass;
 
   public ReflectiveModuleAdapter(Class<?> moduleClass, Module annotation) {
@@ -60,7 +60,7 @@
   }
 
   @Override public void getBindings(Map<String, Binding<?>> bindings) {
-    for (Class<?> c = moduleClass; c != Object.class; c = c.getSuperclass()) {
+    for (Class<?> c = moduleClass; !c.equals(Object.class); c = c.getSuperclass()) {
       for (Method method : c.getDeclaredMethods()) {
         Provides provides = method.getAnnotation(Provides.class);
         if (provides != null) {
@@ -111,7 +111,7 @@
         library));
   }
 
-  @Override protected Object newModule() {
+  @Override public Object newModule() {
     try {
       Constructor<?> constructor = moduleClass.getDeclaredConstructor();
       constructor.setAccessible(true);
@@ -130,6 +130,22 @@
   }
 
   /**
+   * Creates a ReflectiveModuleAdapter or throws an {@code IllegalArgumentException}.
+   */
+  @SuppressWarnings("unchecked") // Runtime checks validate that the result type matches 'T'.
+  public static <T> ModuleAdapter<T> create(Class<? extends T> moduleClass) {
+    Module annotation = moduleClass.getAnnotation(Module.class);
+    if (annotation == null) {
+      throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
+    }
+    if (!moduleClass.getSuperclass().equals(Object.class)) {
+      throw new IllegalArgumentException(
+          "Modules must not extend from other classes: " + moduleClass.getName());
+    }
+    return (ModuleAdapter<T>) new ReflectiveModuleAdapter(moduleClass, annotation);
+  }
+
+  /**
    * Invokes a method to provide a value. The method's parameters are injected.
    */
   private final class ProviderMethodBinding<T> extends Binding<T> {
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveStaticInjection.java b/core/src/main/java/dagger/internal/loaders/ReflectiveStaticInjection.java
similarity index 63%
rename from core/src/main/java/dagger/internal/loaders/reflect/ReflectiveStaticInjection.java
rename to core/src/main/java/dagger/internal/loaders/ReflectiveStaticInjection.java
index df3deb0..1150eed 100644
--- a/core/src/main/java/dagger/internal/loaders/reflect/ReflectiveStaticInjection.java
+++ b/core/src/main/java/dagger/internal/loaders/ReflectiveStaticInjection.java
@@ -13,23 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.loaders.reflect;
+package dagger.internal.loaders;
 
 import dagger.internal.Binding;
 import dagger.internal.Keys;
 import dagger.internal.Linker;
 import dagger.internal.StaticInjection;
 import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.List;
+import javax.inject.Inject;
 
 /**
  * Uses reflection to inject the static fields of a class.
  */
-final class ReflectiveStaticInjection extends StaticInjection {
+public final class ReflectiveStaticInjection extends StaticInjection {
   private final ClassLoader loader;
   private final Field[] fields;
   private Binding<?>[] bindings;
 
-  public ReflectiveStaticInjection(ClassLoader loader, Field[] fields) {
+  private ReflectiveStaticInjection(ClassLoader loader, Field[] fields) {
     this.fields = fields;
     this.loader = loader;
   }
@@ -52,4 +56,19 @@
       throw new AssertionError(e);
     }
   }
+
+  public static StaticInjection create(Class<?> injectedClass) {
+    List<Field> fields = new ArrayList<Field>();
+    for (Field field : injectedClass.getDeclaredFields()) {
+      if (Modifier.isStatic(field.getModifiers()) && field.isAnnotationPresent(Inject.class)) {
+        field.setAccessible(true);
+        fields.add(field);
+      }
+    }
+    if (fields.isEmpty()) {
+      throw new IllegalArgumentException("No static injections: " + injectedClass.getName());
+    }
+    return new ReflectiveStaticInjection(injectedClass.getClassLoader(),
+        fields.toArray(new Field[fields.size()]));
+  }
 }
\ No newline at end of file
/Fim/
/Fim/
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 9c62140..1fe64b4 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -126,6 +126,11 @@
     return DaggerObjectGraph.makeGraph(null, new FailoverLoader(), modules);
   }
 
+  // visible for testing
+  static ObjectGraph createWith(Loader loader, Object... modules) {
+    return DaggerObjectGraph.makeGraph(null, loader, modules);
+  }
+
   static class DaggerObjectGraph extends ObjectGraph {
     private final DaggerObjectGraph base;
     private final Linker linker;
/Fim/
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
index 674b259..877fb0d 100644
--- a/core/src/main/java/dagger/internal/FailoverLoader.java
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -19,7 +19,6 @@
 
 import dagger.internal.loaders.GeneratedAdapters;
 import dagger.internal.loaders.ReflectiveAtInjectBinding;
-import dagger.internal.loaders.ReflectiveModuleAdapter;
 import dagger.internal.loaders.ReflectiveStaticInjection;
 
 /**
@@ -33,37 +32,40 @@
    * Obtains a module adapter for {@code module} from the first responding resolver.
    */
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
-    ModuleAdapter<T> result = GeneratedAdapters.initModuleAdapter(type);
-    if (result == null) {
-      result = ReflectiveModuleAdapter.create(type);
+    try {
+      ModuleAdapter<T> result = GeneratedAdapters.initModuleAdapter(type);
+      result.module = (instance != null) ? instance : result.newModule();
+      return result;
+    } catch (ClassNotFoundException e) {
+      throw new TypeNotPresentException(type + GeneratedAdapters.MODULE_ADAPTER_SUFFIX, e);
     }
-    result.module = (instance != null) ? instance : result.newModule();
-    return result;
   }
 
   @Override public Binding<?> getAtInjectBinding(String key, String className,
       ClassLoader classLoader, boolean mustHaveInjections) {
-    try {
-      Binding<?> result = GeneratedAdapters.initInjectAdapter(className, classLoader);
-      if (result == null) {
-        // A null classloader is the system classloader.
-        classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
-        Class<?> c = classLoader.loadClass(className);
-        if (!c.isInterface()) {
-          result = ReflectiveAtInjectBinding.create(c, mustHaveInjections);
+      try {
+        return GeneratedAdapters.initInjectAdapter(className, classLoader);
+      } catch (ClassNotFoundException ignored) {
+        try {
+          // A null classloader is the system classloader.
+          classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
+          Class<?> type = classLoader.loadClass(className);
+          if (!type.isInterface()) {
+            return null; // Short-circuit since we can't build reflective bindings for interfaces.
+          }
+          return ReflectiveAtInjectBinding.create(type, mustHaveInjections);
+        } catch (ClassNotFoundException e) {
+          throw new TypeNotPresentException(
+              String.format("Could not find %s needed for binding %s", className, key), e);
         }
       }
-      return result;
-    } catch (ClassNotFoundException e) {
-      throw new RuntimeException("Could not find " + className + " needed for binding " + key, e);
-    }
   }
 
   @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    StaticInjection result = GeneratedAdapters.initStaticInjection(injectedClass);
-    if (result == null) {
-      result = ReflectiveStaticInjection.create(injectedClass);
+    try {
+      return GeneratedAdapters.initStaticInjection(injectedClass);
+    } catch (ClassNotFoundException ignored) {
+      return ReflectiveStaticInjection.create(injectedClass);
     }
-    return result;
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Loader.java b/core/src/main/java/dagger/internal/Loader.java
index c2016a5..1d2d10f 100644
--- a/core/src/main/java/dagger/internal/Loader.java
+++ b/core/src/main/java/dagger/internal/Loader.java
@@ -30,7 +30,8 @@
       String key, String className, ClassLoader classLoader, boolean mustHaveInjections);
 
   /**
-   * Returns a module adapter for {@code module}.
+   * Returns a module adapter for {@code module} or throws a {@code TypeNotPresentException} if
+   * none can be found.
    */
   <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module);
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
index 2682da0..0907ad0 100644
--- a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
+++ b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
@@ -21,7 +21,6 @@
 import dagger.internal.StaticInjection;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
-import java.util.logging.Level;
 import java.util.logging.Logger;
 
 /**
@@ -36,20 +35,24 @@
 
   private GeneratedAdapters() { }
 
-  public static <T> ModuleAdapter<T> initModuleAdapter(Class<? extends T> moduleClass) {
+  public static <T> ModuleAdapter<T> initModuleAdapter(Class<? extends T> moduleClass)
+      throws ClassNotFoundException {
     return instantiate(moduleClass.getName() + MODULE_ADAPTER_SUFFIX, moduleClass.getClassLoader());
   }
 
-  public static Binding<?> initInjectAdapter(String className, ClassLoader classLoader) {
+  public static Binding<?> initInjectAdapter(String className, ClassLoader classLoader)
+      throws ClassNotFoundException {
     return instantiate(className + INJECT_ADAPTER_SUFFIX, classLoader);
   }
 
-  public static StaticInjection initStaticInjection(Class<?> injectedClass) {
+  public static StaticInjection initStaticInjection(Class<?> injectedClass)
+      throws ClassNotFoundException {
     return instantiate(injectedClass.getName() + STATIC_INJECTION_SUFFIX,
         injectedClass.getClassLoader());
   }
 
-  private static <T> T instantiate(String name, ClassLoader classLoader) {
+  private static <T> T instantiate(String name, ClassLoader classLoader)
+      throws ClassNotFoundException {
     try {
       // A null classloader is the system classloader.
       classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
@@ -57,11 +60,6 @@
       Constructor<?> constructor = generatedClass.getDeclaredConstructor();
       constructor.setAccessible(true);
       return (T) constructor.newInstance();
-    } catch (ClassNotFoundException e) {
-      if (logger.isLoggable(Level.FINE)) {
-        logger.log(Level.FINE, name + " could not be found.", e);
-      }
-      return null; // Not finding a class is not inherently an error, unlike finding a bad class.
     } catch (NoSuchMethodException e) {
       throw new RuntimeException("No default constructor found on " + name, e);
     } catch (InstantiationException e) {
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionTest.java b/core/src/test/java/dagger/ExtensionTest.java
index f688f2d..06f9b86 100644
--- a/core/src/test/java/dagger/ExtensionTest.java
+++ b/core/src/test/java/dagger/ExtensionTest.java
@@ -16,6 +16,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import java.util.Arrays;
 import javax.inject.Inject;
 import javax.inject.Singleton;
@@ -55,11 +56,12 @@
   static class ExtensionModule { }
 
   @Test public void basicExtension() {
-    assertNotNull(ObjectGraph.create(new RootModule()).plus(new ExtensionModule()));
+    assertNotNull(ObjectGraph.createWith(new TestingLoader(), new RootModule())
+        .plus(new ExtensionModule()));
   }
 
   @Test public void basicInjection() {
-    ObjectGraph root = ObjectGraph.create(new RootModule());
+    ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule());
     assertThat(root.get(A.class)).isNotNull();
     assertThat(root.get(A.class)).isSameAs(root.get(A.class)); // Present and Singleton.
     assertThat(root.get(B.class)).isNotSameAs(root.get(B.class)); // Not singleton.
@@ -77,7 +79,7 @@
   }
 
   @Test public void scopedGraphs() {
-    ObjectGraph app = ObjectGraph.create(new RootModule());
+    ObjectGraph app = ObjectGraph.createWith(new TestingLoader(), new RootModule());
     assertThat(app.get(A.class)).isNotNull();
     assertThat(app.get(A.class)).isSameAs(app.get(A.class));
     assertThat(app.get(B.class)).isNotSameAs(app.get(B.class));
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionWithStateTest.java b/core/src/test/java/dagger/ExtensionWithStateTest.java
index da2f7ac..ff35e2a 100644
--- a/core/src/test/java/dagger/ExtensionWithStateTest.java
+++ b/core/src/test/java/dagger/ExtensionWithStateTest.java
@@ -16,6 +16,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import javax.inject.Inject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -48,7 +49,7 @@
 
   @Test public void basicInjectionWithExtension() {
     A a = new A();
-    ObjectGraph root = ObjectGraph.create(new RootModule(a));
+    ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule(a));
     assertThat(root.get(A.class)).isSameAs(a);
 
     // Extension graph behaves as the root graph would for root-ish things.
/Fim/
diff --git a/core/src/test/java/dagger/InjectStaticsTest.java b/core/src/test/java/dagger/InjectStaticsTest.java
index 0421b1e..a19456b 100644
--- a/core/src/test/java/dagger/InjectStaticsTest.java
+++ b/core/src/test/java/dagger/InjectStaticsTest.java
@@ -15,6 +15,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import javax.inject.Inject;
 import org.junit.Before;
 import org.junit.Test;
@@ -47,7 +48,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(),new TestModule());
     assertThat(InjectsOneField.staticField).isNull();
     graph.injectStatics();
     assertThat(InjectsOneField.staticField).isEqualTo("static");
@@ -66,7 +67,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     assertThat(InjectsStaticAndNonStatic.staticField).isNull();
     graph.injectStatics();
     assertThat(InjectsStaticAndNonStatic.staticField).isEqualTo("static");
@@ -85,7 +86,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     assertThat(InjectsStaticAndNonStatic.staticField).isNull();
     InjectsStaticAndNonStatic object = new InjectsStaticAndNonStatic();
     graph.inject(object);
/Fim/
diff --git a/core/src/test/java/dagger/InjectionOfLazyTest.java b/core/src/test/java/dagger/InjectionOfLazyTest.java
index 1133f3b..7156c96 100644
--- a/core/src/test/java/dagger/InjectionOfLazyTest.java
+++ b/core/src/test/java/dagger/InjectionOfLazyTest.java
@@ -16,6 +16,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import java.util.concurrent.atomic.AtomicInteger;
 import javax.inject.Inject;
 import javax.inject.Provider;
@@ -127,6 +128,6 @@
   }
 
   private <T> T injectWithModule(T ep, Object ... modules) {
-    return ObjectGraph.create(modules).inject(ep);
+    return ObjectGraph.createWith(new TestingLoader(), modules).inject(ep);
   }
 }
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index a12fb2c..7fdb609 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -16,6 +16,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import java.util.AbstractList;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -53,7 +54,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
     G g = entryPoint.gProvider.get();
     assertThat(g.a).isNotNull();
     assertThat(g.b).isNotNull();
@@ -112,7 +113,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
 
     assertThat(entryPoint.aProvider.get()).isNotNull();
     assertThat(entryPoint.aProvider.get()).isNotNull();
@@ -134,7 +135,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
     assertThat(entryPoint.fProvider.get()).isSameAs(entryPoint.fProvider.get());
     assertThat(entryPoint.iProvider.get()).isSameAs(entryPoint.iProvider.get());
   }
@@ -165,7 +166,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
     assertThat(entryPoint.a).isNotNull();
     assertThat(one).isSameAs(entryPoint.aOne);
     assertThat(two).isSameAs(entryPoint.aTwo);
@@ -190,7 +191,7 @@
 
     TestEntryPoint entryPoint = new TestEntryPoint();
     TestModule module = new TestModule();
-    ObjectGraph.create(module).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), module).inject(entryPoint);
     entryPoint.lProvider.get();
 
     assertThat(module.a1).isNotNull();
@@ -221,7 +222,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
 
     assertThat(entryPoint.f1).isSameAs(entryPoint.f2);
     assertThat(entryPoint.f1).isSameAs(entryPoint.n1.f1);
@@ -247,7 +248,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.validate();
       fail();
@@ -268,7 +269,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
     assertThat(entryPoint.q.f).isNotNull();
   }
 
@@ -282,7 +283,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
     assertThat(entryPoint.t).isNotNull();
   }
 
@@ -323,7 +324,7 @@
     R.injected = false;
     TestEntryPoint entryPoint = new TestEntryPoint();
     TestModule module = new TestModule();
-    ObjectGraph.create(module).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), module).inject(entryPoint);
 
     assertThat(R.injected).isFalse();
     assertThat(module.sInjected).isFalse();
@@ -349,7 +350,7 @@
     }
 
     try {
-      ObjectGraph.create(new TestModule());
+      ObjectGraph.createWith(new TestingLoader(), new TestModule());
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -367,7 +368,7 @@
     }
 
     try {
-      ObjectGraph.create(new TestModule());
+      ObjectGraph.createWith(new TestingLoader(), new TestModule());
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -386,7 +387,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
     assertThat(entryPoint.aProvider.get()).isSameAs(entryPoint.aProvider.get());
   }
 
@@ -413,7 +414,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new BaseModule(), new OverridesModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new BaseModule(), new OverridesModule()).inject(entryPoint);
     E e = entryPoint.eProvider.get();
     assertThat(e).isNotNull();
     assertThat(e.f).isNotNull();
@@ -428,7 +429,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.validate();
       fail();
@@ -449,7 +450,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     graph.validate();
     assertThat(graph.get(Runnable.class)).isSameAs(runnable);
   }
@@ -463,7 +464,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.validate();
       fail();
@@ -498,7 +499,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
     assertThat(entryPoint.extendsParameterizedType.string).isEqualTo("injected");
   }
 
@@ -515,7 +516,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
     assertThat(entryPoint.listOfStrings).isEqualTo(Arrays.asList("a", "b"));
   }
 
@@ -532,7 +533,7 @@
     }
 
     try {
-      ObjectGraph.create(new TestModule());
+      ObjectGraph.createWith(new TestingLoader(), new TestModule());
       fail();
     } catch (UnsupportedOperationException expected) {
     }
@@ -555,7 +556,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.validate();
       fail();
@@ -568,7 +569,7 @@
     class TestModule {
     }
 
-    ObjectGraph.create(new TestModule());
+    ObjectGraph.createWith(new TestingLoader(), new TestModule());
   }
 
   @Test public void getInstance() {
@@ -581,7 +582,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     assertThat((int) graph.get(Integer.class)).isEqualTo(0);
     assertThat((int) graph.get(Integer.class)).isEqualTo(1);
   }
@@ -594,7 +595,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.get(Integer.class);
       fail();
@@ -610,7 +611,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     assertEquals(1, (int) graph.get(int.class));
   }
 
@@ -622,7 +623,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     assertEquals("[1, 2, 3]", Arrays.toString(graph.get(int[].class)));
   }
 
@@ -645,7 +646,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     BoundTwoWays provided = graph.get(BoundTwoWays.class);
     assertEquals("Pepsi", provided.s);
 
@@ -664,7 +665,7 @@
     class TestModule {
     }
 
-    ObjectGraph.create(new TestModule()).validate();
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).validate();
   }
 
   static class InjectMembersOnly {
@@ -681,7 +682,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.get(InjectMembersOnly.class);
       fail();
@@ -701,7 +702,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.validate();
       fail();
@@ -724,7 +725,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.validate();
       fail();
@@ -745,7 +746,7 @@
     }
 
     try {
-      ObjectGraph.create(new TestModule()).inject(new TestEntryPoint());
+      ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(new TestEntryPoint());
       fail();
     } catch (ClassCastException e) {
       assertThat(e.getMessage()).isEqualTo("foo");
@@ -764,7 +765,7 @@
     }
 
     try {
-      ObjectGraph.create(new TestModule()).get(ThrowsOnConstruction.class);
+      ObjectGraph.createWith(new TestingLoader(), new TestModule()).get(ThrowsOnConstruction.class);
       fail();
     } catch (ClassCastException e) {
       assertThat(e.getMessage()).isEqualTo("foo");
@@ -782,7 +783,7 @@
   static class ExtensionModule { }
 
   @Test public void testSingletonLinkingThroughExtensionGraph() {
-    ObjectGraph root = ObjectGraph.create(new RootModule());
+    ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule());
     // DO NOT CALL root.get(C.class)) HERE to get forced-linking behaviour from plus();
     ObjectGraph extension = root.plus(new ExtensionModule());
     assertThat(extension.get(SingletonLinkedFromExtension.class).c).isSameAs(root.get(C.class));
@@ -801,7 +802,7 @@
     }
 
     try {
-      ObjectGraph.create(new TestModule()).inject(new Test());
+      ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(new Test());
       fail();
     } catch (IllegalStateException e) {
       assertThat(e.getMessage()).contains("Can't inject private field: ");
@@ -819,7 +820,7 @@
     }
 
     try {
-      ObjectGraph.create(new TestModule()).get(Test.class);
+      ObjectGraph.createWith(new TestingLoader(), new TestModule()).get(Test.class);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e.getMessage()).contains("Can't inject private constructor: ");
@@ -832,7 +833,7 @@
     class TestModule {
     }
 
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     objectGraph.validate();
     try {
       objectGraph.get(ArrayList.class);
/Fim/
diff --git a/core/src/test/java/dagger/LazyInjectionTest.java b/core/src/test/java/dagger/LazyInjectionTest.java
index 522a344..849a431 100644
--- a/core/src/test/java/dagger/LazyInjectionTest.java
+++ b/core/src/test/java/dagger/LazyInjectionTest.java
@@ -15,6 +15,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import javax.inject.Inject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -29,7 +30,7 @@
     class TestModule {
     }
 
-    ObjectGraph.create(new TestModule());
+    ObjectGraph.createWith(new TestingLoader(), new TestModule());
     assertThat(lazyEntryPointLoaded).isFalse();
   }
 
@@ -48,7 +49,7 @@
       }
     }
 
-    ObjectGraph.create(new TestModule());
+    ObjectGraph.createWith(new TestingLoader(), new TestModule());
     assertThat(lazyProvidesParameterLoaded).isFalse();
   }
 
@@ -67,7 +68,7 @@
       }
     }
 
-    ObjectGraph.create(new TestModule());
+    ObjectGraph.createWith(new TestingLoader(), new TestModule());
     assertThat(lazyProvidesResultLoaded).isFalse();
   }
 
@@ -83,7 +84,7 @@
     class TestModule {
     }
 
-    ObjectGraph.create(new TestModule());
+    ObjectGraph.createWith(new TestingLoader(), new TestModule());
     assertThat(LazyInjectStaticsLoaded).isFalse();
   }
 
@@ -109,7 +110,7 @@
       }
     }
 
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     TestEntryPoint entryPoint = new TestEntryPoint();
     objectGraph.inject(entryPoint);
     assertThat(entryPoint.injected).isEqualTo("5");
/Fim/
diff --git a/core/src/test/java/dagger/MembersInjectorTest.java b/core/src/test/java/dagger/MembersInjectorTest.java
index 75408eb..5a0197f 100644
--- a/core/src/test/java/dagger/MembersInjectorTest.java
+++ b/core/src/test/java/dagger/MembersInjectorTest.java
@@ -15,6 +15,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.inject.Singleton;
@@ -44,7 +45,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new StringModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new StringModule()).inject(entryPoint);
     Injectable injectable = new Injectable();
     entryPoint.membersInjector.injectMembers(injectable);
     assertThat(injectable.injected).isEqualTo("injected");
@@ -75,7 +76,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new StringModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new StringModule()).inject(entryPoint);
     Unconstructable object = new Unconstructable("constructor");
     entryPoint.membersInjector.injectMembers(object);
     assertThat(object.constructor).isEqualTo("constructor");
@@ -92,7 +93,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.get(TestEntryPoint.class);
       fail();
@@ -109,7 +110,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.get(TestEntryPoint.class);
       fail();
@@ -126,7 +127,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.get(TestEntryPoint.class);
       fail();
@@ -160,7 +161,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
     NonStaticInner nonStaticInner = new NonStaticInner();
     entryPoint.membersInjector.injectMembers(nonStaticInner);
     assertThat(nonStaticInner.injected).isEqualTo("injected");
@@ -175,7 +176,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.get(TestEntryPoint.class);
       fail();
@@ -206,7 +207,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
 
     InjectsString provided = entryPoint.provider.get();
     assertThat(provided.value).isEqualTo("provides");
/Fim/
diff --git a/core/src/test/java/dagger/ModuleTest.java b/core/src/test/java/dagger/ModuleTest.java
index 571d1b2..56dcecc 100644
--- a/core/src/test/java/dagger/ModuleTest.java
+++ b/core/src/test/java/dagger/ModuleTest.java
@@ -15,6 +15,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import org.junit.Test;
@@ -24,6 +25,8 @@
 import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
+//TODO: Migrate to compiler.
+
 @RunWith(JUnit4.class)
 public final class ModuleTest {
   static class TestEntryPoint {
@@ -42,7 +45,7 @@
       }
     }
 
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     TestEntryPoint entryPoint = objectGraph.get(TestEntryPoint.class);
     assertThat(entryPoint.s).isEqualTo("injected");
   }
@@ -63,7 +66,7 @@
       }
     }
 
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     TestStaticInjection.s = null;
     objectGraph.injectStatics();
     assertThat(TestStaticInjection.s).isEqualTo("injected");
@@ -85,7 +88,7 @@
     class TestModule {
     }
 
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     TestEntryPoint entryPoint = new TestEntryPoint();
     objectGraph.inject(entryPoint);
     assertThat(entryPoint.s).isEqualTo("injected");
@@ -104,7 +107,7 @@
     class TestModule {
     }
 
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     TestEntryPoint entryPoint = new TestEntryPoint();
     objectGraph.inject(entryPoint);
     assertThat(entryPoint.s).isEqualTo("injected");
@@ -129,7 +132,7 @@
     }
 
     try {
-      ObjectGraph.create(new TestModule());
+      ObjectGraph.createWith(new TestingLoader(), new TestModule());
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -144,7 +147,7 @@
     class TestModule {
     }
 
-    ObjectGraph objectGraph = ObjectGraph.create(new ModuleWithConstructor("a"), new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new ModuleWithConstructor("a"), new TestModule());
     TestEntryPoint entryPoint = new TestEntryPoint();
     objectGraph.inject(entryPoint);
     assertThat(entryPoint.s).isEqualTo("a");
@@ -162,13 +165,13 @@
 
   @Test public void autoInstantiationOfModules() {
     // Have to make these non-method-scoped or instantiation errors occur.
-    ObjectGraph objectGraph = ObjectGraph.create(TestModuleA.class);
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), TestModuleA.class);
     assertThat(objectGraph.get(A.class)).isNotNull();
   }
 
   @Test public void autoInstantiationOfIncludedModules() {
     // Have to make these non-method-scoped or instantiation errors occur.
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModuleB()); // TestModuleA auto-created.
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModuleB()); // TestModuleA auto-created.
     assertThat(objectGraph.get(A.class)).isNotNull();
     assertThat(objectGraph.get(B.class).a).isNotNull();
   }
@@ -180,7 +183,7 @@
 
   @Test(expected = IllegalArgumentException.class)
   public void childModuleMissingModuleAnnotation() {
-    ObjectGraph.create(new ChildModuleMissingModuleAnnotation());
+    ObjectGraph.createWith(new TestingLoader(), new TestingLoader(), new ChildModuleMissingModuleAnnotation());
   }
 
   @Module
@@ -188,7 +191,7 @@
 
   @Test public void moduleExtendingClassThrowsException() {
     try {
-      ObjectGraph.create(new ThreadModule());
+      ObjectGraph.createWith(new TestingLoader(), new ThreadModule());
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).startsWith("Modules must not extend from other classes: ");
@@ -203,7 +206,7 @@
       }
     }
     try {
-      ObjectGraph.create(new ProvidesProviderModule());
+      ObjectGraph.createWith(new TestingLoader(), new ProvidesProviderModule());
       fail();
     } catch (IllegalStateException e) {
       assertThat(e.getMessage()) //
@@ -220,7 +223,7 @@
       }
     }
     try {
-      ObjectGraph.create(new ProvidesRawProviderModule());
+      ObjectGraph.createWith(new TestingLoader(), new ProvidesRawProviderModule());
       fail();
     } catch (IllegalStateException e) {
       assertThat(e.getMessage()) //
@@ -237,7 +240,7 @@
       }
     }
     try {
-      ObjectGraph.create(new ProvidesLazyModule());
+      ObjectGraph.createWith(new TestingLoader(), new ProvidesLazyModule());
       fail();
     } catch (IllegalStateException e) {
       assertThat(e.getMessage()) //
@@ -254,7 +257,7 @@
       }
     }
     try {
-      ObjectGraph.create(new ProvidesRawLazyModule());
+      ObjectGraph.createWith(new TestingLoader(), new ProvidesRawLazyModule());
       fail();
     } catch (IllegalStateException e) {
       assertThat(e.getMessage()) //
/Fim/
diff --git a/core/src/test/java/dagger/ProblemDetectorTest.java b/core/src/test/java/dagger/ProblemDetectorTest.java
index 83b1124..a6b7c43 100644
--- a/core/src/test/java/dagger/ProblemDetectorTest.java
+++ b/core/src/test/java/dagger/ProblemDetectorTest.java
@@ -15,6 +15,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import javax.inject.Inject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,7 +34,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.validate();
       fail();
@@ -52,7 +53,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.validate();
       fail();
@@ -71,7 +72,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     graph.validate();
   }
 
/Fim/
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index 7be7a9e..1393ecc 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -16,6 +16,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.Arrays;
@@ -108,7 +109,7 @@
       @Provides(type=SET) Integer b() { return defaultCounter.getAndIncrement(); }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     TestEntryPoint1 ep1 = graph.inject(new TestEntryPoint1());
     TestEntryPoint2 ep2 = graph.inject(new TestEntryPoint2());
     assertEquals(set(100, 200), ep1.objects1);
@@ -184,7 +185,7 @@
       @Provides(type=SET) String provideString2() { return "string2"; }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     graph.validate();
   }
 
@@ -212,7 +213,7 @@
   }
 
   private <T> T injectWithModule(T ep, Object ... modules) {
-    return ObjectGraph.create(modules).inject(ep);
+    return ObjectGraph.createWith(new TestingLoader(), modules).inject(ep);
   }
 
   private <T> Set<T> set(T... ts) {
/Fim/
diff --git a/core/src/test/java/dagger/ThreadSafetyTest.java b/core/src/test/java/dagger/ThreadSafetyTest.java
index 2622d12..ba4986d 100644
--- a/core/src/test/java/dagger/ThreadSafetyTest.java
+++ b/core/src/test/java/dagger/ThreadSafetyTest.java
@@ -16,6 +16,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.Callable;
@@ -73,7 +74,8 @@
 
   @Test public void concurrentSingletonAccess() throws Exception {
     final List<Future<Long>> futures = new ArrayList<Future<Long>>();
-    final ObjectGraph graph = ObjectGraph.create(new LatchingModule(latch));
+    final ObjectGraph graph =
+        ObjectGraph.createWith(new TestingLoader(), new LatchingModule(latch));
     for (int i = 0; i < THREAD_COUNT; i++) {
       futures.add(es.submit(new Callable<Long>() {
         @Override public Long call() {
@@ -92,7 +94,8 @@
 
   @Test public void concurrentLazyAccess() throws Exception {
     final List<Future<Integer>> futures = new ArrayList<Future<Integer>>();
-    final ObjectGraph graph = ObjectGraph.create(new LatchingModule(latch));
+    final ObjectGraph graph =
+        ObjectGraph.createWith(new TestingLoader(), new LatchingModule(latch));
     final LazyEntryPoint lep = graph.get(LazyEntryPoint.class);
     for (int i = 0; i < THREAD_COUNT; i++) {
       futures.add(es.submit(new Callable<Integer>() {
/Fim/
diff --git a/core/src/test/java/dagger/UnusedProviderTest.java b/core/src/test/java/dagger/UnusedProviderTest.java
index f9ffbef..683c6dc 100644
--- a/core/src/test/java/dagger/UnusedProviderTest.java
+++ b/core/src/test/java/dagger/UnusedProviderTest.java
@@ -15,6 +15,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -35,7 +36,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     graph.validate();
   }
 
@@ -52,7 +53,7 @@
     }
 
     try {
-      ObjectGraph graph = ObjectGraph.create(new TestModule());
+      ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
       graph.validate();
       fail("Validation should have exploded!");
     } catch (IllegalStateException expected) {
@@ -75,7 +76,7 @@
     @Module(injects = EntryPoint.class) class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     graph = graph.plus(new ExampleLibraryModule());
     graph.validate();
   }
@@ -88,7 +89,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.validate();
       fail();
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java b/core/src/test/java/dagger/internal/TestOnlyModuleAdapter.java
similarity index 91%
rename from core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
rename to core/src/test/java/dagger/internal/TestOnlyModuleAdapter.java
index 1bb36f7..a2b1a20 100644
--- a/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
+++ b/core/src/test/java/dagger/internal/TestOnlyModuleAdapter.java
@@ -13,16 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.loaders;
+package dagger.internal;
 
 import dagger.Lazy;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.Binding;
-import dagger.internal.Keys;
-import dagger.internal.Linker;
-import dagger.internal.ModuleAdapter;
-import dagger.internal.SetBinding;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
@@ -34,10 +29,11 @@
 import javax.inject.Provider;
 import javax.inject.Singleton;
 
-public final class ReflectiveModuleAdapter extends ModuleAdapter<Object> {
+//TODO: Reduce the complexity of this and/or replace with a mock or fake.
+public final class TestOnlyModuleAdapter extends ModuleAdapter<Object> {
   final Class<?> moduleClass;
 
-  public ReflectiveModuleAdapter(Class<?> moduleClass, Module annotation) {
+  public TestOnlyModuleAdapter(Class<?> moduleClass, Module annotation) {
     super(
         injectableTypesToKeys(annotation.injects()),
         annotation.staticInjections(),
@@ -130,7 +126,7 @@
   }
 
   /**
-   * Creates a ReflectiveModuleAdapter or throws an {@code IllegalArgumentException}.
+   * Creates a TestOnlyModuleAdapter or throws an {@code IllegalArgumentException}.
    */
   @SuppressWarnings("unchecked") // Runtime checks validate that the result type matches 'T'.
   public static <T> ModuleAdapter<T> create(Class<? extends T> moduleClass) {
@@ -142,7 +138,7 @@
       throw new IllegalArgumentException(
           "Modules must not extend from other classes: " + moduleClass.getName());
     }
-    return (ModuleAdapter<T>) new ReflectiveModuleAdapter(moduleClass, annotation);
+    return (ModuleAdapter<T>) new TestOnlyModuleAdapter(moduleClass, annotation);
   }
 
   /**
@@ -172,7 +168,6 @@
       }
     }
 
-    @SuppressWarnings("unchecked") // We defined 'T' in terms of the method's return type.
     @Override public T get() {
       Object[] args = new Object[parameters.length];
       for (int i = 0; i < parameters.length; i++) {
/Fim/
diff --git a/core/src/test/java/dagger/internal/TestingLoader.java b/core/src/test/java/dagger/internal/TestingLoader.java
new file mode 100644
index 0000000..512c4b6
--- /dev/null
+++ b/core/src/test/java/dagger/internal/TestingLoader.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+
+import dagger.internal.loaders.ReflectiveAtInjectBinding;
+import dagger.internal.loaders.ReflectiveStaticInjection;
+
+/**
+ * A test-only loader that merely uses reflection to test internals.
+ */
+public final class TestingLoader implements Loader {
+
+  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
+    ModuleAdapter<T> adapter = TestOnlyModuleAdapter.create(type);
+    adapter.module = (instance != null) ? instance : adapter.newModule();
+    return adapter;
+  }
+
+  @Override public Binding<?> getAtInjectBinding(String key, String className, ClassLoader ignored,
+      boolean mustHaveInjections) {
+     try {
+      Class<?> type = getClass().getClassLoader().loadClass(className);
+      if (type.isInterface()) {
+        return null; // Short-circuit since we can't build reflective bindings for interfaces.
+      }
+      return ReflectiveAtInjectBinding.create(type, mustHaveInjections);
+    } catch (ClassNotFoundException e) {
+      throw new TypeNotPresentException(
+          String.format("Could not find %s needed for binding %s", className, key), e);
+    }
+  }
+
+  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
+    return ReflectiveStaticInjection.create(injectedClass);
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
index 877fb0d..48b3e38 100644
--- a/core/src/main/java/dagger/internal/FailoverLoader.java
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -32,13 +32,14 @@
    * Obtains a module adapter for {@code module} from the first responding resolver.
    */
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
+    ModuleAdapter<T> result = null;
     try {
-      ModuleAdapter<T> result = GeneratedAdapters.initModuleAdapter(type);
-      result.module = (instance != null) ? instance : result.newModule();
-      return result;
+      result = GeneratedAdapters.initModuleAdapter(type);
     } catch (ClassNotFoundException e) {
       throw new TypeNotPresentException(type + GeneratedAdapters.MODULE_ADAPTER_SUFFIX, e);
     }
+    result.module = (instance != null) ? instance : result.newModule();
+    return result;
   }
 
   @Override public Binding<?> getAtInjectBinding(String key, String className,
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
index 0907ad0..6ef7445 100644
--- a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
+++ b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
@@ -35,16 +35,28 @@
 
   private GeneratedAdapters() { }
 
+  /**
+   * Attempts to load an adapter named from the provided type plus a constant suffix
+   * {@link #MODULE_ADAPTER_SUFFIX}, or throws a ClassNotFoundException.
+   */
   public static <T> ModuleAdapter<T> initModuleAdapter(Class<? extends T> moduleClass)
       throws ClassNotFoundException {
     return instantiate(moduleClass.getName() + MODULE_ADAPTER_SUFFIX, moduleClass.getClassLoader());
   }
 
+  /**
+   * Attempts to load an adapter named from the provided class name plus a constant suffix
+   * {@link #INJECT_ADAPTER_SUFFIX}, or throws a ClassNotFoundException.
+   */
   public static Binding<?> initInjectAdapter(String className, ClassLoader classLoader)
       throws ClassNotFoundException {
     return instantiate(className + INJECT_ADAPTER_SUFFIX, classLoader);
   }
 
+  /**
+   * Attempts to load an adapter named from the provided type plus a constant suffix
+   * {@link #STATIC_INJECTION_SUFFIX}, or throws a ClassNotFoundException.
+   */
   public static StaticInjection initStaticInjection(Class<?> injectedClass)
       throws ClassNotFoundException {
     return instantiate(injectedClass.getName() + STATIC_INJECTION_SUFFIX,
/Fim/
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
index 48b3e38..52f923e 100644
--- a/core/src/main/java/dagger/internal/FailoverLoader.java
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -46,7 +46,7 @@
       ClassLoader classLoader, boolean mustHaveInjections) {
       try {
         return GeneratedAdapters.initInjectAdapter(className, classLoader);
-      } catch (ClassNotFoundException ignored) {
+      } catch (ClassNotFoundException ignored /* failover case */) {
         try {
           // A null classloader is the system classloader.
           classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
index 6ef7445..91a974a 100644
--- a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
+++ b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
@@ -37,7 +37,7 @@
 
   /**
    * Attempts to load an adapter named from the provided type plus a constant suffix
-   * {@link #MODULE_ADAPTER_SUFFIX}, or throws a ClassNotFoundException.
+   * {@link #MODULE_ADAPTER_SUFFIX}, or throws a {@code ClassNotFoundException}.
    */
   public static <T> ModuleAdapter<T> initModuleAdapter(Class<? extends T> moduleClass)
       throws ClassNotFoundException {
@@ -46,7 +46,7 @@
 
   /**
    * Attempts to load an adapter named from the provided class name plus a constant suffix
-   * {@link #INJECT_ADAPTER_SUFFIX}, or throws a ClassNotFoundException.
+   * {@link #INJECT_ADAPTER_SUFFIX}, or throws a {@code ClassNotFoundException}.
    */
   public static Binding<?> initInjectAdapter(String className, ClassLoader classLoader)
       throws ClassNotFoundException {
@@ -55,7 +55,7 @@
 
   /**
    * Attempts to load an adapter named from the provided type plus a constant suffix
-   * {@link #STATIC_INJECTION_SUFFIX}, or throws a ClassNotFoundException.
+   * {@link #STATIC_INJECTION_SUFFIX}, or throws a {@code ClassNotFoundException}.
    */
   public static StaticInjection initStaticInjection(Class<?> injectedClass)
       throws ClassNotFoundException {
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 9c62140..1fe64b4 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -126,6 +126,11 @@
     return DaggerObjectGraph.makeGraph(null, new FailoverLoader(), modules);
   }
 
+  // visible for testing
+  static ObjectGraph createWith(Loader loader, Object... modules) {
+    return DaggerObjectGraph.makeGraph(null, loader, modules);
+  }
+
   static class DaggerObjectGraph extends ObjectGraph {
     private final DaggerObjectGraph base;
     private final Linker linker;
/Fim/
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
index 674b259..52f923e 100644
--- a/core/src/main/java/dagger/internal/FailoverLoader.java
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -19,7 +19,6 @@
 
 import dagger.internal.loaders.GeneratedAdapters;
 import dagger.internal.loaders.ReflectiveAtInjectBinding;
-import dagger.internal.loaders.ReflectiveModuleAdapter;
 import dagger.internal.loaders.ReflectiveStaticInjection;
 
 /**
@@ -33,9 +32,11 @@
    * Obtains a module adapter for {@code module} from the first responding resolver.
    */
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
-    ModuleAdapter<T> result = GeneratedAdapters.initModuleAdapter(type);
-    if (result == null) {
-      result = ReflectiveModuleAdapter.create(type);
+    ModuleAdapter<T> result = null;
+    try {
+      result = GeneratedAdapters.initModuleAdapter(type);
+    } catch (ClassNotFoundException e) {
+      throw new TypeNotPresentException(type + GeneratedAdapters.MODULE_ADAPTER_SUFFIX, e);
     }
     result.module = (instance != null) ? instance : result.newModule();
     return result;
@@ -43,27 +44,29 @@
 
   @Override public Binding<?> getAtInjectBinding(String key, String className,
       ClassLoader classLoader, boolean mustHaveInjections) {
-    try {
-      Binding<?> result = GeneratedAdapters.initInjectAdapter(className, classLoader);
-      if (result == null) {
-        // A null classloader is the system classloader.
-        classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
-        Class<?> c = classLoader.loadClass(className);
-        if (!c.isInterface()) {
-          result = ReflectiveAtInjectBinding.create(c, mustHaveInjections);
+      try {
+        return GeneratedAdapters.initInjectAdapter(className, classLoader);
+      } catch (ClassNotFoundException ignored /* failover case */) {
+        try {
+          // A null classloader is the system classloader.
+          classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
+          Class<?> type = classLoader.loadClass(className);
+          if (!type.isInterface()) {
+            return null; // Short-circuit since we can't build reflective bindings for interfaces.
+          }
+          return ReflectiveAtInjectBinding.create(type, mustHaveInjections);
+        } catch (ClassNotFoundException e) {
+          throw new TypeNotPresentException(
+              String.format("Could not find %s needed for binding %s", className, key), e);
         }
       }
-      return result;
-    } catch (ClassNotFoundException e) {
-      throw new RuntimeException("Could not find " + className + " needed for binding " + key, e);
-    }
   }
 
   @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    StaticInjection result = GeneratedAdapters.initStaticInjection(injectedClass);
-    if (result == null) {
-      result = ReflectiveStaticInjection.create(injectedClass);
+    try {
+      return GeneratedAdapters.initStaticInjection(injectedClass);
+    } catch (ClassNotFoundException ignored) {
+      return ReflectiveStaticInjection.create(injectedClass);
     }
-    return result;
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Loader.java b/core/src/main/java/dagger/internal/Loader.java
index c2016a5..1d2d10f 100644
--- a/core/src/main/java/dagger/internal/Loader.java
+++ b/core/src/main/java/dagger/internal/Loader.java
@@ -30,7 +30,8 @@
       String key, String className, ClassLoader classLoader, boolean mustHaveInjections);
 
   /**
-   * Returns a module adapter for {@code module}.
+   * Returns a module adapter for {@code module} or throws a {@code TypeNotPresentException} if
+   * none can be found.
    */
   <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module);
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
index 2682da0..91a974a 100644
--- a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
+++ b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
@@ -21,7 +21,6 @@
 import dagger.internal.StaticInjection;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
-import java.util.logging.Level;
 import java.util.logging.Logger;
 
 /**
@@ -36,20 +35,36 @@
 
   private GeneratedAdapters() { }
 
-  public static <T> ModuleAdapter<T> initModuleAdapter(Class<? extends T> moduleClass) {
+  /**
+   * Attempts to load an adapter named from the provided type plus a constant suffix
+   * {@link #MODULE_ADAPTER_SUFFIX}, or throws a {@code ClassNotFoundException}.
+   */
+  public static <T> ModuleAdapter<T> initModuleAdapter(Class<? extends T> moduleClass)
+      throws ClassNotFoundException {
     return instantiate(moduleClass.getName() + MODULE_ADAPTER_SUFFIX, moduleClass.getClassLoader());
   }
 
-  public static Binding<?> initInjectAdapter(String className, ClassLoader classLoader) {
+  /**
+   * Attempts to load an adapter named from the provided class name plus a constant suffix
+   * {@link #INJECT_ADAPTER_SUFFIX}, or throws a {@code ClassNotFoundException}.
+   */
+  public static Binding<?> initInjectAdapter(String className, ClassLoader classLoader)
+      throws ClassNotFoundException {
     return instantiate(className + INJECT_ADAPTER_SUFFIX, classLoader);
   }
 
-  public static StaticInjection initStaticInjection(Class<?> injectedClass) {
+  /**
+   * Attempts to load an adapter named from the provided type plus a constant suffix
+   * {@link #STATIC_INJECTION_SUFFIX}, or throws a {@code ClassNotFoundException}.
+   */
+  public static StaticInjection initStaticInjection(Class<?> injectedClass)
+      throws ClassNotFoundException {
     return instantiate(injectedClass.getName() + STATIC_INJECTION_SUFFIX,
         injectedClass.getClassLoader());
   }
 
-  private static <T> T instantiate(String name, ClassLoader classLoader) {
+  private static <T> T instantiate(String name, ClassLoader classLoader)
+      throws ClassNotFoundException {
     try {
       // A null classloader is the system classloader.
       classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
@@ -57,11 +72,6 @@
       Constructor<?> constructor = generatedClass.getDeclaredConstructor();
       constructor.setAccessible(true);
       return (T) constructor.newInstance();
-    } catch (ClassNotFoundException e) {
-      if (logger.isLoggable(Level.FINE)) {
-        logger.log(Level.FINE, name + " could not be found.", e);
-      }
-      return null; // Not finding a class is not inherently an error, unlike finding a bad class.
     } catch (NoSuchMethodException e) {
       throw new RuntimeException("No default constructor found on " + name, e);
     } catch (InstantiationException e) {
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionTest.java b/core/src/test/java/dagger/ExtensionTest.java
index f688f2d..06f9b86 100644
--- a/core/src/test/java/dagger/ExtensionTest.java
+++ b/core/src/test/java/dagger/ExtensionTest.java
@@ -16,6 +16,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import java.util.Arrays;
 import javax.inject.Inject;
 import javax.inject.Singleton;
@@ -55,11 +56,12 @@
   static class ExtensionModule { }
 
   @Test public void basicExtension() {
-    assertNotNull(ObjectGraph.create(new RootModule()).plus(new ExtensionModule()));
+    assertNotNull(ObjectGraph.createWith(new TestingLoader(), new RootModule())
+        .plus(new ExtensionModule()));
   }
 
   @Test public void basicInjection() {
-    ObjectGraph root = ObjectGraph.create(new RootModule());
+    ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule());
     assertThat(root.get(A.class)).isNotNull();
     assertThat(root.get(A.class)).isSameAs(root.get(A.class)); // Present and Singleton.
     assertThat(root.get(B.class)).isNotSameAs(root.get(B.class)); // Not singleton.
@@ -77,7 +79,7 @@
   }
 
   @Test public void scopedGraphs() {
-    ObjectGraph app = ObjectGraph.create(new RootModule());
+    ObjectGraph app = ObjectGraph.createWith(new TestingLoader(), new RootModule());
     assertThat(app.get(A.class)).isNotNull();
     assertThat(app.get(A.class)).isSameAs(app.get(A.class));
     assertThat(app.get(B.class)).isNotSameAs(app.get(B.class));
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionWithStateTest.java b/core/src/test/java/dagger/ExtensionWithStateTest.java
index da2f7ac..ff35e2a 100644
--- a/core/src/test/java/dagger/ExtensionWithStateTest.java
+++ b/core/src/test/java/dagger/ExtensionWithStateTest.java
@@ -16,6 +16,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import javax.inject.Inject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -48,7 +49,7 @@
 
   @Test public void basicInjectionWithExtension() {
     A a = new A();
-    ObjectGraph root = ObjectGraph.create(new RootModule(a));
+    ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule(a));
     assertThat(root.get(A.class)).isSameAs(a);
 
     // Extension graph behaves as the root graph would for root-ish things.
/Fim/
diff --git a/core/src/test/java/dagger/InjectStaticsTest.java b/core/src/test/java/dagger/InjectStaticsTest.java
index 0421b1e..a19456b 100644
--- a/core/src/test/java/dagger/InjectStaticsTest.java
+++ b/core/src/test/java/dagger/InjectStaticsTest.java
@@ -15,6 +15,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import javax.inject.Inject;
 import org.junit.Before;
 import org.junit.Test;
@@ -47,7 +48,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(),new TestModule());
     assertThat(InjectsOneField.staticField).isNull();
     graph.injectStatics();
     assertThat(InjectsOneField.staticField).isEqualTo("static");
@@ -66,7 +67,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     assertThat(InjectsStaticAndNonStatic.staticField).isNull();
     graph.injectStatics();
     assertThat(InjectsStaticAndNonStatic.staticField).isEqualTo("static");
@@ -85,7 +86,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     assertThat(InjectsStaticAndNonStatic.staticField).isNull();
     InjectsStaticAndNonStatic object = new InjectsStaticAndNonStatic();
     graph.inject(object);
/Fim/
diff --git a/core/src/test/java/dagger/InjectionOfLazyTest.java b/core/src/test/java/dagger/InjectionOfLazyTest.java
index 1133f3b..7156c96 100644
--- a/core/src/test/java/dagger/InjectionOfLazyTest.java
+++ b/core/src/test/java/dagger/InjectionOfLazyTest.java
@@ -16,6 +16,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import java.util.concurrent.atomic.AtomicInteger;
 import javax.inject.Inject;
 import javax.inject.Provider;
@@ -127,6 +128,6 @@
   }
 
   private <T> T injectWithModule(T ep, Object ... modules) {
-    return ObjectGraph.create(modules).inject(ep);
+    return ObjectGraph.createWith(new TestingLoader(), modules).inject(ep);
   }
 }
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index a12fb2c..7fdb609 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -16,6 +16,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import java.util.AbstractList;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -53,7 +54,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
     G g = entryPoint.gProvider.get();
     assertThat(g.a).isNotNull();
     assertThat(g.b).isNotNull();
@@ -112,7 +113,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
 
     assertThat(entryPoint.aProvider.get()).isNotNull();
     assertThat(entryPoint.aProvider.get()).isNotNull();
@@ -134,7 +135,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
     assertThat(entryPoint.fProvider.get()).isSameAs(entryPoint.fProvider.get());
     assertThat(entryPoint.iProvider.get()).isSameAs(entryPoint.iProvider.get());
   }
@@ -165,7 +166,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
     assertThat(entryPoint.a).isNotNull();
     assertThat(one).isSameAs(entryPoint.aOne);
     assertThat(two).isSameAs(entryPoint.aTwo);
@@ -190,7 +191,7 @@
 
     TestEntryPoint entryPoint = new TestEntryPoint();
     TestModule module = new TestModule();
-    ObjectGraph.create(module).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), module).inject(entryPoint);
     entryPoint.lProvider.get();
 
     assertThat(module.a1).isNotNull();
@@ -221,7 +222,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
 
     assertThat(entryPoint.f1).isSameAs(entryPoint.f2);
     assertThat(entryPoint.f1).isSameAs(entryPoint.n1.f1);
@@ -247,7 +248,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.validate();
       fail();
@@ -268,7 +269,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
     assertThat(entryPoint.q.f).isNotNull();
   }
 
@@ -282,7 +283,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
     assertThat(entryPoint.t).isNotNull();
   }
 
@@ -323,7 +324,7 @@
     R.injected = false;
     TestEntryPoint entryPoint = new TestEntryPoint();
     TestModule module = new TestModule();
-    ObjectGraph.create(module).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), module).inject(entryPoint);
 
     assertThat(R.injected).isFalse();
     assertThat(module.sInjected).isFalse();
@@ -349,7 +350,7 @@
     }
 
     try {
-      ObjectGraph.create(new TestModule());
+      ObjectGraph.createWith(new TestingLoader(), new TestModule());
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -367,7 +368,7 @@
     }
 
     try {
-      ObjectGraph.create(new TestModule());
+      ObjectGraph.createWith(new TestingLoader(), new TestModule());
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -386,7 +387,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
     assertThat(entryPoint.aProvider.get()).isSameAs(entryPoint.aProvider.get());
   }
 
@@ -413,7 +414,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new BaseModule(), new OverridesModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new BaseModule(), new OverridesModule()).inject(entryPoint);
     E e = entryPoint.eProvider.get();
     assertThat(e).isNotNull();
     assertThat(e.f).isNotNull();
@@ -428,7 +429,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.validate();
       fail();
@@ -449,7 +450,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     graph.validate();
     assertThat(graph.get(Runnable.class)).isSameAs(runnable);
   }
@@ -463,7 +464,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.validate();
       fail();
@@ -498,7 +499,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
     assertThat(entryPoint.extendsParameterizedType.string).isEqualTo("injected");
   }
 
@@ -515,7 +516,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
     assertThat(entryPoint.listOfStrings).isEqualTo(Arrays.asList("a", "b"));
   }
 
@@ -532,7 +533,7 @@
     }
 
     try {
-      ObjectGraph.create(new TestModule());
+      ObjectGraph.createWith(new TestingLoader(), new TestModule());
       fail();
     } catch (UnsupportedOperationException expected) {
     }
@@ -555,7 +556,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.validate();
       fail();
@@ -568,7 +569,7 @@
     class TestModule {
     }
 
-    ObjectGraph.create(new TestModule());
+    ObjectGraph.createWith(new TestingLoader(), new TestModule());
   }
 
   @Test public void getInstance() {
@@ -581,7 +582,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     assertThat((int) graph.get(Integer.class)).isEqualTo(0);
     assertThat((int) graph.get(Integer.class)).isEqualTo(1);
   }
@@ -594,7 +595,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.get(Integer.class);
       fail();
@@ -610,7 +611,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     assertEquals(1, (int) graph.get(int.class));
   }
 
@@ -622,7 +623,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     assertEquals("[1, 2, 3]", Arrays.toString(graph.get(int[].class)));
   }
 
@@ -645,7 +646,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     BoundTwoWays provided = graph.get(BoundTwoWays.class);
     assertEquals("Pepsi", provided.s);
 
@@ -664,7 +665,7 @@
     class TestModule {
     }
 
-    ObjectGraph.create(new TestModule()).validate();
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).validate();
   }
 
   static class InjectMembersOnly {
@@ -681,7 +682,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.get(InjectMembersOnly.class);
       fail();
@@ -701,7 +702,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.validate();
       fail();
@@ -724,7 +725,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.validate();
       fail();
@@ -745,7 +746,7 @@
     }
 
     try {
-      ObjectGraph.create(new TestModule()).inject(new TestEntryPoint());
+      ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(new TestEntryPoint());
       fail();
     } catch (ClassCastException e) {
       assertThat(e.getMessage()).isEqualTo("foo");
@@ -764,7 +765,7 @@
     }
 
     try {
-      ObjectGraph.create(new TestModule()).get(ThrowsOnConstruction.class);
+      ObjectGraph.createWith(new TestingLoader(), new TestModule()).get(ThrowsOnConstruction.class);
       fail();
     } catch (ClassCastException e) {
       assertThat(e.getMessage()).isEqualTo("foo");
@@ -782,7 +783,7 @@
   static class ExtensionModule { }
 
   @Test public void testSingletonLinkingThroughExtensionGraph() {
-    ObjectGraph root = ObjectGraph.create(new RootModule());
+    ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule());
     // DO NOT CALL root.get(C.class)) HERE to get forced-linking behaviour from plus();
     ObjectGraph extension = root.plus(new ExtensionModule());
     assertThat(extension.get(SingletonLinkedFromExtension.class).c).isSameAs(root.get(C.class));
@@ -801,7 +802,7 @@
     }
 
     try {
-      ObjectGraph.create(new TestModule()).inject(new Test());
+      ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(new Test());
       fail();
     } catch (IllegalStateException e) {
       assertThat(e.getMessage()).contains("Can't inject private field: ");
@@ -819,7 +820,7 @@
     }
 
     try {
-      ObjectGraph.create(new TestModule()).get(Test.class);
+      ObjectGraph.createWith(new TestingLoader(), new TestModule()).get(Test.class);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e.getMessage()).contains("Can't inject private constructor: ");
@@ -832,7 +833,7 @@
     class TestModule {
     }
 
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     objectGraph.validate();
     try {
       objectGraph.get(ArrayList.class);
/Fim/
diff --git a/core/src/test/java/dagger/LazyInjectionTest.java b/core/src/test/java/dagger/LazyInjectionTest.java
index 522a344..849a431 100644
--- a/core/src/test/java/dagger/LazyInjectionTest.java
+++ b/core/src/test/java/dagger/LazyInjectionTest.java
@@ -15,6 +15,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import javax.inject.Inject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -29,7 +30,7 @@
     class TestModule {
     }
 
-    ObjectGraph.create(new TestModule());
+    ObjectGraph.createWith(new TestingLoader(), new TestModule());
     assertThat(lazyEntryPointLoaded).isFalse();
   }
 
@@ -48,7 +49,7 @@
       }
     }
 
-    ObjectGraph.create(new TestModule());
+    ObjectGraph.createWith(new TestingLoader(), new TestModule());
     assertThat(lazyProvidesParameterLoaded).isFalse();
   }
 
@@ -67,7 +68,7 @@
       }
     }
 
-    ObjectGraph.create(new TestModule());
+    ObjectGraph.createWith(new TestingLoader(), new TestModule());
     assertThat(lazyProvidesResultLoaded).isFalse();
   }
 
@@ -83,7 +84,7 @@
     class TestModule {
     }
 
-    ObjectGraph.create(new TestModule());
+    ObjectGraph.createWith(new TestingLoader(), new TestModule());
     assertThat(LazyInjectStaticsLoaded).isFalse();
   }
 
@@ -109,7 +110,7 @@
       }
     }
 
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     TestEntryPoint entryPoint = new TestEntryPoint();
     objectGraph.inject(entryPoint);
     assertThat(entryPoint.injected).isEqualTo("5");
/Fim/
diff --git a/core/src/test/java/dagger/MembersInjectorTest.java b/core/src/test/java/dagger/MembersInjectorTest.java
index 75408eb..5a0197f 100644
--- a/core/src/test/java/dagger/MembersInjectorTest.java
+++ b/core/src/test/java/dagger/MembersInjectorTest.java
@@ -15,6 +15,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.inject.Singleton;
@@ -44,7 +45,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new StringModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new StringModule()).inject(entryPoint);
     Injectable injectable = new Injectable();
     entryPoint.membersInjector.injectMembers(injectable);
     assertThat(injectable.injected).isEqualTo("injected");
@@ -75,7 +76,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new StringModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new StringModule()).inject(entryPoint);
     Unconstructable object = new Unconstructable("constructor");
     entryPoint.membersInjector.injectMembers(object);
     assertThat(object.constructor).isEqualTo("constructor");
@@ -92,7 +93,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.get(TestEntryPoint.class);
       fail();
@@ -109,7 +110,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.get(TestEntryPoint.class);
       fail();
@@ -126,7 +127,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.get(TestEntryPoint.class);
       fail();
@@ -160,7 +161,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
     NonStaticInner nonStaticInner = new NonStaticInner();
     entryPoint.membersInjector.injectMembers(nonStaticInner);
     assertThat(nonStaticInner.injected).isEqualTo("injected");
@@ -175,7 +176,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.get(TestEntryPoint.class);
       fail();
@@ -206,7 +207,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
 
     InjectsString provided = entryPoint.provider.get();
     assertThat(provided.value).isEqualTo("provides");
/Fim/
diff --git a/core/src/test/java/dagger/ModuleTest.java b/core/src/test/java/dagger/ModuleTest.java
index 571d1b2..ffe818a 100644
--- a/core/src/test/java/dagger/ModuleTest.java
+++ b/core/src/test/java/dagger/ModuleTest.java
@@ -15,6 +15,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import org.junit.Test;
@@ -24,6 +25,8 @@
 import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
+//TODO: Migrate to compiler.
+
 @RunWith(JUnit4.class)
 public final class ModuleTest {
   static class TestEntryPoint {
@@ -42,7 +45,7 @@
       }
     }
 
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     TestEntryPoint entryPoint = objectGraph.get(TestEntryPoint.class);
     assertThat(entryPoint.s).isEqualTo("injected");
   }
@@ -63,7 +66,7 @@
       }
     }
 
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     TestStaticInjection.s = null;
     objectGraph.injectStatics();
     assertThat(TestStaticInjection.s).isEqualTo("injected");
@@ -85,7 +88,7 @@
     class TestModule {
     }
 
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     TestEntryPoint entryPoint = new TestEntryPoint();
     objectGraph.inject(entryPoint);
     assertThat(entryPoint.s).isEqualTo("injected");
@@ -104,7 +107,7 @@
     class TestModule {
     }
 
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     TestEntryPoint entryPoint = new TestEntryPoint();
     objectGraph.inject(entryPoint);
     assertThat(entryPoint.s).isEqualTo("injected");
@@ -129,7 +132,7 @@
     }
 
     try {
-      ObjectGraph.create(new TestModule());
+      ObjectGraph.createWith(new TestingLoader(), new TestModule());
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -144,7 +147,7 @@
     class TestModule {
     }
 
-    ObjectGraph objectGraph = ObjectGraph.create(new ModuleWithConstructor("a"), new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new ModuleWithConstructor("a"), new TestModule());
     TestEntryPoint entryPoint = new TestEntryPoint();
     objectGraph.inject(entryPoint);
     assertThat(entryPoint.s).isEqualTo("a");
@@ -162,13 +165,13 @@
 
   @Test public void autoInstantiationOfModules() {
     // Have to make these non-method-scoped or instantiation errors occur.
-    ObjectGraph objectGraph = ObjectGraph.create(TestModuleA.class);
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), TestModuleA.class);
     assertThat(objectGraph.get(A.class)).isNotNull();
   }
 
   @Test public void autoInstantiationOfIncludedModules() {
     // Have to make these non-method-scoped or instantiation errors occur.
-    ObjectGraph objectGraph = ObjectGraph.create(new TestModuleB()); // TestModuleA auto-created.
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModuleB()); // TestModuleA auto-created.
     assertThat(objectGraph.get(A.class)).isNotNull();
     assertThat(objectGraph.get(B.class).a).isNotNull();
   }
@@ -178,9 +181,14 @@
   @Module(includes = ModuleMissingModuleAnnotation.class)
   static class ChildModuleMissingModuleAnnotation {}
 
-  @Test(expected = IllegalArgumentException.class)
+  @Test
   public void childModuleMissingModuleAnnotation() {
-    ObjectGraph.create(new ChildModuleMissingModuleAnnotation());
+    try {
+      ObjectGraph.createWith(new TestingLoader(), new ChildModuleMissingModuleAnnotation());
+    } catch (IllegalArgumentException e) {
+      assertThat(e.getMessage())
+          .contains("No @Module on dagger.ModuleTest$ModuleMissingModuleAnnotation");
+    }
   }
 
   @Module
@@ -188,7 +196,7 @@
 
   @Test public void moduleExtendingClassThrowsException() {
     try {
-      ObjectGraph.create(new ThreadModule());
+      ObjectGraph.createWith(new TestingLoader(), new ThreadModule());
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).startsWith("Modules must not extend from other classes: ");
@@ -203,7 +211,7 @@
       }
     }
     try {
-      ObjectGraph.create(new ProvidesProviderModule());
+      ObjectGraph.createWith(new TestingLoader(), new ProvidesProviderModule());
       fail();
     } catch (IllegalStateException e) {
       assertThat(e.getMessage()) //
@@ -220,7 +228,7 @@
       }
     }
     try {
-      ObjectGraph.create(new ProvidesRawProviderModule());
+      ObjectGraph.createWith(new TestingLoader(), new ProvidesRawProviderModule());
       fail();
     } catch (IllegalStateException e) {
       assertThat(e.getMessage()) //
@@ -237,7 +245,7 @@
       }
     }
     try {
-      ObjectGraph.create(new ProvidesLazyModule());
+      ObjectGraph.createWith(new TestingLoader(), new ProvidesLazyModule());
       fail();
     } catch (IllegalStateException e) {
       assertThat(e.getMessage()) //
@@ -254,7 +262,7 @@
       }
     }
     try {
-      ObjectGraph.create(new ProvidesRawLazyModule());
+      ObjectGraph.createWith(new TestingLoader(), new ProvidesRawLazyModule());
       fail();
     } catch (IllegalStateException e) {
       assertThat(e.getMessage()) //
/Fim/
diff --git a/core/src/test/java/dagger/ProblemDetectorTest.java b/core/src/test/java/dagger/ProblemDetectorTest.java
index 83b1124..a6b7c43 100644
--- a/core/src/test/java/dagger/ProblemDetectorTest.java
+++ b/core/src/test/java/dagger/ProblemDetectorTest.java
@@ -15,6 +15,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import javax.inject.Inject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,7 +34,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.validate();
       fail();
@@ -52,7 +53,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.validate();
       fail();
@@ -71,7 +72,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     graph.validate();
   }
 
/Fim/
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index 7be7a9e..1393ecc 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -16,6 +16,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.Arrays;
@@ -108,7 +109,7 @@
       @Provides(type=SET) Integer b() { return defaultCounter.getAndIncrement(); }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     TestEntryPoint1 ep1 = graph.inject(new TestEntryPoint1());
     TestEntryPoint2 ep2 = graph.inject(new TestEntryPoint2());
     assertEquals(set(100, 200), ep1.objects1);
@@ -184,7 +185,7 @@
       @Provides(type=SET) String provideString2() { return "string2"; }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     graph.validate();
   }
 
@@ -212,7 +213,7 @@
   }
 
   private <T> T injectWithModule(T ep, Object ... modules) {
-    return ObjectGraph.create(modules).inject(ep);
+    return ObjectGraph.createWith(new TestingLoader(), modules).inject(ep);
   }
 
   private <T> Set<T> set(T... ts) {
/Fim/
diff --git a/core/src/test/java/dagger/ThreadSafetyTest.java b/core/src/test/java/dagger/ThreadSafetyTest.java
index 2622d12..ba4986d 100644
--- a/core/src/test/java/dagger/ThreadSafetyTest.java
+++ b/core/src/test/java/dagger/ThreadSafetyTest.java
@@ -16,6 +16,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.Callable;
@@ -73,7 +74,8 @@
 
   @Test public void concurrentSingletonAccess() throws Exception {
     final List<Future<Long>> futures = new ArrayList<Future<Long>>();
-    final ObjectGraph graph = ObjectGraph.create(new LatchingModule(latch));
+    final ObjectGraph graph =
+        ObjectGraph.createWith(new TestingLoader(), new LatchingModule(latch));
     for (int i = 0; i < THREAD_COUNT; i++) {
       futures.add(es.submit(new Callable<Long>() {
         @Override public Long call() {
@@ -92,7 +94,8 @@
 
   @Test public void concurrentLazyAccess() throws Exception {
     final List<Future<Integer>> futures = new ArrayList<Future<Integer>>();
-    final ObjectGraph graph = ObjectGraph.create(new LatchingModule(latch));
+    final ObjectGraph graph =
+        ObjectGraph.createWith(new TestingLoader(), new LatchingModule(latch));
     final LazyEntryPoint lep = graph.get(LazyEntryPoint.class);
     for (int i = 0; i < THREAD_COUNT; i++) {
       futures.add(es.submit(new Callable<Integer>() {
/Fim/
diff --git a/core/src/test/java/dagger/UnusedProviderTest.java b/core/src/test/java/dagger/UnusedProviderTest.java
index f9ffbef..683c6dc 100644
--- a/core/src/test/java/dagger/UnusedProviderTest.java
+++ b/core/src/test/java/dagger/UnusedProviderTest.java
@@ -15,6 +15,7 @@
  */
 package dagger;
 
+import dagger.internal.TestingLoader;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -35,7 +36,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     graph.validate();
   }
 
@@ -52,7 +53,7 @@
     }
 
     try {
-      ObjectGraph graph = ObjectGraph.create(new TestModule());
+      ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
       graph.validate();
       fail("Validation should have exploded!");
     } catch (IllegalStateException expected) {
@@ -75,7 +76,7 @@
     @Module(injects = EntryPoint.class) class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     graph = graph.plus(new ExampleLibraryModule());
     graph.validate();
   }
@@ -88,7 +89,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
     try {
       graph.validate();
       fail();
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java b/core/src/test/java/dagger/internal/TestOnlyModuleAdapter.java
similarity index 91%
rename from core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
rename to core/src/test/java/dagger/internal/TestOnlyModuleAdapter.java
index 1bb36f7..a2b1a20 100644
--- a/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
+++ b/core/src/test/java/dagger/internal/TestOnlyModuleAdapter.java
@@ -13,16 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.loaders;
+package dagger.internal;
 
 import dagger.Lazy;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.Binding;
-import dagger.internal.Keys;
-import dagger.internal.Linker;
-import dagger.internal.ModuleAdapter;
-import dagger.internal.SetBinding;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
@@ -34,10 +29,11 @@
 import javax.inject.Provider;
 import javax.inject.Singleton;
 
-public final class ReflectiveModuleAdapter extends ModuleAdapter<Object> {
+//TODO: Reduce the complexity of this and/or replace with a mock or fake.
+public final class TestOnlyModuleAdapter extends ModuleAdapter<Object> {
   final Class<?> moduleClass;
 
-  public ReflectiveModuleAdapter(Class<?> moduleClass, Module annotation) {
+  public TestOnlyModuleAdapter(Class<?> moduleClass, Module annotation) {
     super(
         injectableTypesToKeys(annotation.injects()),
         annotation.staticInjections(),
@@ -130,7 +126,7 @@
   }
 
   /**
-   * Creates a ReflectiveModuleAdapter or throws an {@code IllegalArgumentException}.
+   * Creates a TestOnlyModuleAdapter or throws an {@code IllegalArgumentException}.
    */
   @SuppressWarnings("unchecked") // Runtime checks validate that the result type matches 'T'.
   public static <T> ModuleAdapter<T> create(Class<? extends T> moduleClass) {
@@ -142,7 +138,7 @@
       throw new IllegalArgumentException(
           "Modules must not extend from other classes: " + moduleClass.getName());
     }
-    return (ModuleAdapter<T>) new ReflectiveModuleAdapter(moduleClass, annotation);
+    return (ModuleAdapter<T>) new TestOnlyModuleAdapter(moduleClass, annotation);
   }
 
   /**
@@ -172,7 +168,6 @@
       }
     }
 
-    @SuppressWarnings("unchecked") // We defined 'T' in terms of the method's return type.
     @Override public T get() {
       Object[] args = new Object[parameters.length];
       for (int i = 0; i < parameters.length; i++) {
/Fim/
diff --git a/core/src/test/java/dagger/internal/TestingLoader.java b/core/src/test/java/dagger/internal/TestingLoader.java
new file mode 100644
index 0000000..512c4b6
--- /dev/null
+++ b/core/src/test/java/dagger/internal/TestingLoader.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+
+import dagger.internal.loaders.ReflectiveAtInjectBinding;
+import dagger.internal.loaders.ReflectiveStaticInjection;
+
+/**
+ * A test-only loader that merely uses reflection to test internals.
+ */
+public final class TestingLoader implements Loader {
+
+  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
+    ModuleAdapter<T> adapter = TestOnlyModuleAdapter.create(type);
+    adapter.module = (instance != null) ? instance : adapter.newModule();
+    return adapter;
+  }
+
+  @Override public Binding<?> getAtInjectBinding(String key, String className, ClassLoader ignored,
+      boolean mustHaveInjections) {
+     try {
+      Class<?> type = getClass().getClassLoader().loadClass(className);
+      if (type.isInterface()) {
+        return null; // Short-circuit since we can't build reflective bindings for interfaces.
+      }
+      return ReflectiveAtInjectBinding.create(type, mustHaveInjections);
+    } catch (ClassNotFoundException e) {
+      throw new TypeNotPresentException(
+          String.format("Could not find %s needed for binding %s", className, key), e);
+    }
+  }
+
+  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
+    return ReflectiveStaticInjection.create(injectedClass);
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
index 52f923e..4b14af2 100644
--- a/core/src/main/java/dagger/internal/FailoverLoader.java
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -51,7 +51,7 @@
           // A null classloader is the system classloader.
           classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
           Class<?> type = classLoader.loadClass(className);
-          if (!type.isInterface()) {
+          if (type.isInterface()) {
             return null; // Short-circuit since we can't build reflective bindings for interfaces.
           }
           return ReflectiveAtInjectBinding.create(type, mustHaveInjections);
/Fim/
diff --git a/core/src/test/java/dagger/internal/FailoverLoaderTest.java b/core/src/test/java/dagger/internal/FailoverLoaderTest.java
new file mode 100644
index 0000000..0c049fc
--- /dev/null
+++ b/core/src/test/java/dagger/internal/FailoverLoaderTest.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2013 Google Inc.
+ * Copyright (C) 2013 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import dagger.Provides;
+import javax.inject.Inject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+/**
+ * A test case to deal with fall-back to reflection where the concrete type has been generated
+ * but the parent has no {@code @Inject} annotation, and so has not been generated.
+ */
+@RunWith(JUnit4.class)
+public final class FailoverLoaderTest {
+
+  @Module(injects = EntryPoint.class)
+  static class TestModule {
+    @Provides String aString() { return "a"; }
+  }
+
+  /** A reflective module that will be loaded in place of a generated module for this test. */
+  static final class TestModule$$ModuleAdapter extends TestOnlyModuleAdapter<TestModule> {
+    public TestModule$$ModuleAdapter() {
+      super(TestModule.class, TestModule.class.getAnnotation(Module.class));
+    }
+  }
+
+  static class EntryPoint {
+    @Inject String a;
+  }
+
+  @Test public void simpleInjectionWithUnGeneratedCode() {
+    EntryPoint entryPoint = new EntryPoint();
+    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    assertThat(entryPoint.a).isEqualTo("a");
+  }
+}
/Fim/
diff --git a/core/src/test/java/dagger/internal/TestOnlyModuleAdapter.java b/core/src/test/java/dagger/internal/TestOnlyModuleAdapter.java
index a2b1a20..08d75a6 100644
--- a/core/src/test/java/dagger/internal/TestOnlyModuleAdapter.java
+++ b/core/src/test/java/dagger/internal/TestOnlyModuleAdapter.java
@@ -30,7 +30,7 @@
 import javax.inject.Singleton;
 
 //TODO: Reduce the complexity of this and/or replace with a mock or fake.
-public final class TestOnlyModuleAdapter extends ModuleAdapter<Object> {
+public class TestOnlyModuleAdapter<T> extends ModuleAdapter<T> {
   final Class<?> moduleClass;
 
   public TestOnlyModuleAdapter(Class<?> moduleClass, Module annotation) {
@@ -107,11 +107,11 @@
         library));
   }
 
-  @Override public Object newModule() {
+  @Override public T newModule() {
     try {
       Constructor<?> constructor = moduleClass.getDeclaredConstructor();
       constructor.setAccessible(true);
-      return constructor.newInstance();
+      return (T)constructor.newInstance();
     } catch (InvocationTargetException e) {
       throw new IllegalArgumentException(e.getCause());
     } catch (NoSuchMethodException e) {
@@ -138,7 +138,7 @@
       throw new IllegalArgumentException(
           "Modules must not extend from other classes: " + moduleClass.getName());
     }
-    return (ModuleAdapter<T>) new TestOnlyModuleAdapter(moduleClass, annotation);
+    return new TestOnlyModuleAdapter(moduleClass, annotation);
   }
 
   /**
/Fim/
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
index 52f923e..4b14af2 100644
--- a/core/src/main/java/dagger/internal/FailoverLoader.java
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -51,7 +51,7 @@
           // A null classloader is the system classloader.
           classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
           Class<?> type = classLoader.loadClass(className);
-          if (!type.isInterface()) {
+          if (type.isInterface()) {
             return null; // Short-circuit since we can't build reflective bindings for interfaces.
           }
           return ReflectiveAtInjectBinding.create(type, mustHaveInjections);
/Fim/
diff --git a/core/src/test/java/dagger/internal/FailoverLoaderTest.java b/core/src/test/java/dagger/internal/FailoverLoaderTest.java
new file mode 100644
index 0000000..cb17ef6
--- /dev/null
+++ b/core/src/test/java/dagger/internal/FailoverLoaderTest.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2013 Google Inc.
+ * Copyright (C) 2013 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import dagger.Provides;
+import javax.inject.Inject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+/**
+ * A test case to deal with fall-back to reflection where the concrete type has been generated
+ * but the parent has no {@code @Inject} annotation, and so has not been generated.
+ */
+@RunWith(JUnit4.class)
+public final class FailoverLoaderTest {
+
+  @Module(injects = EntryPoint.class)
+  static class TestModule {
+    @Provides String aString() { return "a"; }
+  }
+
+  /** A reflective module that will be loaded in place of a generated module for this test. */
+  static final class TestModule$$ModuleAdapter extends TestingModuleAdapter<TestModule> {
+    public TestModule$$ModuleAdapter() {
+      super(TestModule.class, TestModule.class.getAnnotation(Module.class));
+    }
+  }
+
+  static class EntryPoint {
+    @Inject String a;
+  }
+
+  @Test public void simpleInjectionWithUnGeneratedCode() {
+    EntryPoint entryPoint = new EntryPoint();
+    ObjectGraph.create(new TestModule()).inject(entryPoint);
+    assertThat(entryPoint.a).isEqualTo("a");
+  }
+}
/Fim/
diff --git a/core/src/test/java/dagger/internal/TestingLoader.java b/core/src/test/java/dagger/internal/TestingLoader.java
index 512c4b6..958068d 100644
--- a/core/src/test/java/dagger/internal/TestingLoader.java
+++ b/core/src/test/java/dagger/internal/TestingLoader.java
@@ -26,7 +26,7 @@
 public final class TestingLoader implements Loader {
 
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
-    ModuleAdapter<T> adapter = TestOnlyModuleAdapter.create(type);
+    ModuleAdapter<T> adapter = TestingModuleAdapter.create(type);
     adapter.module = (instance != null) ? instance : adapter.newModule();
     return adapter;
   }
/Fim/
diff --git a/core/src/test/java/dagger/internal/TestOnlyModuleAdapter.java b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
similarity index 88%
rename from core/src/test/java/dagger/internal/TestOnlyModuleAdapter.java
rename to core/src/test/java/dagger/internal/TestingModuleAdapter.java
index a2b1a20..d1cf36d 100644
--- a/core/src/test/java/dagger/internal/TestOnlyModuleAdapter.java
+++ b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
@@ -30,10 +30,10 @@
 import javax.inject.Singleton;
 
 //TODO: Reduce the complexity of this and/or replace with a mock or fake.
-public final class TestOnlyModuleAdapter extends ModuleAdapter<Object> {
+public class TestingModuleAdapter<M> extends ModuleAdapter<M> {
   final Class<?> moduleClass;
 
-  public TestOnlyModuleAdapter(Class<?> moduleClass, Module annotation) {
+  public TestingModuleAdapter(Class<?> moduleClass, Module annotation) {
     super(
         injectableTypesToKeys(annotation.injects()),
         annotation.staticInjections(),
@@ -95,23 +95,23 @@
     }
   }
 
-  private <T> void handleBindings(Map<String, Binding<?>> bindings, Method method, String key,
+  private void handleBindings(Map<String, Binding<?>> bindings, Method method, String key,
       boolean library) {
-    bindings.put(key, new ProviderMethodBinding<T>(method, key, module, library));
+    bindings.put(key, new ProviderMethodBinding<M>(method, key, module, library));
   }
 
-  private <T> void handleSetBindings(Map<String, Binding<?>> bindings, Method method, String key,
+  private void handleSetBindings(Map<String, Binding<?>> bindings, Method method, String key,
       boolean library) {
     String setKey = Keys.getSetKey(method.getGenericReturnType(), method.getAnnotations(), method);
-    SetBinding.<T>add(bindings, setKey, new ProviderMethodBinding<T>(method, key, module,
+    SetBinding.<M>add(bindings, setKey, new ProviderMethodBinding<M>(method, key, module,
         library));
   }
 
-  @Override public Object newModule() {
+  @Override public M newModule() {
     try {
       Constructor<?> constructor = moduleClass.getDeclaredConstructor();
       constructor.setAccessible(true);
-      return constructor.newInstance();
+      return (M)constructor.newInstance();
     } catch (InvocationTargetException e) {
       throw new IllegalArgumentException(e.getCause());
     } catch (NoSuchMethodException e) {
@@ -126,10 +126,9 @@
   }
 
   /**
-   * Creates a TestOnlyModuleAdapter or throws an {@code IllegalArgumentException}.
+   * Creates a TestingModuleAdapter or throws an {@code IllegalArgumentException}.
    */
-  @SuppressWarnings("unchecked") // Runtime checks validate that the result type matches 'T'.
-  public static <T> ModuleAdapter<T> create(Class<? extends T> moduleClass) {
+  public static <M> ModuleAdapter<M> create(Class<? extends M> moduleClass) {
     Module annotation = moduleClass.getAnnotation(Module.class);
     if (annotation == null) {
       throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
@@ -138,7 +137,7 @@
       throw new IllegalArgumentException(
           "Modules must not extend from other classes: " + moduleClass.getName());
     }
-    return (ModuleAdapter<T>) new TestOnlyModuleAdapter(moduleClass, annotation);
+    return new TestingModuleAdapter<M>(moduleClass, annotation);
   }
 
   /**
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
index e35e84d..8fd401a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
@@ -29,7 +29,7 @@
  * {@link Binding#get} or {@link Binding#injectMembers} methods. They are only suitable
  * for graph analysis and error detection.
  */
-public final class GraphAnalysisLoader implements Loader {
+public final class GraphAnalysisLoader extends Loader {
 
   private final ProcessingEnvironment processingEnv;
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
index 4b14af2..1c27451 100644
--- a/core/src/main/java/dagger/internal/FailoverLoader.java
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -17,56 +17,57 @@
 package dagger.internal;
 
 
-import dagger.internal.loaders.GeneratedAdapters;
 import dagger.internal.loaders.ReflectiveAtInjectBinding;
 import dagger.internal.loaders.ReflectiveStaticInjection;
 
+import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
+
 /**
  * Handles loading/finding of modules, injection bindings, and static injections by use of a
  * strategy of "load the appropriate generated code" or, if no such code is found, create a
  * reflective equivalent.
  */
-public final class FailoverLoader implements Loader {
+public final class FailoverLoader extends Loader {
 
   /**
    * Obtains a module adapter for {@code module} from the first responding resolver.
    */
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
-    ModuleAdapter<T> result = null;
-    try {
-      result = GeneratedAdapters.initModuleAdapter(type);
-    } catch (ClassNotFoundException e) {
-      throw new TypeNotPresentException(type + GeneratedAdapters.MODULE_ADAPTER_SUFFIX, e);
+    ModuleAdapter<T> result =
+        instantiate(type.getName() + MODULE_ADAPTER_SUFFIX, type.getClassLoader());
+    if (result == null) {
+      throw new IllegalStateException("Module adapter for " + type + " could not be loaded. "
+          + "Please ensure that code generation was run for this module.");
     }
     result.module = (instance != null) ? instance : result.newModule();
     return result;
   }
 
-  @Override public Binding<?> getAtInjectBinding(String key, String className,
-      ClassLoader classLoader, boolean mustHaveInjections) {
-      try {
-        return GeneratedAdapters.initInjectAdapter(className, classLoader);
-      } catch (ClassNotFoundException ignored /* failover case */) {
-        try {
-          // A null classloader is the system classloader.
-          classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
-          Class<?> type = classLoader.loadClass(className);
-          if (type.isInterface()) {
-            return null; // Short-circuit since we can't build reflective bindings for interfaces.
-          }
-          return ReflectiveAtInjectBinding.create(type, mustHaveInjections);
-        } catch (ClassNotFoundException e) {
-          throw new TypeNotPresentException(
-              String.format("Could not find %s needed for binding %s", className, key), e);
-        }
-      }
+  @Override public Binding<?> getAtInjectBinding(
+      String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
+    Binding<?> result = instantiate(className + INJECT_ADAPTER_SUFFIX, classLoader);
+    if (result != null) {
+      return result; // Found loadable adapter, returning it.
+    }
+    Class<?> type = loadClass(classLoader, className);
+    if (type.equals(Void.class)) {
+      throw new IllegalStateException(
+          String.format("Could not load class %s needed for binding %s", className, key));
+    }
+    if (type.isInterface()) {
+      return null; // Short-circuit since we can't build reflective bindings for interfaces.
+    }
+    return ReflectiveAtInjectBinding.create(type, mustHaveInjections);
   }
 
   @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    try {
-      return GeneratedAdapters.initStaticInjection(injectedClass);
-    } catch (ClassNotFoundException ignored) {
-      return ReflectiveStaticInjection.create(injectedClass);
+    StaticInjection result = instantiate(
+          injectedClass.getName() + STATIC_INJECTION_SUFFIX, injectedClass.getClassLoader());
+    if (result != null) {
+      return result;
     }
+    return ReflectiveStaticInjection.create(injectedClass);
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Loader.java b/core/src/main/java/dagger/internal/Loader.java
index 1d2d10f..6a17d77 100644
--- a/core/src/main/java/dagger/internal/Loader.java
+++ b/core/src/main/java/dagger/internal/Loader.java
@@ -16,27 +16,82 @@
  */
 package dagger.internal;
 
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+
 /**
  * Provides a point of configuration of the basic resolving functions within Dagger, namely
  * that of Module handling, injection binding creation, and static injection.  A plugin must
  * provide all resolution methods
  */
-public interface Loader {
+public abstract class Loader {
+
+  final LruCache<ClassLoader, LruCache<String, Class<?>>> caches =
+      new LruCache<ClassLoader, LruCache<String, Class<?>>>(Integer.MAX_VALUE) {
+    @Override protected LruCache<String, Class<?>> create(final ClassLoader classLoader) {
+      return new LruCache<String, Class<?>>(Integer.MAX_VALUE) {
+        @Override protected Class<?> create(String className) {
+          try {
+            return classLoader.loadClass(className);
+          } catch (ClassNotFoundException e) {
+            return Void.class; // Cache the failure (negative case).
+          }
+        }
+      };
+    }
+  };
+
   /**
    * Returns a binding that uses {@code @Inject} annotations, or null if no valid binding can
    * be found or created.
    */
-  Binding<?> getAtInjectBinding(
+  public abstract Binding<?> getAtInjectBinding(
       String key, String className, ClassLoader classLoader, boolean mustHaveInjections);
 
   /**
    * Returns a module adapter for {@code module} or throws a {@code TypeNotPresentException} if
    * none can be found.
    */
-  <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module);
+  public abstract <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module);
 
   /**
    * Returns the static injection for {@code injectedClass}.
    */
-  StaticInjection getStaticInjection(Class<?> injectedClass);
+  public abstract StaticInjection getStaticInjection(Class<?> injectedClass);
+
+  /**
+   * Loads a class from a {@code ClassLoader}-specific cache if it's already there, or
+   * loads it from the given {@code ClassLoader} and caching it for future requests.  Failures
+   * to load are also cached using the Void.class type.  A null {@code ClassLoader} is assumed
+   * to be the system classloader.
+   */
+  protected Class<?> loadClass(ClassLoader classLoader, String name) {
+    // A null classloader is the system classloader.
+    classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
+    return caches.get(classLoader).get(name);
+  }
+
+  /**
+   * Instantiates a class using its default constructor and the given {@link ClassLoader}.
+   */
+  protected <T> T instantiate(String name, ClassLoader classLoader) {
+    try {
+      Class<?> generatedClass = loadClass(classLoader, name);
+      if (generatedClass == Void.class) {
+        return null;
+      }
+      Constructor<?> constructor = generatedClass.getDeclaredConstructor();
+      constructor.setAccessible(true);
+      return (T) constructor.newInstance();
+    } catch (NoSuchMethodException e) {
+      throw new RuntimeException("No default constructor found on " + name, e);
+    } catch (InstantiationException e) {
+      throw new RuntimeException("Failed to initialize " + name, e);
+    } catch (IllegalAccessException e) {
+      throw new RuntimeException("Failed to initialize " + name, e);
+    } catch (InvocationTargetException e) {
+      throw new RuntimeException("Error while initializing " + name, e.getCause());
+    }
+  }
+
 }
\ No newline at end of file
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
index 91a974a..72a825a 100644
--- a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
+++ b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
@@ -16,70 +16,15 @@
  */
 package dagger.internal.loaders;
 
-import dagger.internal.Binding;
-import dagger.internal.ModuleAdapter;
-import dagger.internal.StaticInjection;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.util.logging.Logger;
 
 /**
- * A utility for loading and initializing generated adapters.
+ * A single point for API used in common by Adapters and Adapter generators
  */
 public final class GeneratedAdapters {
   private static final String SEPARATOR = "$$";
   public static final String INJECT_ADAPTER_SUFFIX = SEPARATOR + "InjectAdapter";
   public static final String MODULE_ADAPTER_SUFFIX = SEPARATOR + "ModuleAdapter";
   public static final String STATIC_INJECTION_SUFFIX = SEPARATOR + "StaticInjection";
-  private static final Logger logger = Logger.getLogger(GeneratedAdapters.class.getName());
 
   private GeneratedAdapters() { }
-
-  /**
-   * Attempts to load an adapter named from the provided type plus a constant suffix
-   * {@link #MODULE_ADAPTER_SUFFIX}, or throws a {@code ClassNotFoundException}.
-   */
-  public static <T> ModuleAdapter<T> initModuleAdapter(Class<? extends T> moduleClass)
-      throws ClassNotFoundException {
-    return instantiate(moduleClass.getName() + MODULE_ADAPTER_SUFFIX, moduleClass.getClassLoader());
-  }
-
-  /**
-   * Attempts to load an adapter named from the provided class name plus a constant suffix
-   * {@link #INJECT_ADAPTER_SUFFIX}, or throws a {@code ClassNotFoundException}.
-   */
-  public static Binding<?> initInjectAdapter(String className, ClassLoader classLoader)
-      throws ClassNotFoundException {
-    return instantiate(className + INJECT_ADAPTER_SUFFIX, classLoader);
-  }
-
-  /**
-   * Attempts to load an adapter named from the provided type plus a constant suffix
-   * {@link #STATIC_INJECTION_SUFFIX}, or throws a {@code ClassNotFoundException}.
-   */
-  public static StaticInjection initStaticInjection(Class<?> injectedClass)
-      throws ClassNotFoundException {
-    return instantiate(injectedClass.getName() + STATIC_INJECTION_SUFFIX,
-        injectedClass.getClassLoader());
-  }
-
-  private static <T> T instantiate(String name, ClassLoader classLoader)
-      throws ClassNotFoundException {
-    try {
-      // A null classloader is the system classloader.
-      classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
-      Class<?> generatedClass = classLoader.loadClass(name);
-      Constructor<?> constructor = generatedClass.getDeclaredConstructor();
-      constructor.setAccessible(true);
-      return (T) constructor.newInstance();
-    } catch (NoSuchMethodException e) {
-      throw new RuntimeException("No default constructor found on " + name, e);
-    } catch (InstantiationException e) {
-      throw new RuntimeException("Failed to initialize " + name, e);
-    } catch (IllegalAccessException e) {
-      throw new RuntimeException("Failed to initialize " + name, e);
-    } catch (InvocationTargetException e) {
-      throw new RuntimeException("Error while initializing " + name, e.getCause());
-    }
-  }
 }
/Fim/
diff --git a/core/src/test/java/dagger/internal/TestingLoader.java b/core/src/test/java/dagger/internal/TestingLoader.java
index 958068d..a135d01 100644
--- a/core/src/test/java/dagger/internal/TestingLoader.java
+++ b/core/src/test/java/dagger/internal/TestingLoader.java
@@ -23,7 +23,7 @@
 /**
  * A test-only loader that merely uses reflection to test internals.
  */
-public final class TestingLoader implements Loader {
+public final class TestingLoader extends Loader {
 
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
     ModuleAdapter<T> adapter = TestingModuleAdapter.create(type);
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
index e35e84d..8fd401a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
@@ -29,7 +29,7 @@
  * {@link Binding#get} or {@link Binding#injectMembers} methods. They are only suitable
  * for graph analysis and error detection.
  */
-public final class GraphAnalysisLoader implements Loader {
+public final class GraphAnalysisLoader extends Loader {
 
   private final ProcessingEnvironment processingEnv;
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
index 4b14af2..1c27451 100644
--- a/core/src/main/java/dagger/internal/FailoverLoader.java
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -17,56 +17,57 @@
 package dagger.internal;
 
 
-import dagger.internal.loaders.GeneratedAdapters;
 import dagger.internal.loaders.ReflectiveAtInjectBinding;
 import dagger.internal.loaders.ReflectiveStaticInjection;
 
+import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
+
 /**
  * Handles loading/finding of modules, injection bindings, and static injections by use of a
  * strategy of "load the appropriate generated code" or, if no such code is found, create a
  * reflective equivalent.
  */
-public final class FailoverLoader implements Loader {
+public final class FailoverLoader extends Loader {
 
   /**
    * Obtains a module adapter for {@code module} from the first responding resolver.
    */
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
-    ModuleAdapter<T> result = null;
-    try {
-      result = GeneratedAdapters.initModuleAdapter(type);
-    } catch (ClassNotFoundException e) {
-      throw new TypeNotPresentException(type + GeneratedAdapters.MODULE_ADAPTER_SUFFIX, e);
+    ModuleAdapter<T> result =
+        instantiate(type.getName() + MODULE_ADAPTER_SUFFIX, type.getClassLoader());
+    if (result == null) {
+      throw new IllegalStateException("Module adapter for " + type + " could not be loaded. "
+          + "Please ensure that code generation was run for this module.");
     }
     result.module = (instance != null) ? instance : result.newModule();
     return result;
   }
 
-  @Override public Binding<?> getAtInjectBinding(String key, String className,
-      ClassLoader classLoader, boolean mustHaveInjections) {
-      try {
-        return GeneratedAdapters.initInjectAdapter(className, classLoader);
-      } catch (ClassNotFoundException ignored /* failover case */) {
-        try {
-          // A null classloader is the system classloader.
-          classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
-          Class<?> type = classLoader.loadClass(className);
-          if (type.isInterface()) {
-            return null; // Short-circuit since we can't build reflective bindings for interfaces.
-          }
-          return ReflectiveAtInjectBinding.create(type, mustHaveInjections);
-        } catch (ClassNotFoundException e) {
-          throw new TypeNotPresentException(
-              String.format("Could not find %s needed for binding %s", className, key), e);
-        }
-      }
+  @Override public Binding<?> getAtInjectBinding(
+      String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
+    Binding<?> result = instantiate(className + INJECT_ADAPTER_SUFFIX, classLoader);
+    if (result != null) {
+      return result; // Found loadable adapter, returning it.
+    }
+    Class<?> type = loadClass(classLoader, className);
+    if (type.equals(Void.class)) {
+      throw new IllegalStateException(
+          String.format("Could not load class %s needed for binding %s", className, key));
+    }
+    if (type.isInterface()) {
+      return null; // Short-circuit since we can't build reflective bindings for interfaces.
+    }
+    return ReflectiveAtInjectBinding.create(type, mustHaveInjections);
   }
 
   @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    try {
-      return GeneratedAdapters.initStaticInjection(injectedClass);
-    } catch (ClassNotFoundException ignored) {
-      return ReflectiveStaticInjection.create(injectedClass);
+    StaticInjection result = instantiate(
+          injectedClass.getName() + STATIC_INJECTION_SUFFIX, injectedClass.getClassLoader());
+    if (result != null) {
+      return result;
     }
+    return ReflectiveStaticInjection.create(injectedClass);
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Loader.java b/core/src/main/java/dagger/internal/Loader.java
index 1d2d10f..e5bcb08 100644
--- a/core/src/main/java/dagger/internal/Loader.java
+++ b/core/src/main/java/dagger/internal/Loader.java
@@ -16,27 +16,82 @@
  */
 package dagger.internal;
 
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+
 /**
  * Provides a point of configuration of the basic resolving functions within Dagger, namely
  * that of Module handling, injection binding creation, and static injection.  A plugin must
  * provide all resolution methods
  */
-public interface Loader {
+public abstract class Loader {
+
+  private final LruCache<ClassLoader, LruCache<String, Class<?>>> caches =
+      new LruCache<ClassLoader, LruCache<String, Class<?>>>(Integer.MAX_VALUE) {
+    @Override protected LruCache<String, Class<?>> create(final ClassLoader classLoader) {
+      return new LruCache<String, Class<?>>(Integer.MAX_VALUE) {
+        @Override protected Class<?> create(String className) {
+          try {
+            return classLoader.loadClass(className);
+          } catch (ClassNotFoundException e) {
+            return Void.class; // Cache the failure (negative case).
+          }
+        }
+      };
+    }
+  };
+
   /**
    * Returns a binding that uses {@code @Inject} annotations, or null if no valid binding can
    * be found or created.
    */
-  Binding<?> getAtInjectBinding(
+  public abstract Binding<?> getAtInjectBinding(
       String key, String className, ClassLoader classLoader, boolean mustHaveInjections);
 
   /**
    * Returns a module adapter for {@code module} or throws a {@code TypeNotPresentException} if
    * none can be found.
    */
-  <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module);
+  public abstract <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module);
 
   /**
    * Returns the static injection for {@code injectedClass}.
    */
-  StaticInjection getStaticInjection(Class<?> injectedClass);
+  public abstract StaticInjection getStaticInjection(Class<?> injectedClass);
+
+  /**
+   * Loads a class from a {@code ClassLoader}-specific cache if it's already there, or
+   * loads it from the given {@code ClassLoader} and caching it for future requests.  Failures
+   * to load are also cached using the Void.class type.  A null {@code ClassLoader} is assumed
+   * to be the system classloader.
+   */
+  protected Class<?> loadClass(ClassLoader classLoader, String name) {
+    // A null classloader is the system classloader.
+    classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
+    return caches.get(classLoader).get(name);
+  }
+
+  /**
+   * Instantiates a class using its default constructor and the given {@link ClassLoader}.
+   */
+  protected <T> T instantiate(String name, ClassLoader classLoader) {
+    try {
+      Class<?> generatedClass = loadClass(classLoader, name);
+      if (generatedClass == Void.class) {
+        return null;
+      }
+      Constructor<?> constructor = generatedClass.getDeclaredConstructor();
+      constructor.setAccessible(true);
+      return (T) constructor.newInstance();
+    } catch (NoSuchMethodException e) {
+      throw new RuntimeException("No default constructor found on " + name, e);
+    } catch (InstantiationException e) {
+      throw new RuntimeException("Failed to initialize " + name, e);
+    } catch (IllegalAccessException e) {
+      throw new RuntimeException("Failed to initialize " + name, e);
+    } catch (InvocationTargetException e) {
+      throw new RuntimeException("Error while initializing " + name, e.getCause());
+    }
+  }
+
 }
\ No newline at end of file
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
index 91a974a..72a825a 100644
--- a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
+++ b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
@@ -16,70 +16,15 @@
  */
 package dagger.internal.loaders;
 
-import dagger.internal.Binding;
-import dagger.internal.ModuleAdapter;
-import dagger.internal.StaticInjection;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.util.logging.Logger;
 
 /**
- * A utility for loading and initializing generated adapters.
+ * A single point for API used in common by Adapters and Adapter generators
  */
 public final class GeneratedAdapters {
   private static final String SEPARATOR = "$$";
   public static final String INJECT_ADAPTER_SUFFIX = SEPARATOR + "InjectAdapter";
   public static final String MODULE_ADAPTER_SUFFIX = SEPARATOR + "ModuleAdapter";
   public static final String STATIC_INJECTION_SUFFIX = SEPARATOR + "StaticInjection";
-  private static final Logger logger = Logger.getLogger(GeneratedAdapters.class.getName());
 
   private GeneratedAdapters() { }
-
-  /**
-   * Attempts to load an adapter named from the provided type plus a constant suffix
-   * {@link #MODULE_ADAPTER_SUFFIX}, or throws a {@code ClassNotFoundException}.
-   */
-  public static <T> ModuleAdapter<T> initModuleAdapter(Class<? extends T> moduleClass)
-      throws ClassNotFoundException {
-    return instantiate(moduleClass.getName() + MODULE_ADAPTER_SUFFIX, moduleClass.getClassLoader());
-  }
-
-  /**
-   * Attempts to load an adapter named from the provided class name plus a constant suffix
-   * {@link #INJECT_ADAPTER_SUFFIX}, or throws a {@code ClassNotFoundException}.
-   */
-  public static Binding<?> initInjectAdapter(String className, ClassLoader classLoader)
-      throws ClassNotFoundException {
-    return instantiate(className + INJECT_ADAPTER_SUFFIX, classLoader);
-  }
-
-  /**
-   * Attempts to load an adapter named from the provided type plus a constant suffix
-   * {@link #STATIC_INJECTION_SUFFIX}, or throws a {@code ClassNotFoundException}.
-   */
-  public static StaticInjection initStaticInjection(Class<?> injectedClass)
-      throws ClassNotFoundException {
-    return instantiate(injectedClass.getName() + STATIC_INJECTION_SUFFIX,
-        injectedClass.getClassLoader());
-  }
-
-  private static <T> T instantiate(String name, ClassLoader classLoader)
-      throws ClassNotFoundException {
-    try {
-      // A null classloader is the system classloader.
-      classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
-      Class<?> generatedClass = classLoader.loadClass(name);
-      Constructor<?> constructor = generatedClass.getDeclaredConstructor();
-      constructor.setAccessible(true);
-      return (T) constructor.newInstance();
-    } catch (NoSuchMethodException e) {
-      throw new RuntimeException("No default constructor found on " + name, e);
-    } catch (InstantiationException e) {
-      throw new RuntimeException("Failed to initialize " + name, e);
-    } catch (IllegalAccessException e) {
-      throw new RuntimeException("Failed to initialize " + name, e);
-    } catch (InvocationTargetException e) {
-      throw new RuntimeException("Error while initializing " + name, e.getCause());
-    }
-  }
 }
/Fim/
diff --git a/core/src/test/java/dagger/internal/TestingLoader.java b/core/src/test/java/dagger/internal/TestingLoader.java
index 958068d..a135d01 100644
--- a/core/src/test/java/dagger/internal/TestingLoader.java
+++ b/core/src/test/java/dagger/internal/TestingLoader.java
@@ -23,7 +23,7 @@
 /**
  * A test-only loader that merely uses reflection to test internals.
  */
-public final class TestingLoader implements Loader {
+public final class TestingLoader extends Loader {
 
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
     ModuleAdapter<T> adapter = TestingModuleAdapter.create(type);
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index cb7b5e6..3a5ca8a 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -52,6 +52,13 @@
       <artifactId>fest-assert</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+      <classifier>tests</classifier>
+    </dependency>
   </dependencies>
 
   <build>
@@ -59,9 +66,26 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration>
-          <compilerArgument>-proc:none</compilerArgument>
-        </configuration>
+        <executions>
+          <execution>
+            <id>default-compile</id>
+            <goals><goal>compile</goal></goals>
+            <configuration>
+              <compilerArgument>-proc:none</compilerArgument>
+            </configuration>
+          </execution>
+          <execution>
+            <id>default-test-compile</id>
+            <goals><goal>testCompile</goal></goals>
+            <configuration>
+              <annotationProcessors>
+                <annotationProcessor>dagger.internal.codegen.InjectAdapterProcessor</annotationProcessor>
+                <annotationProcessor>dagger.internal.codegen.ModuleAdapterProcessor</annotationProcessor>
+                <annotationProcessor>dagger.internal.codegen.GraphAnalysisProcessor</annotationProcessor>
+              </annotationProcessors>
+            </configuration>
+          </execution>
+        </executions>
       </plugin>
 
       <plugin>
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
new file mode 100644
index 0000000..1be3f2b
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
@@ -0,0 +1,62 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import dagger.Provides;
+import javax.inject.Inject;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+
+public final class PrimitiveInjectionTest {
+  static class ArrayInjectable {
+    @Inject byte[] byteArray;
+    @Inject int[] integerArray;
+    @Inject boolean[] booleanArray;
+    @Inject char[] charArray;
+    @Inject long[] longArray;
+    @Inject float[] floatArray;
+    @Inject double[] doubleArray;
+  }
+
+  @Module(injects = ArrayInjectable.class)
+  static class ByteArrayModule {
+    @Provides byte[] byteArray() { return new byte[] { Byte.MAX_VALUE }; }
+    @Provides int[] provideInt() { return new int[] { Integer.MAX_VALUE }; }
+    @Provides boolean[] provideBoolean() { return new boolean[] { true }; }
+    @Provides long[] provideLong() { return new long[] { Long.MAX_VALUE }; }
+    @Provides char[] provideChar() { return new char[] { Character.MAX_VALUE }; }
+    @Provides float[] provideFloat() { return new float[] { Float.MAX_VALUE }; }
+    @Provides double[] provideDouble() { return new double[] { Double.MAX_VALUE }; }
+  }
+
+  @Test public void primitiveArrayTypesAllInjected() {
+    ArrayInjectable result = ObjectGraph.create(ByteArrayModule.class).get(ArrayInjectable.class);
+    assertThat(result).isNotNull();
+    assertThat(result.byteArray).isEqualTo(new byte[] { Byte.MAX_VALUE });
+    assertThat(result.integerArray).isEqualTo(new int[] { Integer.MAX_VALUE });
+    assertThat(result.booleanArray).isEqualTo(new boolean[] { true });
+    assertThat(result.charArray).isEqualTo(new char[] { Character.MAX_VALUE });
+    assertThat(result.longArray).isEqualTo(new long[] { Long.MAX_VALUE });
+    assertThat(result.floatArray).isEqualTo(new float[] { Float.MAX_VALUE });
+    assertThat(result.doubleArray).isEqualTo(new double[] { Double.MAX_VALUE });
+  }
+
+
+}
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 9782025..dd1b1ab 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -48,13 +48,21 @@
   <build>
     <plugins>
       <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.9</version>
         <configuration>
           <excludePackageNames>dagger.internal:dagger.internal.*</excludePackageNames>
         </configuration>
       </plugin>
+      <plugin>
+        <artifactId>maven-jar-plugin</artifactId>
+        <executions>
+          <execution>
+            <goals>
+              <goal>test-jar</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
     </plugins>
   </build>
 </project>
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java b/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
index 39e6191..8235ed2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
@@ -121,7 +121,12 @@
         return null;
       }
       @Override public Void visitArray(ArrayType arrayType, Void v) {
-        typeToString(arrayType.getComponentType(), result, innerClassSeparator);
+        TypeMirror type = arrayType.getComponentType();
+        if (type instanceof PrimitiveType) {
+          result.append(type.toString()); // Don't box, since this is an array.
+        } else {
+          typeToString(arrayType.getComponentType(), result, innerClassSeparator);
+        }
         result.append("[]");
         return null;
       }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java b/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
index 8235ed2..995623c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
@@ -1,5 +1,6 @@
 /*
- * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
index 1be3f2b..84956d5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
@@ -1,5 +1,6 @@
 /**
- * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index cb7b5e6..3a5ca8a 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -52,6 +52,13 @@
       <artifactId>fest-assert</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+      <classifier>tests</classifier>
+    </dependency>
   </dependencies>
 
   <build>
@@ -59,9 +66,26 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration>
-          <compilerArgument>-proc:none</compilerArgument>
-        </configuration>
+        <executions>
+          <execution>
+            <id>default-compile</id>
+            <goals><goal>compile</goal></goals>
+            <configuration>
+              <compilerArgument>-proc:none</compilerArgument>
+            </configuration>
+          </execution>
+          <execution>
+            <id>default-test-compile</id>
+            <goals><goal>testCompile</goal></goals>
+            <configuration>
+              <annotationProcessors>
+                <annotationProcessor>dagger.internal.codegen.InjectAdapterProcessor</annotationProcessor>
+                <annotationProcessor>dagger.internal.codegen.ModuleAdapterProcessor</annotationProcessor>
+                <annotationProcessor>dagger.internal.codegen.GraphAnalysisProcessor</annotationProcessor>
+              </annotationProcessors>
+            </configuration>
+          </execution>
+        </executions>
       </plugin>
 
       <plugin>
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java b/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
index 39e6191..995623c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
@@ -1,5 +1,6 @@
 /*
- * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -121,7 +122,12 @@
         return null;
       }
       @Override public Void visitArray(ArrayType arrayType, Void v) {
-        typeToString(arrayType.getComponentType(), result, innerClassSeparator);
+        TypeMirror type = arrayType.getComponentType();
+        if (type instanceof PrimitiveType) {
+          result.append(type.toString()); // Don't box, since this is an array.
+        } else {
+          typeToString(arrayType.getComponentType(), result, innerClassSeparator);
+        }
         result.append("[]");
         return null;
       }
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
new file mode 100644
index 0000000..ca82480
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
@@ -0,0 +1,61 @@
+/**
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import dagger.Provides;
+import javax.inject.Inject;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+public final class PrimitiveInjectionTest {
+  static class ArrayInjectable {
+    @Inject byte[] byteArray;
+    @Inject int[] integerArray;
+    @Inject boolean[] booleanArray;
+    @Inject char[] charArray;
+    @Inject long[] longArray;
+    @Inject float[] floatArray;
+    @Inject double[] doubleArray;
+  }
+
+  @Module(injects = ArrayInjectable.class)
+  static class PrimitiveArrayModule {
+    @Provides byte[] byteArray() { return new byte[] { Byte.MAX_VALUE }; }
+    @Provides int[] provideInt() { return new int[] { Integer.MAX_VALUE }; }
+    @Provides boolean[] provideBoolean() { return new boolean[] { true }; }
+    @Provides long[] provideLong() { return new long[] { Long.MAX_VALUE }; }
+    @Provides char[] provideChar() { return new char[] { Character.MAX_VALUE }; }
+    @Provides float[] provideFloat() { return new float[] { Float.MAX_VALUE }; }
+    @Provides double[] provideDouble() { return new double[] { Double.MAX_VALUE }; }
+  }
+
+  @Test public void primitiveArrayTypesAllInjected() {
+    ArrayInjectable result = ObjectGraph.create(PrimitiveArrayModule.class)
+        .get(ArrayInjectable.class);
+    assertThat(result).isNotNull();
+    assertThat(result.byteArray).isEqualTo(new byte[] { Byte.MAX_VALUE });
+    assertThat(result.integerArray).isEqualTo(new int[] { Integer.MAX_VALUE });
+    assertThat(result.booleanArray).isEqualTo(new boolean[] { true });
+    assertThat(result.charArray).isEqualTo(new char[] { Character.MAX_VALUE });
+    assertThat(result.longArray).isEqualTo(new long[] { Long.MAX_VALUE });
+    assertThat(result.floatArray).isEqualTo(new float[] { Float.MAX_VALUE });
+    assertThat(result.doubleArray).isEqualTo(new double[] { Double.MAX_VALUE });
+  }
+}
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 9782025..dd1b1ab 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -48,13 +48,21 @@
   <build>
     <plugins>
       <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.9</version>
         <configuration>
           <excludePackageNames>dagger.internal:dagger.internal.*</excludePackageNames>
         </configuration>
       </plugin>
+      <plugin>
+        <artifactId>maven-jar-plugin</artifactId>
+        <executions>
+          <execution>
+            <goals>
+              <goal>test-jar</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
     </plugins>
   </build>
 </project>
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
index ca82480..adeea2a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
@@ -21,9 +21,12 @@
 import dagger.Provides;
 import javax.inject.Inject;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.fest.assertions.Assertions.assertThat;
 
+@RunWith(JUnit4.class)
 public final class PrimitiveInjectionTest {
   static class ArrayInjectable {
     @Inject byte[] byteArray;
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java b/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
index 995623c..86ee6e5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
@@ -33,6 +33,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ErrorType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVariable;
@@ -135,6 +136,13 @@
         result.append(typeVariable.asElement().getSimpleName());
         return null;
       }
+      @Override public Void visitError(ErrorType errorType, Void v) {
+        // There's already an error but it may not have been reported (most likely
+        // a missing import). If we throw an UnsupportedOperationException here
+        // we'll obscure the real error, so just continue.
+        result.append("error");
+        return null;
+      }
       @Override protected Void defaultAction(TypeMirror typeMirror, Void v) {
         throw new UnsupportedOperationException(
             "Unexpected TypeKind " + typeMirror.getKind() + " for "  + typeMirror);
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index cd8206b..b3df601 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -96,6 +96,10 @@
       Map<String, Object> annotation = getAnnotation(Module.class, element);
       TypeElement moduleType = (TypeElement) element;
 
+      if (annotation == null) {
+        error("Missing @Module annotation.", moduleType);
+        continue;
+      }
       if (annotation.get("complete").equals(Boolean.TRUE)) {
         Map<String, Binding<?>> bindings;
         try {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java b/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
index 995623c..86ee6e5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
@@ -33,6 +33,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ErrorType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVariable;
@@ -135,6 +136,13 @@
         result.append(typeVariable.asElement().getSimpleName());
         return null;
       }
+      @Override public Void visitError(ErrorType errorType, Void v) {
+        // There's already an error but it may not have been reported (most likely
+        // a missing import). If we throw an UnsupportedOperationException here
+        // we'll obscure the real error, so just continue.
+        result.append("error");
+        return null;
+      }
       @Override protected Void defaultAction(TypeMirror typeMirror, Void v) {
         throw new UnsupportedOperationException(
             "Unexpected TypeKind " + typeMirror.getKind() + " for "  + typeMirror);
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
index ca82480..adeea2a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
@@ -21,9 +21,12 @@
 import dagger.Provides;
 import javax.inject.Inject;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.fest.assertions.Assertions.assertThat;
 
+@RunWith(JUnit4.class)
 public final class PrimitiveInjectionTest {
   static class ArrayInjectable {
     @Inject byte[] byteArray;
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index a9f1fd5..e9a3292 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -59,6 +59,18 @@
       <scope>test</scope>
       <classifier>tests</classifier>
     </dependency>
+    <dependency>
+      <groupId>com.google.testing.compile</groupId>
+      <artifactId>compile-testing</artifactId>
+      <version>0.1</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.truth0</groupId>
+      <artifactId>truth</artifactId>
+      <version>0.13</version>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 
   <build>
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index bb55063..cb2d34f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -18,6 +18,7 @@
 import dagger.Module;
 import dagger.Provides;
 import dagger.internal.Binding;
+import dagger.internal.Binding.InvalidBindingException;
 import dagger.internal.Linker;
 import dagger.internal.ProblemDetector;
 import dagger.internal.SetBinding;
@@ -45,6 +46,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 import javax.tools.FileObject;
@@ -89,7 +91,7 @@
 
     Set<Element> modules = new LinkedHashSet<Element>();
     for (String moduleName : delayedModuleNames) {
-      modules.add(processingEnv.getElementUtils().getTypeElement(moduleName));
+      modules.add(elements().getTypeElement(moduleName));
     }
 
     for (Element element : modules) {
@@ -108,7 +110,10 @@
         } catch (ModuleValidationException e) {
           error("Graph validation failed: " + e.getMessage(), e.source);
           continue;
-        } catch (IllegalStateException e) {
+        } catch (InvalidBindingException e) {
+          error("Graph validation failed: " + e.getMessage(), elements().getTypeElement(e.type));
+          continue;
+        } catch (RuntimeException e) {
           error("Graph validation failed: " + e.getMessage(), moduleType);
           continue;
         }
@@ -235,6 +240,10 @@
     }
   }
 
+  private Elements elements() {
+    return processingEnv.getElementUtils();
+  }
+
   private String shortMethodName(ExecutableElement method) {
     return method.getEnclosingElement().getSimpleName().toString()
         + "." + method.getSimpleName() + "()";
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/CyclicDependencyTest.java b/compiler/src/test/java/dagger/internal/codegen/CyclicDependencyTest.java
new file mode 100644
index 0000000..3a8eae2
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/CyclicDependencyTest.java
@@ -0,0 +1,87 @@
+/**
+ * Copyright (c) 2013 Google, Inc.
+ * Copyright (c) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public class CyclicDependencyTest {
+
+  @Test public void cyclicDepsWithInjectables() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("CyclicDeps", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import javax.inject.Inject;",
+        "class CyclicDeps {",
+        "  static class Foo {",
+        "    @Inject Foo(Bar b) { }",
+        "  }",
+        "  static class Bar {",
+        "    @Inject Bar(Blah b) { }",
+        "  }",
+        "  static class Blah {",
+        "    @Inject Blah(Foo f) { }",
+        "  }",
+        "  static class EntryPoint {",
+        "    @Inject Foo f;",
+        "  }",
+        "  @Module(injects = EntryPoint.class)",
+        "  static class TestModule { }",
+        "}"));
+
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining("0. CyclicDeps$Foo bound by").in(sourceFile).onLine(17).and()
+        .withErrorContaining("1. CyclicDeps$Bar bound by").in(sourceFile).onLine(17).and()
+        .withErrorContaining("2. CyclicDeps$Blah bound by").in(sourceFile).onLine(17);
+  }
+
+  @Test public void cyclicDepsWithProvidesMethods() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("CyclicDeps", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "class CyclicDeps {",
+        "  static class A { }",
+        "  static class B { }",
+        "  static class C { }",
+        "  static class D { }",
+        "  @Module(injects = D.class)",
+        "  static class CyclicModule {",
+        "    @Provides A a(D d) { return null; }",
+        "    @Provides B b(A a) { return null; }",
+        "    @Provides C c(B b) { return null; }",
+        "    @Provides D d(C c) { return null; }",
+        "  }",
+        "}"));
+
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining("0. CyclicDeps$A bound by Provider").in(sourceFile).onLine(9).and()
+        .withErrorContaining("1. CyclicDeps$D bound by Provider").in(sourceFile).onLine(9).and()
+        .withErrorContaining("2. CyclicDeps$C bound by Provider").in(sourceFile).onLine(9).and()
+        .withErrorContaining("3. CyclicDeps$B bound by Provider").in(sourceFile).onLine(9);
+  }
+
+}
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/CyclicModuleIncludesTest.java b/compiler/src/test/java/dagger/internal/codegen/CyclicModuleIncludesTest.java
new file mode 100644
index 0000000..a1d2b89
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/CyclicModuleIncludesTest.java
@@ -0,0 +1,85 @@
+/**
+ * Copyright (c) 2013 Google, Inc.
+ * Copyright (c) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public class CyclicModuleIncludesTest {
+  private final JavaFileObject javaFile =
+      JavaFileObjects.forSourceString("CyclicModules", Joiner.on("\n").join(
+          "import dagger.Module;",
+          "class CyclicModules {",
+          "  @Module(includes = SelfReferencingModule.class)",
+          "  static class SelfReferencingModule { }",
+          "  @Module(includes = Spock.class)",
+          "  static class Rock {}",
+          "  @Module(includes = Rock.class)",
+          "  static class Paper {}",
+          "  @Module(includes = Paper.class)",
+          "  static class Scissors {}",
+          "  @Module(includes = Scissors.class)",
+          "  static class Lizard {}",
+          "  @Module(includes = Lizard.class)",
+          "  static class Spock {}",
+          "}"));
+
+  @Test public void cyclicModuleSelfIncludes() {
+    ASSERT.about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining("CyclicModules.SelfReferencingModule includes itself directly")
+            .in(javaFile).onLine(4);
+  }
+
+  @Test public void cyclicModuleIncludes_full_cycle() {
+    ASSERT.about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining("0. CyclicModules.Rock included by CyclicModules.Paper")
+            .in(javaFile).onLine(6).and()
+        .withErrorContaining("1. CyclicModules.Paper included by CyclicModules.Scissors")
+            .in(javaFile).onLine(6).and()
+        .withErrorContaining("2. CyclicModules.Scissors included by CyclicModules.Lizard")
+            .in(javaFile).onLine(6).and()
+        .withErrorContaining("3. CyclicModules.Lizard included by CyclicModules.Spock")
+            .in(javaFile).onLine(6).and()
+        .withErrorContaining("4. CyclicModules.Spock included by CyclicModules.Rock")
+            .in(javaFile).onLine(6);
+  }
+
+  @Test public void cyclicModuleIncludes_initial_inclusion() {
+    ASSERT.about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining("0. CyclicModules.Rock included by CyclicModules.Paper")
+            .in(javaFile).onLine(6).and()
+        .withErrorContaining("0. CyclicModules.Paper included by CyclicModules.Scissors")
+            .in(javaFile).onLine(8).and()
+        .withErrorContaining("0. CyclicModules.Scissors included by CyclicModules.Lizard")
+            .in(javaFile).onLine(10).and()
+        .withErrorContaining("0. CyclicModules.Lizard included by CyclicModules.Spock")
+            .in(javaFile).onLine(12).and()
+        .withErrorContaining("0. CyclicModules.Spock included by CyclicModules.Rock")
+            .in(javaFile).onLine(14);
+  }
+
+
+}
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProcessorTestUtils.java b/compiler/src/test/java/dagger/internal/codegen/ProcessorTestUtils.java
new file mode 100644
index 0000000..645ba86
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ProcessorTestUtils.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2013 Google, Inc.
+ * Copyright (c) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import java.util.Arrays;
+import javax.annotation.processing.Processor;
+
+/**
+ * Internal test utilities.
+ */
+class ProcessorTestUtils {
+  static Iterable<? extends Processor> daggerProcessors() {
+    return Arrays.asList(
+        new InjectAdapterProcessor(),
+        new ModuleAdapterProcessor(),
+        new GraphAnalysisProcessor(),
+        new ValidationProcessor());
+  }
+}
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/ScopeAnnotationOnAbstractTypesTest.java b/compiler/src/test/java/dagger/internal/codegen/ScopeAnnotationOnAbstractTypesTest.java
new file mode 100644
index 0000000..88ba41f
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ScopeAnnotationOnAbstractTypesTest.java
@@ -0,0 +1,53 @@
+/**
+ * Copyright (c) 2013 Google, Inc.
+ * Copyright (c) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public class ScopeAnnotationOnAbstractTypesTest {
+  private final String SCOPING_ERROR_TEXT =
+      "Scoping annotations are only allowed on concrete types and @Provides methods:";
+
+  @Test public void scopeOnAbstract() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import javax.inject.Singleton;",
+        "class Test {",
+        "  @Module(library = true, injects = { AbstractClass.class, Interface.class })",
+        "  class TestModule { }",
+        "  @Singleton abstract class AbstractClass { }",
+        "  @Singleton interface Interface { }",
+        "}"));
+
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining(SCOPING_ERROR_TEXT).in(sourceFile).onLine(7).atColumn(14).and()
+        .withErrorContaining("Test.Interface").in(sourceFile).onLine(7).atColumn(14).and()
+        .withErrorContaining(SCOPING_ERROR_TEXT).in(sourceFile).onLine(6).atColumn(23).and()
+        .withErrorContaining("Test.AbstractClass").in(sourceFile).onLine(6).atColumn(23);
+  }
+}
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/SimpleMissingDependencyTest.java b/compiler/src/test/java/dagger/internal/codegen/SimpleMissingDependencyTest.java
new file mode 100644
index 0000000..b8773c4
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/SimpleMissingDependencyTest.java
@@ -0,0 +1,54 @@
+/**
+ * Copyright (c) 2013 Google, Inc.
+ * Copyright (c) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public class SimpleMissingDependencyTest {
+
+  @Test public void missingDependency() {
+    JavaFileObject file = JavaFileObjects.forSourceString("MissingDep", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import javax.inject.Inject;",
+        "class MissingDep {",
+        "  @Inject Dependency dep;",
+        "  static interface Dependency {",
+        "    void doit();",
+        "  }",
+        "  @Module(injects = MissingDep.class)",
+        "  static class DaModule {",
+        "    /* missing */ // @Provides Dependency a() { return new Dependency(); }",
+        "  }",
+        "}"));
+
+    ASSERT.about(javaSource())
+        .that(file).processedWith(daggerProcessors())
+        .failsToCompile()
+        .withErrorContaining("MissingDep$Dependency could not be bound").in(file).onLine(9).and()
+        .withErrorContaining("required by MissingDep for MissingDep.DaModule").in(file).onLine(9);
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/Binding.java b/core/src/main/java/dagger/internal/Binding.java
index 776d8c9..893dd95 100644
--- a/core/src/main/java/dagger/internal/Binding.java
+++ b/core/src/main/java/dagger/internal/Binding.java
@@ -63,7 +63,8 @@
 
   protected Binding(String provideKey, String membersKey, boolean singleton, Object requiredBy) {
     if (singleton && provideKey == null) {
-      throw new IllegalArgumentException();
+      throw new InvalidBindingException(Keys.getClassName(membersKey),
+          "is exclusively members injected and therefore cannot be scoped");
     }
     this.provideKey = provideKey;
     this.membersKey = membersKey;
@@ -149,4 +150,19 @@
     return getClass().getSimpleName()
             + "[provideKey=\"" + provideKey + "\", memberskey=\"" + membersKey + "\"]";
   }
+
+  /** An exception thrown by anything attempting to construct a binding which is invalid. */
+  public static class InvalidBindingException extends RuntimeException {
+    public final String type;
+
+    public InvalidBindingException(String type, String error) {
+      super(error);
+      this.type = type;
+    }
+
+    public InvalidBindingException(String type, String error, Throwable cause) {
+      super("Binding for " + type + " was invalid: " + error, cause);
+      this.type = type;
+    }
+  }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
index 3df9877..da7eeb2 100644
--- a/core/src/main/java/dagger/internal/Keys.java
+++ b/core/src/main/java/dagger/internal/Keys.java
@@ -144,7 +144,7 @@
         result.append("[]");
       } else if (c.isPrimitive()) {
         if (topLevel) {
-          throw new UnsupportedOperationException("Uninjectable type " + type);
+          throw new UnsupportedOperationException("Uninjectable type " + c.getName());
         }
         result.append(c.getName());
       } else {
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 59de824..86edaf5 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal;
 
+import dagger.internal.Binding.InvalidBindingException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.LinkedList;
@@ -118,15 +119,19 @@
           Binding<?> scopedJitBinding = scope(jitBinding);
           toLink.add(scopedJitBinding);
           putBinding(scopedJitBinding);
+        } catch (InvalidBindingException e) {
+          addError(e.type + " " + e.getMessage() + " required by " + binding.requiredBy);
+          bindings.put(key, Binding.UNRESOLVED);
+        } catch (UnsupportedOperationException e) {
+          addError("Unsupported: " + e.getMessage() + " required by " + binding.requiredBy);
+          bindings.put(key, Binding.UNRESOLVED);
+        } catch (IllegalArgumentException e) {
+          addError(e.getMessage() + " required by " + binding.requiredBy);
+          bindings.put(key, Binding.UNRESOLVED);
+        } catch (RuntimeException e) {
+          throw e;
         } catch (Exception e) {
-          if (e.getMessage() != null) {
-            addError(e.getMessage() + " required by " + binding.requiredBy);
-            bindings.put(key, Binding.UNRESOLVED);
-          } else if (e instanceof RuntimeException) {
-            throw (RuntimeException) e;
-          } else {
-            throw new RuntimeException(e);
-          }
+          throw new RuntimeException(e);
         }
       } else {
         // Attempt to attach the binding to its dependencies. If any dependency
@@ -187,8 +192,7 @@
         return binding;
       }
     }
-
-    throw new IllegalArgumentException("No binding for " + key);
+    throw new InvalidBindingException(className, "could not be bound with key " + key);
   }
 
   /** @deprecated Older, generated code still using this should be re-generated. */
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java b/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
index ed84a89..08f0264 100644
--- a/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
@@ -170,7 +170,7 @@
         continue;
       }
       if (injectedConstructor != null) {
-        throw new IllegalArgumentException("Too many injectable constructors on " + type.getName());
+        throw new InvalidBindingException(type.getName(), "has too many injectable constructors");
       }
       injectedConstructor = constructor;
     }
@@ -181,8 +181,8 @@
         } catch (NoSuchMethodException ignored) {
         }
       } else if (mustHaveInjections) {
-        throw new IllegalArgumentException("No injectable members on " + type.getName()
-            + ". Do you want to add an injectable constructor?");
+        throw new InvalidBindingException(type.getName(),
+            "has no injectable members. Do you want to add an injectable constructor?");
       }
     }
 
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index 09a5e58..ece3902 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -549,7 +549,7 @@
 
   @Test public void noProvideBindingsForAbstractClasses() {
     class TestEntryPoint {
-      @Inject AbstractList<?> abstractList;
+      @Inject AbstractList abstractList;
     }
 
     @Module(injects = TestEntryPoint.class)
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index a9f1fd5..e9a3292 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -59,6 +59,18 @@
       <scope>test</scope>
       <classifier>tests</classifier>
     </dependency>
+    <dependency>
+      <groupId>com.google.testing.compile</groupId>
+      <artifactId>compile-testing</artifactId>
+      <version>0.1</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.truth0</groupId>
+      <artifactId>truth</artifactId>
+      <version>0.13</version>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 
   <build>
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index bb55063..cb2d34f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -18,6 +18,7 @@
 import dagger.Module;
 import dagger.Provides;
 import dagger.internal.Binding;
+import dagger.internal.Binding.InvalidBindingException;
 import dagger.internal.Linker;
 import dagger.internal.ProblemDetector;
 import dagger.internal.SetBinding;
@@ -45,6 +46,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 import javax.tools.FileObject;
@@ -89,7 +91,7 @@
 
     Set<Element> modules = new LinkedHashSet<Element>();
     for (String moduleName : delayedModuleNames) {
-      modules.add(processingEnv.getElementUtils().getTypeElement(moduleName));
+      modules.add(elements().getTypeElement(moduleName));
     }
 
     for (Element element : modules) {
@@ -108,7 +110,10 @@
         } catch (ModuleValidationException e) {
           error("Graph validation failed: " + e.getMessage(), e.source);
           continue;
-        } catch (IllegalStateException e) {
+        } catch (InvalidBindingException e) {
+          error("Graph validation failed: " + e.getMessage(), elements().getTypeElement(e.type));
+          continue;
+        } catch (RuntimeException e) {
           error("Graph validation failed: " + e.getMessage(), moduleType);
           continue;
         }
@@ -235,6 +240,10 @@
     }
   }
 
+  private Elements elements() {
+    return processingEnv.getElementUtils();
+  }
+
   private String shortMethodName(ExecutableElement method) {
     return method.getEnclosingElement().getSimpleName().toString()
         + "." + method.getSimpleName() + "()";
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/CyclicDependencyTest.java b/compiler/src/test/java/dagger/internal/codegen/CyclicDependencyTest.java
new file mode 100644
index 0000000..9a8bb7c
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/CyclicDependencyTest.java
@@ -0,0 +1,85 @@
+/**
+ * Copyright (c) 2013 Google, Inc.
+ * Copyright (c) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public class CyclicDependencyTest {
+
+  @Test public void cyclicDepsWithInjectables() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("CyclicDeps", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import javax.inject.Inject;",
+        "class CyclicDeps {",
+        "  static class Foo {",
+        "    @Inject Foo(Bar b) { }",
+        "  }",
+        "  static class Bar {",
+        "    @Inject Bar(Blah b) { }",
+        "  }",
+        "  static class Blah {",
+        "    @Inject Blah(Foo f) { }",
+        "  }",
+        "  static class EntryPoint {",
+        "    @Inject Foo f;",
+        "  }",
+        "  @Module(injects = EntryPoint.class)",
+        "  static class TestModule { }",
+        "}"));
+
+    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining("0. CyclicDeps$Foo bound by").in(sourceFile).onLine(17).and()
+        .withErrorContaining("1. CyclicDeps$Bar bound by").in(sourceFile).onLine(17).and()
+        .withErrorContaining("2. CyclicDeps$Blah bound by").in(sourceFile).onLine(17);
+  }
+
+  @Test public void cyclicDepsWithProvidesMethods() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("CyclicDeps", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "class CyclicDeps {",
+        "  static class A { }",
+        "  static class B { }",
+        "  static class C { }",
+        "  static class D { }",
+        "  @Module(injects = D.class)",
+        "  static class CyclicModule {",
+        "    @Provides A a(D d) { return null; }",
+        "    @Provides B b(A a) { return null; }",
+        "    @Provides C c(B b) { return null; }",
+        "    @Provides D d(C c) { return null; }",
+        "  }",
+        "}"));
+
+    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining("0. CyclicDeps$A bound by Provider").in(sourceFile).onLine(9).and()
+        .withErrorContaining("1. CyclicDeps$D bound by Provider").in(sourceFile).onLine(9).and()
+        .withErrorContaining("2. CyclicDeps$C bound by Provider").in(sourceFile).onLine(9).and()
+        .withErrorContaining("3. CyclicDeps$B bound by Provider").in(sourceFile).onLine(9);
+  }
+
+}
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/CyclicModuleIncludesTest.java b/compiler/src/test/java/dagger/internal/codegen/CyclicModuleIncludesTest.java
new file mode 100644
index 0000000..a1d2b89
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/CyclicModuleIncludesTest.java
@@ -0,0 +1,85 @@
+/**
+ * Copyright (c) 2013 Google, Inc.
+ * Copyright (c) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public class CyclicModuleIncludesTest {
+  private final JavaFileObject javaFile =
+      JavaFileObjects.forSourceString("CyclicModules", Joiner.on("\n").join(
+          "import dagger.Module;",
+          "class CyclicModules {",
+          "  @Module(includes = SelfReferencingModule.class)",
+          "  static class SelfReferencingModule { }",
+          "  @Module(includes = Spock.class)",
+          "  static class Rock {}",
+          "  @Module(includes = Rock.class)",
+          "  static class Paper {}",
+          "  @Module(includes = Paper.class)",
+          "  static class Scissors {}",
+          "  @Module(includes = Scissors.class)",
+          "  static class Lizard {}",
+          "  @Module(includes = Lizard.class)",
+          "  static class Spock {}",
+          "}"));
+
+  @Test public void cyclicModuleSelfIncludes() {
+    ASSERT.about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining("CyclicModules.SelfReferencingModule includes itself directly")
+            .in(javaFile).onLine(4);
+  }
+
+  @Test public void cyclicModuleIncludes_full_cycle() {
+    ASSERT.about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining("0. CyclicModules.Rock included by CyclicModules.Paper")
+            .in(javaFile).onLine(6).and()
+        .withErrorContaining("1. CyclicModules.Paper included by CyclicModules.Scissors")
+            .in(javaFile).onLine(6).and()
+        .withErrorContaining("2. CyclicModules.Scissors included by CyclicModules.Lizard")
+            .in(javaFile).onLine(6).and()
+        .withErrorContaining("3. CyclicModules.Lizard included by CyclicModules.Spock")
+            .in(javaFile).onLine(6).and()
+        .withErrorContaining("4. CyclicModules.Spock included by CyclicModules.Rock")
+            .in(javaFile).onLine(6);
+  }
+
+  @Test public void cyclicModuleIncludes_initial_inclusion() {
+    ASSERT.about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining("0. CyclicModules.Rock included by CyclicModules.Paper")
+            .in(javaFile).onLine(6).and()
+        .withErrorContaining("0. CyclicModules.Paper included by CyclicModules.Scissors")
+            .in(javaFile).onLine(8).and()
+        .withErrorContaining("0. CyclicModules.Scissors included by CyclicModules.Lizard")
+            .in(javaFile).onLine(10).and()
+        .withErrorContaining("0. CyclicModules.Lizard included by CyclicModules.Spock")
+            .in(javaFile).onLine(12).and()
+        .withErrorContaining("0. CyclicModules.Spock included by CyclicModules.Rock")
+            .in(javaFile).onLine(14);
+  }
+
+
+}
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectAdapterGenerationTest.java
new file mode 100644
index 0000000..0ced01d
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectAdapterGenerationTest.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2013 Google Inc.
+ * Copyright (C) 2013 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public final class InjectAdapterGenerationTest {
+  @Test public void basicInjectAdapter() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Basic", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import javax.inject.Inject;",
+        "class Basic {",
+        "  static class A { @Inject A() { } }",
+        "  @Module(injects = A.class)",
+        "  static class CyclicModule { }",
+        "}"));
+
+    JavaFileObject expectedModuleAdapter =
+        JavaFileObjects.forSourceString("Basic$A$$InjectAdapter", Joiner.on("\n").join(
+            "import dagger.internal.ModuleAdapter;",
+            "public final class Basic$CyclicModule$$ModuleAdapter",
+            "    extends ModuleAdapter<Basic.CyclicModule> {",
+            "  private static final String[] INJECTS = {\"members/Basic$A\"};",
+            "  private static final Class<?>[] STATIC_INJECTIONS = {};",
+            "  private static final Class<?>[] INCLUDES = {};",
+            "  public Basic$CyclicModule$$ModuleAdapter() {",
+            "    super(INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
+            "  }",
+            "  @Override public Basic.CyclicModule newModule() {",
+            "    return new Basic.CyclicModule();",
+            "  }",
+            "}"));
+
+    JavaFileObject expectedInjectAdapter =
+        JavaFileObjects.forSourceString("Basic$A$$InjectAdapter", Joiner.on("\n").join(
+            "import dagger.internal.Binding;",
+            "import javax.inject.Provider;",
+            "public final class Basic$A$$InjectAdapter",
+            "    extends Binding<Basic.A> implements Provider<Basic.A> {",
+            "  public Basic$A$$InjectAdapter() {",
+            "    super(\"Basic$A\", \"members/Basic$A\", NOT_SINGLETON, Basic.A.class);",
+            "  }",
+            "  @Override public Basic.A get() {",
+            "    Basic.A result = new Basic.A();",
+            "    return result;",
+            "  }",
+            "}"));
+
+    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
+        .compilesWithoutError().and()
+        .generatesSources(expectedModuleAdapter, expectedInjectAdapter);
+
+  }
+}
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/LibraryModuleTest.java b/compiler/src/test/java/dagger/internal/codegen/LibraryModuleTest.java
new file mode 100644
index 0000000..703aa69
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/LibraryModuleTest.java
@@ -0,0 +1,66 @@
+/**
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public final class LibraryModuleTest {
+  @Test public void unusedProviderMethodsPassOnLibrary() {
+    JavaFileObject source = JavaFileObjects.forSourceString("Library", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.ObjectGraph;",
+        "import dagger.Provides;",
+        "import java.lang.Override;",
+        "@Module(library = true)",
+        "class TestModule {",
+        "  @Provides String string() {",
+        "    return \"string\";",
+        "  }",
+        "}"));
+    ASSERT.about(javaSource())
+        .that(source).processedWith(daggerProcessors()).compilesWithoutError();
+  }
+
+  @Test public void unusedProviderMethodsFailOnNonLibrary() {
+    JavaFileObject source = JavaFileObjects.forSourceString("Library", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.ObjectGraph;",
+        "import dagger.Provides;",
+        "import java.lang.Override;",
+        "@Module(library = false)",
+        "class TestModule {",
+        "  @Provides String string() {",
+        "    return \"string\";",
+        "  }",
+        "}"));
+    ASSERT.about(javaSource()).that(source).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining("Graph validation failed:").in(source).onLine(6).and()
+        .withErrorContaining("You have these unused @Provider methods:").in(source).onLine(6).and()
+        .withErrorContaining("1. TestModule.string()").in(source).onLine(6).and()
+        .withErrorContaining("Set library=true in your module").in(source).onLine(6);
+  }
+}
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProcessorTestUtils.java b/compiler/src/test/java/dagger/internal/codegen/ProcessorTestUtils.java
new file mode 100644
index 0000000..645ba86
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ProcessorTestUtils.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2013 Google, Inc.
+ * Copyright (c) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import java.util.Arrays;
+import javax.annotation.processing.Processor;
+
+/**
+ * Internal test utilities.
+ */
+class ProcessorTestUtils {
+  static Iterable<? extends Processor> daggerProcessors() {
+    return Arrays.asList(
+        new InjectAdapterProcessor(),
+        new ModuleAdapterProcessor(),
+        new GraphAnalysisProcessor(),
+        new ValidationProcessor());
+  }
+}
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/ScopeAnnotationOnAbstractTypesTest.java b/compiler/src/test/java/dagger/internal/codegen/ScopeAnnotationOnAbstractTypesTest.java
new file mode 100644
index 0000000..88ba41f
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ScopeAnnotationOnAbstractTypesTest.java
@@ -0,0 +1,53 @@
+/**
+ * Copyright (c) 2013 Google, Inc.
+ * Copyright (c) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public class ScopeAnnotationOnAbstractTypesTest {
+  private final String SCOPING_ERROR_TEXT =
+      "Scoping annotations are only allowed on concrete types and @Provides methods:";
+
+  @Test public void scopeOnAbstract() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import javax.inject.Singleton;",
+        "class Test {",
+        "  @Module(library = true, injects = { AbstractClass.class, Interface.class })",
+        "  class TestModule { }",
+        "  @Singleton abstract class AbstractClass { }",
+        "  @Singleton interface Interface { }",
+        "}"));
+
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining(SCOPING_ERROR_TEXT).in(sourceFile).onLine(7).atColumn(14).and()
+        .withErrorContaining("Test.Interface").in(sourceFile).onLine(7).atColumn(14).and()
+        .withErrorContaining(SCOPING_ERROR_TEXT).in(sourceFile).onLine(6).atColumn(23).and()
+        .withErrorContaining("Test.AbstractClass").in(sourceFile).onLine(6).atColumn(23);
+  }
+}
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/SimpleMissingDependencyTest.java b/compiler/src/test/java/dagger/internal/codegen/SimpleMissingDependencyTest.java
new file mode 100644
index 0000000..b8773c4
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/SimpleMissingDependencyTest.java
@@ -0,0 +1,54 @@
+/**
+ * Copyright (c) 2013 Google, Inc.
+ * Copyright (c) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public class SimpleMissingDependencyTest {
+
+  @Test public void missingDependency() {
+    JavaFileObject file = JavaFileObjects.forSourceString("MissingDep", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import javax.inject.Inject;",
+        "class MissingDep {",
+        "  @Inject Dependency dep;",
+        "  static interface Dependency {",
+        "    void doit();",
+        "  }",
+        "  @Module(injects = MissingDep.class)",
+        "  static class DaModule {",
+        "    /* missing */ // @Provides Dependency a() { return new Dependency(); }",
+        "  }",
+        "}"));
+
+    ASSERT.about(javaSource())
+        .that(file).processedWith(daggerProcessors())
+        .failsToCompile()
+        .withErrorContaining("MissingDep$Dependency could not be bound").in(file).onLine(9).and()
+        .withErrorContaining("required by MissingDep for MissingDep.DaModule").in(file).onLine(9);
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/Binding.java b/core/src/main/java/dagger/internal/Binding.java
index 776d8c9..893dd95 100644
--- a/core/src/main/java/dagger/internal/Binding.java
+++ b/core/src/main/java/dagger/internal/Binding.java
@@ -63,7 +63,8 @@
 
   protected Binding(String provideKey, String membersKey, boolean singleton, Object requiredBy) {
     if (singleton && provideKey == null) {
-      throw new IllegalArgumentException();
+      throw new InvalidBindingException(Keys.getClassName(membersKey),
+          "is exclusively members injected and therefore cannot be scoped");
     }
     this.provideKey = provideKey;
     this.membersKey = membersKey;
@@ -149,4 +150,19 @@
     return getClass().getSimpleName()
             + "[provideKey=\"" + provideKey + "\", memberskey=\"" + membersKey + "\"]";
   }
+
+  /** An exception thrown by anything attempting to construct a binding which is invalid. */
+  public static class InvalidBindingException extends RuntimeException {
+    public final String type;
+
+    public InvalidBindingException(String type, String error) {
+      super(error);
+      this.type = type;
+    }
+
+    public InvalidBindingException(String type, String error, Throwable cause) {
+      super("Binding for " + type + " was invalid: " + error, cause);
+      this.type = type;
+    }
+  }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
index 3df9877..da7eeb2 100644
--- a/core/src/main/java/dagger/internal/Keys.java
+++ b/core/src/main/java/dagger/internal/Keys.java
@@ -144,7 +144,7 @@
         result.append("[]");
       } else if (c.isPrimitive()) {
         if (topLevel) {
-          throw new UnsupportedOperationException("Uninjectable type " + type);
+          throw new UnsupportedOperationException("Uninjectable type " + c.getName());
         }
         result.append(c.getName());
       } else {
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 59de824..86edaf5 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal;
 
+import dagger.internal.Binding.InvalidBindingException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.LinkedList;
@@ -118,15 +119,19 @@
           Binding<?> scopedJitBinding = scope(jitBinding);
           toLink.add(scopedJitBinding);
           putBinding(scopedJitBinding);
+        } catch (InvalidBindingException e) {
+          addError(e.type + " " + e.getMessage() + " required by " + binding.requiredBy);
+          bindings.put(key, Binding.UNRESOLVED);
+        } catch (UnsupportedOperationException e) {
+          addError("Unsupported: " + e.getMessage() + " required by " + binding.requiredBy);
+          bindings.put(key, Binding.UNRESOLVED);
+        } catch (IllegalArgumentException e) {
+          addError(e.getMessage() + " required by " + binding.requiredBy);
+          bindings.put(key, Binding.UNRESOLVED);
+        } catch (RuntimeException e) {
+          throw e;
         } catch (Exception e) {
-          if (e.getMessage() != null) {
-            addError(e.getMessage() + " required by " + binding.requiredBy);
-            bindings.put(key, Binding.UNRESOLVED);
-          } else if (e instanceof RuntimeException) {
-            throw (RuntimeException) e;
-          } else {
-            throw new RuntimeException(e);
-          }
+          throw new RuntimeException(e);
         }
       } else {
         // Attempt to attach the binding to its dependencies. If any dependency
@@ -187,8 +192,7 @@
         return binding;
       }
     }
-
-    throw new IllegalArgumentException("No binding for " + key);
+    throw new InvalidBindingException(className, "could not be bound with key " + key);
   }
 
   /** @deprecated Older, generated code still using this should be re-generated. */
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java b/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
index ed84a89..08f0264 100644
--- a/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
@@ -170,7 +170,7 @@
         continue;
       }
       if (injectedConstructor != null) {
-        throw new IllegalArgumentException("Too many injectable constructors on " + type.getName());
+        throw new InvalidBindingException(type.getName(), "has too many injectable constructors");
       }
       injectedConstructor = constructor;
     }
@@ -181,8 +181,8 @@
         } catch (NoSuchMethodException ignored) {
         }
       } else if (mustHaveInjections) {
-        throw new IllegalArgumentException("No injectable members on " + type.getName()
-            + ". Do you want to add an injectable constructor?");
+        throw new InvalidBindingException(type.getName(),
+            "has no injectable members. Do you want to add an injectable constructor?");
       }
     }
 
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index 09a5e58..ece3902 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -549,7 +549,7 @@
 
   @Test public void noProvideBindingsForAbstractClasses() {
     class TestEntryPoint {
-      @Inject AbstractList<?> abstractList;
+      @Inject AbstractList abstractList;
     }
 
     @Module(injects = TestEntryPoint.class)
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index e9a3292..8eb2534 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -62,7 +62,7 @@
     <dependency>
       <groupId>com.google.testing.compile</groupId>
       <artifactId>compile-testing</artifactId>
-      <version>0.1</version>
+      <version>0.2-SNAPSHOT</version>
       <scope>test</scope>
     </dependency>
     <dependency>
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProcessorTestUtils.java b/compiler/src/test/java/dagger/tests/integration/ProcessorTestUtils.java
similarity index 72%
rename from compiler/src/test/java/dagger/internal/codegen/ProcessorTestUtils.java
rename to compiler/src/test/java/dagger/tests/integration/ProcessorTestUtils.java
index 645ba86..12ff02d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProcessorTestUtils.java
+++ b/compiler/src/test/java/dagger/tests/integration/ProcessorTestUtils.java
@@ -14,16 +14,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.tests.integration;
 
+import dagger.internal.codegen.GraphAnalysisProcessor;
+import dagger.internal.codegen.InjectAdapterProcessor;
+import dagger.internal.codegen.ModuleAdapterProcessor;
+import dagger.internal.codegen.ValidationProcessor;
 import java.util.Arrays;
 import javax.annotation.processing.Processor;
 
 /**
  * Internal test utilities.
  */
-class ProcessorTestUtils {
-  static Iterable<? extends Processor> daggerProcessors() {
+public class ProcessorTestUtils {
+  public static Iterable<? extends Processor> daggerProcessors() {
     return Arrays.asList(
         new InjectAdapterProcessor(),
         new ModuleAdapterProcessor(),
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
similarity index 96%
rename from compiler/src/test/java/dagger/internal/codegen/InjectAdapterGenerationTest.java
rename to compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index 0ced01d..9030479 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.tests.integration.codegen;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -24,7 +24,7 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/CyclicDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
similarity index 96%
rename from compiler/src/test/java/dagger/internal/codegen/CyclicDependencyTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
index 9a8bb7c..a18762d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/CyclicDependencyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.tests.integration.validation;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -24,7 +24,7 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/CyclicModuleIncludesTest.java b/compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java
similarity index 96%
rename from compiler/src/test/java/dagger/internal/codegen/CyclicModuleIncludesTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java
index a1d2b89..a152518 100644
--- a/compiler/src/test/java/dagger/internal/codegen/CyclicModuleIncludesTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.tests.integration.validation;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -24,7 +24,7 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/LibraryModuleTest.java b/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
similarity index 95%
rename from compiler/src/test/java/dagger/internal/codegen/LibraryModuleTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
index 703aa69..7a368a3 100644
--- a/compiler/src/test/java/dagger/internal/codegen/LibraryModuleTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.tests.integration.validation;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -24,7 +24,7 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/ScopeAnnotationOnAbstractTypesTest.java b/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationOnAbstractTypesTest.java
similarity index 94%
rename from compiler/src/test/java/dagger/internal/codegen/ScopeAnnotationOnAbstractTypesTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationOnAbstractTypesTest.java
index 88ba41f..705f9ba 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ScopeAnnotationOnAbstractTypesTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationOnAbstractTypesTest.java
@@ -14,7 +14,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.tests.integration.validation;
+
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -24,7 +26,6 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
 import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/SimpleMissingDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java
similarity index 93%
rename from compiler/src/test/java/dagger/internal/codegen/SimpleMissingDependencyTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java
index b8773c4..5dfe21f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SimpleMissingDependencyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.tests.integration.validation;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -24,7 +24,7 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationOnAbstractTypesTest.java b/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationAbuseTest.java
similarity index 64%
rename from compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationOnAbstractTypesTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationAbuseTest.java
index 705f9ba..9979167 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationOnAbstractTypesTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationAbuseTest.java
@@ -16,8 +16,6 @@
  */
 package dagger.tests.integration.validation;
 
-import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
-
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -26,29 +24,43 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
-public class ScopeAnnotationOnAbstractTypesTest {
-  private final String SCOPING_ERROR_TEXT =
+public class ScopeAnnotationAbuseTest {
+  private static final String ABSTRACTION_SCOPING_TEXT =
       "Scoping annotations are only allowed on concrete types and @Provides methods:";
 
-  @Test public void scopeOnAbstract() {
+  @Test public void compileFailsWithScopeOnInterface() {
     JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
         "import dagger.Module;",
         "import javax.inject.Singleton;",
         "class Test {",
-        "  @Module(library = true, injects = { AbstractClass.class, Interface.class })",
-        "  class TestModule { }",
-        "  @Singleton abstract class AbstractClass { }",
+        "  @Module(library = true, injects = Interface.class) class TestModule { }",
         "  @Singleton interface Interface { }",
         "}"));
 
     ASSERT.about(javaSource())
         .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining(SCOPING_ERROR_TEXT).in(sourceFile).onLine(7).atColumn(14).and()
-        .withErrorContaining("Test.Interface").in(sourceFile).onLine(7).atColumn(14).and()
-        .withErrorContaining(SCOPING_ERROR_TEXT).in(sourceFile).onLine(6).atColumn(23).and()
-        .withErrorContaining("Test.AbstractClass").in(sourceFile).onLine(6).atColumn(23);
+        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(14).and()
+        .withErrorContaining("Test.Interface").in(sourceFile).onLine(5).atColumn(14);
   }
+
+  @Test public void compileFailsWithScopeOnAbstractClass() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import javax.inject.Singleton;",
+        "class Test {",
+        "  @Module(library = true, injects = AbstractClass.class) class TestModule { }",
+        "  @Singleton abstract class AbstractClass { }",
+        "}"));
+
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(23).and()
+        .withErrorContaining("Test.AbstractClass").in(sourceFile).onLine(5).atColumn(23);
+  }
+  
+  
 }
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationAbuseTest.java b/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationAbuseTest.java
index 9979167..3990951 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationAbuseTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationAbuseTest.java
@@ -27,24 +27,31 @@
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static org.truth0.Truth.ASSERT;
 
+/**
+ * Integration tests for the validation processors related to the use
+ * of Scoping Annotations.
+ */
+// TODO(cgruber): Audit this class when compile-testing has error/warning counts available.
 @RunWith(JUnit4.class)
 public class ScopeAnnotationAbuseTest {
   private static final String ABSTRACTION_SCOPING_TEXT =
       "Scoping annotations are only allowed on concrete types and @Provides methods:";
+  private static final String MISUSED_SCOPE_TEXT =
+      "Dagger will ignore scoping annotations on methods that are not @Provides methods:";
 
   @Test public void compileFailsWithScopeOnInterface() {
     JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
         "import dagger.Module;",
         "import javax.inject.Singleton;",
         "class Test {",
-        "  @Module(library = true, injects = Interface.class) class TestModule { }",
-        "  @Singleton interface Interface { }",
+        "  @Module(injects = TestType.class) class TestModule { }",
+        "  @Singleton interface TestType { }",
         "}"));
 
     ASSERT.about(javaSource())
         .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
         .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(14).and()
-        .withErrorContaining("Test.Interface").in(sourceFile).onLine(5).atColumn(14);
+        .withErrorContaining("Test.TestType").in(sourceFile).onLine(5).atColumn(14);
   }
 
   @Test public void compileFailsWithScopeOnAbstractClass() {
@@ -52,15 +59,157 @@
         "import dagger.Module;",
         "import javax.inject.Singleton;",
         "class Test {",
-        "  @Module(library = true, injects = AbstractClass.class) class TestModule { }",
-        "  @Singleton abstract class AbstractClass { }",
+        "  @Module(injects = TestType.class) class TestModule { }",
+        "  @Singleton abstract class TestType { }",
         "}"));
 
     ASSERT.about(javaSource())
         .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
         .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(23).and()
-        .withErrorContaining("Test.AbstractClass").in(sourceFile).onLine(5).atColumn(23);
+        .withErrorContaining("Test.TestType").in(sourceFile).onLine(5).atColumn(23);
   }
-  
-  
+
+  @Test public void compileFailsWithScopeOnField() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Singleton;",
+        "class Test {",
+        "  @Singleton String field;",
+        "  @Inject public Test() { }",
+        "  @Module(injects = Test.class) class TestModule { }",
+        "}"));
+
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(21).and()
+        .withErrorContaining("Test.field").in(sourceFile).onLine(5).atColumn(21);
+  }
+
+  @Test public void compileFailsWithScopeOnMethodParameter() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "@Module(library = true, injects = String.class)",
+        "class Test {",
+        "  @Provides int provideInteger() { return 0; }",
+        "  @Provides String provideString(@Singleton int intParam) { return \"\"; }",
+        "}"));
+
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(7).atColumn(49).and()
+        .withErrorContaining("intParam").in(sourceFile).onLine(7).atColumn(49);
+  }
+
+  @Test public void compileFailsWithScopeOnConstructor() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Singleton;",
+        "class Test {",
+        "  @Singleton @Inject public Test() { }",
+        "  @Module(injects = Test.class) class TestModule { }",
+        "}"));
+
+   String singletonErrorText = ""
+   	    + "Singleton annotations have no effect on constructors. "
+   	    + "Did you mean to annotate the class?";
+
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(29).and()
+        .withErrorContaining("Test.Test()").in(sourceFile).onLine(5).atColumn(29).and()
+        .withErrorContaining(singletonErrorText).in(sourceFile).onLine(6).atColumn(33);
+  }
+
+  @Test public void compileWarnsWithScopedNonProvidesMethod() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import javax.inject.Singleton;",
+        "class Test {",
+        "  @Singleton void method() { }",
+        "}"));
+
+    // TODO(cgruber): uncomment warning predicates when compile-testing has them.
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
+        //.withWarningContaining(MISUSED_SCOPE_TEXT).in(sourceFile).onLine(3).atColumn(49).and()
+        //.withWarningContaining("Test.method()").in(sourceFile).onLine(3).atColumn(49);
+  }
+
+  @Test public void compileWarnsWithScopedIncorrectlySuppressedNonProvidesMethod() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import javax.inject.Singleton;",
+        "class Test {",
+        "  @SuppressWarnings(\"some string other than 'scoping'\")",
+        "  @Singleton void method() { }",
+        "}"));
+
+    // TODO(cgruber): uncomment warning predicates when compile-testing has them.
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
+        //.withWarningContaining(MISUSED_SCOPE_TEXT).in(sourceFile).onLine(4).atColumn(49).and()
+        //.withWarningContaining("Test.method()").in(sourceFile).onLine(4).atColumn(49);
+  }
+
+  @Test public void compileSucceedsWithScopedSuppressedNonProvidesMethod() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import javax.inject.Singleton;",
+        "class Test {",
+        "  @SuppressWarnings(\"scoping\")",
+        "  @Singleton void method() { }",
+        "}"));
+
+    // TODO(cgruber): uncomment warning predicates when compile-testing has them.
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
+        //.and().hasNoWarnings();
+  }
+
+  @Test public void compileSucceedsWithScopedMultiplySuppressedNonProvidesMethod() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import javax.inject.Singleton;",
+        "class Test {",
+        "  @SuppressWarnings({\"blah\", \"scoping\", \"foo\"})",
+        "  @Singleton void method() { }",
+        "}"));
+
+    // TODO(cgruber): uncomment warning predicates when compile-testing has them.
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
+        //.and().hasNoWarnings();
+  }
+
+  @Test public void compileSucceedsScopeOnConcreteType() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import javax.inject.Inject;",
+        "import javax.inject.Singleton;",
+        "@Singleton",
+        "class Test {",
+        "  @Inject public Test() { }",
+        "}"));
+
+    // TODO(cgruber): uncomment warning predicates when compile-testing has them.
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
+        //.and().hasNoWarnings();
+  }
+
+  @Test public void compileSucceedsScopeOnProvidesMethod() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "@Module(library = true, injects = String.class)",
+        "class Test {",
+        "  @Provides @Singleton public String provideString() { return \"\"; }",
+        "}"));
+
+    // TODO(cgruber): uncomment warning predicates when compile-testing has them.
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
+        //.and().hasNoWarnings();
+  }
+
 }
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 8eb2534..e9a3292 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -62,7 +62,7 @@
     <dependency>
       <groupId>com.google.testing.compile</groupId>
       <artifactId>compile-testing</artifactId>
-      <version>0.2-SNAPSHOT</version>
+      <version>0.1</version>
       <scope>test</scope>
     </dependency>
     <dependency>
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationAbuseTest.java b/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java
similarity index 99%
rename from compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationAbuseTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java
index 3990951..2ac52ef 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationAbuseTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java
@@ -33,7 +33,7 @@
  */
 // TODO(cgruber): Audit this class when compile-testing has error/warning counts available.
 @RunWith(JUnit4.class)
-public class ScopeAnnotationAbuseTest {
+public class ScopeAnnotationUseTest {
   private static final String ABSTRACTION_SCOPING_TEXT =
       "Scoping annotations are only allowed on concrete types and @Provides methods:";
   private static final String MISUSED_SCOPE_TEXT =
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java b/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java
index 2ac52ef..88d4ff5 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java
@@ -24,7 +24,9 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static java.util.Arrays.asList;
 import static org.truth0.Truth.ASSERT;
 
 /**
@@ -103,6 +105,38 @@
         .withErrorContaining("intParam").in(sourceFile).onLine(7).atColumn(49);
   }
 
+  @Test public void compileFailsWithMultipleScopeAnnotations() {
+    JavaFileObject annotation = JavaFileObjects.forSourceString("MyScope", Joiner.on("\n").join(
+        "import java.lang.annotation.Retention;",
+        "import javax.inject.Scope;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "@Scope @Retention(RUNTIME) public @interface MyScope { }"));
+
+    JavaFileObject module = JavaFileObjects.forSourceString("MyModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "@Module(library = true, injects = Injectable.class)",
+        "class MyModule {",
+        "  @Provides @Singleton @MyScope String method() { return \"\"; }",
+        "}"));
+
+    JavaFileObject injectable = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import javax.inject.Inject;",
+        "import javax.inject.Singleton;",
+        "@Singleton @MyScope",
+        "class Injectable {",
+        "  @Inject String string;",
+        "}"));
+
+    String error = "Only one scoping annotation is allowed per element: ";
+
+    ASSERT.about(javaSources()).that(asList(annotation, module, injectable))
+        .processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining(error + "MyModule.method()").in(module).onLine(6).atColumn(40).and()
+        .withErrorContaining(error + "Injectable").in(injectable).onLine(4).atColumn(1);
+  }
+
   @Test public void compileFailsWithScopeOnConstructor() {
     JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
         "import dagger.Module;",
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProcessorTestUtils.java b/compiler/src/test/java/dagger/tests/integration/ProcessorTestUtils.java
similarity index 72%
rename from compiler/src/test/java/dagger/internal/codegen/ProcessorTestUtils.java
rename to compiler/src/test/java/dagger/tests/integration/ProcessorTestUtils.java
index 645ba86..12ff02d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProcessorTestUtils.java
+++ b/compiler/src/test/java/dagger/tests/integration/ProcessorTestUtils.java
@@ -14,16 +14,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.tests.integration;
 
+import dagger.internal.codegen.GraphAnalysisProcessor;
+import dagger.internal.codegen.InjectAdapterProcessor;
+import dagger.internal.codegen.ModuleAdapterProcessor;
+import dagger.internal.codegen.ValidationProcessor;
 import java.util.Arrays;
 import javax.annotation.processing.Processor;
 
 /**
  * Internal test utilities.
  */
-class ProcessorTestUtils {
-  static Iterable<? extends Processor> daggerProcessors() {
+public class ProcessorTestUtils {
+  public static Iterable<? extends Processor> daggerProcessors() {
     return Arrays.asList(
         new InjectAdapterProcessor(),
         new ModuleAdapterProcessor(),
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
similarity index 96%
rename from compiler/src/test/java/dagger/internal/codegen/InjectAdapterGenerationTest.java
rename to compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index 0ced01d..9030479 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.tests.integration.codegen;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -24,7 +24,7 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/CyclicDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
similarity index 96%
rename from compiler/src/test/java/dagger/internal/codegen/CyclicDependencyTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
index 9a8bb7c..a18762d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/CyclicDependencyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.tests.integration.validation;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -24,7 +24,7 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/CyclicModuleIncludesTest.java b/compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java
similarity index 96%
rename from compiler/src/test/java/dagger/internal/codegen/CyclicModuleIncludesTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java
index a1d2b89..a152518 100644
--- a/compiler/src/test/java/dagger/internal/codegen/CyclicModuleIncludesTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.tests.integration.validation;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -24,7 +24,7 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/LibraryModuleTest.java b/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
similarity index 95%
rename from compiler/src/test/java/dagger/internal/codegen/LibraryModuleTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
index 703aa69..7a368a3 100644
--- a/compiler/src/test/java/dagger/internal/codegen/LibraryModuleTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.tests.integration.validation;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -24,7 +24,7 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java b/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java
new file mode 100644
index 0000000..61b1737
--- /dev/null
+++ b/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java
@@ -0,0 +1,252 @@
+/**
+ * Copyright (c) 2013 Google, Inc.
+ * Copyright (c) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.tests.integration.validation;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static java.util.Arrays.asList;
+import static org.truth0.Truth.ASSERT;
+
+/**
+ * Integration tests for the validation processors related to the use
+ * of Scoping Annotations.
+ */
+// TODO(cgruber): Audit this class when http://github.com/google/compile-testing
+//                has error/warning counts and other warning predicates available.
+@RunWith(JUnit4.class)
+public class ScopeAnnotationUseTest {
+  private static final String ABSTRACTION_SCOPING_TEXT =
+      "Scoping annotations are only allowed on concrete types and @Provides methods:";
+
+  // TODO(cgruber): uncomment when http://github.com/google/compile-testing supports warnings.
+  //private static final String MISUSED_SCOPE_TEXT =
+  //    "Dagger will ignore scoping annotations on methods that are not @Provides methods:";
+
+  @Test public void compileSucceedsScopeOnConcreteType() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import javax.inject.Inject;",
+        "import javax.inject.Singleton;",
+        "@Singleton",
+        "class Test {",
+        "  @Inject public Test() { }",
+        "}"));
+
+    // TODO(cgruber): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
+        //.and().hasNoWarnings();
+  }
+
+  @Test public void compileSucceedsScopeOnProvidesMethod() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "@Module(library = true, injects = String.class)",
+        "class Test {",
+        "  @Provides @Singleton public String provideString() { return \"\"; }",
+        "}"));
+
+    // TODO(cgruber): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
+        //.and().hasNoWarnings();
+  }
+
+  @Test public void compileSucceedsWithScopedSuppressedNonProvidesMethod() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import javax.inject.Singleton;",
+        "class Test {",
+        "  @SuppressWarnings(\"scoping\")",
+        "  @Singleton void method() { }",
+        "}"));
+
+    // TODO(cgruber): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
+        //.and().hasNoWarnings();
+  }
+
+  @Test public void compileSucceedsWithScopedMultiplySuppressedNonProvidesMethod() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import javax.inject.Singleton;",
+        "class Test {",
+        "  @SuppressWarnings({\"blah\", \"scoping\", \"foo\"})",
+        "  @Singleton void method() { }",
+        "}"));
+
+    // TODO(cgruber): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
+        //.and().hasNoWarnings();
+  }
+
+  @Test public void compileWarnsWithScopedNonProvidesMethod() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import javax.inject.Singleton;",
+        "class Test {",
+        "  @Singleton void method() { }",
+        "}"));
+
+    // TODO(cgruber): uncomment when http://github.com/google/compile-testing supports warnings.
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
+        //.withWarningContaining(MISUSED_SCOPE_TEXT).in(sourceFile).onLine(3).atColumn(49).and()
+        //.withWarningContaining("Test.method()").in(sourceFile).onLine(3).atColumn(49);
+  }
+
+  @Test public void compileWarnsWithScopedIncorrectlySuppressedNonProvidesMethod() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import javax.inject.Singleton;",
+        "class Test {",
+        "  @SuppressWarnings(\"some string other than 'scoping'\")",
+        "  @Singleton void method() { }",
+        "}"));
+
+    // TODO(cgruber): uncomment when http://github.com/google/compile-testing supports warnings.
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
+        //.withWarningContaining(MISUSED_SCOPE_TEXT).in(sourceFile).onLine(4).atColumn(49).and()
+        //.withWarningContaining("Test.method()").in(sourceFile).onLine(4).atColumn(49);
+  }
+
+  @Test public void compileFailsWithScopeOnInterface() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import javax.inject.Singleton;",
+        "class Test {",
+        "  @Module(injects = TestType.class) class TestModule { }",
+        "  @Singleton interface TestType { }",
+        "}"));
+
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(14).and()
+        .withErrorContaining("Test.TestType").in(sourceFile).onLine(5).atColumn(14);
+  }
+
+  @Test public void compileFailsWithScopeOnAbstractClass() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import javax.inject.Singleton;",
+        "class Test {",
+        "  @Module(injects = TestType.class) class TestModule { }",
+        "  @Singleton abstract class TestType { }",
+        "}"));
+
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(23).and()
+        .withErrorContaining("Test.TestType").in(sourceFile).onLine(5).atColumn(23);
+  }
+
+  @Test public void compileFailsWithScopeOnField() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Singleton;",
+        "class Test {",
+        "  @Singleton String field;",
+        "  @Inject public Test() { }",
+        "  @Module(injects = Test.class) class TestModule { }",
+        "}"));
+
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(21).and()
+        .withErrorContaining("Test.field").in(sourceFile).onLine(5).atColumn(21);
+  }
+
+  @Test public void compileFailsWithScopeOnMethodParameter() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "@Module(library = true, injects = String.class)",
+        "class Test {",
+        "  @Provides int provideInteger() { return 0; }",
+        "  @Provides String provideString(@Singleton int intParam) { return \"\"; }",
+        "}"));
+
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(7).atColumn(49).and()
+        .withErrorContaining("intParam").in(sourceFile).onLine(7).atColumn(49);
+  }
+
+  @Test public void compileFailsWithMultipleScopeAnnotations() {
+    JavaFileObject annotation = JavaFileObjects.forSourceString("MyScope", Joiner.on("\n").join(
+        "import java.lang.annotation.Retention;",
+        "import javax.inject.Scope;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "@Scope @Retention(RUNTIME) public @interface MyScope { }"));
+
+    JavaFileObject module = JavaFileObjects.forSourceString("MyModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "@Module(library = true, injects = Injectable.class)",
+        "class MyModule {",
+        "  @Provides @Singleton @MyScope String method() { return \"\"; }",
+        "}"));
+
+    JavaFileObject injectable = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import javax.inject.Inject;",
+        "import javax.inject.Singleton;",
+        "@Singleton @MyScope",
+        "class Injectable {",
+        "  @Inject String string;",
+        "}"));
+
+    String error = "Only one scoping annotation is allowed per element: ";
+
+    ASSERT.about(javaSources()).that(asList(annotation, module, injectable))
+        .processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining(error + "MyModule.method()").in(module).onLine(6).atColumn(40).and()
+        .withErrorContaining(error + "Injectable").in(injectable).onLine(4).atColumn(1);
+  }
+
+  @Test public void compileFailsWithScopeOnConstructor() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Singleton;",
+        "class Test {",
+        "  @Singleton @Inject public Test() { }",
+        "  @Module(injects = Test.class) class TestModule { }",
+        "}"));
+
+   String singletonErrorText = ""
+        + "Singleton annotations have no effect on constructors. "
+        + "Did you mean to annotate the class?";
+
+    ASSERT.about(javaSource())
+        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(29).and()
+        .withErrorContaining("Test.Test()").in(sourceFile).onLine(5).atColumn(29).and()
+        .withErrorContaining(singletonErrorText).in(sourceFile).onLine(6).atColumn(33);
+  }
+}
+
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/SimpleMissingDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java
similarity index 93%
rename from compiler/src/test/java/dagger/internal/codegen/SimpleMissingDependencyTest.java
rename to compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java
index b8773c4..5dfe21f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SimpleMissingDependencyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.tests.integration.validation;
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
@@ -24,7 +24,7 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.internal.codegen.ProcessorTestUtils.daggerProcessors;
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 1fe64b4..5ffa23f 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -23,6 +23,7 @@
 import dagger.internal.Loader;
 import dagger.internal.ModuleAdapter;
 import dagger.internal.ProblemDetector;
+import dagger.internal.SetBinding;
 import dagger.internal.StaticInjection;
 import dagger.internal.ThrowingErrorHandler;
 import dagger.internal.UniqueMap;
@@ -162,31 +163,48 @@
 
       // Extract bindings in the 'base' and 'overrides' set. Within each set no
       // duplicates are permitted.
-      Map<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>();
-      Map<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>();
+      UniqueMap<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>() {
+        @Override public Binding<?> put(String key, Binding<?> value) {
+          return super.put(key, (value instanceof SetBinding)
+              ? new SetBinding<Object>((SetBinding<Object>) value) : value);
+        }
+      };
+      if (base != null) {
+        baseBindings.putAll(base.linkEverything()); // Add parent bindings
+      }
+      UniqueMap<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>() {
+        @Override public Binding<?> put(String key, Binding<?> value) {
+          if (value instanceof SetBinding) {
+            throw new IllegalArgumentException("Module overrides cannot contribute set bindings.");
+          }
+          return super.put(key, value);
+        }
+      };
       for (ModuleAdapter<?> moduleAdapter : getAllModuleAdapters(plugin, modules).values()) {
-        for (String key : moduleAdapter.injectableTypes) {
-          injectableTypes.put(key, moduleAdapter.getModule().getClass());
+        for (int i = 0; i < moduleAdapter.injectableTypes.length; i++) {
+          injectableTypes.put(moduleAdapter.injectableTypes[i], moduleAdapter.getModuleClass());
         }
-        for (Class<?> c : moduleAdapter.staticInjections) {
-          staticInjections.put(c, null);
+        for (int i = 0; i < moduleAdapter.staticInjections.length; i++) {
+          staticInjections.put(moduleAdapter.staticInjections[i], null);
         }
-        Map<String, Binding<?>> addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
-        moduleAdapter.getBindings(addTo);
+        try {
+          moduleAdapter.getBindings(moduleAdapter.overrides ? overrideBindings : baseBindings);
+        } catch (IllegalArgumentException e) {
+          throw new IllegalArgumentException(moduleAdapter.getModuleClass().getSimpleName()
+              + " is an overriding module and cannot contribute set bindings.");
+        }
       }
 
       // Create a linker and install all of the user's bindings
-      Linker linker = new Linker((base != null) ? base.linker : null, plugin,
-          new ThrowingErrorHandler());
+      Linker linker =
+          new Linker((base != null) ? base.linker : null, plugin, new ThrowingErrorHandler());
       linker.installBindings(baseBindings);
       linker.installBindings(overrideBindings);
 
       return new DaggerObjectGraph(base, linker, plugin, staticInjections, injectableTypes);
     }
 
-
     @Override public ObjectGraph plus(Object... modules) {
-      linkEverything();
       return makeGraph(this, plugin, modules);
     }
 
@@ -292,4 +310,5 @@
       }
     }
   }
+
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 86edaf5..57e5b04 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -280,10 +280,9 @@
    * Returns a scoped binding for {@code binding}.
    */
   static <T> Binding<T> scope(final Binding<T> binding) {
-    if (!binding.isSingleton()) {
-      return binding;
+    if (!binding.isSingleton() || binding instanceof SingletonBinding) {
+      return binding; // Default scoped binding or already a scoped binding.
     }
-    if (binding instanceof SingletonBinding) throw new AssertionError();
     return new SingletonBinding<T>(binding);
   }
 
@@ -424,5 +423,8 @@
     @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
       throw new UnsupportedOperationException("Deferred bindings must resolve first.");
     }
+    @Override public String toString() {
+      return "DeferredBinding[deferredKey=" + deferredKey + "]";
+    }
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index ab255ce..818ec00 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -57,7 +57,7 @@
     throw new UnsupportedOperationException("No no-args constructor on " + getClass().getName());
   }
 
-  public T getModule() {
-    return module;
+  public Class<?> getModuleClass() {
+    return module.getClass();
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Modules.java b/core/src/main/java/dagger/internal/Modules.java
index ef994cd..36bde75 100644
--- a/core/src/main/java/dagger/internal/Modules.java
+++ b/core/src/main/java/dagger/internal/Modules.java
@@ -50,7 +50,7 @@
     // Add the adapters that we have module instances for. This way we won't
     // construct module objects when we have a user-supplied instance.
     for (ModuleAdapter<?> adapter : seedAdapters) {
-      adaptersByModuleType.put(adapter.getModule().getClass(), adapter);
+      adaptersByModuleType.put(adapter.getModuleClass(), adapter);
     }
 
     // Next add adapters for the modules that we need to construct. This creates
/Fim/
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index 9b94c78..202fa5b 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -28,27 +28,45 @@
  */
 public final class SetBinding<T> extends Binding<Set<T>> {
 
-  @SuppressWarnings("unchecked")
   public static <T> void add(Map<String, Binding<?>> bindings, String setKey, Binding<?> binding) {
+    prepareSetBinding(bindings, setKey, binding).contributors.add(Linker.scope(binding));
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> SetBinding<T> prepareSetBinding(
+      Map<String, Binding<?>> bindings, String setKey, Binding<?> binding) {
     Binding<?> previous = bindings.get(setKey);
     SetBinding<T> setBinding;
     if (previous instanceof SetBinding) {
-      setBinding = (SetBinding) previous;
+      return (SetBinding<T>) previous;
     } else if (previous != null) {
       throw new IllegalArgumentException("Duplicate:\n    " + previous + "\n    " + binding);
     } else {
       setBinding = new SetBinding<T>(setKey, binding.requiredBy);
       bindings.put(setKey, setBinding);
+      return (SetBinding<T>) bindings.get(setKey); // BindingMap.put() copies SetBindings.
     }
-    setBinding.contributors.add(Linker.scope(binding));
   }
 
   private final Set<Binding<?>> contributors = new LinkedHashSet<Binding<?>>();
 
+  /**
+   * Creates a new {@code SetBinding} with the given "provides" key, and the requiredBy object
+   * for traceability.
+   */
   public SetBinding(String key, Object requiredBy) {
     super(key, null, false, requiredBy);
   }
 
+  /**
+   * Creates a new {@code SetBinding} with all of the contributing bindings of the provided
+   * original {@code SetBinding}.
+   */
+  public SetBinding(SetBinding<T> original) {
+    super(original.provideKey, null, false, original.requiredBy);
+    contributors.addAll(original.contributors);
+  }
+
   @Override public void attach(Linker linker) {
     for (Binding<?> contributor : contributors) {
       contributor.attach(linker);
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java b/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
new file mode 100644
index 0000000..0f60423
--- /dev/null
+++ b/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2013 Google Inc.
+ * Copyright (C) 2013 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import dagger.internal.TestingLoader;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static dagger.Provides.Type.SET;
+import static org.fest.assertions.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public final class ExtensionWithSetBindingsTest {
+  private static final AtomicInteger counter = new AtomicInteger(0);
+
+  @Singleton
+  static class RealSingleton {
+    @Inject Set<Integer> ints;
+  }
+
+  @Singleton
+  static class Main {
+    @Inject Set<Integer> ints;
+  }
+
+  @Module(injects = RealSingleton.class)
+  static class RootModule {
+    @Provides(type=SET) @Singleton Integer provideA() { return counter.getAndIncrement(); }
+    @Provides(type=SET) @Singleton Integer provideB() { return counter.getAndIncrement(); }
+  }
+
+  @Module(addsTo = RootModule.class, injects = Main.class )
+  static class ExtensionModule {
+    @Provides(type=SET) @Singleton Integer provideC() { return counter.getAndIncrement(); }
+    @Provides(type=SET) @Singleton Integer provideD() { return counter.getAndIncrement(); }
+  }
+
+  @Test public void basicInjectionWithExtension() {
+    ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule());
+    RealSingleton rs = root.get(RealSingleton.class);
+    assertThat(rs.ints).contains(0, 1);
+
+    ObjectGraph extension = root.plus(new ExtensionModule());
+    Main main = extension.get(Main.class);
+    assertThat(main.ints).contains(0, 1, 2, 3);
+
+    // Second time around.
+    ObjectGraph extension2 = root.plus(new ExtensionModule());
+    Main main2 = extension2.get(Main.class);
+    assertThat(main2.ints).contains(0, 1, 4, 5);
+  }
+
+  @Module(includes = ExtensionModule.class, overrides = true)
+  static class TestModule {
+    @Provides(type=SET) @Singleton Integer provide9999() { return 9999; }
+  }
+
+  @Test public void basicInjectionWithExtensionAndOverrides() {
+    try {
+      ObjectGraph.createWith(new TestingLoader(), new RootModule()).plus(new TestModule());
+      fail("Should throw exception.");
+    } catch (IllegalArgumentException e) {
+      assertEquals("TestModule is an overriding module and cannot contribute set bindings.",
+          e.getMessage());
+    }
+  }
+}
/Fim/
diff --git a/core/src/test/java/dagger/internal/TestingModuleAdapter.java b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
index 2819a5e..04dcc5e 100644
--- a/core/src/test/java/dagger/internal/TestingModuleAdapter.java
+++ b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
@@ -128,6 +128,10 @@
     }
   }
 
+  @Override public String toString() {
+    return "TestingModuleAdapter[" + this.moduleClass.getName() + "]";
+  }
+
   /**
    * Creates a TestingModuleAdapter or throws an {@code IllegalArgumentException}.
    */
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index b0cfe10..dd801c6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -159,7 +159,7 @@
 
     Linker.ErrorHandler errorHandler = ignoreCompletenessErrors ? Linker.ErrorHandler.NULL
         : new GraphAnalysisErrorHandler(processingEnv, rootModule.getQualifiedName().toString());
-    Linker linker = new Linker(null, new GraphAnalysisLoader(processingEnv), errorHandler);
+    Linker linker = new Linker(new GraphAnalysisLoader(processingEnv), errorHandler);
     // Linker requires synchronization for calls to requestBinding and linkAll.
     // We know statically that we're single threaded, but we synchronize anyway
     // to make the linker happy.
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 5ffa23f..1d77816 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -196,8 +196,7 @@
       }
 
       // Create a linker and install all of the user's bindings
-      Linker linker =
-          new Linker((base != null) ? base.linker : null, plugin, new ThrowingErrorHandler());
+      Linker linker = new Linker(plugin, new ThrowingErrorHandler());
       linker.installBindings(baseBindings);
       linker.installBindings(overrideBindings);
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 57e5b04..701d6c2 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -30,13 +30,6 @@
 public final class Linker {
   private static final Object UNINITIALIZED = new Object();
 
-  /**
-   * The base {@code Linker} which will be consulted to satisfy bindings not
-   * otherwise satisfiable from this {@code Linker}. The top-most {@code Linker}
-   * in a chain will have a null base linker.
-   */
-  private final Linker base;
-
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
   private final Queue<Binding<?>> toLink = new LinkedList<Binding<?>>();
 
@@ -53,11 +46,10 @@
 
   private final ErrorHandler errorHandler;
 
-  public Linker(Linker base, Loader plugin, ErrorHandler errorHandler) {
+  public Linker(Loader plugin, ErrorHandler errorHandler) {
     if (plugin == null) throw new NullPointerException("plugin");
     if (errorHandler == null) throw new NullPointerException("errorHandler");
 
-    this.base = base;
     this.plugin = plugin;
     this.errorHandler = errorHandler;
   }
@@ -234,15 +226,7 @@
       boolean mustHaveInjections, boolean library) {
     assertLockHeld();
 
-    Binding<?> binding = null;
-    for (Linker linker = this; linker != null; linker = linker.base) {
-      binding = linker.bindings.get(key);
-      if (binding != null) {
-        if (linker != this && !binding.isLinked()) throw new AssertionError();
-        break;
-      }
-    }
-
+    Binding<?> binding = bindings.get(key);
     if (binding == null) {
       // We can't satisfy this binding. Make sure it'll work next time!
       Binding<?> deferredBinding =
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index b0cfe10..dd801c6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -159,7 +159,7 @@
 
     Linker.ErrorHandler errorHandler = ignoreCompletenessErrors ? Linker.ErrorHandler.NULL
         : new GraphAnalysisErrorHandler(processingEnv, rootModule.getQualifiedName().toString());
-    Linker linker = new Linker(null, new GraphAnalysisLoader(processingEnv), errorHandler);
+    Linker linker = new Linker(new GraphAnalysisLoader(processingEnv), errorHandler);
     // Linker requires synchronization for calls to requestBinding and linkAll.
     // We know statically that we're single threaded, but we synchronize anyway
     // to make the linker happy.
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 1fe64b4..1d77816 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -23,6 +23,7 @@
 import dagger.internal.Loader;
 import dagger.internal.ModuleAdapter;
 import dagger.internal.ProblemDetector;
+import dagger.internal.SetBinding;
 import dagger.internal.StaticInjection;
 import dagger.internal.ThrowingErrorHandler;
 import dagger.internal.UniqueMap;
@@ -162,31 +163,47 @@
 
       // Extract bindings in the 'base' and 'overrides' set. Within each set no
       // duplicates are permitted.
-      Map<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>();
-      Map<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>();
+      UniqueMap<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>() {
+        @Override public Binding<?> put(String key, Binding<?> value) {
+          return super.put(key, (value instanceof SetBinding)
+              ? new SetBinding<Object>((SetBinding<Object>) value) : value);
+        }
+      };
+      if (base != null) {
+        baseBindings.putAll(base.linkEverything()); // Add parent bindings
+      }
+      UniqueMap<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>() {
+        @Override public Binding<?> put(String key, Binding<?> value) {
+          if (value instanceof SetBinding) {
+            throw new IllegalArgumentException("Module overrides cannot contribute set bindings.");
+          }
+          return super.put(key, value);
+        }
+      };
       for (ModuleAdapter<?> moduleAdapter : getAllModuleAdapters(plugin, modules).values()) {
-        for (String key : moduleAdapter.injectableTypes) {
-          injectableTypes.put(key, moduleAdapter.getModule().getClass());
+        for (int i = 0; i < moduleAdapter.injectableTypes.length; i++) {
+          injectableTypes.put(moduleAdapter.injectableTypes[i], moduleAdapter.getModuleClass());
         }
-        for (Class<?> c : moduleAdapter.staticInjections) {
-          staticInjections.put(c, null);
+        for (int i = 0; i < moduleAdapter.staticInjections.length; i++) {
+          staticInjections.put(moduleAdapter.staticInjections[i], null);
         }
-        Map<String, Binding<?>> addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
-        moduleAdapter.getBindings(addTo);
+        try {
+          moduleAdapter.getBindings(moduleAdapter.overrides ? overrideBindings : baseBindings);
+        } catch (IllegalArgumentException e) {
+          throw new IllegalArgumentException(moduleAdapter.getModuleClass().getSimpleName()
+              + " is an overriding module and cannot contribute set bindings.");
+        }
       }
 
       // Create a linker and install all of the user's bindings
-      Linker linker = new Linker((base != null) ? base.linker : null, plugin,
-          new ThrowingErrorHandler());
+      Linker linker = new Linker(plugin, new ThrowingErrorHandler());
       linker.installBindings(baseBindings);
       linker.installBindings(overrideBindings);
 
       return new DaggerObjectGraph(base, linker, plugin, staticInjections, injectableTypes);
     }
 
-
     @Override public ObjectGraph plus(Object... modules) {
-      linkEverything();
       return makeGraph(this, plugin, modules);
     }
 
@@ -292,4 +309,5 @@
       }
     }
   }
+
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 86edaf5..0fef0fe 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -30,13 +30,6 @@
 public final class Linker {
   private static final Object UNINITIALIZED = new Object();
 
-  /**
-   * The base {@code Linker} which will be consulted to satisfy bindings not
-   * otherwise satisfiable from this {@code Linker}. The top-most {@code Linker}
-   * in a chain will have a null base linker.
-   */
-  private final Linker base;
-
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
   private final Queue<Binding<?>> toLink = new LinkedList<Binding<?>>();
 
@@ -53,11 +46,10 @@
 
   private final ErrorHandler errorHandler;
 
-  public Linker(Linker base, Loader plugin, ErrorHandler errorHandler) {
+  public Linker(Loader plugin, ErrorHandler errorHandler) {
     if (plugin == null) throw new NullPointerException("plugin");
     if (errorHandler == null) throw new NullPointerException("errorHandler");
 
-    this.base = base;
     this.plugin = plugin;
     this.errorHandler = errorHandler;
   }
@@ -234,15 +226,7 @@
       boolean mustHaveInjections, boolean library) {
     assertLockHeld();
 
-    Binding<?> binding = null;
-    for (Linker linker = this; linker != null; linker = linker.base) {
-      binding = linker.bindings.get(key);
-      if (binding != null) {
-        if (linker != this && !binding.isLinked()) throw new AssertionError();
-        break;
-      }
-    }
-
+    Binding<?> binding = bindings.get(key);
     if (binding == null) {
       // We can't satisfy this binding. Make sure it'll work next time!
       Binding<?> deferredBinding =
@@ -280,10 +264,9 @@
    * Returns a scoped binding for {@code binding}.
    */
   static <T> Binding<T> scope(final Binding<T> binding) {
-    if (!binding.isSingleton()) {
-      return binding;
+    if (!binding.isSingleton() || binding instanceof SingletonBinding) {
+      return binding; // Default scoped binding or already a scoped binding.
     }
-    if (binding instanceof SingletonBinding) throw new AssertionError();
     return new SingletonBinding<T>(binding);
   }
 
@@ -418,11 +401,17 @@
       this.classLoader = classLoader;
       this.mustHaveInjections = mustHaveInjections;
     }
+
     @Override public void injectMembers(Object t) {
       throw new UnsupportedOperationException("Deferred bindings must resolve first.");
     }
+
     @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
       throw new UnsupportedOperationException("Deferred bindings must resolve first.");
     }
+
+    @Override public String toString() {
+      return "DeferredBinding[deferredKey=" + deferredKey + "]";
+    }
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index ab255ce..818ec00 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -57,7 +57,7 @@
     throw new UnsupportedOperationException("No no-args constructor on " + getClass().getName());
   }
 
-  public T getModule() {
-    return module;
+  public Class<?> getModuleClass() {
+    return module.getClass();
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Modules.java b/core/src/main/java/dagger/internal/Modules.java
index ef994cd..36bde75 100644
--- a/core/src/main/java/dagger/internal/Modules.java
+++ b/core/src/main/java/dagger/internal/Modules.java
@@ -50,7 +50,7 @@
     // Add the adapters that we have module instances for. This way we won't
     // construct module objects when we have a user-supplied instance.
     for (ModuleAdapter<?> adapter : seedAdapters) {
-      adaptersByModuleType.put(adapter.getModule().getClass(), adapter);
+      adaptersByModuleType.put(adapter.getModuleClass(), adapter);
     }
 
     // Next add adapters for the modules that we need to construct. This creates
/Fim/
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index 9b94c78..202fa5b 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -28,27 +28,45 @@
  */
 public final class SetBinding<T> extends Binding<Set<T>> {
 
-  @SuppressWarnings("unchecked")
   public static <T> void add(Map<String, Binding<?>> bindings, String setKey, Binding<?> binding) {
+    prepareSetBinding(bindings, setKey, binding).contributors.add(Linker.scope(binding));
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> SetBinding<T> prepareSetBinding(
+      Map<String, Binding<?>> bindings, String setKey, Binding<?> binding) {
     Binding<?> previous = bindings.get(setKey);
     SetBinding<T> setBinding;
     if (previous instanceof SetBinding) {
-      setBinding = (SetBinding) previous;
+      return (SetBinding<T>) previous;
     } else if (previous != null) {
       throw new IllegalArgumentException("Duplicate:\n    " + previous + "\n    " + binding);
     } else {
       setBinding = new SetBinding<T>(setKey, binding.requiredBy);
       bindings.put(setKey, setBinding);
+      return (SetBinding<T>) bindings.get(setKey); // BindingMap.put() copies SetBindings.
     }
-    setBinding.contributors.add(Linker.scope(binding));
   }
 
   private final Set<Binding<?>> contributors = new LinkedHashSet<Binding<?>>();
 
+  /**
+   * Creates a new {@code SetBinding} with the given "provides" key, and the requiredBy object
+   * for traceability.
+   */
   public SetBinding(String key, Object requiredBy) {
     super(key, null, false, requiredBy);
   }
 
+  /**
+   * Creates a new {@code SetBinding} with all of the contributing bindings of the provided
+   * original {@code SetBinding}.
+   */
+  public SetBinding(SetBinding<T> original) {
+    super(original.provideKey, null, false, original.requiredBy);
+    contributors.addAll(original.contributors);
+  }
+
   @Override public void attach(Linker linker) {
     for (Binding<?> contributor : contributors) {
       contributor.attach(linker);
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java b/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
new file mode 100644
index 0000000..30b4929
--- /dev/null
+++ b/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2013 Google Inc.
+ * Copyright (C) 2013 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import dagger.internal.TestingLoader;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static dagger.Provides.Type.SET;
+import static org.fest.assertions.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public final class ExtensionWithSetBindingsTest {
+  private static final AtomicInteger counter = new AtomicInteger(0);
+
+  @Singleton
+  static class RealSingleton {
+    @Inject Set<Integer> ints;
+  }
+
+  @Singleton
+  static class Main {
+    @Inject Set<Integer> ints;
+  }
+
+  @Module(injects = RealSingleton.class)
+  static class RootModule {
+    @Provides(type=SET) @Singleton Integer provideA() { return counter.getAndIncrement(); }
+    @Provides(type=SET) @Singleton Integer provideB() { return counter.getAndIncrement(); }
+  }
+
+  @Module(addsTo = RootModule.class, injects = Main.class )
+  static class ExtensionModule {
+    @Provides(type=SET) @Singleton Integer provideC() { return counter.getAndIncrement(); }
+    @Provides(type=SET) @Singleton Integer provideD() { return counter.getAndIncrement(); }
+  }
+
+  @Test public void basicInjectionWithExtension() {
+    ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule());
+    RealSingleton rs = root.get(RealSingleton.class);
+    assertThat(rs.ints).containsOnly(0, 1);
+
+    ObjectGraph extension = root.plus(new ExtensionModule());
+    Main main = extension.get(Main.class);
+    assertThat(main.ints).containsOnly(0, 1, 2, 3);
+
+    // Second time around.
+    ObjectGraph extension2 = root.plus(new ExtensionModule());
+    Main main2 = extension2.get(Main.class);
+    assertThat(main2.ints).containsOnly(0, 1, 4, 5);
+  }
+
+  @Module(includes = ExtensionModule.class, overrides = true)
+  static class TestModule {
+    @Provides(type=SET) @Singleton Integer provide9999() { return 9999; }
+  }
+
+  @Test public void basicInjectionWithExtensionAndOverrides() {
+    try {
+      ObjectGraph.createWith(new TestingLoader(), new RootModule()).plus(new TestModule());
+      fail("Should throw exception.");
+    } catch (IllegalArgumentException e) {
+      assertEquals("TestModule is an overriding module and cannot contribute set bindings.",
+          e.getMessage());
+    }
+  }
+}
/Fim/
diff --git a/core/src/test/java/dagger/internal/TestingModuleAdapter.java b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
index 2819a5e..04dcc5e 100644
--- a/core/src/test/java/dagger/internal/TestingModuleAdapter.java
+++ b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
@@ -128,6 +128,10 @@
     }
   }
 
+  @Override public String toString() {
+    return "TestingModuleAdapter[" + this.moduleClass.getName() + "]";
+  }
+
   /**
    * Creates a TestingModuleAdapter or throws an {@code IllegalArgumentException}.
    */
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index b11c5e3..90747f9 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -48,7 +48,8 @@
             "  private static final Class<?>[] STATIC_INJECTIONS = {};",
             "  private static final Class<?>[] INCLUDES = {};",
             "  public Basic$AModule$$ModuleAdapter() {",
-            "    super(INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
+            "    super(Basic.AModule.class,INJECTS, STATIC_INJECTIONS, false, INCLUDES,",
+            "      true, false);",
             "  }",
             "  @Override public Basic.AModule newModule() {",
             "    return new Basic.AModule();",
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
index 8fd401a..c3cd022 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
@@ -54,7 +54,7 @@
     return GraphAnalysisInjectBinding.create(type, mustHaveInjections);
   }
 
-  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
+  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<T> moduleClass) {
     throw new UnsupportedOperationException();
   }
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 4e65315..ff87d24 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -302,8 +302,8 @@
 
     writer.emitEmptyLine();
     writer.beginMethod(null, adapterName, EnumSet.of(PUBLIC));
-    writer.emitStatement("super(INJECTS, STATIC_INJECTIONS, %s /*overrides*/, "
-        + "INCLUDES, %s /*complete*/, %s /*library*/)", overrides, complete, library);
+    writer.emitStatement("super(%s.class, INJECTS, STATIC_INJECTIONS, %s /*overrides*/, "
+        + "INCLUDES, %s /*complete*/, %s /*library*/)", typeName,  overrides, complete, library);
     writer.endMethod();
 
     ExecutableElement noArgsConstructor = getNoArgsConstructor(type);
@@ -323,7 +323,8 @@
       writer.emitEmptyLine();
       writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
       writer.emitAnnotation(Override.class);
-      writer.beginMethod("void", "getBindings", EnumSet.of(PUBLIC), BINDINGS_MAP, "map");
+      writer.beginMethod("void", "getBindings", EnumSet.of(PUBLIC), BINDINGS_MAP, "map",
+          typeName, "module");
 
       for (ExecutableElement providerMethod : providerMethods) {
         Provides provides = providerMethod.getAnnotation(Provides.class);
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index b11c5e3..59aff69 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -48,7 +48,8 @@
             "  private static final Class<?>[] STATIC_INJECTIONS = {};",
             "  private static final Class<?>[] INCLUDES = {};",
             "  public Basic$AModule$$ModuleAdapter() {",
-            "    super(INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
+            "    super(Basic.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES,",
+            "      true, false);",
             "  }",
             "  @Override public Basic.AModule newModule() {",
             "    return new Basic.AModule();",
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 1d77816..03b3d8c 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -22,6 +22,7 @@
 import dagger.internal.Linker;
 import dagger.internal.Loader;
 import dagger.internal.ModuleAdapter;
+import dagger.internal.Modules;
 import dagger.internal.ProblemDetector;
 import dagger.internal.SetBinding;
 import dagger.internal.StaticInjection;
@@ -29,8 +30,7 @@
 import dagger.internal.UniqueMap;
 import java.util.LinkedHashMap;
 import java.util.Map;
-
-import static dagger.internal.Modules.getAllModuleAdapters;
+import java.util.Map.Entry;
 
 
 /**
@@ -135,9 +135,9 @@
   static class DaggerObjectGraph extends ObjectGraph {
     private final DaggerObjectGraph base;
     private final Linker linker;
+    private final Loader plugin;
     private final Map<Class<?>, StaticInjection> staticInjections;
     private final Map<String, Class<?>> injectableTypes;
-    private final Loader plugin;
 
     DaggerObjectGraph(DaggerObjectGraph base,
         Linker linker,
@@ -180,17 +180,22 @@
           return super.put(key, value);
         }
       };
-      for (ModuleAdapter<?> moduleAdapter : getAllModuleAdapters(plugin, modules).values()) {
+
+      Map<ModuleAdapter<?>, Object> loadedModules = Modules.loadModules(plugin, modules);
+      for (Entry<ModuleAdapter<?>, Object> loadedModule : loadedModules.entrySet()) {
+        @SuppressWarnings("unchecked")
+        ModuleAdapter<Object> moduleAdapter = (ModuleAdapter<Object>) loadedModule.getKey();
         for (int i = 0; i < moduleAdapter.injectableTypes.length; i++) {
-          injectableTypes.put(moduleAdapter.injectableTypes[i], moduleAdapter.getModuleClass());
+          injectableTypes.put(moduleAdapter.injectableTypes[i], moduleAdapter.moduleClass);
         }
         for (int i = 0; i < moduleAdapter.staticInjections.length; i++) {
           staticInjections.put(moduleAdapter.staticInjections[i], null);
         }
         try {
-          moduleAdapter.getBindings(moduleAdapter.overrides ? overrideBindings : baseBindings);
+          Map<String, Binding<?>> addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
+          moduleAdapter.getBindings(addTo, loadedModule.getValue());
         } catch (IllegalArgumentException e) {
-          throw new IllegalArgumentException(moduleAdapter.getModuleClass().getSimpleName()
+          throw new IllegalArgumentException(moduleAdapter.moduleClass.getSimpleName()
               + " is an overriding module and cannot contribute set bindings.");
         }
       }
@@ -200,7 +205,8 @@
       linker.installBindings(baseBindings);
       linker.installBindings(overrideBindings);
 
-      return new DaggerObjectGraph(base, linker, plugin, staticInjections, injectableTypes);
+      return new DaggerObjectGraph(base, linker, plugin, staticInjections,
+          injectableTypes);
     }
 
     @Override public ObjectGraph plus(Object... modules) {
/Fim/
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
index 0f2a6e1..350bd8f 100644
--- a/core/src/main/java/dagger/internal/FailoverLoader.java
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -36,18 +36,25 @@
    * be wasteful in terms of both CPU and memory allocated.
    */
 
+  private final LruCache<Class<?>, ModuleAdapter<?>> loadedAdapters =
+      new LruCache<Class<?>, ModuleAdapter<?>>(Integer.MAX_VALUE) {
+    @Override protected ModuleAdapter<?> create(Class<?> type) {
+      ModuleAdapter<?> result =
+          instantiate(type.getName().concat(MODULE_ADAPTER_SUFFIX), type.getClassLoader());
+      if (result == null) {
+        throw new IllegalStateException("Module adapter for " + type + " could not be loaded. "
+            + "Please ensure that code generation was run for this module.");
+      }
+      return result;
+    }
+  };
+
   /**
    * Obtains a module adapter for {@code module} from the first responding resolver.
    */
-  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
-    ModuleAdapter<T> result =
-        instantiate(type.getName().concat(MODULE_ADAPTER_SUFFIX), type.getClassLoader());
-    if (result == null) {
-      throw new IllegalStateException("Module adapter for " + type + " could not be loaded. "
-          + "Please ensure that code generation was run for this module.");
-    }
-    result.module = (instance != null) ? instance : result.newModule();
-    return result;
+  @SuppressWarnings("unchecked") // cache ensures types match
+  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<T> type) {
+    return (ModuleAdapter<T>) loadedAdapters.get(type);
   }
 
   @Override public Binding<?> getAtInjectBinding(
/Fim/
diff --git a/core/src/main/java/dagger/internal/Loader.java b/core/src/main/java/dagger/internal/Loader.java
index e5bcb08..c367a53 100644
--- a/core/src/main/java/dagger/internal/Loader.java
+++ b/core/src/main/java/dagger/internal/Loader.java
@@ -49,10 +49,10 @@
       String key, String className, ClassLoader classLoader, boolean mustHaveInjections);
 
   /**
-   * Returns a module adapter for {@code module} or throws a {@code TypeNotPresentException} if
+   * Returns a module adapter for {@code moduleClass} or throws a {@code TypeNotPresentException} if
    * none can be found.
    */
-  public abstract <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module);
+  public abstract <T> ModuleAdapter<T> getModuleAdapter(Class<T> moduleClass);
 
   /**
    * Returns the static injection for {@code injectedClass}.
/Fim/
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index 818ec00..dfe09b2 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -23,16 +23,18 @@
  * Extracts bindings from an {@code @Module}-annotated class.
  */
 public abstract class ModuleAdapter<T> {
+  public final Class<T> moduleClass;
   public final String[] injectableTypes;
   public final Class<?>[] staticInjections;
   public final boolean overrides;
   public final Class<?>[] includes;
   public final boolean complete;
   public final boolean library;
-  protected T module;
 
-  protected ModuleAdapter(String[] injectableTypes, Class<?>[] staticInjections, boolean overrides,
-      Class<?>[] includes, boolean complete, boolean library) {
+  protected ModuleAdapter(Class<T> moduleClass, String[] injectableTypes,
+      Class<?>[] staticInjections, boolean overrides, Class<?>[] includes, boolean complete,
+      boolean library) {
+    this.moduleClass = moduleClass;
     this.injectableTypes = injectableTypes;
     this.staticInjections = staticInjections;
     this.overrides = overrides;
@@ -45,7 +47,8 @@
    * Returns bindings for the {@code @Provides} methods of {@code module}. The
    * returned bindings must be linked before they can be used to inject values.
    */
-  public void getBindings(@SuppressWarnings("unused") Map<String, Binding<?>> map) {
+  public void getBindings(@SuppressWarnings("unused") Map<String, Binding<?>> map,
+      @SuppressWarnings("unused") T module) {
     // no-op;
   }
 
@@ -57,7 +60,20 @@
     throw new UnsupportedOperationException("No no-args constructor on " + getClass().getName());
   }
 
-  public Class<?> getModuleClass() {
-    return module.getClass();
+  @Override
+  public final boolean equals(Object obj) {
+    if (obj == this) {
+      return true;
+    } else if (obj instanceof ModuleAdapter<?>) {
+      ModuleAdapter<?> that = (ModuleAdapter<?>) obj;
+      return this.moduleClass.equals(that.moduleClass);
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public final int hashCode() {
+    return moduleClass.hashCode();
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Modules.java b/core/src/main/java/dagger/internal/Modules.java
index 36bde75..8b269f5 100644
--- a/core/src/main/java/dagger/internal/Modules.java
+++ b/core/src/main/java/dagger/internal/Modules.java
@@ -31,35 +31,38 @@
    * Returns a full set of module adapters, including module adapters for included
    * modules.
    */
-  public static Map<Class<?>, ModuleAdapter<?>> getAllModuleAdapters(Loader plugin,
-      Object[] seedModules) {
-    // Create a module adapter for each seed module.
-    ModuleAdapter<?>[] seedAdapters = new ModuleAdapter<?>[seedModules.length];
-    int s = 0;
-    for (Object module : seedModules) {
-      if (module instanceof Class) {
-        seedAdapters[s++] = plugin.getModuleAdapter((Class<?>) module, null); // Loader constructs.
+  public static Map<ModuleAdapter<?>, Object> loadModules(Loader loader,
+      Object[] seedModulesOrClasses) {
+    Map<ModuleAdapter<?>, Object> seedAdapters =
+        new LinkedHashMap<ModuleAdapter<?>, Object>(seedModulesOrClasses.length);
+    for (int i = 0; i < seedModulesOrClasses.length; i++) {
+      if (seedModulesOrClasses[i] instanceof Class<?>) {
+        ModuleAdapter<?> adapter = loader.getModuleAdapter((Class<?>) seedModulesOrClasses[i]);
+        seedAdapters.put(adapter, adapter.newModule());
       } else {
-        seedAdapters[s++] = plugin.getModuleAdapter(module.getClass(), module);
+        ModuleAdapter<?> adapter = loader.getModuleAdapter(seedModulesOrClasses[i].getClass());
+        seedAdapters.put(adapter, seedModulesOrClasses[i]);
       }
     }
 
-    Map<Class<?>, ModuleAdapter<?>> adaptersByModuleType
-        = new LinkedHashMap<Class<?>, ModuleAdapter<?>>();
-
     // Add the adapters that we have module instances for. This way we won't
     // construct module objects when we have a user-supplied instance.
-    for (ModuleAdapter<?> adapter : seedAdapters) {
-      adaptersByModuleType.put(adapter.getModuleClass(), adapter);
-    }
+    Map<ModuleAdapter<?>, Object> result =
+        new LinkedHashMap<ModuleAdapter<?>, Object>(seedAdapters);
 
-    // Next add adapters for the modules that we need to construct. This creates
-    // instances of modules as necessary.
-    for (ModuleAdapter<?> adapter : seedAdapters) {
-      collectIncludedModulesRecursively(plugin, adapter, adaptersByModuleType);
+    // Next collect included modules
+    Map<Class<?>, ModuleAdapter<?>> transitiveInclusions =
+        new LinkedHashMap<Class<?>, ModuleAdapter<?>>();
+    for (ModuleAdapter<?> adapter : seedAdapters.keySet()) {
+      collectIncludedModulesRecursively(loader, adapter, transitiveInclusions);
     }
-
-    return adaptersByModuleType;
+    // and create them if necessary
+    for (ModuleAdapter<?> dependency : transitiveInclusions.values()) {
+      if (!result.containsKey(dependency)) {
+        result.put(dependency, dependency.newModule());
+      }
+    }
+    return result;
   }
 
   /**
@@ -70,7 +73,7 @@
       Map<Class<?>, ModuleAdapter<?>> result) {
     for (Class<?> include : adapter.includes) {
       if (!result.containsKey(include)) {
-        ModuleAdapter<Object> includedModuleAdapter = plugin.getModuleAdapter(include, null);
+        ModuleAdapter<?> includedModuleAdapter = plugin.getModuleAdapter(include);
         result.put(include, includedModuleAdapter);
         collectIncludedModulesRecursively(plugin, includedModuleAdapter, result);
       }
/Fim/
diff --git a/core/src/test/java/dagger/internal/TestingLoader.java b/core/src/test/java/dagger/internal/TestingLoader.java
index a135d01..b364cde 100644
--- a/core/src/test/java/dagger/internal/TestingLoader.java
+++ b/core/src/test/java/dagger/internal/TestingLoader.java
@@ -25,9 +25,8 @@
  */
 public final class TestingLoader extends Loader {
 
-  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
+  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<T> type) {
     ModuleAdapter<T> adapter = TestingModuleAdapter.create(type);
-    adapter.module = (instance != null) ? instance : adapter.newModule();
     return adapter;
   }
 
/Fim/
diff --git a/core/src/test/java/dagger/internal/TestingModuleAdapter.java b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
index 04dcc5e..eed43e9 100644
--- a/core/src/test/java/dagger/internal/TestingModuleAdapter.java
+++ b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
@@ -31,17 +31,15 @@
 
 //TODO: Reduce the complexity of this and/or replace with a mock or fake.
 public class TestingModuleAdapter<M> extends ModuleAdapter<M> {
-  final Class<?> moduleClass;
-
-  public TestingModuleAdapter(Class<?> moduleClass, Module annotation) {
+  public TestingModuleAdapter(Class<M> moduleClass, Module annotation) {
     super(
+        moduleClass,
         injectableTypesToKeys(annotation.injects()),
         annotation.staticInjections(),
         annotation.overrides(),
         annotation.includes(),
         annotation.complete(),
         annotation.library());
-    this.moduleClass = moduleClass;
   }
 
   private static String[] injectableTypesToKeys(Class<?>[] injectableTypes) {
@@ -55,7 +53,7 @@
     return result;
   }
 
-  @Override public void getBindings(Map<String, Binding<?>> bindings) {
+  @Override public void getBindings(Map<String, Binding<?>> bindings, M module) {
     for (Class<?> c = moduleClass; !c.equals(Object.class); c = c.getSuperclass()) {
       for (Method method : c.getDeclaredMethods()) {
         Provides provides = method.getAnnotation(Provides.class);
@@ -82,15 +80,15 @@
           String key = Keys.get(genericReturnType, method.getAnnotations(), method);
           switch (provides.type()) {
             case UNIQUE:
-              handleBindings(bindings, method, key, library);
+              handleBindings(bindings, module, method, key, library);
               break;
             case SET:
               String setKey = Keys.getSetKey(method.getGenericReturnType(),
                   method.getAnnotations(), method);
-              handleSetBindings(bindings, method, setKey, key, library);
+              handleSetBindings(bindings, module, method, setKey, key, library);
               break;
             case SET_VALUES:
-              handleSetBindings(bindings, method, key, key, library);
+              handleSetBindings(bindings, module, method, key, key, library);
               break;
             default:
               throw new AssertionError("Unknown @Provides type " + provides.type());
@@ -100,14 +98,15 @@
     }
   }
 
-  private void handleBindings(Map<String, Binding<?>> bindings, Method method, String key,
+  private void handleBindings(Map<String, Binding<?>> bindings, M module, Method method, String key,
       boolean library) {
     bindings.put(key, new ProviderMethodBinding<M>(method, key, module, library));
   }
 
-  private void handleSetBindings(Map<String, Binding<?>> bindings, Method method, String setKey,
-      String providerKey, boolean library) {
-    SetBinding.<M>add(bindings, setKey, new ProviderMethodBinding<M>(method, providerKey, module, library));
+  private void handleSetBindings(Map<String, Binding<?>> bindings, M module, Method method,
+      String setKey, String providerKey, boolean library) {
+    SetBinding.<M>add(bindings, setKey,
+        new ProviderMethodBinding<M>(method, providerKey, module, library));
   }
 
   @Override public M newModule() {
@@ -135,7 +134,7 @@
   /**
    * Creates a TestingModuleAdapter or throws an {@code IllegalArgumentException}.
    */
-  public static <M> ModuleAdapter<M> create(Class<? extends M> moduleClass) {
+  public static <M> ModuleAdapter<M> create(Class<M> moduleClass) {
     Module annotation = moduleClass.getAnnotation(Module.class);
     if (annotation == null) {
       throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
/Fim/
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
index 350bd8f..a9fb260 100644
--- a/core/src/main/java/dagger/internal/FailoverLoader.java
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -36,18 +36,18 @@
    * be wasteful in terms of both CPU and memory allocated.
    */
 
-  private final LruCache<Class<?>, ModuleAdapter<?>> loadedAdapters =
-      new LruCache<Class<?>, ModuleAdapter<?>>(Integer.MAX_VALUE) {
-    @Override protected ModuleAdapter<?> create(Class<?> type) {
-      ModuleAdapter<?> result =
-          instantiate(type.getName().concat(MODULE_ADAPTER_SUFFIX), type.getClassLoader());
-      if (result == null) {
-        throw new IllegalStateException("Module adapter for " + type + " could not be loaded. "
-            + "Please ensure that code generation was run for this module.");
-      }
-      return result;
-    }
-  };
+  private final Memoizer<Class<?>, ModuleAdapter<?>> loadedAdapters =
+      new Memoizer<Class<?>, ModuleAdapter<?>>() {
+        @Override protected ModuleAdapter<?> create(Class<?> type) {
+          ModuleAdapter<?> result =
+              instantiate(type.getName().concat(MODULE_ADAPTER_SUFFIX), type.getClassLoader());
+          if (result == null) {
+            throw new IllegalStateException("Module adapter for " + type + " could not be loaded. "
+                + "Please ensure that code generation was run for this module.");
+          }
+          return result;
+        }
+      };
 
   /**
    * Obtains a module adapter for {@code module} from the first responding resolver.
/Fim/
diff --git a/core/src/main/java/dagger/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
index da7eeb2..53a4d7a 100644
--- a/core/src/main/java/dagger/internal/Keys.java
+++ b/core/src/main/java/dagger/internal/Keys.java
@@ -46,12 +46,12 @@
   private static final String LAZY_PREFIX = Lazy.class.getCanonicalName() + "<";
   private static final String SET_PREFIX = Set.class.getCanonicalName() + "<";
 
-  private static final LruCache<Class<? extends Annotation>, Boolean> IS_QUALIFIER_ANNOTATION
-      = new LruCache<Class<? extends Annotation>, Boolean>(Integer.MAX_VALUE) {
-    @Override protected Boolean create(Class<? extends Annotation> annotationType) {
-      return annotationType.isAnnotationPresent(Qualifier.class);
-    }
-  };
+  private static final Memoizer<Class<? extends Annotation>, Boolean> IS_QUALIFIER_ANNOTATION =
+      new Memoizer<Class<? extends Annotation>, Boolean>() {
+        @Override protected Boolean create(Class<? extends Annotation> annotationType) {
+          return annotationType.isAnnotationPresent(Qualifier.class);
+        }
+      };
 
   Keys() {
   }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Loader.java b/core/src/main/java/dagger/internal/Loader.java
index c367a53..ed81ede 100644
--- a/core/src/main/java/dagger/internal/Loader.java
+++ b/core/src/main/java/dagger/internal/Loader.java
@@ -25,21 +25,20 @@
  * provide all resolution methods
  */
 public abstract class Loader {
-
-  private final LruCache<ClassLoader, LruCache<String, Class<?>>> caches =
-      new LruCache<ClassLoader, LruCache<String, Class<?>>>(Integer.MAX_VALUE) {
-    @Override protected LruCache<String, Class<?>> create(final ClassLoader classLoader) {
-      return new LruCache<String, Class<?>>(Integer.MAX_VALUE) {
-        @Override protected Class<?> create(String className) {
-          try {
-            return classLoader.loadClass(className);
-          } catch (ClassNotFoundException e) {
-            return Void.class; // Cache the failure (negative case).
-          }
+  private final Memoizer<ClassLoader, Memoizer<String, Class<?>>> caches =
+      new Memoizer<ClassLoader, Memoizer<String, Class<?>>>() {
+        @Override protected Memoizer<String, Class<?>> create(final ClassLoader classLoader) {
+          return new Memoizer<String, Class<?>>() {
+            @Override protected Class<?> create(String className) {
+              try {
+                return classLoader.loadClass(className);
+              } catch (ClassNotFoundException e) {
+                return Void.class; // Cache the failure (negative case).
+              }
+            }
+          };
         }
       };
-    }
-  };
 
   /**
    * Returns a binding that uses {@code @Inject} annotations, or null if no valid binding can
/Fim/
/Fim/
diff --git a/core/src/main/java/dagger/internal/Memoizer.java b/core/src/main/java/dagger/internal/Memoizer.java
new file mode 100644
index 0000000..04cdc10
--- /dev/null
+++ b/core/src/main/java/dagger/internal/Memoizer.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+/**
+ * Represents an operation to be
+ */
+abstract class Memoizer<K, V> {
+  private final Map<K, V> map;
+  private final Lock readLock;
+  private final Lock writeLock;
+
+  public Memoizer() {
+    this.map = new LinkedHashMap<K, V>();
+    ReadWriteLock lock = new ReentrantReadWriteLock();
+    this.readLock = lock.readLock();
+    this.writeLock = lock.writeLock();
+  }
+
+  public final V get(K key) {
+    if (key == null) {
+      throw new NullPointerException("key == null");
+    }
+
+    // check to see if we already have a value
+    readLock.lock();
+    try {
+      V value = map.get(key);
+      if (value != null) {
+        return value;
+      }
+    } finally {
+      readLock.unlock();
+    }
+
+    // create a new value.  this may race and we might create more than one instance, but that's ok
+    V newValue = create(key);
+    if (newValue == null) {
+      throw new NullPointerException("create returned null");
+    }
+
+    // write the new value and return it
+    writeLock.lock();
+    try {
+      map.put(key, newValue);
+      return newValue;
+    } finally {
+      writeLock.unlock();
+    }
+  }
+
+  protected abstract V create(K key);
+
+  @Override public final String toString() {
+    readLock.lock();
+    try {
+      return map.toString();
+    } finally {
+      readLock.unlock();
+    }
+  }
+}
\ No newline at end of file
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index dd801c6..45dc4b6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -173,10 +173,13 @@
         Map<String, Binding<?>> addTo = overrides ? overrideBindings : baseBindings;
 
         // Gather the injectable types from the annotation.
+        Set<String> injectsProvisionKeys = new LinkedHashSet<String>();
         for (Object injectableTypeObject : (Object[]) annotation.get("injects")) {
           TypeMirror injectableType = (TypeMirror) injectableTypeObject;
+          String providerKey = GeneratorKeys.get(injectableType);
+          injectsProvisionKeys.add(providerKey);
           String key = isInterface(injectableType)
-              ? GeneratorKeys.get(injectableType)
+              ? providerKey
               : GeneratorKeys.rawMembersKey(injectableType);
           linker.requestBinding(key, module.getQualifiedName().toString(),
               getClass().getClassLoader(), false, true);
@@ -216,6 +219,9 @@
 
           switch (provides.type()) {
             case UNIQUE:
+              if (injectsProvisionKeys.contains(binding.provideKey)) {
+                binding.setDependedOn(true);
+              }
               addTo.put(key, binding);
               break;
 
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java b/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
index 7a368a3..edc8816 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
@@ -18,12 +18,14 @@
 
 import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
+import java.util.Arrays;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static org.truth0.Truth.ASSERT;
 
@@ -32,7 +34,6 @@
   @Test public void unusedProviderMethodsPassOnLibrary() {
     JavaFileObject source = JavaFileObjects.forSourceString("Library", Joiner.on("\n").join(
         "import dagger.Module;",
-        "import dagger.ObjectGraph;",
         "import dagger.Provides;",
         "import java.lang.Override;",
         "@Module(library = true)",
@@ -48,7 +49,6 @@
   @Test public void unusedProviderMethodsFailOnNonLibrary() {
     JavaFileObject source = JavaFileObjects.forSourceString("Library", Joiner.on("\n").join(
         "import dagger.Module;",
-        "import dagger.ObjectGraph;",
         "import dagger.Provides;",
         "import java.lang.Override;",
         "@Module(library = false)",
@@ -58,9 +58,44 @@
         "  }",
         "}"));
     ASSERT.about(javaSource()).that(source).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining("Graph validation failed:").in(source).onLine(6).and()
-        .withErrorContaining("You have these unused @Provider methods:").in(source).onLine(6).and()
-        .withErrorContaining("1. TestModule.string()").in(source).onLine(6).and()
-        .withErrorContaining("Set library=true in your module").in(source).onLine(6);
+        .withErrorContaining("Graph validation failed:").in(source).onLine(5).and()
+        .withErrorContaining("You have these unused @Provider methods:").in(source).onLine(5).and()
+        .withErrorContaining("1. TestModule.string()").in(source).onLine(5).and()
+        .withErrorContaining("Set library=true in your module").in(source).onLine(5);
   }
+
+  @Test public void injectsOfInterfaceMakesProvidesBindingNotAnOrphan() {
+    JavaFileObject foo = JavaFileObjects.forSourceString("Foo", "interface Foo {}");
+    JavaFileObject module = JavaFileObjects.forSourceString("TestModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "@Module(injects = Foo.class, library = false)",
+        "class TestModule {",
+        "  @Singleton @Provides Foo provideFoo() {",
+        "    return new Foo() {};",
+        "  }",
+        "}"));
+    ASSERT.about(javaSources()).that(Arrays.asList(foo, module))
+        .processedWith(daggerProcessors())
+        .compilesWithoutError();
+  }
+
+  @Test public void injectsOfClassMakesProvidesBindingNotAnOrphan() {
+    JavaFileObject foo = JavaFileObjects.forSourceString("Foo", "class Foo {}");
+    JavaFileObject module = JavaFileObjects.forSourceString("TestModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "@Module(injects = Foo.class, library = false)",
+        "class TestModule {",
+        "  @Singleton @Provides Foo provideFoo() {",
+        "    return new Foo() {};",
+        "  }",
+        "}"));
+    ASSERT.about(javaSources()).that(Arrays.asList(foo, module))
+        .processedWith(daggerProcessors())
+        .compilesWithoutError();
+  }
+
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
index 53a4d7a..dc36020 100644
--- a/core/src/main/java/dagger/internal/Keys.java
+++ b/core/src/main/java/dagger/internal/Keys.java
@@ -61,14 +61,14 @@
     return get(type, null);
   }
 
-
   /** Returns a key for the members of {@code type}. */
   public static String getMembersKey(Class<?> key) {
-    return "members/" + get(key);
+    // for classes key.getName() is equivalent to get(key)
+    return "members/".concat(key.getName());
   }
 
   /** Returns a key for {@code type} annotated by {@code annotation}. */
-  public static String get(Type type, Annotation annotation) {
+  private static String get(Type type, Annotation annotation) {
     type = boxIfPrimitive(type);
     if (annotation == null && type instanceof Class && !((Class<?>) type).isArray()) {
       return ((Class<?>) type).getName();
@@ -233,11 +233,6 @@
     return string.regionMatches(offset, substring, 0, substring.length());
   }
 
-  /** Returns true if {@code key} is a binding that supports members injection. */
-  public static boolean isMembersInjection(String key) {
-    return key.startsWith("members/");
-  }
-
   /** Returns true if {@code key} has a qualifier annotation. */
   public static boolean isAnnotated(String key) {
     return key.startsWith("@");
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
index a9a90fe..26394b6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
@@ -17,7 +17,9 @@
 
 import dagger.internal.Binding;
 import java.io.IOException;
+import java.util.Comparator;
 import java.util.HashSet;
+import java.util.TreeSet;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
@@ -49,7 +51,7 @@
     for (Map.Entry<Binding<?>, String> entry : namesIndex.entrySet()) {
       Binding<?> sourceBinding = entry.getKey();
       String sourceName = entry.getValue();
-      Set<Binding<?>> dependencies = new HashSet<Binding<?>>();
+      Set<Binding<?>> dependencies = new TreeSet<Binding<?>>(new BindingComparator());
       sourceBinding.getDependencies(dependencies, dependencies);
       for (Binding<?> targetBinding : dependencies) {
         String targetName = namesIndex.get(targetBinding);
@@ -122,4 +124,16 @@
 
     return result.toString();
   }
+
+  /** A Comparator for Bindings so we can insure a consistent ordering of output. */
+  private static class BindingComparator implements Comparator<Binding<?>> {
+    @Override
+    public int compare(Binding<?> left, Binding<?> right) {
+      return getStringForBinding(left).compareTo(getStringForBinding(right));
+    }
+
+    private String getStringForBinding(Binding<?> binding) {
+      return binding == null ? "" : binding.toString();
+    }
+  }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index 202fa5b..b2dd00f 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -48,7 +48,7 @@
     }
   }
 
-  private final Set<Binding<?>> contributors = new LinkedHashSet<Binding<?>>();
+  private final Set<Binding<?>> contributors;
 
   /**
    * Creates a new {@code SetBinding} with the given "provides" key, and the requiredBy object
@@ -56,6 +56,7 @@
    */
   public SetBinding(String key, Object requiredBy) {
     super(key, null, false, requiredBy);
+    contributors = new LinkedHashSet<Binding<?>>();
   }
 
   /**
@@ -64,7 +65,9 @@
    */
   public SetBinding(SetBinding<T> original) {
     super(original.provideKey, null, false, original.requiredBy);
-    contributors.addAll(original.contributors);
+    this.setLibrary(original.library());
+    this.setDependedOn(original.dependedOn());
+    contributors = new LinkedHashSet<Binding<?>>(original.contributors);
   }
 
   @Override public void attach(Linker linker) {
/Fim/
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index 202fa5b..ed0c5f7 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -38,17 +38,20 @@
     Binding<?> previous = bindings.get(setKey);
     SetBinding<T> setBinding;
     if (previous instanceof SetBinding) {
-      return (SetBinding<T>) previous;
+      setBinding = (SetBinding<T>) previous;
+      setBinding.setLibrary(setBinding.library() && binding.library());
+      return setBinding;
     } else if (previous != null) {
       throw new IllegalArgumentException("Duplicate:\n    " + previous + "\n    " + binding);
     } else {
       setBinding = new SetBinding<T>(setKey, binding.requiredBy);
+      setBinding.setLibrary(binding.library());
       bindings.put(setKey, setBinding);
       return (SetBinding<T>) bindings.get(setKey); // BindingMap.put() copies SetBindings.
     }
   }
 
-  private final Set<Binding<?>> contributors = new LinkedHashSet<Binding<?>>();
+  private final Set<Binding<?>> contributors;
 
   /**
    * Creates a new {@code SetBinding} with the given "provides" key, and the requiredBy object
@@ -56,6 +59,7 @@
    */
   public SetBinding(String key, Object requiredBy) {
     super(key, null, false, requiredBy);
+    contributors = new LinkedHashSet<Binding<?>>();
   }
 
   /**
@@ -64,7 +68,9 @@
    */
   public SetBinding(SetBinding<T> original) {
     super(original.provideKey, null, false, original.requiredBy);
-    contributors.addAll(original.contributors);
+    this.setLibrary(original.library());
+    this.setDependedOn(original.dependedOn());
+    contributors = new LinkedHashSet<Binding<?>>(original.contributors);
   }
 
   @Override public void attach(Linker linker) {
/Fim/
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index 3960157..cf5dccb 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -38,6 +38,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
 
 @RunWith(JUnit4.class)
 public final class SetBindingTest {
@@ -239,6 +240,55 @@
     graph.validate();
   }
 
+  @Test public void validateLibraryModules() {
+    class TestEntryPoint {}
+
+    @Module(library = true)
+    class SetModule {
+      @Provides(type = SET)
+      public String provideString() {
+        return "";
+      }
+    }
+
+    @Module(injects = TestEntryPoint.class, includes = SetModule.class)
+    class TestModule {}
+
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(),
+        new TestModule(), new SetModule());
+    graph.validate();
+  }
+
+  @Test public void validateLibraryModules_nonLibraryContributors() {
+    class TestEntryPoint {}
+
+    @Module(library = true)
+    class SetModule1 {
+      @Provides(type = SET)
+      public String provideString() {
+        return "a";
+      }
+    }
+
+    @Module
+    class SetModule2 {
+      @Provides(type = SET)
+      public String provideString() {
+        return "b";
+      }
+    }
+
+    @Module(injects = TestEntryPoint.class, includes = { SetModule1.class, SetModule2.class })
+    class TestModule {}
+
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(),
+        new TestModule(), new SetModule1(), new SetModule2());
+    try {
+      graph.validate();
+      fail();
+    } catch (IllegalStateException expected) {}
+  }
+
   static class Logger {
     @Inject Set<LogSink> loggers;
     public void log(String text, Throwable error) {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index 45dc4b6..0f0c280 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -60,12 +60,16 @@
 import static dagger.internal.codegen.Util.getPackage;
 import static dagger.internal.codegen.Util.isInterface;
 import static dagger.internal.codegen.Util.methodName;
+import static java.util.Arrays.asList;
 
 /**
  * Performs full graph analysis on a module.
  */
 @SupportedAnnotationTypes("dagger.Module")
 public final class GraphAnalysisProcessor extends AbstractProcessor {
+  private static final Set<String> ERROR_NAMES_TO_PROPAGATE = new LinkedHashSet<String>(asList(
+      "com.sun.tools.javac.code.Symbol$CompletionFailure"));
+
   private final Set<String> delayedModuleNames = new LinkedHashSet<String>();
 
   @Override public SourceVersion getSupportedSourceVersion() {
@@ -120,7 +124,11 @@
           error("Graph validation failed: " + e.getMessage(), elements().getTypeElement(e.type));
           continue;
         } catch (RuntimeException e) {
-          error("Graph validation failed: " + e.getMessage(), moduleType);
+          if (ERROR_NAMES_TO_PROPAGATE.contains(e.getClass().getName())) {
+            throw e;
+          }
+          error("Unknown error " + e.getClass().getName() + " thrown by javac in graph validation: "
+              + e.getMessage(), moduleType);
           continue;
         }
         try {
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index f95285c..741ea2a 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -62,7 +62,7 @@
     <dependency>
       <groupId>com.google.testing.compile</groupId>
       <artifactId>compile-testing</artifactId>
-      <version>0.3</version>
+      <version>0.4</version>
       <scope>test</scope>
     </dependency>
     <dependency>
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index 59aff69..aec56e5 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -76,4 +76,98 @@
         .generatesSources(expectedModuleAdapter, expectedInjectAdapter);
 
   }
+
+  /**
+   * Shows current behavior for a {@link dagger.Provides provides method}
+   * used to supply an injected ctor parameter.
+   *
+   * <ul>
+   *   <li>{@code ProvidesAdapter} invokes the module's provides method on
+   *   {@code get}</li>
+   *   <li>On {@code getBindings}, the above is newed up and linked to its type
+   *   key.
+   *   <li>{@code InjectAdapter} contains a field for the parameter binding,
+   *   referenced in {@code getDependencies} and set on {@code attach}</li>
+   *   <li>On {@code get}, the injected constructor is called with the value of
+   *   {@link dagger.internal.Binding#get}</li>
+   * </ul>
+   */
+  @Test public void providerForCtorInjection() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "class Field {",
+        "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
+        "  @Module(injects = A.class)",
+        "  static class AModule { @Provides String name() { return \"foo\"; }}",
+        "}"));
+
+    JavaFileObject expectedModuleAdapter =
+        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
+        "import dagger.internal.Binding;",
+        "import dagger.internal.ModuleAdapter;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "public final class Field$AModule$$ModuleAdapter",
+        "    extends ModuleAdapter<Field.AModule> {",
+        "  private static final String[] INJECTS = {\"members/Field$A\"};",
+        "  private static final Class<?>[] STATIC_INJECTIONS = {};",
+        "  private static final Class<?>[] INCLUDES = {};",
+        "  public Field$AModule$$ModuleAdapter() {",
+        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
+        "  }",
+        "  @Override public Field.AModule newModule() {",
+        "    return new Field.AModule();",
+        "  }",
+        "  @Override public void getBindings(Map<String, Binding<?>> map, Field.AModule module) {",
+        "    map.put(\"java.lang.String\", new NameProvidesAdapter(module));", // eager new!
+        "  }",
+        "  public static final class NameProvidesAdapter", // corresponds to method name
+        "      extends Binding<String> implements Provider<String> {",
+        "    private final Field.AModule module;",
+        "    public NameProvidesAdapter(Field.AModule module) {",
+        "      super(\"java.lang.String\", null, NOT_SINGLETON, \"Field.AModule.name()\");",
+        "      this.module = module;",
+        "      setLibrary(false);",
+        "    }",
+        "    @Override public String get() {",
+        "      return module.name();", // corresponds to @Provides method
+        "    }",
+        "  }",
+        "}"));
+
+    JavaFileObject expectedInjectAdapter =
+        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
+            "import dagger.internal.Binding;",
+            "import dagger.internal.Linker;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "public final class Field$A$$InjectAdapter",
+            "    extends Binding<Field.A> implements Provider<Field.A> {",
+            "  private Binding<String> name;", // for ctor
+            "  public Field$A$$InjectAdapter() {",
+            "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
+            "  }",
+            "  @Override @SuppressWarnings(\"unchecked\")",
+            "  public void attach(Linker linker) {",
+            "    name = (Binding<String>)linker.requestBinding(", // binding key is not a class
+            "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());",
+            "  }",
+            "  @Override public void getDependencies(",
+            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
+            "    getBindings.add(name);", // name is added to dependencies
+            "  }",
+            "  @Override public Field.A get() {",
+            "    Field.A result = new Field.A(name.get());", // adds ctor param
+            "    return result;",
+            "  }",
+            "}"));
+
+    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expectedModuleAdapter, expectedInjectAdapter);
+
+  }
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index ff87d24..5503e17 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -485,7 +485,7 @@
       writer.beginMethod("void", "getDependencies", EnumSet.of(PUBLIC), setOfBindings,
           "getBindings", setOfBindings, "injectMembersBindings");
       for (Element parameter : parameters) {
-        writer.emitStatement("getBindings.add(%s)", parameter.getSimpleName().toString());
+        writer.emitStatement("getBindings.add(%s)", parameterName(parameter));
       }
       writer.endMethod();
     }
@@ -499,7 +499,7 @@
     for (Element parameter : parameters) {
       if (!first) args.append(", ");
       else first = false;
-      args.append(String.format("%s.get()", parameter.getSimpleName().toString()));
+      args.append(String.format("%s.get()", parameterName(parameter)));
     }
     writer.emitStatement("return module.%s(%s)", methodName, args.toString());
     writer.endMethod();
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
new file mode 100644
index 0000000..b321126
--- /dev/null
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2013 Google Inc.
+ * Copyright (C) 2013 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.tests.integration.codegen;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static java.util.Arrays.asList;
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public final class ModuleAdapterGenerationTest {
+
+  @Test public void providesHasParameterNamedModule() {
+    JavaFileObject a = JavaFileObjects.forSourceString("A", Joiner.on("\n").join(
+        "import javax.inject.Inject;",
+        "class A { @Inject A(){ }}"));
+    JavaFileObject b = JavaFileObjects.forSourceString("B", Joiner.on("\n").join(
+        "import javax.inject.Inject;",
+        "class B { @Inject B(){ }}"));
+
+    JavaFileObject module = JavaFileObjects.forSourceString("BModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "@Module(injects = B.class)",
+        "class BModule { @Provides B b(A module) { return new B(); }}"));
+
+    ASSERT.about(javaSources()).that(asList(a, b, module)).processedWith(daggerProcessors())
+        .compilesWithoutError();
+  }
+
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 0fef0fe..adc9396 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -99,18 +99,18 @@
           continue; // A binding for this key has since been linked.
         }
         try {
-          Binding<?> jitBinding =
-              createJitBinding(key, binding.requiredBy, deferred.classLoader, mustHaveInjections);
-          jitBinding.setLibrary(binding.library());
-          jitBinding.setDependedOn(binding.dependedOn());
+          Binding<?> resolvedBinding =
+              createBinding(key, binding.requiredBy, deferred.classLoader, mustHaveInjections);
+          resolvedBinding.setLibrary(binding.library());
+          resolvedBinding.setDependedOn(binding.dependedOn());
           // Fail if the type of binding we got wasn't capable of what was requested.
-          if (!key.equals(jitBinding.provideKey) && !key.equals(jitBinding.membersKey)) {
+          if (!key.equals(resolvedBinding.provideKey) && !key.equals(resolvedBinding.membersKey)) {
             throw new IllegalStateException("Unable to create binding for " + key);
           }
           // Enqueue the JIT binding so its own dependencies can be linked.
-          Binding<?> scopedJitBinding = scope(jitBinding);
-          toLink.add(scopedJitBinding);
-          putBinding(scopedJitBinding);
+          Binding<?> scopedBinding = scope(resolvedBinding);
+          toLink.add(scopedBinding);
+          putBinding(scopedBinding);
         } catch (InvalidBindingException e) {
           addError(e.type + " " + e.getMessage() + " required by " + binding.requiredBy);
           bindings.put(key, Binding.UNRESOLVED);
@@ -156,16 +156,17 @@
   }
 
   /**
-   * Creates a just-in-time binding for the key in {@code deferred}. The type of binding
+   * Returns a binding for the key in {@code deferred}. The type of binding
    * to be created depends on the key's type:
    * <ul>
    *   <li>Injections of {@code Provider<Foo>}, {@code MembersInjector<Bar>}, and
    *       {@code Lazy<Blah>} will delegate to the bindings of {@code Foo}, {@code Bar}, and
    *       {@code Blah} respectively.
-   *   <li>Injections of other types will use the injectable constructors of those classes.
+   *   <li>Injections of raw types will use the injectable constructors of those classes.
+   *   <li>Any other injection types require @Provides bindings and will error out.
    * </ul>
    */
-  private Binding<?> createJitBinding(String key, Object requiredBy, ClassLoader classLoader,
+  private Binding<?> createBinding(String key, Object requiredBy, ClassLoader classLoader,
       boolean mustHaveInjections) {
     String builtInBindingsKey = Keys.getBuiltInBindingsKey(key);
     if (builtInBindingsKey != null) {
@@ -177,12 +178,14 @@
     }
 
     String className = Keys.getClassName(key);
-    if (className != null && !Keys.isAnnotated(key)) {
-      Binding<?> binding =
-          plugin.getAtInjectBinding(key, className, classLoader, mustHaveInjections);
-      if (binding != null) {
-        return binding;
-      }
+    if (className == null || Keys.isAnnotated(key)) {
+      // Cannot jit-bind annotated keys or generic types.
+      throw new IllegalArgumentException(key);
+    }
+    Binding<?> binding =
+        plugin.getAtInjectBinding(key, className, classLoader, mustHaveInjections);
+    if (binding != null) {
+      return binding;
     }
     throw new InvalidBindingException(className, "could not be bound with key " + key);
   }
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 03b3d8c..61013bf 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -205,8 +205,7 @@
       linker.installBindings(baseBindings);
       linker.installBindings(overrideBindings);
 
-      return new DaggerObjectGraph(base, linker, plugin, staticInjections,
-          injectableTypes);
+      return new DaggerObjectGraph(base, linker, plugin, staticInjections, injectableTypes);
     }
 
     @Override public ObjectGraph plus(Object... modules) {
@@ -240,10 +239,17 @@
      * Links all bindings, injectable types and static injections.
      */
     private Map<String, Binding<?>> linkEverything() {
+      Map<String, Binding<?>> bindings = linker.fullyLinkedBindings();
+      if (bindings != null) {
+        return bindings;
+      }
       synchronized (linker) {
+        if ((bindings = linker.fullyLinkedBindings()) != null) {
+          return bindings;
+        }
         linkStaticInjections();
         linkInjectableTypes();
-        return linker.linkAll();
+        return linker.linkAll(); // Linker.linkAll() implicitly does Linker.linkRequested().
       }
     }
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index adc9396..7562513 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -15,8 +15,10 @@
  */
 package dagger.internal;
 
+import dagger.ObjectGraph;
 import dagger.internal.Binding.InvalidBindingException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
@@ -42,6 +44,14 @@
   /** All of the object graph's bindings. This may contain unlinked bindings. */
   private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
 
+  /**
+   * An unmodifiable map containing all of the bindings available in this linker, fully linked.
+   * This will be null if the bindings are not yet fully linked. It provides both a signal
+   * of completion of the {@link #linkAll()} method, as well as a place to reference the final,
+   * fully linked map of bindings.
+   */
+  private volatile Map<String, Binding<?>> linkedBindings = null;
+
   private final Loader plugin;
 
   private final ErrorHandler errorHandler;
@@ -58,37 +68,60 @@
    * Adds all bindings in {@code toInstall}. The caller must call either {@link
    * #linkAll} or {@link #requestBinding} and {@link #linkRequested} before the
    * bindings can be used.
+   *
+   * This method may only be called before {@link #linkAll()}. Subsequent calls to
+   * {@link #installBindings()} will throw an {@link IllegalStateException}.
    */
   public void installBindings(Map<String, ? extends Binding<?>> toInstall) {
+    if (linkedBindings != null) {
+      throw new IllegalStateException("Cannot install further bindings after calling linkAll().");
+    }
     for (Map.Entry<String, ? extends Binding<?>> entry : toInstall.entrySet()) {
       bindings.put(entry.getKey(), scope(entry.getValue()));
     }
   }
 
   /**
-   * Links requested bindings and installed bindings, plus all of their
-   * transitive dependencies. This creates JIT bindings as necessary to fill in
-   * the gaps.
+   * Links all known bindings (whether requested or installed), plus all of their
+   * transitive dependencies. This loads injectable types' bindings as necessary to fill in
+   * the gaps.  If this method has returned successfully at least once, all further
+   * work is short-circuited.
    *
-   * @return all bindings known by this linker, which will all be linked.
+   * @throws AssertionError if this method is not called within a synchronized block which
+   *     holds this {@link Linker} as the lock object.
    */
   public Map<String, Binding<?>> linkAll() {
+    assertLockHeld();
+    if (linkedBindings != null) {
+      return linkedBindings;
+    }
     for (Binding<?> binding : bindings.values()) {
       if (!binding.isLinked()) {
         toLink.add(binding);
       }
     }
-    linkRequested();
-    return bindings;
+    linkRequested(); // This method throws if bindings are not resolvable/linkable.
+    linkedBindings = Collections.unmodifiableMap(bindings);
+    return linkedBindings;
+  }
+
+  /**
+   * Returns the map of all bindings available to this {@link Linker}, if and only if
+   * {@link #linkAll()} has successfully returned at least once, otherwise it returns null;
+   */
+  public Map<String, Binding<?>> fullyLinkedBindings() {
+    return linkedBindings;
   }
 
   /**
    * Links all requested bindings plus their transitive dependencies. This
    * creates JIT bindings as necessary to fill in the gaps.
+   *
+   * @throws AssertionError if this method is not called within a synchronized block which
+   *     holds this {@link Linker} as the lock object.
    */
   public void linkRequested() {
     assertLockHeld();
-
     Binding<?> binding;
     while ((binding = toLink.poll()) != null) {
       if (binding instanceof DeferredBinding) {
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 7562513..025ff48 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal;
 
-import dagger.ObjectGraph;
 import dagger.internal.Binding.InvalidBindingException;
 import java.util.ArrayList;
 import java.util.Collections;
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index 0f0c280..8be0c96 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -167,7 +167,7 @@
 
     Linker.ErrorHandler errorHandler = ignoreCompletenessErrors ? Linker.ErrorHandler.NULL
         : new GraphAnalysisErrorHandler(processingEnv, rootModule.getQualifiedName().toString());
-    Linker linker = new Linker(new GraphAnalysisLoader(processingEnv), errorHandler);
+    Linker linker = new Linker(null, new GraphAnalysisLoader(processingEnv), errorHandler);
     // Linker requires synchronization for calls to requestBinding and linkAll.
     // We know statically that we're single threaded, but we synchronize anyway
     // to make the linker happy.
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 61013bf..35cd80f 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -201,7 +201,8 @@
       }
 
       // Create a linker and install all of the user's bindings
-      Linker linker = new Linker(plugin, new ThrowingErrorHandler());
+      Linker linker =
+          new Linker((base != null) ? base.linker : null, plugin, new ThrowingErrorHandler());
       linker.installBindings(baseBindings);
       linker.installBindings(overrideBindings);
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 025ff48..d68256b 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -31,6 +31,13 @@
 public final class Linker {
   private static final Object UNINITIALIZED = new Object();
 
+  /**
+   * The base {@code Linker} which will be consulted to satisfy bindings not
+   * otherwise satisfiable from this {@code Linker}. The top-most {@code Linker}
+   * in a chain will have a null base linker.
+   */
+  private final Linker base;
+
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
   private final Queue<Binding<?>> toLink = new LinkedList<Binding<?>>();
 
@@ -55,10 +62,11 @@
 
   private final ErrorHandler errorHandler;
 
-  public Linker(Loader plugin, ErrorHandler errorHandler) {
+  public Linker(Linker base, Loader plugin, ErrorHandler errorHandler) {
     if (plugin == null) throw new NullPointerException("plugin");
     if (errorHandler == null) throw new NullPointerException("errorHandler");
 
+    this.base = base;
     this.plugin = plugin;
     this.errorHandler = errorHandler;
   }
@@ -261,7 +269,15 @@
       boolean mustHaveInjections, boolean library) {
     assertLockHeld();
 
-    Binding<?> binding = bindings.get(key);
+    Binding<?> binding = null;
+    for (Linker linker = this; linker != null; linker = linker.base) {
+      binding = linker.bindings.get(key);
+      if (binding != null) {
+        if (linker != this && !binding.isLinked()) throw new AssertionError();
+        break;
+      }
+    }
+
     if (binding == null) {
       // We can't satisfy this binding. Make sure it'll work next time!
       Binding<?> deferredBinding =
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 586a693..5503e17 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -15,11 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.base.Function;
-import com.google.common.base.Joiner;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Ordering;
 import com.squareup.javawriter.JavaWriter;
 import dagger.Lazy;
 import dagger.Module;
@@ -71,9 +66,9 @@
 import static dagger.internal.codegen.Util.getNoArgsConstructor;
 import static dagger.internal.codegen.Util.getPackage;
 import static dagger.internal.codegen.Util.isCallableConstructor;
+import static dagger.internal.codegen.Util.isInterface;
 import static dagger.internal.codegen.Util.typeToString;
 import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
-import static java.util.Arrays.asList;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -269,33 +264,15 @@
     writer.beginType(adapterName, "class", EnumSet.of(PUBLIC, FINAL),
         JavaWriter.type(ModuleAdapter.class, typeName));
 
-    final List<String> providedTypes = FluentIterable.from(providerMethods)
-        .transform(new Function<ExecutableElement, String>() {
-          @Override public String apply(ExecutableElement element) {
-            return GeneratorKeys.get(element.getReturnType());
-          }
-        }).toList();
-    StringBuilder injectsField = new StringBuilder("{");
-    Iterable<String> injectsFieldKeys = FluentIterable.<Object>from(asList(injects))
-        .transform(new Cast<TypeMirror>())
-        .transformAndConcat(new Function<TypeMirror, Iterable<String>>() {
-          @Override public Iterable<String> apply(TypeMirror type) {
-            String key = GeneratorKeys.get(type);
-            if (!providedTypes.contains(key) && Util.needsMemberInjection(type)) {
-              String membersKey = GeneratorKeys.rawMembersKey(type);
-              Iterable<String> keys = ImmutableList.of(membersKey, key);
-              return keys;
-            }
-            return ImmutableList.of(key);
-          }
-        })
-        .transform(new Function<String, String>() {
-          @Override public String apply(String key) {
-            return JavaWriter.stringLiteral(key);
-          }
-        })
-        .toSortedSet(Ordering.natural());
-    Joiner.on(", ").appendTo(injectsField, injectsFieldKeys).append("}");
+    StringBuilder injectsField = new StringBuilder().append("{ ");
+    for (Object injectableType : injects) {
+      TypeMirror typeMirror = (TypeMirror) injectableType;
+      String key = isInterface(typeMirror)
+          ? GeneratorKeys.get(typeMirror)
+          : GeneratorKeys.rawMembersKey(typeMirror);
+      injectsField.append(JavaWriter.stringLiteral(key)).append(", ");
+    }
+    injectsField.append("}");
     writer.emitField("String[]", "INJECTS", EnumSet.of(PRIVATE, STATIC, FINAL),
         injectsField.toString());
 
@@ -536,17 +513,4 @@
     }
     return parameter.getSimpleName().toString();
   }
-
-  /**
-   * A function used to perform a cast to a strongly known type.  This does not actually
-   * perform any casting logic, but bridges Java's typesystem.  {@link Cast} should only
-   * be used in circumstances where the cast is bullet-proof and safe.
-   */
-  private static final class Cast<T> implements Function<Object, T> {
-    @SuppressWarnings("unchecked")
-    @Override
-    public T apply(Object o) {
-      return (T) o;
-    }
-  }
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 0007859..0f8b36c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,15 +16,12 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
 import dagger.internal.Keys;
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.AnnotationValueVisitor;
@@ -34,14 +31,12 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ErrorType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVariable;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
@@ -243,23 +238,6 @@
     }
   }
 
-  /**
-   * Returns true if the type reflected by this TypeMirror contains @Inject fields.
-   */
-  public static boolean needsMemberInjection(TypeMirror type) {
-    return type.accept(new SimpleTypeVisitor6<Boolean, Void>() {
-      @Override public Boolean visitDeclared(DeclaredType declaredType, Void v) {
-        List<? extends Element> enclosed = declaredType.asElement().getEnclosedElements();
-        return FluentIterable.<VariableElement>from(ElementFilter.fieldsIn(enclosed))
-            .anyMatch(new Predicate<VariableElement>() {
-              @Override public boolean apply(VariableElement e) {
-                return e.getAnnotation(Inject.class) != null;
-              }
-            });
-      }
-    }, null);
-  }
-
   // TODO(sgoldfed): better format for other types of elements?
   static String elementToString(Element element) {
     switch (element.getKind()) {
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index 857b546..aec56e5 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -44,7 +44,7 @@
             "import dagger.internal.ModuleAdapter;",
             "public final class Basic$AModule$$ModuleAdapter",
             "    extends ModuleAdapter<Basic.AModule> {",
-            "  private static final String[] INJECTS = {\"Basic$A\"};",
+            "  private static final String[] INJECTS = {\"members/Basic$A\"};",
             "  private static final Class<?>[] STATIC_INJECTIONS = {};",
             "  private static final Class<?>[] INCLUDES = {};",
             "  public Basic$AModule$$ModuleAdapter() {",
@@ -99,7 +99,7 @@
         "import javax.inject.Inject;",
         "class Field {",
         "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
-        "  @Module(injects = { A.class, String.class })",
+        "  @Module(injects = A.class)",
         "  static class AModule { @Provides String name() { return \"foo\"; }}",
         "}"));
 
@@ -111,8 +111,7 @@
         "import javax.inject.Provider;",
         "public final class Field$AModule$$ModuleAdapter",
         "    extends ModuleAdapter<Field.AModule> {",
-        "  private static final String[] INJECTS = ",
-        "      {\"Field$A\", \"java.lang.String\"};",
+        "  private static final String[] INJECTS = {\"members/Field$A\"};",
         "  private static final Class<?>[] STATIC_INJECTIONS = {};",
         "  private static final Class<?>[] INCLUDES = {};",
         "  public Field$AModule$$ModuleAdapter() {",
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
index d7af842..b321126 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
@@ -23,7 +23,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static java.util.Arrays.asList;
@@ -31,115 +30,6 @@
 
 @RunWith(JUnit4.class)
 public final class ModuleAdapterGenerationTest {
-  @Test public void injectsMembersInjectedAndProvidedAndConstructedTypes() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "class Field {",
-        "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
-        "  static class B { @Inject String name; }",
-        "  @Module(injects = { A.class, String.class, B.class })",
-        "  static class AModule { @Provides String name() { return \"foo\"; }}",
-        "}"));
-
-    JavaFileObject expectedModuleAdapter =
-        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
-        "import dagger.internal.Binding;",
-        "import dagger.internal.ModuleAdapter;",
-        "import java.util.Map;",
-        "import javax.inject.Provider;",
-        "public final class Field$AModule$$ModuleAdapter extends ModuleAdapter<Field.AModule> {",
-        "  private static final String[] INJECTS = ",
-        "      {\"Field$A\", \"Field$B\", \"java.lang.String\", \"members/Field$B\"};",
-        "  private static final Class<?>[] STATIC_INJECTIONS = {};",
-        "  private static final Class<?>[] INCLUDES = {};",
-        "  public Field$AModule$$ModuleAdapter() {",
-        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
-        "  }",
-        "  @Override public Field.AModule newModule() {",
-        "    return new Field.AModule();",
-        "  }",
-        "  @Override public void getBindings(Map<String, Binding<?>> map, Field.AModule module) {",
-        "    map.put(\"java.lang.String\", new NameProvidesAdapter(module));", // eager new!
-        "  }",
-        "  public static final class NameProvidesAdapter", // corresponds to method name
-        "      extends Binding<String> implements Provider<String> {",
-        "    private final Field.AModule module;",
-        "    public NameProvidesAdapter(Field.AModule module) {",
-        "      super(\"java.lang.String\", null, NOT_SINGLETON, \"Field.AModule.name()\");",
-        "      this.module = module;",
-        "      setLibrary(false);",
-        "    }",
-        "    @Override public String get() {",
-        "      return module.name();", // corresponds to @Provides method
-        "    }",
-        "  }",
-        "}"));
-
-    JavaFileObject expectedInjectAdapterA =
-        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
-            "import dagger.internal.Binding;",
-            "import dagger.internal.Linker;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "public final class Field$A$$InjectAdapter",
-            "    extends Binding<Field.A> implements Provider<Field.A> {",
-            "  private Binding<String> name;", // For Constructor.
-            "  public Field$A$$InjectAdapter() {",
-            "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
-            "  }",
-            "  @Override @SuppressWarnings(\"unchecked\")",
-            "  public void attach(Linker linker) {",
-            "    name = (Binding<String>)linker.requestBinding(",
-            "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());",
-            "  }",
-            "  @Override public void getDependencies(",
-            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
-            "    getBindings.add(name);", // Name is added to dependencies.
-            "  }",
-            "  @Override public Field.A get() {",
-            "    Field.A result = new Field.A(name.get());", // Adds constructor parameter.
-            "    return result;",
-            "  }",
-            "}"));
-
-    JavaFileObject expectedInjectAdapterB =
-        JavaFileObjects.forSourceString("Field$B$$InjectAdapter", Joiner.on("\n").join(
-            "import dagger.MembersInjector;",
-            "import dagger.internal.Binding;",
-            "import dagger.internal.Linker;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "public final class Field$B$$InjectAdapter",
-            "    extends Binding<Field.B> implements Provider<Field.B>, MembersInjector<Field.B> {",
-            "  private Binding<String> name;", // For field.
-            "  public Field$B$$InjectAdapter() {",
-            "    super(\"Field$B\", \"members/Field$B\", NOT_SINGLETON, Field.B.class);",
-            "  }",
-            "  @Override @SuppressWarnings(\"unchecked\")",
-            "  public void attach(Linker linker) {",
-            "    name = (Binding<String>)linker.requestBinding(",
-            "      \"java.lang.String\", Field.B.class, getClass().getClassLoader());",
-            "  }",
-            "  @Override public void getDependencies(",
-            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
-            "    injectMembersBindings.add(name);", // Name is added to dependencies.
-            "  }",
-            "  @Override public Field.B get() {",
-            "    Field.B result = new Field.B();",
-            "    injectMembers(result);",
-            "    return result;",
-            "  }",
-            "  @Override public void injectMembers(Field.B object) {",
-            "    object.name = name.get();", // Inject field.
-            "  }",
-            "}"));
-    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedModuleAdapter, expectedInjectAdapterA, expectedInjectAdapterB);
-  }
 
   @Test public void providesHasParameterNamedModule() {
     JavaFileObject a = JavaFileObjects.forSourceString("A", Joiner.on("\n").join(
@@ -152,10 +42,12 @@
     JavaFileObject module = JavaFileObjects.forSourceString("BModule", Joiner.on("\n").join(
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import javax.inject.Inject;",
         "@Module(injects = B.class)",
         "class BModule { @Provides B b(A module) { return new B(); }}"));
 
     ASSERT.about(javaSources()).that(asList(a, b, module)).processedWith(daggerProcessors())
         .compilesWithoutError();
   }
+
 }
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
new file mode 100644
index 0000000..994c780
--- /dev/null
+++ b/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
@@ -0,0 +1,90 @@
+/**
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.tests.integration.operation;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import dagger.Provides;
+import javax.inject.Inject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public final class SimpleInjectionTest {
+  static abstract class AbstractFoo {
+    @Inject String blah;
+  }
+
+  static class Foo extends AbstractFoo { }
+
+  @Module(injects = Foo.class)
+  static class FooModule {
+    @Provides String string() { return "blah"; }
+  }
+
+  @Module(injects = Foo.class)
+  static class ProvidingFooModule {
+    @Provides String string() { return "blah"; }
+    @Provides Foo foo(String blah) {
+      Foo foo = new Foo();
+      foo.blah = blah;
+      return foo;
+    }
+  }
+
+  @Test public void memberInject_WithoutProvidesMethod() {
+    Foo foo = new Foo();
+    ObjectGraph.create(FooModule.class).inject(foo);
+    ASSERT.that(foo.blah).equals("blah");
+  }
+
+  @Test public void membersInject_WithProvidesMethod() {
+    Foo foo = new Foo();
+    ObjectGraph.create(ProvidingFooModule.class).inject(foo);
+    ASSERT.that(foo.blah).equals("blah");
+  }
+
+  @Test public void get_WithProvidesMethod() {
+    Foo foo = ObjectGraph.create(ProvidingFooModule.class).get(Foo.class);
+    ASSERT.that(foo.blah).equals("blah");
+  }
+
+  static class Bar { }
+
+  @Module(injects = Bar.class)
+  static class BarModule {
+  }
+
+  @Test public void membersInject_WithNonInjectable() {
+    Bar bar = new Bar();
+    ObjectGraph.create(BarModule.class).inject(bar);
+  }
+
+  @Module(injects = Bar.class)
+  static class ProvidingBarModule {
+    @Provides public Bar bar() { return new Bar(); }
+  }
+
+  @Test public void membersInject_WithProvidedNonInjectable() {
+    Bar bar = ObjectGraph.create(ProvidingBarModule.class).get(Bar.class);
+    ASSERT.that(bar).isNotNull();
+  }
+
+}
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 586a693..5503e17 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -15,11 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.base.Function;
-import com.google.common.base.Joiner;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Ordering;
 import com.squareup.javawriter.JavaWriter;
 import dagger.Lazy;
 import dagger.Module;
@@ -71,9 +66,9 @@
 import static dagger.internal.codegen.Util.getNoArgsConstructor;
 import static dagger.internal.codegen.Util.getPackage;
 import static dagger.internal.codegen.Util.isCallableConstructor;
+import static dagger.internal.codegen.Util.isInterface;
 import static dagger.internal.codegen.Util.typeToString;
 import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
-import static java.util.Arrays.asList;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -269,33 +264,15 @@
     writer.beginType(adapterName, "class", EnumSet.of(PUBLIC, FINAL),
         JavaWriter.type(ModuleAdapter.class, typeName));
 
-    final List<String> providedTypes = FluentIterable.from(providerMethods)
-        .transform(new Function<ExecutableElement, String>() {
-          @Override public String apply(ExecutableElement element) {
-            return GeneratorKeys.get(element.getReturnType());
-          }
-        }).toList();
-    StringBuilder injectsField = new StringBuilder("{");
-    Iterable<String> injectsFieldKeys = FluentIterable.<Object>from(asList(injects))
-        .transform(new Cast<TypeMirror>())
-        .transformAndConcat(new Function<TypeMirror, Iterable<String>>() {
-          @Override public Iterable<String> apply(TypeMirror type) {
-            String key = GeneratorKeys.get(type);
-            if (!providedTypes.contains(key) && Util.needsMemberInjection(type)) {
-              String membersKey = GeneratorKeys.rawMembersKey(type);
-              Iterable<String> keys = ImmutableList.of(membersKey, key);
-              return keys;
-            }
-            return ImmutableList.of(key);
-          }
-        })
-        .transform(new Function<String, String>() {
-          @Override public String apply(String key) {
-            return JavaWriter.stringLiteral(key);
-          }
-        })
-        .toSortedSet(Ordering.natural());
-    Joiner.on(", ").appendTo(injectsField, injectsFieldKeys).append("}");
+    StringBuilder injectsField = new StringBuilder().append("{ ");
+    for (Object injectableType : injects) {
+      TypeMirror typeMirror = (TypeMirror) injectableType;
+      String key = isInterface(typeMirror)
+          ? GeneratorKeys.get(typeMirror)
+          : GeneratorKeys.rawMembersKey(typeMirror);
+      injectsField.append(JavaWriter.stringLiteral(key)).append(", ");
+    }
+    injectsField.append("}");
     writer.emitField("String[]", "INJECTS", EnumSet.of(PRIVATE, STATIC, FINAL),
         injectsField.toString());
 
@@ -536,17 +513,4 @@
     }
     return parameter.getSimpleName().toString();
   }
-
-  /**
-   * A function used to perform a cast to a strongly known type.  This does not actually
-   * perform any casting logic, but bridges Java's typesystem.  {@link Cast} should only
-   * be used in circumstances where the cast is bullet-proof and safe.
-   */
-  private static final class Cast<T> implements Function<Object, T> {
-    @SuppressWarnings("unchecked")
-    @Override
-    public T apply(Object o) {
-      return (T) o;
-    }
-  }
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 0007859..0f8b36c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,15 +16,12 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
 import dagger.internal.Keys;
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.AnnotationValueVisitor;
@@ -34,14 +31,12 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ErrorType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVariable;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
@@ -243,23 +238,6 @@
     }
   }
 
-  /**
-   * Returns true if the type reflected by this TypeMirror contains @Inject fields.
-   */
-  public static boolean needsMemberInjection(TypeMirror type) {
-    return type.accept(new SimpleTypeVisitor6<Boolean, Void>() {
-      @Override public Boolean visitDeclared(DeclaredType declaredType, Void v) {
-        List<? extends Element> enclosed = declaredType.asElement().getEnclosedElements();
-        return FluentIterable.<VariableElement>from(ElementFilter.fieldsIn(enclosed))
-            .anyMatch(new Predicate<VariableElement>() {
-              @Override public boolean apply(VariableElement e) {
-                return e.getAnnotation(Inject.class) != null;
-              }
-            });
-      }
-    }, null);
-  }
-
   // TODO(sgoldfed): better format for other types of elements?
   static String elementToString(Element element) {
     switch (element.getKind()) {
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index 857b546..59aff69 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -44,7 +44,7 @@
             "import dagger.internal.ModuleAdapter;",
             "public final class Basic$AModule$$ModuleAdapter",
             "    extends ModuleAdapter<Basic.AModule> {",
-            "  private static final String[] INJECTS = {\"Basic$A\"};",
+            "  private static final String[] INJECTS = {\"members/Basic$A\"};",
             "  private static final Class<?>[] STATIC_INJECTIONS = {};",
             "  private static final Class<?>[] INCLUDES = {};",
             "  public Basic$AModule$$ModuleAdapter() {",
@@ -76,99 +76,4 @@
         .generatesSources(expectedModuleAdapter, expectedInjectAdapter);
 
   }
-
-  /**
-   * Shows current behavior for a {@link dagger.Provides provides method}
-   * used to supply an injected ctor parameter.
-   *
-   * <ul>
-   *   <li>{@code ProvidesAdapter} invokes the module's provides method on
-   *   {@code get}</li>
-   *   <li>On {@code getBindings}, the above is newed up and linked to its type
-   *   key.
-   *   <li>{@code InjectAdapter} contains a field for the parameter binding,
-   *   referenced in {@code getDependencies} and set on {@code attach}</li>
-   *   <li>On {@code get}, the injected constructor is called with the value of
-   *   {@link dagger.internal.Binding#get}</li>
-   * </ul>
-   */
-  @Test public void providerForCtorInjection() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "class Field {",
-        "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
-        "  @Module(injects = { A.class, String.class })",
-        "  static class AModule { @Provides String name() { return \"foo\"; }}",
-        "}"));
-
-    JavaFileObject expectedModuleAdapter =
-        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
-        "import dagger.internal.Binding;",
-        "import dagger.internal.ModuleAdapter;",
-        "import java.util.Map;",
-        "import javax.inject.Provider;",
-        "public final class Field$AModule$$ModuleAdapter",
-        "    extends ModuleAdapter<Field.AModule> {",
-        "  private static final String[] INJECTS = ",
-        "      {\"Field$A\", \"java.lang.String\"};",
-        "  private static final Class<?>[] STATIC_INJECTIONS = {};",
-        "  private static final Class<?>[] INCLUDES = {};",
-        "  public Field$AModule$$ModuleAdapter() {",
-        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
-        "  }",
-        "  @Override public Field.AModule newModule() {",
-        "    return new Field.AModule();",
-        "  }",
-        "  @Override public void getBindings(Map<String, Binding<?>> map, Field.AModule module) {",
-        "    map.put(\"java.lang.String\", new NameProvidesAdapter(module));", // eager new!
-        "  }",
-        "  public static final class NameProvidesAdapter", // corresponds to method name
-        "      extends Binding<String> implements Provider<String> {",
-        "    private final Field.AModule module;",
-        "    public NameProvidesAdapter(Field.AModule module) {",
-        "      super(\"java.lang.String\", null, NOT_SINGLETON, \"Field.AModule.name()\");",
-        "      this.module = module;",
-        "      setLibrary(false);",
-        "    }",
-        "    @Override public String get() {",
-        "      return module.name();", // corresponds to @Provides method
-        "    }",
-        "  }",
-        "}"));
-
-    JavaFileObject expectedInjectAdapter =
-        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
-            "import dagger.internal.Binding;",
-            "import dagger.internal.Linker;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "public final class Field$A$$InjectAdapter",
-            "    extends Binding<Field.A> implements Provider<Field.A> {",
-            "  private Binding<String> name;", // for ctor
-            "  public Field$A$$InjectAdapter() {",
-            "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
-            "  }",
-            "  @Override @SuppressWarnings(\"unchecked\")",
-            "  public void attach(Linker linker) {",
-            "    name = (Binding<String>)linker.requestBinding(", // binding key is not a class
-            "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());",
-            "  }",
-            "  @Override public void getDependencies(",
-            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
-            "    getBindings.add(name);", // name is added to dependencies
-            "  }",
-            "  @Override public Field.A get() {",
-            "    Field.A result = new Field.A(name.get());", // adds ctor param
-            "    return result;",
-            "  }",
-            "}"));
-
-    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedModuleAdapter, expectedInjectAdapter);
-
-  }
 }
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
index d7af842..3983ee9 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
@@ -31,6 +31,101 @@
 
 @RunWith(JUnit4.class)
 public final class ModuleAdapterGenerationTest {
+  /**
+   * Shows current behavior for a {@link dagger.Provides provides method}
+   * used to supply an injected ctor parameter.
+   *
+   * <ul>
+   *   <li>{@code ProvidesAdapter} invokes the module's provides method on
+   *   {@code get}</li>
+   *   <li>On {@code getBindings}, the above is newed up and linked to its type
+   *   key.
+   *   <li>{@code InjectAdapter} contains a field for the parameter binding,
+   *   referenced in {@code getDependencies} and set on {@code attach}</li>
+   *   <li>On {@code get}, the injected constructor is called with the value of
+   *   {@link dagger.internal.Binding#get}</li>
+   * </ul>
+   */
+  @Test public void providerForCtorInjection() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "class Field {",
+        "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
+        "  @Module(injects = { A.class, String.class })",
+        "  static class AModule { @Provides String name() { return \"foo\"; }}",
+        "}"));
+
+    JavaFileObject expectedModuleAdapter =
+        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
+        "import dagger.internal.Binding;",
+        "import dagger.internal.ModuleAdapter;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "public final class Field$AModule$$ModuleAdapter",
+        "    extends ModuleAdapter<Field.AModule> {",
+        "  private static final String[] INJECTS = ",
+        "      {\"members/Field$A\", \"members/java.lang.String\"};",
+        "  private static final Class<?>[] STATIC_INJECTIONS = {};",
+        "  private static final Class<?>[] INCLUDES = {};",
+        "  public Field$AModule$$ModuleAdapter() {",
+        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
+        "  }",
+        "  @Override public Field.AModule newModule() {",
+        "    return new Field.AModule();",
+        "  }",
+        "  @Override public void getBindings(Map<String, Binding<?>> map, Field.AModule module) {",
+        "    map.put(\"java.lang.String\", new NameProvidesAdapter(module));", // eager new!
+        "  }",
+        "  public static final class NameProvidesAdapter", // corresponds to method name
+        "      extends Binding<String> implements Provider<String> {",
+        "    private final Field.AModule module;",
+        "    public NameProvidesAdapter(Field.AModule module) {",
+        "      super(\"java.lang.String\", null, NOT_SINGLETON, \"Field.AModule.name()\");",
+        "      this.module = module;",
+        "      setLibrary(false);",
+        "    }",
+        "    @Override public String get() {",
+        "      return module.name();", // corresponds to @Provides method
+        "    }",
+        "  }",
+        "}"));
+
+    JavaFileObject expectedInjectAdapter =
+        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
+            "import dagger.internal.Binding;",
+            "import dagger.internal.Linker;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "public final class Field$A$$InjectAdapter",
+            "    extends Binding<Field.A> implements Provider<Field.A> {",
+            "  private Binding<String> name;", // for ctor
+            "  public Field$A$$InjectAdapter() {",
+            "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
+            "  }",
+            "  @Override @SuppressWarnings(\"unchecked\")",
+            "  public void attach(Linker linker) {",
+            "    name = (Binding<String>)linker.requestBinding(", // binding key is not a class
+            "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());",
+            "  }",
+            "  @Override public void getDependencies(",
+            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
+            "    getBindings.add(name);", // name is added to dependencies
+            "  }",
+            "  @Override public Field.A get() {",
+            "    Field.A result = new Field.A(name.get());", // adds ctor param
+            "    return result;",
+            "  }",
+            "}"));
+
+    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expectedModuleAdapter, expectedInjectAdapter);
+
+  }
+
   @Test public void injectsMembersInjectedAndProvidedAndConstructedTypes() {
     JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
         "import dagger.Module;",
@@ -51,7 +146,7 @@
         "import javax.inject.Provider;",
         "public final class Field$AModule$$ModuleAdapter extends ModuleAdapter<Field.AModule> {",
         "  private static final String[] INJECTS = ",
-        "      {\"Field$A\", \"Field$B\", \"java.lang.String\", \"members/Field$B\"};",
+        "      {\"members/Field$A\", \"members/java.lang.String\", \"members/Field$B\"};",
         "  private static final Class<?>[] STATIC_INJECTIONS = {};",
         "  private static final Class<?>[] INCLUDES = {};",
         "  public Field$AModule$$ModuleAdapter() {",
@@ -141,6 +236,7 @@
         .generatesSources(expectedModuleAdapter, expectedInjectAdapterA, expectedInjectAdapterB);
   }
 
+
   @Test public void providesHasParameterNamedModule() {
     JavaFileObject a = JavaFileObjects.forSourceString("A", Joiner.on("\n").join(
         "import javax.inject.Inject;",
@@ -152,10 +248,12 @@
     JavaFileObject module = JavaFileObjects.forSourceString("BModule", Joiner.on("\n").join(
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import javax.inject.Inject;",
         "@Module(injects = B.class)",
         "class BModule { @Provides B b(A module) { return new B(); }}"));
 
     ASSERT.about(javaSources()).that(asList(a, b, module)).processedWith(daggerProcessors())
         .compilesWithoutError();
   }
+
 }
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
similarity index 97%
rename from compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
rename to compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index adeea2a..5f7451c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.tests.integration.operation;
 
 import dagger.Module;
 import dagger.ObjectGraph;
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
new file mode 100644
index 0000000..994c780
--- /dev/null
+++ b/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
@@ -0,0 +1,90 @@
+/**
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.tests.integration.operation;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import dagger.Provides;
+import javax.inject.Inject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public final class SimpleInjectionTest {
+  static abstract class AbstractFoo {
+    @Inject String blah;
+  }
+
+  static class Foo extends AbstractFoo { }
+
+  @Module(injects = Foo.class)
+  static class FooModule {
+    @Provides String string() { return "blah"; }
+  }
+
+  @Module(injects = Foo.class)
+  static class ProvidingFooModule {
+    @Provides String string() { return "blah"; }
+    @Provides Foo foo(String blah) {
+      Foo foo = new Foo();
+      foo.blah = blah;
+      return foo;
+    }
+  }
+
+  @Test public void memberInject_WithoutProvidesMethod() {
+    Foo foo = new Foo();
+    ObjectGraph.create(FooModule.class).inject(foo);
+    ASSERT.that(foo.blah).equals("blah");
+  }
+
+  @Test public void membersInject_WithProvidesMethod() {
+    Foo foo = new Foo();
+    ObjectGraph.create(ProvidingFooModule.class).inject(foo);
+    ASSERT.that(foo.blah).equals("blah");
+  }
+
+  @Test public void get_WithProvidesMethod() {
+    Foo foo = ObjectGraph.create(ProvidingFooModule.class).get(Foo.class);
+    ASSERT.that(foo.blah).equals("blah");
+  }
+
+  static class Bar { }
+
+  @Module(injects = Bar.class)
+  static class BarModule {
+  }
+
+  @Test public void membersInject_WithNonInjectable() {
+    Bar bar = new Bar();
+    ObjectGraph.create(BarModule.class).inject(bar);
+  }
+
+  @Module(injects = Bar.class)
+  static class ProvidingBarModule {
+    @Provides public Bar bar() { return new Bar(); }
+  }
+
+  @Test public void membersInject_WithProvidedNonInjectable() {
+    Bar bar = ObjectGraph.create(ProvidingBarModule.class).get(Bar.class);
+    ASSERT.that(bar).isNotNull();
+  }
+
+}
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index 8be0c96..d009f75 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -19,8 +19,10 @@
 import dagger.Provides;
 import dagger.internal.Binding;
 import dagger.internal.Binding.InvalidBindingException;
+import dagger.internal.BindingsGroup;
 import dagger.internal.Linker;
 import dagger.internal.ProblemDetector;
+import dagger.internal.ProvidesBinding;
 import dagger.internal.SetBinding;
 import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
 import java.io.IOException;
@@ -56,10 +58,10 @@
 
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
+import static dagger.internal.codegen.Util.className;
 import static dagger.internal.codegen.Util.getAnnotation;
 import static dagger.internal.codegen.Util.getPackage;
 import static dagger.internal.codegen.Util.isInterface;
-import static dagger.internal.codegen.Util.methodName;
 import static java.util.Arrays.asList;
 
 /**
@@ -172,13 +174,21 @@
     // We know statically that we're single threaded, but we synchronize anyway
     // to make the linker happy.
     synchronized (linker) {
-      Map<String, Binding<?>> baseBindings = new LinkedHashMap<String, Binding<?>>();
-      Map<String, Binding<?>> overrideBindings = new LinkedHashMap<String, Binding<?>>();
+      BindingsGroup baseBindings = new BindingsGroup() {
+        @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
+          return super.put(key, value);
+        }
+      };
+      BindingsGroup overrideBindings = new BindingsGroup() {
+        @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
+          throw new IllegalStateException("Module overrides cannot contribute set bindings.");
+        }
+      };
       for (TypeElement module : allModules.values()) {
         Map<String, Object> annotation = getAnnotation(Module.class, module);
         boolean overrides = (Boolean) annotation.get("overrides");
         boolean library = (Boolean) annotation.get("library");
-        Map<String, Binding<?>> addTo = overrides ? overrideBindings : baseBindings;
+        BindingsGroup addTo = overrides ? overrideBindings : baseBindings;
 
         // Gather the injectable types from the annotation.
         Set<String> injectsProvisionKeys = new LinkedHashSet<String>();
@@ -208,9 +218,9 @@
           }
           ExecutableElement providerMethod = (ExecutableElement) enclosed;
           String key = GeneratorKeys.get(providerMethod);
-          Binding binding = new ProviderMethodBinding(key, providerMethod, library);
+          ProvidesBinding<?> binding = new ProviderMethodBinding(key, providerMethod, library);
 
-          Binding previous = addTo.get(key);
+          Binding<?> previous = addTo.get(key);
           if (previous != null) {
             if ((provides.type() == SET || provides.type() == SET_VALUES)
                 && previous instanceof SetBinding) {
@@ -230,7 +240,11 @@
               if (injectsProvisionKeys.contains(binding.provideKey)) {
                 binding.setDependedOn(true);
               }
-              addTo.put(key, binding);
+              try {
+                addTo.contributeProvidesBinding(key, binding);
+              } catch (IllegalStateException ise) {
+                throw new ModuleValidationException(ise.getMessage(), providerMethod);
+              }
               break;
 
             case SET:
@@ -264,11 +278,6 @@
     return processingEnv.getElementUtils();
   }
 
-  private String shortMethodName(ExecutableElement method) {
-    return method.getEnclosingElement().getSimpleName().toString()
-        + "." + method.getSimpleName() + "()";
-  }
-
   void collectIncludesRecursively(
       TypeElement module, Map<String, TypeElement> result, Deque<String> path) {
     Map<String, Object> annotation = getAnnotation(Module.class, module);
@@ -317,12 +326,13 @@
     }
   }
 
-  static class ProviderMethodBinding extends Binding<Object> {
+  static class ProviderMethodBinding extends ProvidesBinding<Object> {
     private final ExecutableElement method;
     private final Binding<?>[] parameters;
 
     protected ProviderMethodBinding(String provideKey, ExecutableElement method, boolean library) {
-      super(provideKey, null, method.getAnnotation(Singleton.class) != null, methodName(method));
+      super(provideKey, method.getAnnotation(Singleton.class) != null,
+          className(method), method.getSimpleName().toString());
       this.method = method;
       this.parameters = new Binding[method.getParameters().size()];
       setLibrary(library);
@@ -348,6 +358,11 @@
     @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
       Collections.addAll(get, parameters);
     }
+
+    @Override public String toString() {
+      return "ProvidesBinding[key=" + provideKey
+          + " method=" + moduleClass + "." + method.getSimpleName() + "()";
+    }
   }
 
   void writeDotFile(TypeElement module, Map<String, Binding<?>> bindings) throws IOException {
@@ -363,9 +378,9 @@
   }
 
   static class ModuleValidationException extends IllegalStateException {
-    final TypeElement source;
+    final Element source;
 
-    public ModuleValidationException(String message, TypeElement source) {
+    public ModuleValidationException(String message, Element source) {
       super(message);
       this.source = source;
     }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
index 26394b6..bfa9418 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
@@ -125,7 +125,7 @@
     return result.toString();
   }
 
-  /** A Comparator for Bindings so we can insure a consistent ordering of output. */
+  /** A Comparator for BindingsGroup so we can insure a consistent ordering of output. */
   private static class BindingComparator implements Comparator<Binding<?>> {
     @Override
     public int compare(Binding<?> left, Binding<?> right) {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 5503e17..e2d74f2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -20,8 +20,10 @@
 import dagger.Module;
 import dagger.Provides;
 import dagger.internal.Binding;
+import dagger.internal.BindingsGroup;
 import dagger.internal.Linker;
 import dagger.internal.ModuleAdapter;
+import dagger.internal.ProvidesBinding;
 import dagger.internal.SetBinding;
 import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
 import java.io.IOException;
@@ -81,8 +83,7 @@
  */
 @SupportedAnnotationTypes({ "*" })
 public final class ModuleAdapterProcessor extends AbstractProcessor {
-  private static final String BINDINGS_MAP = JavaWriter.type(
-      Map.class, String.class.getCanonicalName(), Binding.class.getCanonicalName() + "<?>");
+  private static final String BINDINGS_MAP = JavaWriter.type(BindingsGroup.class);
   private static final List<String> INVALID_RETURN_TYPES =
       Arrays.asList(Provider.class.getCanonicalName(), Lazy.class.getCanonicalName());
 
@@ -323,7 +324,7 @@
       writer.emitEmptyLine();
       writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
       writer.emitAnnotation(Override.class);
-      writer.beginMethod("void", "getBindings", EnumSet.of(PUBLIC), BINDINGS_MAP, "map",
+      writer.beginMethod("void", "getBindings", EnumSet.of(PUBLIC), BINDINGS_MAP, "bindings",
           typeName, "module");
 
       for (ExecutableElement providerMethod : providerMethods) {
@@ -331,20 +332,21 @@
         switch (provides.type()) {
           case UNIQUE: {
             String key = GeneratorKeys.get(providerMethod);
-            writer.emitStatement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
+            writer.emitStatement("bindings.contributeProvidesBinding(%s, new %s(module))",
+                JavaWriter.stringLiteral(key),
                 bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
             break;
           }
           case SET: {
             String key = GeneratorKeys.getSetKey(providerMethod);
-            writer.emitStatement("SetBinding.add(map, %s, new %s(module))",
+            writer.emitStatement("SetBinding.add(bindings, %s, new %s(module))",
                 JavaWriter.stringLiteral(key),
                 bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
             break;
           }
           case SET_VALUES: {
             String key = GeneratorKeys.get(providerMethod);
-            writer.emitStatement("SetBinding.add(map, %s, new %s(module))",
+            writer.emitStatement("SetBinding.add(bindings, %s, new %s(module))",
                 JavaWriter.stringLiteral(key),
                 bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
             break;
@@ -369,13 +371,14 @@
     Set<String> imports = new LinkedHashSet<String>();
     imports.add(ModuleAdapter.class.getCanonicalName());
     if (providers) {
-      imports.add(Binding.class.getCanonicalName());
-      imports.add(Map.class.getCanonicalName());
+      imports.add(BindingsGroup.class.getCanonicalName());
       imports.add(Provider.class.getCanonicalName());
+      imports.add(ProvidesBinding.class.getCanonicalName());
     }
     if (dependencies) {
       imports.add(Linker.class.getCanonicalName());
       imports.add(Set.class.getCanonicalName());
+      imports.add(Binding.class.getCanonicalName());
     }
     if (multibindings) {
       imports.add(SetBinding.class.getCanonicalName());
@@ -439,7 +442,7 @@
     writer.emitEmptyLine();
     writer.emitJavadoc(bindingTypeDocs(returnType, false, false, dependent));
     writer.beginType(className, "class", EnumSet.of(PUBLIC, STATIC, FINAL),
-        JavaWriter.type(Binding.class, returnType),
+        JavaWriter.type(ProvidesBinding.class, returnType),
         JavaWriter.type(Provider.class, returnType));
     writer.emitField(moduleType, "module", EnumSet.of(PRIVATE, FINAL));
     for (Element parameter : parameters) {
@@ -452,10 +455,10 @@
     writer.beginMethod(null, className, EnumSet.of(PUBLIC), moduleType, "module");
     boolean singleton = providerMethod.getAnnotation(Singleton.class) != null;
     String key = JavaWriter.stringLiteral(GeneratorKeys.get(providerMethod));
-    String membersKey = null;
     writer.emitStatement("super(%s, %s, %s, %s)",
-        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"),
-        JavaWriter.stringLiteral(moduleType + "." + methodName + "()"));
+        key, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"),
+        JavaWriter.stringLiteral(moduleType),
+        JavaWriter.stringLiteral(methodName));
     writer.emitStatement("this.module = module");
     writer.emitStatement("setLibrary(%s)", library);
     writer.endMethod();
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 0f8b36c..86d587e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -322,13 +322,12 @@
         || type.getModifiers().contains(Modifier.STATIC);
   }
 
+
   /**
-   * Returns a user-presentable string like {@code
-   * coffee.CoffeeModule#provideHeater()}.
+   * Returns a user-presentable string like {@code coffee.CoffeeModule}.
    */
-  public static String methodName(ExecutableElement method) {
-    return ((TypeElement) method.getEnclosingElement()).getQualifiedName()
-        + "." + method.getSimpleName() + "()";
+  public static String className(ExecutableElement method) {
+    return ((TypeElement) method.getEnclosingElement()).getQualifiedName().toString();
   }
 
   public static boolean isInterface(TypeMirror typeMirror) {
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
index 3983ee9..3bf7a96 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
@@ -59,9 +59,9 @@
 
     JavaFileObject expectedModuleAdapter =
         JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
-        "import dagger.internal.Binding;",
+        "import dagger.internal.BindingsGroup;",
         "import dagger.internal.ModuleAdapter;",
-        "import java.util.Map;",
+        "import dagger.internal.ProvidesBinding;",
         "import javax.inject.Provider;",
         "public final class Field$AModule$$ModuleAdapter",
         "    extends ModuleAdapter<Field.AModule> {",
@@ -75,14 +75,15 @@
         "  @Override public Field.AModule newModule() {",
         "    return new Field.AModule();",
         "  }",
-        "  @Override public void getBindings(Map<String, Binding<?>> map, Field.AModule module) {",
-        "    map.put(\"java.lang.String\", new NameProvidesAdapter(module));", // eager new!
+        "  @Override public void getBindings(BindingsGroup bindings, Field.AModule module) {",
+        "    bindings.contributeProvidesBinding(\"java.lang.String\",",
+        "        new NameProvidesAdapter(module));", // eager new!
         "  }",
         "  public static final class NameProvidesAdapter", // corresponds to method name
-        "      extends Binding<String> implements Provider<String> {",
+        "      extends ProvidesBinding<String> implements Provider<String> {",
         "    private final Field.AModule module;",
         "    public NameProvidesAdapter(Field.AModule module) {",
-        "      super(\"java.lang.String\", null, NOT_SINGLETON, \"Field.AModule.name()\");",
+        "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");",
         "      this.module = module;",
         "      setLibrary(false);",
         "    }",
@@ -140,9 +141,9 @@
 
     JavaFileObject expectedModuleAdapter =
         JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
-        "import dagger.internal.Binding;",
+        "import dagger.internal.BindingsGroup;",
         "import dagger.internal.ModuleAdapter;",
-        "import java.util.Map;",
+        "import dagger.internal.ProvidesBinding;",
         "import javax.inject.Provider;",
         "public final class Field$AModule$$ModuleAdapter extends ModuleAdapter<Field.AModule> {",
         "  private static final String[] INJECTS = ",
@@ -155,14 +156,15 @@
         "  @Override public Field.AModule newModule() {",
         "    return new Field.AModule();",
         "  }",
-        "  @Override public void getBindings(Map<String, Binding<?>> map, Field.AModule module) {",
-        "    map.put(\"java.lang.String\", new NameProvidesAdapter(module));", // eager new!
+        "  @Override public void getBindings(BindingsGroup bindings, Field.AModule module) {",
+        "    bindings.contributeProvidesBinding(\"java.lang.String\",",
+        "        new NameProvidesAdapter(module));", // eager new!
         "  }",
         "  public static final class NameProvidesAdapter", // corresponds to method name
-        "      extends Binding<String> implements Provider<String> {",
+        "      extends ProvidesBinding<String> implements Provider<String> {",
         "    private final Field.AModule module;",
         "    public NameProvidesAdapter(Field.AModule module) {",
-        "      super(\"java.lang.String\", null, NOT_SINGLETON, \"Field.AModule.name()\");",
+        "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");",
         "      this.module = module;",
         "      setLibrary(false);",
         "    }",
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
index a18762d..1afd4d9 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
@@ -76,10 +76,10 @@
         "}"));
 
     ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining("0. CyclicDeps$A bound by Provider").in(sourceFile).onLine(9).and()
-        .withErrorContaining("1. CyclicDeps$D bound by Provider").in(sourceFile).onLine(9).and()
-        .withErrorContaining("2. CyclicDeps$C bound by Provider").in(sourceFile).onLine(9).and()
-        .withErrorContaining("3. CyclicDeps$B bound by Provider").in(sourceFile).onLine(9);
+        .withErrorContaining("0. CyclicDeps$A bound by Provides").in(sourceFile).onLine(9).and()
+        .withErrorContaining("1. CyclicDeps$D bound by Provides").in(sourceFile).onLine(9).and()
+        .withErrorContaining("2. CyclicDeps$C bound by Provides").in(sourceFile).onLine(9).and()
+        .withErrorContaining("3. CyclicDeps$B bound by Provides").in(sourceFile).onLine(9);
   }
 
 }
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index bbe7b00..e5d5428 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -17,6 +17,7 @@
 package dagger;
 
 import dagger.internal.Binding;
+import dagger.internal.BindingsGroup;
 import dagger.internal.FailoverLoader;
 import dagger.internal.Keys;
 import dagger.internal.Linker;
@@ -27,8 +28,9 @@
 import dagger.internal.SetBinding;
 import dagger.internal.StaticInjection;
 import dagger.internal.ThrowingErrorHandler;
-import dagger.internal.UniqueMap;
+import java.util.ArrayList;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 
@@ -132,40 +134,45 @@
     return DaggerObjectGraph.makeGraph(null, loader, modules);
   }
 
+  // TODO(cgruber): Move this internal implementation of ObjectGraph into the internal package.
   static class DaggerObjectGraph extends ObjectGraph {
     private final DaggerObjectGraph base;
     private final Linker linker;
     private final Loader plugin;
     private final Map<Class<?>, StaticInjection> staticInjections;
     private final Map<String, Class<?>> injectableTypes;
+    private final List<SetBinding<?>> setBindings;
 
     DaggerObjectGraph(DaggerObjectGraph base,
         Linker linker,
         Loader plugin,
         Map<Class<?>, StaticInjection> staticInjections,
-        Map<String, Class<?>> injectableTypes) {
-      if (linker == null) throw new NullPointerException("linker");
-      if (plugin == null) throw new NullPointerException("plugin");
-      if (staticInjections == null) throw new NullPointerException("staticInjections");
-      if (injectableTypes == null) throw new NullPointerException("injectableTypes");
+        Map<String, Class<?>> injectableTypes,
+        List<SetBinding<?>> setBindings) {
 
       this.base = base;
-      this.linker = linker;
-      this.plugin = plugin;
-      this.staticInjections = staticInjections;
-      this.injectableTypes = injectableTypes;
+      this.linker = checkNotNull(linker, "linker");
+      this.plugin = checkNotNull(plugin, "plugin");
+      this.staticInjections = checkNotNull(staticInjections, "staticInjections");
+      this.injectableTypes = checkNotNull(injectableTypes, "injectableTypes");
+      this.setBindings = checkNotNull(setBindings, "setBindings");
+    }
+
+    private static <T> T checkNotNull(T object, String label) {
+      if (object == null) throw new NullPointerException(label);
+      return object;
     }
 
     private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Object... modules) {
       Map<String, Class<?>> injectableTypes = new LinkedHashMap<String, Class<?>>();
       Map<Class<?>, StaticInjection> staticInjections
           = new LinkedHashMap<Class<?>, StaticInjection>();
-      UniqueMap<String, Binding<?>> baseBindings = initBaseBindings(base);
-      UniqueMap<String, Binding<?>> overrideBindings = initOverrideBindings();
+      StandardBindings baseBindings =
+          (base == null) ? new StandardBindings() : new StandardBindings(base.setBindings);
+      BindingsGroup overrideBindings = new OverridesBindings();
 
       Map<ModuleAdapter<?>, Object> loadedModules = Modules.loadModules(plugin, modules);
       for (Entry<ModuleAdapter<?>, Object> loadedModule : loadedModules.entrySet()) {
-        @SuppressWarnings("unchecked")
         ModuleAdapter<Object> moduleAdapter = (ModuleAdapter<Object>) loadedModule.getKey();
         for (int i = 0; i < moduleAdapter.injectableTypes.length; i++) {
           injectableTypes.put(moduleAdapter.injectableTypes[i], moduleAdapter.moduleClass);
@@ -174,7 +181,7 @@
           staticInjections.put(moduleAdapter.staticInjections[i], null);
         }
         try {
-          Map<String, Binding<?>> addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
+          BindingsGroup addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
           moduleAdapter.getBindings(addTo, loadedModule.getValue());
         } catch (IllegalArgumentException e) {
           throw new IllegalArgumentException(moduleAdapter.moduleClass.getSimpleName()
@@ -188,46 +195,12 @@
       linker.installBindings(baseBindings);
       linker.installBindings(overrideBindings);
 
-      return new DaggerObjectGraph(base, linker, plugin, staticInjections, injectableTypes);
-    }
-
-    /**
-     * Returns an empty {@code UniqueMap} which will throw errors if a SetBinding is added
-     * to it.
-     */
-    private static UniqueMap<String, Binding<?>> initOverrideBindings() {
-      return new UniqueMap<String, Binding<?>>() {
-        @Override public Binding<?> put(String key, Binding<?> value) {
-          if (value instanceof SetBinding) {
-            throw new IllegalArgumentException("Module overrides cannot contribute set bindings.");
-          }
-          return super.put(key, value);
-        }
-      };
-    }
-
-    /**
-     * Extract bindings in the 'base' and 'overrides' set. Within each set no
-     * duplicates are permitted.  Set-bindings are propagated (and cloned) from the parent
-     * to ensure that parent graph participants only see parent bindings, but the child
-     * graph sees parent+child contributions.
-     */
-    private static UniqueMap<String, Binding<?>> initBaseBindings(
-        DaggerObjectGraph base) {
-      UniqueMap<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>();
-      if (base != null) {
-        Map<String, Binding<?>> parentBindings = base.linkEverything();
-        for (Map.Entry<String, Binding<?>> bindingEntry : parentBindings.entrySet()) {
-          if (bindingEntry.getValue() instanceof SetBinding) {
-            baseBindings.put(bindingEntry.getKey(),
-                new SetBinding<Object>((SetBinding<Object>) bindingEntry.getValue()));
-          }
-        }
-      }
-      return baseBindings;
+      return new DaggerObjectGraph(
+          base, linker, plugin, staticInjections, injectableTypes, baseBindings.setBindings);
     }
 
     @Override public ObjectGraph plus(Object... modules) {
+      linkEverything();
       return makeGraph(this, plugin, modules);
     }
 
@@ -341,4 +314,44 @@
     }
   }
 
+
+  /**
+   * A BindingsGroup which fails when existing values are clobbered and sets aside
+   * {@link SetBinding}.
+   */
+  private static final class StandardBindings extends BindingsGroup {
+    private final List<SetBinding<?>> setBindings;
+
+    public StandardBindings() {
+      setBindings = new ArrayList<SetBinding<?>>();
+    }
+
+    public StandardBindings(List<SetBinding<?>> baseSetBindings) {
+      setBindings = new ArrayList<SetBinding<?>>(baseSetBindings.size());
+      for (SetBinding<?> sb : baseSetBindings) {
+        @SuppressWarnings({ "rawtypes", "unchecked" })
+        SetBinding<?> child = new SetBinding(sb);
+        setBindings.add(child);
+        put(child.provideKey, child);
+      }
+    }
+
+    @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
+      setBindings.add(value);
+      return super.put(key, value);
+    }
+  }
+
+  /**
+   * A BindingsGroup which throws an {@link IllegalArgumentException} when a
+   * {@link SetBinding} is contributed, since overrides modules cannot contribute such
+   * bindings.
+   */
+  private static final class OverridesBindings extends BindingsGroup {
+    OverridesBindings() { }
+
+    @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
+      throw new IllegalArgumentException("Module overrides cannot contribute set bindings.");
+    }
+  }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/BindingsGroup.java b/core/src/main/java/dagger/internal/BindingsGroup.java
new file mode 100644
index 0000000..4bd21b7
--- /dev/null
+++ b/core/src/main/java/dagger/internal/BindingsGroup.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+/**
+ * A grouping of bindings that fails when existing values are clobbered, to be used in collecting
+ * the initial set of bindings for a graph (from provides methods).
+ */
+public abstract class BindingsGroup {
+  private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
+
+  public abstract Binding<?> contributeSetBinding(String key, SetBinding<?> value);
+
+  public Binding<?> contributeProvidesBinding(String key, ProvidesBinding<?> value) {
+    return put(key, value);
+  }
+
+  protected Binding<?> put(String key, Binding<?> value) {
+    Binding<?> clobbered = bindings.put(key, value);
+    if (clobbered != null) {
+      bindings.put(key, clobbered); // Put things back as they were.
+      throw new IllegalArgumentException("Duplicate:\n    " + clobbered + "\n    " + value);
+    }
+    return null;
+  }
+
+  public Binding<?> get(String key) {
+    return bindings.get(key);
+  }
+
+  public final Set<Entry<String, Binding<?>>> entrySet() {
+    return bindings.entrySet();
+  }
+
+  @Override public String toString() {
+    return getClass().getSimpleName() + bindings.toString();
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
index dc36020..0a2a787 100644
--- a/core/src/main/java/dagger/internal/Keys.java
+++ b/core/src/main/java/dagger/internal/Keys.java
@@ -35,7 +35,7 @@
  *       qualified by the annotation.
  *   <li>{@code members/com.square.Foo}: injects members of Foo.
  * </ol>
- * Bindings from {@code @Provides} methods are of the first two types. Bindings
+ * BindingsGroup from {@code @Provides} methods are of the first two types. BindingsGroup
  * created from {@code @Inject}-annotated members of a class are of the first
  * and last types.
  */
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index d68256b..27a64d3 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -38,7 +38,7 @@
    */
   private final Linker base;
 
-  /** Bindings requiring a call to attach(). May contain deferred bindings. */
+  /** BindingsGroup requiring a call to attach(). May contain deferred bindings. */
   private final Queue<Binding<?>> toLink = new LinkedList<Binding<?>>();
 
   /** True unless calls to requestBinding() were unable to satisfy the binding. */
@@ -77,9 +77,9 @@
    * bindings can be used.
    *
    * This method may only be called before {@link #linkAll()}. Subsequent calls to
-   * {@link #installBindings()} will throw an {@link IllegalStateException}.
+   * {@link #installBindings(BindingsGroup)} will throw an {@link IllegalStateException}.
    */
-  public void installBindings(Map<String, ? extends Binding<?>> toInstall) {
+  public void installBindings(BindingsGroup toInstall) {
     if (linkedBindings != null) {
       throw new IllegalStateException("Cannot install further bindings after calling linkAll().");
     }
/Fim/
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index dfe09b2..2986ad6 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -17,8 +17,6 @@
 package dagger.internal;
 
 
-import java.util.Map;
-
 /**
  * Extracts bindings from an {@code @Module}-annotated class.
  */
@@ -47,8 +45,8 @@
    * Returns bindings for the {@code @Provides} methods of {@code module}. The
    * returned bindings must be linked before they can be used to inject values.
    */
-  public void getBindings(@SuppressWarnings("unused") Map<String, Binding<?>> map,
-      @SuppressWarnings("unused") T module) {
+  @SuppressWarnings("unused")
+  public void getBindings(BindingsGroup map, T module) {
     // no-op;
   }
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/ProvidesBinding.java b/core/src/main/java/dagger/internal/ProvidesBinding.java
new file mode 100644
index 0000000..2e6f989
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ProvidesBinding.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+/**
+ * A {@code Binding<T>} which delegates to a module method.
+ */
+public abstract class ProvidesBinding<T> extends Binding<T> {
+  protected final String moduleClass;
+
+  protected final String methodName;
+
+  /**
+   * Creates a new {@code ProvidesBinding} with the given "provides" key, a flag as to whether
+   * this binding should be scoped, and the requiredBy object for traceability.
+   */
+  public ProvidesBinding(String key, boolean singleton, String moduleClass, String methodName) {
+    // Set requiredBy as fullMethodName to preserve older debugging meaning.
+    super(key, null, singleton, moduleClass + "." + methodName + "()");
+    this.moduleClass = moduleClass;
+    this.methodName = methodName;
+  }
+
+  /**
+   * A provides binding is responsible for implementing storage of the module instance, and
+   * delegation to that module instance's method.
+   */
+  @Override
+  public abstract T get();
+
+  @Override public String toString() {
+    return getClass().getName() + "[key=" + provideKey
+        + " method=" + moduleClass + "." + methodName + "()" + "]";
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index ed0c5f7..92d02ad 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -16,9 +16,10 @@
  */
 package dagger.internal;
 
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedHashSet;
-import java.util.Map;
+import java.util.List;
 import java.util.Set;
 
 /**
@@ -28,13 +29,13 @@
  */
 public final class SetBinding<T> extends Binding<Set<T>> {
 
-  public static <T> void add(Map<String, Binding<?>> bindings, String setKey, Binding<?> binding) {
+  public static <T> void add(BindingsGroup bindings, String setKey, Binding<?> binding) {
     prepareSetBinding(bindings, setKey, binding).contributors.add(Linker.scope(binding));
   }
 
   @SuppressWarnings("unchecked")
   private static <T> SetBinding<T> prepareSetBinding(
-      Map<String, Binding<?>> bindings, String setKey, Binding<?> binding) {
+      BindingsGroup bindings, String setKey, Binding<?> binding) {
     Binding<?> previous = bindings.get(setKey);
     SetBinding<T> setBinding;
     if (previous instanceof SetBinding) {
@@ -46,12 +47,21 @@
     } else {
       setBinding = new SetBinding<T>(setKey, binding.requiredBy);
       setBinding.setLibrary(binding.library());
-      bindings.put(setKey, setBinding);
+      bindings.contributeSetBinding(setKey, setBinding);
       return (SetBinding<T>) bindings.get(setKey); // BindingMap.put() copies SetBindings.
     }
   }
 
-  private final Set<Binding<?>> contributors;
+  /**
+   * A {@link SetBinding} with whose contributing bindings this set-binding provides a union
+   * view.
+   */
+  private final SetBinding<T> parent;
+
+  /**
+   * A {@link Set} of {@link Binding} instances which contribute values to the injected set.
+   */
+  private final List<Binding<?>> contributors;
 
   /**
    * Creates a new {@code SetBinding} with the given "provides" key, and the requiredBy object
@@ -59,7 +69,8 @@
    */
   public SetBinding(String key, Object requiredBy) {
     super(key, null, false, requiredBy);
-    contributors = new LinkedHashSet<Binding<?>>();
+    parent = null;
+    contributors = new ArrayList<Binding<?>>();
   }
 
   /**
@@ -68,9 +79,10 @@
    */
   public SetBinding(SetBinding<T> original) {
     super(original.provideKey, null, false, original.requiredBy);
+    parent = original;
     this.setLibrary(original.library());
     this.setDependedOn(original.dependedOn());
-    contributors = new LinkedHashSet<Binding<?>>(original.contributors);
+    contributors = new ArrayList<Binding<?>>();
   }
 
   @Override public void attach(Linker linker) {
@@ -79,30 +91,54 @@
     }
   }
 
+  public int size() {
+    int size = 0;
+    for (SetBinding<T> binding = this; binding != null; binding = binding.parent) {
+      size += binding.contributors.size();
+    }
+    return size;
+  }
+
   @SuppressWarnings("unchecked") // Only Binding<T> and Set<T> are added to contributors.
   @Override public Set<T> get() {
-    Set<T> result = new LinkedHashSet<T>(contributors.size());
-    for (Binding<?> contributor : contributors) {
-      Object contribution = contributor.get(); // Let runtime exceptions through.
-      if (contributor.provideKey.equals(provideKey)) {
-        result.addAll((Set<T>) contribution);
-      } else {
-        result.add((T) contribution);
+    List<T> result = new ArrayList<T>();
+    for (SetBinding<T> setBinding = this; setBinding != null; setBinding = setBinding.parent) {
+      for (Binding<?> contributor : setBinding.contributors) {
+        Object contribution = contributor.get(); // Let runtime exceptions through.
+        if (contributor.provideKey.equals(provideKey)) {
+          result.addAll((Set<T>) contribution);
+        } else {
+          result.add((T) contribution);
+        }
       }
     }
-    return Collections.unmodifiableSet(result);
+    return Collections.unmodifiableSet(new LinkedHashSet<T>(result));
   }
 
   @Override public void getDependencies(
       Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
-    getBindings.addAll(contributors);
+    for (SetBinding<T> binding = this; binding != null; binding = binding.parent) {
+      getBindings.addAll(binding.contributors);
+    }
   }
 
   @Override public void injectMembers(Set<T> t) {
-    throw new UnsupportedOperationException("Cannot inject into a Set binding");
+    throw new UnsupportedOperationException("Cannot inject members on a contributed Set<T>.");
   }
 
   @Override public String toString() {
-    return "SetBinding" + contributors;
+    boolean first = true;
+    StringBuilder builder = new StringBuilder("SetBinding[");
+    for (SetBinding<T> setBinding = this; setBinding != null; setBinding = setBinding.parent) {
+      for (Binding<?> contributor : setBinding.contributors) {
+        if (!first) {
+          builder.append(",");
+        }
+        builder.append(contributor);
+        first = false;
+      }
+    }
+    builder.append("]");
+    return builder.toString();
   }
 }
/Fim/
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index ece3902..ef5b275 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -868,10 +868,10 @@
     @Inject C c; // Singleton.
   }
 
-  @Module(complete=false, injects =C.class)
+  @Module(complete = false, injects = C.class)
   static class RootModule { }
 
-  @Module(addsTo=RootModule.class, injects =SingletonLinkedFromExtension.class)
+  @Module(addsTo = RootModule.class, injects = SingletonLinkedFromExtension.class)
   static class ExtensionModule { }
 
   @Test public void testSingletonLinkingThroughExtensionGraph() {
/Fim/
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index cf5dccb..6a02906 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -209,6 +209,22 @@
     assertThat(logoutput.get()).contains("NullPointerException");
   }
 
+  @Test public void duplicateValuesContributed() {
+    class TestEntryPoint {
+      @Inject Set<String> strings;
+    }
+
+    @Module(injects = TestEntryPoint.class)
+    class TestModule {
+      @Provides(type=SET) String provideString1() { return "a"; }
+      @Provides(type=SET) String provideString2() { return "a"; }
+      @Provides(type=SET) String provideString3() { return "b"; }
+    }
+
+    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
+    assertThat(ep.strings).containsOnly("a", "b");
+  }
+
   @Test public void validateSetBinding() {
     class TestEntryPoint {
       @Inject Set<String> strings;
/Fim/
diff --git a/core/src/test/java/dagger/internal/TestingModuleAdapter.java b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
index eed43e9..b5d54f0 100644
--- a/core/src/test/java/dagger/internal/TestingModuleAdapter.java
+++ b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
@@ -24,7 +24,6 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
-import java.util.Map;
 import java.util.Set;
 import javax.inject.Provider;
 import javax.inject.Singleton;
@@ -53,7 +52,7 @@
     return result;
   }
 
-  @Override public void getBindings(Map<String, Binding<?>> bindings, M module) {
+  @Override public void getBindings(BindingsGroup bindings, M module) {
     for (Class<?> c = moduleClass; !c.equals(Object.class); c = c.getSuperclass()) {
       for (Method method : c.getDeclaredMethods()) {
         Provides provides = method.getAnnotation(Provides.class);
@@ -98,15 +97,17 @@
     }
   }
 
-  private void handleBindings(Map<String, Binding<?>> bindings, M module, Method method, String key,
+  private void handleBindings(BindingsGroup bindings, M module, Method method, String key,
       boolean library) {
-    bindings.put(key, new ProviderMethodBinding<M>(method, key, module, library));
+    bindings.contributeProvidesBinding(key,
+        new ReflectiveProvidesBinding<M>(method, key, moduleClass.getName(), module, library));
   }
 
-  private void handleSetBindings(Map<String, Binding<?>> bindings, M module, Method method,
+  private void handleSetBindings(BindingsGroup bindings, M module, Method method,
       String setKey, String providerKey, boolean library) {
     SetBinding.<M>add(bindings, setKey,
-        new ProviderMethodBinding<M>(method, providerKey, module, library));
+        new ReflectiveProvidesBinding<M>(
+            method, providerKey, moduleClass.getName(), module, library));
   }
 
   @Override public M newModule() {
@@ -149,14 +150,14 @@
   /**
    * Invokes a method to provide a value. The method's parameters are injected.
    */
-  private final class ProviderMethodBinding<T> extends Binding<T> {
+  private static final class ReflectiveProvidesBinding<T> extends ProvidesBinding<T> {
     private Binding<?>[] parameters;
     private final Method method;
     private final Object instance;
 
-    public ProviderMethodBinding(Method method, String key, Object instance, boolean library) {
-      super(key, null, method.isAnnotationPresent(Singleton.class),
-          moduleClass.getName() + "." + method.getName() + "()");
+    public ReflectiveProvidesBinding(Method method, String key, String moduleClass,
+        Object instance, boolean library) {
+      super(key, method.isAnnotationPresent(Singleton.class), moduleClass, method.getName());
       this.method = method;
       this.instance = instance;
       method.setAccessible(true);
@@ -199,9 +200,5 @@
     @Override public void injectMembers(T t) {
       throw new AssertionError("Provides method bindings are not MembersInjectors");
     }
-
-    @Override public String toString() {
-      return method.toString();
-    }
   }
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index 8be0c96..d009f75 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -19,8 +19,10 @@
 import dagger.Provides;
 import dagger.internal.Binding;
 import dagger.internal.Binding.InvalidBindingException;
+import dagger.internal.BindingsGroup;
 import dagger.internal.Linker;
 import dagger.internal.ProblemDetector;
+import dagger.internal.ProvidesBinding;
 import dagger.internal.SetBinding;
 import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
 import java.io.IOException;
@@ -56,10 +58,10 @@
 
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
+import static dagger.internal.codegen.Util.className;
 import static dagger.internal.codegen.Util.getAnnotation;
 import static dagger.internal.codegen.Util.getPackage;
 import static dagger.internal.codegen.Util.isInterface;
-import static dagger.internal.codegen.Util.methodName;
 import static java.util.Arrays.asList;
 
 /**
@@ -172,13 +174,21 @@
     // We know statically that we're single threaded, but we synchronize anyway
     // to make the linker happy.
     synchronized (linker) {
-      Map<String, Binding<?>> baseBindings = new LinkedHashMap<String, Binding<?>>();
-      Map<String, Binding<?>> overrideBindings = new LinkedHashMap<String, Binding<?>>();
+      BindingsGroup baseBindings = new BindingsGroup() {
+        @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
+          return super.put(key, value);
+        }
+      };
+      BindingsGroup overrideBindings = new BindingsGroup() {
+        @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
+          throw new IllegalStateException("Module overrides cannot contribute set bindings.");
+        }
+      };
       for (TypeElement module : allModules.values()) {
         Map<String, Object> annotation = getAnnotation(Module.class, module);
         boolean overrides = (Boolean) annotation.get("overrides");
         boolean library = (Boolean) annotation.get("library");
-        Map<String, Binding<?>> addTo = overrides ? overrideBindings : baseBindings;
+        BindingsGroup addTo = overrides ? overrideBindings : baseBindings;
 
         // Gather the injectable types from the annotation.
         Set<String> injectsProvisionKeys = new LinkedHashSet<String>();
@@ -208,9 +218,9 @@
           }
           ExecutableElement providerMethod = (ExecutableElement) enclosed;
           String key = GeneratorKeys.get(providerMethod);
-          Binding binding = new ProviderMethodBinding(key, providerMethod, library);
+          ProvidesBinding<?> binding = new ProviderMethodBinding(key, providerMethod, library);
 
-          Binding previous = addTo.get(key);
+          Binding<?> previous = addTo.get(key);
           if (previous != null) {
             if ((provides.type() == SET || provides.type() == SET_VALUES)
                 && previous instanceof SetBinding) {
@@ -230,7 +240,11 @@
               if (injectsProvisionKeys.contains(binding.provideKey)) {
                 binding.setDependedOn(true);
               }
-              addTo.put(key, binding);
+              try {
+                addTo.contributeProvidesBinding(key, binding);
+              } catch (IllegalStateException ise) {
+                throw new ModuleValidationException(ise.getMessage(), providerMethod);
+              }
               break;
 
             case SET:
@@ -264,11 +278,6 @@
     return processingEnv.getElementUtils();
   }
 
-  private String shortMethodName(ExecutableElement method) {
-    return method.getEnclosingElement().getSimpleName().toString()
-        + "." + method.getSimpleName() + "()";
-  }
-
   void collectIncludesRecursively(
       TypeElement module, Map<String, TypeElement> result, Deque<String> path) {
     Map<String, Object> annotation = getAnnotation(Module.class, module);
@@ -317,12 +326,13 @@
     }
   }
 
-  static class ProviderMethodBinding extends Binding<Object> {
+  static class ProviderMethodBinding extends ProvidesBinding<Object> {
     private final ExecutableElement method;
     private final Binding<?>[] parameters;
 
     protected ProviderMethodBinding(String provideKey, ExecutableElement method, boolean library) {
-      super(provideKey, null, method.getAnnotation(Singleton.class) != null, methodName(method));
+      super(provideKey, method.getAnnotation(Singleton.class) != null,
+          className(method), method.getSimpleName().toString());
       this.method = method;
       this.parameters = new Binding[method.getParameters().size()];
       setLibrary(library);
@@ -348,6 +358,11 @@
     @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
       Collections.addAll(get, parameters);
     }
+
+    @Override public String toString() {
+      return "ProvidesBinding[key=" + provideKey
+          + " method=" + moduleClass + "." + method.getSimpleName() + "()";
+    }
   }
 
   void writeDotFile(TypeElement module, Map<String, Binding<?>> bindings) throws IOException {
@@ -363,9 +378,9 @@
   }
 
   static class ModuleValidationException extends IllegalStateException {
-    final TypeElement source;
+    final Element source;
 
-    public ModuleValidationException(String message, TypeElement source) {
+    public ModuleValidationException(String message, Element source) {
       super(message);
       this.source = source;
     }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
index 26394b6..a0fe29c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
@@ -19,11 +19,11 @@
 import java.io.IOException;
 import java.util.Comparator;
 import java.util.HashSet;
-import java.util.TreeSet;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeMap;
+import java.util.TreeSet;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 5503e17..e2d74f2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -20,8 +20,10 @@
 import dagger.Module;
 import dagger.Provides;
 import dagger.internal.Binding;
+import dagger.internal.BindingsGroup;
 import dagger.internal.Linker;
 import dagger.internal.ModuleAdapter;
+import dagger.internal.ProvidesBinding;
 import dagger.internal.SetBinding;
 import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
 import java.io.IOException;
@@ -81,8 +83,7 @@
  */
 @SupportedAnnotationTypes({ "*" })
 public final class ModuleAdapterProcessor extends AbstractProcessor {
-  private static final String BINDINGS_MAP = JavaWriter.type(
-      Map.class, String.class.getCanonicalName(), Binding.class.getCanonicalName() + "<?>");
+  private static final String BINDINGS_MAP = JavaWriter.type(BindingsGroup.class);
   private static final List<String> INVALID_RETURN_TYPES =
       Arrays.asList(Provider.class.getCanonicalName(), Lazy.class.getCanonicalName());
 
@@ -323,7 +324,7 @@
       writer.emitEmptyLine();
       writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
       writer.emitAnnotation(Override.class);
-      writer.beginMethod("void", "getBindings", EnumSet.of(PUBLIC), BINDINGS_MAP, "map",
+      writer.beginMethod("void", "getBindings", EnumSet.of(PUBLIC), BINDINGS_MAP, "bindings",
           typeName, "module");
 
       for (ExecutableElement providerMethod : providerMethods) {
@@ -331,20 +332,21 @@
         switch (provides.type()) {
           case UNIQUE: {
             String key = GeneratorKeys.get(providerMethod);
-            writer.emitStatement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
+            writer.emitStatement("bindings.contributeProvidesBinding(%s, new %s(module))",
+                JavaWriter.stringLiteral(key),
                 bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
             break;
           }
           case SET: {
             String key = GeneratorKeys.getSetKey(providerMethod);
-            writer.emitStatement("SetBinding.add(map, %s, new %s(module))",
+            writer.emitStatement("SetBinding.add(bindings, %s, new %s(module))",
                 JavaWriter.stringLiteral(key),
                 bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
             break;
           }
           case SET_VALUES: {
             String key = GeneratorKeys.get(providerMethod);
-            writer.emitStatement("SetBinding.add(map, %s, new %s(module))",
+            writer.emitStatement("SetBinding.add(bindings, %s, new %s(module))",
                 JavaWriter.stringLiteral(key),
                 bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
             break;
@@ -369,13 +371,14 @@
     Set<String> imports = new LinkedHashSet<String>();
     imports.add(ModuleAdapter.class.getCanonicalName());
     if (providers) {
-      imports.add(Binding.class.getCanonicalName());
-      imports.add(Map.class.getCanonicalName());
+      imports.add(BindingsGroup.class.getCanonicalName());
       imports.add(Provider.class.getCanonicalName());
+      imports.add(ProvidesBinding.class.getCanonicalName());
     }
     if (dependencies) {
       imports.add(Linker.class.getCanonicalName());
       imports.add(Set.class.getCanonicalName());
+      imports.add(Binding.class.getCanonicalName());
     }
     if (multibindings) {
       imports.add(SetBinding.class.getCanonicalName());
@@ -439,7 +442,7 @@
     writer.emitEmptyLine();
     writer.emitJavadoc(bindingTypeDocs(returnType, false, false, dependent));
     writer.beginType(className, "class", EnumSet.of(PUBLIC, STATIC, FINAL),
-        JavaWriter.type(Binding.class, returnType),
+        JavaWriter.type(ProvidesBinding.class, returnType),
         JavaWriter.type(Provider.class, returnType));
     writer.emitField(moduleType, "module", EnumSet.of(PRIVATE, FINAL));
     for (Element parameter : parameters) {
@@ -452,10 +455,10 @@
     writer.beginMethod(null, className, EnumSet.of(PUBLIC), moduleType, "module");
     boolean singleton = providerMethod.getAnnotation(Singleton.class) != null;
     String key = JavaWriter.stringLiteral(GeneratorKeys.get(providerMethod));
-    String membersKey = null;
     writer.emitStatement("super(%s, %s, %s, %s)",
-        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"),
-        JavaWriter.stringLiteral(moduleType + "." + methodName + "()"));
+        key, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"),
+        JavaWriter.stringLiteral(moduleType),
+        JavaWriter.stringLiteral(methodName));
     writer.emitStatement("this.module = module");
     writer.emitStatement("setLibrary(%s)", library);
     writer.endMethod();
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 0f8b36c..86d587e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -322,13 +322,12 @@
         || type.getModifiers().contains(Modifier.STATIC);
   }
 
+
   /**
-   * Returns a user-presentable string like {@code
-   * coffee.CoffeeModule#provideHeater()}.
+   * Returns a user-presentable string like {@code coffee.CoffeeModule}.
    */
-  public static String methodName(ExecutableElement method) {
-    return ((TypeElement) method.getEnclosingElement()).getQualifiedName()
-        + "." + method.getSimpleName() + "()";
+  public static String className(ExecutableElement method) {
+    return ((TypeElement) method.getEnclosingElement()).getQualifiedName().toString();
   }
 
   public static boolean isInterface(TypeMirror typeMirror) {
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
index 3983ee9..3bf7a96 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
@@ -59,9 +59,9 @@
 
     JavaFileObject expectedModuleAdapter =
         JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
-        "import dagger.internal.Binding;",
+        "import dagger.internal.BindingsGroup;",
         "import dagger.internal.ModuleAdapter;",
-        "import java.util.Map;",
+        "import dagger.internal.ProvidesBinding;",
         "import javax.inject.Provider;",
         "public final class Field$AModule$$ModuleAdapter",
         "    extends ModuleAdapter<Field.AModule> {",
@@ -75,14 +75,15 @@
         "  @Override public Field.AModule newModule() {",
         "    return new Field.AModule();",
         "  }",
-        "  @Override public void getBindings(Map<String, Binding<?>> map, Field.AModule module) {",
-        "    map.put(\"java.lang.String\", new NameProvidesAdapter(module));", // eager new!
+        "  @Override public void getBindings(BindingsGroup bindings, Field.AModule module) {",
+        "    bindings.contributeProvidesBinding(\"java.lang.String\",",
+        "        new NameProvidesAdapter(module));", // eager new!
         "  }",
         "  public static final class NameProvidesAdapter", // corresponds to method name
-        "      extends Binding<String> implements Provider<String> {",
+        "      extends ProvidesBinding<String> implements Provider<String> {",
         "    private final Field.AModule module;",
         "    public NameProvidesAdapter(Field.AModule module) {",
-        "      super(\"java.lang.String\", null, NOT_SINGLETON, \"Field.AModule.name()\");",
+        "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");",
         "      this.module = module;",
         "      setLibrary(false);",
         "    }",
@@ -140,9 +141,9 @@
 
     JavaFileObject expectedModuleAdapter =
         JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
-        "import dagger.internal.Binding;",
+        "import dagger.internal.BindingsGroup;",
         "import dagger.internal.ModuleAdapter;",
-        "import java.util.Map;",
+        "import dagger.internal.ProvidesBinding;",
         "import javax.inject.Provider;",
         "public final class Field$AModule$$ModuleAdapter extends ModuleAdapter<Field.AModule> {",
         "  private static final String[] INJECTS = ",
@@ -155,14 +156,15 @@
         "  @Override public Field.AModule newModule() {",
         "    return new Field.AModule();",
         "  }",
-        "  @Override public void getBindings(Map<String, Binding<?>> map, Field.AModule module) {",
-        "    map.put(\"java.lang.String\", new NameProvidesAdapter(module));", // eager new!
+        "  @Override public void getBindings(BindingsGroup bindings, Field.AModule module) {",
+        "    bindings.contributeProvidesBinding(\"java.lang.String\",",
+        "        new NameProvidesAdapter(module));", // eager new!
         "  }",
         "  public static final class NameProvidesAdapter", // corresponds to method name
-        "      extends Binding<String> implements Provider<String> {",
+        "      extends ProvidesBinding<String> implements Provider<String> {",
         "    private final Field.AModule module;",
         "    public NameProvidesAdapter(Field.AModule module) {",
-        "      super(\"java.lang.String\", null, NOT_SINGLETON, \"Field.AModule.name()\");",
+        "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");",
         "      this.module = module;",
         "      setLibrary(false);",
         "    }",
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
index a18762d..1afd4d9 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
@@ -76,10 +76,10 @@
         "}"));
 
     ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining("0. CyclicDeps$A bound by Provider").in(sourceFile).onLine(9).and()
-        .withErrorContaining("1. CyclicDeps$D bound by Provider").in(sourceFile).onLine(9).and()
-        .withErrorContaining("2. CyclicDeps$C bound by Provider").in(sourceFile).onLine(9).and()
-        .withErrorContaining("3. CyclicDeps$B bound by Provider").in(sourceFile).onLine(9);
+        .withErrorContaining("0. CyclicDeps$A bound by Provides").in(sourceFile).onLine(9).and()
+        .withErrorContaining("1. CyclicDeps$D bound by Provides").in(sourceFile).onLine(9).and()
+        .withErrorContaining("2. CyclicDeps$C bound by Provides").in(sourceFile).onLine(9).and()
+        .withErrorContaining("3. CyclicDeps$B bound by Provides").in(sourceFile).onLine(9);
   }
 
 }
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index bbe7b00..e5d5428 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -17,6 +17,7 @@
 package dagger;
 
 import dagger.internal.Binding;
+import dagger.internal.BindingsGroup;
 import dagger.internal.FailoverLoader;
 import dagger.internal.Keys;
 import dagger.internal.Linker;
@@ -27,8 +28,9 @@
 import dagger.internal.SetBinding;
 import dagger.internal.StaticInjection;
 import dagger.internal.ThrowingErrorHandler;
-import dagger.internal.UniqueMap;
+import java.util.ArrayList;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 
@@ -132,40 +134,45 @@
     return DaggerObjectGraph.makeGraph(null, loader, modules);
   }
 
+  // TODO(cgruber): Move this internal implementation of ObjectGraph into the internal package.
   static class DaggerObjectGraph extends ObjectGraph {
     private final DaggerObjectGraph base;
     private final Linker linker;
     private final Loader plugin;
     private final Map<Class<?>, StaticInjection> staticInjections;
     private final Map<String, Class<?>> injectableTypes;
+    private final List<SetBinding<?>> setBindings;
 
     DaggerObjectGraph(DaggerObjectGraph base,
         Linker linker,
         Loader plugin,
         Map<Class<?>, StaticInjection> staticInjections,
-        Map<String, Class<?>> injectableTypes) {
-      if (linker == null) throw new NullPointerException("linker");
-      if (plugin == null) throw new NullPointerException("plugin");
-      if (staticInjections == null) throw new NullPointerException("staticInjections");
-      if (injectableTypes == null) throw new NullPointerException("injectableTypes");
+        Map<String, Class<?>> injectableTypes,
+        List<SetBinding<?>> setBindings) {
 
       this.base = base;
-      this.linker = linker;
-      this.plugin = plugin;
-      this.staticInjections = staticInjections;
-      this.injectableTypes = injectableTypes;
+      this.linker = checkNotNull(linker, "linker");
+      this.plugin = checkNotNull(plugin, "plugin");
+      this.staticInjections = checkNotNull(staticInjections, "staticInjections");
+      this.injectableTypes = checkNotNull(injectableTypes, "injectableTypes");
+      this.setBindings = checkNotNull(setBindings, "setBindings");
+    }
+
+    private static <T> T checkNotNull(T object, String label) {
+      if (object == null) throw new NullPointerException(label);
+      return object;
     }
 
     private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Object... modules) {
       Map<String, Class<?>> injectableTypes = new LinkedHashMap<String, Class<?>>();
       Map<Class<?>, StaticInjection> staticInjections
           = new LinkedHashMap<Class<?>, StaticInjection>();
-      UniqueMap<String, Binding<?>> baseBindings = initBaseBindings(base);
-      UniqueMap<String, Binding<?>> overrideBindings = initOverrideBindings();
+      StandardBindings baseBindings =
+          (base == null) ? new StandardBindings() : new StandardBindings(base.setBindings);
+      BindingsGroup overrideBindings = new OverridesBindings();
 
       Map<ModuleAdapter<?>, Object> loadedModules = Modules.loadModules(plugin, modules);
       for (Entry<ModuleAdapter<?>, Object> loadedModule : loadedModules.entrySet()) {
-        @SuppressWarnings("unchecked")
         ModuleAdapter<Object> moduleAdapter = (ModuleAdapter<Object>) loadedModule.getKey();
         for (int i = 0; i < moduleAdapter.injectableTypes.length; i++) {
           injectableTypes.put(moduleAdapter.injectableTypes[i], moduleAdapter.moduleClass);
@@ -174,7 +181,7 @@
           staticInjections.put(moduleAdapter.staticInjections[i], null);
         }
         try {
-          Map<String, Binding<?>> addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
+          BindingsGroup addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
           moduleAdapter.getBindings(addTo, loadedModule.getValue());
         } catch (IllegalArgumentException e) {
           throw new IllegalArgumentException(moduleAdapter.moduleClass.getSimpleName()
@@ -188,46 +195,12 @@
       linker.installBindings(baseBindings);
       linker.installBindings(overrideBindings);
 
-      return new DaggerObjectGraph(base, linker, plugin, staticInjections, injectableTypes);
-    }
-
-    /**
-     * Returns an empty {@code UniqueMap} which will throw errors if a SetBinding is added
-     * to it.
-     */
-    private static UniqueMap<String, Binding<?>> initOverrideBindings() {
-      return new UniqueMap<String, Binding<?>>() {
-        @Override public Binding<?> put(String key, Binding<?> value) {
-          if (value instanceof SetBinding) {
-            throw new IllegalArgumentException("Module overrides cannot contribute set bindings.");
-          }
-          return super.put(key, value);
-        }
-      };
-    }
-
-    /**
-     * Extract bindings in the 'base' and 'overrides' set. Within each set no
-     * duplicates are permitted.  Set-bindings are propagated (and cloned) from the parent
-     * to ensure that parent graph participants only see parent bindings, but the child
-     * graph sees parent+child contributions.
-     */
-    private static UniqueMap<String, Binding<?>> initBaseBindings(
-        DaggerObjectGraph base) {
-      UniqueMap<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>();
-      if (base != null) {
-        Map<String, Binding<?>> parentBindings = base.linkEverything();
-        for (Map.Entry<String, Binding<?>> bindingEntry : parentBindings.entrySet()) {
-          if (bindingEntry.getValue() instanceof SetBinding) {
-            baseBindings.put(bindingEntry.getKey(),
-                new SetBinding<Object>((SetBinding<Object>) bindingEntry.getValue()));
-          }
-        }
-      }
-      return baseBindings;
+      return new DaggerObjectGraph(
+          base, linker, plugin, staticInjections, injectableTypes, baseBindings.setBindings);
     }
 
     @Override public ObjectGraph plus(Object... modules) {
+      linkEverything();
       return makeGraph(this, plugin, modules);
     }
 
@@ -341,4 +314,44 @@
     }
   }
 
+
+  /**
+   * A BindingsGroup which fails when existing values are clobbered and sets aside
+   * {@link SetBinding}.
+   */
+  private static final class StandardBindings extends BindingsGroup {
+    private final List<SetBinding<?>> setBindings;
+
+    public StandardBindings() {
+      setBindings = new ArrayList<SetBinding<?>>();
+    }
+
+    public StandardBindings(List<SetBinding<?>> baseSetBindings) {
+      setBindings = new ArrayList<SetBinding<?>>(baseSetBindings.size());
+      for (SetBinding<?> sb : baseSetBindings) {
+        @SuppressWarnings({ "rawtypes", "unchecked" })
+        SetBinding<?> child = new SetBinding(sb);
+        setBindings.add(child);
+        put(child.provideKey, child);
+      }
+    }
+
+    @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
+      setBindings.add(value);
+      return super.put(key, value);
+    }
+  }
+
+  /**
+   * A BindingsGroup which throws an {@link IllegalArgumentException} when a
+   * {@link SetBinding} is contributed, since overrides modules cannot contribute such
+   * bindings.
+   */
+  private static final class OverridesBindings extends BindingsGroup {
+    OverridesBindings() { }
+
+    @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
+      throw new IllegalArgumentException("Module overrides cannot contribute set bindings.");
+    }
+  }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/BindingsGroup.java b/core/src/main/java/dagger/internal/BindingsGroup.java
new file mode 100644
index 0000000..861f7de
--- /dev/null
+++ b/core/src/main/java/dagger/internal/BindingsGroup.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+/**
+ * A grouping of bindings that fails when existing values are clobbered, to be used in collecting
+ * the initial set of bindings for a graph (from provides methods).
+ */
+public abstract class BindingsGroup {
+  private final Map<String, Binding<?>> bindings = new LinkedHashMap<String, Binding<?>>();
+
+  public abstract Binding<?> contributeSetBinding(String key, SetBinding<?> value);
+
+  public Binding<?> contributeProvidesBinding(String key, ProvidesBinding<?> value) {
+    return put(key, value);
+  }
+
+  protected Binding<?> put(String key, Binding<?> value) {
+    Binding<?> clobbered = bindings.put(key, value);
+    if (clobbered != null) {
+      bindings.put(key, clobbered); // Put things back as they were.
+      throw new IllegalArgumentException("Duplicate:\n    " + clobbered + "\n    " + value);
+    }
+    return null;
+  }
+
+  public Binding<?> get(String key) {
+    return bindings.get(key);
+  }
+
+  public final Set<Entry<String, Binding<?>>> entrySet() {
+    return bindings.entrySet();
+  }
+
+  @Override public String toString() {
+    return getClass().getSimpleName() + bindings.toString();
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
index dc36020..fb65cc6 100644
--- a/core/src/main/java/dagger/internal/Keys.java
+++ b/core/src/main/java/dagger/internal/Keys.java
@@ -35,7 +35,7 @@
  *       qualified by the annotation.
  *   <li>{@code members/com.square.Foo}: injects members of Foo.
  * </ol>
- * Bindings from {@code @Provides} methods are of the first two types. Bindings
+ * Bindings from {@code @Provides} methods are of the first two types. BindingsGroup
  * created from {@code @Inject}-annotated members of a class are of the first
  * and last types.
  */
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index d68256b..1341639 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -77,9 +77,9 @@
    * bindings can be used.
    *
    * This method may only be called before {@link #linkAll()}. Subsequent calls to
-   * {@link #installBindings()} will throw an {@link IllegalStateException}.
+   * {@link #installBindings(BindingsGroup)} will throw an {@link IllegalStateException}.
    */
-  public void installBindings(Map<String, ? extends Binding<?>> toInstall) {
+  public void installBindings(BindingsGroup toInstall) {
     if (linkedBindings != null) {
       throw new IllegalStateException("Cannot install further bindings after calling linkAll().");
     }
/Fim/
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index dfe09b2..2986ad6 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -17,8 +17,6 @@
 package dagger.internal;
 
 
-import java.util.Map;
-
 /**
  * Extracts bindings from an {@code @Module}-annotated class.
  */
@@ -47,8 +45,8 @@
    * Returns bindings for the {@code @Provides} methods of {@code module}. The
    * returned bindings must be linked before they can be used to inject values.
    */
-  public void getBindings(@SuppressWarnings("unused") Map<String, Binding<?>> map,
-      @SuppressWarnings("unused") T module) {
+  @SuppressWarnings("unused")
+  public void getBindings(BindingsGroup map, T module) {
     // no-op;
   }
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/ProvidesBinding.java b/core/src/main/java/dagger/internal/ProvidesBinding.java
new file mode 100644
index 0000000..2e6f989
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ProvidesBinding.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+/**
+ * A {@code Binding<T>} which delegates to a module method.
+ */
+public abstract class ProvidesBinding<T> extends Binding<T> {
+  protected final String moduleClass;
+
+  protected final String methodName;
+
+  /**
+   * Creates a new {@code ProvidesBinding} with the given "provides" key, a flag as to whether
+   * this binding should be scoped, and the requiredBy object for traceability.
+   */
+  public ProvidesBinding(String key, boolean singleton, String moduleClass, String methodName) {
+    // Set requiredBy as fullMethodName to preserve older debugging meaning.
+    super(key, null, singleton, moduleClass + "." + methodName + "()");
+    this.moduleClass = moduleClass;
+    this.methodName = methodName;
+  }
+
+  /**
+   * A provides binding is responsible for implementing storage of the module instance, and
+   * delegation to that module instance's method.
+   */
+  @Override
+  public abstract T get();
+
+  @Override public String toString() {
+    return getClass().getName() + "[key=" + provideKey
+        + " method=" + moduleClass + "." + methodName + "()" + "]";
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index ed0c5f7..af37290 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -16,9 +16,10 @@
  */
 package dagger.internal;
 
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedHashSet;
-import java.util.Map;
+import java.util.List;
 import java.util.Set;
 
 /**
@@ -28,13 +29,13 @@
  */
 public final class SetBinding<T> extends Binding<Set<T>> {
 
-  public static <T> void add(Map<String, Binding<?>> bindings, String setKey, Binding<?> binding) {
+  public static <T> void add(BindingsGroup bindings, String setKey, Binding<?> binding) {
     prepareSetBinding(bindings, setKey, binding).contributors.add(Linker.scope(binding));
   }
 
   @SuppressWarnings("unchecked")
   private static <T> SetBinding<T> prepareSetBinding(
-      Map<String, Binding<?>> bindings, String setKey, Binding<?> binding) {
+      BindingsGroup bindings, String setKey, Binding<?> binding) {
     Binding<?> previous = bindings.get(setKey);
     SetBinding<T> setBinding;
     if (previous instanceof SetBinding) {
@@ -46,12 +47,21 @@
     } else {
       setBinding = new SetBinding<T>(setKey, binding.requiredBy);
       setBinding.setLibrary(binding.library());
-      bindings.put(setKey, setBinding);
+      bindings.contributeSetBinding(setKey, setBinding);
       return (SetBinding<T>) bindings.get(setKey); // BindingMap.put() copies SetBindings.
     }
   }
 
-  private final Set<Binding<?>> contributors;
+  /**
+   * A {@link SetBinding} with whose contributing bindings this set-binding provides a union
+   * view.
+   */
+  private final SetBinding<T> parent;
+
+  /**
+   * A {@link Set} of {@link Binding} instances which contribute values to the injected set.
+   */
+  private final List<Binding<?>> contributors;
 
   /**
    * Creates a new {@code SetBinding} with the given "provides" key, and the requiredBy object
@@ -59,7 +69,8 @@
    */
   public SetBinding(String key, Object requiredBy) {
     super(key, null, false, requiredBy);
-    contributors = new LinkedHashSet<Binding<?>>();
+    parent = null;
+    contributors = new ArrayList<Binding<?>>();
   }
 
   /**
@@ -68,9 +79,10 @@
    */
   public SetBinding(SetBinding<T> original) {
     super(original.provideKey, null, false, original.requiredBy);
+    parent = original;
     this.setLibrary(original.library());
     this.setDependedOn(original.dependedOn());
-    contributors = new LinkedHashSet<Binding<?>>(original.contributors);
+    contributors = new ArrayList<Binding<?>>();
   }
 
   @Override public void attach(Linker linker) {
@@ -79,30 +91,55 @@
     }
   }
 
+  public int size() {
+    int size = 0;
+    for (SetBinding<T> binding = this; binding != null; binding = binding.parent) {
+      size += binding.contributors.size();
+    }
+    return size;
+  }
+
   @SuppressWarnings("unchecked") // Only Binding<T> and Set<T> are added to contributors.
   @Override public Set<T> get() {
-    Set<T> result = new LinkedHashSet<T>(contributors.size());
-    for (Binding<?> contributor : contributors) {
-      Object contribution = contributor.get(); // Let runtime exceptions through.
-      if (contributor.provideKey.equals(provideKey)) {
-        result.addAll((Set<T>) contribution);
-      } else {
-        result.add((T) contribution);
+    List<T> result = new ArrayList<T>();
+    for (SetBinding<T> setBinding = this; setBinding != null; setBinding = setBinding.parent) {
+      for (int i = 0, size = setBinding.contributors.size(); i < size; i++) {
+        Binding<?> contributor = setBinding.contributors.get(i);
+        Object contribution = contributor.get(); // Let runtime exceptions through.
+        if (contributor.provideKey.equals(provideKey)) {
+          result.addAll((Set<T>) contribution);
+        } else {
+          result.add((T) contribution);
+        }
       }
     }
-    return Collections.unmodifiableSet(result);
+    return Collections.unmodifiableSet(new LinkedHashSet<T>(result));
   }
 
   @Override public void getDependencies(
       Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
-    getBindings.addAll(contributors);
+    for (SetBinding<T> binding = this; binding != null; binding = binding.parent) {
+      getBindings.addAll(binding.contributors);
+    }
   }
 
   @Override public void injectMembers(Set<T> t) {
-    throw new UnsupportedOperationException("Cannot inject into a Set binding");
+    throw new UnsupportedOperationException("Cannot inject members on a contributed Set<T>.");
   }
 
   @Override public String toString() {
-    return "SetBinding" + contributors;
+    boolean first = true;
+    StringBuilder builder = new StringBuilder("SetBinding[");
+    for (SetBinding<T> setBinding = this; setBinding != null; setBinding = setBinding.parent) {
+      for (int i = 0, size = setBinding.contributors.size(); i < size; i++) {
+        if (!first) {
+          builder.append(",");
+        }
+        builder.append(setBinding.contributors.get(i));
+        first = false;
+      }
+    }
+    builder.append("]");
+    return builder.toString();
   }
 }
/Fim/
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index ece3902..ef5b275 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -868,10 +868,10 @@
     @Inject C c; // Singleton.
   }
 
-  @Module(complete=false, injects =C.class)
+  @Module(complete = false, injects = C.class)
   static class RootModule { }
 
-  @Module(addsTo=RootModule.class, injects =SingletonLinkedFromExtension.class)
+  @Module(addsTo = RootModule.class, injects = SingletonLinkedFromExtension.class)
   static class ExtensionModule { }
 
   @Test public void testSingletonLinkingThroughExtensionGraph() {
/Fim/
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index cf5dccb..6a02906 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -209,6 +209,22 @@
     assertThat(logoutput.get()).contains("NullPointerException");
   }
 
+  @Test public void duplicateValuesContributed() {
+    class TestEntryPoint {
+      @Inject Set<String> strings;
+    }
+
+    @Module(injects = TestEntryPoint.class)
+    class TestModule {
+      @Provides(type=SET) String provideString1() { return "a"; }
+      @Provides(type=SET) String provideString2() { return "a"; }
+      @Provides(type=SET) String provideString3() { return "b"; }
+    }
+
+    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
+    assertThat(ep.strings).containsOnly("a", "b");
+  }
+
   @Test public void validateSetBinding() {
     class TestEntryPoint {
       @Inject Set<String> strings;
/Fim/
diff --git a/core/src/test/java/dagger/internal/TestingModuleAdapter.java b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
index eed43e9..b5d54f0 100644
--- a/core/src/test/java/dagger/internal/TestingModuleAdapter.java
+++ b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
@@ -24,7 +24,6 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
-import java.util.Map;
 import java.util.Set;
 import javax.inject.Provider;
 import javax.inject.Singleton;
@@ -53,7 +52,7 @@
     return result;
   }
 
-  @Override public void getBindings(Map<String, Binding<?>> bindings, M module) {
+  @Override public void getBindings(BindingsGroup bindings, M module) {
     for (Class<?> c = moduleClass; !c.equals(Object.class); c = c.getSuperclass()) {
       for (Method method : c.getDeclaredMethods()) {
         Provides provides = method.getAnnotation(Provides.class);
@@ -98,15 +97,17 @@
     }
   }
 
-  private void handleBindings(Map<String, Binding<?>> bindings, M module, Method method, String key,
+  private void handleBindings(BindingsGroup bindings, M module, Method method, String key,
       boolean library) {
-    bindings.put(key, new ProviderMethodBinding<M>(method, key, module, library));
+    bindings.contributeProvidesBinding(key,
+        new ReflectiveProvidesBinding<M>(method, key, moduleClass.getName(), module, library));
   }
 
-  private void handleSetBindings(Map<String, Binding<?>> bindings, M module, Method method,
+  private void handleSetBindings(BindingsGroup bindings, M module, Method method,
       String setKey, String providerKey, boolean library) {
     SetBinding.<M>add(bindings, setKey,
-        new ProviderMethodBinding<M>(method, providerKey, module, library));
+        new ReflectiveProvidesBinding<M>(
+            method, providerKey, moduleClass.getName(), module, library));
   }
 
   @Override public M newModule() {
@@ -149,14 +150,14 @@
   /**
    * Invokes a method to provide a value. The method's parameters are injected.
    */
-  private final class ProviderMethodBinding<T> extends Binding<T> {
+  private static final class ReflectiveProvidesBinding<T> extends ProvidesBinding<T> {
     private Binding<?>[] parameters;
     private final Method method;
     private final Object instance;
 
-    public ProviderMethodBinding(Method method, String key, Object instance, boolean library) {
-      super(key, null, method.isAnnotationPresent(Singleton.class),
-          moduleClass.getName() + "." + method.getName() + "()");
+    public ReflectiveProvidesBinding(Method method, String key, String moduleClass,
+        Object instance, boolean library) {
+      super(key, method.isAnnotationPresent(Singleton.class), moduleClass, method.getName());
       this.method = method;
       this.instance = instance;
       method.setAccessible(true);
@@ -199,9 +200,5 @@
     @Override public void injectMembers(T t) {
       throw new AssertionError("Provides method bindings are not MembersInjectors");
     }
-
-    @Override public String toString() {
-      return method.toString();
-    }
   }
 }
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index fb0367d..34ceb17 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -70,7 +70,7 @@
         <plugin>
           <groupId>com.jayway.maven.plugins.android.generation2</groupId>
           <artifactId>android-maven-plugin</artifactId>
-          <version>3.8.0</version>
+          <version>3.8.2</version>
           <configuration>
             <sdk>
               <platform>16</platform>
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/FailureModeErrorsTest.java b/compiler/src/test/java/dagger/tests/integration/operation/FailureModeErrorsTest.java
new file mode 100644
index 0000000..0aede5b
--- /dev/null
+++ b/compiler/src/test/java/dagger/tests/integration/operation/FailureModeErrorsTest.java
@@ -0,0 +1,70 @@
+/**
+ * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.tests.integration.operation;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import javax.inject.Inject;
+import javax.inject.Qualifier;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static junit.framework.Assert.fail;
+import static org.fest.assertions.Assertions.assertThat;
+
+@RunWith(JUnit4.class)
+public final class FailureModeErrorsTest {
+
+  @Module
+  static class CompleteModule {}
+
+  static class ArrayFoo {
+    @Inject ArrayFoo(String[] ignored) {}
+  }
+
+  @Module(injects = ArrayFoo.class, complete = false)
+  static class ArrayFooModule {}
+
+  @Test public void failOnMissingModule_array() {
+    try {
+      ObjectGraph.create(new CompleteModule(), new ArrayFooModule()).get(ArrayFoo.class);
+      fail("Should have thrown.");
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).contains("is a generic class or an array");
+    }
+  }
+
+  @Qualifier @interface MyFoo {}
+
+  static class QualifyingFoo {
+    @Inject QualifyingFoo(@MyFoo String ignored) {}
+  }
+
+  @Module(injects = QualifyingFoo.class, complete = false)
+  static class QualifyingFooModule {}
+
+  @Test public void failOnMissingModule_qualified() {
+    try {
+      ObjectGraph.create(new CompleteModule(), new QualifyingFooModule()).get(QualifyingFoo.class);
+      fail("Should have thrown.");
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).contains("is a @Qualifier-annotated type and must be bound");
+    }
+  }
+
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 5852e26..e9cf9f4 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -217,9 +217,14 @@
     }
 
     String className = Keys.getClassName(key);
-    if (className == null || Keys.isAnnotated(key)) {
-      // Cannot jit-bind annotated keys or generic types.
-      throw new IllegalArgumentException(key);
+    if (className == null) {
+      throw new InvalidBindingException(key,
+          "is a generic class or an array and can only be bound with concrete type parameter(s) "
+          + "in a @Provides method.");
+    }
+    if (Keys.isAnnotated(key)) {
+      throw new InvalidBindingException(key,
+          "is a @Qualifier-annotated type and must be bound by a @Provides method.");
     }
     Binding<?> binding =
         plugin.getAtInjectBinding(key, className, classLoader, mustHaveInjections);
/Fim/
