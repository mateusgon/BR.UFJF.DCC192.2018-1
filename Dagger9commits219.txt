diff --git a/src/main/java/com/squareup/codegen/GeneratorKeys.java b/src/main/java/com/squareup/codegen/GeneratorKeys.java
index 6c45577..4b92db6 100644
--- a/src/main/java/com/squareup/codegen/GeneratorKeys.java
+++ b/src/main/java/com/squareup/codegen/GeneratorKeys.java
@@ -67,7 +67,7 @@
     result.append('@');
     result.append(((TypeElement) qualifier.getAnnotationType().asElement()).getQualifiedName());
     result.append('(');
-    for (Map.Entry<? extends ExecutableElement,? extends AnnotationValue> entry
+    for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry
         : qualifier.getElementValues().entrySet()) {
       result.append(entry.getKey().getSimpleName());
       result.append('=');
/Fim/
diff --git a/src/main/java/com/squareup/codegen/InjectProcessor.java b/src/main/java/com/squareup/codegen/InjectProcessor.java
index 988fdd1..0b29b2c 100644
--- a/src/main/java/com/squareup/codegen/InjectProcessor.java
+++ b/src/main/java/com/squareup/codegen/InjectProcessor.java
@@ -107,12 +107,12 @@
     for (int p = 0; p < parameters.size(); p++) {
       TypeMirror parameterType = parameters.get(p).asType();
       writer.field(CodeGen.parameterizedType(Binding.class, parameterType.toString()),
-          "c" + p, PRIVATE);
+          constructorParameterName(p), PRIVATE);
     }
     for (int f = 0; f < fields.size(); f++) {
       TypeMirror fieldType = fields.get(f).asType();
       writer.field(CodeGen.parameterizedType(Binding.class, fieldType.toString()),
-          "f" + f, PRIVATE);
+          fieldName(f), PRIVATE);
     }
 
     writer.beginMethod(null, type.getSimpleName() + "$InjectAdapter", PUBLIC);
@@ -124,17 +124,17 @@
     for (int p = 0; p < constructor.getParameters().size(); p++) {
       TypeMirror parameterType = constructor.getParameters().get(p).asType();
       writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
-          "c" + p,
+          constructorParameterName(p),
           CodeGen.parameterizedType(Binding.class, parameterType.toString()),
           JavaWriter.stringLiteral(GeneratorKeys.get(constructor.getParameters().get(p))),
           typeName);
     }
-    for (int p = 0; p < fields.size(); p++) {
-      TypeMirror parameterType = fields.get(p).asType();
+    for (int f = 0; f < fields.size(); f++) {
+      TypeMirror parameterType = fields.get(f).asType();
       writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
-          "f" + p,
+          fieldName(f),
           CodeGen.parameterizedType(Binding.class, parameterType.toString()),
-          JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) fields.get(p))),
+          JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) fields.get(f))),
           typeName);
     }
     writer.endMethod();
@@ -147,7 +147,7 @@
       if (p != 0) {
         newInstance.append(", ");
       }
-      newInstance.append("c").append(p).append(".get()");
+      newInstance.append(constructorParameterName(p)).append(".get()");
     }
     newInstance.append(')');
     writer.statement(newInstance.toString());
@@ -160,7 +160,7 @@
     for (int f = 0; f < fields.size(); f++) {
       writer.statement("object.%s = %s.get()",
           fields.get(f).getSimpleName().toString(),
-          "f" + f);
+          fieldName(f));
     }
     writer.endMethod();
 
@@ -173,6 +173,14 @@
     writer.close();
   }
 
+  private String fieldName(int index) {
+    return "f" + index;
+  }
+
+  private String constructorParameterName(int index) {
+    return "c" + index;
+  }
+
   static class InjectedClass {
     ExecutableElement constructor;
     List<Element> fields = new ArrayList<Element>();
/Fim/
diff --git a/src/main/java/com/squareup/codegen/ProvidesProcessor.java b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
index d401b92..8451a24 100644
--- a/src/main/java/com/squareup/codegen/ProvidesProcessor.java
+++ b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
@@ -54,9 +54,9 @@
 @SupportedAnnotationTypes("com.squareup.injector.Provides")
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class ProvidesProcessor extends AbstractProcessor {
-  private static final String bindingsMap = CodeGen.parameterizedType(
+  private static final String BINDINGS_MAP = CodeGen.parameterizedType(
       Map.class, String.class.getName(), Binding.class.getName() + "<?>");
-  private static final String bindingsHashMap = CodeGen.parameterizedType(
+  private static final String BINDINGS_HASH_MAP = CodeGen.parameterizedType(
       HashMap.class, String.class.getName(), Binding.class.getName() + "<?>");
 
   @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
@@ -132,8 +132,8 @@
         CodeGen.parameterizedType(ModuleAdapter.class, typeName));
 
     writer.annotation(Override.class);
-    writer.beginMethod(bindingsMap, "getBindings", PUBLIC, typeName, "module");
-    writer.statement("%s result = new %s()", bindingsMap, bindingsHashMap);
+    writer.beginMethod(BINDINGS_MAP, "getBindings", PUBLIC, typeName, "module");
+    writer.statement("%s result = new %s()", BINDINGS_MAP, BINDINGS_HASH_MAP);
     for (ExecutableElement providerMethod : providerMethods) {
       String key = GeneratorKeys.get(providerMethod);
       writer.statement("result.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
@@ -165,7 +165,7 @@
     for (int p = 0; p < parameters.size(); p++) {
       TypeMirror parameterType = parameters.get(p).asType();
       writer.field(CodeGen.parameterizedType(Binding.class, parameterType.toString()),
-          "p" + p, PRIVATE);
+          parameterName(p), PRIVATE);
     }
 
     writer.beginMethod(null, className, PUBLIC, moduleType, "module");
@@ -178,8 +178,8 @@
     for (int p = 0; p < parameters.size(); p++) {
       VariableElement parameter = parameters.get(p);
       String parameterKey = GeneratorKeys.get(parameter);
-      writer.statement("p%d = (%s) linker.requestBinding(%s, %s.class)",
-          p,
+      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
+          parameterName(p),
           CodeGen.parameterizedType(Binding.class, parameter.asType().toString()),
           JavaWriter.stringLiteral(parameterKey), moduleType);
     }
@@ -192,7 +192,7 @@
       if (p != 0) {
         args.append(", ");
       }
-      args.append(String.format("p%d.get()", p));
+      args.append(String.format("%s.get()", parameterName(p)));
     }
     writer.statement("return module.%s(%s)", methodName, args.toString());
     writer.endMethod();
@@ -204,4 +204,8 @@
 
     writer.endType();
   }
+
+  private String parameterName(int index) {
+    return "p" + index;
+  }
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Keys.java b/src/main/java/com/squareup/injector/internal/Keys.java
index 0d74700..c35264d 100644
--- a/src/main/java/com/squareup/injector/internal/Keys.java
+++ b/src/main/java/com/squareup/injector/internal/Keys.java
@@ -173,26 +173,15 @@
   }
 
   private static Type boxIfPrimitive(Type type) {
-    if (type == byte.class) {
-      return Byte.class;
-    } if (type == short.class) {
-      return Short.class;
-    } if (type == int.class) {
-      return Integer.class;
-    } else if (type == long.class) {
-      return Long.class;
-    } else if (type == char.class) {
-      return Character.class;
-    } else if (type == boolean.class) {
-      return Boolean.class;
-    } else if (type == float.class) {
-      return Float.class;
-    } else if (type == double.class) {
-      return Double.class;
-    } else if (type == void.class) {
-      return Void.class;
-    } else {
-      return type;
-    }
+    if (type == byte.class) return Byte.class;
+    if (type == short.class) return Short.class;
+    if (type == int.class) return Integer.class;
+    if (type == long.class) return Long.class;
+    if (type == char.class) return Character.class;
+    if (type == boolean.class) return Boolean.class;
+    if (type == float.class) return Float.class;
+    if (type == double.class) return Double.class;
+    if (type == void.class) return Void.class;
+    return type;
   }
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/DependencyGraph.java b/src/main/java/com/squareup/injector/DependencyGraph.java
index 5a48130..cae1c3e 100644
--- a/src/main/java/com/squareup/injector/DependencyGraph.java
+++ b/src/main/java/com/squareup/injector/DependencyGraph.java
@@ -18,6 +18,7 @@
 import com.squareup.injector.internal.Binding;
 import com.squareup.injector.internal.Keys;
 import com.squareup.injector.internal.Linker;
+import com.squareup.injector.internal.StaticInjection;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -50,10 +51,13 @@
  * @author Jesse Wilson
  */
 public final class DependencyGraph {
+  private final StaticInjection[] staticInjections;
   private final Class<?> injectorClass;
   private final Map<Class<?>, Binding<?>> bindings;
 
-  private DependencyGraph(Class<?> injectorClass, Map<Class<?>, Binding<?>> bindings) {
+  private DependencyGraph(StaticInjection[] staticInjections,
+      Class<?> injectorClass, Map<Class<?>, Binding<?>> bindings) {
+    this.staticInjections = staticInjections;
     this.injectorClass = injectorClass;
     this.bindings = bindings;
   }
@@ -61,6 +65,10 @@
   /**
    * Returns a new dependency graph using the {@literal @}{@link
    * Injector}-annotated object and {@code modules}.
+   *
+   * <p>This <strong>does not</strong> inject any members. Most applications
+   * should call {@link #injectStatics} to inject static members and/or {@link
+   * #inject} to inject instance members when this method has returned.
    */
   public static DependencyGraph get(Object injector, Object... overrides) {
     Class<?> injectorClass = injector.getClass();
@@ -70,6 +78,13 @@
     }
     Class<?>[] entryPoints = annotation.entryPoints();
     Class<?>[] modules = annotation.modules();
+    Class<?>[] staticInjectionClasses = annotation.staticInjections();
+
+    // Create static injections.
+    StaticInjection[] staticInjections = new StaticInjection[staticInjectionClasses.length];
+    for (int i = 0; i < staticInjectionClasses.length; i++) {
+      staticInjections[i] = StaticInjection.get(staticInjectionClasses[i]);
+    }
 
     // Create a linker and install all of the user's modules. Modules provided
     // at runtime may override modules provided in the @Injector annotation.
@@ -80,13 +95,22 @@
     // Request the bindings we'll need from the linker. This will cause the
     // linker to link these bindings in the link step.
     getEntryPointsMap(linker, injectorClass, entryPoints);
+    for (StaticInjection staticInjection : staticInjections) {
+      staticInjection.attach(linker);
+    }
 
     // Fill out the graph, creating JIT bindings as necessary.
     linker.link();
 
+    // Attach all necessary injections. Now that we've linked, all bindings will be available.
+    Map<Class<?>, Binding<?>> entryPointsMap =
+        getEntryPointsMap(linker, injectorClass, entryPoints);
+    for (StaticInjection staticInjection : staticInjections) {
+      staticInjection.attach(linker);
+    }
+
     // Link success. Return a new linked dependency graph.
-    return new DependencyGraph(injectorClass,
-        getEntryPointsMap(linker, injectorClass, entryPoints));
+    return new DependencyGraph(staticInjections, injectorClass, entryPointsMap);
   }
 
   private static Object[] classesToObjects(Class<?>[] moduleClasses) {
@@ -124,6 +148,23 @@
     return result;
   }
 
+  /**
+   * Injects the static fields of the classes listed in the injector's {@code
+   * staticInjections} property.
+   */
+  public void injectStatics() {
+    for (StaticInjection staticInjection : staticInjections) {
+      staticInjection.inject();
+    }
+  }
+
+  /**
+   * Injects the members of {@code instance}, including injectable members
+   * inherited from its supertypes.
+   *
+   * @throws IllegalArgumentException if the runtime type of {@code instance} is
+   *     not the injector's type or one of its entry point types.
+   */
   @SuppressWarnings("unchecked") // bindings is a typesafe heterogeneous container
   public void inject(Object instance) {
     Binding<Object> binding = (Binding<Object>) bindings.get(instance.getClass());
/Fim/
diff --git a/src/main/java/com/squareup/injector/Injector.java b/src/main/java/com/squareup/injector/Injector.java
index 2bac98a..93a137d 100644
--- a/src/main/java/com/squareup/injector/Injector.java
+++ b/src/main/java/com/squareup/injector/Injector.java
@@ -29,4 +29,5 @@
 @Target(ElementType.TYPE) public @interface Injector {
   Class<?>[] modules() default { };
   Class<?>[] entryPoints() default { };
+  Class<?>[] staticInjections() default { };
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ConstructorBinding.java b/src/main/java/com/squareup/injector/internal/ConstructorBinding.java
index ae1ab7f..08ca1a4 100644
--- a/src/main/java/com/squareup/injector/internal/ConstructorBinding.java
+++ b/src/main/java/com/squareup/injector/internal/ConstructorBinding.java
@@ -19,6 +19,7 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Modifier;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.List;
@@ -102,7 +103,7 @@
     final List<Field> injectedFields = new ArrayList<Field>();
     for (Class<?> c = type; c != Object.class; c = c.getSuperclass()) {
       for (Field field : c.getDeclaredFields()) {
-        if (field.getAnnotation(Inject.class) == null) {
+        if (field.getAnnotation(Inject.class) == null || Modifier.isStatic(field.getModifiers())) {
           continue;
         }
         field.setAccessible(true);
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/StaticInjection.java b/src/main/java/com/squareup/injector/internal/StaticInjection.java
new file mode 100644
index 0000000..b35bc7e
--- /dev/null
+++ b/src/main/java/com/squareup/injector/internal/StaticInjection.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2012 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.List;
+import javax.inject.Inject;
+
+/**
+ * Injects the static fields of a class.
+ *
+ * @author Jesse Wilson
+ */
+public final class StaticInjection {
+  private final Field[] fields;
+  private Binding<?>[] bindings;
+
+  private StaticInjection(Field[] fields) {
+    this.fields = fields;
+  }
+
+  public static StaticInjection get(Class<?> c) {
+    List<Field> fields = new ArrayList<Field>();
+    for (Field field : c.getDeclaredFields()) {
+      if (field.getAnnotation(Inject.class) == null
+          || !Modifier.isStatic(field.getModifiers())) {
+        continue;
+      }
+      field.setAccessible(true);
+      fields.add(field);
+    }
+    if (fields.isEmpty()) {
+      throw new IllegalArgumentException("No static injections: " + c.getName());
+    }
+    return new StaticInjection(fields.toArray(new Field[fields.size()]));
+  }
+
+  public void attach(Linker linker) {
+    bindings = new Binding<?>[fields.length];
+    for (int i = 0; i < fields.length; i++) {
+      Field field = fields[i];
+      String fieldKey = Keys.get(field.getGenericType(), field.getAnnotations(), field);
+      bindings[i] = linker.requestBinding(fieldKey, field);
+    }
+  }
+
+  public void inject() {
+    try {
+      for (int f = 0; f < fields.length; f++) {
+        fields[f].set(null, bindings[f].get());
+      }
+    } catch (IllegalAccessException e) {
+      throw new AssertionError(e);
+    }
+  }
+}
/Fim/
diff --git a/src/test/java/com/squareup/injector/InjectStaticsTest.java b/src/test/java/com/squareup/injector/InjectStaticsTest.java
new file mode 100644
index 0000000..af26ac5
--- /dev/null
+++ b/src/test/java/com/squareup/injector/InjectStaticsTest.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2012 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import javax.inject.Inject;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+/**
+ * @author Jesse Wilson
+ */
+public final class InjectStaticsTest {
+  @Before public void setUp() {
+    InjectsOneField.staticField = null;
+    InjectsStaticAndNonStatic.staticField = null;
+  }
+
+  @Injector(staticInjections = InjectsOneField.class)
+  public static class InjectorA {
+    @Inject InjectorA() {
+    }
+  }
+
+  public static class InjectsOneField {
+    @Inject static String staticField;
+  }
+
+  @Test public void injectStatics() {
+    DependencyGraph graph = DependencyGraph.get(new InjectorA(), new Object() {
+      @Provides String provideString() {
+        return "static";
+      }
+    });
+    assertThat(InjectsOneField.staticField).isNull();
+    graph.injectStatics();
+    assertThat(InjectsOneField.staticField).isEqualTo("static");
+  }
+
+  @Injector(
+      staticInjections = InjectsStaticAndNonStatic.class,
+      entryPoints = InjectsStaticAndNonStatic.class)
+  public static class InjectorB {
+    @Inject InjectorB() {
+    }
+  }
+
+  public static class InjectsStaticAndNonStatic {
+    @Inject Integer nonStaticField;
+    @Inject static String staticField;
+  }
+
+  @Test public void instanceFieldsNotInjectedByInjectStatics() {
+    DependencyGraph graph = DependencyGraph.get(new InjectorB(), new Object() {
+      @Provides String provideString() {
+        return "static";
+      }
+      @Provides Integer provideInteger() {
+        throw new AssertionError();
+      }
+    });
+    assertThat(InjectsStaticAndNonStatic.staticField).isNull();
+    graph.injectStatics();
+    assertThat(InjectsStaticAndNonStatic.staticField).isEqualTo("static");
+  }
+
+  @Test public void staticFieldsNotInjectedByInjectMembers() {
+    DependencyGraph graph = DependencyGraph.get(new InjectorB(), new Object() {
+      @Provides String provideString() {
+        throw new AssertionError();
+      }
+      @Provides Integer provideInteger() {
+        return 5;
+      }
+    });
+    assertThat(InjectsStaticAndNonStatic.staticField).isNull();
+    InjectsStaticAndNonStatic object = new InjectsStaticAndNonStatic();
+    graph.inject(object);
+    assertThat(InjectsStaticAndNonStatic.staticField).isNull();
+    assertThat(object.nonStaticField).isEqualTo(5);
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/codegen/CodeGen.java b/src/main/java/com/squareup/codegen/CodeGen.java
index 960aa8c..8da7a60 100644
--- a/src/main/java/com/squareup/codegen/CodeGen.java
+++ b/src/main/java/com/squareup/codegen/CodeGen.java
@@ -18,6 +18,7 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
 
 /**
  * Support for annotation processors.
@@ -36,6 +37,20 @@
   }
 
   /**
+   * Returns a fully qualified class name to complement {@code type}. The
+   * returned class is in the same package as {@code type}. This supports nested
+   * classes by using a '$' instead of '.' for nesting:  "java.util.Map.Entry"
+   * becomes "java.util.Map$Entry".
+   */
+  public static String adapterName(TypeElement typeName, String suffix) {
+    String packageName = CodeGen.getPackage(typeName).getQualifiedName().toString();
+    String qualifiedName = typeName.getQualifiedName().toString();
+    return packageName + '.'
+        + qualifiedName.substring(packageName.length() + 1).replace('.', '$')
+        + suffix;
+  }
+
+  /**
    * Returns a string like {@code java.util.List<java.lang.String>}.
    */
   public static String parameterizedType(Class<?> raw, String... parameters) {
/Fim/
diff --git a/src/main/java/com/squareup/codegen/InjectProcessor.java b/src/main/java/com/squareup/codegen/InjectProcessor.java
index 9d9e324..08475c9 100644
--- a/src/main/java/com/squareup/codegen/InjectProcessor.java
+++ b/src/main/java/com/squareup/codegen/InjectProcessor.java
@@ -20,6 +20,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -61,7 +62,7 @@
     } catch (IOException e) {
       processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "Code gen failed: " + e);
     }
-    return !types.isEmpty();
+    return true;
   }
 
   private Map<TypeElement, InjectedClass> getInjectedClasses(RoundEnvironment env) {
@@ -80,18 +81,51 @@
         injectedClass.constructor = (ExecutableElement) element;
       }
     }
+
+    // Find no-args constructors for classes that don't have @Inject constructors.
+    for (Iterator<Map.Entry<TypeElement, InjectedClass>> i = classes.entrySet().iterator();
+        i.hasNext(); ) {
+      Map.Entry<TypeElement, InjectedClass> entry = i.next();
+      TypeElement typeElement = entry.getKey();
+      InjectedClass injectedClass = entry.getValue();
+      if (injectedClass.constructor == null) {
+        injectedClass.constructor = getNoArgsConstructor(typeElement);
+        if (injectedClass.constructor == null) {
+          processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
+              "no injectable constructor for " + typeElement.getQualifiedName());
+          i.remove();
+        }
+      }
+    }
+
     return classes;
   }
 
   /**
-   * Write a companion class for {@code type} that implements {@link
-   * com.squareup.injector.internal.ModuleAdapter} to expose its provider methods.
+   * Returns the no args constructor for {@code typeElement}, or null if no such
+   * constructor exists.
+   */
+  private ExecutableElement getNoArgsConstructor(TypeElement typeElement) {
+    for (Element element : typeElement.getEnclosedElements()) {
+      if (element.getKind() != ElementKind.CONSTRUCTOR) {
+        continue;
+      }
+      ExecutableElement constructor = (ExecutableElement) element;
+      if (constructor.getParameters().isEmpty()) {
+        return constructor;
+      }
+    }
+    return null;
+  }
+
+  /**
+   * Write a companion class for {@code type} that extends {@link Binding}.
    */
   private void writeInjectAdapter(TypeElement type, ExecutableElement constructor,
       List<Element> fields) throws IOException {
     String key = GeneratorKeys.get(type);
     String typeName = type.getQualifiedName().toString();
-    String adapterName = typeName + "$InjectAdapter";
+    String adapterName = CodeGen.adapterName(type, "$InjectAdapter");
     JavaFileObject sourceFile = processingEnv.getFiler()
         .createSourceFile(adapterName, type);
     JavaWriter writer = new JavaWriter(sourceFile.openWriter());
@@ -115,7 +149,7 @@
           fieldName(f), PRIVATE);
     }
 
-    writer.beginMethod(null, type.getSimpleName() + "$InjectAdapter", PUBLIC);
+    writer.beginMethod(null, adapterName, PUBLIC);
     writer.statement("super(%s.class, %s)", typeName, JavaWriter.stringLiteral(key));
     writer.endMethod();
 
/Fim/
diff --git a/src/main/java/com/squareup/codegen/JavaWriter.java b/src/main/java/com/squareup/codegen/JavaWriter.java
index 4ac5ae1..a0b2d1c 100644
--- a/src/main/java/com/squareup/codegen/JavaWriter.java
+++ b/src/main/java/com/squareup/codegen/JavaWriter.java
@@ -207,7 +207,8 @@
    *
    * @param returnType the method's return type, or null for constructors.
    * @param parameters alternating parameter types and names.
-   * @param name the method name, or the class name for constructors.
+   * @param name the method name, or the fully qualified class name for
+   *     constructors.
    */
   public void beginMethod(String returnType, String name, int modifiers, String... parameters)
       throws IOException {
@@ -216,8 +217,10 @@
     if (returnType != null) {
       type(returnType);
       out.write(" ");
+      out.write(name);
+    } else {
+      type(name);
     }
-    out.write(name);
     out.write("(");
     for (int p = 0; p < parameters.length; ) {
       if (p != 0) {
/Fim/
diff --git a/src/main/java/com/squareup/codegen/ProvidesProcessor.java b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
index 80b5ded..ecc597b 100644
--- a/src/main/java/com/squareup/codegen/ProvidesProcessor.java
+++ b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
@@ -68,7 +68,7 @@
     } catch (IOException e) {
       processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "Code gen failed: " + e);
     }
-    return !types.isEmpty();
+    return true;
   }
 
   /**
@@ -117,8 +117,9 @@
    */
   private void writeModuleAdapter(TypeElement type, List<ExecutableElement> providerMethods)
       throws IOException {
+    String adapterName = CodeGen.adapterName(type, "$ModuleAdapter");
     JavaFileObject sourceFile = processingEnv.getFiler()
-        .createSourceFile(type.getQualifiedName() + "$ModuleAdapter", type);
+        .createSourceFile(adapterName, type);
     JavaWriter writer = new JavaWriter(sourceFile.openWriter());
 
     writer.addPackage(CodeGen.getPackage(type).getQualifiedName().toString());
@@ -128,7 +129,7 @@
     writer.addImport(Linker.class);
 
     String typeName = type.getQualifiedName().toString();
-    writer.beginType(typeName + "$ModuleAdapter", "class", PUBLIC | FINAL, null,
+    writer.beginType(adapterName, "class", PUBLIC | FINAL, null,
         CodeGen.parameterizedType(ModuleAdapter.class, typeName));
 
     writer.annotation(Override.class);
/Fim/
diff --git a/src/test/java/com/squareup/codegen/JavaWriterTest.java b/src/test/java/com/squareup/codegen/JavaWriterTest.java
index a485521..2477866 100644
--- a/src/test/java/com/squareup/codegen/JavaWriterTest.java
+++ b/src/test/java/com/squareup/codegen/JavaWriterTest.java
@@ -91,7 +91,7 @@
   @Test public void constructorDeclaration() throws IOException {
     javaWriter.addPackage("com.squareup");
     javaWriter.beginType("com.squareup.Foo", "class", 0);
-    javaWriter.beginMethod(null, "Foo", Modifier.PUBLIC, "java.lang.String", "s");
+    javaWriter.beginMethod(null, "com.squareup.Foo", Modifier.PUBLIC, "java.lang.String", "s");
     javaWriter.endMethod();
     javaWriter.endType();
     assertCode(""
/Fim/
diff --git a/src/main/java/com/squareup/codegen/JavaWriter.java b/src/main/java/com/squareup/codegen/JavaWriter.java
index a0b2d1c..688e52e 100644
--- a/src/main/java/com/squareup/codegen/JavaWriter.java
+++ b/src/main/java/com/squareup/codegen/JavaWriter.java
@@ -115,7 +115,8 @@
       String imported;
       if ((imported = importedTypes.get(name)) != null) {
         out.write(imported);
-      } else if (name.startsWith(packagePrefix)) {
+      } else if (name.startsWith(packagePrefix)
+          && name.indexOf('.', packagePrefix.length()) == -1) {
         out.write(name.substring(packagePrefix.length()));
       } else if (name.startsWith("java.lang.")) {
         out.write(name.substring("java.lang.".length()));
/Fim/
diff --git a/src/main/java/com/squareup/injector/DependencyGraph.java b/src/main/java/com/squareup/injector/DependencyGraph.java
index cae1c3e..6eac151 100644
--- a/src/main/java/com/squareup/injector/DependencyGraph.java
+++ b/src/main/java/com/squareup/injector/DependencyGraph.java
@@ -19,7 +19,9 @@
 import com.squareup.injector.internal.Keys;
 import com.squareup.injector.internal.Linker;
 import com.squareup.injector.internal.StaticInjection;
+import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 
 /**
@@ -114,18 +116,19 @@
   }
 
   private static Object[] classesToObjects(Class<?>[] moduleClasses) {
-    try {
-      Object[] moduleObjects = new Object[moduleClasses.length];
-      for (int i = 0; i < moduleClasses.length; i++) {
-        Class<?> module = moduleClasses[i];
-        moduleObjects[i] = module.newInstance();
+    List<Object> moduleObjects = new ArrayList<Object>();
+    for (Class<?> module : moduleClasses) {
+      try {
+        moduleObjects.add(module.newInstance());
+      } catch (InstantiationException e) {
+        // No no-args constructor. Assume there's an override.
+      } catch (RuntimeException e) {
+        throw e;
+      } catch (Exception e) {
+        throw new RuntimeException(e);
       }
-      return moduleObjects;
-    } catch (RuntimeException e) {
-      throw e;
-    } catch (Exception e) {
-      throw new RuntimeException(e);
     }
+    return moduleObjects.toArray();
   }
 
   /**
/Fim/
diff --git a/src/test/java/com/squareup/codegen/JavaWriterTest.java b/src/test/java/com/squareup/codegen/JavaWriterTest.java
index 2477866..379998f 100644
--- a/src/test/java/com/squareup/codegen/JavaWriterTest.java
+++ b/src/test/java/com/squareup/codegen/JavaWriterTest.java
@@ -132,6 +132,18 @@
         + "}\n");
   }
 
+  @Test public void addImportFromSubpackage() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", Modifier.PUBLIC | Modifier.FINAL);
+    javaWriter.field("com.squareup.bar.Baz", "baz", 0);
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "public final class Foo {\n"
+        + "  com.squareup.bar.Baz baz;\n"
+        + "}\n");
+  }
+
   @Test public void ifControlFlow() throws IOException {
     javaWriter.addPackage("com.squareup");
     javaWriter.beginType("com.squareup.Foo", "class", 0);
/Fim/
diff --git a/src/test/java/com/squareup/injector/InjectorTest.java b/src/test/java/com/squareup/injector/InjectorTest.java
index 553aa2e..4948d1d 100644
--- a/src/test/java/com/squareup/injector/InjectorTest.java
+++ b/src/test/java/com/squareup/injector/InjectorTest.java
@@ -358,6 +358,36 @@
     }
   }
 
+  @Test public void manuallyCreatedModuleNoOverride() {
+    try {
+      new ManuallyCreatedModuleInjector().inject();
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void manuallyCreatedModuleWithOverride() {
+    ManuallyCreatedModuleInjector module = new ManuallyCreatedModuleInjector()
+        .inject(new ManuallyCreatedModule("runtime argument"));
+    assertThat(module.string).isEqualTo("runtime argument");
+  }
+
+  @Injector(modules = { ManuallyCreatedModule.class })
+  public static class ManuallyCreatedModuleInjector
+      extends AbstractInjector<ManuallyCreatedModuleInjector> {
+    @Inject String string;
+  }
+
+  static class ManuallyCreatedModule {
+    final String string;
+    public ManuallyCreatedModule(String string) {
+      this.string = string;
+    }
+    @Provides String provideString() {
+      return string;
+    }
+  }
+
   public static abstract class AbstractInjector<T> {
     @SuppressWarnings("unchecked")
     public T inject(Object... modules) {
/Fim/
diff --git a/pom.xml b/pom.xml
index 4af38b8..a5b9c69 100644
--- a/pom.xml
+++ b/pom.xml
@@ -37,6 +37,7 @@
         <junit.version>4.10</junit.version>
         <fest.version>1.4</fest.version>
         <javax.inject.version>1</javax.inject.version>
+        <guice.version>3.0</guice.version>
     </properties>
 
     <scm>
@@ -69,6 +70,12 @@
             <version>${javax.inject.version}</version>
         </dependency>
         <dependency>
+            <groupId>com.google.inject</groupId>
+            <artifactId>guice</artifactId>
+            <version>${guice.version}</version>
+            <classifier>no_aop</classifier>
+        </dependency>
+        <dependency>
             <groupId>junit</groupId>
             <artifactId>junit</artifactId>
             <version>${junit.version}</version>
/Fim/
diff --git a/src/main/java/com/squareup/codegen/ProvidesProcessor.java b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
index ecc597b..122e670 100644
--- a/src/main/java/com/squareup/codegen/ProvidesProcessor.java
+++ b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
@@ -22,6 +22,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -48,8 +49,6 @@
 /**
  * Generates an implementation of {@link ModuleAdapter} that includes a binding
  * for each {@code @Provides} method of a target class.
- *
- * @author Jesse Wilson
  */
 @SupportedAnnotationTypes("com.squareup.injector.Provides")
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
@@ -77,7 +76,7 @@
   private Map<TypeElement, List<ExecutableElement>> providerMethodsByClass(RoundEnvironment env) {
     Map<TypeElement, List<ExecutableElement>> result
         = new HashMap<TypeElement, List<ExecutableElement>>();
-    for (Element providerMethod : env.getElementsAnnotatedWith(Provides.class)) {
+    for (Element providerMethod : providesMethods(env)) {
       TypeElement type = (TypeElement) providerMethod.getEnclosingElement();
       Set<Modifier> typeModifiers = type.getModifiers();
       if (type.getKind() != ElementKind.CLASS) {
@@ -111,6 +110,13 @@
     return result;
   }
 
+  private Set<? extends Element> providesMethods(RoundEnvironment env) {
+    Set<Element> result = new LinkedHashSet<Element>();
+    result.addAll(env.getElementsAnnotatedWith(Provides.class));
+    result.addAll(env.getElementsAnnotatedWith(com.google.inject.Provides.class));
+    return result;
+  }
+
   /**
    * Write a companion class for {@code type} that implements {@link
    * ModuleAdapter} to expose its provider methods.
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Binding.java b/src/main/java/com/squareup/injector/internal/Binding.java
index c408887..d6740fa 100644
--- a/src/main/java/com/squareup/injector/internal/Binding.java
+++ b/src/main/java/com/squareup/injector/internal/Binding.java
@@ -23,7 +23,8 @@
  *
  * @author Jesse Wilson
  */
-public abstract class Binding<T> implements Provider<T>, MembersInjector<T> {
+public abstract class Binding<T> implements Provider<T>, MembersInjector<T>,
+    com.google.inject.Provider<T>, com.google.inject.MembersInjector<T> {
   final Object requiredBy;
   public final String key;
 
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ConstructorBinding.java b/src/main/java/com/squareup/injector/internal/ConstructorBinding.java
index 08ca1a4..3631c4c 100644
--- a/src/main/java/com/squareup/injector/internal/ConstructorBinding.java
+++ b/src/main/java/com/squareup/injector/internal/ConstructorBinding.java
@@ -121,9 +121,8 @@
         continue;
       }
       if (injectedConstructor != null) {
-        throw new IllegalArgumentException("Too many injectable constructors on " + type);
+        throw new IllegalArgumentException("Too many injectable constructors on " + type.getName());
       }
-      constructor.setAccessible(true);
       injectedConstructor = constructor;
     }
     if (injectedConstructor == null) {
@@ -137,6 +136,10 @@
       }
     }
 
+    if (injectedConstructor != null) {
+      injectedConstructor.setAccessible(true);
+    }
+
     return new ConstructorBinding<T>(type, Keys.get(type, null), injectedConstructor,
         injectedFields.toArray(new Field[injectedFields.size()]));
   }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Keys.java b/src/main/java/com/squareup/injector/internal/Keys.java
index 5b870c1..4d71139 100644
--- a/src/main/java/com/squareup/injector/internal/Keys.java
+++ b/src/main/java/com/squareup/injector/internal/Keys.java
@@ -30,12 +30,15 @@
  * This currently formats keys by concatenating the annotation name, a slash
  * "/", and the type name. Parameterized types are formatted with ", " between
  * type parameters. The exact key format may change in a future release.
- *
- * @author Jesse Wilson
  */
 public final class Keys {
   private static final String PROVIDER_PREFIX = Provider.class.getName() + "<";
   private static final String MEMBERS_INJECTOR_PREFIX = MembersInjector.class.getName() + "<";
+  private static final String GUICE_MEMBERS_INJECTOR_PREFIX
+      = com.google.inject.MembersInjector.class.getName() + "<";
+  private static final String GUICE_PROVIDER_PREFIX
+      = com.google.inject.Provider.class.getName() + "<";
+
   private static final LruCache<Class<? extends Annotation>, Boolean> IS_QUALIFIER_ANNOTATION
       = new LruCache<Class<? extends Annotation>, Boolean>(Integer.MAX_VALUE) {
     @Override protected Boolean create(Class<? extends Annotation> annotationType) {
@@ -139,10 +142,14 @@
     }
 
     String wrapperPrefix;
-    if (key.regionMatches(start, PROVIDER_PREFIX, 0, PROVIDER_PREFIX.length())) {
+    if (substringStartsWith(key, start, PROVIDER_PREFIX)) {
       wrapperPrefix = PROVIDER_PREFIX;
-    } else if (key.regionMatches(start, MEMBERS_INJECTOR_PREFIX, 0, MEMBERS_INJECTOR_PREFIX.length())) {
+    } else if (substringStartsWith(key, start, GUICE_PROVIDER_PREFIX)) {
+      wrapperPrefix = GUICE_PROVIDER_PREFIX;
+    } else if (substringStartsWith(key, start, MEMBERS_INJECTOR_PREFIX)) {
       wrapperPrefix = MEMBERS_INJECTOR_PREFIX;
+    } else if (substringStartsWith(key, start, GUICE_MEMBERS_INJECTOR_PREFIX)) {
+      wrapperPrefix = GUICE_MEMBERS_INJECTOR_PREFIX;
     } else {
       return null;
     }
@@ -151,6 +158,13 @@
   }
 
   /**
+   * Returns true if {@code string.substring(offset).startsWith(substring)}.
+   */
+  private static boolean substringStartsWith(String string, int offset, String substring) {
+    return string.regionMatches(offset, substring, 0, substring.length());
+  }
+
+  /**
    * Returns true if {@code key} has a qualifier annotation.
    */
   public static boolean isAnnotated(String key) {
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Modules.java b/src/main/java/com/squareup/injector/internal/Modules.java
index b0a8c93..41058eb 100644
--- a/src/main/java/com/squareup/injector/internal/Modules.java
+++ b/src/main/java/com/squareup/injector/internal/Modules.java
@@ -59,7 +59,8 @@
     Map<String, Binding<?>> result = new HashMap<String, Binding<?>>();
     for (Class<?> c = module.getClass(); c != Object.class; c = c.getSuperclass()) {
       for (Method method : c.getDeclaredMethods()) {
-        if (method.getAnnotation(Provides.class) == null) {
+        if (method.getAnnotation(Provides.class) == null
+            && method.getAnnotation(com.google.inject.Provides.class) == null) {
           continue;
         }
         Binding<Object> binding = methodToBinding(module, method);
/Fim/
diff --git a/src/test/java/com/squareup/injector/GuiceSupportTest.java b/src/test/java/com/squareup/injector/GuiceSupportTest.java
new file mode 100644
index 0000000..0eeb67f
--- /dev/null
+++ b/src/test/java/com/squareup/injector/GuiceSupportTest.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2012 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import javax.inject.Inject;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+@SuppressWarnings("unused")
+public final class GuiceSupportTest {
+  @Injector(modules = StringModule.class)
+  public static class GuiceInjector {
+    @Inject com.google.inject.Provider<Injectable> provider;
+    @Inject com.google.inject.MembersInjector<Injectable> membersInjector;
+  }
+
+  public static class Injectable {
+    @Inject String string;
+  }
+
+  static class StringModule {
+    @Provides String provideString() {
+      return "injected";
+    }
+  }
+
+  @Test public void testGuiceProviderGet() {
+    GuiceInjector injector = new GuiceInjector();
+    DependencyGraph.get(injector).inject(injector);
+    Injectable provided = injector.provider.get();
+    assertThat(provided.string).isEqualTo("injected");
+  }
+
+  @Test public void testGuiceMembersInjector() {
+    GuiceInjector injector = new GuiceInjector();
+    DependencyGraph.get(injector).inject(injector);
+    Injectable injectable = new Injectable();
+    injector.membersInjector.injectMembers(injectable);
+    assertThat(injectable.string).isEqualTo("injected");
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/codegen/ProvidesProcessor.java b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
index 70798c5..d9e5ef4 100644
--- a/src/main/java/com/squareup/codegen/ProvidesProcessor.java
+++ b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
@@ -87,7 +87,8 @@
       if (typeModifiers.contains(Modifier.PRIVATE)
           || typeModifiers.contains(Modifier.ABSTRACT)) {
         processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
-            "Unexpected modifiers on type declaring @Provides method: " + providerMethod);
+            "Classes declaring @Provides methods must not be private or abstract: "
+                + type.getQualifiedName());
       }
 
       Set<Modifier> methodModifiers = providerMethod.getModifiers();
@@ -95,7 +96,8 @@
           || methodModifiers.contains(Modifier.ABSTRACT)
           || methodModifiers.contains(Modifier.STATIC)) {
         processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
-            "Unexpected modifiers on @Provides method: " + providerMethod);
+            "@Provides methods must not be private, abstract or static: "
+                + type.getQualifiedName() + "." + providerMethod);
         continue;
       }
 
@@ -178,8 +180,8 @@
     writer.beginMethod(null, className, PUBLIC, moduleType, "module");
     boolean singleton = true; // TODO
     boolean injectMembersOnly = false;
-    writer.statement("super(%s, %s, %s, %s.class)",
-        JavaWriter.stringLiteral(key), singleton, injectMembersOnly, moduleType);
+    writer.statement("super(%s, %s, %s, %s.class)", JavaWriter.stringLiteral(key), singleton,
+        injectMembersOnly, moduleType);
     writer.statement("this.module = module");
     writer.endMethod();
 
/Fim/
diff --git a/src/main/java/com/squareup/injector/Injector.java b/src/main/java/com/squareup/injector/Module.java
similarity index 69%
rename from src/main/java/com/squareup/injector/Injector.java
rename to src/main/java/com/squareup/injector/Module.java
index 93a137d..ae76826 100644
--- a/src/main/java/com/squareup/injector/Injector.java
+++ b/src/main/java/com/squareup/injector/Module.java
@@ -21,13 +21,19 @@
 import java.lang.annotation.Target;
 
 /**
- * Annotates the root of the dependency graph.
- *
- * @author Jesse Wilson
+ * Annotates a class that contributes to the object graph.
  */
 @Retention(RetentionPolicy.RUNTIME)
-@Target(ElementType.TYPE) public @interface Injector {
-  Class<?>[] modules() default { };
+@Target(ElementType.TYPE)
+public @interface Module {
   Class<?>[] entryPoints() default { };
   Class<?>[] staticInjections() default { };
+
+  /**
+   * True if @Provides methods from this module are permitted to override those
+   * of other modules. This is a dangerous feature as it permits binding
+   * conflicts to go unnoticed. It should only be used in test and development
+   * modules.
+   */
+  boolean overrides() default false;
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/ObjectGraph.java b/src/main/java/com/squareup/injector/ObjectGraph.java
index 4309215..cb39367 100644
--- a/src/main/java/com/squareup/injector/ObjectGraph.java
+++ b/src/main/java/com/squareup/injector/ObjectGraph.java
@@ -21,8 +21,11 @@
 import com.squareup.injector.internal.StaticInjection;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 /**
  * A graph of objects linked by their dependencies.
@@ -51,50 +54,62 @@
  * </ul>
  */
 public final class ObjectGraph {
-  private final StaticInjection[] staticInjections;
-  private final Class<?> injectorClass;
+  private final List<StaticInjection> staticInjections;
   private final Map<Class<?>, Binding<?>> bindings;
 
-  private ObjectGraph(StaticInjection[] staticInjections, Class<?> injectorClass,
-      Map<Class<?>, Binding<?>> bindings) {
+  private ObjectGraph(List<StaticInjection> staticInjections, Map<Class<?>, Binding<?>> bindings) {
     this.staticInjections = staticInjections;
-    this.injectorClass = injectorClass;
     this.bindings = bindings;
   }
 
   /**
    * Returns a new dependency graph using the {@literal @}{@link
-   * Injector}-annotated object and {@code modules}.
+   * Module}-annotated modules.
    *
    * <p>This <strong>does not</strong> inject any members. Most applications
    * should call {@link #injectStatics} to inject static members and/or {@link
    * #inject} to inject instance members when this method has returned.
    */
-  public static ObjectGraph get(Object injector, Object... overrides) {
-    Class<?> injectorClass = injector.getClass();
-    Injector annotation = injectorClass.getAnnotation(Injector.class);
-    if (annotation == null) {
-      throw new IllegalArgumentException("No @Injector on " + injectorClass.getName());
+  public static ObjectGraph get(Object... modules) {
+    Map<Class<?>, Class<?>> entryPoints = new LinkedHashMap<Class<?>, Class<?>>();
+    Set<Class<?>> staticInjectionClasses = new LinkedHashSet<Class<?>>();
+
+    List<Object> baseModules = new ArrayList<Object>();
+    List<Object> overrideModules = new ArrayList<Object>();
+    for (Object module : modules) {
+      Class<?> moduleClass = module.getClass();
+      Module annotation = moduleClass.getAnnotation(Module.class);
+      if (annotation == null) {
+        throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
+      }
+      for (Class<?> entryPoint : annotation.entryPoints()) {
+        entryPoints.put(entryPoint, moduleClass);
+      }
+      for (Class<?> staticInjection : annotation.staticInjections()) {
+        staticInjectionClasses.add(staticInjection);
+      }
+      if (annotation.overrides()) {
+        overrideModules.add(module);
+      } else {
+        baseModules.add(module);
+      }
     }
-    Class<?>[] entryPoints = annotation.entryPoints();
-    Class<?>[] modules = annotation.modules();
-    Class<?>[] staticInjectionClasses = annotation.staticInjections();
 
     // Create static injections.
-    StaticInjection[] staticInjections = new StaticInjection[staticInjectionClasses.length];
-    for (int i = 0; i < staticInjectionClasses.length; i++) {
-      staticInjections[i] = StaticInjection.get(staticInjectionClasses[i]);
+    List<StaticInjection> staticInjections = new ArrayList<StaticInjection>();
+    for (Class<?> c : staticInjectionClasses) {
+      staticInjections.add(StaticInjection.get(c));
     }
 
     // Create a linker and install all of the user's modules. Modules provided
-    // at runtime may override modules provided in the @Injector annotation.
+    // at runtime may override modules provided in the @Module annotation.
     Linker linker = new Linker();
-    linker.installModules(classesToObjects(modules));
-    linker.installModules(overrides);
+    linker.installModules(baseModules);
+    linker.installModules(overrideModules);
 
     // Request the bindings we'll need from the linker. This will cause the
     // linker to link these bindings in the link step.
-    getEntryPointsMap(linker, injectorClass, entryPoints);
+    getEntryPointsMap(linker, entryPoints);
     for (StaticInjection staticInjection : staticInjections) {
       staticInjection.attach(linker);
     }
@@ -104,29 +119,13 @@
 
     // Attach all necessary injections. Now that we've linked, all bindings will be available.
     Map<Class<?>, Binding<?>> entryPointsMap =
-        getEntryPointsMap(linker, injectorClass, entryPoints);
+        getEntryPointsMap(linker, entryPoints);
     for (StaticInjection staticInjection : staticInjections) {
       staticInjection.attach(linker);
     }
 
     // Link success. Return a new linked dependency graph.
-    return new ObjectGraph(staticInjections, injectorClass, entryPointsMap);
-  }
-
-  private static Object[] classesToObjects(Class<?>[] moduleClasses) {
-    List<Object> moduleObjects = new ArrayList<Object>();
-    for (Class<?> module : moduleClasses) {
-      try {
-        moduleObjects.add(module.newInstance());
-      } catch (InstantiationException e) {
-        // No no-args constructor. Assume there's an override.
-      } catch (RuntimeException e) {
-        throw e;
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-    return moduleObjects.toArray();
+    return new ObjectGraph(staticInjections, entryPointsMap);
   }
 
   /**
@@ -139,12 +138,13 @@
    * <p>If executed after {@code link()}, the bindings will not be null and the
    * map can be used.
    */
-  private static Map<Class<?>, Binding<?>> getEntryPointsMap(Linker linker, Class<?> injectorClass,
-      Class<?>[] entryPoints) {
+  private static Map<Class<?>, Binding<?>> getEntryPointsMap(Linker linker,
+      Map<Class<?>, Class<?>> entryPoints) {
     Map<Class<?>, Binding<?>> result = new HashMap<Class<?>, Binding<?>>();
-    result.put(injectorClass, linker.requestBinding(Keys.get(injectorClass), "injector", false));
-    for (Class<?> entryPoint : entryPoints) {
-      result.put(entryPoint, linker.requestBinding(Keys.get(entryPoint), "entry point", false));
+    for (Map.Entry<Class<?>, Class<?>> entry : entryPoints.entrySet()) {
+      Class<?> entryPoint = entry.getKey();
+      Class<?> moduleClass = entry.getValue();
+      result.put(entryPoint, linker.requestBinding(Keys.get(entryPoint), moduleClass, false));
     }
     return result;
   }
@@ -171,7 +171,7 @@
     Binding<Object> binding = (Binding<Object>) bindings.get(instance.getClass());
     if (binding == null) {
       throw new IllegalArgumentException("No binding for " + instance.getClass().getName() + ". "
-          + "You must explicitly add it as an entry point of " + injectorClass.getName() + ".");
+          + "You must explicitly add it as an entry point.");
     }
     binding.injectMembers(instance);
   }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Keys.java b/src/main/java/com/squareup/injector/internal/Keys.java
index 43b0425..04bdd23 100644
--- a/src/main/java/com/squareup/injector/internal/Keys.java
+++ b/src/main/java/com/squareup/injector/internal/Keys.java
@@ -164,7 +164,8 @@
     if (key.startsWith("@")) {
       start = key.lastIndexOf('/') + 1;
     }
-    return key.regionMatches(start, MEMBERS_INJECTOR_PREFIX, 0, MEMBERS_INJECTOR_PREFIX.length());
+    return substringStartsWith(key, start, MEMBERS_INJECTOR_PREFIX)
+        || substringStartsWith(key, start, GUICE_MEMBERS_INJECTOR_PREFIX);
   }
 
   /** Returns true if {@code key} has a qualifier annotation. */
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Linker.java b/src/main/java/com/squareup/injector/internal/Linker.java
index b1386f4..b998903 100644
--- a/src/main/java/com/squareup/injector/internal/Linker.java
+++ b/src/main/java/com/squareup/injector/internal/Linker.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.injector.internal;
 
+import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.LinkedList;
@@ -45,7 +46,7 @@
    * be any duplicated bindings in {@code modules}, though multiple calls to
    * this method may contain duplicates: last installed wins.
    */
-  public void installModules(Object[] modules) {
+  public void installModules(Iterable<Object> modules) {
     for (Binding<?> binding : Modules.getBindings(modules).values()) {
       putBinding(binding);
     }
@@ -108,8 +109,11 @@
 
     String className = Keys.getClassName(deferred.key);
     if (className != null && !Keys.isAnnotated(deferred.key)) {
-      // Handle all other injections with constructor bindings.
-      return ConstructorBinding.create(Class.forName(className));
+      // Handle concrete class injections with constructor bindings.
+      Class<?> c = Class.forName(className);
+      if (!c.isInterface() && !Modifier.isAbstract(c.getModifiers())) {
+        return ConstructorBinding.create(c);
+      }
     }
 
     throw new IllegalArgumentException("No binding for " + deferred.key);
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Modules.java b/src/main/java/com/squareup/injector/internal/Modules.java
index 41058eb..45b2246 100644
--- a/src/main/java/com/squareup/injector/internal/Modules.java
+++ b/src/main/java/com/squareup/injector/internal/Modules.java
@@ -36,16 +36,10 @@
    *
    * @throws IllegalArgumentException if any bindings are duplicated.
    */
-  public static Map<String, Binding<?>> getBindings(Object... modules) {
+  public static Map<String, Binding<?>> getBindings(Iterable<Object> modules) {
     Map<String, Binding<?>> result = new HashMap<String, Binding<?>>();
-    int expectedSize = 0;
     for (Object module : modules) {
-      Map<String, Binding<?>> moduleBindings = extractBindings(module);
-      expectedSize += moduleBindings.size();
-      result.putAll(moduleBindings);
-    }
-    if (result.size() != expectedSize) {
-      throw new IllegalArgumentException("Duplicate bindings!");
+      extractBindings(module, result);
     }
     return result;
   }
@@ -55,22 +49,26 @@
    * returned bindings are not attached to a particular injector and cannot be
    * used to inject values.
    */
-  private static Map<String, Binding<?>> extractBindings(Object module) {
-    Map<String, Binding<?>> result = new HashMap<String, Binding<?>>();
+  private static void extractBindings(Object module, Map<String, Binding<?>> result) {
+    int count = 0;
     for (Class<?> c = module.getClass(); c != Object.class; c = c.getSuperclass()) {
       for (Method method : c.getDeclaredMethods()) {
         if (method.getAnnotation(Provides.class) == null
             && method.getAnnotation(com.google.inject.Provides.class) == null) {
           continue;
         }
-        Binding<Object> binding = methodToBinding(module, method);
-        result.put(binding.key, binding);
+        count++;
+        Binding<?> binding = methodToBinding(module, method);
+        Binding<?> clobbered = result.put(binding.key, binding);
+        if (clobbered != null) {
+          throw new IllegalArgumentException("Duplicate bindings:\n    "
+              + clobbered + "\n    " + binding);
+        }
       }
     }
-    if (result.isEmpty()) {
+    if (count == 0) {
       throw new IllegalArgumentException("No @Provides methods on " + module);
     }
-    return result;
   }
 
   private static <T> Binding<T> methodToBinding(Object module, Method method) {
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java b/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
index 52b6bdf..7d80337 100644
--- a/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
+++ b/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
@@ -60,4 +60,8 @@
       throw new RuntimeException(e.getCause());
     }
   }
+
+  @Override public String toString() {
+    return method.toString();
+  }
 }
/Fim/
diff --git a/src/test/java/com/squareup/injector/GuiceSupportTest.java b/src/test/java/com/squareup/injector/GuiceSupportTest.java
index bff18be..303b9ab 100644
--- a/src/test/java/com/squareup/injector/GuiceSupportTest.java
+++ b/src/test/java/com/squareup/injector/GuiceSupportTest.java
@@ -22,34 +22,44 @@
 
 @SuppressWarnings("unused")
 public final class GuiceSupportTest {
-  @Injector(modules = StringModule.class)
-  public static class GuiceInjector {
-    @Inject com.google.inject.Provider<Injectable> provider;
-    @Inject com.google.inject.MembersInjector<Injectable> membersInjector;
-  }
-
-  public static class Injectable {
+  static class Injectable {
     @Inject String string;
   }
 
-  static class StringModule {
-    @Provides String provideString() {
-      return "injected";
-    }
-  }
-
   @Test public void testGuiceProviderGet() {
-    GuiceInjector injector = new GuiceInjector();
-    ObjectGraph.get(injector).inject(injector);
-    Injectable provided = injector.provider.get();
+    class TestEntryPoint {
+      @Inject com.google.inject.Provider<Injectable> provider;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class StringModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new StringModule()).inject(entryPoint);
+    Injectable provided = entryPoint.provider.get();
     assertThat(provided.string).isEqualTo("injected");
   }
 
   @Test public void testGuiceMembersInjector() {
-    GuiceInjector injector = new GuiceInjector();
-    ObjectGraph.get(injector).inject(injector);
+    class TestEntryPoint {
+      @Inject com.google.inject.MembersInjector<Injectable> membersInjector;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class StringModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new StringModule()).inject(entryPoint);
     Injectable injectable = new Injectable();
-    injector.membersInjector.injectMembers(injectable);
+    entryPoint.membersInjector.injectMembers(injectable);
     assertThat(injectable.string).isEqualTo("injected");
   }
 }
/Fim/
diff --git a/src/test/java/com/squareup/injector/InjectStaticsTest.java b/src/test/java/com/squareup/injector/InjectStaticsTest.java
index 6356165..5a1f735 100644
--- a/src/test/java/com/squareup/injector/InjectStaticsTest.java
+++ b/src/test/java/com/squareup/injector/InjectStaticsTest.java
@@ -28,63 +28,62 @@
     InjectsStaticAndNonStatic.staticField = null;
   }
 
-  @Injector(staticInjections = InjectsOneField.class)
-  public static class InjectorA {
-    @Inject InjectorA() {
-    }
-  }
-
   public static class InjectsOneField {
     @Inject static String staticField;
   }
 
-  @Test public void injectStatics() {
-    ObjectGraph graph = ObjectGraph.get(new InjectorA(), new Object() {
-      @Provides String provideString() {
-        return "static";
-      }
-    });
-    assertThat(InjectsOneField.staticField).isNull();
-    graph.injectStatics();
-    assertThat(InjectsOneField.staticField).isEqualTo("static");
-  }
-
-  @Injector(
-      staticInjections = InjectsStaticAndNonStatic.class,
-      entryPoints = InjectsStaticAndNonStatic.class)
-  public static class InjectorB {
-    @Inject InjectorB() {
-    }
-  }
-
   public static class InjectsStaticAndNonStatic {
     @Inject Integer nonStaticField;
     @Inject static String staticField;
   }
 
+  @Test public void injectStatics() {
+    @Module(staticInjections = InjectsOneField.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "static";
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    assertThat(InjectsOneField.staticField).isNull();
+    graph.injectStatics();
+    assertThat(InjectsOneField.staticField).isEqualTo("static");
+  }
+
   @Test public void instanceFieldsNotInjectedByInjectStatics() {
-    ObjectGraph graph = ObjectGraph.get(new InjectorB(), new Object() {
+    @Module(
+        staticInjections = InjectsStaticAndNonStatic.class,
+        entryPoints = InjectsStaticAndNonStatic.class)
+    class TestModule {
       @Provides String provideString() {
         return "static";
       }
       @Provides Integer provideInteger() {
         throw new AssertionError();
       }
-    });
+    }
+
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
     assertThat(InjectsStaticAndNonStatic.staticField).isNull();
     graph.injectStatics();
     assertThat(InjectsStaticAndNonStatic.staticField).isEqualTo("static");
   }
 
   @Test public void staticFieldsNotInjectedByInjectMembers() {
-    ObjectGraph graph = ObjectGraph.get(new InjectorB(), new Object() {
+    @Module(
+        staticInjections = InjectsStaticAndNonStatic.class,
+        entryPoints = InjectsStaticAndNonStatic.class)
+    class TestModule {
       @Provides String provideString() {
         throw new AssertionError();
       }
       @Provides Integer provideInteger() {
         return 5;
       }
-    });
+    }
+
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
     assertThat(InjectsStaticAndNonStatic.staticField).isNull();
     InjectsStaticAndNonStatic object = new InjectsStaticAndNonStatic();
     graph.inject(object);
/Fim/
diff --git a/src/test/java/com/squareup/injector/InjectionTest.java b/src/test/java/com/squareup/injector/InjectionTest.java
index ce4b66d..ef9945f 100644
--- a/src/test/java/com/squareup/injector/InjectionTest.java
+++ b/src/test/java/com/squareup/injector/InjectionTest.java
@@ -16,8 +16,8 @@
  */
 package com.squareup.injector;
 
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicReference;
+import java.util.AbstractList;
+import java.util.RandomAccess;
 import javax.inject.Inject;
 import javax.inject.Named;
 import javax.inject.Provider;
@@ -29,24 +29,24 @@
 
 @SuppressWarnings("unused")
 public final class InjectionTest {
-
-  @Injector
-  public static class GInjector extends AbstractInjector<GInjector> {
-    @Inject Provider<G> gProvider;
-  }
-
   @Test public void basicInjection() {
-    GInjector gInjector = new GInjector().inject(new Object() {
+    class TestEntryPoint {
+      @Inject Provider<G> gProvider;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
       @Provides E provideE(F f) {
         return new E(f);
       }
-
       @Provides F provideF() {
         return new F();
       }
-    });
-    G g = gInjector.gProvider.get();
+    }
 
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    G g = entryPoint.gProvider.get();
     assertThat(g.a).isNotNull();
     assertThat(g.b).isNotNull();
     assertThat(g.c).isNotNull();
@@ -95,25 +95,43 @@
   }
 
   @Test public void providerInjection() {
-    AProviderInjector aProviderInjector = new AProviderInjector().inject();
-    assertThat(aProviderInjector.aProvider.get()).isNotNull();
-    assertThat(aProviderInjector.aProvider.get()).isNotNull();
-    assertThat(aProviderInjector.aProvider.get()).isNotSameAs(aProviderInjector.aProvider.get());
+    class TestEntryPoint {
+      @Inject Provider<A> aProvider;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides Object unused() {
+        throw new AssertionError();
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+
+    assertThat(entryPoint.aProvider.get()).isNotNull();
+    assertThat(entryPoint.aProvider.get()).isNotNull();
+    assertThat(entryPoint.aProvider.get()).isNotSameAs(entryPoint.aProvider.get());
   }
 
-  @Injector
-  public static class AProviderInjector extends AbstractInjector<AProviderInjector> {
-    @Inject Provider<A> aProvider;
-  }
 
   @Test public void singletons() {
-    FiInjector fiInjector = new FiInjector().inject(new Object() {
-      @Provides @Singleton F provideK() {
+    class TestEntryPoint {
+      @Inject Provider<F> fProvider;
+      @Inject Provider<I> iProvider;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides @Singleton F provideF() {
         return new F();
       }
-    });
-    assertThat(fiInjector.fProvider.get()).isSameAs(fiInjector.fProvider.get());
-    assertThat(fiInjector.iProvider.get()).isSameAs(fiInjector.iProvider.get());
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    assertThat(entryPoint.fProvider.get()).isSameAs(entryPoint.fProvider.get());
+    assertThat(entryPoint.iProvider.get()).isSameAs(entryPoint.iProvider.get());
   }
 
   @Singleton
@@ -121,60 +139,59 @@
     @Inject I() {}
   }
 
-  @Injector
-  public static class FiInjector extends AbstractInjector<FiInjector> {
-    @Inject Provider<F> fProvider;
-    @Inject Provider<I> iProvider;
-  }
-
   @Test public void bindingAnnotations() {
     final A one = new A();
     final A two = new A();
 
-    NamedInjector k = new NamedInjector().inject(new Object() {
+    class TestEntryPoint {
+      @Inject A a;
+      @Inject @Named("one") A aOne;
+      @Inject @Named("two") A aTwo;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
       @Provides @Named("one") A getOne() {
         return one;
       }
       @Provides @Named("two") A getTwo() {
         return two;
       }
-    });
+    }
 
-    assertThat(k.a).isNotNull();
-    assertThat(one).isSameAs(k.aOne);
-    assertThat(two).isSameAs(k.aTwo);
-  }
-
-  @Injector
-  public static class NamedInjector extends AbstractInjector<NamedInjector> {
-    @Inject A a;
-    @Inject @Named("one") A aOne;
-    @Inject @Named("two") A aTwo;
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    assertThat(entryPoint.a).isNotNull();
+    assertThat(one).isSameAs(entryPoint.aOne);
+    assertThat(two).isSameAs(entryPoint.aTwo);
   }
 
   @Test public void singletonBindingAnnotationAndProvider() {
-    final AtomicReference<A> a1 = new AtomicReference<A>();
-    final AtomicReference<A> a2 = new AtomicReference<A>();
+    class TestEntryPoint {
+      @Inject Provider<L> lProvider;
+    }
 
-    LInjector lInjector = new LInjector().inject(new Object() {
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      A a1;
+      A a2;
+
       @Provides @Singleton @Named("one") F provideF(Provider<A> aProvider) {
-        a1.set(aProvider.get());
-        a2.set(aProvider.get());
+        a1 = aProvider.get();
+        a2 = aProvider.get();
         return new F();
       }
-    });
-    lInjector.lProvider.get();
+    }
 
-    assertThat(a1.get()).isNotNull();
-    assertThat(a2.get()).isNotNull();
-    assertThat(a1.get()).isNotSameAs(a2.get());
-    L l = lInjector.lProvider.get();
-    assertThat(l).isSameAs(l.lProvider.get());
-  }
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    TestModule module = new TestModule();
+    ObjectGraph.get(module).inject(entryPoint);
+    entryPoint.lProvider.get();
 
-  @Injector
-  public static class LInjector extends AbstractInjector<LInjector> {
-    @Inject Provider<L> lProvider;
+    assertThat(module.a1).isNotNull();
+    assertThat(module.a2).isNotNull();
+    assertThat(module.a1).isNotSameAs(module.a2);
+    assertThat(entryPoint.lProvider.get()).isSameAs(entryPoint.lProvider.get());
   }
 
   @Singleton
@@ -184,27 +201,30 @@
   }
 
   @Test public void singletonInGraph() {
-    MultipleInjector multipleInjector = new MultipleInjector().inject(new Object() {
+    class TestEntryPoint {
+      @Inject N n1;
+      @Inject N n2;
+      @Inject F f1;
+      @Inject F f2;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
       @Provides @Singleton F provideF() {
         return new F();
       }
-    });
+    }
 
-    assertThat(multipleInjector.f1).isSameAs(multipleInjector.f2);
-    assertThat(multipleInjector.f1).isSameAs(multipleInjector.n1.f1);
-    assertThat(multipleInjector.f1).isSameAs(multipleInjector.n1.f2);
-    assertThat(multipleInjector.f1).isSameAs(multipleInjector.n2.f1);
-    assertThat(multipleInjector.f1).isSameAs(multipleInjector.n2.f2);
-    assertThat(multipleInjector.f1).isSameAs(multipleInjector.n1.fProvider.get());
-    assertThat(multipleInjector.f1).isSameAs(multipleInjector.n2.fProvider.get());
-  }
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
 
-  @Injector
-  public static class MultipleInjector extends AbstractInjector<MultipleInjector> {
-    @Inject N n1;
-    @Inject N n2;
-    @Inject F f1;
-    @Inject F f2;
+    assertThat(entryPoint.f1).isSameAs(entryPoint.f2);
+    assertThat(entryPoint.f1).isSameAs(entryPoint.n1.f1);
+    assertThat(entryPoint.f1).isSameAs(entryPoint.n1.f2);
+    assertThat(entryPoint.f1).isSameAs(entryPoint.n2.f1);
+    assertThat(entryPoint.f1).isSameAs(entryPoint.n2.f2);
+    assertThat(entryPoint.f1).isSameAs(entryPoint.n1.fProvider.get());
+    assertThat(entryPoint.f1).isSameAs(entryPoint.n2.fProvider.get());
   }
 
   public static class N {
@@ -214,30 +234,39 @@
   }
 
   @Test public void noJitBindingsForAnnotations() {
+    class TestEntryPoint {
+      @Inject @Named("a") A a;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides Object unused() {
+        throw new AssertionError();
+      }
+    }
+
     try {
-      new AnnotatedJitInjector().inject();
+      ObjectGraph.get(new TestModule());
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
 
-  @Injector
-  public static class AnnotatedJitInjector extends AbstractInjector<AnnotatedJitInjector> {
-    @Inject @Named("a") A a;
-  }
-
   @Test public void subclasses() {
-    QInjector qInjector = new QInjector().inject(new Object() {
+    class TestEntryPoint {
+      @Inject Q q;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
       @Provides F provideF() {
         return new F();
       }
-    });
-    assertThat(qInjector.q.f).isNotNull();
-  }
+    }
 
-  @Injector
-  public static class QInjector extends AbstractInjector<QInjector> {
-    @Inject Q q;
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    assertThat(entryPoint.q.f).isNotNull();
   }
 
   public static class P {
@@ -249,22 +278,31 @@
   }
 
   @Test public void singletonsAreNotEager() {
-    final AtomicBoolean sInjected = new AtomicBoolean();
+    class TestEntryPoint {
+      @Inject Provider<A> aProvider;
+    }
 
-    R.injected = false;
-    AProviderInjector aProviderInjector = new AProviderInjector().inject(new Object() {
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      boolean sInjected = false;
+
       @Provides F provideF(R r) {
         return new F();
       }
 
       @Provides @Singleton S provideS() {
-        sInjected.set(true);
+        sInjected = true;
         return new S();
       }
-    });
+    }
+
+    R.injected = false;
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    TestModule module = new TestModule();
+    ObjectGraph.get(module).inject(entryPoint);
 
     assertThat(R.injected).isFalse();
-    assertThat(sInjected.get()).isFalse();
+    assertThat(module.sInjected).isFalse();
   }
 
   @Singleton
@@ -278,92 +316,104 @@
   static class S {}
 
   @Test public void providerMethodsConflict() {
-    try {
-      new GInjector().inject(new Object() {
-        @Provides A provideA1() {
-          throw new AssertionError();
-        }
+    @Module
+    class TestModule {
+      @Provides A provideA1() {
+        throw new AssertionError();
+      }
+      @Provides A provideA2() {
+        throw new AssertionError();
+      }
+    }
 
-        @Provides A provideA2() {
-          throw new AssertionError();
-        }
-      });
+    try {
+      ObjectGraph.get(new TestModule());
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
 
   @Test public void singletonsInjectedOnlyIntoProviders() {
-    AProviderInjector h = new AProviderInjector().inject(new Object() {
+    class TestEntryPoint {
+      @Inject Provider<A> aProvider;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
       @Provides @Singleton A provideA() {
         return new A();
       }
-    });
-    assertThat(h.aProvider.get()).isSameAs(h.aProvider.get());
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    assertThat(entryPoint.aProvider.get()).isSameAs(entryPoint.aProvider.get());
   }
 
   @Test public void moduleOverrides() {
-    Object overrides = new Object() {
+    class TestEntryPoint {
+      @Inject Provider<E> eProvider;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class BaseModule {
+      @Provides F provideF() {
+        throw new AssertionError();
+      }
+      @Provides E provideE(F f) {
+        return new E(f);
+      }
+    }
+
+    @Module(overrides = true)
+    class OverridesModule {
       @Provides F provideF() {
         return new F();
       }
-    };
+    }
 
-    EProviderInjector injector = new EProviderInjector().inject(overrides);
-    E e = injector.eProvider.get();
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new BaseModule(), new OverridesModule()).inject(entryPoint);
+    E e = entryPoint.eProvider.get();
     assertThat(e).isNotNull();
     assertThat(e.f).isNotNull();
   }
 
-  @Injector(modules = { BaseModule.class })
-  public static class EProviderInjector extends AbstractInjector<EProviderInjector> {
-    @Inject Provider<E> eProvider;
-  }
-
-  static class BaseModule {
-    @Provides F provideF() {
-      throw new AssertionError();
+  @Test public void noJitBindingsForInterfaces() {
+    class TestEntryPoint {
+      @Inject RandomAccess randomAccess;
     }
-    @Provides E provideE(F f) {
-      return new E(f);
-    }
-  }
 
-  @Test public void manuallyCreatedModuleNoOverride() {
+    @Module(entryPoints = TestEntryPoint.class)
+    class BaseModule {
+      @Provides Object unused() {
+        throw new AssertionError();
+      }
+    }
+
     try {
-      new ManuallyCreatedModuleInjector().inject();
+      ObjectGraph.get(new BaseModule());
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
 
-  @Test public void manuallyCreatedModuleWithOverride() {
-    ManuallyCreatedModuleInjector module = new ManuallyCreatedModuleInjector()
-        .inject(new ManuallyCreatedModule("runtime argument"));
-    assertThat(module.string).isEqualTo("runtime argument");
-  }
-
-  @Injector(modules = { ManuallyCreatedModule.class })
-  public static class ManuallyCreatedModuleInjector
-      extends AbstractInjector<ManuallyCreatedModuleInjector> {
-    @Inject String string;
-  }
-
-  static class ManuallyCreatedModule {
-    final String string;
-    public ManuallyCreatedModule(String string) {
-      this.string = string;
+  @Test public void noJitBindingsForAbstractClasses() {
+    class TestEntryPoint {
+      @Inject AbstractList abstractList;
     }
-    @Provides String provideString() {
-      return string;
-    }
-  }
 
-  public static abstract class AbstractInjector<T> {
-    @SuppressWarnings("unchecked")
-    public T inject(Object... modules) {
-      ObjectGraph.get(this, modules).inject(this);
-      return (T) this;
+    @Module(entryPoints = TestEntryPoint.class)
+    class BaseModule {
+      @Provides Object unused() {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      ObjectGraph.get(new BaseModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
     }
   }
 }
/Fim/
diff --git a/src/test/java/com/squareup/injector/MembersInjectorTest.java b/src/test/java/com/squareup/injector/MembersInjectorTest.java
index 589fef3..8f357ce 100644
--- a/src/test/java/com/squareup/injector/MembersInjectorTest.java
+++ b/src/test/java/com/squareup/injector/MembersInjectorTest.java
@@ -30,9 +30,21 @@
 @SuppressWarnings("unused")
 public final class MembersInjectorTest {
   @Test public void injectMembers() {
-    InjectInjectable injector = new InjectInjectable().inject();
+    class TestEntryPoint {
+      @Inject MembersInjector<Injectable> membersInjector;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class StringModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new StringModule()).inject(entryPoint);
     Injectable injectable = new Injectable();
-    injector.membersInjector.injectMembers(injectable);
+    entryPoint.membersInjector.injectMembers(injectable);
     assertThat(injectable.injected).isEqualTo("injected");
   }
 
@@ -40,11 +52,6 @@
     @Inject String injected;
   }
 
-  @Injector(modules = StringModule.class)
-  static class InjectInjectable extends AbstractInjector<InjectInjectable> {
-    @Inject MembersInjector<Injectable> membersInjector;
-  }
-
   static class Unconstructable {
     final String constructor;
     @Inject String injected;
@@ -54,57 +61,81 @@
   }
 
   @Test public void membersInjectorOfUnconstructableIsOkay() {
-    UnconstructableMembersInjector injector = new UnconstructableMembersInjector().inject();
+    class TestEntryPoint {
+      @Inject MembersInjector<Unconstructable> membersInjector;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class StringModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new StringModule()).inject(entryPoint);
     Unconstructable object = new Unconstructable("constructor");
-    injector.membersInjector.injectMembers(object);
+    entryPoint.membersInjector.injectMembers(object);
     assertThat(object.constructor).isEqualTo("constructor");
     assertThat(object.injected).isEqualTo("injected");
   }
 
-  @Injector(modules = StringModule.class)
-  static class UnconstructableMembersInjector
-      extends AbstractInjector<UnconstructableMembersInjector> {
-    @Inject MembersInjector<Unconstructable> membersInjector;
-  }
 
   @Test public void injectionOfUnconstructableFails() {
-    try {
-      ObjectGraph.get(new UnconstructableInjector());
-      fail();
-    } catch (Exception expected) {
+    class TestEntryPoint {
+      @Inject Unconstructable unconstructable;
     }
-  }
 
-  @Injector(modules = StringModule.class)
-  static class UnconstructableInjector {
-    @Inject Unconstructable unconstructable;
-  }
-
-  @Test public void instanceInjectionOfMembersOnlyType() {
-    try {
-      ObjectGraph.get(new UnconstructableProviderInjector());
-      fail();
-    } catch (Exception expected) {
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides Object unused() {
+        throw new AssertionError();
+      }
     }
-  }
 
-  @Injector(modules = StringModule.class)
-  static class UnconstructableProviderInjector {
-    @Inject Provider<Unconstructable> provider;
-  }
-
-  @Test public void rejectUnconstructableSingleton() {
     try {
-      ObjectGraph.get(new UnconstructableSingletonInjector());
+      ObjectGraph.get(new TestModule());
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
 
-  @Injector(modules = StringModule.class)
-  static class UnconstructableSingletonInjector
-      extends AbstractInjector<UnconstructableSingletonInjector> {
-    @Inject MembersInjector<UnconstructableSingleton> membersInjector;
+  @Test public void instanceInjectionOfMembersOnlyType() {
+    class TestEntryPoint {
+      @Inject Provider<Unconstructable> provider;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides Object unused() {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      ObjectGraph.get(new TestModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void rejectUnconstructableSingleton() {
+    class TestEntryPoint {
+      @Inject MembersInjector<UnconstructableSingleton> membersInjector;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides Object unused() {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      ObjectGraph.get(new TestModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
   }
 
   @Singleton
@@ -120,43 +151,41 @@
     @Inject String injected;
   }
 
-  @Injector(modules = StringModule.class)
-  static class NonStaticInnerMembersInjector
-      extends AbstractInjector<NonStaticInnerMembersInjector> {
-    @Inject MembersInjector<NonStaticInner> membersInjector;
-  }
-
   @Test public void membersInjectorOfNonStaticInnerIsOkay() {
-    NonStaticInnerMembersInjector injector = new NonStaticInnerMembersInjector().inject();
+    class TestEntryPoint {
+      @Inject MembersInjector<NonStaticInner> membersInjector;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
     NonStaticInner nonStaticInner = new NonStaticInner();
-    injector.membersInjector.injectMembers(nonStaticInner);
+    entryPoint.membersInjector.injectMembers(nonStaticInner);
     assertThat(nonStaticInner.injected).isEqualTo("injected");
   }
 
-  @Injector(modules = StringModule.class)
-  static class NonStaticInnerInjector {
-    @Inject NonStaticInner nonStaticInner;
-  }
-
   @Test public void instanceInjectionOfNonStaticInnerFailsEarly() {
+    class TestEntryPoint {
+      @Inject NonStaticInner nonStaticInner;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides Object unused() {
+        throw new AssertionError();
+      }
+    }
+
     try {
-      ObjectGraph.get(new NonStaticInnerInjector());
+      ObjectGraph.get(new TestModule());
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
-
-  public static abstract class AbstractInjector<T> {
-    @SuppressWarnings("unchecked")
-    public T inject(Object... modules) {
-      ObjectGraph.get(this, modules).inject(this);
-      return (T) this;
-    }
-  }
-
-  static class StringModule {
-    @Provides String provideString() {
-      return "injected";
-    }
-  }
 }
\ No newline at end of file
/Fim/
diff --git a/src/main/java/com/squareup/injector/ObjectGraph.java b/src/main/java/com/squareup/injector/ObjectGraph.java
index 98acbc4..7a889f2 100644
--- a/src/main/java/com/squareup/injector/ObjectGraph.java
+++ b/src/main/java/com/squareup/injector/ObjectGraph.java
@@ -21,12 +21,10 @@
 import com.squareup.injector.internal.ProblemDetector;
 import com.squareup.injector.internal.StaticInjection;
 import java.util.ArrayList;
-import java.util.HashMap;
+import java.util.Collection;
 import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 
 /**
  * A graph of objects linked by their dependencies.
@@ -55,12 +53,15 @@
  * </ul>
  */
 public final class ObjectGraph {
-  private final List<StaticInjection> staticInjections;
-  private final Map<Class<?>, Binding<?>> bindings;
+  private final Linker linker;
+  private final Map<Class<?>, StaticInjection> staticInjections;
+  private final Map<Class<?>, Class<?>> entryPoints;
 
-  private ObjectGraph(List<StaticInjection> staticInjections, Map<Class<?>, Binding<?>> bindings) {
+  public ObjectGraph(Linker linker, Map<Class<?>, StaticInjection> staticInjections,
+      Map<Class<?>, Class<?>> entryPoints) {
+    this.linker = linker;
     this.staticInjections = staticInjections;
-    this.bindings = bindings;
+    this.entryPoints = entryPoints;
   }
 
   /**
@@ -72,8 +73,17 @@
    * #inject} to inject instance members when this method has returned.
    */
   public static ObjectGraph get(Object... modules) {
+    return get(false, modules);
+  }
+
+  public static ObjectGraph getLazy(Object... modules) {
+    return get(true, modules);
+  }
+
+  private static ObjectGraph get(boolean lazy, Object... modules) {
     Map<Class<?>, Class<?>> entryPoints = new LinkedHashMap<Class<?>, Class<?>>();
-    Set<Class<?>> staticInjectionClasses = new LinkedHashSet<Class<?>>();
+    Map<Class<?>, StaticInjection> staticInjections
+        = new LinkedHashMap<Class<?>, StaticInjection>();
 
     List<Object> baseModules = new ArrayList<Object>();
     List<Object> overrideModules = new ArrayList<Object>();
@@ -83,11 +93,11 @@
       if (annotation == null) {
         throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
       }
-      for (Class<?> entryPoint : annotation.entryPoints()) {
-        entryPoints.put(entryPoint, moduleClass);
+      for (Class<?> c : annotation.entryPoints()) {
+        entryPoints.put(c, moduleClass);
       }
-      for (Class<?> staticInjection : annotation.staticInjections()) {
-        staticInjectionClasses.add(staticInjection);
+      for (Class<?> c : annotation.staticInjections()) {
+        staticInjections.put(c, lazy ? null : StaticInjection.get(c));
       }
       if (annotation.overrides()) {
         overrideModules.add(module);
@@ -96,62 +106,49 @@
       }
     }
 
-    // Create static injections.
-    List<StaticInjection> staticInjections = new ArrayList<StaticInjection>();
-    for (Class<?> c : staticInjectionClasses) {
-      staticInjections.add(StaticInjection.get(c));
-    }
-
     // Create a linker and install all of the user's modules. Modules provided
     // at runtime may override modules provided in the @Module annotation.
     Linker linker = new Linker();
     linker.installModules(baseModules);
     linker.installModules(overrideModules);
 
-    // Request the bindings we'll need from the linker. This will cause the
-    // linker to link these bindings in the link step.
-    getEntryPointsMap(linker, entryPoints);
-    for (StaticInjection staticInjection : staticInjections) {
-      staticInjection.attach(linker);
+    ObjectGraph result = new ObjectGraph(linker, staticInjections, entryPoints);
+
+    // Link all bindings (unless this injector is lazy).
+    if (!lazy) {
+      result.linkStaticInjections();
+      result.linkEntryPoints();
+      linker.linkAll();
     }
 
-    // Fill out the graph, creating JIT bindings as necessary.
-    linker.link();
-
-    // Attach all necessary injections. Now that we've linked, all bindings will be available.
-    Map<Class<?>, Binding<?>> entryPointsMap =
-        getEntryPointsMap(linker, entryPoints);
-    for (StaticInjection staticInjection : staticInjections) {
-      staticInjection.attach(linker);
-    }
-
-    // Link success. Return a new linked dependency graph.
-    return new ObjectGraph(staticInjections, entryPointsMap);
+    return result;
   }
 
-  public void detectProblems() {
-    new ProblemDetector().detectProblems(bindings.values());
+  private void linkStaticInjections() {
+    for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
+      StaticInjection staticInjection = entry.getValue();
+      if (staticInjection == null) {
+        staticInjection = StaticInjection.get(entry.getKey());
+        entry.setValue(staticInjection);
+      }
+      staticInjection.attach(linker);
+    }
+  }
+
+  private void linkEntryPoints() {
+    for (Map.Entry<Class<?>, Class<?>> entry : entryPoints.entrySet()) {
+      linker.requestBinding(Keys.get(entry.getKey()), entry.getValue(), true);
+    }
   }
 
   /**
-   * Returns a map from class to entry point.
-   *
-   * <p>If executed before {@code link()}, this tells the linker which keys are
-   * required. Since the bindings haven't been linked, the returned map may
-   * contain null bindings and should not be used.
-   *
-   * <p>If executed after {@code link()}, the bindings will not be null and the
-   * map can be used.
+   * Do full graph problem detection.
    */
-  private static Map<Class<?>, Binding<?>> getEntryPointsMap(Linker linker,
-      Map<Class<?>, Class<?>> entryPoints) {
-    Map<Class<?>, Binding<?>> result = new HashMap<Class<?>, Binding<?>>();
-    for (Map.Entry<Class<?>, Class<?>> entry : entryPoints.entrySet()) {
-      Class<?> entryPoint = entry.getKey();
-      Class<?> moduleClass = entry.getValue();
-      result.put(entryPoint, linker.requestBinding(Keys.get(entryPoint), moduleClass, false));
-    }
-    return result;
+  public void detectProblems() {
+    linkStaticInjections();
+    linkEntryPoints();
+    Collection<Binding<?>> allBindings = linker.linkAll();
+    new ProblemDetector().detectProblems(allBindings);
   }
 
   /**
@@ -159,8 +156,17 @@
    * staticInjections} property.
    */
   public void injectStatics() {
-    for (StaticInjection staticInjection : staticInjections) {
-      staticInjection.inject();
+    // We call linkStaticInjections() twice on purpose. The first time through
+    // we request all of the bindings we need. The linker returns null for
+    // bindings it doesn't have. Then we ask the linker to link all of those
+    // requested bindings. Finally we call linkStaticInjections() again: this
+    // time the linker won't return null because everything has been linked.
+    linkStaticInjections();
+    linker.linkRequested();
+    linkStaticInjections();
+
+    for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
+      entry.getValue().inject();
     }
   }
 
@@ -171,13 +177,20 @@
    * @throws IllegalArgumentException if the runtime type of {@code instance} is
    *     not the injector's type or one of its entry point types.
    */
-  @SuppressWarnings("unchecked") // bindings is a typesafe heterogeneous container
+  @SuppressWarnings("unchecked") // the linker matches keys to bindings by their type
   public void inject(Object instance) {
-    Binding<Object> binding = (Binding<Object>) bindings.get(instance.getClass());
-    if (binding == null) {
-      throw new IllegalArgumentException("No binding for " + instance.getClass().getName() + ". "
+    Class<?> type = instance.getClass();
+    Class<?> moduleClass = entryPoints.get(type);
+    if (moduleClass == null) {
+      throw new IllegalArgumentException("No binding for " + type.getName() + ". "
           + "You must explicitly add it as an entry point.");
     }
-    binding.injectMembers(instance);
+    String key = Keys.get(type);
+    Binding<?> binding = linker.requestBinding(key, moduleClass, true);
+    if (binding == null || !binding.linked) {
+      linker.linkRequested();
+      binding = linker.requestBinding(key, moduleClass, true);
+    }
+    ((Binding<Object>) binding).injectMembers(instance);
   }
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Binding.java b/src/main/java/com/squareup/injector/internal/Binding.java
index fd766c8..799f820 100644
--- a/src/main/java/com/squareup/injector/internal/Binding.java
+++ b/src/main/java/com/squareup/injector/internal/Binding.java
@@ -27,6 +27,7 @@
   public final boolean singleton;
   public final boolean injectMembersOnly;
   public final Object requiredBy;
+  public boolean linked;
 
   protected Binding(String key, boolean singleton, boolean injectMembersOnly, Object requiredBy) {
     if (singleton && injectMembersOnly) {
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ConstructorBinding.java b/src/main/java/com/squareup/injector/internal/ConstructorBinding.java
index c186e30..6733408 100644
--- a/src/main/java/com/squareup/injector/internal/ConstructorBinding.java
+++ b/src/main/java/com/squareup/injector/internal/ConstructorBinding.java
@@ -120,7 +120,7 @@
     final List<Field> injectedFields = new ArrayList<Field>();
     for (Class<?> c = type; c != Object.class; c = c.getSuperclass()) {
       for (Field field : c.getDeclaredFields()) {
-        if (field.getAnnotation(Inject.class) == null || Modifier.isStatic(field.getModifiers())) {
+        if (!field.isAnnotationPresent(Inject.class) || Modifier.isStatic(field.getModifiers())) {
           continue;
         }
         field.setAccessible(true);
@@ -135,7 +135,7 @@
      */
     Constructor<T> injectedConstructor = null;
     for (Constructor<T> constructor : (Constructor<T>[]) type.getDeclaredConstructors()) {
-      if (constructor.getAnnotation(Inject.class) == null) {
+      if (!constructor.isAnnotationPresent(Inject.class)) {
         continue;
       }
       if (injectedConstructor != null) {
@@ -145,7 +145,8 @@
     }
     if (injectedConstructor == null) {
       if (injectedFields.isEmpty()) {
-        throw new IllegalArgumentException("No injectable constructor on " + type.getName());
+        throw new IllegalArgumentException("No injectable members on " + type.getName()
+            + ". Do you want to add an injectable constructor?");
       }
       try {
         injectedConstructor = type.getDeclaredConstructor();
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Linker.java b/src/main/java/com/squareup/injector/internal/Linker.java
index 67dc6a5..0f62f20 100644
--- a/src/main/java/com/squareup/injector/internal/Linker.java
+++ b/src/main/java/com/squareup/injector/internal/Linker.java
@@ -17,6 +17,7 @@
 
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
@@ -30,15 +31,15 @@
   private static final Object UNINITIALIZED = new Object();
 
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
-  private final Queue<Binding<?>> unattachedBindings = new LinkedList<Binding<?>>();
+  private final Queue<Binding<?>> toLink = new LinkedList<Binding<?>>();
 
   /** True unless calls to requestBinding() were unable to satisfy the binding. */
-  private boolean currentAttachSuccess = true;
+  private boolean attachSuccess = true;
 
   /** All errors encountered during injection. */
   private final List<String> errors = new ArrayList<String>();
 
-  /** All of the injector's bindings. */
+  /** All of the injector's bindings. This may contain unlinked bindings. */
   private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
 
   /**
@@ -53,30 +54,53 @@
   }
 
   /**
-   * Links the bindings in {@code bindings}, creating JIT bindings as necessary
-   * to fill in the gaps. When this returns all bindings and their dependencies
-   * will be attached.
+   * Links requested bindings and installed bindings, plus all of their
+   * transitive dependencies. This creates JIT bindings as necessary to fill in
+   * the gaps.
+   *
+   * @return all bindings known by this linker, which will all be linked.
    */
-  public void link() {
-    unattachedBindings.addAll(bindings.values());
+  public Collection<Binding<?>> linkAll() {
+    for (Binding<?> binding : bindings.values()) {
+      if (!binding.linked) {
+        toLink.add(binding);
+      }
+    }
+    linkRequested();
+    return bindings.values();
+  }
 
+  /**
+   * Links all requested bindings plus their transitive dependencies. This
+   * creates JIT bindings as necessary to fill in the gaps.
+   */
+  public void linkRequested() {
     Binding binding;
-    while ((binding = unattachedBindings.poll()) != null) {
+    while ((binding = toLink.poll()) != null) {
       if (binding instanceof DeferredBinding) {
-        if (getBinding(binding.key) != null) {
-          continue; // A binding for this key has already been promoted.
+        if (bindings.get(binding.key) != null) {
+          continue; // A binding for this key has since been linked.
         }
         try {
           Binding<?> jitBinding = createJitBinding((DeferredBinding<?>) binding);
           // Enqueue the JIT binding so its own dependencies can be linked.
-          unattachedBindings.add(jitBinding);
+          toLink.add(jitBinding);
           putBinding(jitBinding);
         } catch (Exception e) {
           addError(e.getMessage() + " required by " + binding.requiredBy);
           putBinding(new UnresolvedBinding<Object>(binding.requiredBy, binding.key));
         }
       } else {
-        attachBinding(binding);
+        // Attempt to attach the binding to its dependencies. If any dependency
+        // is not available, the attach will fail. We'll enqueue creation of
+        // that dependency and retry the attachment later.
+        attachSuccess = true;
+        binding.attach(this);
+        if (attachSuccess) {
+          binding.linked = true;
+        } else {
+          toLink.add(binding);
+        }
       }
     }
 
@@ -120,38 +144,30 @@
   }
 
   /**
-   * Attempts to attach {@code binding} to its dependencies. If any dependency
-   * is not available, the attach will fail. We'll enqueue creation of that
-   * dependency and retry the attachment later.
-   */
-  private void attachBinding(Binding binding) {
-    currentAttachSuccess = true;
-    binding.attach(this);
-    if (!currentAttachSuccess) {
-      unattachedBindings.add(binding);
-    }
-  }
-
-  /**
    * Returns the binding if it exists immediately. Otherwise this returns
-   * null. The injector will create that binding later and reattach the
-   * caller's binding.
+   * null. If the returned binding didn't exist or was unlinked, it will be
+   * enqueued to be linked.
    */
   public Binding<?> requestBinding(String key, Object requiredBy, boolean needMembersOnly) {
-    Binding<?> binding = getBinding(key);
+    Binding<?> binding = bindings.get(key);
     if (binding == null) {
       // We can't satisfy this binding. Make sure it'll work next time!
-      unattachedBindings.add(new DeferredBinding<Object>(requiredBy, key));
-      currentAttachSuccess = false;
-    } else if (!needMembersOnly && binding.injectMembersOnly) {
+      toLink.add(new DeferredBinding<Object>(requiredBy, key));
+      attachSuccess = false;
+      return null;
+    }
+
+    if (!binding.linked) {
+      toLink.add(binding); // This binding was never linked; link it now!
+    }
+
+    if (!needMembersOnly && binding.injectMembersOnly) {
       errors.add(requiredBy + " injects " + binding.key
           + ", but that type supports members injection only");
+      return null;
     }
-    return binding;
-  }
 
-  private Binding<?> getBinding(String key) {
-    return bindings.get(key);
+    return binding;
   }
 
   private <T> void putBinding(final Binding<T> binding) {
/Fim/
diff --git a/src/test/java/com/squareup/injector/LazyInjectionTest.java b/src/test/java/com/squareup/injector/LazyInjectionTest.java
new file mode 100644
index 0000000..6849247
--- /dev/null
+++ b/src/test/java/com/squareup/injector/LazyInjectionTest.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2012 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import javax.inject.Inject;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+public final class LazyInjectionTest {
+  @Test public void getLazyDoesNotCauseEntryPointsToBeLoaded() {
+    @Module(entryPoints = LazyEntryPoint.class)
+    class TestModule {
+      @Provides Object unused() {
+        throw new AssertionError();
+      }
+    }
+
+    ObjectGraph.getLazy(new TestModule());
+    assertThat(lazyEntryPointLoaded).isFalse();
+  }
+
+  private static boolean lazyEntryPointLoaded = false;
+  static class LazyEntryPoint {
+    static {
+      lazyEntryPointLoaded = true;
+    }
+  }
+
+  @Test public void getLazyDoesNotCauseProvidesParametersToBeLoaded() {
+    @Module
+    class TestModule {
+      @Provides Object provideObject(LazyProvidesParameter parameter) {
+        throw new AssertionError();
+      }
+    }
+
+    ObjectGraph.getLazy(new TestModule());
+    assertThat(lazyProvidesParameterLoaded).isFalse();
+  }
+
+  private static boolean lazyProvidesParameterLoaded = false;
+  static class LazyProvidesParameter {
+    static {
+      lazyProvidesParameterLoaded = true;
+    }
+  }
+
+  @Test public void getLazyDoesNotCauseProvidesResultToBeLoaded() {
+    @Module
+    class TestModule {
+      @Provides LazyProvidesResult provideLazy() {
+        throw new AssertionError();
+      }
+    }
+
+    ObjectGraph.getLazy(new TestModule());
+    assertThat(lazyProvidesResultLoaded).isFalse();
+  }
+
+  private static boolean lazyProvidesResultLoaded = false;
+  static class LazyProvidesResult {
+    static {
+      lazyProvidesResultLoaded = true;
+    }
+  }
+
+  @Test public void getLazyDoesNotCauseStaticsToBeLoaded() {
+    @Module(staticInjections = LazyInjectStatics.class)
+    class TestModule {
+      @Provides Object unused() {
+        throw new AssertionError();
+      }
+    }
+
+    ObjectGraph.getLazy(new TestModule());
+    assertThat(LazyInjectStaticsLoaded).isFalse();
+  }
+
+  private static boolean LazyInjectStaticsLoaded = false;
+  static class LazyInjectStatics {
+    static {
+      LazyInjectStaticsLoaded = true;
+    }
+  }
+
+  @Test public void lazyInjectionRequiresProvidesMethod() {
+    class TestEntryPoint {
+      @Inject String injected;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides String provideString(Integer integer) {
+        return integer.toString();
+      }
+      @Provides Integer provideInteger() {
+        return 5;
+      }
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.getLazy(new TestModule());
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    objectGraph.inject(entryPoint);
+    assertThat(entryPoint.injected).isEqualTo("5");
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Modules.java b/src/main/java/com/squareup/injector/internal/Modules.java
index bd18050..1db23af 100644
--- a/src/main/java/com/squareup/injector/internal/Modules.java
+++ b/src/main/java/com/squareup/injector/internal/Modules.java
@@ -52,19 +52,22 @@
    */
   private static void extractBindings(Object module, UniqueMap<String, Binding<?>> bindings) {
     // First look for a generated ModuleAdapter.
+    ModuleAdapter<Object> moduleAdapter = null;
     try {
       String adapter = module.getClass().getName() + "$ModuleAdapter";
       Class<?> c = Class.forName(adapter);
       Constructor<?> constructor = c.getConstructor();
       constructor.setAccessible(true);
-      @SuppressWarnings("unchecked") // We only generate matching module adapters.
-      ModuleAdapter<Object> moduleAdapter = (ModuleAdapter) constructor.newInstance();
-      moduleAdapter.getBindings(module, bindings);
-      return;
+      moduleAdapter = (ModuleAdapter) constructor.newInstance();
     } catch (Exception ignored) {
       // TODO: verbose log that code gen isn't enabled for this module
     }
 
+    if (moduleAdapter != null) {
+      moduleAdapter.getBindings(module, bindings);
+      return;
+    }
+
     // Fall back to runtime reflection.
     int count = 0;
     for (Class<?> c = module.getClass(); c != Object.class; c = c.getSuperclass()) {
@@ -95,6 +98,7 @@
     @Override public V put(K key, V value) {
       V clobbered = super.put(key, value);
       if (clobbered != null) {
+        super.put(key, clobbered); // Put things back as they were.
         throw new IllegalArgumentException("Duplicate:\n    " + clobbered + "\n    " + value);
       }
       return null;
/Fim/
diff --git a/src/main/java/com/squareup/codegen/InjectProcessor.java b/src/main/java/com/squareup/codegen/InjectProcessor.java
index 67df620..fee5070 100644
--- a/src/main/java/com/squareup/codegen/InjectProcessor.java
+++ b/src/main/java/com/squareup/codegen/InjectProcessor.java
@@ -154,6 +154,7 @@
     writer.addPackage(CodeGen.getPackage(type).getQualifiedName().toString());
     writer.addImport(Binding.class);
     writer.addImport(Linker.class);
+    writer.addImport(Set.class);
 
     writer.beginType(adapterName, "class", FINAL,
         CodeGen.parameterizedType(Binding.class, typeName));
@@ -247,6 +248,23 @@
     }
     writer.endMethod();
 
+    writer.annotation(Override.class);
+    String setOfBindings = CodeGen.parameterizedType(Set.class, "Binding<?>");
+    writer.beginMethod("void", "getDependencies", PUBLIC, setOfBindings, "getBindings",
+        setOfBindings, "injectMembersBindings");
+    if (constructor != null) {
+      for (int p = 0; p < constructor.getParameters().size(); p++) {
+        writer.statement("getBindings.add(%s)", constructorParameterName(p));
+      }
+    }
+    for (int f = 0; f < fields.size(); f++) {
+      writer.statement("injectMembersBindings.add(%s)", fieldName(f));
+    }
+    if (supertype != null) {
+      writer.statement("injectMembersBindings.add(%s)", "supertype");
+    }
+    writer.endMethod();
+
     writer.endType();
     writer.close();
   }
/Fim/
diff --git a/src/main/java/com/squareup/codegen/ProvidesProcessor.java b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
index c4e0e3d..e130b82 100644
--- a/src/main/java/com/squareup/codegen/ProvidesProcessor.java
+++ b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
@@ -213,6 +213,15 @@
     writer.statement("return module.%s(%s)", methodName, args.toString());
     writer.endMethod();
 
+    writer.annotation(Override.class);
+    String setOfBindings = CodeGen.parameterizedType(Set.class, "Binding<?>");
+    writer.beginMethod("void", "getDependencies", PUBLIC, setOfBindings, "getBindings",
+        setOfBindings, "injectMembersBindings");
+    for (int p = 0; p < parameters.size(); p++) {
+      writer.statement("getBindings.add(%s)", parameterName(p));
+    }
+    writer.endMethod();
+
     writer.endType();
   }
 
/Fim/
diff --git a/src/main/java/com/squareup/injector/ObjectGraph.java b/src/main/java/com/squareup/injector/ObjectGraph.java
index c652580..6979eed 100644
--- a/src/main/java/com/squareup/injector/ObjectGraph.java
+++ b/src/main/java/com/squareup/injector/ObjectGraph.java
@@ -34,14 +34,15 @@
  *   <li>Field injection. A class may have any number of field injections, and
  *       fields may be of any visibility. Static fields will be injected each
  *       time an instance is injected.
- *   <li>Constructor injection. A class may have a single {@code
- *       @Inject}-annotated constructor. Classes that have fields injected
- *       may omit the {@link @Inject} annotation if they have a public
+ *   <li>Constructor injection. A class may have a single
+ *       {@code @Inject}-annotated constructor. Classes that have fields
+ *       injected may omit the {@link @Inject} annotation if they have a public
  *       no-arguments constructor.
  *   <li>Injection of {@code @Provides} method parameters.
  *   <li>{@code @Provides} methods annotated {@code @Singleton}.
  *   <li>Constructor-injected classes annotated {@code @Singleton}.
  *   <li>Injection of {@link javax.inject.Provider}s.
+ *   <li>Injection of {@link MembersInjector}s.
  *   <li>Qualifier annotations on injected parameters and fields.
  *   <li>JSR 330 annotations.
  * </ul>
@@ -57,7 +58,7 @@
   private final Map<Class<?>, StaticInjection> staticInjections;
   private final Map<Class<?>, Class<?>> entryPoints;
 
-  public ObjectGraph(Linker linker, Map<Class<?>, StaticInjection> staticInjections,
+  private ObjectGraph(Linker linker, Map<Class<?>, StaticInjection> staticInjections,
       Map<Class<?>, Class<?>> entryPoints) {
     this.linker = linker;
     this.staticInjections = staticInjections;
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/AtInjectBinding.java b/src/main/java/com/squareup/injector/internal/AtInjectBinding.java
index 996a921..8a7818e 100644
--- a/src/main/java/com/squareup/injector/internal/AtInjectBinding.java
+++ b/src/main/java/com/squareup/injector/internal/AtInjectBinding.java
@@ -23,6 +23,7 @@
 import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 import javax.inject.Inject;
 import javax.inject.Singleton;
 
@@ -111,14 +112,18 @@
     }
   }
 
-  @Override public Binding<?>[] getDependencies() {
-    if (parameters == null) {
-      return fieldBindings;
+  @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+    if (parameters != null) {
+      for (Binding<?> binding : parameters) {
+        get.add(binding);
+      }
     }
-    Binding<?>[] result = new Binding<?>[parameters.length + fieldBindings.length];
-    System.arraycopy(parameters, 0, result, 0, parameters.length);
-    System.arraycopy(fieldBindings, 0, result, parameters.length, fieldBindings.length);
-    return result;
+    for (Binding<?> binding : fieldBindings) {
+      injectMembers.add(binding);
+    }
+    if (supertypeBinding != null) {
+      injectMembers.add(supertypeBinding);
+    }
   }
 
   @Override public String toString() {
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Binding.java b/src/main/java/com/squareup/injector/internal/Binding.java
index 0001752..f41c165 100644
--- a/src/main/java/com/squareup/injector/internal/Binding.java
+++ b/src/main/java/com/squareup/injector/internal/Binding.java
@@ -16,6 +16,7 @@
 package com.squareup.injector.internal;
 
 import com.squareup.injector.MembersInjector;
+import java.util.Set;
 import javax.inject.Provider;
 
 /**
@@ -61,8 +62,18 @@
     throw new UnsupportedOperationException(getClass().getName());
   }
 
-  // TODO: split up dependencies for get() and injectMembers().
-  public Binding<?>[] getDependencies() {
+  /**
+   * Populates {@code getBindings} and {@code injectMembersBindings} with the
+   * bindings used by this binding to satisfy {@link #get} and {@link
+   * #injectMembers} calls, respectively.
+   *
+   * @param getBindings the bindings required by this binding's {@code get}
+   *     method. Although {@code get} usually calls into {@code injectMembers},
+   *     this <i>does not</i> contain the injectMembers bindings.
+   * @param injectMembersBindings the bindings required by this binding's {@code
+   *     injectMembers} method.
+   */
+  public void getDependencies(Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
     throw new UnsupportedOperationException(getClass().getName());
   }
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/BuiltInBinding.java b/src/main/java/com/squareup/injector/internal/BuiltInBinding.java
index 7018014..2b089e1 100644
--- a/src/main/java/com/squareup/injector/internal/BuiltInBinding.java
+++ b/src/main/java/com/squareup/injector/internal/BuiltInBinding.java
@@ -15,6 +15,8 @@
  */
 package com.squareup.injector.internal;
 
+import java.util.Set;
+
 /**
  * Injects a Provider or a MembersInjector.
  */
@@ -43,4 +45,8 @@
   public Binding<?> getDelegate() {
     return delegate;
   }
+
+  @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+    // We don't add 'delegate' because it isn't actually used by get() or injectMembers().
+  }
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Linker.java b/src/main/java/com/squareup/injector/internal/Linker.java
index 641bbc9..be18cfa 100644
--- a/src/main/java/com/squareup/injector/internal/Linker.java
+++ b/src/main/java/com/squareup/injector/internal/Linker.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.injector.internal;
 
+import com.squareup.injector.ObjectGraph;
 import java.lang.reflect.Constructor;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -23,11 +24,15 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Queue;
+import java.util.Set;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 /**
  * Links bindings to their dependencies.
  */
 public final class Linker {
+  private static final Logger LOGGER = Logger.getLogger(ObjectGraph.class.getName());
   private static final Object UNINITIALIZED = new Object();
 
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
@@ -144,8 +149,9 @@
         Constructor<?> constructor = c.getConstructor();
         constructor.setAccessible(true);
         return (Binding<?>) constructor.newInstance();
-      } catch (Exception ignored) {
-        // TODO: verbose log that code gen isn't enabled for this class
+      } catch (Exception e) {
+        LOGGER.log(Level.FINE, "No generated inject adapter for " + className
+            + ". Falling back to reflection.", e);
       }
 
       // Handle class bindings by injecting @Inject-annotated members.
@@ -217,8 +223,8 @@
         }
         return (T) onlyInstance;
       }
-      @Override public Binding<?>[] getDependencies() {
-        return binding.getDependencies();
+      @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+        binding.getDependencies(get, injectMembers);
       }
       @Override public String toString() {
         return binding.toString();
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Modules.java b/src/main/java/com/squareup/injector/internal/Modules.java
index 1db23af..9e7dde3 100644
--- a/src/main/java/com/squareup/injector/internal/Modules.java
+++ b/src/main/java/com/squareup/injector/internal/Modules.java
@@ -15,11 +15,14 @@
  */
 package com.squareup.injector.internal;
 
+import com.squareup.injector.ObjectGraph;
 import com.squareup.injector.Provides;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 /**
  * Helper methods for dealing with collections of bindings. Any object whose
@@ -29,6 +32,8 @@
  * @author Jesse Wilson
  */
 final class Modules {
+  private static final Logger LOGGER = Logger.getLogger(ObjectGraph.class.getName());
+
   private Modules() {
   }
 
@@ -59,8 +64,9 @@
       Constructor<?> constructor = c.getConstructor();
       constructor.setAccessible(true);
       moduleAdapter = (ModuleAdapter) constructor.newInstance();
-    } catch (Exception ignored) {
-      // TODO: verbose log that code gen isn't enabled for this module
+    } catch (Exception e) {
+      LOGGER.log(Level.FINE, "No generated module for " + module.getClass().getName()
+          + ". Falling back to reflection.", e);
     }
 
     if (moduleAdapter != null) {
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ProblemDetector.java b/src/main/java/com/squareup/injector/internal/ProblemDetector.java
index f564e99..41127d9 100644
--- a/src/main/java/com/squareup/injector/internal/ProblemDetector.java
+++ b/src/main/java/com/squareup/injector/internal/ProblemDetector.java
@@ -17,6 +17,7 @@
 
 import java.util.Collection;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
@@ -26,8 +27,6 @@
  * Detects problems like cyclic dependencies.
  */
 public final class ProblemDetector {
-  // TODO: perform 2-phase injection to avoid some circular dependency problems
-
   Set<Binding<?>> done = new HashSet<Binding<?>>();
   Queue<Binding<?>> roots = new LinkedList<Binding<?>>();
   List<Binding<?>> path = new LinkedList<Binding<?>>();
@@ -70,7 +69,10 @@
 
     path.add(binding);
     try {
-      for (Binding<?> dependency : binding.getDependencies()) {
+      // TODO: perform 2-phase injection to avoid some circular dependency problems
+      Set<Binding<?>> dependencies = new LinkedHashSet<Binding<?>>();
+      binding.getDependencies(dependencies, dependencies);
+      for (Binding<?> dependency : dependencies) {
         if (dependency instanceof BuiltInBinding) {
           roots.add(((BuiltInBinding<?>) dependency).getDelegate());
         } else {
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java b/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
index 21c3210..f475269 100644
--- a/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
+++ b/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
@@ -19,6 +19,7 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
+import java.util.Set;
 import javax.inject.Singleton;
 
 /**
@@ -61,8 +62,10 @@
     }
   }
 
-  @Override public Binding<?>[] getDependencies() {
-    return parameters;
+  @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+    for (Binding binding : parameters) {
+      get.add(binding);
+    }
   }
 
   @Override public String toString() {
/Fim/
diff --git a/src/test/java/com/squareup/injector/InjectionTest.java b/src/test/java/com/squareup/injector/InjectionTest.java
index cce6905..82cb783 100644
--- a/src/test/java/com/squareup/injector/InjectionTest.java
+++ b/src/test/java/com/squareup/injector/InjectionTest.java
@@ -17,6 +17,8 @@
 package com.squareup.injector;
 
 import java.util.AbstractList;
+import java.util.Arrays;
+import java.util.List;
 import java.util.RandomAccess;
 import javax.inject.Inject;
 import javax.inject.Named;
@@ -448,7 +450,62 @@
     assertThat(entryPoint.extendsParameterizedType.string).isEqualTo("injected");
   }
 
-  // TODO: test injecting parameterized types
-  // TODO: test injecting wildcard types
-  // TODO: test constructor binding for a class that has a type parameter
+  @Test public void injectParameterizedType() {
+    class TestEntryPoint {
+      @Inject List<String> listOfStrings;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides List<String> provideList() {
+        return Arrays.asList("a", "b");
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    assertThat(entryPoint.listOfStrings).isEqualTo(Arrays.asList("a", "b"));
+  }
+
+  @Test public void injectWilcardType() {
+    class TestEntryPoint {
+      @Inject List<? extends Number> listOfNumbers;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides List<? extends Number> provideList() {
+        return Arrays.asList(1, 2);
+      }
+    }
+
+    try {
+      ObjectGraph.get(new TestModule());
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  @Test public void noConstructorInjectionsForClassesWithTypeParameters() {
+    class Parameterized<T> {
+      @Inject String string;
+    }
+
+    class TestEntryPoint {
+      @Inject Parameterized<Long> parameterized;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    try {
+      ObjectGraph.get(new TestModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Modules.java b/src/main/java/com/squareup/injector/internal/Modules.java
index 9e7dde3..104a82d 100644
--- a/src/main/java/com/squareup/injector/internal/Modules.java
+++ b/src/main/java/com/squareup/injector/internal/Modules.java
@@ -75,21 +75,16 @@
     }
 
     // Fall back to runtime reflection.
-    int count = 0;
     for (Class<?> c = module.getClass(); c != Object.class; c = c.getSuperclass()) {
       for (Method method : c.getDeclaredMethods()) {
         if (!method.isAnnotationPresent(Provides.class)
             && !method.isAnnotationPresent(com.google.inject.Provides.class)) {
           continue;
         }
-        count++;
         Binding<?> binding = methodToBinding(module, method);
         bindings.put(binding.provideKey, binding);
       }
     }
-    if (count == 0) {
-      throw new IllegalArgumentException("No @Provides methods on " + module);
-    }
   }
 
   private static <T> Binding<T> methodToBinding(Object module, Method method) {
/Fim/
diff --git a/src/test/java/com/squareup/injector/InjectionTest.java b/src/test/java/com/squareup/injector/InjectionTest.java
index 82cb783..379f8e2 100644
--- a/src/test/java/com/squareup/injector/InjectionTest.java
+++ b/src/test/java/com/squareup/injector/InjectionTest.java
@@ -103,9 +103,6 @@
 
     @Module(entryPoints = TestEntryPoint.class)
     class TestModule {
-      @Provides Object unused() {
-        throw new AssertionError();
-      }
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
@@ -242,9 +239,6 @@
 
     @Module(entryPoints = TestEntryPoint.class)
     class TestModule {
-      @Provides Object unused() {
-        throw new AssertionError();
-      }
     }
 
     try {
@@ -388,9 +382,6 @@
 
     @Module(entryPoints = TestEntryPoint.class)
     class TestModule {
-      @Provides Object unused() {
-        throw new AssertionError();
-      }
     }
 
     try {
@@ -407,9 +398,6 @@
 
     @Module(entryPoints = TestEntryPoint.class)
     class TestModule {
-      @Provides Object unused() {
-        throw new AssertionError();
-      }
     }
 
     try {
@@ -508,4 +496,12 @@
     } catch (IllegalArgumentException expected) {
     }
   }
+
+  @Test public void moduleWithNoProvidesMethods() {
+    @Module
+    class TestModule {
+    }
+
+    ObjectGraph.get(new TestModule());
+  }
 }
/Fim/
diff --git a/src/test/java/com/squareup/injector/LazyInjectionTest.java b/src/test/java/com/squareup/injector/LazyInjectionTest.java
index 6849247..430acbd 100644
--- a/src/test/java/com/squareup/injector/LazyInjectionTest.java
+++ b/src/test/java/com/squareup/injector/LazyInjectionTest.java
@@ -24,9 +24,6 @@
   @Test public void getLazyDoesNotCauseEntryPointsToBeLoaded() {
     @Module(entryPoints = LazyEntryPoint.class)
     class TestModule {
-      @Provides Object unused() {
-        throw new AssertionError();
-      }
     }
 
     ObjectGraph.getLazy(new TestModule());
@@ -81,9 +78,6 @@
   @Test public void getLazyDoesNotCauseStaticsToBeLoaded() {
     @Module(staticInjections = LazyInjectStatics.class)
     class TestModule {
-      @Provides Object unused() {
-        throw new AssertionError();
-      }
     }
 
     ObjectGraph.getLazy(new TestModule());
/Fim/
diff --git a/src/test/java/com/squareup/injector/MembersInjectorTest.java b/src/test/java/com/squareup/injector/MembersInjectorTest.java
index 9e0df2f..962cfcc 100644
--- a/src/test/java/com/squareup/injector/MembersInjectorTest.java
+++ b/src/test/java/com/squareup/injector/MembersInjectorTest.java
@@ -88,9 +88,6 @@
 
     @Module(entryPoints = TestEntryPoint.class)
     class TestModule {
-      @Provides Object unused() {
-        throw new AssertionError();
-      }
     }
 
     try {
@@ -107,9 +104,6 @@
 
     @Module(entryPoints = TestEntryPoint.class)
     class TestModule {
-      @Provides Object unused() {
-        throw new AssertionError();
-      }
     }
 
     try {
@@ -126,9 +120,6 @@
 
     @Module(entryPoints = TestEntryPoint.class)
     class TestModule {
-      @Provides Object unused() {
-        throw new AssertionError();
-      }
     }
 
     try {
@@ -177,9 +168,6 @@
 
     @Module(entryPoints = TestEntryPoint.class)
     class TestModule {
-      @Provides Object unused() {
-        throw new AssertionError();
-      }
     }
 
     try {
/Fim/
diff --git a/src/test/java/com/squareup/injector/ProblemDetectorTest.java b/src/test/java/com/squareup/injector/ProblemDetectorTest.java
index def029e..55a1b7b 100644
--- a/src/test/java/com/squareup/injector/ProblemDetectorTest.java
+++ b/src/test/java/com/squareup/injector/ProblemDetectorTest.java
@@ -28,9 +28,6 @@
 
     @Module(entryPoints = TestEntryPoint.class)
     class TestModule {
-      @Provides Object unused() {
-        throw new AssertionError();
-      }
     }
 
     ObjectGraph graph = ObjectGraph.get(new TestModule());
/Fim/
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..133735f
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,22 @@
+.classpath
+.project
+.settings
+eclipsebin
+
+bin
+gen
+build
+out
+lib
+
+target
+pom.xml.*
+release.properties
+
+.idea
+*.iml
+classes
+
+obj
+
+.DS_Store
/Fim/
diff --git a/LICENSE.txt b/LICENSE.txt
new file mode 100644
index 0000000..d645695
--- /dev/null
+++ b/LICENSE.txt
@@ -0,0 +1,202 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
/Fim/
diff --git a/README.md b/README.md
index e69de29..3ef0375 100644
--- a/README.md
+++ b/README.md
@@ -0,0 +1,21 @@
+Square Injector
+===============
+
+A JSR-330 dependency injector for Android and Java.
+
+License
+=======
+
+    Copyright 2012 Square, Inc.
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
/Fim/
diff --git a/TODO b/TODO
new file mode 100644
index 0000000..1dc1d07
--- /dev/null
+++ b/TODO
@@ -0,0 +1,5 @@
+Injector todos...
+
+Circular dependency errors
+Make singletons thread-safe
+
/Fim/
diff --git a/checkstyle.xml b/checkstyle.xml
new file mode 100644
index 0000000..79e74e8
--- /dev/null
+++ b/checkstyle.xml
@@ -0,0 +1,120 @@
+<?xml version="1.0"?>
+<!DOCTYPE module PUBLIC
+    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
+    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
+
+<module name="Checker">
+    <!--module name="NewlineAtEndOfFile"/-->
+    <module name="FileLength"/>
+    <module name="FileTabCharacter"/>
+
+    <!-- Trailing spaces -->
+    <module name="RegexpSingleline">
+        <property name="format" value="\s+$"/>
+        <property name="message" value="Line has trailing spaces."/>
+    </module>
+
+    <module name="TreeWalker">
+        <property name="cacheFile" value="${checkstyle.cache.file}"/>
+
+        <!-- Checks for Javadoc comments.                     -->
+        <!-- See http://checkstyle.sf.net/config_javadoc.html -->
+        <!--module name="JavadocMethod"/-->
+        <!--module name="JavadocType"/-->
+        <!--module name="JavadocVariable"/-->
+        <!--module name="JavadocStyle"/-->
+
+
+        <!-- Checks for Naming Conventions.                  -->
+        <!-- See http://checkstyle.sf.net/config_naming.html -->
+        <module name="ConstantName"/>
+        <module name="LocalFinalVariableName"/>
+        <module name="LocalVariableName"/>
+        <module name="MemberName"/>
+        <module name="MethodName"/>
+        <module name="PackageName"/>
+        <module name="ParameterName"/>
+        <module name="StaticVariableName"/>
+        <module name="TypeName"/>
+
+
+        <!-- Checks for imports                              -->
+        <!-- See http://checkstyle.sf.net/config_import.html -->
+        <module name="AvoidStarImport"/>
+        <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
+        <module name="RedundantImport"/>
+        <module name="UnusedImports"/>
+
+
+        <!-- Checks for Size Violations.                    -->
+        <!-- See http://checkstyle.sf.net/config_sizes.html -->
+        <module name="LineLength">
+            <property name="max" value="120"/>
+        </module>
+        <!--module name="MethodLength"/-->
+        <!--module name="ParameterNumber"/-->
+
+
+        <!-- Checks for whitespace                               -->
+        <!-- See http://checkstyle.sf.net/config_whitespace.html -->
+        <module name="GenericWhitespace"/>
+        <!--<module name="EmptyForIteratorPad"/>-->
+        <module name="MethodParamPad"/>
+        <module name="NoWhitespaceAfter"/>
+        <module name="NoWhitespaceBefore"/>
+        <module name="OperatorWrap"/>
+        <module name="ParenPad"/>
+        <!--module name="TypecastParenPad"/-->
+        <module name="WhitespaceAfter"/>
+        <module name="WhitespaceAround"/>
+
+
+        <!-- Modifier Checks                                    -->
+        <!-- See http://checkstyle.sf.net/config_modifiers.html -->
+        <!--module name="ModifierOrder"/-->
+        <module name="RedundantModifier"/>
+
+
+        <!-- Checks for blocks. You know, those {}'s         -->
+        <!-- See http://checkstyle.sf.net/config_blocks.html -->
+        <!--module name="AvoidNestedBlocks"/-->
+        <!--module name="EmptyBlock"/-->
+        <module name="LeftCurly"/>
+        <!--module name="NeedBraces"/-->
+        <module name="RightCurly"/>
+
+
+        <!-- Checks for common coding problems               -->
+        <!-- See http://checkstyle.sf.net/config_coding.html -->
+        <!--module name="AvoidInlineConditionals"/-->
+        <module name="CovariantEquals"/>
+        <module name="DoubleCheckedLocking"/>
+        <module name="EmptyStatement"/>
+        <module name="EqualsAvoidNull"/>
+        <module name="EqualsHashCode"/>
+        <!--module name="HiddenField"/-->
+        <module name="IllegalInstantiation"/>
+        <!--<module name="InnerAssignment"/>-->
+        <!--module name="MagicNumber"/-->
+        <module name="MissingSwitchDefault"/>
+        <module name="RedundantThrows"/>
+        <module name="SimplifyBooleanExpression"/>
+        <module name="SimplifyBooleanReturn"/>
+
+        <!-- Checks for class design                         -->
+        <!-- See http://checkstyle.sf.net/config_design.html -->
+        <!--module name="DesignForExtension"/-->
+        <!--module name="FinalClass"/-->
+        <!--module name="HideUtilityClassConstructor"/-->
+        <!--module name="InterfaceIsType"/-->
+        <!--module name="VisibilityModifier"/-->
+
+
+        <!-- Miscellaneous other checks.                   -->
+        <!-- See http://checkstyle.sf.net/config_misc.html -->
+        <!--module name="ArrayTypeStyle"/-->
+        <!--module name="FinalParameters"/-->
+        <!--module name="TodoComment"/-->
+        <module name="UpperEll"/>
+    </module>
+</module>
/Fim/
diff --git a/pom.xml b/pom.xml
new file mode 100644
index 0000000..4af38b8
--- /dev/null
+++ b/pom.xml
@@ -0,0 +1,119 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2012 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <groupId>com.squareup</groupId>
+    <artifactId>injector</artifactId>
+    <version>1.0-SNAPSHOT</version>
+    <packaging>jar</packaging>
+
+    <name>Injector</name>
+    <description>A JSR-330 dependency injector.</description>
+    <url>http://git.squareup.com/square/injector/</url>
+
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+
+        <!-- Compilation -->
+        <java.version>1.6</java.version>
+
+        <!-- Test Dependencies -->
+        <junit.version>4.10</junit.version>
+        <fest.version>1.4</fest.version>
+        <javax.inject.version>1</javax.inject.version>
+    </properties>
+
+    <scm>
+        <url>http://git.squareup.com/square/injector/</url>
+        <connection>scm:git:git://git.squareup.com/square/injector.git</connection>
+        <developerConnection>scm:git:ssh://git@git.squareup.com/square/injector.git</developerConnection>
+    </scm>
+
+    <issueManagement>
+        <system>GitHub Issues</system>
+        <url>http://git.squareup.com/square/injector/issues</url>
+    </issueManagement>
+
+    <licenses>
+        <license>
+            <name>Apache 2.0</name>
+            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+        </license>
+    </licenses>
+
+    <organization>
+        <name>Square, Inc.</name>
+        <url>http://squareup.com</url>
+    </organization>
+
+    <dependencies>
+        <dependency>
+            <groupId>javax.inject</groupId>
+            <artifactId>javax.inject</artifactId>
+            <version>${javax.inject.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <version>${junit.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.easytesting</groupId>
+            <artifactId>fest-assert</artifactId>
+            <version>${fest.version}</version>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <finalName>square-${project.artifactId}-${project.version}</finalName>
+
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <version>2.5</version>
+                <configuration>
+                    <source>${java.version}</source>
+                    <target>${java.version}</target>
+                    <compilerArgument>-proc:none</compilerArgument>
+                </configuration>
+            </plugin>
+
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-checkstyle-plugin</artifactId>
+                <version>2.9.1</version>
+                <configuration>
+                    <failsOnError>true</failsOnError>
+                    <configLocation>checkstyle.xml</configLocation>
+                </configuration>
+                <executions>
+                    <execution>
+                        <phase>verify</phase>
+                        <goals>
+                            <goal>checkstyle</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+        </plugins>
+    </build>
+</project>
/Fim/
diff --git a/src/main/java/com/squareup/codegen/CodeGen.java b/src/main/java/com/squareup/codegen/CodeGen.java
new file mode 100644
index 0000000..bcdad2b
--- /dev/null
+++ b/src/main/java/com/squareup/codegen/CodeGen.java
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.codegen;
+
+import com.squareup.injector.internal.Keys;
+import java.lang.reflect.Method;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
+import javax.lang.model.util.SimpleAnnotationValueVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+/**
+ * Support for annotation processors.
+ */
+final class CodeGen {
+  private CodeGen() {
+  }
+
+  public static PackageElement getPackage(Element type) {
+    while (type.getKind() != ElementKind.PACKAGE) {
+      type = type.getEnclosingElement();
+    }
+    return (PackageElement) type;
+  }
+
+  /**
+   * Returns the supertype, or {@code null} if the supertype is a platform
+   * class. This is intended for annotation processors that assume platform
+   * classes will never be annotated with application annotations.
+   */
+  public static TypeMirror getApplicationSupertype(TypeElement type) {
+    TypeMirror supertype = type.getSuperclass();
+    return Keys.isPlatformType(supertype.toString()) ? null : supertype;
+  }
+
+  /** Returns a fully qualified class name to complement {@code type}. */
+  public static String adapterName(TypeElement typeElement, String suffix) {
+    StringBuilder builder = new StringBuilder();
+    rawTypeToString(builder, typeElement, '$');
+    builder.append(suffix);
+    return builder.toString();
+  }
+
+  /** Returns a string like {@code java.util.List<java.lang.String>}. */
+  public static String parameterizedType(Class<?> raw, String... parameters) {
+    StringBuilder result = new StringBuilder();
+    result.append(raw.getName());
+    result.append("<");
+    for (int i = 0; i < parameters.length; i++) {
+      if (i != 0) {
+        result.append(", ");
+      }
+      result.append(parameters[i]);
+    }
+    result.append(">");
+    return result.toString();
+  }
+
+  /** Returns a string for {@code type}. Primitive types are always boxed. */
+  public static String typeToString(TypeMirror type) {
+    StringBuilder result = new StringBuilder();
+    typeToString(type, result, '.');
+    return result.toString();
+  }
+
+  /** Returns a string for the raw type of {@code type}. Primitive types are always boxed. */
+  public static String rawTypeToString(TypeMirror type, char innerClassSeparator) {
+    if (!(type instanceof DeclaredType)) {
+      throw new IllegalArgumentException("Unexpected type: " + type);
+    }
+    StringBuilder result = new StringBuilder();
+    DeclaredType declaredType = (DeclaredType) type;
+    rawTypeToString(result, (TypeElement) declaredType.asElement(), innerClassSeparator);
+    return result.toString();
+  }
+
+  /**
+   * Appends a string for {@code type} to {@code result}. Primitive types are
+   * always boxed.
+   *
+   * @param innerClassSeparator either '.' or '$', which will appear in a
+   *     class name like "java.lang.Map.Entry" or "java.lang.Map$Entry".
+   *     Use '.' for references to existing types in code. Use '$' to define new
+   *     class names and for strings that will be used by runtime reflection.
+   */
+  public static void typeToString(final TypeMirror type, final StringBuilder result,
+      final char innerClassSeparator) {
+    type.accept(new SimpleTypeVisitor6<Void, Void>() {
+      @Override public Void visitDeclared(DeclaredType declaredType, Void v) {
+        TypeElement typeElement = (TypeElement) declaredType.asElement();
+        rawTypeToString(result, typeElement, innerClassSeparator);
+        List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+        if (!typeArguments.isEmpty()) {
+          result.append("<");
+          for (int i = 0; i < typeArguments.size(); i++) {
+            if (i != 0) {
+              result.append(", ");
+            }
+            typeToString(typeArguments.get(i), result, innerClassSeparator);
+          }
+          result.append(">");
+        }
+        return null;
+      }
+      @Override public Void visitPrimitive(PrimitiveType primitiveType, Void aVoid) {
+        result.append(box((PrimitiveType) type).getName());
+        return null;
+      }
+      @Override public Void visitArray(ArrayType arrayType, Void aVoid) {
+        typeToString(arrayType.getComponentType(), result, innerClassSeparator);
+        result.append("[]");
+        return null;
+      }
+      @Override public Void visitTypeVariable(TypeVariable typeVariable, Void v) {
+        return null;
+      }
+      @Override protected Void defaultAction(TypeMirror typeMirror, Void aVoid) {
+        throw new UnsupportedOperationException("Unexpected type " + typeMirror);
+      }
+    }, null);
+  }
+
+  private static final AnnotationValueVisitor<Object, Void> VALUE_EXTRACTOR
+      = new SimpleAnnotationValueVisitor6<Object, Void>() {
+    @Override protected Object defaultAction(Object o, Void v) {
+      return o;
+    }
+    @Override public Object visitArray(List<? extends AnnotationValue> values, Void v) {
+      Object[] result = new Object[values.size()];
+      for (int i = 0; i < values.size(); i++) {
+        result[i] = values.get(i).accept(this, null);
+      }
+      return result;
+    }
+  };
+
+  /**
+   * Returns the annotation on {@code element} formatted as a Map. This returns
+   * a Map rather than an instance of the annotation interface to work-around
+   * the fact that Class and Class[] fields won't work at code generation time.
+   * See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5089128
+   */
+  public static Map<String, Object> getAnnotation(Class<?> annotationType, Element element) {
+    for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
+      if (!annotation.getAnnotationType().toString().equals(annotationType.getName())) {
+        continue;
+      }
+
+      Map<String, Object> result = new LinkedHashMap<String, Object>();
+      for (Method m : annotationType.getMethods()) {
+        result.put(m.getName(), m.getDefaultValue());
+      }
+      for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> e
+          : annotation.getElementValues().entrySet()) {
+        String name = e.getKey().getSimpleName().toString();
+        Object value = e.getValue().accept(VALUE_EXTRACTOR, null);
+        result.put(name, value);
+      }
+      return result;
+    }
+
+    return null; // Annotation not found.
+  }
+
+  static void rawTypeToString(StringBuilder result, TypeElement type,
+      char innerClassSeparator) {
+    String packageName = getPackage(type).getQualifiedName().toString();
+    String qualifiedName = type.getQualifiedName().toString();
+    result.append(packageName);
+    result.append('.');
+    result.append(
+        qualifiedName.substring(packageName.length() + 1).replace('.', innerClassSeparator));
+  }
+
+  private static Class<?> box(PrimitiveType primitiveType) {
+    switch (primitiveType.getKind()) {
+      case BYTE:
+        return Byte.class;
+      case SHORT:
+        return Short.class;
+      case INT:
+        return Integer.class;
+      case LONG:
+        return Long.class;
+      case FLOAT:
+        return Float.class;
+      case DOUBLE:
+        return Double.class;
+      case BOOLEAN:
+        return Boolean.class;
+      case CHAR:
+        return Character.class;
+      case VOID:
+        return Void.class;
+      default:
+        throw new AssertionError();
+    }
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/codegen/GeneratorKeys.java b/src/main/java/com/squareup/codegen/GeneratorKeys.java
new file mode 100644
index 0000000..3293299
--- /dev/null
+++ b/src/main/java/com/squareup/codegen/GeneratorKeys.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.codegen;
+
+import java.util.List;
+import java.util.Map;
+import javax.inject.Qualifier;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Creates keys using javac's mirror APIs. Unlike {@code Keys}, this class uses
+ * APIs not available on Android.
+ */
+final class GeneratorKeys {
+  private GeneratorKeys() {
+  }
+
+  /**
+   * Returns the members injector key for the raw type of {@code type}.
+   * Parameterized types are not currently supported for members injection in
+   * generated code.
+   */
+  public static String rawMembersKey(TypeMirror type) {
+    return "members/" + CodeGen.rawTypeToString(type, '$');
+  }
+
+  /** Returns the provider key for {@code type}. */
+  public static String get(TypeMirror type) {
+    StringBuilder result = new StringBuilder();
+    CodeGen.typeToString(type, result, '$');
+    return result.toString();
+  }
+
+  /** Returns the provided key for {@code method}. */
+  public static String get(ExecutableElement method) {
+    StringBuilder result = new StringBuilder();
+    AnnotationMirror qualifier = getQualifier(method.getAnnotationMirrors(), method);
+    if (qualifier != null) {
+      qualifierToString(qualifier, result);
+    }
+    CodeGen.typeToString(method.getReturnType(), result, '$');
+    return result.toString();
+  }
+
+  /** Returns the provider key for {@code parameter}. */
+  public static String get(VariableElement parameter) {
+    StringBuilder result = new StringBuilder();
+    AnnotationMirror qualifier = getQualifier(parameter.getAnnotationMirrors(), parameter);
+    if (qualifier != null) {
+      qualifierToString(qualifier, result);
+    }
+    CodeGen.typeToString(parameter.asType(), result, '$');
+    return result.toString();
+  }
+
+  private static void qualifierToString(AnnotationMirror qualifier, StringBuilder result) {
+    // TODO: guarantee that element values are sorted by name (if there are multiple)
+    result.append('@');
+    result.append(((TypeElement) qualifier.getAnnotationType().asElement()).getQualifiedName());
+    result.append('(');
+    for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry
+        : qualifier.getElementValues().entrySet()) {
+      result.append(entry.getKey().getSimpleName());
+      result.append('=');
+      result.append(entry.getValue().getValue());
+    }
+    result.append(")/");
+  }
+
+  private static AnnotationMirror getQualifier(
+      List<? extends AnnotationMirror> annotations, Object member) {
+    AnnotationMirror qualifier = null;
+    for (AnnotationMirror annotation : annotations) {
+      if (annotation.getAnnotationType().asElement().getAnnotation(Qualifier.class) == null) {
+        continue;
+      }
+      if (qualifier != null) {
+        throw new IllegalArgumentException("Too many qualifier annotations on " + member);
+      }
+      qualifier = annotation;
+    }
+    return qualifier;
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/codegen/InjectProcessor.java b/src/main/java/com/squareup/codegen/InjectProcessor.java
new file mode 100644
index 0000000..1671b26
--- /dev/null
+++ b/src/main/java/com/squareup/codegen/InjectProcessor.java
@@ -0,0 +1,292 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.codegen;
+
+import com.squareup.injector.internal.Binding;
+import com.squareup.injector.internal.Linker;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.annotation.processing.SupportedAnnotationTypes;
+import javax.annotation.processing.SupportedSourceVersion;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic;
+import javax.tools.JavaFileObject;
+
+import static java.lang.reflect.Modifier.FINAL;
+import static java.lang.reflect.Modifier.PRIVATE;
+import static java.lang.reflect.Modifier.PUBLIC;
+
+/**
+ * Generates an implementation of {@link Binding} that injects the
+ * {@literal @}{@code Inject}-annotated members of a class.
+ */
+@SupportedAnnotationTypes("javax.inject.Inject")
+@SupportedSourceVersion(SourceVersion.RELEASE_6)
+public final class InjectProcessor extends AbstractProcessor {
+  @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
+    try {
+      for (InjectedClass injectedClass : getInjectedClasses(env)) {
+        writeInjectAdapter(injectedClass.type, injectedClass.constructor, injectedClass.fields);
+      }
+    } catch (IOException e) {
+      error("Code gen failed: %s", e);
+    }
+    return true;
+  }
+
+  private Set<InjectedClass> getInjectedClasses(RoundEnvironment env) {
+    // First gather the set of classes that have @Inject-annotated members.
+    Set<TypeElement> injectedTypes = new LinkedHashSet<TypeElement>();
+    for (Element element : env.getElementsAnnotatedWith(Inject.class)) {
+      injectedTypes.add((TypeElement) element.getEnclosingElement());
+    }
+
+    // Next get the InjectedClass for each of those.
+    Set<InjectedClass> result = new LinkedHashSet<InjectedClass>();
+    for (TypeElement type : injectedTypes) {
+      result.add(getInjectedClass(type));
+    }
+
+    return result;
+  }
+
+  /**
+   * @param type a type with an @Inject-annotated member.
+   */
+  private InjectedClass getInjectedClass(TypeElement type) {
+    boolean isAbstract = type.getModifiers().contains(Modifier.ABSTRACT);
+    ExecutableElement constructor = null;
+    List<Element> fields = new ArrayList<Element>();
+    for (Element member : type.getEnclosedElements()) {
+      if (member.getAnnotation(Inject.class) == null
+          || member.getModifiers().contains(Modifier.STATIC)) {
+        continue;
+      }
+
+      switch (member.getKind()) {
+        case FIELD:
+          fields.add(member);
+          break;
+        case CONSTRUCTOR:
+          if (constructor != null) {
+            error("Too many injectable constructors on %s.", type.getQualifiedName());
+          } else if (isAbstract) {
+            error("Abstract class %s must not have an @Inject-annotated constructor.",
+                type.getQualifiedName());
+          }
+          constructor = (ExecutableElement) member;
+          break;
+        default:
+          error("Cannot inject %s", member);
+          break;
+      }
+    }
+
+    if (constructor == null && !isAbstract) {
+      constructor = findNoArgsConstructor(type);
+    }
+
+    return new InjectedClass(type, constructor, fields);
+  }
+
+  /**
+   * Returns the no args constructor for {@code typeElement}, or null if no such
+   * constructor exists.
+   */
+  private ExecutableElement findNoArgsConstructor(TypeElement typeElement) {
+    for (Element element : typeElement.getEnclosedElements()) {
+      if (element.getKind() != ElementKind.CONSTRUCTOR) {
+        continue;
+      }
+      ExecutableElement constructor = (ExecutableElement) element;
+      if (constructor.getParameters().isEmpty()) {
+        return constructor;
+      }
+    }
+    return null;
+  }
+
+  private void error(String format, Object... args) {
+    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, String.format(format, args));
+  }
+
+  /**
+   * Write a companion class for {@code type} that extends {@link Binding}.
+   *
+   * @param constructor the injectable constructor, or null if this binding
+   *     supports members injection only.
+   */
+  private void writeInjectAdapter(TypeElement type, ExecutableElement constructor,
+      List<Element> fields) throws IOException {
+    String typeName = type.getQualifiedName().toString();
+    TypeMirror supertype = CodeGen.getApplicationSupertype(type);
+    String adapterName = CodeGen.adapterName(type, "$InjectAdapter");
+    JavaFileObject sourceFile = processingEnv.getFiler()
+        .createSourceFile(adapterName, type);
+    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
+
+    writer.addPackage(CodeGen.getPackage(type).getQualifiedName().toString());
+    writer.addImport(Binding.class);
+    writer.addImport(Linker.class);
+    writer.addImport(Set.class);
+
+    writer.beginType(adapterName, "class", FINAL,
+        CodeGen.parameterizedType(Binding.class, typeName));
+
+    if (constructor != null) {
+      List<? extends VariableElement> parameters = constructor.getParameters();
+      for (int p = 0; p < parameters.size(); p++) {
+        TypeMirror parameterType = parameters.get(p).asType();
+        writer.field(CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(parameterType)),
+            constructorParameterName(p), PRIVATE);
+      }
+    }
+    for (int f = 0; f < fields.size(); f++) {
+      TypeMirror fieldType = fields.get(f).asType();
+      writer.field(CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(fieldType)),
+          fieldName(f), PRIVATE);
+    }
+    if (supertype != null) {
+      writer.field(CodeGen.parameterizedType(Binding.class,
+          CodeGen.rawTypeToString(supertype, '.')), "supertype", PRIVATE);
+    }
+
+    writer.beginMethod(null, adapterName, PUBLIC);
+    String key = (constructor != null)
+        ? JavaWriter.stringLiteral(GeneratorKeys.get(type.asType()))
+        : null;
+    String membersKey = JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(type.asType()));
+    boolean singleton = type.getAnnotation(Singleton.class) != null;
+    writer.statement("super(%s, %s, %s /*singleton*/, %s.class)",
+        key, membersKey, singleton, typeName);
+    writer.endMethod();
+
+    writer.annotation(Override.class);
+    writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
+    if (constructor != null) {
+      for (int p = 0; p < constructor.getParameters().size(); p++) {
+        TypeMirror parameterType = constructor.getParameters().get(p).asType();
+        writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
+            constructorParameterName(p),
+            CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(parameterType)),
+            JavaWriter.stringLiteral(GeneratorKeys.get(constructor.getParameters().get(p))),
+            typeName);
+      }
+    }
+    for (int f = 0; f < fields.size(); f++) {
+      TypeMirror fieldType = fields.get(f).asType();
+      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
+          fieldName(f),
+          CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(fieldType)),
+          JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) fields.get(f))),
+          typeName);
+    }
+    if (supertype != null) {
+      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
+          "supertype",
+          CodeGen.parameterizedType(Binding.class, CodeGen.rawTypeToString(supertype, '.')),
+          JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(supertype)),
+          typeName);
+    }
+    writer.endMethod();
+
+    writer.annotation(Override.class);
+    writer.beginMethod(typeName, "get", PUBLIC);
+    if (constructor != null) {
+      StringBuilder newInstance = new StringBuilder();
+      newInstance.append(typeName).append(" result = new ").append(typeName).append('(');
+      for (int p = 0; p < constructor.getParameters().size(); p++) {
+        if (p != 0) {
+          newInstance.append(", ");
+        }
+        newInstance.append(constructorParameterName(p)).append(".get()");
+      }
+      newInstance.append(')');
+      writer.statement(newInstance.toString());
+      writer.statement("injectMembers(result)");
+      writer.statement("return result");
+    } else {
+      writer.statement("throw new UnsupportedOperationException()");
+    }
+    writer.endMethod();
+
+    writer.annotation(Override.class);
+    writer.beginMethod("void", "injectMembers", PUBLIC, typeName, "object");
+    for (int f = 0; f < fields.size(); f++) {
+      writer.statement("object.%s = %s.get()",
+          fields.get(f).getSimpleName().toString(),
+          fieldName(f));
+    }
+    if (supertype != null) {
+      writer.statement("supertype.injectMembers(object)");
+    }
+    writer.endMethod();
+
+    writer.annotation(Override.class);
+    String setOfBindings = CodeGen.parameterizedType(Set.class, "Binding<?>");
+    writer.beginMethod("void", "getDependencies", PUBLIC, setOfBindings, "getBindings",
+        setOfBindings, "injectMembersBindings");
+    if (constructor != null) {
+      for (int p = 0; p < constructor.getParameters().size(); p++) {
+        writer.statement("getBindings.add(%s)", constructorParameterName(p));
+      }
+    }
+    for (int f = 0; f < fields.size(); f++) {
+      writer.statement("injectMembersBindings.add(%s)", fieldName(f));
+    }
+    if (supertype != null) {
+      writer.statement("injectMembersBindings.add(%s)", "supertype");
+    }
+    writer.endMethod();
+
+    writer.endType();
+    writer.close();
+  }
+
+  private String fieldName(int index) {
+    return "f" + index;
+  }
+
+  private String constructorParameterName(int index) {
+    return "c" + index;
+  }
+
+  static class InjectedClass {
+    final TypeElement type;
+    final ExecutableElement constructor;
+    final List<Element> fields;
+
+    InjectedClass(TypeElement type, ExecutableElement constructor, List<Element> fields) {
+      this.type = type;
+      this.constructor = constructor;
+      this.fields = fields;
+    }
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/codegen/JavaWriter.java b/src/main/java/com/squareup/codegen/JavaWriter.java
new file mode 100644
index 0000000..688e52e
--- /dev/null
+++ b/src/main/java/com/squareup/codegen/JavaWriter.java
@@ -0,0 +1,444 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.codegen;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Emits Java source files.
+ *
+ * @author Jesse Wilson
+ */
+public final class JavaWriter {
+  private static final Pattern TYPE_PATTERN = Pattern.compile("(?:[\\w$]+\\.)*([\\w$]+)");
+  private static final String INDENT = "  ";
+
+  /** Map fully qualified type names to their short names. */
+  private final Map<String, String> importedTypes = new HashMap<String, String>();
+
+  private String packagePrefix;
+  private final List<Scope> scopes = new ArrayList<Scope>();
+  private final Writer out;
+
+  /**
+   * @param out the stream to which Java source will be written. This should be
+   *     a buffered stream.
+   */
+  public JavaWriter(Writer out) {
+    this.out = out;
+  }
+
+  /**
+   * Emit a package declaration.
+   */
+  public void addPackage(String packageName) throws IOException {
+    if (this.packagePrefix != null) {
+      throw new IllegalStateException();
+    }
+    out.write("package ");
+    out.write(packageName);
+    out.write(";\n");
+    this.packagePrefix = packageName + ".";
+  }
+
+  /**
+   * Equivalent to {@code addImport(type.getName())}.
+   */
+  public void addImport(Class<?> type) throws IOException {
+    addImport(type.getName());
+  }
+
+  /**
+   * Emit an import for {@code type}. For the duration of the file, all
+   * references to this class will be automatically shortened.
+   */
+  public void addImport(String type) throws IOException {
+    Matcher matcher = TYPE_PATTERN.matcher(type);
+    if (!matcher.matches()) {
+      throw new IllegalArgumentException(type);
+    }
+    if (importedTypes.put(type, matcher.group(1)) != null) {
+      throw new IllegalArgumentException(type);
+    }
+    out.write("import ");
+    out.write(type);
+    out.write(";\n");
+  }
+
+  /**
+   * Emits a name like {@code java.lang.String} or {@code
+   * java.util.List<java.lang.String>}, shorting it with imports if
+   * possible.
+   */
+  private void type(String type) throws IOException {
+    if (this.packagePrefix == null) {
+      throw new IllegalStateException();
+    }
+
+    Matcher m = TYPE_PATTERN.matcher(type);
+    int pos = 0;
+    while (true) {
+      boolean found = m.find(pos);
+
+      // copy non-matching characters like "<"
+      int typeStart = found ? m.start() : type.length();
+      out.write(type, pos, typeStart - pos);
+
+      if (!found) {
+        break;
+      }
+
+      // copy a single class name, shortening it if possible
+      String name = m.group(0);
+      String imported;
+      if ((imported = importedTypes.get(name)) != null) {
+        out.write(imported);
+      } else if (name.startsWith(packagePrefix)
+          && name.indexOf('.', packagePrefix.length()) == -1) {
+        out.write(name.substring(packagePrefix.length()));
+      } else if (name.startsWith("java.lang.")) {
+        out.write(name.substring("java.lang.".length()));
+      } else {
+        out.write(name);
+      }
+      pos = m.end();
+    }
+  }
+
+  /**
+   * Emits a type declaration.
+   *
+   * @param kind such as "class", "interface" or "enum".
+   */
+  public void beginType(String type, String kind, int modifiers) throws IOException {
+    beginType(type, kind, modifiers, null);
+  }
+
+  /**
+   * Emits a type declaration.
+   *
+   * @param kind such as "class", "interface" or "enum".
+   * @param extendsType the class to extend, or null for no extends clause.
+   */
+  public void beginType(String type, String kind, int modifiers,
+      String extendsType, String... implementsTypes) throws IOException {
+    indent();
+    modifiers(modifiers);
+    out.write(kind);
+    out.write(" ");
+    type(type);
+    if (extendsType != null) {
+      out.write("\n");
+      indent();
+      out.write("    extends ");
+      type(extendsType);
+    }
+    if (implementsTypes.length > 0) {
+      out.write("\n");
+      indent();
+      out.write("    implements ");
+      for (int i = 0; i < implementsTypes.length; i++) {
+        if (i != 0) {
+          out.write(", ");
+        }
+        type(implementsTypes[i]);
+      }
+    }
+    out.write(" {\n");
+    pushScope(Scope.TYPE_DECLARATION);
+  }
+
+  /**
+   * Completes the current type declaration.
+   */
+  public void endType() throws IOException {
+    if (popScope() != Scope.TYPE_DECLARATION) {
+      throw new IllegalStateException();
+    }
+    indent();
+    out.write("}\n");
+  }
+
+  /**
+   * Emits a field declaration.
+   */
+  public void field(String type, String name, int modifiers) throws IOException {
+    field(type, name, modifiers, null);
+  }
+
+  public void field(String type, String name, int modifiers, String initialValue)
+      throws IOException {
+    indent();
+    modifiers(modifiers);
+    type(type);
+    out.write(" ");
+    out.write(name);
+
+    if (initialValue != null) {
+      out.write(" = ");
+      out.write(initialValue);
+    }
+    out.write(";\n");
+  }
+
+  /**
+   * Emit a method declaration.
+   *
+   * @param returnType the method's return type, or null for constructors.
+   * @param parameters alternating parameter types and names.
+   * @param name the method name, or the fully qualified class name for
+   *     constructors.
+   */
+  public void beginMethod(String returnType, String name, int modifiers, String... parameters)
+      throws IOException {
+    indent();
+    modifiers(modifiers);
+    if (returnType != null) {
+      type(returnType);
+      out.write(" ");
+      out.write(name);
+    } else {
+      type(name);
+    }
+    out.write("(");
+    for (int p = 0; p < parameters.length; ) {
+      if (p != 0) {
+        out.write(", ");
+      }
+      type(parameters[p++]);
+      out.write(" ");
+      type(parameters[p++]);
+    }
+    out.write(")");
+    if ((modifiers & Modifier.ABSTRACT) != 0) {
+      out.write(";\n");
+      pushScope(Scope.ABSTRACT_METHOD);
+    } else {
+      out.write(" {\n");
+      pushScope(Scope.NON_ABSTRACT_METHOD);
+    }
+  }
+
+  /**
+   * Annotates the next element with {@code annotation}. The annotation has no
+   * attributes.
+   */
+  public void annotation(String annotation) throws IOException {
+    indent();
+    out.write("@");
+    type(annotation);
+    out.write("\n");
+  }
+
+  /**
+   * Equivalent to {@code annotation(annotationType.getName())}.
+   */
+  public void annotation(Class<? extends Annotation> annotationType) throws IOException {
+    annotation(annotationType.getName());
+  }
+
+  /**
+   * @param pattern a code pattern like "int i = %s". Shouldn't contain a
+   * trailing semicolon or newline character.
+   */
+  public void statement(String pattern, Object... args) throws IOException {
+    checkInMethod();
+    indent();
+    out.write(String.format(pattern, args));
+    out.write(";\n");
+  }
+
+  /**
+   * @param controlFlow the control flow construct and its code, such as
+   *     "if (foo == 5)". Shouldn't contain braces or newline characters.
+   */
+  public void beginControlFlow(String controlFlow) throws IOException {
+    checkInMethod();
+    indent();
+    out.write(controlFlow);
+    out.write(" {\n");
+    pushScope(Scope.CONTROL_FLOW);
+  }
+
+  /**
+   * @param controlFlow the control flow construct and its code, such as
+   *     "else if (foo == 10)". Shouldn't contain braces or newline characters.
+   */
+  public void nextControlFlow(String controlFlow) throws IOException {
+    if (popScope() != Scope.CONTROL_FLOW) {
+      throw new IllegalArgumentException();
+    }
+
+    indent();
+    pushScope(Scope.CONTROL_FLOW);
+    out.write("} ");
+    out.write(controlFlow);
+    out.write(" {\n");
+  }
+
+  public void endControlFlow() throws IOException {
+    endControlFlow(null);
+  }
+
+  /**
+   * @param controlFlow the optional control flow construct and its code, such
+   *     as "while(foo == 20)". Only used for "do/while" control flows.
+   */
+  public void endControlFlow(String controlFlow) throws IOException {
+    if (popScope() != Scope.CONTROL_FLOW) {
+      throw new IllegalArgumentException();
+    }
+
+    indent();
+    if (controlFlow != null) {
+      out.write("} ");
+      out.write(controlFlow);
+      out.write(";\n");
+    } else {
+      out.write("}\n");
+    }
+  }
+
+  /**
+   * Completes the current method declaration.
+   */
+  public void endMethod() throws IOException {
+    Scope popped = popScope();
+    if (popped == Scope.NON_ABSTRACT_METHOD) {
+      indent();
+      out.write("}\n");
+    } else if (popped != Scope.ABSTRACT_METHOD) {
+      throw new IllegalStateException();
+    }
+  }
+
+  /**
+   * Returns the string literal representing {@code data}, including wrapping
+   * quotes.
+   */
+  public static String stringLiteral(String data) {
+    StringBuilder result = new StringBuilder();
+    result.append('"');
+    for (int i = 0; i < data.length(); i++) {
+      char c = data.charAt(i);
+      switch (c) {
+        case '"':
+          result.append("\\\"");
+          break;
+        case '\\':
+          result.append("\\\\");
+          break;
+        case '\t':
+          result.append("\\\t");
+          break;
+        case '\b':
+          result.append("\\\b");
+          break;
+        case '\n':
+          result.append("\\\n");
+          break;
+        case '\r':
+          result.append("\\\r");
+          break;
+        case '\f':
+          result.append("\\\f");
+          break;
+        default:
+          result.append(c);
+      }
+    }
+    result.append('"');
+    return result.toString();
+  }
+
+  public void close() throws IOException {
+    out.close();
+  }
+
+  /**
+   * Emit modifier names.
+   */
+  private void modifiers(int modifiers) throws IOException {
+    if ((modifiers & Modifier.PUBLIC) != 0) {
+      out.write("public ");
+    }
+    if ((modifiers & Modifier.PRIVATE) != 0) {
+      out.write("private ");
+    }
+    if ((modifiers & Modifier.PROTECTED) != 0) {
+      out.write("protected ");
+    }
+    if ((modifiers & Modifier.STATIC) != 0) {
+      out.write("static ");
+    }
+    if ((modifiers & Modifier.FINAL) != 0) {
+      out.write("final ");
+    }
+    if ((modifiers & Modifier.ABSTRACT) != 0) {
+      out.write("abstract ");
+    }
+    if ((modifiers & Modifier.SYNCHRONIZED) != 0) {
+      out.write("synchronized ");
+    }
+    if ((modifiers & Modifier.TRANSIENT) != 0) {
+      out.write("transient ");
+    }
+    if ((modifiers & Modifier.VOLATILE) != 0) {
+      out.write("volatile ");
+    }
+  }
+
+  private void indent() throws IOException {
+    for (int i = 0; i < scopes.size(); i++) {
+      out.write(INDENT);
+    }
+  }
+
+  private void checkInMethod() {
+    Scope scope = peekScope();
+    if (scope != Scope.NON_ABSTRACT_METHOD && scope != Scope.CONTROL_FLOW) {
+      throw new IllegalArgumentException();
+    }
+  }
+
+  private void pushScope(Scope pushed) {
+    scopes.add(pushed);
+  }
+
+  private Scope peekScope() {
+    return scopes.get(scopes.size() - 1);
+  }
+
+  private Scope popScope() {
+    return scopes.remove(scopes.size() - 1);
+  }
+
+  private enum Scope {
+    TYPE_DECLARATION,
+    ABSTRACT_METHOD,
+    NON_ABSTRACT_METHOD,
+    CONTROL_FLOW,
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/codegen/ProvidesProcessor.java b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
new file mode 100644
index 0000000..2a82aeb
--- /dev/null
+++ b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
@@ -0,0 +1,260 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.codegen;
+
+import com.squareup.injector.Module;
+import com.squareup.injector.Provides;
+import com.squareup.injector.internal.Binding;
+import com.squareup.injector.internal.Linker;
+import com.squareup.injector.internal.ModuleAdapter;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.annotation.processing.SupportedAnnotationTypes;
+import javax.annotation.processing.SupportedSourceVersion;
+import javax.inject.Singleton;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic;
+import javax.tools.JavaFileObject;
+
+import static java.lang.reflect.Modifier.FINAL;
+import static java.lang.reflect.Modifier.PRIVATE;
+import static java.lang.reflect.Modifier.PUBLIC;
+import static java.lang.reflect.Modifier.STATIC;
+
+/**
+ * Generates an implementation of {@link ModuleAdapter} that includes a binding
+ * for each {@code @Provides} method of a target class.
+ */
+@SupportedAnnotationTypes("com.squareup.injector.Provides")
+@SupportedSourceVersion(SourceVersion.RELEASE_6)
+public final class ProvidesProcessor extends AbstractProcessor {
+  private static final String BINDINGS_MAP = CodeGen.parameterizedType(
+      Map.class, String.class.getName(), Binding.class.getName() + "<?>");
+
+  // TODO: include @Provides methods from the superclass
+
+  @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
+    try {
+      Map<TypeElement, List<ExecutableElement>> providerMethods = providerMethodsByClass(env);
+      for (Map.Entry<TypeElement, List<ExecutableElement>> module : providerMethods.entrySet()) {
+        writeModuleAdapter(module.getKey(), module.getValue());
+      }
+    } catch (IOException e) {
+      error("Code gen failed: " + e);
+    }
+    return true;
+  }
+
+  private void error(String message) {
+    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message);
+  }
+
+  /**
+   * Returns a map containing all {@code @Provides} methods, indexed by class.
+   */
+  private Map<TypeElement, List<ExecutableElement>> providerMethodsByClass(RoundEnvironment env) {
+    Map<TypeElement, List<ExecutableElement>> result
+        = new HashMap<TypeElement, List<ExecutableElement>>();
+    for (Element providerMethod : providesMethods(env)) {
+      TypeElement type = (TypeElement) providerMethod.getEnclosingElement();
+      Set<Modifier> typeModifiers = type.getModifiers();
+      if (type.getKind() != ElementKind.CLASS) {
+        error("Unexpected @Provides on " + providerMethod);
+        continue;
+      }
+      if (typeModifiers.contains(Modifier.PRIVATE)
+          || typeModifiers.contains(Modifier.ABSTRACT)) {
+        error("Classes declaring @Provides methods must not be private or abstract: "
+                + type.getQualifiedName());
+      }
+
+      Set<Modifier> methodModifiers = providerMethod.getModifiers();
+      if (methodModifiers.contains(Modifier.PRIVATE)
+          || methodModifiers.contains(Modifier.ABSTRACT)
+          || methodModifiers.contains(Modifier.STATIC)) {
+        error("@Provides methods must not be private, abstract or static: "
+                + type.getQualifiedName() + "." + providerMethod);
+        continue;
+      }
+
+      List<ExecutableElement> methods = result.get(type);
+      if (methods == null) {
+        methods = new ArrayList<ExecutableElement>();
+        result.put(type, methods);
+      }
+      methods.add((ExecutableElement) providerMethod);
+    }
+
+    return result;
+  }
+
+  private Set<? extends Element> providesMethods(RoundEnvironment env) {
+    Set<Element> result = new LinkedHashSet<Element>();
+    result.addAll(env.getElementsAnnotatedWith(Provides.class));
+    return result;
+  }
+
+  /**
+   * Write a companion class for {@code type} that implements {@link
+   * ModuleAdapter} to expose its provider methods.
+   */
+  private void writeModuleAdapter(TypeElement type, List<ExecutableElement> providerMethods)
+      throws IOException {
+    Map<String, Object> module = CodeGen.getAnnotation(Module.class, type);
+    if (module == null) {
+      error(type + " has @Provides methods but no @Module annotation");
+      return;
+    }
+
+    Object[] staticInjections = (Object[]) module.get("staticInjections");
+    Object[] entryPoints = (Object[]) module.get("entryPoints");
+    boolean overrides = (Boolean) module.get("overrides");
+
+    String adapterName = CodeGen.adapterName(type, "$ModuleAdapter");
+    JavaFileObject sourceFile = processingEnv.getFiler()
+        .createSourceFile(adapterName, type);
+    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
+
+    writer.addPackage(CodeGen.getPackage(type).getQualifiedName().toString());
+    writer.addImport(Binding.class);
+    writer.addImport(ModuleAdapter.class);
+    writer.addImport(Map.class);
+    writer.addImport(Linker.class);
+
+    String typeName = type.getQualifiedName().toString();
+    writer.beginType(adapterName, "class", PUBLIC | FINAL,
+        CodeGen.parameterizedType(ModuleAdapter.class, typeName));
+
+    StringBuilder entryPointsField = new StringBuilder().append("{ ");
+    for (Object entryPoint : entryPoints) {
+      TypeMirror typeMirror = (TypeMirror) entryPoint;
+      String key = GeneratorKeys.rawMembersKey(typeMirror);
+      entryPointsField.append(JavaWriter.stringLiteral(key)).append(", ");
+    }
+    entryPointsField.append("}");
+    writer.field("String[]", "ENTRY_POINTS", PRIVATE | STATIC | FINAL,
+        entryPointsField.toString());
+
+    StringBuilder staticInjectionsField = new StringBuilder().append("{ ");
+    for (Object staticInjection : staticInjections) {
+      TypeMirror typeMirror = (TypeMirror) staticInjection;
+      staticInjectionsField.append(CodeGen.typeToString(typeMirror)).append(".class, ");
+    }
+    staticInjectionsField.append("}");
+    writer.field("Class<?>[]", "STATIC_INJECTIONS", PRIVATE | STATIC | FINAL,
+        staticInjectionsField.toString());
+
+    writer.beginMethod(null, adapterName, PUBLIC);
+    writer.statement("super(ENTRY_POINTS, STATIC_INJECTIONS, %s)", overrides);
+    writer.endMethod();
+
+    writer.annotation(Override.class);
+    writer.beginMethod("void", "getBindings", PUBLIC, typeName, "module", BINDINGS_MAP, "map");
+    for (ExecutableElement providerMethod : providerMethods) {
+      String key = GeneratorKeys.get(providerMethod);
+      writer.statement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
+          providerMethod.getSimpleName().toString() + "Binding");
+    }
+    writer.endMethod();
+
+    for (ExecutableElement providerMethod : providerMethods) {
+      writeBindingClass(writer, providerMethod);
+    }
+
+    writer.endType();
+    writer.close();
+  }
+
+  private void writeBindingClass(JavaWriter writer, ExecutableElement providerMethod)
+      throws IOException {
+    String methodName = providerMethod.getSimpleName().toString();
+    String moduleType = CodeGen.typeToString(providerMethod.getEnclosingElement().asType());
+    String className = providerMethod.getSimpleName() + "Binding";
+    String returnType = CodeGen.typeToString(providerMethod.getReturnType());
+
+    writer.beginType(className, "class", PRIVATE | STATIC,
+        CodeGen.parameterizedType(Binding.class, returnType));
+    writer.field(moduleType, "module", PRIVATE | FINAL);
+    List<? extends VariableElement> parameters = providerMethod.getParameters();
+    for (int p = 0; p < parameters.size(); p++) {
+      TypeMirror parameterType = parameters.get(p).asType();
+      writer.field(CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(parameterType)),
+          parameterName(p), PRIVATE);
+    }
+
+    writer.beginMethod(null, className, PUBLIC, moduleType, "module");
+    boolean singleton = providerMethod.getAnnotation(Singleton.class) != null;
+    String key = JavaWriter.stringLiteral(GeneratorKeys.get(providerMethod));
+    String membersKey = null;
+    writer.statement("super(%s, %s, %s /*singleton*/, %s.class)",
+        key, membersKey, singleton, moduleType);
+    writer.statement("this.module = module");
+    writer.endMethod();
+
+    writer.annotation(Override.class);
+    writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
+    for (int p = 0; p < parameters.size(); p++) {
+      VariableElement parameter = parameters.get(p);
+      String parameterKey = GeneratorKeys.get(parameter);
+      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
+          parameterName(p),
+          CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(parameter.asType())),
+          JavaWriter.stringLiteral(parameterKey), moduleType);
+    }
+    writer.endMethod();
+
+    writer.annotation(Override.class);
+    writer.beginMethod(returnType, "get", PUBLIC);
+    StringBuilder args = new StringBuilder();
+    for (int p = 0; p < parameters.size(); p++) {
+      if (p != 0) {
+        args.append(", ");
+      }
+      args.append(String.format("%s.get()", parameterName(p)));
+    }
+    writer.statement("return module.%s(%s)", methodName, args.toString());
+    writer.endMethod();
+
+    writer.annotation(Override.class);
+    String setOfBindings = CodeGen.parameterizedType(Set.class, "Binding<?>");
+    writer.beginMethod("void", "getDependencies", PUBLIC, setOfBindings, "getBindings",
+        setOfBindings, "injectMembersBindings");
+    for (int p = 0; p < parameters.size(); p++) {
+      writer.statement("getBindings.add(%s)", parameterName(p));
+    }
+    writer.endMethod();
+
+    writer.endType();
+  }
+
+  private String parameterName(int index) {
+    return "p" + index;
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/MembersInjector.java b/src/main/java/com/squareup/injector/MembersInjector.java
new file mode 100644
index 0000000..3767d39
--- /dev/null
+++ b/src/main/java/com/squareup/injector/MembersInjector.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+/**
+ * Injects dependencies into the fields and methods on instances of type
+ * {@code T}. Ignores the presence or absence of an injectable constructor.
+ *
+ * @param <T> type to inject members of
+ *
+ * @author Bob Lee
+ * @author Jesse Wilson
+ */
+public interface MembersInjector<T> {
+
+  /**
+   * Injects dependencies into the fields and methods of {@code instance}.
+   * Ignores the presence or absence of an injectable constructor.
+   *
+   * <p>Whenever the injector creates an instance, it performs this injection
+   * automatically (after first performing constructor injection), so if you're
+   * able to let the injector create all your objects for you, you'll never need
+   * to use this method.
+   *
+   * @param instance to inject members on. May be {@code null}.
+   */
+  void injectMembers(T instance);
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/Module.java b/src/main/java/com/squareup/injector/Module.java
new file mode 100644
index 0000000..ae76826
--- /dev/null
+++ b/src/main/java/com/squareup/injector/Module.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Annotates a class that contributes to the object graph.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+public @interface Module {
+  Class<?>[] entryPoints() default { };
+  Class<?>[] staticInjections() default { };
+
+  /**
+   * True if @Provides methods from this module are permitted to override those
+   * of other modules. This is a dangerous feature as it permits binding
+   * conflicts to go unnoticed. It should only be used in test and development
+   * modules.
+   */
+  boolean overrides() default false;
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/ObjectGraph.java b/src/main/java/com/squareup/injector/ObjectGraph.java
new file mode 100644
index 0000000..217e27a
--- /dev/null
+++ b/src/main/java/com/squareup/injector/ObjectGraph.java
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import com.squareup.injector.internal.Binding;
+import com.squareup.injector.internal.Keys;
+import com.squareup.injector.internal.Linker;
+import com.squareup.injector.internal.ModuleAdapter;
+import com.squareup.injector.internal.ProblemDetector;
+import com.squareup.injector.internal.StaticInjection;
+import com.squareup.injector.internal.UniqueMap;
+import java.util.Collection;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+/**
+ * A graph of objects linked by their dependencies.
+ *
+ * <p>The following injection features are supported:
+ * <ul>
+ *   <li>Field injection. A class may have any number of field injections, and
+ *       fields may be of any visibility. Static fields will be injected each
+ *       time an instance is injected.
+ *   <li>Constructor injection. A class may have a single
+ *       {@code @Inject}-annotated constructor. Classes that have fields
+ *       injected may omit the {@link @Inject} annotation if they have a public
+ *       no-arguments constructor.
+ *   <li>Injection of {@code @Provides} method parameters.
+ *   <li>{@code @Provides} methods annotated {@code @Singleton}.
+ *   <li>Constructor-injected classes annotated {@code @Singleton}.
+ *   <li>Injection of {@link javax.inject.Provider}s.
+ *   <li>Injection of {@link MembersInjector}s.
+ *   <li>Qualifier annotations on injected parameters and fields.
+ *   <li>JSR 330 annotations.
+ * </ul>
+ *
+ * <p>The following injection features are not currently supported:
+ * <ul>
+ *   <li>Method injection.</li>
+ *   <li>Circular dependencies.</li>
+ * </ul>
+ */
+public final class ObjectGraph {
+  private final Linker linker;
+  private final Map<Class<?>, StaticInjection> staticInjections;
+  private final Map<String, Class<?>> entryPoints;
+
+  private ObjectGraph(Linker linker, Map<Class<?>, StaticInjection> staticInjections,
+      Map<String, Class<?>> entryPoints) {
+    this.linker = linker;
+    this.staticInjections = staticInjections;
+    this.entryPoints = entryPoints;
+  }
+
+  /**
+   * Returns a new dependency graph using the {@literal @}{@link
+   * Module}-annotated modules.
+   *
+   * <p>This <strong>does not</strong> inject any members. Most applications
+   * should call {@link #injectStatics} to inject static members and/or {@link
+   * #inject} to inject instance members when this method has returned.
+   */
+  public static ObjectGraph get(Object... modules) {
+    return get(false, modules);
+  }
+
+  public static ObjectGraph getLazy(Object... modules) {
+    return get(true, modules);
+  }
+
+  private static ObjectGraph get(boolean lazy, Object... modules) {
+    Map<String, Class<?>> entryPoints = new LinkedHashMap<String, Class<?>>();
+    Map<Class<?>, StaticInjection> staticInjections
+        = new LinkedHashMap<Class<?>, StaticInjection>();
+
+    // Extract bindings in the 'base' and 'overrides' set. Within each set no
+    // duplicates are permitted.
+    Map<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>();
+    Map<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>();
+    for (Object module : modules) {
+      Class<?> moduleClass = module.getClass();
+      ModuleAdapter<Object> adapter = ModuleAdapter.get(module);
+      for (String key : adapter.entryPoints) {
+        entryPoints.put(key, moduleClass);
+      }
+      for (Class<?> c : adapter.staticInjections) {
+        staticInjections.put(c, lazy ? null : StaticInjection.get(c));
+      }
+      Map<String, Binding<?>> addTo = adapter.overrides ? overrideBindings : baseBindings;
+      adapter.getBindings(module, addTo);
+    }
+
+    // Create a linker and install all of the user's bindings.
+    Linker linker = new Linker();
+    linker.installBindings(baseBindings);
+    linker.installBindings(overrideBindings);
+
+    ObjectGraph result = new ObjectGraph(linker, staticInjections, entryPoints);
+
+    // Link all bindings (unless this injector is lazy).
+    if (!lazy) {
+      result.linkStaticInjections();
+      result.linkEntryPoints();
+      linker.linkAll();
+    }
+
+    return result;
+  }
+
+  private void linkStaticInjections() {
+    for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
+      StaticInjection staticInjection = entry.getValue();
+      if (staticInjection == null) {
+        staticInjection = StaticInjection.get(entry.getKey());
+        entry.setValue(staticInjection);
+      }
+      staticInjection.attach(linker);
+    }
+  }
+
+  private void linkEntryPoints() {
+    for (Map.Entry<String, Class<?>> entry : entryPoints.entrySet()) {
+      linker.requestBinding(entry.getKey(), entry.getValue());
+    }
+  }
+
+  /**
+   * Do full graph problem detection.
+   */
+  public void detectProblems() {
+    linkStaticInjections();
+    linkEntryPoints();
+    Collection<Binding<?>> allBindings = linker.linkAll();
+    new ProblemDetector().detectProblems(allBindings);
+  }
+
+  /**
+   * Injects the static fields of the classes listed in the injector's {@code
+   * staticInjections} property.
+   */
+  public void injectStatics() {
+    // We call linkStaticInjections() twice on purpose. The first time through
+    // we request all of the bindings we need. The linker returns null for
+    // bindings it doesn't have. Then we ask the linker to link all of those
+    // requested bindings. Finally we call linkStaticInjections() again: this
+    // time the linker won't return null because everything has been linked.
+    linkStaticInjections();
+    linker.linkRequested();
+    linkStaticInjections();
+
+    for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
+      entry.getValue().inject();
+    }
+  }
+
+  /**
+   * Injects the members of {@code instance}, including injectable members
+   * inherited from its supertypes.
+   *
+   * @throws IllegalArgumentException if the runtime type of {@code instance} is
+   *     not the injector's type or one of its entry point types.
+   */
+  @SuppressWarnings("unchecked") // the linker matches keys to bindings by their type
+  public void inject(Object instance) {
+    String key = Keys.getMembersKey(instance.getClass());
+    Class<?> moduleClass = entryPoints.get(key);
+    if (moduleClass == null) {
+      throw new IllegalArgumentException("No entry point for " + instance.getClass().getName()
+          + ". You must explicitly add an entry point to one of your modules.");
+    }
+    Binding<?> binding = linker.requestBinding(key, moduleClass);
+    if (binding == null || !binding.linked) {
+      linker.linkRequested();
+      binding = linker.requestBinding(key, moduleClass);
+    }
+    ((Binding<Object>) binding).injectMembers(instance);
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/Provides.java b/src/main/java/com/squareup/injector/Provides.java
new file mode 100644
index 0000000..fb0b4f7
--- /dev/null
+++ b/src/main/java/com/squareup/injector/Provides.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2007 Google Inc.
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Annotates methods of a module to create a provider method binding. The
+ * method's return type is bound to it's returned value. The injector will pass
+ * dependencies to the method as parameters.
+ *
+ * @author Bob Lee
+ */
+@Documented @Target(METHOD) @Retention(RUNTIME)
+public @interface Provides {
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/AtInjectBinding.java b/src/main/java/com/squareup/injector/internal/AtInjectBinding.java
new file mode 100644
index 0000000..2bc960d
--- /dev/null
+++ b/src/main/java/com/squareup/injector/internal/AtInjectBinding.java
@@ -0,0 +1,219 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+/**
+ * A binding that injects the constructor and fields of a class.
+ */
+final class AtInjectBinding<T> extends Binding<T> {
+  private final Field[] fields;
+  private final Constructor<T> constructor;
+  private final Class<?> supertype;
+  private final String[] keys;
+  private Binding<?>[] fieldBindings;
+  private Binding<?>[] parameterBindings;
+  private Binding<? super T> supertypeBinding;
+
+  /**
+   * @param keys keys for the fields, constructor parameters and supertype in
+   *     that order. These are precomputed to minimize reflection when {@code
+   *     attach} is called multiple times.
+   * @param constructor the injectable constructor, or null if this binding
+   *     supports members injection only.
+   * @param supertype the injectable supertype, or null if the supertype is a
+   */
+  private AtInjectBinding(String provideKey, String membersKey, boolean singleton, Class<?> type,
+      Field[] fields, Constructor<T> constructor, int parameterCount, Class<?> supertype,
+      String[] keys) {
+    super(provideKey, membersKey, singleton, type);
+    this.constructor = constructor;
+    this.fields = fields;
+    this.supertype = supertype;
+    this.keys = keys;
+    this.parameterBindings = new Binding<?>[parameterCount];
+    this.fieldBindings = new Binding<?>[fields.length];
+  }
+
+  @SuppressWarnings("unchecked") // The linker promises it's safe to cast to Binding<? super T>.
+  @Override public void attach(Linker linker) {
+    int k = 0;
+    for (int i = 0; i < fields.length; i++) {
+      if (fieldBindings[i] == null) {
+        fieldBindings[i] = linker.requestBinding(keys[k], fields[i]);
+      }
+      k++;
+    }
+    if (constructor != null) {
+      for (int i = 0; i < parameterBindings.length; i++) {
+        if (parameterBindings[i] == null) {
+          parameterBindings[i] = linker.requestBinding(keys[k], constructor);
+        }
+        k++;
+      }
+    }
+    if (supertype != null && supertypeBinding == null) {
+      supertypeBinding = (Binding<? super T>) linker.requestBinding(keys[k], membersKey);
+    }
+  }
+
+  @Override public T get() {
+    if (constructor == null) {
+      throw new UnsupportedOperationException();
+    }
+    Object[] args = new Object[parameterBindings.length];
+    for (int i = 0; i < parameterBindings.length; i++) {
+      args[i] = parameterBindings[i].get();
+    }
+    T result;
+    try {
+      result = constructor.newInstance(args);
+    } catch (IllegalAccessException e) {
+      throw new AssertionError(e);
+    } catch (InvocationTargetException e) {
+      throw new RuntimeException(e.getCause());
+    } catch (InstantiationException e) {
+      throw new RuntimeException(e);
+    }
+    injectMembers(result);
+    return result;
+  }
+
+  @Override public void injectMembers(T t) {
+    try {
+      for (int i = 0; i < fields.length; i++) {
+        fields[i].set(t, fieldBindings[i].get());
+      }
+      if (supertypeBinding != null) {
+        supertypeBinding.injectMembers(t);
+      }
+    } catch (IllegalAccessException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+    if (parameterBindings != null) {
+      for (Binding<?> binding : parameterBindings) {
+        get.add(binding);
+      }
+    }
+    for (Binding<?> binding : fieldBindings) {
+      injectMembers.add(binding);
+    }
+    if (supertypeBinding != null) {
+      injectMembers.add(supertypeBinding);
+    }
+  }
+
+  @Override public String toString() {
+    return provideKey != null ? provideKey : membersKey;
+  }
+
+  /**
+   * @param forMembersInjection true if the binding is being created to inject
+   *     members only. Such injections do not require {@code @Inject}
+   *     annotations.
+   */
+  public static <T> Binding<T> create(Class<T> type, boolean forMembersInjection) {
+    boolean singleton = type.isAnnotationPresent(Singleton.class);
+    List<String> keys = new ArrayList<String>();
+
+    // Lookup the injectable fields and their corresponding keys.
+    List<Field> injectedFields = new ArrayList<Field>();
+    for (Class<?> c = type; c != Object.class; c = c.getSuperclass()) {
+      for (Field field : c.getDeclaredFields()) {
+        if (!field.isAnnotationPresent(Inject.class) || Modifier.isStatic(field.getModifiers())) {
+          continue;
+        }
+        field.setAccessible(true);
+        injectedFields.add(field);
+        keys.add(Keys.get(field.getGenericType(), field.getAnnotations(), field));
+      }
+    }
+
+    // Look up @Inject-annotated constructors. If there's no @Inject-annotated
+    // constructor, use a default public constructor if the class has other
+    // injections. Otherwise treat the class as non-injectable.
+    Constructor<T> injectedConstructor = null;
+    for (Constructor<T> constructor : (Constructor<T>[]) type.getDeclaredConstructors()) {
+      if (!constructor.isAnnotationPresent(Inject.class)) {
+        continue;
+      }
+      if (injectedConstructor != null) {
+        throw new IllegalArgumentException("Too many injectable constructors on " + type.getName());
+      }
+      injectedConstructor = constructor;
+    }
+    if (injectedConstructor == null) {
+      if (injectedFields.isEmpty() && !forMembersInjection) {
+        throw new IllegalArgumentException("No injectable members on " + type.getName()
+            + ". Do you want to add an injectable constructor?");
+      }
+      try {
+        injectedConstructor = type.getDeclaredConstructor();
+      } catch (NoSuchMethodException ignored) {
+      }
+    }
+
+    int parameterCount;
+    String provideKey;
+    if (injectedConstructor != null) {
+      provideKey = Keys.get(type);
+      injectedConstructor.setAccessible(true);
+      Type[] types = injectedConstructor.getGenericParameterTypes();
+      parameterCount = types.length;
+      if (parameterCount != 0) {
+        Annotation[][] annotations = injectedConstructor.getParameterAnnotations();
+        for (int p = 0; p < types.length; p++) {
+          keys.add(Keys.get(types[p], annotations[p], injectedConstructor));
+        }
+      }
+    } else {
+      provideKey = null;
+      parameterCount = 0;
+      if (singleton) {
+        throw new IllegalArgumentException(
+            "No injectable constructor on @Singleton " + type.getName());
+      }
+    }
+
+    Class<? super T> supertype = type.getSuperclass();
+    if (supertype != null) {
+      if (Keys.isPlatformType(supertype.getName())) {
+        supertype = null;
+      } else {
+        keys.add(Keys.getMembersKey(supertype));
+      }
+    }
+
+    String membersKey = Keys.getMembersKey(type);
+    return new AtInjectBinding<T>(provideKey, membersKey, singleton, type,
+        injectedFields.toArray(new Field[injectedFields.size()]), injectedConstructor,
+        parameterCount, supertype, keys.toArray(new String[keys.size()]));
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Binding.java b/src/main/java/com/squareup/injector/internal/Binding.java
new file mode 100644
index 0000000..bccc0ee
--- /dev/null
+++ b/src/main/java/com/squareup/injector/internal/Binding.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import com.squareup.injector.MembersInjector;
+import java.util.Set;
+import javax.inject.Provider;
+
+/**
+ * Injects a value of a specific type.
+ */
+public class Binding<T> implements Provider<T>, MembersInjector<T> {
+  public static final Binding<Object> UNRESOLVED = new Binding<Object>(null, null, false, null);
+
+  /** The key used to provide instances of 'T', or null if this binding cannot provide instances. */
+  public final String provideKey;
+
+  /** The key used to inject members of 'T', or null if this binding cannot inject members. */
+  public final String membersKey;
+
+  /** True if the provided instance is always the same object. */
+  public final boolean singleton;
+
+  public final Object requiredBy;
+  public boolean linked;
+
+  protected Binding(String provideKey, String membersKey, boolean singleton, Object requiredBy) {
+    if (singleton && provideKey == null) {
+      throw new IllegalArgumentException();
+    }
+    this.provideKey = provideKey;
+    this.membersKey = membersKey;
+    this.singleton = singleton;
+    this.requiredBy = requiredBy;
+  }
+
+  /**
+   * Links this binding to its dependencies.
+   */
+  public void attach(Linker linker) {
+  }
+
+  @Override public void injectMembers(T t) {
+    throw new UnsupportedOperationException(getClass().getName());
+  }
+
+  @Override public T get() {
+    throw new UnsupportedOperationException(getClass().getName());
+  }
+
+  /**
+   * Populates {@code getBindings} and {@code injectMembersBindings} with the
+   * bindings used by this binding to satisfy {@link #get} and {@link
+   * #injectMembers} calls, respectively.
+   *
+   * @param getBindings the bindings required by this binding's {@code get}
+   *     method. Although {@code get} usually calls into {@code injectMembers},
+   *     this <i>does not</i> contain the injectMembers bindings.
+   * @param injectMembersBindings the bindings required by this binding's {@code
+   *     injectMembers} method.
+   */
+  public void getDependencies(Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
+    throw new UnsupportedOperationException(getClass().getName());
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/BuiltInBinding.java b/src/main/java/com/squareup/injector/internal/BuiltInBinding.java
new file mode 100644
index 0000000..2b089e1
--- /dev/null
+++ b/src/main/java/com/squareup/injector/internal/BuiltInBinding.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import java.util.Set;
+
+/**
+ * Injects a Provider or a MembersInjector.
+ */
+final class BuiltInBinding<T> extends Binding<T> {
+  private final String delegateKey;
+  private Binding<?> delegate;
+
+  public BuiltInBinding(String key, Object requiredBy, String delegateKey) {
+    super(key, null, false, requiredBy);
+    this.delegateKey = delegateKey;
+  }
+
+  @Override public void attach(Linker linker) {
+    delegate = linker.requestBinding(delegateKey, requiredBy);
+  }
+
+  @Override public void injectMembers(T t) {
+    throw new UnsupportedOperationException();
+  }
+
+  @SuppressWarnings("unchecked") // At runtime we know 'T' is a Provider or MembersInjector.
+  @Override public T get() {
+    return (T) delegate;
+  }
+
+  public Binding<?> getDelegate() {
+    return delegate;
+  }
+
+  @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+    // We don't add 'delegate' because it isn't actually used by get() or injectMembers().
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Keys.java b/src/main/java/com/squareup/injector/internal/Keys.java
new file mode 100644
index 0000000..4aab693
--- /dev/null
+++ b/src/main/java/com/squareup/injector/internal/Keys.java
@@ -0,0 +1,209 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import com.squareup.injector.MembersInjector;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.GenericArrayType;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+/**
+ * Formats strings that identify the value to be injected. Keys are of one of
+ * three forms:
+ * <ol>
+ *   <li>{@code com.square.Foo}: provides instances of Foo.
+ *   <li>{@code @com.square.Bar/com.square.Foo}: provides instances of Foo
+ *       qualified by the annotation.
+ *   <li>{@code members/com.square.Foo}: injects members of Foo.
+ * </ol>
+ * Bindings from {@code @Provides} methods are of the first two types. Bindings
+ * created from {@code @Inject}-annotated members of a class are of the first
+ * and last types.
+ */
+public final class Keys {
+  private static final String PROVIDER_PREFIX = Provider.class.getName() + "<";
+  private static final String MEMBERS_INJECTOR_PREFIX = MembersInjector.class.getName() + "<";
+
+  private static final LruCache<Class<? extends Annotation>, Boolean> IS_QUALIFIER_ANNOTATION
+      = new LruCache<Class<? extends Annotation>, Boolean>(Integer.MAX_VALUE) {
+    @Override protected Boolean create(Class<? extends Annotation> annotationType) {
+      return annotationType.isAnnotationPresent(Qualifier.class);
+    }
+  };
+
+  Keys() {
+  }
+
+  /** Returns a key for {@code type} with no annotation. */
+  public static String get(Type type) {
+    return get(type, null);
+  }
+
+
+  /** Returns a key for the members of {@code type}. */
+  public static String getMembersKey(Class<?> key) {
+    return "members/" + get(key);
+  }
+
+  /** Returns a key for {@code type} annotated by {@code annotation}. */
+  public static String get(Type type, Annotation annotation) {
+    type = boxIfPrimitive(type);
+    if (annotation == null
+        && type instanceof Class
+        && !((Class<?>) type).isArray()) {
+      return ((Class<?>) type).getName();
+    }
+
+    StringBuilder result = new StringBuilder();
+    if (annotation != null) {
+      result.append(annotation).append("/");
+    }
+    typeToString(type, result);
+    return result.toString();
+  }
+
+  /**
+   * Returns a key for {@code type} annotated with {@code annotations},
+   * reporting failures against {@code subject}.
+   *
+   * @param annotations the annotations on a single method, field or parameter.
+   *     This array may contain at most one qualifier annotation.
+   */
+  public static String get(Type type, Annotation[] annotations, Object subject) {
+    Annotation qualifier = null;
+    for (Annotation a : annotations) {
+      if (!IS_QUALIFIER_ANNOTATION.get(a.annotationType())) {
+        continue;
+      }
+      if (qualifier != null) {
+        throw new IllegalArgumentException("Too many qualifier annotations on " + subject);
+      }
+      qualifier = a;
+    }
+    return get(type, qualifier);
+  }
+
+  private static void typeToString(Type type, StringBuilder result) {
+    if (type instanceof Class) {
+      Class<?> c = (Class<?>) type;
+      if (c.isArray()) {
+        result.append(c.getComponentType().getName());
+        result.append("[]");
+      } else if (c.isPrimitive()) {
+        // TODO: support this?
+        throw new UnsupportedOperationException("Uninjectable type " + type);
+      } else {
+        result.append(c.getName());
+      }
+    } else if (type instanceof ParameterizedType) {
+      ParameterizedType parameterizedType = (ParameterizedType) type;
+      typeToString(parameterizedType.getRawType(), result);
+      Type[] arguments = parameterizedType.getActualTypeArguments();
+      result.append("<");
+      for (int i = 0; i < arguments.length; i++) {
+        if (i != 0) {
+          result.append(", ");
+        }
+        typeToString(arguments[i], result);
+      }
+      result.append(">");
+    } else if (type instanceof GenericArrayType) {
+      GenericArrayType genericArrayType = (GenericArrayType) type;
+      result.append(((Class<?>) genericArrayType.getGenericComponentType()).getName());
+      result.append("[]");
+    } else {
+      throw new UnsupportedOperationException("Uninjectable type " + type);
+    }
+  }
+
+  /**
+   * Returns a key for the type provided by, or injected by this key. For
+   * example, if this is a key for a {@code Provider<Foo>}, this returns the
+   * key for {@code Foo}. This retains annotations and supports both Provider
+   * keys and MembersInjector keys.
+   */
+  public static String getDelegateKey(String key) {
+    int start = 0;
+    if (key.startsWith("@")) {
+      start = key.lastIndexOf('/') + 1;
+    }
+
+    String delegatePrefix;
+    String wrapperPrefix;
+    if (substringStartsWith(key, start, PROVIDER_PREFIX)) {
+      delegatePrefix = key.substring(0, start);
+      wrapperPrefix = PROVIDER_PREFIX;
+    } else if (substringStartsWith(key, start, MEMBERS_INJECTOR_PREFIX)) {
+      delegatePrefix = "members/";
+      wrapperPrefix = MEMBERS_INJECTOR_PREFIX;
+    } else {
+      return null;
+    }
+    return delegatePrefix
+        + key.substring(start + wrapperPrefix.length(), key.length() - 1);
+  }
+
+  /** Returns true if {@code string.substring(offset).startsWith(substring)}. */
+  private static boolean substringStartsWith(String string, int offset, String substring) {
+    return string.regionMatches(offset, substring, 0, substring.length());
+  }
+
+  /** Returns true if {@code key} is a binding that supports members injection. */
+  public static boolean isMembersInjection(String key) {
+    return key.startsWith("members/");
+  }
+
+  /** Returns true if {@code key} has a qualifier annotation. */
+  public static boolean isAnnotated(String key) {
+    return key.startsWith("@");
+  }
+
+  /**
+   * Returns the class name for {@code key}, if {@code key} was created with a
+   * class instance. Returns null if {@code key} represents a parameterized type
+   * or an array type.
+   */
+  public static String getClassName(String key) {
+    int start = 0;
+    if (key.startsWith("@") || key.startsWith("members/")) {
+      start = key.lastIndexOf('/') + 1;
+    }
+    return (key.indexOf('<', start) == -1 && key.indexOf('[') == -1)
+        ? key.substring(start)
+        : null;
+  }
+
+  /** Returns true if {@code name} is the name of a platform-provided class. */
+  public static boolean isPlatformType(String name) {
+    return name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.");
+  }
+
+  private static Type boxIfPrimitive(Type type) {
+    if (type == byte.class) return Byte.class;
+    if (type == short.class) return Short.class;
+    if (type == int.class) return Integer.class;
+    if (type == long.class) return Long.class;
+    if (type == char.class) return Character.class;
+    if (type == boolean.class) return Boolean.class;
+    if (type == float.class) return Float.class;
+    if (type == double.class) return Double.class;
+    if (type == void.class) return Void.class;
+    return type;
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Linker.java b/src/main/java/com/squareup/injector/internal/Linker.java
new file mode 100644
index 0000000..0dbe48b
--- /dev/null
+++ b/src/main/java/com/squareup/injector/internal/Linker.java
@@ -0,0 +1,256 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import com.squareup.injector.ObjectGraph;
+import java.lang.reflect.Constructor;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Queue;
+import java.util.Set;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Links bindings to their dependencies.
+ */
+public final class Linker {
+  private static final Logger LOGGER = Logger.getLogger(ObjectGraph.class.getName());
+  private static final Object UNINITIALIZED = new Object();
+
+  /** Bindings requiring a call to attach(). May contain deferred bindings. */
+  private final Queue<Binding<?>> toLink = new LinkedList<Binding<?>>();
+
+  /** True unless calls to requestBinding() were unable to satisfy the binding. */
+  private boolean attachSuccess = true;
+
+  /** All errors encountered during injection. */
+  private final List<String> errors = new ArrayList<String>();
+
+  /** All of the injector's bindings. This may contain unlinked bindings. */
+  private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
+
+  /**
+   * Adds all the bindings from {@code toInstall}. The bindings must be linked
+   * before they can be used.
+   */
+  public void installBindings(Map<String, Binding<?>> toInstall) {
+    for (Binding<?> binding : toInstall.values()) {
+      bindings.put(binding.provideKey, scope(binding));
+    }
+  }
+
+  /**
+   * Links requested bindings and installed bindings, plus all of their
+   * transitive dependencies. This creates JIT bindings as necessary to fill in
+   * the gaps.
+   *
+   * @return all bindings known by this linker, which will all be linked.
+   */
+  public Collection<Binding<?>> linkAll() {
+    for (Binding<?> binding : bindings.values()) {
+      if (!binding.linked) {
+        toLink.add(binding);
+      }
+    }
+    linkRequested();
+    return bindings.values();
+  }
+
+  /**
+   * Links all requested bindings plus their transitive dependencies. This
+   * creates JIT bindings as necessary to fill in the gaps.
+   */
+  public void linkRequested() {
+    Binding binding;
+    while ((binding = toLink.poll()) != null) {
+      if (binding instanceof DeferredBinding) {
+        String key = ((DeferredBinding<?>) binding).deferredKey;
+        if (bindings.containsKey(key)) {
+          continue; // A binding for this key has since been linked.
+        }
+        try {
+          Binding<?> jitBinding = createJitBinding(key, binding.requiredBy);
+          // Fail if the type of binding we got wasn't capable of what was requested.
+          if (!key.equals(jitBinding.provideKey) && !key.equals(jitBinding.membersKey)) {
+            throw new IllegalStateException("Unable to create binding for " + key);
+          }
+          // Enqueue the JIT binding so its own dependencies can be linked.
+          toLink.add(jitBinding);
+          putBinding(jitBinding);
+        } catch (Exception e) {
+          addError(e.getMessage() + " required by " + binding.requiredBy);
+          bindings.put(key, Binding.UNRESOLVED);
+        }
+      } else {
+        // Attempt to attach the binding to its dependencies. If any dependency
+        // is not available, the attach will fail. We'll enqueue creation of
+        // that dependency and retry the attachment later.
+        attachSuccess = true;
+        binding.attach(this);
+        if (attachSuccess) {
+          binding.linked = true;
+        } else {
+          toLink.add(binding);
+        }
+      }
+    }
+
+    if (!errors.isEmpty()) {
+      StringBuilder message = new StringBuilder();
+      message.append("Errors creating injector:");
+      for (String error : errors) {
+        message.append("\n  ").append(error);
+      }
+      throw new IllegalArgumentException(message.toString());
+    }
+  }
+
+  /**
+   * Creates a just-in-time binding for the key in {@code deferred}. The type of
+   * binding to be created depends on the key's type:
+   * <ul>
+   *   <li>Injections of {@code Provider<Foo>} and {@code MembersInjector<Bar>}
+   *       will delegate to the bindings of {@code Foo} and {@code Bar}
+   *       respectively.
+   *   <li>Injections of other types will use the injectable constructors of
+   *       those classes.
+   * </ul>
+   */
+  private Binding<?> createJitBinding(String key, Object requiredBy) throws ClassNotFoundException {
+    String delegateKey = Keys.getDelegateKey(key);
+    if (delegateKey != null) {
+      return new BuiltInBinding<Object>(key, requiredBy, delegateKey);
+    }
+
+    String className = Keys.getClassName(key);
+    if (className != null && !Keys.isAnnotated(key)) {
+      // First look for a generated InjectAdapter.
+      try {
+        Class<?> c = Class.forName(className + "$InjectAdapter");
+        Constructor<?> constructor = c.getConstructor();
+        constructor.setAccessible(true);
+        return (Binding<?>) constructor.newInstance();
+      } catch (Exception e) {
+        LOGGER.log(Level.FINE, "No generated inject adapter for " + className
+            + ". Falling back to reflection.", e);
+      }
+
+      // Handle class bindings by injecting @Inject-annotated members.
+      Class<?> c = Class.forName(className);
+      if (!c.isInterface()) {
+        return AtInjectBinding.create(c, Keys.isMembersInjection(key));
+      }
+    }
+
+    throw new IllegalArgumentException("No binding for " + key);
+  }
+
+  /**
+   * Returns the binding if it exists immediately. Otherwise this returns
+   * null. If the returned binding didn't exist or was unlinked, it will be
+   * enqueued to be linked.
+   */
+  public Binding<?> requestBinding(String key, Object requiredBy) {
+    Binding<?> binding = bindings.get(key);
+    if (binding == null) {
+      // We can't satisfy this binding. Make sure it'll work next time!
+      DeferredBinding<Object> deferredBinding = new DeferredBinding<Object>(key, requiredBy);
+      toLink.add(deferredBinding);
+      attachSuccess = false;
+      return null;
+    }
+
+    if (!binding.linked) {
+      toLink.add(binding); // This binding was never linked; link it now!
+    }
+
+    return binding;
+  }
+
+  private <T> void putBinding(Binding<T> binding) {
+    binding = scope(binding);
+
+    // At binding insertion time it's possible that another binding for the same
+    // key to already exist. This occurs when an @Provides method returns a type T
+    // and we also inject the members of that type.
+    if (binding.provideKey != null) {
+      putIfAbsent(bindings, binding.provideKey, binding);
+    }
+    if (binding.membersKey != null) {
+      putIfAbsent(bindings, binding.membersKey, binding);
+    }
+  }
+
+  /**
+   * Returns a scoped binding for {@code binding}.
+   */
+  private <T> Binding<T> scope(final Binding<T> binding) {
+    if (!binding.singleton) {
+      return binding;
+    }
+
+    return new Binding<T>(binding.provideKey, binding.membersKey, true, binding.requiredBy) {
+      private Object onlyInstance = UNINITIALIZED;
+      @Override public void attach(Linker linker) {
+        binding.attach(linker);
+      }
+      @Override public void injectMembers(T t) {
+        binding.injectMembers(t);
+      }
+      @SuppressWarnings("unchecked") // onlyInstance is either 'UNINITIALIZED' or a 'T'.
+      @Override public T get() {
+        if (onlyInstance == UNINITIALIZED) {
+          onlyInstance = binding.get();
+        }
+        return (T) onlyInstance;
+      }
+      @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+        binding.getDependencies(get, injectMembers);
+      }
+      @Override public String toString() {
+        return binding.toString();
+      }
+    };
+  }
+
+  /**
+   * Puts the mapping {@code key, value} in {@code map} if no mapping for {@code
+   * key} already exists.
+   */
+  private <K, V> void putIfAbsent(Map<K, V> map, K key, V value) {
+    V replaced = map.put(key, value); // Optimistic: prefer only one hash operation lookup.
+    if (replaced != null) {
+      map.put(key, replaced);
+    }
+  }
+
+  private void addError(String message) {
+    errors.add(message);
+  }
+
+  private static class DeferredBinding<T> extends Binding<T> {
+    final String deferredKey;
+    private DeferredBinding(String deferredKey, Object requiredBy) {
+      super(null, null, false, requiredBy);
+      this.deferredKey = deferredKey;
+    }
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/LruCache.java b/src/main/java/com/squareup/injector/internal/LruCache.java
new file mode 100644
index 0000000..f00d6c2
--- /dev/null
+++ b/src/main/java/com/squareup/injector/internal/LruCache.java
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+/**
+ * Private copy of {@code android.util.LruCache}.
+ */
+class LruCache<K, V> {
+  private final LinkedHashMap<K, V> map;
+
+  /** Size of this cache in units. Not necessarily the number of elements. */
+  private int size;
+  private int maxSize;
+
+  private int putCount;
+  private int createCount;
+  private int evictionCount;
+  private int hitCount;
+  private int missCount;
+
+  /**
+   * @param maxSize for caches that do not override {@link #sizeOf}, this is
+   *     the maximum number of entries in the cache. For all other caches,
+   *     this is the maximum sum of the sizes of the entries in this cache.
+   */
+  public LruCache(int maxSize) {
+    if (maxSize <= 0) {
+      throw new IllegalArgumentException("maxSize <= 0");
+    }
+    this.maxSize = maxSize;
+    this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
+  }
+
+  /**
+   * Returns the value for {@code key} if it exists in the cache or can be
+   * created by {@code #create}. If a value was returned, it is moved to the
+   * head of the queue. This returns null if a value is not cached and cannot
+   * be created.
+   */
+  public final V get(K key) {
+    if (key == null) {
+      throw new NullPointerException("key == null");
+    }
+
+    V mapValue;
+    synchronized (this) {
+      mapValue = map.get(key);
+      if (mapValue != null) {
+        hitCount++;
+        return mapValue;
+      }
+      missCount++;
+    }
+
+    /*
+    * Attempt to create a value. This may take a long time, and the map
+    * may be different when create() returns. If a conflicting value was
+    * added to the map while create() was working, we leave that value in
+    * the map and release the created value.
+    */
+
+    V createdValue = create(key);
+    if (createdValue == null) {
+      return null;
+    }
+
+    synchronized (this) {
+      createCount++;
+      mapValue = map.put(key, createdValue);
+
+      if (mapValue != null) {
+        // There was a conflict so undo that last put
+        map.put(key, mapValue);
+      } else {
+        size += safeSizeOf(key, createdValue);
+      }
+    }
+
+    if (mapValue != null) {
+      entryRemoved(false, key, createdValue, mapValue);
+      return mapValue;
+    } else {
+      trimToSize(maxSize);
+      return createdValue;
+    }
+  }
+
+  /**
+   * Caches {@code value} for {@code key}. The value is moved to the head of
+   * the queue.
+   *
+   * @return the previous value mapped by {@code key}.
+   */
+  public final V put(K key, V value) {
+    if (key == null || value == null) {
+      throw new NullPointerException("key == null || value == null");
+    }
+
+    V previous;
+    synchronized (this) {
+      putCount++;
+      size += safeSizeOf(key, value);
+      previous = map.put(key, value);
+      if (previous != null) {
+        size -= safeSizeOf(key, previous);
+      }
+    }
+
+    if (previous != null) {
+      entryRemoved(false, key, previous, value);
+    }
+
+    trimToSize(maxSize);
+    return previous;
+  }
+
+  /**
+   * @param maxSize the maximum size of the cache before returning. May be -1
+   *     to evict even 0-sized elements.
+   */
+  private void trimToSize(int maxSize) {
+    while (true) {
+      K key;
+      V value;
+      synchronized (this) {
+        if (size < 0 || (map.isEmpty() && size != 0)) {
+          throw new IllegalStateException(getClass().getName()
+              + ".sizeOf() is reporting inconsistent results!");
+        }
+
+        if (size <= maxSize || map.isEmpty()) {
+          break;
+        }
+
+        Map.Entry<K, V> toEvict = map.entrySet().iterator().next();
+        key = toEvict.getKey();
+        value = toEvict.getValue();
+        map.remove(key);
+        size -= safeSizeOf(key, value);
+        evictionCount++;
+      }
+
+      entryRemoved(true, key, value, null);
+    }
+  }
+
+  /**
+   * Removes the entry for {@code key} if it exists.
+   *
+   * @return the previous value mapped by {@code key}.
+   */
+  public final V remove(K key) {
+    if (key == null) {
+      throw new NullPointerException("key == null");
+    }
+
+    V previous;
+    synchronized (this) {
+      previous = map.remove(key);
+      if (previous != null) {
+        size -= safeSizeOf(key, previous);
+      }
+    }
+
+    if (previous != null) {
+      entryRemoved(false, key, previous, null);
+    }
+
+    return previous;
+  }
+
+  /**
+   * Called for entries that have been evicted or removed. This method is
+   * invoked when a value is evicted to make space, removed by a call to
+   * {@link #remove}, or replaced by a call to {@link #put}. The default
+   * implementation does nothing.
+   *
+   * <p>The method is called without synchronization: other threads may
+   * access the cache while this method is executing.
+   *
+   * @param evicted true if the entry is being removed to make space, false
+   *     if the removal was caused by a {@link #put} or {@link #remove}.
+   * @param newValue the new value for {@code key}, if it exists. If non-null,
+   *     this removal was caused by a {@link #put}. Otherwise it was caused by
+   *     an eviction or a {@link #remove}.
+   */
+  protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {
+  }
+
+  /**
+   * Called after a cache miss to compute a value for the corresponding key.
+   * Returns the computed value or null if no value can be computed. The
+   * default implementation returns null.
+   *
+   * <p>The method is called without synchronization: other threads may
+   * access the cache while this method is executing.
+   *
+   * <p>If a value for {@code key} exists in the cache when this method
+   * returns, the created value will be released with {@link #entryRemoved}
+   * and discarded. This can occur when multiple threads request the same key
+   * at the same time (causing multiple values to be created), or when one
+   * thread calls {@link #put} while another is creating a value for the same
+   * key.
+   */
+  protected V create(K key) {
+    return null;
+  }
+
+  private int safeSizeOf(K key, V value) {
+    int result = sizeOf(key, value);
+    if (result < 0) {
+      throw new IllegalStateException("Negative size: " + key + "=" + value);
+    }
+    return result;
+  }
+
+  /**
+   * Returns the size of the entry for {@code key} and {@code value} in
+   * user-defined units.  The default implementation returns 1 so that size
+   * is the number of entries and max size is the maximum number of entries.
+   *
+   * <p>An entry's size must not change while it is in the cache.
+   */
+  protected int sizeOf(K key, V value) {
+    return 1;
+  }
+
+  /**
+   * Clear the cache, calling {@link #entryRemoved} on each removed entry.
+   */
+  public final void evictAll() {
+    trimToSize(-1); // -1 will evict 0-sized elements
+  }
+
+  /**
+   * For caches that do not override {@link #sizeOf}, this returns the number
+   * of entries in the cache. For all other caches, this returns the sum of
+   * the sizes of the entries in this cache.
+   */
+  public synchronized final int size() {
+    return size;
+  }
+
+  /**
+   * For caches that do not override {@link #sizeOf}, this returns the maximum
+   * number of entries in the cache. For all other caches, this returns the
+   * maximum sum of the sizes of the entries in this cache.
+   */
+  public synchronized final int maxSize() {
+    return maxSize;
+  }
+
+  /**
+   * Returns the number of times {@link #get} returned a value.
+   */
+  public synchronized final int hitCount() {
+    return hitCount;
+  }
+
+  /**
+   * Returns the number of times {@link #get} returned null or required a new
+   * value to be created.
+   */
+  public synchronized final int missCount() {
+    return missCount;
+  }
+
+  /**
+   * Returns the number of times {@link #create(Object)} returned a value.
+   */
+  public synchronized final int createCount() {
+    return createCount;
+  }
+
+  /**
+   * Returns the number of times {@link #put} was called.
+   */
+  public synchronized final int putCount() {
+    return putCount;
+  }
+
+  /**
+   * Returns the number of values that have been evicted.
+   */
+  public synchronized final int evictionCount() {
+    return evictionCount;
+  }
+
+  /**
+   * Returns a copy of the current contents of the cache, ordered from least
+   * recently accessed to most recently accessed.
+   */
+  public synchronized final Map<K, V> snapshot() {
+    return new LinkedHashMap<K, V>(map);
+  }
+
+  @Override public synchronized final String toString() {
+    int accesses = hitCount + missCount;
+    int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;
+    return String.format("LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]",
+        maxSize, hitCount, missCount, hitPercent);
+  }
+}
\ No newline at end of file
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ModuleAdapter.java b/src/main/java/com/squareup/injector/internal/ModuleAdapter.java
new file mode 100644
index 0000000..b1ffc9b
--- /dev/null
+++ b/src/main/java/com/squareup/injector/internal/ModuleAdapter.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import com.squareup.injector.Module;
+import com.squareup.injector.ObjectGraph;
+import com.squareup.injector.Provides;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.util.Map;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Extracts bindings from an {@code @Module}-annotated class.
+ */
+public abstract class ModuleAdapter<T> {
+  private static final Logger LOGGER = Logger.getLogger(ObjectGraph.class.getName());
+
+  public final String[] entryPoints;
+  public final Class<?>[] staticInjections;
+  public final boolean overrides;
+
+  protected ModuleAdapter(String[] entryPoints, Class<?>[] staticInjections, boolean overrides) {
+    this.entryPoints = entryPoints;
+    this.staticInjections = staticInjections;
+    this.overrides = overrides;
+  }
+
+  /**
+   * Returns bindings for the {@code @Provides} methods of {@code module}. The
+   * returned bindings must be linked before they can be used to inject values.
+   */
+  public abstract void getBindings(T module, Map<String, Binding<?>> map);
+
+  /**
+   * Returns a module adapter for {@code module}, preferring a code-generated
+   * implementation and falling back to a reflective implementation.
+   */
+  @SuppressWarnings("unchecked") // Runtime checks validate that the result type matches 'T'.
+  public static <T> ModuleAdapter<T> get(T module) {
+    Class<?> moduleClass = module.getClass();
+    try {
+      String adapter = moduleClass.getName() + "$ModuleAdapter";
+      Class<?> c = Class.forName(adapter);
+      Constructor<?> constructor = c.getConstructor();
+      constructor.setAccessible(true);
+      return (ModuleAdapter) constructor.newInstance();
+    } catch (Exception e) {
+      LOGGER.log(Level.FINE, "No generated module for " + moduleClass.getName()
+          + ". Falling back to reflection.", e);
+    }
+
+    Module annotation = moduleClass.getAnnotation(Module.class);
+    if (annotation == null) {
+      throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
+    }
+    return (ModuleAdapter) new ReflectiveModuleAdapter(moduleClass, annotation);
+  }
+
+  static class ReflectiveModuleAdapter extends ModuleAdapter<Object> {
+    final Class<?> moduleClass;
+
+    ReflectiveModuleAdapter(Class<?> moduleClass, Module annotation) {
+      super(toMemberKeys(annotation.entryPoints()), annotation.staticInjections(),
+          annotation.overrides());
+      this.moduleClass = moduleClass;
+    }
+
+    private static String[] toMemberKeys(Class<?>[] entryPoints) {
+      String[] result = new String[entryPoints.length];
+      for (int i = 0; i < entryPoints.length; i++) {
+        result[i] = Keys.getMembersKey(entryPoints[i]);
+      }
+      return result;
+    }
+
+    @Override public void getBindings(Object module, Map<String, Binding<?>> bindings) {
+      // Fall back to runtime reflection.
+      for (Class<?> c = moduleClass; c != Object.class; c = c.getSuperclass()) {
+        for (Method method : c.getDeclaredMethods()) {
+          if (!method.isAnnotationPresent(Provides.class)) {
+            continue;
+          }
+          Binding<?> binding = methodToBinding(module, method);
+          bindings.put(binding.provideKey, binding);
+        }
+      }
+    }
+
+    private <T> Binding<T> methodToBinding(Object module, Method method) {
+      String key = Keys.get(method.getGenericReturnType(), method.getAnnotations(), method);
+      return new ProviderMethodBinding<T>(method, key, module);
+    }
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ProblemDetector.java b/src/main/java/com/squareup/injector/internal/ProblemDetector.java
new file mode 100644
index 0000000..41127d9
--- /dev/null
+++ b/src/main/java/com/squareup/injector/internal/ProblemDetector.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+import java.util.Set;
+
+/**
+ * Detects problems like cyclic dependencies.
+ */
+public final class ProblemDetector {
+  Set<Binding<?>> done = new HashSet<Binding<?>>();
+  Queue<Binding<?>> roots = new LinkedList<Binding<?>>();
+  List<Binding<?>> path = new LinkedList<Binding<?>>();
+
+  public void detectProblems(Collection<Binding<?>> bindings) {
+    roots.addAll(bindings);
+
+    StringBuilder message = null;
+    Binding<?> root;
+    while ((root = roots.poll()) != null) {
+      if (done.add(root)) {
+        try {
+          detectCircularDependencies(root);
+        } catch (IllegalStateException e) {
+          if (message == null) {
+            message = new StringBuilder().append("Graph problems:");
+          }
+          message.append("\n  ").append(e.getMessage());
+        }
+      }
+    }
+
+    if (message != null) {
+      throw new RuntimeException(message.toString());
+    }
+  }
+
+  private void detectCircularDependencies(Binding<?> binding) {
+    int index = path.indexOf(binding);
+    if (index != -1) {
+      StringBuilder message = new StringBuilder()
+          .append("Dependency cycle:");
+      for (int i = index; i < path.size(); i++) {
+        message.append("\n    ").append(i - index).append(". ")
+            .append(path.get(i).provideKey).append(" bound by ").append(path.get(i));
+      }
+      message.append("\n    ").append(0).append(". ").append(binding.provideKey);
+      throw new IllegalStateException(message.toString());
+    }
+
+    path.add(binding);
+    try {
+      // TODO: perform 2-phase injection to avoid some circular dependency problems
+      Set<Binding<?>> dependencies = new LinkedHashSet<Binding<?>>();
+      binding.getDependencies(dependencies, dependencies);
+      for (Binding<?> dependency : dependencies) {
+        if (dependency instanceof BuiltInBinding) {
+          roots.add(((BuiltInBinding<?>) dependency).getDelegate());
+        } else {
+          detectCircularDependencies(dependency);
+        }
+      }
+    } finally {
+      path.remove(path.size() - 1);
+    }
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java b/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
new file mode 100644
index 0000000..f475269
--- /dev/null
+++ b/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import java.util.Set;
+import javax.inject.Singleton;
+
+/**
+ * Invokes a method to provide a value. The method's parameters are injected.
+ */
+final class ProviderMethodBinding<T> extends Binding<T> {
+  private Binding[] parameters;
+  private final Method method;
+  private final Object instance;
+
+  public ProviderMethodBinding(Method method, String key, Object instance) {
+    super(key, null, method.isAnnotationPresent(Singleton.class), method);
+    this.method = method;
+    this.instance = instance;
+    method.setAccessible(true);
+  }
+
+  @Override public void attach(Linker linker) {
+    Type[] types = method.getGenericParameterTypes();
+    Annotation[][] annotations = method.getParameterAnnotations();
+    parameters = new Binding[types.length];
+    for (int i = 0; i < parameters.length; i++) {
+      String key = Keys.get(types[i], annotations[i], method + " parameter " + i);
+      parameters[i] = linker.requestBinding(key, method);
+    }
+  }
+
+  @SuppressWarnings("unchecked") // The caller is required to make 'method' and 'T' match
+  @Override public T get() {
+    Object[] args = new Object[parameters.length];
+    for (int i = 0; i < parameters.length; i++) {
+      args[i] = parameters[i].get();
+    }
+    try {
+      return (T) method.invoke(instance, args);
+    } catch (IllegalAccessException e) {
+      throw new RuntimeException(e);
+    } catch (InvocationTargetException e) {
+      throw new RuntimeException(e.getCause());
+    }
+  }
+
+  @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+    for (Binding binding : parameters) {
+      get.add(binding);
+    }
+  }
+
+  @Override public String toString() {
+    return method.toString();
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/StaticInjection.java b/src/main/java/com/squareup/injector/internal/StaticInjection.java
new file mode 100644
index 0000000..93a8398
--- /dev/null
+++ b/src/main/java/com/squareup/injector/internal/StaticInjection.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2012 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.List;
+import javax.inject.Inject;
+
+/**
+ * Injects the static fields of a class.
+ *
+ * @author Jesse Wilson
+ */
+public final class StaticInjection {
+  private final Field[] fields;
+  private Binding<?>[] bindings;
+
+  private StaticInjection(Field[] fields) {
+    this.fields = fields;
+  }
+
+  public static StaticInjection get(Class<?> c) {
+    List<Field> fields = new ArrayList<Field>();
+    for (Field field : c.getDeclaredFields()) {
+      if (field.getAnnotation(Inject.class) == null
+          || !Modifier.isStatic(field.getModifiers())) {
+        continue;
+      }
+      field.setAccessible(true);
+      fields.add(field);
+    }
+    if (fields.isEmpty()) {
+      throw new IllegalArgumentException("No static injections: " + c.getName());
+    }
+    return new StaticInjection(fields.toArray(new Field[fields.size()]));
+  }
+
+  public void attach(Linker linker) {
+    bindings = new Binding<?>[fields.length];
+    for (int i = 0; i < fields.length; i++) {
+      Field field = fields[i];
+      String key = Keys.get(field.getGenericType(), field.getAnnotations(), field);
+      bindings[i] = linker.requestBinding(key, field);
+    }
+  }
+
+  public void inject() {
+    try {
+      for (int f = 0; f < fields.length; f++) {
+        fields[f].set(null, bindings[f].get());
+      }
+    } catch (IllegalAccessException e) {
+      throw new AssertionError(e);
+    }
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/UniqueMap.java b/src/main/java/com/squareup/injector/internal/UniqueMap.java
new file mode 100644
index 0000000..b369005
--- /dev/null
+++ b/src/main/java/com/squareup/injector/internal/UniqueMap.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+/**
+ * A map that fails when existing values are clobbered.
+ */
+public class UniqueMap<K, V> extends LinkedHashMap<K, V> {
+  @Override public V put(K key, V value) {
+    V clobbered = super.put(key, value);
+    if (clobbered != null) {
+      super.put(key, clobbered); // Put things back as they were.
+      throw new IllegalArgumentException("Duplicate:\n    " + clobbered + "\n    " + value);
+    }
+    return null;
+  }
+  @Override public void putAll(Map<? extends K, ? extends V> map) {
+    for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {
+      put(entry.getKey(), entry.getValue());
+    }
+  }
+}
/Fim/
diff --git a/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/src/main/resources/META-INF/services/javax.annotation.processing.Processor
new file mode 100644
index 0000000..a453d47
--- /dev/null
+++ b/src/main/resources/META-INF/services/javax.annotation.processing.Processor
@@ -0,0 +1,2 @@
+com.squareup.codegen.InjectProcessor
+com.squareup.codegen.ProvidesProcessor
/Fim/
diff --git a/src/test/java/com/squareup/codegen/JavaWriterTest.java b/src/test/java/com/squareup/codegen/JavaWriterTest.java
new file mode 100644
index 0000000..379998f
--- /dev/null
+++ b/src/test/java/com/squareup/codegen/JavaWriterTest.java
@@ -0,0 +1,271 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.codegen;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.lang.reflect.Modifier;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+public final class JavaWriterTest {
+  private final StringWriter stringWriter = new StringWriter();
+  private final JavaWriter javaWriter = new JavaWriter(stringWriter);
+
+  @Test public void typeDeclaration() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", Modifier.PUBLIC | Modifier.FINAL);
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "public final class Foo {\n"
+        + "}\n");
+  }
+
+  @Test public void fieldDeclaration() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.field("java.lang.String", "string", Modifier.PRIVATE | Modifier.STATIC);
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  private static String string;\n"
+        + "}\n");
+  }
+
+  @Test public void fieldDeclarationWithInitialValue() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.field("java.lang.String", "string", 0, "\"bar\" + \"baz\"");
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  String string = \"bar\" + \"baz\";\n"
+        + "}\n");
+  }
+
+  @Test public void abstractMethodDeclaration() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod("java.lang.String", "foo", Modifier.ABSTRACT | Modifier.PUBLIC,
+        "java.lang.Object", "object", "java.lang.String", "s");
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  public abstract String foo(Object object, String s);\n"
+        + "}\n");
+  }
+
+  @Test public void nonAbstractMethodDeclaration() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  int foo(String s) {\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  @Test public void constructorDeclaration() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod(null, "com.squareup.Foo", Modifier.PUBLIC, "java.lang.String", "s");
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  public Foo(String s) {\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  @Test public void statement() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
+    javaWriter.statement("int j = s.length() + %s", 13);
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  int foo(String s) {\n"
+        + "    int j = s.length() + 13;\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  @Test public void addImport() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.addImport("java.util.ArrayList");
+    javaWriter.beginType("com.squareup.Foo", "class", Modifier.PUBLIC | Modifier.FINAL);
+    javaWriter.field("java.util.ArrayList", "list", 0, "new java.util.ArrayList()");
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "import java.util.ArrayList;\n"
+        + "public final class Foo {\n"
+        + "  ArrayList list = new java.util.ArrayList();\n"
+        + "}\n");
+  }
+
+  @Test public void addImportFromSubpackage() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", Modifier.PUBLIC | Modifier.FINAL);
+    javaWriter.field("com.squareup.bar.Baz", "baz", 0);
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "public final class Foo {\n"
+        + "  com.squareup.bar.Baz baz;\n"
+        + "}\n");
+  }
+
+  @Test public void ifControlFlow() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
+    javaWriter.beginControlFlow("if (s.isEmpty())");
+    javaWriter.statement("int j = s.length() + %s", 13);
+    javaWriter.endControlFlow();
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  int foo(String s) {\n"
+        + "    if (s.isEmpty()) {\n"
+        + "      int j = s.length() + 13;\n"
+        + "    }\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  @Test public void doWhileControlFlow() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
+    javaWriter.beginControlFlow("do");
+    javaWriter.statement("int j = s.length() + %s", 13);
+    javaWriter.endControlFlow("while (s.isEmpty())");
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  int foo(String s) {\n"
+        + "    do {\n"
+        + "      int j = s.length() + 13;\n"
+        + "    } while (s.isEmpty());\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  @Test public void tryCatchFinallyControlFlow() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
+    javaWriter.beginControlFlow("try");
+    javaWriter.statement("int j = s.length() + %s", 13);
+    javaWriter.nextControlFlow("catch (RuntimeException e)");
+    javaWriter.statement("e.printStackTrace()");
+    javaWriter.nextControlFlow("finally");
+    javaWriter.statement("int k = %s", 13);
+    javaWriter.endControlFlow();
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  int foo(String s) {\n"
+        + "    try {\n"
+        + "      int j = s.length() + 13;\n"
+        + "    } catch (RuntimeException e) {\n"
+        + "      e.printStackTrace();\n"
+        + "    } finally {\n"
+        + "      int k = 13;\n"
+        + "    }\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  @Test public void annotatedType() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.addImport("javax.inject.Singleton");
+    javaWriter.annotation("javax.inject.Singleton");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "import javax.inject.Singleton;\n"
+        + "@Singleton\n"
+        + "class Foo {\n"
+        + "}\n");
+  }
+
+  @Test public void annotatedMember() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.annotation(Deprecated.class);
+    javaWriter.field("java.lang.String", "s", 0);
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  @Deprecated\n"
+        + "  String s;\n"
+        + "}\n");
+  }
+
+  @Test public void parameterizedType() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.addImport("java.util.Map");
+    javaWriter.addImport("java.util.Date");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.field("java.util.Map<java.lang.String, java.util.Date>", "map", 0);
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "import java.util.Map;\n"
+        + "import java.util.Date;\n"
+        + "class Foo {\n"
+        + "  Map<String, Date> map;\n"
+        + "}\n");
+  }
+
+  @Test public void testStringLiteral() {
+    assertThat(JavaWriter.stringLiteral("")).isEqualTo("\"\"");
+    assertThat(JavaWriter.stringLiteral("JavaWriter")).isEqualTo("\"JavaWriter\"");
+    assertThat(JavaWriter.stringLiteral("\\")).isEqualTo("\"\\\\\"");
+    assertThat(JavaWriter.stringLiteral("\"")).isEqualTo("\"\\\"\"");
+    assertThat(JavaWriter.stringLiteral("\t")).isEqualTo("\"\\\t\"");
+    assertThat(JavaWriter.stringLiteral("\n")).isEqualTo("\"\\\n\"");
+  }
+
+  private void assertCode(String expected) {
+    assertThat(stringWriter.toString()).isEqualTo(expected);
+  }
+}
/Fim/
diff --git a/src/test/java/com/squareup/injector/InjectStaticsTest.java b/src/test/java/com/squareup/injector/InjectStaticsTest.java
new file mode 100644
index 0000000..5a1f735
--- /dev/null
+++ b/src/test/java/com/squareup/injector/InjectStaticsTest.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2012 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import javax.inject.Inject;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+@SuppressWarnings("unused")
+public final class InjectStaticsTest {
+  @Before public void setUp() {
+    InjectsOneField.staticField = null;
+    InjectsStaticAndNonStatic.staticField = null;
+  }
+
+  public static class InjectsOneField {
+    @Inject static String staticField;
+  }
+
+  public static class InjectsStaticAndNonStatic {
+    @Inject Integer nonStaticField;
+    @Inject static String staticField;
+  }
+
+  @Test public void injectStatics() {
+    @Module(staticInjections = InjectsOneField.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "static";
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    assertThat(InjectsOneField.staticField).isNull();
+    graph.injectStatics();
+    assertThat(InjectsOneField.staticField).isEqualTo("static");
+  }
+
+  @Test public void instanceFieldsNotInjectedByInjectStatics() {
+    @Module(
+        staticInjections = InjectsStaticAndNonStatic.class,
+        entryPoints = InjectsStaticAndNonStatic.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "static";
+      }
+      @Provides Integer provideInteger() {
+        throw new AssertionError();
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    assertThat(InjectsStaticAndNonStatic.staticField).isNull();
+    graph.injectStatics();
+    assertThat(InjectsStaticAndNonStatic.staticField).isEqualTo("static");
+  }
+
+  @Test public void staticFieldsNotInjectedByInjectMembers() {
+    @Module(
+        staticInjections = InjectsStaticAndNonStatic.class,
+        entryPoints = InjectsStaticAndNonStatic.class)
+    class TestModule {
+      @Provides String provideString() {
+        throw new AssertionError();
+      }
+      @Provides Integer provideInteger() {
+        return 5;
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    assertThat(InjectsStaticAndNonStatic.staticField).isNull();
+    InjectsStaticAndNonStatic object = new InjectsStaticAndNonStatic();
+    graph.inject(object);
+    assertThat(InjectsStaticAndNonStatic.staticField).isNull();
+    assertThat(object.nonStaticField).isEqualTo(5);
+  }
+}
/Fim/
diff --git a/src/test/java/com/squareup/injector/InjectionTest.java b/src/test/java/com/squareup/injector/InjectionTest.java
new file mode 100644
index 0000000..379f8e2
--- /dev/null
+++ b/src/test/java/com/squareup/injector/InjectionTest.java
@@ -0,0 +1,507 @@
+/*
+ * Copyright (C) 2010 Google Inc.
+ * Copyright (C) 2012 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import java.util.AbstractList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.RandomAccess;
+import javax.inject.Inject;
+import javax.inject.Named;
+import javax.inject.Provider;
+import javax.inject.Singleton;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+@SuppressWarnings("unused")
+public final class InjectionTest {
+  @Test public void basicInjection() {
+    class TestEntryPoint {
+      @Inject Provider<G> gProvider;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides E provideE(F f) {
+        return new E(f);
+      }
+      @Provides F provideF() {
+        return new F();
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    G g = entryPoint.gProvider.get();
+    assertThat(g.a).isNotNull();
+    assertThat(g.b).isNotNull();
+    assertThat(g.c).isNotNull();
+    assertThat(g.d).isNotNull();
+    assertThat(g.e).isNotNull();
+    assertThat(g.e.f).isNotNull();
+  }
+
+  static class A {
+    @Inject A() {}
+  }
+
+  static class B {
+    @Inject B() {}
+  }
+
+  @Singleton
+  static class C {
+    @Inject C() {}
+  }
+
+  @Singleton
+  static class D {
+    @Inject D() {}
+  }
+
+  static class E {
+    F f;
+    E(F f) {
+      this.f = f;
+    }
+  }
+
+  static class F {}
+
+  static class G {
+    @Inject A a;
+    @Inject B b;
+    C c;
+    D d;
+    @Inject E e;
+    @Inject G(C c, D d) {
+      this.c = c;
+      this.d = d;
+    }
+  }
+
+  @Test public void providerInjection() {
+    class TestEntryPoint {
+      @Inject Provider<A> aProvider;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+
+    assertThat(entryPoint.aProvider.get()).isNotNull();
+    assertThat(entryPoint.aProvider.get()).isNotNull();
+    assertThat(entryPoint.aProvider.get()).isNotSameAs(entryPoint.aProvider.get());
+  }
+
+
+  @Test public void singletons() {
+    class TestEntryPoint {
+      @Inject Provider<F> fProvider;
+      @Inject Provider<I> iProvider;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides @Singleton F provideF() {
+        return new F();
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    assertThat(entryPoint.fProvider.get()).isSameAs(entryPoint.fProvider.get());
+    assertThat(entryPoint.iProvider.get()).isSameAs(entryPoint.iProvider.get());
+  }
+
+  @Singleton
+  static class I {
+    @Inject I() {}
+  }
+
+  @Test public void bindingAnnotations() {
+    final A one = new A();
+    final A two = new A();
+
+    class TestEntryPoint {
+      @Inject A a;
+      @Inject @Named("one") A aOne;
+      @Inject @Named("two") A aTwo;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides @Named("one") A getOne() {
+        return one;
+      }
+      @Provides @Named("two") A getTwo() {
+        return two;
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    assertThat(entryPoint.a).isNotNull();
+    assertThat(one).isSameAs(entryPoint.aOne);
+    assertThat(two).isSameAs(entryPoint.aTwo);
+  }
+
+  @Test public void singletonBindingAnnotationAndProvider() {
+    class TestEntryPoint {
+      @Inject Provider<L> lProvider;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      A a1;
+      A a2;
+
+      @Provides @Singleton @Named("one") F provideF(Provider<A> aProvider) {
+        a1 = aProvider.get();
+        a2 = aProvider.get();
+        return new F();
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    TestModule module = new TestModule();
+    ObjectGraph.get(module).inject(entryPoint);
+    entryPoint.lProvider.get();
+
+    assertThat(module.a1).isNotNull();
+    assertThat(module.a2).isNotNull();
+    assertThat(module.a1).isNotSameAs(module.a2);
+    assertThat(entryPoint.lProvider.get()).isSameAs(entryPoint.lProvider.get());
+  }
+
+  @Singleton
+  public static class L {
+    @Inject @Named("one") F f;
+    @Inject Provider<L> lProvider;
+  }
+
+  @Test public void singletonInGraph() {
+    class TestEntryPoint {
+      @Inject N n1;
+      @Inject N n2;
+      @Inject F f1;
+      @Inject F f2;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides @Singleton F provideF() {
+        return new F();
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+
+    assertThat(entryPoint.f1).isSameAs(entryPoint.f2);
+    assertThat(entryPoint.f1).isSameAs(entryPoint.n1.f1);
+    assertThat(entryPoint.f1).isSameAs(entryPoint.n1.f2);
+    assertThat(entryPoint.f1).isSameAs(entryPoint.n2.f1);
+    assertThat(entryPoint.f1).isSameAs(entryPoint.n2.f2);
+    assertThat(entryPoint.f1).isSameAs(entryPoint.n1.fProvider.get());
+    assertThat(entryPoint.f1).isSameAs(entryPoint.n2.fProvider.get());
+  }
+
+  public static class N {
+    @Inject F f1;
+    @Inject F f2;
+    @Inject Provider<F> fProvider;
+  }
+
+  @Test public void noJitBindingsForAnnotations() {
+    class TestEntryPoint {
+      @Inject @Named("a") A a;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+    }
+
+    try {
+      ObjectGraph.get(new TestModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void subclasses() {
+    class TestEntryPoint {
+      @Inject Q q;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides F provideF() {
+        return new F();
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    assertThat(entryPoint.q.f).isNotNull();
+  }
+
+  public static class P {
+    @Inject F f;
+  }
+
+  public static class Q extends P {
+    @Inject Q() {}
+  }
+
+  @Test public void singletonsAreNotEager() {
+    class TestEntryPoint {
+      @Inject Provider<A> aProvider;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      boolean sInjected = false;
+
+      @Provides F provideF(R r) {
+        return new F();
+      }
+
+      @Provides @Singleton S provideS() {
+        sInjected = true;
+        return new S();
+      }
+    }
+
+    R.injected = false;
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    TestModule module = new TestModule();
+    ObjectGraph.get(module).inject(entryPoint);
+
+    assertThat(R.injected).isFalse();
+    assertThat(module.sInjected).isFalse();
+  }
+
+  @Singleton
+  static class R {
+    static boolean injected = false;
+    @Inject R() {
+      injected = true;
+    }
+  }
+
+  static class S {}
+
+  @Test public void providerMethodsConflict() {
+    @Module
+    class TestModule {
+      @Provides A provideA1() {
+        throw new AssertionError();
+      }
+      @Provides A provideA2() {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      ObjectGraph.get(new TestModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void singletonsInjectedOnlyIntoProviders() {
+    class TestEntryPoint {
+      @Inject Provider<A> aProvider;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides @Singleton A provideA() {
+        return new A();
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    assertThat(entryPoint.aProvider.get()).isSameAs(entryPoint.aProvider.get());
+  }
+
+  @Test public void moduleOverrides() {
+    class TestEntryPoint {
+      @Inject Provider<E> eProvider;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class BaseModule {
+      @Provides F provideF() {
+        throw new AssertionError();
+      }
+      @Provides E provideE(F f) {
+        return new E(f);
+      }
+    }
+
+    @Module(overrides = true)
+    class OverridesModule {
+      @Provides F provideF() {
+        return new F();
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new BaseModule(), new OverridesModule()).inject(entryPoint);
+    E e = entryPoint.eProvider.get();
+    assertThat(e).isNotNull();
+    assertThat(e.f).isNotNull();
+  }
+
+  @Test public void noJitBindingsForInterfaces() {
+    class TestEntryPoint {
+      @Inject RandomAccess randomAccess;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+    }
+
+    try {
+      ObjectGraph.get(new TestModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void noProvideBindingsForAbstractClasses() {
+    class TestEntryPoint {
+      @Inject AbstractList abstractList;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+    }
+
+    try {
+      ObjectGraph.get(new TestModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  static class ExtendsParameterizedType extends AbstractList<Integer> {
+    @Inject String string;
+    @Override public Integer get(int i) {
+      throw new AssertionError();
+    }
+    @Override public int size() {
+      throw new AssertionError();
+    }
+  }
+
+  /**
+   * We've had bugs where we look for the wrong keys when a class extends a
+   * parameterized class. Explicitly test that we can inject such classes.
+   */
+  @Test public void extendsParameterizedType() {
+    class TestEntryPoint {
+      @Inject ExtendsParameterizedType extendsParameterizedType;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    assertThat(entryPoint.extendsParameterizedType.string).isEqualTo("injected");
+  }
+
+  @Test public void injectParameterizedType() {
+    class TestEntryPoint {
+      @Inject List<String> listOfStrings;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides List<String> provideList() {
+        return Arrays.asList("a", "b");
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    assertThat(entryPoint.listOfStrings).isEqualTo(Arrays.asList("a", "b"));
+  }
+
+  @Test public void injectWilcardType() {
+    class TestEntryPoint {
+      @Inject List<? extends Number> listOfNumbers;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides List<? extends Number> provideList() {
+        return Arrays.asList(1, 2);
+      }
+    }
+
+    try {
+      ObjectGraph.get(new TestModule());
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  @Test public void noConstructorInjectionsForClassesWithTypeParameters() {
+    class Parameterized<T> {
+      @Inject String string;
+    }
+
+    class TestEntryPoint {
+      @Inject Parameterized<Long> parameterized;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    try {
+      ObjectGraph.get(new TestModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void moduleWithNoProvidesMethods() {
+    @Module
+    class TestModule {
+    }
+
+    ObjectGraph.get(new TestModule());
+  }
+}
/Fim/
diff --git a/src/test/java/com/squareup/injector/LazyInjectionTest.java b/src/test/java/com/squareup/injector/LazyInjectionTest.java
new file mode 100644
index 0000000..430acbd
--- /dev/null
+++ b/src/test/java/com/squareup/injector/LazyInjectionTest.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2012 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import javax.inject.Inject;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+public final class LazyInjectionTest {
+  @Test public void getLazyDoesNotCauseEntryPointsToBeLoaded() {
+    @Module(entryPoints = LazyEntryPoint.class)
+    class TestModule {
+    }
+
+    ObjectGraph.getLazy(new TestModule());
+    assertThat(lazyEntryPointLoaded).isFalse();
+  }
+
+  private static boolean lazyEntryPointLoaded = false;
+  static class LazyEntryPoint {
+    static {
+      lazyEntryPointLoaded = true;
+    }
+  }
+
+  @Test public void getLazyDoesNotCauseProvidesParametersToBeLoaded() {
+    @Module
+    class TestModule {
+      @Provides Object provideObject(LazyProvidesParameter parameter) {
+        throw new AssertionError();
+      }
+    }
+
+    ObjectGraph.getLazy(new TestModule());
+    assertThat(lazyProvidesParameterLoaded).isFalse();
+  }
+
+  private static boolean lazyProvidesParameterLoaded = false;
+  static class LazyProvidesParameter {
+    static {
+      lazyProvidesParameterLoaded = true;
+    }
+  }
+
+  @Test public void getLazyDoesNotCauseProvidesResultToBeLoaded() {
+    @Module
+    class TestModule {
+      @Provides LazyProvidesResult provideLazy() {
+        throw new AssertionError();
+      }
+    }
+
+    ObjectGraph.getLazy(new TestModule());
+    assertThat(lazyProvidesResultLoaded).isFalse();
+  }
+
+  private static boolean lazyProvidesResultLoaded = false;
+  static class LazyProvidesResult {
+    static {
+      lazyProvidesResultLoaded = true;
+    }
+  }
+
+  @Test public void getLazyDoesNotCauseStaticsToBeLoaded() {
+    @Module(staticInjections = LazyInjectStatics.class)
+    class TestModule {
+    }
+
+    ObjectGraph.getLazy(new TestModule());
+    assertThat(LazyInjectStaticsLoaded).isFalse();
+  }
+
+  private static boolean LazyInjectStaticsLoaded = false;
+  static class LazyInjectStatics {
+    static {
+      LazyInjectStaticsLoaded = true;
+    }
+  }
+
+  @Test public void lazyInjectionRequiresProvidesMethod() {
+    class TestEntryPoint {
+      @Inject String injected;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides String provideString(Integer integer) {
+        return integer.toString();
+      }
+      @Provides Integer provideInteger() {
+        return 5;
+      }
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.getLazy(new TestModule());
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    objectGraph.inject(entryPoint);
+    assertThat(entryPoint.injected).isEqualTo("5");
+  }
+}
/Fim/
diff --git a/src/test/java/com/squareup/injector/MembersInjectorTest.java b/src/test/java/com/squareup/injector/MembersInjectorTest.java
new file mode 100644
index 0000000..962cfcc
--- /dev/null
+++ b/src/test/java/com/squareup/injector/MembersInjectorTest.java
@@ -0,0 +1,212 @@
+/*
+ * Copyright (C) 2012 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Singleton;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests MembersInjector injection, and how injector features interact with
+ * types unconstructable types (types that support members injection only).
+ */
+@SuppressWarnings("unused")
+public final class MembersInjectorTest {
+  @Test public void injectMembers() {
+    class TestEntryPoint {
+      @Inject MembersInjector<Injectable> membersInjector;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class StringModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new StringModule()).inject(entryPoint);
+    Injectable injectable = new Injectable();
+    entryPoint.membersInjector.injectMembers(injectable);
+    assertThat(injectable.injected).isEqualTo("injected");
+  }
+
+  static class Injectable {
+    @Inject String injected;
+  }
+
+  static class Unconstructable {
+    final String constructor;
+    @Inject String injected;
+    Unconstructable(String constructor) {
+      this.constructor = constructor;
+    }
+  }
+
+  @Test public void membersInjectorOfUnconstructableIsOkay() {
+    class TestEntryPoint {
+      @Inject MembersInjector<Unconstructable> membersInjector;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class StringModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new StringModule()).inject(entryPoint);
+    Unconstructable object = new Unconstructable("constructor");
+    entryPoint.membersInjector.injectMembers(object);
+    assertThat(object.constructor).isEqualTo("constructor");
+    assertThat(object.injected).isEqualTo("injected");
+  }
+
+
+  @Test public void injectionOfUnconstructableFails() {
+    class TestEntryPoint {
+      @Inject Unconstructable unconstructable;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+    }
+
+    try {
+      ObjectGraph.get(new TestModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void instanceInjectionOfMembersOnlyType() {
+    class TestEntryPoint {
+      @Inject Provider<Unconstructable> provider;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+    }
+
+    try {
+      ObjectGraph.get(new TestModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void rejectUnconstructableSingleton() {
+    class TestEntryPoint {
+      @Inject MembersInjector<UnconstructableSingleton> membersInjector;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+    }
+
+    try {
+      ObjectGraph.get(new TestModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Singleton
+  static class UnconstructableSingleton {
+    final String constructor;
+    @Inject String injected;
+    UnconstructableSingleton(String constructor) {
+      this.constructor = constructor;
+    }
+  }
+
+  class NonStaticInner {
+    @Inject String injected;
+  }
+
+  @Test public void membersInjectorOfNonStaticInnerIsOkay() {
+    class TestEntryPoint {
+      @Inject MembersInjector<NonStaticInner> membersInjector;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    NonStaticInner nonStaticInner = new NonStaticInner();
+    entryPoint.membersInjector.injectMembers(nonStaticInner);
+    assertThat(nonStaticInner.injected).isEqualTo("injected");
+  }
+
+  @Test public void instanceInjectionOfNonStaticInnerFailsEarly() {
+    class TestEntryPoint {
+      @Inject NonStaticInner nonStaticInner;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+    }
+
+    try {
+      ObjectGraph.get(new TestModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void providesMethodsAndMembersInjectionDoNotConflict() {
+    class InjectsString {
+      @Inject String value;
+    }
+
+    class TestEntryPoint {
+      @Inject Provider<InjectsString> provider;
+      @Inject MembersInjector<InjectsString> membersInjector;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides InjectsString provideInjectsString() {
+        InjectsString result = new InjectsString();
+        result.value = "provides";
+        return result;
+      }
+      @Provides String provideString() {
+        return "members";
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+
+    InjectsString provided = entryPoint.provider.get();
+    assertThat(provided.value).isEqualTo("provides");
+
+    InjectsString membersInjected = new InjectsString();
+    entryPoint.membersInjector.injectMembers(membersInjected);
+    assertThat(membersInjected.value).isEqualTo("members");
+  }
+}
\ No newline at end of file
/Fim/
diff --git a/src/test/java/com/squareup/injector/ProblemDetectorTest.java b/src/test/java/com/squareup/injector/ProblemDetectorTest.java
new file mode 100644
index 0000000..55a1b7b
--- /dev/null
+++ b/src/test/java/com/squareup/injector/ProblemDetectorTest.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import javax.inject.Inject;
+import org.junit.Test;
+
+import static org.junit.Assert.fail;
+
+public final class ProblemDetectorTest {
+  @Test public void circularDependenciesDetected() {
+    class TestEntryPoint {
+      @Inject Rock rock;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+    }
+
+    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    try {
+      graph.detectProblems();
+      fail();
+    } catch (RuntimeException expected) {
+    }
+  }
+
+  static class Rock {
+    @Inject Scissors scissors;
+  }
+
+  static class Scissors {
+    @Inject Paper paper;
+  }
+
+  static class Paper {
+    @Inject Rock rock;
+  }
+}
/Fim/
diff --git a/src/test/java/com/squareup/injector/internal/KeysTest.java b/src/test/java/com/squareup/injector/internal/KeysTest.java
new file mode 100644
index 0000000..39a6b46
--- /dev/null
+++ b/src/test/java/com/squareup/injector/internal/KeysTest.java
@@ -0,0 +1,114 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import com.squareup.injector.MembersInjector;
+import java.lang.reflect.Field;
+import java.util.List;
+import java.util.Map;
+import javax.inject.Named;
+import javax.inject.Provider;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+/**
+ * @author Jesse Wilson
+ */
+public final class KeysTest {
+  int primitive;
+  @Test public void lonePrimitiveGetsBoxed() throws NoSuchFieldException {
+    assertThat(fieldKey("primitive"))
+        .isEqualTo("java.lang.Integer");
+  }
+
+  Map<String, List<Integer>> mapStringListInteger;
+  @Test public void parameterizedTypes() throws NoSuchFieldException {
+    assertThat(fieldKey("mapStringListInteger"))
+        .isEqualTo("java.util.Map<java.lang.String, java.util.List<java.lang.Integer>>");
+  }
+
+  Map<String, int[]> mapStringArrayInt;
+  @Test public void parameterizedTypeOfPrimitiveArray() throws NoSuchFieldException {
+    assertThat(fieldKey("mapStringArrayInt"))
+        .isEqualTo("java.util.Map<java.lang.String, int[]>");
+  }
+
+  @Named("foo") String annotatedType;
+  @Test public void annotatedType() throws NoSuchFieldException {
+    assertThat(fieldKey("annotatedType"))
+        .isEqualTo("@javax.inject.Named(value=foo)/java.lang.String");
+  }
+
+  String className;
+  @Test public void testGetClassName() throws NoSuchFieldException {
+    assertThat(Keys.getClassName(fieldKey("className")))
+        .isEqualTo("java.lang.String");
+  }
+
+  @Named("foo") String classNameWithAnnotation;
+  @Test public void testGetClassNameWithoutAnnotation() throws NoSuchFieldException {
+    assertThat(Keys.getClassName(fieldKey("classNameWithAnnotation")))
+        .isEqualTo("java.lang.String");
+  }
+
+  String[] classNameArray;
+  @Test public void testGetClassNameArray() throws NoSuchFieldException {
+    assertThat(Keys.getClassName(fieldKey("classNameArray"))).isNull();
+  }
+
+  List<String> classNameParameterized;
+  @Test public void testGetClassParameterized() throws NoSuchFieldException {
+    assertThat(Keys.getClassName(fieldKey("classNameParameterized"))).isNull();
+  }
+
+  @Named("foo") String annotated;
+  @Test public void testAnnotated() throws NoSuchFieldException {
+    assertThat(fieldKey("annotated")).isEqualTo("@javax.inject.Named(value=foo)/java.lang.String");
+    assertThat(Keys.isAnnotated(fieldKey("annotated"))).isTrue();
+  }
+
+  String notAnnotated;
+  @Test public void testIsAnnotatedFalse() throws NoSuchFieldException {
+    assertThat(Keys.isAnnotated(fieldKey("notAnnotated"))).isFalse();
+  }
+
+  Provider<String> providerOfType;
+  String providedType;
+  @Test public void testGetDelegateKey() throws NoSuchFieldException {
+    assertThat(Keys.getDelegateKey(fieldKey("providerOfType")))
+        .isEqualTo(fieldKey("providedType"));
+  }
+
+  @Named("/@") Provider<String> providerOfTypeAnnotated;
+  @Named("/@") String providedTypeAnnotated;
+  @Test public void testGetDelegateKeyWithAnnotation() throws NoSuchFieldException {
+    assertThat(Keys.getDelegateKey(fieldKey("providerOfTypeAnnotated")))
+        .isEqualTo(fieldKey("providedTypeAnnotated"));
+  }
+
+  @Named("/@") MembersInjector<String> membersInjectorOfType;
+  @Named("/@") String injectedType;
+  @Test public void testGetDelegateKeyWithMembersInjector() throws NoSuchFieldException {
+    assertThat(Keys.getDelegateKey(fieldKey("membersInjectorOfType")))
+        .isEqualTo("members/java.lang.String");
+  }
+
+  private String fieldKey(String fieldName) throws NoSuchFieldException {
+    Field field = KeysTest.class.getDeclaredField(fieldName);
+    return Keys.get(field.getGenericType(), field.getAnnotations(), field);
+  }
+}
/Fim/
diff --git a/androidmanifest/pom.xml b/androidmanifest/pom.xml
new file mode 100644
index 0000000..6eb9d19
--- /dev/null
+++ b/androidmanifest/pom.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2012 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+        xmlns="http://maven.apache.org/POM/4.0.0"
+        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+        xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <groupId>com.squareup</groupId>
+        <artifactId>objectgraph-parent</artifactId>
+        <version>1.0-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
+    <artifactId>objectgraph-androidmanifest</artifactId>
+    <packaging>jar</packaging>
+    <name>ObjectGraph AndroidManifest.xml Module Generator</name>
+
+    <dependencies>
+        <dependency>
+            <groupId>com.squareup</groupId>
+            <artifactId>objectgraph</artifactId>
+            <version>1.0-SNAPSHOT</version>
+        </dependency>
+    </dependencies>
+</project>
/Fim/
diff --git a/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java b/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
new file mode 100644
index 0000000..c74b3a5
--- /dev/null
+++ b/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.objectgraph.androidmanifest;
+
+import com.squareup.objectgraph.Module;
+import com.squareup.objectgraph.internal.codegen.JavaWriter;
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import org.w3c.dom.Attr;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+
+// TODO: support inner classes
+// TODO: support relative class name references like ".FooActivity"
+
+/**
+ * Generates an object graph module source file that has entry points for all
+ * classes referenced in an {@code AndroidManifest.xml} file.
+ */
+public final class ModuleGenerator {
+  private static final String NAMESPACE = "http://schemas.android.com/apk/res/android";
+
+  /**
+   * Returns the path of the generated ManifestModule.java for {@code manifest}.
+   *
+   * @param baseDir the directory where generated files are to be created.
+   */
+  public File path(Document manifest, File baseDir) {
+    String packageName = packageName(manifest);
+    return new File(baseDir, packageName.replace('.', '/') + "/ManifestModule.java");
+  }
+
+  String packageName(Document manifest) {
+    Element root = manifest.getDocumentElement();
+    if (!root.getTagName().equals("manifest")) {
+      throw new IllegalArgumentException("Expected <manifest> but was <" + root.getTagName() + ">");
+    }
+    Attr packageAttr = root.getAttributeNode("package");
+    if (packageAttr == null) {
+      throw new IllegalArgumentException("Expected a package attribute");
+    }
+    return packageAttr.getValue();
+  }
+
+  public void generate(Document manifest, JavaWriter out) throws IOException {
+    String packageName = packageName(manifest);
+    List<String> nameReferences = getNameReferences(manifest);
+    generate(packageName, nameReferences, out);
+  }
+
+  void generate(String packageName, List<String> nameReferences, JavaWriter out)
+      throws IOException {
+    String className = packageName + ".ManifestModule";
+    out.addPackage(packageName);
+    out.addImport(Module.class);
+
+    List<String> classLiterals = namesToClassLiterals(nameReferences);
+    Collections.sort(classLiterals);
+    Map<String, Object> attributes = new HashMap<String, Object>();
+    attributes.put("entryPoints", classLiterals.toArray());
+
+    out.annotation(Module.class, attributes);
+    out.beginType(className, "class", Modifier.PUBLIC | Modifier.FINAL);
+    out.endType();
+  }
+
+  /**
+   * Returns class name references for the given class names. This appends the
+   * {@code .class} suffix.
+   */
+  private List<String> namesToClassLiterals(List<String> classNameReferences) {
+    List<String> result = new ArrayList<String>();
+    for (String name : classNameReferences) {
+      result.add(name + ".class");
+    }
+    return result;
+  }
+
+  /**
+   * Returns the names of classes referenced by {@code activity}, {@code
+   * provider}, {@code receiver} and {@code service} tags within {@code
+   * manifest}.
+   */
+  List<String> getNameReferences(Document manifest) {
+    List<String> result = new ArrayList<String>();
+    Element root = manifest.getDocumentElement();
+    if (!root.getTagName().equals("manifest")) {
+      throw new IllegalArgumentException("Expected <manifest> but was <" + root.getTagName() + ">");
+    }
+    for (Element e : childElements(root)) {
+      if (!e.getTagName().equals("application")) {
+        continue;
+      }
+      for (Element ee : childElements(e)) {
+        String tagName = ee.getTagName();
+        if (tagName.equals("activity")
+            || tagName.equals("provider")
+            || tagName.equals("receiver")
+            || tagName.equals("service")) {
+          Attr nameAttr = ee.getAttributeNodeNS(NAMESPACE, "name");
+          if (nameAttr == null) {
+            throw new IllegalArgumentException("Expected a name attribute on " + ee);
+          }
+          result.add(nameAttr.getValue());
+        }
+      }
+    }
+    return result;
+  }
+
+  private List<Element> childElements(Element element) {
+    NodeList childNodes = element.getChildNodes();
+    ArrayList<Element> result = new ArrayList<Element>();
+    for (int i = 0; i < childNodes.getLength(); i++) {
+      if (childNodes.item(i).getNodeType() == Node.ELEMENT_NODE) {
+        result.add((Element) childNodes.item(i));
+      }
+    }
+    return result;
+  }
+
+  public Document manifestToDocument(InputSource androidManifestIn)
+      throws IOException, SAXException, ParserConfigurationException {
+    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
+    documentBuilderFactory.setNamespaceAware(true);
+    DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
+    return documentBuilder.parse(androidManifestIn);
+  }
+}
/Fim/
diff --git a/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java b/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java
new file mode 100644
index 0000000..9365600
--- /dev/null
+++ b/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.objectgraph.androidmanifest;
+
+import com.squareup.objectgraph.internal.codegen.JavaWriter;
+import java.io.IOException;
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.Test;
+import org.w3c.dom.Document;
+import org.xml.sax.InputSource;
+
+import static org.fest.assertions.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class ModuleGeneratorTest {
+  private static final String MANIFEST_XML = ""
+      + "<manifest"
+      + "    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n"
+      + "    package=\"com.squareup.badhorse\">\n"
+      + "  <uses-permission android:name=\"not.an.entry.point\"/>\n"
+      + "  <permission android:name=\"not.an.entry.point\"/>\n"
+      + "  <application android:name=\"not.an.entry.point\">\n"
+      + "    <uses-library android:name=\"not.an.entry.point\"/>\n"
+      + "    <activity android:name=\"result.a.Activity\">\n"
+      + "      <intent-filter>\n"
+      + "        <action android:name=\"not.an.entry.point\"/>\n"
+      + "        <category android:name=\"not.an.entry.point\"/>\n"
+      + "      </intent-filter>\n"
+      + "    </activity>\n"
+      + "    <provider android:name=\"result.b.Provider\"/>\n"
+      + "    <receiver android:name=\"result.c.Receiver\">\n"
+      + "      <intent-filter>\n"
+      + "        <action android:name=\"not.an.entry.point\"/>\n"
+      + "      </intent-filter>\n"
+      + "    </receiver>\n"
+      + "    <service android:name=\"result.d.Service\"/>\n"
+      + "  </application>\n"
+      + "</manifest>\n";
+  private ModuleGenerator generator = new ModuleGenerator();
+  private StringWriter stringWriter = new StringWriter();
+
+  @Test public void packageName() throws Exception {
+    Document document = document(""
+        + "<manifest\n"
+        + "    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n"
+        + "    package=\"com.squareup.badhorse\"\n"
+        + "    android:versionCode=\"42\"\n"
+        + "    android:versionName=\"42.0\">\n"
+        + "</manifest>");
+    assertThat(generator.packageName(document)).isEqualTo("com.squareup.badhorse");
+  }
+
+  @Test public void packageNameWrongDocumentType() throws Exception {
+    Document document = document("<html package=\"com.squareup.badhorse\"/>");
+    try {
+      generator.packageName(document);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void packageNameNoPackage() throws Exception {
+    Document document = document("<manifest/>");
+    try {
+      generator.packageName(document);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void extractEntryPointNames() throws Exception {
+    Document document = document(MANIFEST_XML);
+    assertThat(generator.getNameReferences(document)).isEqualTo(Arrays.asList(
+        "result.a.Activity", "result.b.Provider", "result.c.Receiver", "result.d.Service"));
+  }
+
+  @Test public void generate() throws IOException {
+    String packageName = "com.squareup.badhorse";
+    List<String> nameReferences = Arrays.asList(
+        "com.squareup.badhorse.SinActivity", "com.squareup.badhorse.LeagueOfEvilActivity");
+    generator.generate(packageName, nameReferences, new JavaWriter(stringWriter));
+    assertCode(""
+        + "package com.squareup.badhorse;\n"
+        + "import com.squareup.objectgraph.Module;\n"
+        + "@Module(\n"
+        + "  entryPoints = [\n"
+        + "    com.squareup.badhorse.LeagueOfEvilActivity.class,\n"
+        + "    com.squareup.badhorse.SinActivity.class\n"
+        + "  ]\n"
+        + ")\n"
+        + "public final class ManifestModule {\n"
+        + "}\n");
+  }
+
+  private Document document(String xml) throws Exception {
+    InputSource xmlIn = new InputSource(new StringReader(xml));
+    return generator.manifestToDocument(xmlIn);
+  }
+
+  private void assertCode(String expected) {
+    assertThat(stringWriter.toString()).isEqualTo(expected);
+  }
+}
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 596314e..e79a9c6 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -28,4 +28,19 @@
     <artifactId>objectgraph</artifactId>
     <packaging>jar</packaging>
     <name>ObjectGraph</name>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <version>2.5</version>
+                <configuration>
+                    <source>${java.version}</source>
+                    <target>${java.version}</target>
+                    <compilerArgument>-proc:none</compilerArgument>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
 </project>
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
index ebe1067..14bf329 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
@@ -20,6 +20,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -174,9 +175,7 @@
    * Completes the current type declaration.
    */
   public void endType() throws IOException {
-    if (popScope() != Scope.TYPE_DECLARATION) {
-      throw new IllegalStateException();
-    }
+    popScope(Scope.TYPE_DECLARATION);
     indent();
     out.write("}\n");
   }
@@ -242,21 +241,89 @@
   }
 
   /**
-   * Annotates the next element with {@code annotation}. The annotation has no
-   * attributes.
+   * Equivalent to {@code annotation(annotation, emptyMap())}.
    */
   public void annotation(String annotation) throws IOException {
+    annotation(annotation, Collections.<String, Object>emptyMap());
+  }
+
+  /**
+   * Equivalent to {@code annotation(annotationType.getName(), emptyMap())}.
+   */
+  public void annotation(Class<? extends Annotation> annotationType) throws IOException {
+    annotation(annotationType.getName(), Collections.<String, Object>emptyMap());
+  }
+
+  /**
+   * Equivalent to {@code annotation(annotationType.getName(), attributes)}.
+   */
+  public void annotation(Class<? extends Annotation> annotationType,Map<String, ?> attributes)
+      throws IOException {
+    annotation(annotationType.getName(), attributes);
+  }
+
+  /**
+   * Annotates the next element with {@code annotation} and {@code attributes}.
+   *
+   * @param attributes a map from annotation attribute names to their values.
+   *     Values are encoded using Object.toString(); use {@link #stringLiteral}
+   *     for String values. Object arrays are written one element per line.
+   */
+  public void annotation(String annotation, Map<String, ?> attributes) throws IOException {
     indent();
     out.write("@");
     type(annotation);
+    if (!attributes.isEmpty()) {
+      out.write("(");
+      pushScope(Scope.ANNOTATION_ATTRIBUTE);
+      boolean firstAttribute = true;
+      for (Map.Entry<String, ?> entry : attributes.entrySet()) {
+        if (firstAttribute) {
+          firstAttribute = false;
+          out.write("\n");
+        } else {
+          out.write(",\n");
+        }
+        indent();
+        out.write(entry.getKey());
+        out.write(" = ");
+        Object value = entry.getValue();
+        annotationValue(value);
+      }
+      popScope(Scope.ANNOTATION_ATTRIBUTE);
+      out.write("\n");
+      indent();
+      out.write(")");
+    }
     out.write("\n");
   }
 
   /**
-   * Equivalent to {@code annotation(annotationType.getName())}.
+   * Writes a single annotation value. If the value is an array, each element in
+   * the array will be written to its own line.
    */
-  public void annotation(Class<? extends Annotation> annotationType) throws IOException {
-    annotation(annotationType.getName());
+  private void annotationValue(Object value) throws IOException {
+    if (value instanceof Object[]) {
+      out.write("[");
+      boolean firstValue = true;
+      pushScope(Scope.ANNOTATION_ARRAY_VALUE);
+      for (Object o : ((Object[]) value)) {
+        if (firstValue) {
+          firstValue = false;
+          out.write("\n");
+        } else {
+          out.write(",\n");
+        }
+        indent();
+        out.write(o.toString());
+      }
+      popScope(Scope.ANNOTATION_ARRAY_VALUE);
+      out.write("\n");
+      indent();
+      out.write("]");
+    } else {
+      out.write(value.toString());
+    }
   }
 
   /**
@@ -287,10 +354,7 @@
    *     "else if (foo == 10)". Shouldn't contain braces or newline characters.
    */
   public void nextControlFlow(String controlFlow) throws IOException {
-    if (popScope() != Scope.CONTROL_FLOW) {
-      throw new IllegalArgumentException();
-    }
-
+    popScope(Scope.CONTROL_FLOW);
     indent();
     pushScope(Scope.CONTROL_FLOW);
     out.write("} ");
@@ -307,10 +371,7 @@
    *     as "while(foo == 20)". Only used for "do/while" control flows.
    */
   public void endControlFlow(String controlFlow) throws IOException {
-    if (popScope() != Scope.CONTROL_FLOW) {
-      throw new IllegalArgumentException();
-    }
-
+    popScope(Scope.CONTROL_FLOW);
     indent();
     if (controlFlow != null) {
       out.write("} ");
@@ -435,10 +496,18 @@
     return scopes.remove(scopes.size() - 1);
   }
 
+  private void popScope(Scope expected) {
+    if (scopes.remove(scopes.size() - 1) != expected) {
+      throw new IllegalStateException();
+    }
+  }
+
   private enum Scope {
     TYPE_DECLARATION,
     ABSTRACT_METHOD,
     NON_ABSTRACT_METHOD,
     CONTROL_FLOW,
+    ANNOTATION_ATTRIBUTE,
+    ANNOTATION_ARRAY_VALUE,
   }
 }
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java b/core/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java
index 365b322..410f931 100644
--- a/core/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java
+++ b/core/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java
@@ -18,6 +18,8 @@
 import java.io.IOException;
 import java.io.StringWriter;
 import java.lang.reflect.Modifier;
+import java.util.LinkedHashMap;
+import java.util.Map;
 import org.junit.Test;
 
 import static org.fest.assertions.Assertions.assertThat;
@@ -240,6 +242,31 @@
         + "}\n");
   }
 
+  @Test public void annotatedWithAttributes() throws IOException {
+    Map<String, Object> attributes = new LinkedHashMap<String, Object>();
+    attributes.put("overrides", true);
+    attributes.put("entryPoints", new Object[] { "entryPointA", "entryPointB", "entryPointC" });
+    attributes.put("staticInjections", "com.squareup.Quux");
+
+    javaWriter.addPackage("com.squareup");
+    javaWriter.annotation("Module", attributes);
+    javaWriter.beginType("com.squareup.FooModule", "class", 0);
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "@Module(\n"
+        + "  overrides = true,\n"
+        + "  entryPoints = [\n"
+        + "    entryPointA,\n"
+        + "    entryPointB,\n"
+        + "    entryPointC\n"
+        + "  ],\n"
+        + "  staticInjections = com.squareup.Quux\n"
+        + ")\n"
+        + "class FooModule {\n"
+        + "}\n");
+  }
+
   @Test public void parameterizedType() throws IOException {
     javaWriter.addPackage("com.squareup");
     javaWriter.addImport("java.util.Map");
/Fim/
diff --git a/pom.xml b/pom.xml
index cf40f89..a7e54b0 100644
--- a/pom.xml
+++ b/pom.xml
@@ -30,6 +30,7 @@
 
     <modules>
         <module>core</module>
+        <module>androidmanifest</module>
     </modules>
 
     <properties>
@@ -98,7 +99,6 @@
                 <configuration>
                     <source>${java.version}</source>
                     <target>${java.version}</target>
-                    <compilerArgument>-proc:none</compilerArgument>
                 </configuration>
             </plugin>
 
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/ObjectGraph.java b/core/src/main/java/com/squareup/objectgraph/ObjectGraph.java
index 74e6d6a..b3a236e 100644
--- a/core/src/main/java/com/squareup/objectgraph/ObjectGraph.java
+++ b/core/src/main/java/com/squareup/objectgraph/ObjectGraph.java
@@ -20,6 +20,7 @@
 import com.squareup.objectgraph.internal.Linker;
 import com.squareup.objectgraph.internal.ModuleAdapter;
 import com.squareup.objectgraph.internal.ProblemDetector;
+import com.squareup.objectgraph.internal.RuntimeLinker;
 import com.squareup.objectgraph.internal.StaticInjection;
 import com.squareup.objectgraph.internal.UniqueMap;
 import java.util.Collection;
@@ -104,7 +105,7 @@
     }
 
     // Create a linker and install all of the user's bindings.
-    Linker linker = new Linker();
+    Linker linker = new RuntimeLinker();
     linker.installBindings(baseBindings);
     linker.installBindings(overrideBindings);
 
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/AtInjectBinding.java b/core/src/main/java/com/squareup/objectgraph/internal/AtInjectBinding.java
index 886bdf6..f222d0c 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/AtInjectBinding.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/AtInjectBinding.java
@@ -28,7 +28,7 @@
 import javax.inject.Singleton;
 
 /**
- * A binding that injects the constructor and fields of a class.
+ * A runtime binding that injects the constructor and fields of a class.
  */
 final class AtInjectBinding<T> extends Binding<T> {
   private final Field[] fields;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/Linker.java b/core/src/main/java/com/squareup/objectgraph/internal/Linker.java
index 4e20ced..26d074b 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/Linker.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/Linker.java
@@ -15,8 +15,6 @@
  */
 package com.squareup.objectgraph.internal;
 
-import com.squareup.objectgraph.ObjectGraph;
-import java.lang.reflect.Constructor;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -25,14 +23,11 @@
 import java.util.Map;
 import java.util.Queue;
 import java.util.Set;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 /**
  * Links bindings to their dependencies.
  */
-public final class Linker {
-  private static final Logger LOGGER = Logger.getLogger(ObjectGraph.class.getName());
+public abstract class Linker {
   private static final Object UNINITIALIZED = new Object();
 
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
@@ -48,23 +43,31 @@
   private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
 
   /**
-   * Adds all the bindings from {@code toInstall}. The bindings must be linked
-   * before they can be used.
+   * Equivalent to calling {@link #installBinding} on each entry in {@code
+   * toInstall}.
    */
-  public void installBindings(Map<String, Binding<?>> toInstall) {
-    for (Binding<?> binding : toInstall.values()) {
-      bindings.put(binding.provideKey, scope(binding));
+  public final void installBindings(Map<String, Binding<?>> toInstall) {
+    for (Map.Entry<String, Binding<?>> entry : toInstall.entrySet()) {
+      installBinding(entry.getKey(), entry.getValue());
     }
   }
 
   /**
+   * Adds the binding. The caller must call either {@link #linkAll} or {@link
+   * #requestBinding} and {@link #linkRequested} before the binding can be used.
+   */
+  public final void installBinding(String key, Binding<?> binding) {
+    bindings.put(key, scope(binding));
+  }
+
+  /**
    * Links requested bindings and installed bindings, plus all of their
    * transitive dependencies. This creates JIT bindings as necessary to fill in
    * the gaps.
    *
    * @return all bindings known by this linker, which will all be linked.
    */
-  public Collection<Binding<?>> linkAll() {
+  public final Collection<Binding<?>> linkAll() {
     for (Binding<?> binding : bindings.values()) {
       if (!binding.linked) {
         toLink.add(binding);
@@ -78,7 +81,7 @@
    * Links all requested bindings plus their transitive dependencies. This
    * creates JIT bindings as necessary to fill in the gaps.
    */
-  public void linkRequested() {
+  public final void linkRequested() {
     Binding binding;
     while ((binding = toLink.poll()) != null) {
       if (binding instanceof DeferredBinding) {
@@ -113,13 +116,10 @@
       }
     }
 
-    if (!errors.isEmpty()) {
-      StringBuilder message = new StringBuilder();
-      message.append("Errors creating object graph:");
-      for (String error : errors) {
-        message.append("\n  ").append(error);
-      }
-      throw new IllegalArgumentException(message.toString());
+    try {
+      reportErrors(errors);
+    } finally {
+      errors.clear();
     }
   }
 
@@ -142,21 +142,9 @@
 
     String className = Keys.getClassName(key);
     if (className != null && !Keys.isAnnotated(key)) {
-      // First look for a generated InjectAdapter.
-      try {
-        Class<?> c = Class.forName(className + "$InjectAdapter");
-        Constructor<?> constructor = c.getConstructor();
-        constructor.setAccessible(true);
-        return (Binding<?>) constructor.newInstance();
-      } catch (Exception e) {
-        LOGGER.log(Level.FINE, "No generated inject adapter for " + className
-            + ". Falling back to reflection.", e);
-      }
-
-      // Handle class bindings by injecting @Inject-annotated members.
-      Class<?> c = Class.forName(className);
-      if (!c.isInterface()) {
-        return AtInjectBinding.create(c, Keys.isMembersInjection(key));
+      Binding<?> atInjectBinding = createAtInjectBinding(key, className);
+      if (atInjectBinding != null) {
+        return atInjectBinding;
       }
     }
 
@@ -164,11 +152,18 @@
   }
 
   /**
+   * Returns a binding that uses {@code @Inject} annotations, or null if no such
+   * binding can be created.
+   */
+  protected abstract Binding<?> createAtInjectBinding(String key, String className)
+      throws ClassNotFoundException;
+
+  /**
    * Returns the binding if it exists immediately. Otherwise this returns
    * null. If the returned binding didn't exist or was unlinked, it will be
    * enqueued to be linked.
    */
-  public Binding<?> requestBinding(String key, Object requiredBy) {
+  public final Binding<?> requestBinding(String key, Object requiredBy) {
     Binding<?> binding = bindings.get(key);
     if (binding == null) {
       // We can't satisfy this binding. Make sure it'll work next time!
@@ -242,10 +237,20 @@
     }
   }
 
+  /** Enqueue {@code message} as a fatal error to be reported to the user. */
   private void addError(String message) {
     errors.add(message);
   }
 
+  /**
+   * Fail if any errors have been enqueued and clear the list of errors.
+   * Implementations may throw exceptions or report the errors through another
+   * channel.
+   *
+   * @param errors a potentially empty list of error messages.
+   */
+  protected abstract void reportErrors(List<String> errors);
+
   private static class DeferredBinding<T> extends Binding<T> {
     final String deferredKey;
     private DeferredBinding(String deferredKey, Object requiredBy) {
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/RuntimeLinker.java b/core/src/main/java/com/squareup/objectgraph/internal/RuntimeLinker.java
new file mode 100644
index 0000000..4fe5ae2
--- /dev/null
+++ b/core/src/main/java/com/squareup/objectgraph/internal/RuntimeLinker.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.objectgraph.internal;
+
+import com.squareup.objectgraph.ObjectGraph;
+import java.lang.reflect.Constructor;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Linker suitable for application use at runtime. This looks for generated code
+ * and falls back to reflection.
+ */
+public final class RuntimeLinker extends Linker {
+  private static final Logger LOGGER = Logger.getLogger(ObjectGraph.class.getName());
+
+  @Override protected Binding<?> createAtInjectBinding(String key, String className)
+      throws ClassNotFoundException {
+    try {
+      Class<?> c = Class.forName(className + "$InjectAdapter");
+      Constructor<?> constructor = c.getConstructor();
+      constructor.setAccessible(true);
+      return (Binding<?>) constructor.newInstance();
+    } catch (Exception e) {
+      LOGGER.log(Level.FINE, "No generated inject adapter for " + className
+          + ". Falling back to reflection.", e);
+    }
+
+    // Handle class bindings by injecting @Inject-annotated members.
+    Class<?> c = Class.forName(className);
+    if (c.isInterface()) {
+      return null;
+    }
+
+    return AtInjectBinding.create(c, Keys.isMembersInjection(key));
+  }
+
+  @Override protected void reportErrors(List<String> errors) {
+    if (errors.isEmpty()) {
+      return;
+    }
+    StringBuilder message = new StringBuilder();
+    message.append("Errors creating object graph:");
+    for (String error : errors) {
+      message.append("\n  ").append(error);
+    }
+    throw new IllegalArgumentException(message.toString());
+  }
+}
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/AtInjectBinding.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/AtInjectBinding.java
new file mode 100644
index 0000000..82ce212
--- /dev/null
+++ b/core/src/main/java/com/squareup/objectgraph/internal/codegen/AtInjectBinding.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.objectgraph.internal.codegen;
+
+import com.squareup.objectgraph.internal.Binding;
+import com.squareup.objectgraph.internal.Linker;
+import java.util.ArrayList;
+import java.util.List;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * A build time binding that injects the constructor and fields of a class.
+ */
+final class AtInjectBinding extends Binding<Object> {
+  private final TypeElement type;
+  private final List<String> keys;
+
+  private AtInjectBinding(String provideKey, String membersKey,
+      TypeElement type, List<String> keys) {
+    super(provideKey, membersKey, type.getAnnotation(Singleton.class) != null,
+        type.getQualifiedName().toString());
+    this.type = type;
+    this.keys = keys;
+  }
+
+  static AtInjectBinding create(TypeElement type) {
+    List<String> requiredKeys = new ArrayList<String>();
+    boolean hasInjectAnnotatedConstructor = false;
+    boolean isConstructable = false;
+
+    for (Element enclosed : type.getEnclosedElements()) {
+      switch (enclosed.getKind()) {
+      case FIELD:
+        if (hasAtInject(enclosed) && !enclosed.getModifiers().contains(Modifier.STATIC)) {
+          // Attach the non-static fields of 'type'.
+          requiredKeys.add(GeneratorKeys.get((VariableElement) enclosed));
+        }
+        break;
+
+      case CONSTRUCTOR:
+        ExecutableElement constructor = (ExecutableElement) enclosed;
+        List<? extends VariableElement> parameters = constructor.getParameters();
+        if (hasAtInject(enclosed)) {
+          if (hasInjectAnnotatedConstructor) {
+            throw new IllegalArgumentException("Too many injectable constructors on "
+                + type.getQualifiedName().toString());
+          }
+          hasInjectAnnotatedConstructor = true;
+          isConstructable = true;
+          for (VariableElement parameter : parameters) {
+            requiredKeys.add(GeneratorKeys.get(parameter));
+          }
+        } else if (parameters.isEmpty()) {
+          isConstructable = true;
+        }
+        break;
+
+      default:
+        throw new IllegalArgumentException("Unexpected @Inject annotation on "
+            + enclosed.getSimpleName().toString());
+      }
+    }
+
+    if (requiredKeys.isEmpty()) {
+      throw new IllegalArgumentException("No injectable members on "
+          + type.getQualifiedName().toString() + ". Do you want to add an injectable constructor?");
+    }
+
+    // Attach the supertype.
+    TypeMirror supertype = CodeGen.getApplicationSupertype(type);
+    if (supertype != null) {
+      requiredKeys.add(GeneratorKeys.rawMembersKey(supertype));
+    }
+
+    String provideKey = isConstructable ? GeneratorKeys.get(type.asType()) : null;
+    String membersKey = GeneratorKeys.rawMembersKey(type.asType());
+    return new AtInjectBinding(provideKey, membersKey, type, requiredKeys);
+  }
+
+  private static boolean hasAtInject(Element enclosed) {
+    return enclosed.getAnnotation(Inject.class) == null;
+  }
+
+  @Override public void attach(Linker linker) {
+    String requiredBy = type.getQualifiedName().toString();
+    for (String key : keys) {
+      linker.requestBinding(key, requiredBy);
+    }
+  }
+}
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/BuildTimeLinker.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/BuildTimeLinker.java
new file mode 100644
index 0000000..abe1d07
--- /dev/null
+++ b/core/src/main/java/com/squareup/objectgraph/internal/codegen/BuildTimeLinker.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.objectgraph.internal.codegen;
+
+import com.squareup.objectgraph.internal.Binding;
+import com.squareup.objectgraph.internal.Linker;
+import java.util.ArrayList;
+import java.util.List;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.TypeElement;
+import javax.tools.Diagnostic;
+
+/**
+ * Linker suitable for tool use at build time. The bindings created by this
+ * linker have the correct dependency graph, but do not implement {@link
+ * Binding#get} or {@link Binding#injectMembers} methods. They are only suitable
+ * for graph analysis and error detection.
+ */
+final class BuildTimeLinker extends Linker {
+  private final ProcessingEnvironment processingEnv;
+
+  /** Classes the compiler was unable to introspect. */
+  private final List<String> unavailableClasses = new ArrayList<String>();
+
+  BuildTimeLinker(ProcessingEnvironment processingEnv) {
+    this.processingEnv = processingEnv;
+  }
+
+  @Override protected Binding<?> createAtInjectBinding(String key, String className) {
+    TypeElement type = processingEnv.getElementUtils().getTypeElement(className);
+    if (type == null) {
+      // We've encountered a type that the compiler can't introspect. Remember
+      // the class name so we can warn about it later.
+      unavailableClasses.add(className);
+      return Binding.UNRESOLVED;
+    }
+    if (type.getKind() == ElementKind.INTERFACE) {
+      return null;
+    }
+    return AtInjectBinding.create(type);
+  }
+
+  @Override protected void reportErrors(List<String> errors) {
+    if (!unavailableClasses.isEmpty()) {
+      String warning = String.format("%s and %d other classes were not available. Runtime failures "
+          + "are possible!", unavailableClasses.get(0), unavailableClasses.size() - 1);
+      processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING, warning);
+    }
+    for (String error : errors) {
+      processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, error);
+    }
+  }
+}
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java
new file mode 100644
index 0000000..ca07f84
--- /dev/null
+++ b/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.objectgraph.internal.codegen;
+
+import com.squareup.objectgraph.Module;
+import com.squareup.objectgraph.Provides;
+import com.squareup.objectgraph.internal.Binding;
+import com.squareup.objectgraph.internal.Linker;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.annotation.processing.SupportedAnnotationTypes;
+import javax.annotation.processing.SupportedSourceVersion;
+import javax.inject.Singleton;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Performs full graph analysis on a module.
+ */
+@SupportedAnnotationTypes("com.squareup.objectgraph.Module")
+@SupportedSourceVersion(SourceVersion.RELEASE_6)
+public final class FullGraphProcessor extends AbstractProcessor {
+  @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
+    Linker linker = new BuildTimeLinker(processingEnv);
+
+    for (Element moduleType : env.getElementsAnnotatedWith(Module.class)) {
+      Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, moduleType);
+
+      // Gather the entry points from the annotation.
+      for (Object entryPoint : (Object[]) annotation.get("entryPoints")) {
+        linker.requestBinding(GeneratorKeys.rawMembersKey((TypeMirror) entryPoint),
+            ((TypeElement) moduleType).getQualifiedName().toString());
+      }
+
+      // Gather the static injections.
+      // TODO.
+
+      // Gather the enclosed @Provides methods.
+      for (Element enclosed : moduleType.getEnclosedElements()) {
+        if (enclosed.getAnnotation(Provides.class) == null) {
+          continue;
+        }
+        ExecutableElement providerMethod = (ExecutableElement) enclosed;
+        String key = GeneratorKeys.get(providerMethod);
+        linker.installBinding(key, new ProviderMethodBinding(key, providerMethod));
+      }
+    }
+
+    // Link the bindings. This will traverse the dependency graph, and report
+    // errors if any dependencies are missing.
+    linker.linkAll();
+
+    return true;
+  }
+
+  static class ProviderMethodBinding extends Binding<Object> {
+    private final ExecutableElement method;
+    protected ProviderMethodBinding(String provideKey, ExecutableElement method) {
+      super(provideKey, null, method.getAnnotation(Singleton.class) != null, method.toString());
+      this.method = method;
+    }
+    @Override public void attach(Linker linker) {
+      for (VariableElement parameter : method.getParameters()) {
+        String parameterKey = GeneratorKeys.get(parameter);
+        linker.requestBinding(parameterKey, method.toString());
+      }
+    }
+  }
+}
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/GeneratorKeys.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/GeneratorKeys.java
index e3cbad7..115ebdf 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/GeneratorKeys.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/codegen/GeneratorKeys.java
@@ -60,14 +60,14 @@
     return result.toString();
   }
 
-  /** Returns the provider key for {@code parameter}. */
-  public static String get(VariableElement parameter) {
+  /** Returns the provider key for {@code variable}. */
+  public static String get(VariableElement variable) {
     StringBuilder result = new StringBuilder();
-    AnnotationMirror qualifier = getQualifier(parameter.getAnnotationMirrors(), parameter);
+    AnnotationMirror qualifier = getQualifier(variable.getAnnotationMirrors(), variable);
     if (qualifier != null) {
       qualifierToString(qualifier, result);
     }
-    CodeGen.typeToString(parameter.asType(), result, '$');
+    CodeGen.typeToString(variable.asType(), result, '$');
     return result.toString();
   }
 
/Fim/
diff --git a/core/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/core/src/main/resources/META-INF/services/javax.annotation.processing.Processor
index 31c0e88..e81ca7b 100644
--- a/core/src/main/resources/META-INF/services/javax.annotation.processing.Processor
+++ b/core/src/main/resources/META-INF/services/javax.annotation.processing.Processor
@@ -1,2 +1,4 @@
 com.squareup.objectgraph.internal.codegen.InjectProcessor
 com.squareup.objectgraph.internal.codegen.ProvidesProcessor
+# TODO: Enable full graph processing.
+#com.squareup.objectgraph.internal.codegen.FullGraphProcessor
\ No newline at end of file
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/ObjectGraph.java b/core/src/main/java/com/squareup/objectgraph/ObjectGraph.java
index c3a712a..669544c 100644
--- a/core/src/main/java/com/squareup/objectgraph/ObjectGraph.java
+++ b/core/src/main/java/com/squareup/objectgraph/ObjectGraph.java
@@ -23,7 +23,6 @@
 import com.squareup.objectgraph.internal.RuntimeLinker;
 import com.squareup.objectgraph.internal.StaticInjection;
 import com.squareup.objectgraph.internal.UniqueMap;
-import java.lang.reflect.Constructor;
 import java.util.Collection;
 import java.util.LinkedHashMap;
 import java.util.Map;
@@ -84,7 +83,8 @@
   }
 
   private static ObjectGraph get(boolean lazy, Object... modules) {
-    modules = getAllModules(modules);
+    ModuleAdapter<?>[] moduleAdapters = getAllModuleAdapters(modules);
+
     Map<String, Class<?>> entryPoints = new LinkedHashMap<String, Class<?>>();
     Map<Class<?>, StaticInjection> staticInjections
         = new LinkedHashMap<Class<?>, StaticInjection>();
@@ -93,17 +93,15 @@
     // duplicates are permitted.
     Map<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>();
     Map<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>();
-    for (Object module : modules) {
-      Class<?> moduleClass = module.getClass();
-      ModuleAdapter<Object> adapter = ModuleAdapter.get(module);
+    for (ModuleAdapter<?> adapter : moduleAdapters) {
       for (String key : adapter.entryPoints) {
-        entryPoints.put(key, moduleClass);
+        entryPoints.put(key, adapter.getModule().getClass());
       }
       for (Class<?> c : adapter.staticInjections) {
         staticInjections.put(c, lazy ? null : StaticInjection.get(c));
       }
       Map<String, Binding<?>> addTo = adapter.overrides ? overrideBindings : baseBindings;
-      adapter.getBindings(module, addTo);
+      adapter.getBindings(addTo);
     }
 
     // Create a linker and install all of the user's bindings.
@@ -123,56 +121,52 @@
     return result;
   }
 
-  /** Returns a full set of modules, including child modules. */
-  private static Object[] getAllModules(Object... modules) {
-    // TODO: move this work to ModuleAdapter to avoid runtime reflection.
-    Map<Class<?>, Object> modulesByType = new LinkedHashMap<Class<?>, Object>();
-
-    // First add all of the modules that we have instances for. This way we
-    // won't instantiate module types that the user has supplied.
-    for (Object module : modules) {
-      modulesByType.put(module.getClass(), module);
+  /**
+   * Returns a full set of module adapters, including module adapters for child
+   * modules.
+   */
+  private static ModuleAdapter<?>[] getAllModuleAdapters(Object[] seedModules) {
+    // Create a module adapter for each seed module.
+    ModuleAdapter<?>[] seedAdapters = new ModuleAdapter<?>[seedModules.length];
+    int s = 0;
+    for (Object module : seedModules) {
+      seedAdapters[s++] = ModuleAdapter.get(module.getClass(), module);
     }
 
-    // Next add 'Class<?>' keys for the modules that we need to construct. This
-    // creates default instances when necessary.
-    for (Object module : modules) {
-      collectChildModulesRecursively(module.getClass(), modulesByType);
+    Map<Class<?>, ModuleAdapter<?>> adaptersByModuleType
+        = new LinkedHashMap<Class<?>, ModuleAdapter<?>>();
+
+    // Add the adapters that we have module instances for. This way we won't
+    // construct module objects when we have a user-supplied instance.
+    for (ModuleAdapter<?> adapter : seedAdapters) {
+      adaptersByModuleType.put(adapter.getModule().getClass(), adapter);
     }
 
-    return modulesByType.values().toArray();
+    // Next add adapters for the modules that we need to construct. This creates
+    // instances of modules as necessary.
+    for (ModuleAdapter<?> adapter : seedAdapters) {
+      collectChildModulesRecursively(adapter, adaptersByModuleType);
+    }
+
+    return adaptersByModuleType.values().toArray(
+        new ModuleAdapter<?>[adaptersByModuleType.size()]);
   }
 
   /**
-   * Fills {@code result} with the child modules of {@code c}, and their child
-   * modules recursively. Creates default instances for module types if
-   * necessary.
+   * Fills {@code result} with the module adapters for the children of {@code
+   * adapter}, and their children recursively.
    */
-  private static void collectChildModulesRecursively(Class<?> c, Map<Class<?>, Object> result) {
-    Module annotation = c.getAnnotation(Module.class);
-    if (annotation == null) {
-      throw new IllegalArgumentException("Expected @Module on " + c.getName());
-    }
-
-    for (Class<?> childClass : annotation.children()) {
-      if (!result.containsKey(childClass)) {
-        result.put(childClass, newInstance(childClass));
-        collectChildModulesRecursively(childClass, result);
+  private static void collectChildModulesRecursively(ModuleAdapter<?> adapter,
+      Map<Class<?>, ModuleAdapter<?>> result) {
+    for (Class<?> child : adapter.children) {
+      if (!result.containsKey(child)) {
+        ModuleAdapter<Object> childAdapter = ModuleAdapter.get(child, null);
+        result.put(child, childAdapter);
+        collectChildModulesRecursively(childAdapter, result);
       }
     }
   }
 
-  /** Returns an instance of {@code c} by invoking its 0-arg constructor. */
-  private static Object newInstance(Class<?> c) {
-    try {
-      Constructor<?> childConstructor = c.getDeclaredConstructor();
-      childConstructor.setAccessible(true);
-      return childConstructor.newInstance();
-    } catch (Exception e) {
-      throw new IllegalArgumentException("Unable to instantiate " + c.getName(), e);
-    }
-  }
-
   private void linkStaticInjections() {
     for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
       StaticInjection staticInjection = entry.getValue();
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/ModuleAdapter.java b/core/src/main/java/com/squareup/objectgraph/internal/ModuleAdapter.java
index e1c59e4..d44bfef 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/ModuleAdapter.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/ModuleAdapter.java
@@ -33,42 +33,59 @@
   public final String[] entryPoints;
   public final Class<?>[] staticInjections;
   public final boolean overrides;
+  public final Class<?>[] children;
+  public final boolean complete;
+  protected T module;
 
-  protected ModuleAdapter(String[] entryPoints, Class<?>[] staticInjections, boolean overrides) {
+  protected ModuleAdapter(String[] entryPoints, Class<?>[] staticInjections, boolean overrides,
+      Class<?>[] children, boolean complete) {
     this.entryPoints = entryPoints;
     this.staticInjections = staticInjections;
     this.overrides = overrides;
+    this.children = children;
+    this.complete = complete;
   }
 
   /**
    * Returns bindings for the {@code @Provides} methods of {@code module}. The
    * returned bindings must be linked before they can be used to inject values.
    */
-  public abstract void getBindings(T module, Map<String, Binding<?>> map);
+  public abstract void getBindings(Map<String, Binding<?>> map);
+
+  /**
+   * Returns a new instance of the module class created using a no-args
+   * constructor. Only used when a manually-constructed module is not supplied.
+   */
+  protected abstract T newModule();
+
+  public T getModule() {
+    return module;
+  }
 
   /**
    * Returns a module adapter for {@code module}, preferring a code-generated
    * implementation and falling back to a reflective implementation.
    */
   @SuppressWarnings("unchecked") // Runtime checks validate that the result type matches 'T'.
-  public static <T> ModuleAdapter<T> get(T module) {
-    Class<?> moduleClass = module.getClass();
+  public static <T> ModuleAdapter<T> get(Class<? extends T> moduleClass, T module) {
+    ModuleAdapter<T> result;
     try {
       String adapter = moduleClass.getName() + "$ModuleAdapter";
       Class<?> c = Class.forName(adapter);
       Constructor<?> constructor = c.getConstructor();
       constructor.setAccessible(true);
-      return (ModuleAdapter) constructor.newInstance();
+      result = (ModuleAdapter) constructor.newInstance();
     } catch (Exception e) {
       LOGGER.log(Level.FINE, "No generated module for " + moduleClass.getName()
           + ". Falling back to reflection.", e);
+      Module annotation = moduleClass.getAnnotation(Module.class);
+      if (annotation == null) {
+        throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
+      }
+      result = (ModuleAdapter) new ReflectiveModuleAdapter(moduleClass, annotation);
     }
-
-    Module annotation = moduleClass.getAnnotation(Module.class);
-    if (annotation == null) {
-      throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
-    }
-    return (ModuleAdapter) new ReflectiveModuleAdapter(moduleClass, annotation);
+    result.module = (module != null) ? module : result.newModule();
+    return result;
   }
 
   static class ReflectiveModuleAdapter extends ModuleAdapter<Object> {
@@ -76,7 +93,7 @@
 
     ReflectiveModuleAdapter(Class<?> moduleClass, Module annotation) {
       super(toMemberKeys(annotation.entryPoints()), annotation.staticInjections(),
-          annotation.overrides());
+          annotation.overrides(), annotation.children(), annotation.complete());
       this.moduleClass = moduleClass;
     }
 
@@ -88,22 +105,32 @@
       return result;
     }
 
-    @Override public void getBindings(Object module, Map<String, Binding<?>> bindings) {
+    @Override public void getBindings(Map<String, Binding<?>> bindings) {
       // Fall back to runtime reflection.
       for (Class<?> c = moduleClass; c != Object.class; c = c.getSuperclass()) {
         for (Method method : c.getDeclaredMethods()) {
           if (!method.isAnnotationPresent(Provides.class)) {
             continue;
           }
-          Binding<?> binding = methodToBinding(module, method);
+          Binding<?> binding = methodToBinding(method);
           bindings.put(binding.provideKey, binding);
         }
       }
     }
 
-    private <T> Binding<T> methodToBinding(Object module, Method method) {
+    private <T> Binding<T> methodToBinding(Method method) {
       String key = Keys.get(method.getGenericReturnType(), method.getAnnotations(), method);
       return new ProviderMethodBinding<T>(method, key, module);
     }
+
+    @Override protected Object newModule() {
+      try {
+        Constructor<?> childConstructor = moduleClass.getDeclaredConstructor();
+        childConstructor.setAccessible(true);
+        return childConstructor.newInstance();
+      } catch (Exception e) {
+        throw new IllegalArgumentException("Unable to instantiate " + moduleClass.getName(), e);
+      }
+    }
   }
 }
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/AtInjectBinding.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/AtInjectBinding.java
index 532244b..4f4a442 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/AtInjectBinding.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/codegen/AtInjectBinding.java
@@ -43,7 +43,12 @@
     this.keys = keys;
   }
 
-  static AtInjectBinding create(TypeElement type) {
+  /**
+   * @param forMembersInjection true if the binding is being created to inject
+   *     members only. Such injections do not require {@code @Inject}
+   *     annotations.
+   */
+  static AtInjectBinding create(TypeElement type, boolean forMembersInjection) {
     List<String> requiredKeys = new ArrayList<String>();
     boolean hasInjectAnnotatedConstructor = false;
     boolean isConstructable = false;
@@ -76,12 +81,13 @@
         break;
 
       default:
-        throw new IllegalArgumentException("Unexpected @Inject annotation on "
-            + enclosed.getSimpleName().toString());
+        if (hasAtInject(enclosed)) {
+          throw new IllegalArgumentException("Unexpected @Inject annotation on " + enclosed);
+        }
       }
     }
 
-    if (requiredKeys.isEmpty()) {
+    if (!hasInjectAnnotatedConstructor && requiredKeys.isEmpty() && !forMembersInjection) {
       throw new IllegalArgumentException("No injectable members on "
           + type.getQualifiedName().toString() + ". Do you want to add an injectable constructor?");
     }
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/BuildTimeLinker.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/BuildTimeLinker.java
index e166c31..e262ded 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/BuildTimeLinker.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/codegen/BuildTimeLinker.java
@@ -16,6 +16,7 @@
 package com.squareup.objectgraph.internal.codegen;
 
 import com.squareup.objectgraph.internal.Binding;
+import com.squareup.objectgraph.internal.Keys;
 import com.squareup.objectgraph.internal.Linker;
 import java.util.List;
 import javax.annotation.processing.ProcessingEnvironment;
@@ -49,7 +50,7 @@
     if (type.getKind() == ElementKind.INTERFACE) {
       return null;
     }
-    return AtInjectBinding.create(type);
+    return AtInjectBinding.create(type, Keys.isMembersInjection(key));
   }
 
   @Override protected void reportErrors(List<String> errors) {
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/CodeGen.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/CodeGen.java
index 84db86c..020dd12 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/CodeGen.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/codegen/CodeGen.java
@@ -26,6 +26,7 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
@@ -223,4 +224,35 @@
         throw new AssertionError();
     }
   }
+
+  /**
+   * Returns the no-args constructor for {@code type}, or null if no such
+   * constructor exists.
+   */
+  public static ExecutableElement getNoArgsConstructor(TypeElement type) {
+    for (Element enclosed : type.getEnclosedElements()) {
+      if (enclosed.getKind() != ElementKind.CONSTRUCTOR) {
+        continue;
+      }
+      ExecutableElement constructor = (ExecutableElement) enclosed;
+      if (constructor.getParameters().isEmpty()) {
+        return constructor;
+      }
+    }
+    return null;
+  }
+
+  /**
+   * Returns true if generated code can invoke {@code constructor}. That is, if
+   * the constructor is non-private and its enclosing class is either a
+   * top-level class or a static nested class.
+   */
+  public static boolean isCallableConstructor(ExecutableElement constructor) {
+    if (constructor.getModifiers().contains(Modifier.PRIVATE)) {
+      return false;
+    }
+    TypeElement type = (TypeElement) constructor.getEnclosingElement();
+    return type.getEnclosingElement().getKind() == ElementKind.PACKAGE
+        || type.getModifiers().contains(Modifier.STATIC);
+  }
 }
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java
index 04d2c9e..1ec8350 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java
@@ -45,6 +45,7 @@
 
 import static java.lang.reflect.Modifier.FINAL;
 import static java.lang.reflect.Modifier.PRIVATE;
+import static java.lang.reflect.Modifier.PROTECTED;
 import static java.lang.reflect.Modifier.PUBLIC;
 import static java.lang.reflect.Modifier.STATIC;
 
@@ -135,7 +136,9 @@
 
     Object[] staticInjections = (Object[]) module.get("staticInjections");
     Object[] entryPoints = (Object[]) module.get("entryPoints");
+    Object[] children = (Object[]) module.get("children");
     boolean overrides = (Boolean) module.get("overrides");
+    boolean complete = (Boolean) module.get("complete");
 
     String adapterName = CodeGen.adapterName(type, "$ModuleAdapter");
     JavaFileObject sourceFile = processingEnv.getFiler()
@@ -171,12 +174,21 @@
     writer.field("Class<?>[]", "STATIC_INJECTIONS", PRIVATE | STATIC | FINAL,
         staticInjectionsField.toString());
 
+    StringBuilder childrenField = new StringBuilder().append("{ ");
+    for (Object child : children) {
+      TypeMirror typeMirror = (TypeMirror) child;
+      childrenField.append(CodeGen.typeToString(typeMirror)).append(".class, ");
+    }
+    childrenField.append("}");
+    writer.field("Class<?>[]", "CHILDREN", PRIVATE | STATIC | FINAL, childrenField.toString());
+
     writer.beginMethod(null, adapterName, PUBLIC);
-    writer.statement("super(ENTRY_POINTS, STATIC_INJECTIONS, %s)", overrides);
+    writer.statement("super(ENTRY_POINTS, STATIC_INJECTIONS, %s /*overrides*/, "
+        + "CHILDREN, %s /*complete*/)", overrides, complete);
     writer.endMethod();
 
     writer.annotation(Override.class);
-    writer.beginMethod("void", "getBindings", PUBLIC, typeName, "module", BINDINGS_MAP, "map");
+    writer.beginMethod("void", "getBindings", PUBLIC, BINDINGS_MAP, "map");
     for (ExecutableElement providerMethod : providerMethods) {
       String key = GeneratorKeys.get(providerMethod);
       writer.statement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
@@ -184,6 +196,17 @@
     }
     writer.endMethod();
 
+    writer.annotation(Override.class);
+    writer.beginMethod(typeName, "newModule", PROTECTED);
+    ExecutableElement noArgsConstructor = CodeGen.getNoArgsConstructor(type);
+    if (noArgsConstructor != null && CodeGen.isCallableConstructor(noArgsConstructor)) {
+      writer.statement("return new %s()", typeName);
+    } else {
+      writer.statement("throw new UnsupportedOperationException(%s)",
+          JavaWriter.stringLiteral("No no-args constructor on " + type));
+    }
+    writer.endMethod();
+
     for (ExecutableElement providerMethod : providerMethods) {
       writeBindingClass(writer, providerMethod);
     }
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/Linker.java b/core/src/main/java/com/squareup/objectgraph/internal/Linker.java
index 26d074b..0bd631c 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/Linker.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/Linker.java
@@ -43,24 +43,17 @@
   private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
 
   /**
-   * Equivalent to calling {@link #installBinding} on each entry in {@code
-   * toInstall}.
+   * Adds all bindings in {@code toInstall}. The caller must call either {@link
+   * #linkAll} or {@link #requestBinding} and {@link #linkRequested} before the
+   * bindings can be used.
    */
-  public final void installBindings(Map<String, Binding<?>> toInstall) {
-    for (Map.Entry<String, Binding<?>> entry : toInstall.entrySet()) {
-      installBinding(entry.getKey(), entry.getValue());
+  public final void installBindings(Map<String, ? extends Binding<?>> toInstall) {
+    for (Map.Entry<String, ? extends Binding<?>> entry : toInstall.entrySet()) {
+      bindings.put(entry.getKey(), scope(entry.getValue()));
     }
   }
 
   /**
-   * Adds the binding. The caller must call either {@link #linkAll} or {@link
-   * #requestBinding} and {@link #linkRequested} before the binding can be used.
-   */
-  public final void installBinding(String key, Binding<?> binding) {
-    bindings.put(key, scope(binding));
-  }
-
-  /**
    * Links requested bindings and installed bindings, plus all of their
    * transitive dependencies. This creates JIT bindings as necessary to fill in
    * the gaps.
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java
index 5ccf45d..0101eb3 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java
@@ -34,6 +34,7 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
 
 /**
  * Performs full graph analysis on a module.
@@ -60,8 +61,13 @@
     collectChildModulesRecursively(rootModule, allModules);
 
     Linker linker = new BuildTimeLinker(processingEnv);
+    Map<String, ProviderMethodBinding> baseBindings
+        = new LinkedHashMap<String, ProviderMethodBinding>();
+    Map<String, ProviderMethodBinding> overrideBindings
+        = new LinkedHashMap<String, ProviderMethodBinding>();
     for (TypeElement module : allModules.values()) {
       Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
+      boolean overrides = (Boolean) annotation.get("overrides");
 
       // Gather the entry points from the annotation.
       for (Object entryPoint : (Object[]) annotation.get("entryPoints")) {
@@ -79,15 +85,31 @@
         }
         ExecutableElement providerMethod = (ExecutableElement) enclosed;
         String key = GeneratorKeys.get(providerMethod);
-        linker.installBinding(key, new ProviderMethodBinding(key, providerMethod));
+        ProviderMethodBinding binding = new ProviderMethodBinding(key, providerMethod);
+        Map<String, ProviderMethodBinding> addTo = overrides ? overrideBindings : baseBindings;
+        ProviderMethodBinding clobbered = addTo.put(key, binding);
+        if (clobbered != null) {
+          processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
+              "Duplicate bindings for " + key
+                  + ": " + shortMethodName(clobbered.method)
+                  + ", " + shortMethodName(binding.method));
+        }
       }
     }
 
+    linker.installBindings(baseBindings);
+    linker.installBindings(overrideBindings);
+
     // Link the bindings. This will traverse the dependency graph, and report
     // errors if any dependencies are missing.
     linker.linkAll();
   }
 
+  private String shortMethodName(ExecutableElement method) {
+    return method.getEnclosingElement().getSimpleName().toString()
+        + "." + method.getSimpleName() + "()";
+  }
+
   private void collectChildModulesRecursively(TypeElement module, Map<String, TypeElement> result) {
     // Add the module.
     result.put(module.getQualifiedName().toString(), module);
/Fim/
diff --git a/README.md b/README.md
index f50c87e..8100541 100644
--- a/README.md
+++ b/README.md
@@ -1,11 +1,252 @@
 ObjectGraph
 ===========
 
-A JSR-330 dependency injector for Android and Java.
+A fast dependency injector for Android and Java.
+
+### Introduction
+
+The best classes in any application are the ones that do stuff: the `BarcodeDecoder`, the `KoopaPhysicsEngine`, and the `AudioStreamer`. These classes have dependencies; perhaps a `BarcodeCameraFinder`, `DefaultPhysicsEngine`, and an `HttpStreamer`.
+
+To contrast, the worst classes in any application are the ones that take up space without doing much at all: the `BarcodeDecoderFactory`, the `CameraServiceLoader`, and the `MutableContextWrapper`. These classes are the clumsy duct tape that wires the interesting stuff together.
+
+ObjectGraph is a replacement for these `FactoryFactory` classes. It allows you to focus on the interesting classes. Declare dependencies, specify how to satisfy them, and ship your app.
+
+By building on standard [javax.inject][1] annotations (JSR-330), each class is **easy to test**. You don't need a bunch of boilerplate just to swap the `RpcCreditCardService` out for a `FakeCreditCardService`.
+
+Dependency injection isn't just for testing. It also makes it easy to create **reusable, interchangeable modules**. You can share the same `AuthenticationModule`  across all of your apps. And you can run `DevLoggingModule` during development and `ProdLoggingModule` in production to get the right behavior in each situation.
+
+### Declaring Dependencies
+
+ObjectGraph constructs instances of your application classes and satisfies their dependencies. It uses the `javax.inject.Inject` annotation to identify which constructors and fields it is interested in.
+
+Use `@Inject` to annotate the constructor that ObjectGraph should use to create instances of a class. When a new instance is requested, ObjectGraph will obtain the required parameters values and invoke this constructor.
+
+```java
+class Thermosiphon implements Pump {
+  private final Heater heater;
+
+  @Inject
+  Thermosiphon(Heater heater) {
+    this.heater = heater;
+  }
+
+  ...
+}
+```
+
+ObjectGraph can inject fields directly. In this example it obtains a `Heater` instance for the `heater` field and a `Pump` instance for the `pump` field.
+
+```java
+class CoffeeMaker {
+  @Inject Heater heater;
+  @Inject Pump pump;
+
+  ...
+}
+```
+
+If your class has `@Inject`-annotated fields but no `@Inject`-annotated constructor, ObjectGraph will use a no-argument constructor if it exists. Classes that lack `@Inject` annotations cannot be constructed by ObjectGraph.
+
+ObjectGraph does not support method injection.
+
+### Satisfying Dependencies
+
+By default, ObjectGraph satisfies each dependency by constructing an instance of the requested type as described above. When you request a `CoffeeMaker`, it'll obtain one by calling `new CoffeeMaker()` and setting its injectable fields.
+
+But `@Inject` doesn't work everywhere:
+
+* Interfaces can't be constructed.
+* Third-party classes can't be annotated.
+* Configurable objects must be configured!
+
+For these cases where `@Inject` is insufficient or awkward, use an `@Provides`-annotated method to satisfy a dependency. The method's return type defines which dependency it satisfies.
+
+For example, `provideHeater()` is invoked whenever a `Heater` is required:
+
+```java
+@Provides Heater provideHeater() {
+  return new ElectricHeater();
+}
+```
+
+It's possible for `@Provides` methods to have dependencies of their own. This one returns a `Thermosiphon` whenever a `Pump` is required:
+
+```java
+@Provides Pump providePump(Thermosiphon pump) {
+  return pump;
+}
+```
+
+All `@Provides` methods must belong to a module. These are just classes that have an `@Module` annotation.
+
+```java
+@Module
+class DripCoffeeModule {
+  @Provides Heater provideHeater() {
+    return new ElectricHeater();
+  }
+
+  @Provides Pump providePump(Thermosiphon pump) {
+    return pump;
+  }
+}
+```
+
+By convention, `@Provides` methods are named with a `provide` prefix and module classes are named with a `Module` suffix.
+
+### Building the Graph
+
+The `@Inject` and `@Provides`-annotated classes form a graph of objects, linked by their dependencies. Obtain this graph by calling `ObjectGraph.get()`, which accepts one or more modules:
+
+```java
+ObjectGraph objectGraph = ObjectGraph.get(new DripCoffeeModule());
+```
+
+In order to put the graph to use we need to create an **entry point**. This is usually the main class that starts the application. In this example, the `CoffeeApp` class serves as the entry point. We construct an instance of this type and then ask the object graph to inject its fields.
+
+```java
+class CoffeeApp implements Runnable {
+  @Inject CoffeeMaker coffeeMaker;
+
+  @Override public void run() {
+    coffeeMaker.brew();
+  }
+
+  public static void main(String[] args) {
+    ObjectGraph objectGraph = ObjectGraph.get(new DripCoffeeModule());
+    CoffeeApp coffeeApp = new CoffeeApp();
+    objectGraph.inject(coffeeApp);
+    ...
+  }
+}
+```
+
+The only thing that's missing is that the entry point class `CoffeeApp` isn't included in the graph. We need to explicitly register it as an entry point in the `@Module` annotation.
+
+```java
+@Module(
+    entryPoints = CoffeeApp.class
+)
+class DripCoffeeModule {
+  ...
+}
+```
+
+Entry points enable the complete graph to be validated **at compile time**. Detecting problems early speeds up development and takes some of the danger out of refactoring.
+
+Now that the graph is constructed and the entry point is injected, we run our coffee maker app. Fun.
+
+```
+$ java -cp ... coffee.CoffeeApp
+~ ~ ~ heating ~ ~ ~
+=> => pumping => =>
+ [_]P coffee! [_]P
+```
+
+### Singletons
+
+Annotate an `@Provides` method or injectable class with `@Singleton`. The graph will use a single instance of the value for all of its clients.
+
+```java
+@Provides @Singleton Heater provideHeater() {
+  return new ElectricHeater();
+}
+```
+
+The `@Singleton` annotation on an injectable class also serves as documentation. It reminds potential maintainers that this class may be shared by multiple threads.
+
+```java
+@Singleton
+class CoffeeMaker {
+  ...
+}
+```
+
+### Providers
+
+Not to be confused with `@Provides`, a `Provider` is a special dependency that can be used to retrieve any number of instances. Use a `Provider` to make a dependency lazy:
+
+```java
+class GridingCoffeeMaker {
+  @Inject Provider<Grinder> grinderProvider;
+
+  public void brew() {
+    if (needsGrinding()) {
+      Grinder grinder = grinderProvider.get();
+      ...
+    }
+  }
+}
+```
+
+Or when multiple values are required:
+
+```java
+class BigCoffeeMaker {
+  @Inject Provider<Filter> filterProvider;
+
+  public void brew(int numberOfPots) {
+    for (int p = 0; p < numberOfPots; p++) {
+      Filter coffeeFilter = filterProvider.get();
+      ...
+    }
+  }
+}
+```
+
+### Qualifiers
+
+Sometimes the type alone is insufficient to identify a dependency. For example, a sophisticated coffee maker app may want separate heaters for the water and the hot plate.
+
+In this case, we add a **qualifier annotation**. This is any annotation that itself has a `@Qualifier` annotation. Here's the declaration of `@Named`, a qualifier annotation included in `javax.inject`:
+
+```java
+@Qualifier
+@Documented
+@Retention(RUNTIME)
+public @interface Named {
+  String value() default "";
+}
+```
+
+Create your own qualifier annotations just use `@Named`. Apply qualifiers by annotating the field or parameter of interest. The type and qualifier annotation will both be used to identify the dependency.
+
+```java
+class ExpensiveCoffeeMaker {
+  @Inject @Named("water") Heater waterHeater;
+  @Inject @Named("hot plate") Heater hotPlateHeater;
+  ...
+}
+```
+
+Supply qualified values by annotating the corresponding `@Provides` method.
+
+```java
+@Provides @Named("hot plate") Heater provideHotPlateHeater() {
+  return new ElectricHeater(70);
+}
+
+@Provides @Named("water") Heater provideWaterHeater() {
+  return new ElectricHeater(93);
+}
+```
+
+Dependencies may not have multiple qualifier annotations.
+
+
+Upgrading from Guice
+====================
+
+Some notable Guice features that ObjectGraph doesn't support:
+
+* Injecting `final` fields and `private` members. For best performance `ObjectGraph` generates code. Work around this by using constructor injection.
+* Eager singletons. Work around this by creating an `EagerSingletons` class that declares static fields for each eager singleton.
+* Method injection.
+* Classes that lack `@Inject` annotations cannot be constructed by ObjectGraph, even if they have a no-argument constructor.
 
 
 Contributing
-------------
+============
 
 If you would like to contribute code to ObjectGraph you can do so through
 GitHub by forking the repository and sending a pull request.
@@ -17,7 +258,7 @@
 `checkstyle-result.xml` file.
 
 Before your code can be accepted into the project you must also sign the
-[Individual Contributor License Agreement (CLA)][1].
+[Individual Contributor License Agreement (CLA)][2].
 
 
 License
@@ -37,4 +278,5 @@
     See the License for the specific language governing permissions and
     limitations under the License.
 
- [1]: https://spreadsheets.google.com/spreadsheet/viewform?formkey=dDViT2xzUHAwRkI3X3k5Z0lQM091OGc6MQ&ndplr=1
+ [1]: http://atinject.googlecode.com/svn/trunk/javadoc/javax/inject/package-summary.html
+ [2]: https://spreadsheets.google.com/spreadsheet/viewform?formkey=dDViT2xzUHAwRkI3X3k5Z0lQM091OGc6MQ&ndplr=1
/Fim/
diff --git a/androidmanifest/pom.xml b/androidmanifest/pom.xml
index 6eb9d19..6a52004 100644
--- a/androidmanifest/pom.xml
+++ b/androidmanifest/pom.xml
@@ -33,7 +33,7 @@
         <dependency>
             <groupId>com.squareup</groupId>
             <artifactId>objectgraph</artifactId>
-            <version>1.0-SNAPSHOT</version>
+            <version>${project.version}</version>
         </dependency>
     </dependencies>
 </project>
/Fim/
diff --git a/example/pom.xml b/example/pom.xml
new file mode 100644
index 0000000..e55ddc7
--- /dev/null
+++ b/example/pom.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2012 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+        xmlns="http://maven.apache.org/POM/4.0.0"
+        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+        xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <groupId>com.squareup</groupId>
+        <artifactId>objectgraph-parent</artifactId>
+        <version>1.0-SNAPSHOT</version>
+        <relativePath>../pom.xml</relativePath>
+    </parent>
+    <artifactId>objectgraph-example</artifactId>
+    <packaging>jar</packaging>
+    <name>ObjectGraph Example</name>
+
+    <dependencies>
+        <dependency>
+            <groupId>com.squareup</groupId>
+            <artifactId>objectgraph</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+    </dependencies>
+</project>
/Fim/
diff --git a/example/src/main/java/coffee/CoffeeApp.java b/example/src/main/java/coffee/CoffeeApp.java
new file mode 100644
index 0000000..831c9ff
--- /dev/null
+++ b/example/src/main/java/coffee/CoffeeApp.java
@@ -0,0 +1,19 @@
+package coffee;
+
+import com.squareup.objectgraph.ObjectGraph;
+import javax.inject.Inject;
+
+class CoffeeApp implements Runnable {
+  @Inject CoffeeMaker coffeeMaker;
+
+  @Override public void run() {
+    coffeeMaker.brew();
+  }
+
+  public static void main(String[] args) {
+    ObjectGraph objectGraph = ObjectGraph.get(new DripCoffeeModule());
+    CoffeeApp coffeeApp = new CoffeeApp();
+    objectGraph.inject(coffeeApp);
+    coffeeApp.run();
+  }
+}
/Fim/
diff --git a/example/src/main/java/coffee/CoffeeMaker.java b/example/src/main/java/coffee/CoffeeMaker.java
new file mode 100644
index 0000000..c6b5a78
--- /dev/null
+++ b/example/src/main/java/coffee/CoffeeMaker.java
@@ -0,0 +1,15 @@
+package coffee;
+
+import javax.inject.Inject;
+
+class CoffeeMaker {
+  @Inject Heater heater;
+  @Inject Pump pump;
+
+  public void brew() {
+    heater.on();
+    pump.pump();
+    System.out.println(" [_]P coffee! [_]P ");
+    heater.off();
+  }
+}
/Fim/
diff --git a/example/src/main/java/coffee/DripCoffeeModule.java b/example/src/main/java/coffee/DripCoffeeModule.java
new file mode 100644
index 0000000..9102afd
--- /dev/null
+++ b/example/src/main/java/coffee/DripCoffeeModule.java
@@ -0,0 +1,17 @@
+package coffee;
+
+import com.squareup.objectgraph.Module;
+import com.squareup.objectgraph.Provides;
+import javax.inject.Singleton;
+
+@Module(
+    entryPoints = CoffeeApp.class
+)
+class DripCoffeeModule {
+  @Provides @Singleton Heater provideHeater() {
+    return new ElectricHeater();
+  }
+  @Provides Pump providePump(Thermosiphon pump) {
+    return pump;
+  }
+}
/Fim/
diff --git a/example/src/main/java/coffee/ElectricHeater.java b/example/src/main/java/coffee/ElectricHeater.java
new file mode 100644
index 0000000..fbab399
--- /dev/null
+++ b/example/src/main/java/coffee/ElectricHeater.java
@@ -0,0 +1,18 @@
+package coffee;
+
+class ElectricHeater implements Heater {
+  boolean heating;
+
+  @Override public void on() {
+    System.out.println("~ ~ ~ heating ~ ~ ~");
+    this.heating = true;
+  }
+
+  @Override public void off() {
+    this.heating = false;
+  }
+
+  @Override public boolean isHot() {
+    return heating;
+  }
+}
/Fim/
diff --git a/example/src/main/java/coffee/Heater.java b/example/src/main/java/coffee/Heater.java
new file mode 100644
index 0000000..b5ddb6b
--- /dev/null
+++ b/example/src/main/java/coffee/Heater.java
@@ -0,0 +1,7 @@
+package coffee;
+
+interface Heater {
+  void on();
+  void off();
+  boolean isHot();
+}
/Fim/
diff --git a/example/src/main/java/coffee/Pump.java b/example/src/main/java/coffee/Pump.java
new file mode 100644
index 0000000..e394349
--- /dev/null
+++ b/example/src/main/java/coffee/Pump.java
@@ -0,0 +1,5 @@
+package coffee;
+
+interface Pump {
+  void pump();
+}
/Fim/
diff --git a/example/src/main/java/coffee/Thermosiphon.java b/example/src/main/java/coffee/Thermosiphon.java
new file mode 100644
index 0000000..c9f9828
--- /dev/null
+++ b/example/src/main/java/coffee/Thermosiphon.java
@@ -0,0 +1,18 @@
+package coffee;
+
+import javax.inject.Inject;
+
+class Thermosiphon implements Pump {
+  private final Heater heater;
+
+  @Inject
+  Thermosiphon(Heater heater) {
+    this.heater = heater;
+  }
+
+  @Override public void pump() {
+    if (heater.isHot()) {
+      System.out.println("=> => pumping => =>");
+    }
+  }
+}
/Fim/
diff --git a/pom.xml b/pom.xml
index a7e54b0..6f7d9c2 100644
--- a/pom.xml
+++ b/pom.xml
@@ -31,6 +31,7 @@
     <modules>
         <module>core</module>
         <module>androidmanifest</module>
+        <module>example</module>
     </modules>
 
     <properties>
/Fim/
diff --git a/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java b/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
index c74b3a5..dc656da 100644
--- a/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
+++ b/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
@@ -18,7 +18,10 @@
 import com.squareup.objectgraph.Module;
 import com.squareup.objectgraph.internal.codegen.JavaWriter;
 import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.OutputStreamWriter;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -36,7 +39,6 @@
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 
-// TODO: support inner classes
 // TODO: support relative class name references like ".FooActivity"
 
 /**
@@ -51,9 +53,9 @@
    *
    * @param baseDir the directory where generated files are to be created.
    */
-  public File path(Document manifest, File baseDir) {
+  public File path(Document manifest, String moduleName, File baseDir) {
     String packageName = packageName(manifest);
-    return new File(baseDir, packageName.replace('.', '/') + "/ManifestModule.java");
+    return new File(baseDir, packageName.replace('.', '/') + "/" + moduleName + ".java");
   }
 
   String packageName(Document manifest) {
@@ -68,15 +70,15 @@
     return packageAttr.getValue();
   }
 
-  public void generate(Document manifest, JavaWriter out) throws IOException {
+  public void generate(Document manifest, String moduleName, JavaWriter out) throws IOException {
     String packageName = packageName(manifest);
     List<String> nameReferences = getNameReferences(manifest);
-    generate(packageName, nameReferences, out);
+    generate(packageName, nameReferences, moduleName, out);
   }
 
-  void generate(String packageName, List<String> nameReferences, JavaWriter out)
+  void generate(String packageName, List<String> nameReferences, String moduleName, JavaWriter out)
       throws IOException {
-    String className = packageName + ".ManifestModule";
+    String className = packageName + "." + moduleName;
     out.addPackage(packageName);
     out.addImport(Module.class);
 
@@ -97,7 +99,7 @@
   private List<String> namesToClassLiterals(List<String> classNameReferences) {
     List<String> result = new ArrayList<String>();
     for (String name : classNameReferences) {
-      result.add(name + ".class");
+      result.add(name.replace('$', '.') + ".class");
     }
     return result;
   }
@@ -152,4 +154,43 @@
     DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
     return documentBuilder.parse(androidManifestIn);
   }
+
+  public static void main(String[] args) throws Exception {
+    if (args.length != 3) {
+      printUsage();
+      return;
+    }
+
+    File manifestXml = new File(args[0]);
+    String moduleName = args[1];
+    File baseDir = new File(args[2]);
+
+    if (!manifestXml.exists()) {
+      System.out.println("No such file: " + manifestXml);
+      printUsage();
+      return;
+    }
+
+    if (!baseDir.isDirectory()) {
+      System.out.println("No such directory: " + baseDir);
+      printUsage();
+      return;
+    }
+
+    ModuleGenerator moduleGenerator = new ModuleGenerator();
+    InputSource in = new InputSource(new FileInputStream(manifestXml));
+    Document document = moduleGenerator.manifestToDocument(in);
+    File file = moduleGenerator.path(document, moduleName, baseDir);
+    file.getParentFile().mkdirs();
+    JavaWriter out = new JavaWriter(new OutputStreamWriter(new FileOutputStream(file), "UTF-8"));
+    moduleGenerator.generate(document, moduleName, out);
+    out.close();
+  }
+
+  private static void printUsage() {
+    System.out.println("Usage: ModuleGenerator manifest module out");
+    System.out.println("  manifest: path to AndroidManifest.xml");
+    System.out.println("    module: name of the generated class, like 'ManifestModule'");
+    System.out.println("       out: base directory for generated .java source files");
+  }
 }
/Fim/
diff --git a/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java b/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java
index 9365600..b6af824 100644
--- a/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java
+++ b/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java
@@ -94,15 +94,15 @@
     String packageName = "com.squareup.badhorse";
     List<String> nameReferences = Arrays.asList(
         "com.squareup.badhorse.SinActivity", "com.squareup.badhorse.LeagueOfEvilActivity");
-    generator.generate(packageName, nameReferences, new JavaWriter(stringWriter));
+    generator.generate(packageName, nameReferences, "ManifestModule", new JavaWriter(stringWriter));
     assertCode(""
         + "package com.squareup.badhorse;\n"
         + "import com.squareup.objectgraph.Module;\n"
         + "@Module(\n"
-        + "  entryPoints = [\n"
+        + "  entryPoints = {\n"
         + "    com.squareup.badhorse.LeagueOfEvilActivity.class,\n"
         + "    com.squareup.badhorse.SinActivity.class\n"
-        + "  ]\n"
+        + "  }\n"
         + ")\n"
         + "public final class ManifestModule {\n"
         + "}\n");
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java b/core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
index 62d2bf3..ad3b4db 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
@@ -304,7 +304,7 @@
    */
   private void annotationValue(Object value) throws IOException {
     if (value instanceof Object[]) {
-      out.write("[");
+      out.write("{");
       boolean firstValue = true;
       pushScope(Scope.ANNOTATION_ARRAY_VALUE);
       for (Object o : ((Object[]) value)) {
@@ -320,7 +320,7 @@
       popScope(Scope.ANNOTATION_ARRAY_VALUE);
       out.write("\n");
       indent();
-      out.write("]");
+      out.write("}");
     } else {
       out.write(value.toString());
     }
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java b/core/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java
index 410f931..ac414b4 100644
--- a/core/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java
+++ b/core/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java
@@ -256,11 +256,11 @@
         + "package com.squareup;\n"
         + "@Module(\n"
         + "  overrides = true,\n"
-        + "  entryPoints = [\n"
+        + "  entryPoints = {\n"
         + "    entryPointA,\n"
         + "    entryPointB,\n"
         + "    entryPointC\n"
-        + "  ],\n"
+        + "  },\n"
         + "  staticInjections = com.squareup.Quux\n"
         + ")\n"
         + "class FooModule {\n"
/Fim/
diff --git a/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java b/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
index e17dd7e..aca30f8 100644
--- a/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
+++ b/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
@@ -46,7 +46,8 @@
  * classes referenced in an {@code AndroidManifest.xml} file.
  */
 public final class ModuleGenerator {
-  private static final String NAMESPACE = "http://schemas.android.com/apk/res/android";
+  private static final String ANDROID_NS = "http://schemas.android.com/apk/res/android";
+  private static final String OBJECTGRAPH_NS = "http://github.com/square/objectgraph";
 
   /**
    * Returns the path of the generated ManifestModule.java for {@code manifest}.
@@ -135,10 +136,14 @@
             || tagName.equals("provider")
             || tagName.equals("receiver")
             || tagName.equals("service")) {
-          Attr nameAttr = ee.getAttributeNodeNS(NAMESPACE, "name");
+          Attr nameAttr = ee.getAttributeNodeNS(ANDROID_NS, "name");
           if (nameAttr == null) {
             throw new IllegalArgumentException("Expected a name attribute on " + ee);
           }
+          Attr entryPointAttr = ee.getAttributeNodeNS(OBJECTGRAPH_NS, "entryPoint");
+          if (entryPointAttr != null && !Boolean.valueOf(entryPointAttr.getValue())) {
+            continue;
+          }
           result.add(nameAttr.getValue());
         }
       }
/Fim/
diff --git a/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java b/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java
index 2fbee77..c855358 100644
--- a/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java
+++ b/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java
@@ -30,29 +30,6 @@
 import static org.junit.Assert.fail;
 
 public final class ModuleGeneratorTest {
-  private static final String MANIFEST_XML = ""
-      + "<manifest"
-      + "    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n"
-      + "    package=\"com.squareup.badhorse\">\n"
-      + "  <uses-permission android:name=\"not.an.entry.point\"/>\n"
-      + "  <permission android:name=\"not.an.entry.point\"/>\n"
-      + "  <application android:name=\"not.an.entry.point\">\n"
-      + "    <uses-library android:name=\"not.an.entry.point\"/>\n"
-      + "    <activity android:name=\"result.a.Activity\">\n"
-      + "      <intent-filter>\n"
-      + "        <action android:name=\"not.an.entry.point\"/>\n"
-      + "        <category android:name=\"not.an.entry.point\"/>\n"
-      + "      </intent-filter>\n"
-      + "    </activity>\n"
-      + "    <provider android:name=\"result.b.Provider\"/>\n"
-      + "    <receiver android:name=\"result.c.Receiver\">\n"
-      + "      <intent-filter>\n"
-      + "        <action android:name=\"not.an.entry.point\"/>\n"
-      + "      </intent-filter>\n"
-      + "    </receiver>\n"
-      + "    <service android:name=\"result.d.Service\"/>\n"
-      + "  </application>\n"
-      + "</manifest>\n";
   private ModuleGenerator generator = new ModuleGenerator();
   private StringWriter stringWriter = new StringWriter();
 
@@ -93,11 +70,51 @@
   }
 
   @Test public void extractEntryPointNames() throws Exception {
-    Document document = document(MANIFEST_XML);
+    String manifestXml = ""
+        + "<manifest"
+        + "    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n"
+        + "    package=\"com.squareup.badhorse\">\n"
+        + "  <uses-permission android:name=\"not.an.entry.point\"/>\n"
+        + "  <permission android:name=\"not.an.entry.point\"/>\n"
+        + "  <application android:name=\"not.an.entry.point\">\n"
+        + "    <uses-library android:name=\"not.an.entry.point\"/>\n"
+        + "    <activity android:name=\"result.a.Activity\">\n"
+        + "      <intent-filter>\n"
+        + "        <action android:name=\"not.an.entry.point\"/>\n"
+        + "        <category android:name=\"not.an.entry.point\"/>\n"
+        + "      </intent-filter>\n"
+        + "    </activity>\n"
+        + "    <provider android:name=\"result.b.Provider\"/>\n"
+        + "    <receiver android:name=\"result.c.Receiver\">\n"
+        + "      <intent-filter>\n"
+        + "        <action android:name=\"not.an.entry.point\"/>\n"
+        + "      </intent-filter>\n"
+        + "    </receiver>\n"
+        + "    <service android:name=\"result.d.Service\"/>\n"
+        + "  </application>\n"
+        + "</manifest>\n";
+    Document document = document(manifestXml);
     assertThat(generator.getNameReferences(document)).isEqualTo(Arrays.asList(
         "result.a.Activity", "result.b.Provider", "result.c.Receiver", "result.d.Service"));
   }
 
+  @Test public void excludedEntryPointNames() throws Exception {
+    String manifestXml = ""
+        + "<manifest"
+        + "    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n"
+        + "    xmlns:objectgraph=\"http://github.com/square/objectgraph\"\n"
+        + "    package=\"com.squareup.badhorse\">\n"
+        + "  <application>\n"
+        + "    <activity android:name=\"false.Activity\" objectgraph:entryPoint=\"false\"/>\n"
+        + "    <activity android:name=\"true.Activity\" objectgraph:entryPoint=\"true\"/>\n"
+        + "    <activity android:name=\"default.Activity\"/>\n"
+        + "  </application>\n"
+        + "</manifest>\n";
+    Document document = document(manifestXml);
+    assertThat(generator.getNameReferences(document))
+        .isEqualTo(Arrays.asList("true.Activity", "default.Activity"));
+  }
+
   @Test public void generate() throws IOException {
     String packageName = "com.squareup.badhorse";
     List<String> nameReferences = Arrays.asList(
/Fim/
diff --git a/README.md b/README.md
index 26bef4d..8100541 100644
--- a/README.md
+++ b/README.md
@@ -233,120 +233,6 @@
 
 Dependencies may not have multiple qualifier annotations.
 
-### Static Injection
-
-**Warning:** This feature should be used sparingly because static dependencies are difficult to test and reuse.
-
-ObjectGraph can inject static fields. Classes that declare static fields with `@Inject` annotations must be listed as `staticInjections` in a module annotation.
-
-```java
-@Module(
-    staticInjections = LegacyCoffeeUtils.class
-)
-class LegacyModule {
-}
-```
-
-Use `ObjectGraph.injectStatics()` to populate these static fields with their injected values:
-
-```java
-ObjectGraph objectGraph = ObjectGraph.get(new LegacyModule());
-objectGraph.injectStatics();
-```
-
-### Compile-time Validation
-
-ObjectGraph includes an [annotation processor][2] that validates modules and injections. This processor is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is missing a binding for `Executor`:
-
-```java
-@Module
-class DripCoffeeModule {
-  @Provides Heater provideHeater(Executor executor) {
-    return new CpuHeater(executor);
-  }
-}
-```
-
-When compiling it, `javac` rejects the missing binding:
-
-```
-[ERROR] COMPILATION ERROR : 
-[ERROR] error: No binding for java.util.concurrent.Executor
-               required by provideHeater(java.util.concurrent.Executor)
-```
-
-Fix the problem either by adding the an `@Provides`-annotated method for `Executor`, or by marking the module as incomplete. Incomplete modules are permitted to have missing dependencies.
-
-```java
-@Module(complete = false)
-class DripCoffeeModule {
-  @Provides Heater provideHeater(Executor executor) {
-    return new CpuHeater(executor);
-  }
-}
-```
-
-To get the most out of compile-time validation, create a module that includes all of your application's modules as children. The annotation processor will detect problems across the modules and report them.
-
-```java
-@Module(
-    children = {
-        DripCoffeeModule.class,
-        ExecutorModule.class
-    }
-)
-public class CoffeeAppModule {
-}
-```
-
-The annotation processor is enabled automatically when you include ObjectGraph's jar file on your compile classpath.
-
-### Compile-time Code Generation
-
-ObjectGraph's annotation processor may also generate source files with names like `CoffeeMaker$InjectAdapter.java` or `DripCoffeeModule$ModuleAdapter`. These files are ObjectGraph implementation details. You shouldn't need to use them directly, though they can be handy when step-debugging through an injection.
-
-### Module overrides
-
-ObjectGraph will fail with an error if there are multiple competing `@Provides` methods for the same dependency. But sometimes it's necessary to replace production code with a substitute for development or testing. Using `overrides = true` in a module annotation lets you take precedence over the bindings of other modules.
-
-This JUnit test overrides `DripCoffeeModule`'s binding for `Heater` with a mock object from [Mockito][3]. The mock gets injected into the `CoffeeMaker` and also into the test.
-
-```java
-public class CoffeeMakerTest {
-  @Inject CoffeeMaker coffeeMaker;
-  @Inject Heater heater;
-
-  @Before public void setUp() {
-    ObjectGraph.get(new TestModule()).inject(this);
-  }
-
-  @Module(
-      children = DripCoffeeModule.class,
-      entryPoints = CoffeeMakerTest.class,
-      overrides = true
-  )
-  static class TestModule {
-    @Provides @Singleton Heater provideHeater() {
-      return Mockito.mock(Heater.class);
-    }
-  }
-
-  @Test public void testHeaterIsTurnedOnAndThenOff() {
-    Mockito.when(heater.isHot()).thenReturn(true);
-    coffeeMaker.brew();
-    Mockito.verify(heater, Mockito.times(1)).on();
-    Mockito.verify(heater, Mockito.times(1)).off();
-  }
-}
-```
-
-Overrides are best suited for small variations on the application:
-
-* Replacing the real implementation with a mock for unit tests.
-* Replacing LDAP authentication with fake authentication for development.
-
-For more substantial variations it's often simpler to use a different combination of modules.
-
 
 Upgrading from Guice
 ====================
@@ -372,7 +258,7 @@
 `checkstyle-result.xml` file.
 
 Before your code can be accepted into the project you must also sign the
-[Individual Contributor License Agreement (CLA)][4].
+[Individual Contributor License Agreement (CLA)][2].
 
 
 License
@@ -393,6 +279,4 @@
     limitations under the License.
 
  [1]: http://atinject.googlecode.com/svn/trunk/javadoc/javax/inject/package-summary.html
- [2]: http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html
- [3]: http://mockito.googlecode.com/
- [4]: https://spreadsheets.google.com/spreadsheet/viewform?formkey=dDViT2xzUHAwRkI3X3k5Z0lQM091OGc6MQ&ndplr=1
+ [2]: https://spreadsheets.google.com/spreadsheet/viewform?formkey=dDViT2xzUHAwRkI3X3k5Z0lQM091OGc6MQ&ndplr=1
/Fim/
diff --git a/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java b/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
index 7c5e061..aca30f8 100644
--- a/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
+++ b/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
@@ -25,7 +25,7 @@
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.LinkedHashMap;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import javax.xml.parsers.DocumentBuilder;
@@ -95,9 +95,8 @@
 
     List<String> classLiterals = namesToClassLiterals(nameReferences);
     Collections.sort(classLiterals);
-    Map<String, Object> attributes = new LinkedHashMap<String, Object>();
+    Map<String, Object> attributes = new HashMap<String, Object>();
     attributes.put("entryPoints", classLiterals.toArray());
-    attributes.put("complete", "false");
 
     out.annotation(Module.class, attributes);
     out.beginType(className, "class", Modifier.PUBLIC | Modifier.FINAL);
/Fim/
diff --git a/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java b/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java
index 8d3a64c..c855358 100644
--- a/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java
+++ b/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java
@@ -128,8 +128,7 @@
         + "  entryPoints = {\n"
         + "    com.squareup.badhorse.LeagueOfEvilActivity.class,\n"
         + "    com.squareup.badhorse.SinActivity.class\n"
-        + "  },\n"
-        + "  complete = false\n"
+        + "  }\n"
         + ")\n"
         + "public final class ActivitiesModule {\n"
         + "}\n");
@@ -145,8 +144,7 @@
         + "import com.squareup.objectgraph.Module;\n"
         + "@Module(\n"
         + "  entryPoints = {\n"
-        + "  },\n"
-        + "  complete = false\n"
+        + "  }\n"
         + ")\n"
         + "public final class ActivitiesModule {\n"
         + "}\n");
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/Module.java b/core/src/main/java/com/squareup/objectgraph/Module.java
index 842d555..c93bfcd 100644
--- a/core/src/main/java/com/squareup/objectgraph/Module.java
+++ b/core/src/main/java/com/squareup/objectgraph/Module.java
@@ -48,7 +48,6 @@
    * True if all of the bindings required by this module can also be satisfied
    * by this module. If a module is complete it is eligible for additional
    * static checking: tools can detect if required bindings are not available.
-   * Modules that have external dependencies must use {@code complete = false}.
    */
-  boolean complete() default true;
+  boolean complete() default false;
 }
/Fim/
diff --git a/example/src/main/java/coffee/CoffeeMaker.java b/example/src/main/java/coffee/CoffeeMaker.java
index c6b5a78..233917c 100644
--- a/example/src/main/java/coffee/CoffeeMaker.java
+++ b/example/src/main/java/coffee/CoffeeMaker.java
@@ -2,14 +2,16 @@
 
 import javax.inject.Inject;
 
+import com.squareup.objectgraph.Lazy;
+
 class CoffeeMaker {
-  @Inject Heater heater;
+  @Inject Lazy<Heater> heater; // Don't want to create a possibly costly heater until we need it.
   @Inject Pump pump;
 
   public void brew() {
-    heater.on();
+    heater.get().on();
     pump.pump();
     System.out.println(" [_]P coffee! [_]P ");
-    heater.off();
+    heater.get().off();
   }
 }
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/RuntimeLinker.java b/core/src/main/java/com/squareup/objectgraph/internal/RuntimeLinker.java
index 4fe5ae2..c1cf027 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/RuntimeLinker.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/RuntimeLinker.java
@@ -35,9 +35,8 @@
       Constructor<?> constructor = c.getConstructor();
       constructor.setAccessible(true);
       return (Binding<?>) constructor.newInstance();
-    } catch (Exception e) {
-      LOGGER.log(Level.FINE, "No generated inject adapter for " + className
-          + ". Falling back to reflection.", e);
+    } catch (Exception ignored) {
+      // Fall back to reflection.
     }
 
     // Handle class bindings by injecting @Inject-annotated members.
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/RuntimeLinker.java b/core/src/main/java/com/squareup/objectgraph/internal/RuntimeLinker.java
index c1cf027..a90ca9a 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/RuntimeLinker.java
+++ b/core/src/main/java/com/squareup/objectgraph/internal/RuntimeLinker.java
@@ -18,7 +18,6 @@
 import com.squareup.objectgraph.ObjectGraph;
 import java.lang.reflect.Constructor;
 import java.util.List;
-import java.util.logging.Level;
 import java.util.logging.Logger;
 
 /**
/Fim/
diff --git a/README.md b/README.md
index 26bef4d..cffeda4 100644
--- a/README.md
+++ b/README.md
@@ -1,5 +1,5 @@
-ObjectGraph
-===========
+Dagger
+======
 
 A fast dependency injector for Android and Java.
 
@@ -9,7 +9,7 @@
 
 To contrast, the worst classes in any application are the ones that take up space without doing much at all: the `BarcodeDecoderFactory`, the `CameraServiceLoader`, and the `MutableContextWrapper`. These classes are the clumsy duct tape that wires the interesting stuff together.
 
-ObjectGraph is a replacement for these `FactoryFactory` classes. It allows you to focus on the interesting classes. Declare dependencies, specify how to satisfy them, and ship your app.
+Dagger is a replacement for these `FactoryFactory` classes. It allows you to focus on the interesting classes. Declare dependencies, specify how to satisfy them, and ship your app.
 
 By building on standard [javax.inject][1] annotations (JSR-330), each class is **easy to test**. You don't need a bunch of boilerplate just to swap the `RpcCreditCardService` out for a `FakeCreditCardService`.
 
@@ -17,9 +17,9 @@
 
 ### Declaring Dependencies
 
-ObjectGraph constructs instances of your application classes and satisfies their dependencies. It uses the `javax.inject.Inject` annotation to identify which constructors and fields it is interested in.
+Dagger constructs instances of your application classes and satisfies their dependencies. It uses the `javax.inject.Inject` annotation to identify which constructors and fields it is interested in.
 
-Use `@Inject` to annotate the constructor that ObjectGraph should use to create instances of a class. When a new instance is requested, ObjectGraph will obtain the required parameters values and invoke this constructor.
+Use `@Inject` to annotate the constructor that Dagger should use to create instances of a class. When a new instance is requested, Dagger will obtain the required parameters values and invoke this constructor.
 
 ```java
 class Thermosiphon implements Pump {
@@ -34,7 +34,7 @@
 }
 ```
 
-ObjectGraph can inject fields directly. In this example it obtains a `Heater` instance for the `heater` field and a `Pump` instance for the `pump` field.
+Dagger can inject fields directly. In this example it obtains a `Heater` instance for the `heater` field and a `Pump` instance for the `pump` field.
 
 ```java
 class CoffeeMaker {
@@ -45,13 +45,13 @@
 }
 ```
 
-If your class has `@Inject`-annotated fields but no `@Inject`-annotated constructor, ObjectGraph will use a no-argument constructor if it exists. Classes that lack `@Inject` annotations cannot be constructed by ObjectGraph.
+If your class has `@Inject`-annotated fields but no `@Inject`-annotated constructor, Dagger will use a no-argument constructor if it exists. Classes that lack `@Inject` annotations cannot be constructed by Dagger.
 
-ObjectGraph does not support method injection.
+Dagger does not support method injection.
 
 ### Satisfying Dependencies
 
-By default, ObjectGraph satisfies each dependency by constructing an instance of the requested type as described above. When you request a `CoffeeMaker`, it'll obtain one by calling `new CoffeeMaker()` and setting its injectable fields.
+By default, Dagger satisfies each dependency by constructing an instance of the requested type as described above. When you request a `CoffeeMaker`, it'll obtain one by calling `new CoffeeMaker()` and setting its injectable fields.
 
 But `@Inject` doesn't work everywhere:
 
@@ -237,7 +237,7 @@
 
 **Warning:** This feature should be used sparingly because static dependencies are difficult to test and reuse.
 
-ObjectGraph can inject static fields. Classes that declare static fields with `@Inject` annotations must be listed as `staticInjections` in a module annotation.
+Dagger can inject static fields. Classes that declare static fields with `@Inject` annotations must be listed as `staticInjections` in a module annotation.
 
 ```java
 @Module(
@@ -256,7 +256,7 @@
 
 ### Compile-time Validation
 
-ObjectGraph includes an [annotation processor][2] that validates modules and injections. This processor is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is missing a binding for `Executor`:
+Dagger includes an [annotation processor][2] that validates modules and injections. This processor is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is missing a binding for `Executor`:
 
 ```java
 @Module
@@ -299,15 +299,15 @@
 }
 ```
 
-The annotation processor is enabled automatically when you include ObjectGraph's jar file on your compile classpath.
+The annotation processor is enabled automatically when you include Dagger's jar file on your compile classpath.
 
 ### Compile-time Code Generation
 
-ObjectGraph's annotation processor may also generate source files with names like `CoffeeMaker$InjectAdapter.java` or `DripCoffeeModule$ModuleAdapter`. These files are ObjectGraph implementation details. You shouldn't need to use them directly, though they can be handy when step-debugging through an injection.
+Dagger's annotation processor may also generate source files with names like `CoffeeMaker$InjectAdapter.java` or `DripCoffeeModule$ModuleAdapter`. These files are Dagger implementation details. You shouldn't need to use them directly, though they can be handy when step-debugging through an injection.
 
 ### Module overrides
 
-ObjectGraph will fail with an error if there are multiple competing `@Provides` methods for the same dependency. But sometimes it's necessary to replace production code with a substitute for development or testing. Using `overrides = true` in a module annotation lets you take precedence over the bindings of other modules.
+Dagger will fail with an error if there are multiple competing `@Provides` methods for the same dependency. But sometimes it's necessary to replace production code with a substitute for development or testing. Using `overrides = true` in a module annotation lets you take precedence over the bindings of other modules.
 
 This JUnit test overrides `DripCoffeeModule`'s binding for `Heater` with a mock object from [Mockito][3]. The mock gets injected into the `CoffeeMaker` and also into the test.
 
@@ -351,18 +351,18 @@
 Upgrading from Guice
 ====================
 
-Some notable Guice features that ObjectGraph doesn't support:
+Some notable Guice features that Dagger doesn't support:
 
-* Injecting `final` fields and `private` members. For best performance `ObjectGraph` generates code. Work around this by using constructor injection.
+* Injecting `final` fields and `private` members. For best performance Dagger generates code. Work around this by using constructor injection.
 * Eager singletons. Work around this by creating an `EagerSingletons` class that declares static fields for each eager singleton.
 * Method injection.
-* Classes that lack `@Inject` annotations cannot be constructed by ObjectGraph, even if they have a no-argument constructor.
+* Classes that lack `@Inject` annotations cannot be constructed by Dagger, even if they have a no-argument constructor.
 
 
 Contributing
 ============
 
-If you would like to contribute code to ObjectGraph you can do so through
+If you would like to contribute code to Dagger you can do so through
 GitHub by forking the repository and sending a pull request.
 
 When submitting code, please make every effort to follow existing conventions
/Fim/
diff --git a/androidmanifest/pom.xml b/androidmanifest/pom.xml
index 6a52004..2f8f492 100644
--- a/androidmanifest/pom.xml
+++ b/androidmanifest/pom.xml
@@ -20,19 +20,19 @@
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
     <modelVersion>4.0.0</modelVersion>
     <parent>
-        <groupId>com.squareup</groupId>
-        <artifactId>objectgraph-parent</artifactId>
+        <groupId>org.u2020</groupId>
+        <artifactId>dagger-parent</artifactId>
         <version>1.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
-    <artifactId>objectgraph-androidmanifest</artifactId>
+    <artifactId>dagger-androidmanifest</artifactId>
     <packaging>jar</packaging>
-    <name>ObjectGraph AndroidManifest.xml Module Generator</name>
+    <name>Dagger AndroidManifest.xml Module Generator</name>
 
     <dependencies>
         <dependency>
-            <groupId>com.squareup</groupId>
-            <artifactId>objectgraph</artifactId>
+            <groupId>org.u2020</groupId>
+            <artifactId>dagger</artifactId>
             <version>${project.version}</version>
         </dependency>
     </dependencies>
/Fim/
diff --git a/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
similarity index 95%
rename from androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
rename to androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
index 7c5e061..6a0e079 100644
--- a/androidmanifest/src/main/java/com/squareup/objectgraph/androidmanifest/ModuleGenerator.java
+++ b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.androidmanifest;
+package dagger.androidmanifest;
 
-import com.squareup.objectgraph.Module;
-import com.squareup.objectgraph.internal.codegen.JavaWriter;
+import dagger.Module;
+import dagger.internal.codegen.JavaWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
@@ -47,7 +47,7 @@
  */
 public final class ModuleGenerator {
   private static final String ANDROID_NS = "http://schemas.android.com/apk/res/android";
-  private static final String OBJECTGRAPH_NS = "http://github.com/square/objectgraph";
+  private static final String DAGGER_NS = "https://github.com/u2020/dagger";
 
   /**
    * Returns the path of the generated ManifestModule.java for {@code manifest}.
@@ -141,7 +141,7 @@
           if (nameAttr == null) {
             throw new IllegalArgumentException("Expected a name attribute on " + ee);
           }
-          Attr entryPointAttr = ee.getAttributeNodeNS(OBJECTGRAPH_NS, "entryPoint");
+          Attr entryPointAttr = ee.getAttributeNodeNS(DAGGER_NS, "entryPoint");
           if (entryPointAttr != null && !Boolean.valueOf(entryPointAttr.getValue())) {
             continue;
           }
/Fim/
diff --git a/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java b/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
similarity index 92%
rename from androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java
rename to androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
index 8d3a64c..a6fc08f 100644
--- a/androidmanifest/src/test/java/com/squareup/objectgraph/androidmanifest/ModuleGeneratorTest.java
+++ b/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.androidmanifest;
+package dagger.androidmanifest;
 
-import com.squareup.objectgraph.internal.codegen.JavaWriter;
+import dagger.internal.codegen.JavaWriter;
 import java.io.IOException;
 import java.io.StringReader;
 import java.io.StringWriter;
@@ -102,11 +102,11 @@
     String manifestXml = ""
         + "<manifest"
         + "    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n"
-        + "    xmlns:objectgraph=\"http://github.com/square/objectgraph\"\n"
+        + "    xmlns:dagger=\"https://github.com/u2020/dagger\"\n"
         + "    package=\"com.squareup.badhorse\">\n"
         + "  <application>\n"
-        + "    <activity android:name=\"false.Activity\" objectgraph:entryPoint=\"false\"/>\n"
-        + "    <activity android:name=\"true.Activity\" objectgraph:entryPoint=\"true\"/>\n"
+        + "    <activity android:name=\"false.Activity\" dagger:entryPoint=\"false\"/>\n"
+        + "    <activity android:name=\"true.Activity\" dagger:entryPoint=\"true\"/>\n"
         + "    <activity android:name=\"default.Activity\"/>\n"
         + "  </application>\n"
         + "</manifest>\n";
@@ -123,7 +123,7 @@
         new JavaWriter(stringWriter));
     assertCode(""
         + "package com.squareup.badhorse;\n"
-        + "import com.squareup.objectgraph.Module;\n"
+        + "import dagger.Module;\n"
         + "@Module(\n"
         + "  entryPoints = {\n"
         + "    com.squareup.badhorse.LeagueOfEvilActivity.class,\n"
@@ -142,7 +142,7 @@
         new JavaWriter(stringWriter));
     assertCode(""
         + "package com.squareup.badhorse;\n"
-        + "import com.squareup.objectgraph.Module;\n"
+        + "import dagger.Module;\n"
         + "@Module(\n"
         + "  entryPoints = {\n"
         + "  },\n"
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index e79a9c6..5f32219 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,14 +20,14 @@
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
     <modelVersion>4.0.0</modelVersion>
     <parent>
-        <groupId>com.squareup</groupId>
-        <artifactId>objectgraph-parent</artifactId>
+        <groupId>org.u2020</groupId>
+        <artifactId>dagger-parent</artifactId>
         <version>1.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
-    <artifactId>objectgraph</artifactId>
+    <artifactId>dagger</artifactId>
     <packaging>jar</packaging>
-    <name>ObjectGraph</name>
+    <name>Dagger</name>
 
     <build>
         <plugins>
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/Lazy.java b/core/src/main/java/dagger/Lazy.java
similarity index 96%
rename from core/src/main/java/com/squareup/objectgraph/Lazy.java
rename to core/src/main/java/dagger/Lazy.java
index ac61f60..df18973 100644
--- a/core/src/main/java/com/squareup/objectgraph/Lazy.java
+++ b/core/src/main/java/dagger/Lazy.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 /**
  * A value that is lazily returned. A {@code Lazy<T>} creates or obtains its underlying
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/MembersInjector.java b/core/src/main/java/dagger/MembersInjector.java
similarity index 97%
rename from core/src/main/java/com/squareup/objectgraph/MembersInjector.java
rename to core/src/main/java/dagger/MembersInjector.java
index 5712c7d..372c9f5 100644
--- a/core/src/main/java/com/squareup/objectgraph/MembersInjector.java
+++ b/core/src/main/java/dagger/MembersInjector.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 /**
  * Injects dependencies into the fields and methods on instances of type
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/Module.java b/core/src/main/java/dagger/Module.java
similarity index 98%
rename from core/src/main/java/com/squareup/objectgraph/Module.java
rename to core/src/main/java/dagger/Module.java
index 989de64..9f6e174 100644
--- a/core/src/main/java/com/squareup/objectgraph/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
similarity index 94%
rename from core/src/main/java/com/squareup/objectgraph/ObjectGraph.java
rename to core/src/main/java/dagger/ObjectGraph.java
index cbf331e..d61db8d 100644
--- a/core/src/main/java/com/squareup/objectgraph/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -13,16 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
-import com.squareup.objectgraph.internal.Binding;
-import com.squareup.objectgraph.internal.Keys;
-import com.squareup.objectgraph.internal.Linker;
-import com.squareup.objectgraph.internal.ModuleAdapter;
-import com.squareup.objectgraph.internal.ProblemDetector;
-import com.squareup.objectgraph.internal.RuntimeLinker;
-import com.squareup.objectgraph.internal.StaticInjection;
-import com.squareup.objectgraph.internal.UniqueMap;
+import dagger.internal.Binding;
+import dagger.internal.Keys;
+import dagger.internal.Linker;
+import dagger.internal.ModuleAdapter;
+import dagger.internal.ProblemDetector;
+import dagger.internal.RuntimeLinker;
+import dagger.internal.StaticInjection;
+import dagger.internal.UniqueMap;
 import java.util.Collection;
 import java.util.LinkedHashMap;
 import java.util.Map;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/Provides.java b/core/src/main/java/dagger/Provides.java
similarity index 96%
rename from core/src/main/java/com/squareup/objectgraph/Provides.java
rename to core/src/main/java/dagger/Provides.java
index d67ec33..629819b 100644
--- a/core/src/main/java/com/squareup/objectgraph/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/AtInjectBinding.java b/core/src/main/java/dagger/internal/AtInjectBinding.java
similarity index 99%
rename from core/src/main/java/com/squareup/objectgraph/internal/AtInjectBinding.java
rename to core/src/main/java/dagger/internal/AtInjectBinding.java
index f222d0c..c05c358 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/AtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/AtInjectBinding.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/Binding.java b/core/src/main/java/dagger/internal/Binding.java
similarity index 96%
rename from core/src/main/java/com/squareup/objectgraph/internal/Binding.java
rename to core/src/main/java/dagger/internal/Binding.java
index 634bb25..ac299ca 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/Binding.java
+++ b/core/src/main/java/dagger/internal/Binding.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
-import com.squareup.objectgraph.MembersInjector;
+import dagger.MembersInjector;
 import java.util.Set;
 import javax.inject.Provider;
 
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/BuiltInBinding.java b/core/src/main/java/dagger/internal/BuiltInBinding.java
similarity index 96%
rename from core/src/main/java/com/squareup/objectgraph/internal/BuiltInBinding.java
rename to core/src/main/java/dagger/internal/BuiltInBinding.java
index 2e39a13..8388190 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/BuiltInBinding.java
+++ b/core/src/main/java/dagger/internal/BuiltInBinding.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
 import java.util.Set;
 
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
similarity index 98%
rename from core/src/main/java/com/squareup/objectgraph/internal/Keys.java
rename to core/src/main/java/dagger/internal/Keys.java
index 1853033..606abce 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/Keys.java
+++ b/core/src/main/java/dagger/internal/Keys.java
@@ -14,10 +14,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
-import com.squareup.objectgraph.Lazy;
-import com.squareup.objectgraph.MembersInjector;
+import dagger.Lazy;
+import dagger.MembersInjector;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.ParameterizedType;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/LazyBinding.java b/core/src/main/java/dagger/internal/LazyBinding.java
similarity index 95%
rename from core/src/main/java/com/squareup/objectgraph/internal/LazyBinding.java
rename to core/src/main/java/dagger/internal/LazyBinding.java
index 369031b..44fabaf 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/LazyBinding.java
+++ b/core/src/main/java/dagger/internal/LazyBinding.java
@@ -14,9 +14,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
-import com.squareup.objectgraph.Lazy;
+import dagger.Lazy;
 
 /**
  * Injects a Lazy wrapper for a type T
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
similarity index 99%
rename from core/src/main/java/com/squareup/objectgraph/internal/Linker.java
rename to core/src/main/java/dagger/internal/Linker.java
index c29e6c4..c00570b 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
 import java.util.ArrayList;
 import java.util.Collection;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/LruCache.java b/core/src/main/java/dagger/internal/LruCache.java
similarity index 99%
rename from core/src/main/java/com/squareup/objectgraph/internal/LruCache.java
rename to core/src/main/java/dagger/internal/LruCache.java
index 5cdfb99..6ca5062 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/LruCache.java
+++ b/core/src/main/java/dagger/internal/LruCache.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
 import java.util.LinkedHashMap;
 import java.util.Map;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
similarity index 96%
rename from core/src/main/java/com/squareup/objectgraph/internal/ModuleAdapter.java
rename to core/src/main/java/dagger/internal/ModuleAdapter.java
index 11b1f37..445e429 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
-import com.squareup.objectgraph.Module;
-import com.squareup.objectgraph.ObjectGraph;
-import com.squareup.objectgraph.Provides;
+import dagger.Module;
+import dagger.ObjectGraph;
+import dagger.Provides;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 import java.util.Map;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/ProblemDetector.java b/core/src/main/java/dagger/internal/ProblemDetector.java
similarity index 98%
rename from core/src/main/java/com/squareup/objectgraph/internal/ProblemDetector.java
rename to core/src/main/java/dagger/internal/ProblemDetector.java
index 3479fdf..0742bae 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/ProblemDetector.java
+++ b/core/src/main/java/dagger/internal/ProblemDetector.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
 import java.util.Collection;
 import java.util.HashSet;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/ProviderMethodBinding.java b/core/src/main/java/dagger/internal/ProviderMethodBinding.java
similarity index 97%
rename from core/src/main/java/com/squareup/objectgraph/internal/ProviderMethodBinding.java
rename to core/src/main/java/dagger/internal/ProviderMethodBinding.java
index 47d54c7..6c95705 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/ProviderMethodBinding.java
+++ b/core/src/main/java/dagger/internal/ProviderMethodBinding.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationTargetException;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/RuntimeLinker.java b/core/src/main/java/dagger/internal/RuntimeLinker.java
similarity index 89%
rename from core/src/main/java/com/squareup/objectgraph/internal/RuntimeLinker.java
rename to core/src/main/java/dagger/internal/RuntimeLinker.java
index a90ca9a..df92ac8 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/RuntimeLinker.java
+++ b/core/src/main/java/dagger/internal/RuntimeLinker.java
@@ -13,20 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
-import com.squareup.objectgraph.ObjectGraph;
 import java.lang.reflect.Constructor;
 import java.util.List;
-import java.util.logging.Logger;
 
 /**
  * Linker suitable for application use at runtime. This looks for generated code
  * and falls back to reflection.
  */
 public final class RuntimeLinker extends Linker {
-  private static final Logger LOGGER = Logger.getLogger(ObjectGraph.class.getName());
-
   @Override protected Binding<?> createAtInjectBinding(String key, String className)
       throws ClassNotFoundException {
     try {
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/StaticInjection.java b/core/src/main/java/dagger/internal/StaticInjection.java
similarity index 97%
rename from core/src/main/java/com/squareup/objectgraph/internal/StaticInjection.java
rename to core/src/main/java/dagger/internal/StaticInjection.java
index ec7b10b..19bea23 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/StaticInjection.java
+++ b/core/src/main/java/dagger/internal/StaticInjection.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/UniqueMap.java b/core/src/main/java/dagger/internal/UniqueMap.java
similarity index 96%
rename from core/src/main/java/com/squareup/objectgraph/internal/UniqueMap.java
rename to core/src/main/java/dagger/internal/UniqueMap.java
index 21d190f..04a42a7 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/UniqueMap.java
+++ b/core/src/main/java/dagger/internal/UniqueMap.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
 import java.util.LinkedHashMap;
 import java.util.Map;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/ArrayUtil.java b/core/src/main/java/dagger/internal/codegen/ArrayUtil.java
similarity index 96%
rename from core/src/main/java/com/squareup/objectgraph/internal/codegen/ArrayUtil.java
rename to core/src/main/java/dagger/internal/codegen/ArrayUtil.java
index 4294d76..4ab60f3 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/ArrayUtil.java
+++ b/core/src/main/java/dagger/internal/codegen/ArrayUtil.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
 
 /**
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/AtInjectBinding.java b/core/src/main/java/dagger/internal/codegen/AtInjectBinding.java
similarity index 96%
rename from core/src/main/java/com/squareup/objectgraph/internal/codegen/AtInjectBinding.java
rename to core/src/main/java/dagger/internal/codegen/AtInjectBinding.java
index 4f4a442..a50170c 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/AtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/codegen/AtInjectBinding.java
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
-import com.squareup.objectgraph.internal.Binding;
-import com.squareup.objectgraph.internal.Linker;
+import dagger.internal.Binding;
+import dagger.internal.Linker;
 import java.util.ArrayList;
 import java.util.List;
 import javax.inject.Inject;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/BuildTimeLinker.java b/core/src/main/java/dagger/internal/codegen/BuildTimeLinker.java
similarity index 91%
rename from core/src/main/java/com/squareup/objectgraph/internal/codegen/BuildTimeLinker.java
rename to core/src/main/java/dagger/internal/codegen/BuildTimeLinker.java
index 317dbfe..94610ad 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/BuildTimeLinker.java
+++ b/core/src/main/java/dagger/internal/codegen/BuildTimeLinker.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
-import com.squareup.objectgraph.internal.Binding;
-import com.squareup.objectgraph.internal.Keys;
-import com.squareup.objectgraph.internal.Linker;
+import dagger.internal.Binding;
+import dagger.internal.Keys;
+import dagger.internal.Linker;
 import java.util.List;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.ElementKind;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/CodeGen.java b/core/src/main/java/dagger/internal/codegen/CodeGen.java
similarity index 98%
rename from core/src/main/java/com/squareup/objectgraph/internal/codegen/CodeGen.java
rename to core/src/main/java/dagger/internal/codegen/CodeGen.java
index 020dd12..83a42cf 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/CodeGen.java
+++ b/core/src/main/java/dagger/internal/codegen/CodeGen.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
-import com.squareup.objectgraph.internal.Keys;
+import dagger.internal.Keys;
 import java.lang.reflect.Method;
 import java.util.LinkedHashMap;
 import java.util.List;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java b/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
similarity index 94%
rename from core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java
rename to core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 1ecd70f..1fe6c45 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/FullGraphProcessor.java
+++ b/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
-import com.squareup.objectgraph.Module;
-import com.squareup.objectgraph.Provides;
-import com.squareup.objectgraph.internal.Binding;
-import com.squareup.objectgraph.internal.Linker;
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.Binding;
+import dagger.internal.Linker;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
@@ -39,7 +39,7 @@
 /**
  * Performs full graph analysis on a module.
  */
-@SupportedAnnotationTypes("com.squareup.objectgraph.Module")
+@SupportedAnnotationTypes("dagger.Module")
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class FullGraphProcessor extends AbstractProcessor {
   /**
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/GeneratorKeys.java b/core/src/main/java/dagger/internal/codegen/GeneratorKeys.java
similarity index 98%
rename from core/src/main/java/com/squareup/objectgraph/internal/codegen/GeneratorKeys.java
rename to core/src/main/java/dagger/internal/codegen/GeneratorKeys.java
index 115ebdf..a16961a 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/GeneratorKeys.java
+++ b/core/src/main/java/dagger/internal/codegen/GeneratorKeys.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
 import java.util.List;
 import java.util.Map;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/InjectProcessor.java b/core/src/main/java/dagger/internal/codegen/InjectProcessor.java
similarity index 98%
rename from core/src/main/java/com/squareup/objectgraph/internal/codegen/InjectProcessor.java
rename to core/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 5ddc116..1b6de4d 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/InjectProcessor.java
+++ b/core/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
-import com.squareup.objectgraph.internal.Binding;
-import com.squareup.objectgraph.internal.Linker;
+import dagger.internal.Binding;
+import dagger.internal.Linker;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.LinkedHashSet;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java b/core/src/main/java/dagger/internal/codegen/JavaWriter.java
similarity index 99%
rename from core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
rename to core/src/main/java/dagger/internal/codegen/JavaWriter.java
index ad3b4db..fa0dce3 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/JavaWriter.java
+++ b/core/src/main/java/dagger/internal/codegen/JavaWriter.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
 import java.io.IOException;
 import java.io.Writer;
/Fim/
diff --git a/core/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java b/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
similarity index 96%
rename from core/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java
rename to core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 79dc5c1..acc2fcb 100644
--- a/core/src/main/java/com/squareup/objectgraph/internal/codegen/ProvidesProcessor.java
+++ b/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -13,13 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
-import com.squareup.objectgraph.Module;
-import com.squareup.objectgraph.Provides;
-import com.squareup.objectgraph.internal.Binding;
-import com.squareup.objectgraph.internal.Linker;
-import com.squareup.objectgraph.internal.ModuleAdapter;
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.Binding;
+import dagger.internal.Linker;
+import dagger.internal.ModuleAdapter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -53,7 +53,7 @@
  * Generates an implementation of {@link ModuleAdapter} that includes a binding
  * for each {@code @Provides} method of a target class.
  */
-@SupportedAnnotationTypes("com.squareup.objectgraph.Provides")
+@SupportedAnnotationTypes("dagger.Provides")
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class ProvidesProcessor extends AbstractProcessor {
   private static final String BINDINGS_MAP = CodeGen.parameterizedType(
/Fim/
diff --git a/core/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/core/src/main/resources/META-INF/services/javax.annotation.processing.Processor
index 58136b0..db38935 100644
--- a/core/src/main/resources/META-INF/services/javax.annotation.processing.Processor
+++ b/core/src/main/resources/META-INF/services/javax.annotation.processing.Processor
@@ -1,3 +1,3 @@
-com.squareup.objectgraph.internal.codegen.InjectProcessor
-com.squareup.objectgraph.internal.codegen.ProvidesProcessor
-com.squareup.objectgraph.internal.codegen.FullGraphProcessor
\ No newline at end of file
+dagger.internal.codegen.InjectProcessor
+dagger.internal.codegen.ProvidesProcessor
+dagger.internal.codegen.FullGraphProcessor
\ No newline at end of file
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/InjectStaticsTest.java b/core/src/test/java/dagger/InjectStaticsTest.java
similarity index 98%
rename from core/src/test/java/com/squareup/objectgraph/InjectStaticsTest.java
rename to core/src/test/java/dagger/InjectStaticsTest.java
index 3bc7f71..e26122f 100644
--- a/core/src/test/java/com/squareup/objectgraph/InjectStaticsTest.java
+++ b/core/src/test/java/dagger/InjectStaticsTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 import javax.inject.Inject;
 import org.junit.Before;
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/InjectionOfLazyTest.java b/core/src/test/java/dagger/InjectionOfLazyTest.java
similarity index 98%
rename from core/src/test/java/com/squareup/objectgraph/InjectionOfLazyTest.java
rename to core/src/test/java/dagger/InjectionOfLazyTest.java
index be06173..d969b21 100644
--- a/core/src/test/java/com/squareup/objectgraph/InjectionOfLazyTest.java
+++ b/core/src/test/java/dagger/InjectionOfLazyTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 import java.util.concurrent.atomic.AtomicInteger;
 import javax.inject.Inject;
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
similarity index 99%
rename from core/src/test/java/com/squareup/objectgraph/InjectionTest.java
rename to core/src/test/java/dagger/InjectionTest.java
index 0452031..18c2eee 100644
--- a/core/src/test/java/com/squareup/objectgraph/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 import java.util.AbstractList;
 import java.util.Arrays;
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/LazyInjectionTest.java b/core/src/test/java/dagger/LazyInjectionTest.java
similarity index 98%
rename from core/src/test/java/com/squareup/objectgraph/LazyInjectionTest.java
rename to core/src/test/java/dagger/LazyInjectionTest.java
index 5be487b..5a5890a 100644
--- a/core/src/test/java/com/squareup/objectgraph/LazyInjectionTest.java
+++ b/core/src/test/java/dagger/LazyInjectionTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 import javax.inject.Inject;
 import org.junit.Test;
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/MembersInjectorTest.java b/core/src/test/java/dagger/MembersInjectorTest.java
similarity index 99%
rename from core/src/test/java/com/squareup/objectgraph/MembersInjectorTest.java
rename to core/src/test/java/dagger/MembersInjectorTest.java
index 4ecda2a..e8d25c2 100644
--- a/core/src/test/java/com/squareup/objectgraph/MembersInjectorTest.java
+++ b/core/src/test/java/dagger/MembersInjectorTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 import javax.inject.Inject;
 import javax.inject.Provider;
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/ModuleIncludesTest.java b/core/src/test/java/dagger/ModuleIncludesTest.java
similarity index 98%
rename from core/src/test/java/com/squareup/objectgraph/ModuleIncludesTest.java
rename to core/src/test/java/dagger/ModuleIncludesTest.java
index 0a06614..da6ce41 100644
--- a/core/src/test/java/com/squareup/objectgraph/ModuleIncludesTest.java
+++ b/core/src/test/java/dagger/ModuleIncludesTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 import javax.inject.Inject;
 import org.junit.Test;
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/ProblemDetectorTest.java b/core/src/test/java/dagger/ProblemDetectorTest.java
similarity index 96%
rename from core/src/test/java/com/squareup/objectgraph/ProblemDetectorTest.java
rename to core/src/test/java/dagger/ProblemDetectorTest.java
index a8d0ae5..3c68c6a 100644
--- a/core/src/test/java/com/squareup/objectgraph/ProblemDetectorTest.java
+++ b/core/src/test/java/dagger/ProblemDetectorTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph;
+package dagger;
 
 import javax.inject.Inject;
 import org.junit.Test;
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/internal/KeysTest.java b/core/src/test/java/dagger/internal/KeysTest.java
similarity index 97%
rename from core/src/test/java/com/squareup/objectgraph/internal/KeysTest.java
rename to core/src/test/java/dagger/internal/KeysTest.java
index b2425be..dd4a34d 100644
--- a/core/src/test/java/com/squareup/objectgraph/internal/KeysTest.java
+++ b/core/src/test/java/dagger/internal/KeysTest.java
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal;
+package dagger.internal;
 
-import com.squareup.objectgraph.Lazy;
-import com.squareup.objectgraph.MembersInjector;
+import dagger.Lazy;
+import dagger.MembersInjector;
 import java.lang.reflect.Field;
 import java.util.List;
 import java.util.Map;
/Fim/
diff --git a/core/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java b/core/src/test/java/dagger/internal/codegen/JavaWriterTest.java
similarity index 99%
rename from core/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java
rename to core/src/test/java/dagger/internal/codegen/JavaWriterTest.java
index ac414b4..5a10cfd 100644
--- a/core/src/test/java/com/squareup/objectgraph/internal/codegen/JavaWriterTest.java
+++ b/core/src/test/java/dagger/internal/codegen/JavaWriterTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.objectgraph.internal.codegen;
+package dagger.internal.codegen;
 
 import java.io.IOException;
 import java.io.StringWriter;
/Fim/
diff --git a/example/pom.xml b/example/pom.xml
index e55ddc7..40d560f 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -20,19 +20,19 @@
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
     <modelVersion>4.0.0</modelVersion>
     <parent>
-        <groupId>com.squareup</groupId>
-        <artifactId>objectgraph-parent</artifactId>
+        <groupId>org.u2020</groupId>
+        <artifactId>dagger-parent</artifactId>
         <version>1.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
-    <artifactId>objectgraph-example</artifactId>
+    <artifactId>dagger-example</artifactId>
     <packaging>jar</packaging>
-    <name>ObjectGraph Example</name>
+    <name>Dagger Example</name>
 
     <dependencies>
         <dependency>
-            <groupId>com.squareup</groupId>
-            <artifactId>objectgraph</artifactId>
+            <groupId>org.u2020</groupId>
+            <artifactId>dagger</artifactId>
             <version>${project.version}</version>
         </dependency>
     </dependencies>
/Fim/
diff --git a/example/src/main/java/coffee/CoffeeApp.java b/example/src/main/java/coffee/CoffeeApp.java
index 831c9ff..aebbb3e 100644
--- a/example/src/main/java/coffee/CoffeeApp.java
+++ b/example/src/main/java/coffee/CoffeeApp.java
@@ -1,6 +1,6 @@
 package coffee;
 
-import com.squareup.objectgraph.ObjectGraph;
+import dagger.ObjectGraph;
 import javax.inject.Inject;
 
 class CoffeeApp implements Runnable {
/Fim/
diff --git a/example/src/main/java/coffee/CoffeeMaker.java b/example/src/main/java/coffee/CoffeeMaker.java
index 233917c..a4e8180 100644
--- a/example/src/main/java/coffee/CoffeeMaker.java
+++ b/example/src/main/java/coffee/CoffeeMaker.java
@@ -1,9 +1,8 @@
 package coffee;
 
+import dagger.Lazy;
 import javax.inject.Inject;
 
-import com.squareup.objectgraph.Lazy;
-
 class CoffeeMaker {
   @Inject Lazy<Heater> heater; // Don't want to create a possibly costly heater until we need it.
   @Inject Pump pump;
/Fim/
diff --git a/example/src/main/java/coffee/DripCoffeeModule.java b/example/src/main/java/coffee/DripCoffeeModule.java
index 40fbf94..1b1d3fe 100644
--- a/example/src/main/java/coffee/DripCoffeeModule.java
+++ b/example/src/main/java/coffee/DripCoffeeModule.java
@@ -1,7 +1,7 @@
 package coffee;
 
-import com.squareup.objectgraph.Module;
-import com.squareup.objectgraph.Provides;
+import dagger.Module;
+import dagger.Provides;
 import javax.inject.Singleton;
 
 @Module(
/Fim/
diff --git a/example/src/main/java/coffee/PumpModule.java b/example/src/main/java/coffee/PumpModule.java
index e7c72d7..3324b84 100644
--- a/example/src/main/java/coffee/PumpModule.java
+++ b/example/src/main/java/coffee/PumpModule.java
@@ -1,7 +1,7 @@
 package coffee;
 
-import com.squareup.objectgraph.Module;
-import com.squareup.objectgraph.Provides;
+import dagger.Module;
+import dagger.Provides;
 
 @Module(complete = false)
 class PumpModule {
/Fim/
diff --git a/pom.xml b/pom.xml
index 6f7d9c2..842cd78 100644
--- a/pom.xml
+++ b/pom.xml
@@ -20,13 +20,13 @@
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
     <modelVersion>4.0.0</modelVersion>
 
-    <groupId>com.squareup</groupId>
-    <artifactId>objectgraph-parent</artifactId>
+    <groupId>org.u2020</groupId>
+    <artifactId>dagger-parent</artifactId>
     <packaging>pom</packaging>
     <version>1.0-SNAPSHOT</version>
-    <name>ObjectGraph (Parent)</name>
+    <name>Dagger (Parent)</name>
     <description>A JSR-330 dependency injector for Android and Java.</description>
-    <url>https://github.com/square/objectgraph</url>
+    <url>https://github.com/u2020/dagger</url>
 
     <modules>
         <module>core</module>
@@ -47,14 +47,14 @@
     </properties>
 
     <scm>
-        <url>http://github.com/square/objectgraph/</url>
-        <connection>scm:git:git://github.com/square/objectgraph.git</connection>
-        <developerConnection>scm:git:ssh://git@github.com/square/objectgraph.git</developerConnection>
+        <url>http://github.com/u2020/dagger/</url>
+        <connection>scm:git:git://github.com/u2020/dagger.git</connection>
+        <developerConnection>scm:git:ssh://git@github.com/u2020/dagger.git</developerConnection>
     </scm>
 
     <issueManagement>
         <system>GitHub Issues</system>
-        <url>http://github.com/square/objectgraph/issues</url>
+        <url>http://github.com/u2020/dagger/issues</url>
     </issueManagement>
 
     <licenses>
@@ -90,7 +90,7 @@
     </dependencies>
 
     <build>
-        <finalName>square-${project.artifactId}-${project.version}</finalName>
+        <finalName>u2020-${project.artifactId}-${project.version}</finalName>
 
         <plugins>
             <plugin>
/Fim/
diff --git a/androidmanifest/pom.xml b/androidmanifest/pom.xml
index 2f8f492..b8797c0 100644
--- a/androidmanifest/pom.xml
+++ b/androidmanifest/pom.xml
@@ -20,7 +20,7 @@
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
     <modelVersion>4.0.0</modelVersion>
     <parent>
-        <groupId>org.u2020</groupId>
+        <groupId>com.squareup</groupId>
         <artifactId>dagger-parent</artifactId>
         <version>1.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
@@ -31,7 +31,7 @@
 
     <dependencies>
         <dependency>
-            <groupId>org.u2020</groupId>
+            <groupId>com.squareup</groupId>
             <artifactId>dagger</artifactId>
             <version>${project.version}</version>
         </dependency>
/Fim/
diff --git a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
index 6a0e079..44fd347 100644
--- a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
+++ b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
@@ -47,7 +47,7 @@
  */
 public final class ModuleGenerator {
   private static final String ANDROID_NS = "http://schemas.android.com/apk/res/android";
-  private static final String DAGGER_NS = "https://github.com/u2020/dagger";
+  private static final String DAGGER_NS = "https://github.com/square/dagger";
 
   /**
    * Returns the path of the generated ManifestModule.java for {@code manifest}.
/Fim/
diff --git a/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java b/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
index a6fc08f..24d977e 100644
--- a/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
+++ b/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
@@ -102,7 +102,7 @@
     String manifestXml = ""
         + "<manifest"
         + "    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n"
-        + "    xmlns:dagger=\"https://github.com/u2020/dagger\"\n"
+        + "    xmlns:dagger=\"https://github.com/square/dagger\"\n"
         + "    package=\"com.squareup.badhorse\">\n"
         + "  <application>\n"
         + "    <activity android:name=\"false.Activity\" dagger:entryPoint=\"false\"/>\n"
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 5f32219..ae19bd1 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
     <modelVersion>4.0.0</modelVersion>
     <parent>
-        <groupId>org.u2020</groupId>
+        <groupId>com.squareup</groupId>
         <artifactId>dagger-parent</artifactId>
         <version>1.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
/Fim/
diff --git a/example/pom.xml b/example/pom.xml
index 40d560f..aba70d1 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -20,7 +20,7 @@
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
     <modelVersion>4.0.0</modelVersion>
     <parent>
-        <groupId>org.u2020</groupId>
+        <groupId>com.squareup</groupId>
         <artifactId>dagger-parent</artifactId>
         <version>1.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
@@ -31,7 +31,7 @@
 
     <dependencies>
         <dependency>
-            <groupId>org.u2020</groupId>
+            <groupId>com.squareup</groupId>
             <artifactId>dagger</artifactId>
             <version>${project.version}</version>
         </dependency>
/Fim/
diff --git a/pom.xml b/pom.xml
index 842cd78..5489d09 100644
--- a/pom.xml
+++ b/pom.xml
@@ -20,13 +20,13 @@
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
     <modelVersion>4.0.0</modelVersion>
 
-    <groupId>org.u2020</groupId>
+    <groupId>com.squareup</groupId>
     <artifactId>dagger-parent</artifactId>
     <packaging>pom</packaging>
     <version>1.0-SNAPSHOT</version>
     <name>Dagger (Parent)</name>
     <description>A JSR-330 dependency injector for Android and Java.</description>
-    <url>https://github.com/u2020/dagger</url>
+    <url>https://github.com/square/dagger</url>
 
     <modules>
         <module>core</module>
@@ -47,14 +47,14 @@
     </properties>
 
     <scm>
-        <url>http://github.com/u2020/dagger/</url>
-        <connection>scm:git:git://github.com/u2020/dagger.git</connection>
-        <developerConnection>scm:git:ssh://git@github.com/u2020/dagger.git</developerConnection>
+        <url>http://github.com/square/dagger/</url>
+        <connection>scm:git:git://github.com/square/dagger.git</connection>
+        <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
     </scm>
 
     <issueManagement>
         <system>GitHub Issues</system>
-        <url>http://github.com/u2020/dagger/issues</url>
+        <url>http://github.com/square/dagger/issues</url>
     </issueManagement>
 
     <licenses>
@@ -90,7 +90,7 @@
     </dependencies>
 
     <build>
-        <finalName>u2020-${project.artifactId}-${project.version}</finalName>
+        <finalName>square-${project.artifactId}-${project.version}</finalName>
 
         <plugins>
             <plugin>
/Fim/
diff --git a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
index 44fd347..2d7ffa1 100644
--- a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
+++ b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
@@ -47,7 +47,7 @@
  */
 public final class ModuleGenerator {
   private static final String ANDROID_NS = "http://schemas.android.com/apk/res/android";
-  private static final String DAGGER_NS = "https://github.com/square/dagger";
+  private static final String DAGGER_NS = "http://github.com/square/dagger";
 
   /**
    * Returns the path of the generated ManifestModule.java for {@code manifest}.
/Fim/
diff --git a/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java b/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
index 24d977e..ec1ff59 100644
--- a/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
+++ b/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
@@ -102,7 +102,7 @@
     String manifestXml = ""
         + "<manifest"
         + "    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n"
-        + "    xmlns:dagger=\"https://github.com/square/dagger\"\n"
+        + "    xmlns:dagger=\"http://github.com/square/dagger\"\n"
         + "    package=\"com.squareup.badhorse\">\n"
         + "  <application>\n"
         + "    <activity android:name=\"false.Activity\" dagger:entryPoint=\"false\"/>\n"
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/GeneratorKeys.java b/core/src/main/java/dagger/internal/codegen/GeneratorKeys.java
index a16961a..17e2e47 100644
--- a/core/src/main/java/dagger/internal/codegen/GeneratorKeys.java
+++ b/core/src/main/java/dagger/internal/codegen/GeneratorKeys.java
@@ -21,7 +21,6 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
 
@@ -74,7 +73,7 @@
   private static void qualifierToString(AnnotationMirror qualifier, StringBuilder result) {
     // TODO: guarantee that element values are sorted by name (if there are multiple)
     result.append('@');
-    result.append(((TypeElement) qualifier.getAnnotationType().asElement()).getQualifiedName());
+    CodeGen.typeToString(qualifier.getAnnotationType(), result, '$');
     result.append('(');
     for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry
         : qualifier.getElementValues().entrySet()) {
/Fim/
diff --git a/pom.xml b/pom.xml
index 5489d09..81b6dff 100644
--- a/pom.xml
+++ b/pom.xml
@@ -20,6 +20,12 @@
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
     <modelVersion>4.0.0</modelVersion>
 
+    <parent>
+        <groupId>org.sonatype.oss</groupId>
+        <artifactId>oss-parent</artifactId>
+        <version>7</version>
+    </parent>
+
     <groupId>com.squareup</groupId>
     <artifactId>dagger-parent</artifactId>
     <packaging>pom</packaging>
/Fim/
diff --git a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
index 140cd51..4646c9e 100644
--- a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
+++ b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
@@ -197,14 +197,11 @@
   }
 
   /**
-   * Generate a module from the specified <code>AndroidManifest.xml</code>.
+   * Generate a module from the specified {@code AndroidManifest.xml}.
    *
-   * @param manifestXml Path to the <code>AndroidManifest.xml</code>.
+   * @param manifestXml Path to the {@code AndroidManifest.xml}.
    * @param moduleName Name of the target module.
    * @param baseDir Destination directory for the generated module.
-   * @throws IOException
-   * @throws SAXException
-   * @throws ParserConfigurationException
    */
   public static void generate(File manifestXml, String moduleName, File baseDir)
       throws IOException, SAXException, ParserConfigurationException {
/Fim/
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
index 9f6e174..05292d0 100644
--- a/core/src/main/java/dagger/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -38,12 +38,6 @@
   boolean overrides() default false;
 
   /**
-   * @deprecated Use module includes vs. children
-   */
-  @Deprecated
-  Class<?>[] children() default { };
-
-  /**
    * Additional {@code @Module}-annotated classes from which this module is
    * composed. The de-duplicated contributions of the modules in
    * {@code includes}, and of their inclusions recursively, are all contributed
/Fim/
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index c7464c9..b5e7d5c 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -100,26 +100,11 @@
           annotation.entryPoints()),
           annotation.staticInjections(),
           annotation.overrides(),
-          concatenate(annotation.includes(), annotation.children()),
+          annotation.includes(),
           annotation.complete());
       this.moduleClass = moduleClass;
     }
 
-    /**
-     * Returns the concatenation of two {@code Class<T>[]}s.
-     *
-     * TODO(cgruber): Remove this method when module children are removed.
-     *
-     * @deprecated this method exists only to support a legacy deprecation case
-     */
-    @Deprecated
-    private static Class<?>[] concatenate(Class<?>[] first, Class<?>[] second) {
-      final Class<?>[] result = new Class<?>[second.length + first.length];
-      System.arraycopy(second, 0, result, 0, second.length);
-      System.arraycopy(first, 0, result, second.length, first.length);
-      return result;
-    }
-
     private static String[] toMemberKeys(Class<?>[] entryPoints) {
       String[] result = new String[entryPoints.length];
       for (int i = 0; i < entryPoints.length; i++) {
/Fim/
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 7356c66..3e2ff28 100644
--- a/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -121,10 +121,7 @@
     // Recurse for each included module.
     Types typeUtils = processingEnv.getTypeUtils();
     Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
-    @SuppressWarnings("deprecation") // Use known deprecated method. TODO(cgruber): remove.
-    Object[] includes = ArrayUtil.concatenate(
-        (Object[]) annotation.get("includes"),
-        (Object[]) annotation.get("children"));
+    Object[] includes = (Object[]) annotation.get("includes");
     for (Object include : includes) {
       if (!(include instanceof TypeMirror)) {
         processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 78d88f6..894aa30 100644
--- a/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -138,10 +138,7 @@
 
     Object[] staticInjections = (Object[]) module.get("staticInjections");
     Object[] entryPoints = (Object[]) module.get("entryPoints");
-    @SuppressWarnings("deprecation") // use deprecated until children removed.
-    Object[] includes = ArrayUtil.concatenate(
-        (Object[]) module.get("includes"),
-        (Object[]) module.get("children"));
+    Object[] includes = (Object[]) module.get("includes");
 
     boolean overrides = (Boolean) module.get("overrides");
     boolean complete = (Boolean) module.get("complete");
@@ -185,7 +182,7 @@
     for (Object include : includes) {
       if (!(include instanceof TypeMirror)) {
         processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
-            "Unexpected value: " + include + " in includes or children attribute of " + type);
+            "Unexpected value: " + include + " in includes of " + type);
         continue;
       }
       TypeMirror typeMirror = (TypeMirror) include;
/Fim/
diff --git a/core/src/test/java/dagger/ModuleIncludesTest.java b/core/src/test/java/dagger/ModuleIncludesTest.java
index da6ce41..fecc6c5 100644
--- a/core/src/test/java/dagger/ModuleIncludesTest.java
+++ b/core/src/test/java/dagger/ModuleIncludesTest.java
@@ -157,47 +157,10 @@
     assertThat(entryPoint.s).isEqualTo("a");
   }
 
-  // Legacy Tests //
-
-  @Test public void childrenButNoIncludes() {
-    class TestEntryPoint {
-      @Inject String s;
-    }
-    @Module(entryPoints = TestEntryPoint.class, children = ModuleWithBinding.class)
-    class TestModule {
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
-    assertThat(ep.s).isEqualTo("injected");
-  }
-
-  @Module(complete = false)
-  static class ModuleWithInteger {
-    @Provides Integer provideString() { return 1; }
-  }
-
-  @Test public void bothIncludesAndChildren() {
-    class TestEntryPoint {
-      @Inject String s;
-      @Inject Integer i;
-    }
-    @Module(
-        entryPoints = TestEntryPoint.class,
-        includes = ModuleWithInteger.class,
-        children = ModuleWithBinding.class)
-    class TestModule {
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
-    assertThat(ep.s).isEqualTo("injected");
-    assertThat(ep.i).isEqualTo(1);
-  }
-
   private <T> T injectWithModule(T ep, Object ... modules) {
     // TODO(cgruber): Make og.inject(foo) return foo properly.
     ObjectGraph og = ObjectGraph.get(modules);
     og.inject(ep);
     return ep;
   }
-
 }
/Fim/
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index 370a51c..b05496e 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -55,17 +55,17 @@
     }
 
     @Module
-    class TestChildModule {
+    class TestIncludesModule {
       @Provides @Element String provideSecondString() { return "string2"; }
     }
 
-    @Module(entryPoints = TestEntryPoint.class, children = TestChildModule.class)
+    @Module(entryPoints = TestEntryPoint.class, includes = TestIncludesModule.class)
     class TestModule {
       @Provides @Element String provideFirstString() { return "string1"; }
     }
 
     TestEntryPoint ep = injectWithModule(new TestEntryPoint(),
-        new TestModule(), new TestChildModule());
+        new TestModule(), new TestIncludesModule());
     assertEquals(set("string1", "string2"), ep.strings);
   }
 
/Fim/
diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 0000000..33cbd1c
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,4 @@
+language: java
+
+notifications:
+  email: false
/Fim/
diff --git a/androidmanifest/pom.xml b/androidmanifest/pom.xml
index dcdbc80..8626432 100644
--- a/androidmanifest/pom.xml
+++ b/androidmanifest/pom.xml
@@ -26,7 +26,7 @@
         <relativePath>../pom.xml</relativePath>
     </parent>
     <artifactId>dagger-androidmanifest-plugin</artifactId>
-    <packaging>jar</packaging>
+    <packaging>maven-plugin</packaging>
     <name>Dagger AndroidManifest.xml Module Generator</name>
 
     <dependencies>
/Fim/
diff --git a/androidmanifest/README.md b/androidmanifest/README.md
index c6ff27e..3272569 100644
--- a/androidmanifest/README.md
+++ b/androidmanifest/README.md
@@ -18,7 +18,7 @@
     <execution>
       <phase>generate-sources</phase>
       <goals>
-        <goal>generate</goals>
+        <goal>generate</goal>
       </goals>
     </execution>
   </executions>
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 0dfa389..c4bf664 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -220,7 +220,7 @@
           + ". You must explicitly add an entry point to one of your modules.");
     }
     Binding<?> binding = linker.requestBinding(key, moduleClass);
-    if (binding == null || !binding.linked) {
+    if (binding == null || !binding.isLinked()) {
       linker.linkRequested();
       binding = linker.requestBinding(key, moduleClass);
     }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Binding.java b/core/src/main/java/dagger/internal/Binding.java
index ac299ca..7e4aa46 100644
--- a/core/src/main/java/dagger/internal/Binding.java
+++ b/core/src/main/java/dagger/internal/Binding.java
@@ -25,17 +25,22 @@
 public class Binding<T> implements Provider<T>, MembersInjector<T> {
   public static final Binding<Object> UNRESOLVED = new Binding<Object>(null, null, false, null);
 
+  /** Set if the provided instance is always the same object. */
+  private static final int SINGLETON = 1 << 0;
+
+  /** Set if this binding's {@link #attach} completed without any missing dependencies. */
+  private static final int LINKED = 1 << 1;
+
   /** The key used to provide instances of 'T', or null if this binding cannot provide instances. */
   public final String provideKey;
 
   /** The key used to inject members of 'T', or null if this binding cannot inject members. */
   public final String membersKey;
 
-  /** True if the provided instance is always the same object. */
-  public final boolean singleton;
+  /** Bitfield of states like SINGLETON and LINKED. */
+  private int bits;
 
   public final Object requiredBy;
-  public boolean linked;
 
   protected Binding(String provideKey, String membersKey, boolean singleton, Object requiredBy) {
     if (singleton && provideKey == null) {
@@ -43,7 +48,7 @@
     }
     this.provideKey = provideKey;
     this.membersKey = membersKey;
-    this.singleton = singleton;
+    this.bits = (singleton ? SINGLETON : 0);
     this.requiredBy = requiredBy;
   }
 
@@ -75,4 +80,16 @@
   public void getDependencies(Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
     throw new UnsupportedOperationException(getClass().getName());
   }
+
+  void setLinked() {
+    bits |= LINKED;
+  }
+
+  public boolean isLinked() {
+    return (bits & LINKED) != 0;
+  }
+
+  boolean isSingleton() {
+    return (bits & SINGLETON) != 0;
+  }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 0c9a17c..c580225 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -62,7 +62,7 @@
    */
   public final Collection<Binding<?>> linkAll() {
     for (Binding<?> binding : bindings.values()) {
-      if (!binding.linked) {
+      if (!binding.isLinked()) {
         toLink.add(binding);
       }
     }
@@ -102,7 +102,7 @@
         attachSuccess = true;
         binding.attach(this);
         if (attachSuccess) {
-          binding.linked = true;
+          binding.setLinked();
         } else {
           toLink.add(binding);
         }
@@ -169,7 +169,7 @@
       return null;
     }
 
-    if (!binding.linked) {
+    if (!binding.isLinked()) {
       toLink.add(binding); // This binding was never linked; link it now!
     }
 
@@ -194,7 +194,7 @@
    * Returns a scoped binding for {@code binding}.
    */
   static <T> Binding<T> scope(final Binding<T> binding) {
-    if (!binding.singleton) {
+    if (!binding.isSingleton()) {
       return binding;
     }
     if (binding instanceof SingletonBinding) throw new AssertionError();
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/CodeGen.java b/core/src/main/java/dagger/internal/codegen/CodeGen.java
index 83a42cf..3d50c9d 100644
--- a/core/src/main/java/dagger/internal/codegen/CodeGen.java
+++ b/core/src/main/java/dagger/internal/codegen/CodeGen.java
@@ -130,11 +130,11 @@
         }
         return null;
       }
-      @Override public Void visitPrimitive(PrimitiveType primitiveType, Void aVoid) {
+      @Override public Void visitPrimitive(PrimitiveType primitiveType, Void v) {
         result.append(box((PrimitiveType) type).getName());
         return null;
       }
-      @Override public Void visitArray(ArrayType arrayType, Void aVoid) {
+      @Override public Void visitArray(ArrayType arrayType, Void v) {
         typeToString(arrayType.getComponentType(), result, innerClassSeparator);
         result.append("[]");
         return null;
@@ -142,8 +142,9 @@
       @Override public Void visitTypeVariable(TypeVariable typeVariable, Void v) {
         return null;
       }
-      @Override protected Void defaultAction(TypeMirror typeMirror, Void aVoid) {
-        throw new UnsupportedOperationException("Unexpected type " + typeMirror);
+      @Override protected Void defaultAction(TypeMirror typeMirror, Void v) {
+        throw new UnsupportedOperationException(
+            "Unexpected TypeKind " + typeMirror.getKind() + " for "  + typeMirror);
       }
     }, null);
   }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Binding.java b/core/src/main/java/dagger/internal/Binding.java
index 0723227..e69bb66 100644
--- a/core/src/main/java/dagger/internal/Binding.java
+++ b/core/src/main/java/dagger/internal/Binding.java
@@ -114,4 +114,8 @@
   public void setCycleFree(boolean cycleFree) {
     this.bits = cycleFree ? (bits | CYCLE_FREE) : (bits & ~CYCLE_FREE);
   }
+
+  @Override public String toString() {
+    return "Binding[provideKey=\"" + provideKey + "\", memberskey=\"" + membersKey + "\"]";
+  }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/GraphVisualizer.java b/core/src/main/java/dagger/internal/GraphVisualizer.java
index eaa51b9..636b751 100644
--- a/core/src/main/java/dagger/internal/GraphVisualizer.java
+++ b/core/src/main/java/dagger/internal/GraphVisualizer.java
@@ -49,11 +49,17 @@
     for (Map.Entry<Binding<?>, String> entry : namesIndex.entrySet()) {
       Binding<?> sourceBinding = entry.getKey();
       String sourceName = entry.getValue();
-      Set<Binding<?>> dependencies = new HashSet<Binding<?>>();
-      sourceBinding.getDependencies(dependencies, dependencies);
-      for (Binding<?> targetBinding : dependencies) {
-        String targetName = namesIndex.get(targetBinding);
-        writer.edge(sourceName, targetName);
+      try {
+        Set<Binding<?>> dependencies = new HashSet<Binding<?>>();
+        if (sourceBinding != Binding.UNRESOLVED) {
+          sourceBinding.getDependencies(dependencies, dependencies);
+        }
+        for (Binding<?> targetBinding : dependencies) {
+          String targetName = namesIndex.get(targetBinding);
+          writer.edge(sourceName, targetName);
+        }
+      } catch (Exception e) {
+        throw new IllegalStateException("Could not write binding: \"" + sourceBinding + "\"", e);
       }
     }
     writer.endGraph();
/Fim/
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 13ef078..087af22 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -26,8 +26,9 @@
 note that a Square, Inc. copyright line must appear in every copyright notice.
 All files are released with the Apache 2.0 license.
 
-Checkstyle failures during compilation indicate errors in your style and can be
-viewed in the `checkstyle-result.xml` file.
+Checkstyle failures during compilation indicate errors in your style and will
+be displayed in the console output of the build (including in Travis-CI output),
+or can be viewed in the `checkstyle-result.xml` file.
 
 Before your code can be accepted into the project you must sign the
 [Individual Contributor License Agreement (CLA)][1].
/Fim/
diff --git a/pom.xml b/pom.xml
index d0c61bb..3a2920d 100644
--- a/pom.xml
+++ b/pom.xml
@@ -126,6 +126,7 @@
         <version>2.9.1</version>
         <configuration>
           <failsOnError>true</failsOnError>
+          <consoleOutput>true</consoleOutput>
           <configLocation>checkstyle.xml</configLocation>
         </configuration>
         <executions>
/Fim/
diff --git a/deploy_website.sh b/deploy_website.sh
index 7dd9d89..0714118 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -12,7 +12,7 @@
 rm -rf $DIR
 
 # Clone the current repo into temp folder
-git clone git@git.squareup.com:square/dagger.git $DIR
+git clone git@github.com:square/dagger.git $DIR
 
 # Move working directory into temp folder
 cd $DIR
@@ -21,13 +21,14 @@
 git checkout -t origin/gh-pages
 
 # Delete everything
-git rm -rf * .*
+rm -rf *
 
 # Copy website files from real repo
 cp -R ../website/* .
 
 # Stage all files in git and create a commit
 git add .
+git add -u
 git commit -m "Website at ${date}"
 
 # Push the new files up to GitHub
/Fim/
diff --git a/.travis.yml b/.travis.yml
index c15e4e6..d6c3e3d 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,5 +1,10 @@
 language: java
 install: mvn install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
 script: mvn verify
+
 notifications:
   email: false
+
+branches:
+  except:
+    - gh-pages
/Fim/
diff --git a/website/_config.yml b/website/_config.yml
index 3120c33..16ca090 100644
--- a/website/_config.yml
+++ b/website/_config.yml
@@ -1,6 +1,2 @@
 auto: true
 url: "http://square.github.com/dagger/"
-
-markdown: redcarpet2
-redcarpet:
-  extensions: ["no_intra_emphasis", "fenced_code_blocks", "autolink", "tables", "with_toc_data"]
/Fim/
/Fim/
diff --git a/website/index.html b/website/index.html
new file mode 100644
index 0000000..5f9b93a
--- /dev/null
+++ b/website/index.html
@@ -0,0 +1,419 @@
+---
+layout: default
+---
+
+<h3>Introduction</h3>
+
+<p>The best classes in any application are the ones that do stuff: the <code>BarcodeDecoder</code>, the <code>KoopaPhysicsEngine</code>, and the <code>AudioStreamer</code>. These classes have dependencies; perhaps a <code>BarcodeCameraFinder</code>, <code>DefaultPhysicsEngine</code>, and an <code>HttpStreamer</code>.</p>
+
+<p>To contrast, the worst classes in any application are the ones that take up space without doing much at all: the <code>BarcodeDecoderFactory</code>, the <code>CameraServiceLoader</code>, and the <code>MutableContextWrapper</code>. These classes are the clumsy duct tape that wires the interesting stuff together.</p>
+
+<p>Dagger is a replacement for these <code>FactoryFactory</code> classes. It allows you to focus on the interesting classes. Declare dependencies, specify how to satisfy them, and ship your app.</p>
+
+<p>By building on standard <a href="http://atinject.googlecode.com/svn/trunk/javadoc/javax/inject/package-summary.html">javax.inject</a> annotations (JSR-330), each class is <strong>easy to test</strong>. You don't need a bunch of boilerplate just to swap the <code>RpcCreditCardService</code> out for a <code>FakeCreditCardService</code>.</p>
+
+<p>Dependency injection isn't just for testing. It also makes it easy to create <strong>reusable, interchangeable modules</strong>. You can share the same <code>AuthenticationModule</code>  across all of your apps. And you can run <code>DevLoggingModule</code> during development and <code>ProdLoggingModule</code> in production to get the right behavior in each situation.</p>
+
+<h4>Declaring Dependencies</h4>
+
+<p>Dagger constructs instances of your application classes and satisfies their dependencies. It uses the <code>javax.inject.Inject</code> annotation to identify which constructors and fields it is interested in.</p>
+
+<p>Use <code>@Inject</code> to annotate the constructor that Dagger should use to create instances of a class. When a new instance is requested, Dagger will obtain the required parameters values and invoke this constructor.</p>
+
+<pre class="prettyprint">
+class Thermosiphon implements Pump {
+  private final Heater heater;
+
+  @Inject
+  Thermosiphon(Heater heater) {
+    this.heater = heater;
+  }
+
+  ...
+}
+</pre>
+
+<p>Dagger can inject fields directly. In this example it obtains a <code>Heater</code> instance for the <code>heater</code> field and a <code>Pump</code> instance for the <code>pump</code> field.</p>
+
+<pre class="prettyprint">
+class CoffeeMaker {
+  @Inject Heater heater;
+  @Inject Pump pump;
+
+  ...
+}
+</pre>
+
+<p>If your class has <code>@Inject</code>-annotated fields but no <code>@Inject</code>-annotated constructor, Dagger will use a no-argument constructor if it exists. Classes that lack <code>@Inject</code> annotations cannot be constructed by Dagger.</p>
+
+<p>Dagger does not support method injection.</p>
+
+<h4>Satisfying Dependencies</h4>
+
+<p>By default, Dagger satisfies each dependency by constructing an instance of the requested type as described above. When you request a <code>CoffeeMaker</code>, it'll obtain one by calling <code>new CoffeeMaker()</code> and setting its injectable fields.</p>
+
+<p>But <code>@Inject</code> doesn't work everywhere:</p>
+
+<ul>
+  <li>Interfaces can't be constructed.</li>
+  <li>Third-party classes can't be annotated.</li>
+  <li>Configurable objects must be configured!</li>
+</ul>
+
+<p>For these cases where <code>@Inject</code> is insufficient or awkward, use an <code>@Provides</code>-annotated method to satisfy a dependency. The method's return type defines which dependency it satisfies.</p>
+
+<p>For example, <code>provideHeater()</code> is invoked whenever a <code>Heater</code> is required:</p>
+
+<pre class="prettyprint">
+@Provides Heater provideHeater() {
+  return new ElectricHeater();
+}
+</pre>
+
+<p>It's possible for <code>@Provides</code> methods to have dependencies of their own. This one returns a <code>Thermosiphon</code> whenever a <code>Pump</code> is required:</p>
+
+<pre class="prettyprint">
+@Provides Pump providePump(Thermosiphon pump) {
+  return pump;
+}
+</pre>
+
+<p>All <code>@Provides</code> methods must belong to a module. These are just classes that have an <code>@Module</code> annotation.</p>
+
+<pre class="prettyprint">
+@Module
+class DripCoffeeModule {
+  @Provides Heater provideHeater() {
+    return new ElectricHeater();
+  }
+
+  @Provides Pump providePump(Thermosiphon pump) {
+    return pump;
+  }
+}
+</pre>
+
+<p>By convention, <code>@Provides</code> methods are named with a <code>provide</code> prefix and module classes are named with a <code>Module</code> suffix.</p>
+
+<h4>Building the Graph</h4>
+
+<p>The <code>@Inject</code> and <code>@Provides</code>-annotated classes form a graph of objects, linked by their dependencies. Obtain this graph by calling <code>ObjectGraph.create()</code>, which accepts one or more modules:</p>
+
+<pre class="prettyprint">
+ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());
+</pre>
+
+<p>In order to put the graph to use we need to create an <strong>entry point</strong>. This is usually the main class that starts the application. In this example, the <code>CoffeeApp</code> class serves as the entry point. We ask the graph to provide an injected instance of this type:</p>
+
+<pre class="prettyprint">
+class CoffeeApp implements Runnable {
+  @Inject CoffeeMaker coffeeMaker;
+
+  @Override public void run() {
+    coffeeMaker.brew();
+  }
+
+  public static void main(String[] args) {
+    ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());
+    CoffeeApp coffeeApp = objectGraph.get(CoffeeApp.class);
+    ...
+  }
+}
+</pre>
+
+<p>The only thing that's missing is that the entry point class <code>CoffeeApp</code> isn't included in the graph. We need to explicitly register it as an entry point in the <code>@Module</code> annotation.</p>
+
+<pre class="prettyprint">
+@Module(
+    entryPoints = CoffeeApp.class
+)
+class DripCoffeeModule {
+  ...
+}
+</pre>
+
+<p>Entry points enable the complete graph to be validated <strong>at compile time</strong>. Detecting problems early speeds up development and takes some of the danger out of refactoring.</p>
+
+<p>Now that the graph is constructed and the entry point is injected, we run our coffee maker app. Fun.</p>
+
+<pre>
+$ java -cp ... coffee.CoffeeApp
+~ ~ ~ heating ~ ~ ~
+=> => pumping => =>
+ [_]P coffee! [_]P
+</pre>
+
+<h4>Singletons</h4>
+
+<p>Annotate an <code>@Provides</code> method or injectable class with <code>@Singleton</code>. The graph will use a single instance of the value for all of its clients.</p>
+
+<pre class="prettyprint">
+@Provides @Singleton Heater provideHeater() {
+  return new ElectricHeater();
+}
+</pre>
+
+<p>The <code>@Singleton</code> annotation on an injectable class also serves as documentation. It reminds potential maintainers that this class may be shared by multiple threads.</p>
+
+<pre class="prettyprint">
+@Singleton
+class CoffeeMaker {
+  ...
+}
+</pre>
+
+<h4>Lazy injections</h4>
+
+<p>Sometimes you need an object to be instantiated lazily.  For any binding <code>T</code>, you can create a <code>Lazy&lt;T></code> which defers instantiation until the first call to <code>Lazy&lt;T></code>'s <code>get()</code> method. If <code>T</code> is a singleton, then <code>Lazy&lt;T></code> will be the same instance for all injections within the <code>ObjectGraph</code>.  Otherwise, each injection site will get its own <code>Lazy&lt;T></code> instance.  Regardless, subsequent calls to any given instance of <code>Lazy&lt;T></code> will return the same underlying instance of <code>T</code>.</p>
+
+<pre class="prettyprint">
+class GridingCoffeeMaker {
+  @Inject Lazy<Grinder> lazyGrinder;
+
+  public void brew() {
+    while (needsGrinding()) {
+      // Grinder created once on first call to .get() and cached.
+      lazyGrinder.get().grind();
+    }
+  }
+}
+</pre>
+
+<h4>Provider injections</h4>
+
+<p>Sometimes you need multiple instances to be returned instead of just injecting a single value.  While you have several options (Factories, Builders, etc.)   one option is to inject a <code>Provider&lt;T></code> instead of just <code>T</code>.  A <code>Provider&lt;T></code> creates a new instance of <code>T</code> each time <code>.get()</code> is called.</p>
+
+<pre class="prettyprint">
+
+class BigCoffeeMaker {
+  @Inject Provider<Filter> filterProvider;
+
+  public void brew(int numberOfPots) {
+	...
+    for (int p = 0; p < numberOfPots; p++) {
+      maker.addFilter(filterProvider.get()); //new filter every time.
+      maker.addCoffee(...);
+      maker.percolate();
+      ...
+    }
+  }
+}
+</pre>
+
+<p><span class="label label-inverse">Note:</span><em> Injecting <code>Provider&lt;T></code> has the possibility of creating confusing code, and may be a design smell of mis-scoped or mis-structured objects in your graph.  Often you will want to use a <code>Factory&lt;T></code> or a <code>Lazy&lt;T></code> or re-organize the lifetimes and structure of your code to be able to just inject a <code>T</code>.  Injecting <code>Provider&lt;T></code> can, however, be a life saver in some cases.  A common use is when you must use a legacy architecture that doesn't line up with your object's natural lifetimes (e.g. servlets are singletons by design, but only are valid in the context of request-specfic data).</em></p>
+
+<h4>Qualifiers</h4>
+
+<p>Sometimes the type alone is insufficient to identify a dependency. For example, a sophisticated coffee maker app may want separate heaters for the water and the hot plate.</p>
+
+<p>In this case, we add a <strong>qualifier annotation</strong>. This is any annotation that itself has a <code>@Qualifier</code> annotation. Here's the declaration of <code>@Named</code>, a qualifier annotation included in <code>javax.inject</code>:</p>
+
+<pre class="prettyprint">
+@Qualifier
+@Documented
+@Retention(RUNTIME)
+public @interface Named {
+  String value() default "";
+}
+</pre>
+
+<p>You can create your own qualifier annotations, or just use <code>@Named</code>. Apply qualifiers by annotating the field or parameter of interest. The type and qualifier annotation will both be used to identify the dependency.</p>
+
+<pre class="prettyprint">
+class ExpensiveCoffeeMaker {
+  @Inject @Named("water") Heater waterHeater;
+  @Inject @Named("hot plate") Heater hotPlateHeater;
+  ...
+}
+</pre>
+
+<p>Supply qualified values by annotating the corresponding <code>@Provides</code> method.</p>
+
+<pre class="prettyprint">
+@Provides @Named("hot plate") Heater provideHotPlateHeater() {
+  return new ElectricHeater(70);
+}
+
+@Provides @Named("water") Heater provideWaterHeater() {
+  return new ElectricHeater(93);
+}
+</pre>
+
+<p>Dependencies may not have multiple qualifier annotations.</p>
+
+<h4>Static Injection</h4>
+
+<p><span class="label label-important">Warning:</span> This feature should be used sparingly because static dependencies are difficult to test and reuse.</p>
+
+<p>Dagger can inject static fields. Classes that declare static fields with <code>@Inject</code> annotations must be listed as <code>staticInjections</code> in a module annotation.</p>
+
+<pre class="prettyprint">
+@Module(
+    staticInjections = LegacyCoffeeUtils.class
+)
+class LegacyModule {
+}
+</pre>
+
+<p>Use <code>ObjectGraph.injectStatics()</code> to populate these static fields with their injected values:</p>
+
+<pre class="prettyprint">
+ObjectGraph objectGraph = ObjectGraph.create(new LegacyModule());
+objectGraph.injectStatics();
+</pre>
+
+<h4>Compile-time Validation</h4>
+
+<p>Dagger includes an <a href="http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html">annotation processor</a> that validates modules and injections. This processor is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is missing a binding for <code>Executor</code>:</p>
+
+<pre class="prettyprint">
+@Module
+class DripCoffeeModule {
+  @Provides Heater provideHeater(Executor executor) {
+    return new CpuHeater(executor);
+  }
+}
+</pre>
+
+<p>When compiling it, <code>javac</code> rejects the missing binding:</p>
+
+<pre>
+[ERROR] COMPILATION ERROR :
+[ERROR] error: No binding for java.util.concurrent.Executor
+               required by provideHeater(java.util.concurrent.Executor)
+</pre>
+
+<p>Fix the problem either by adding an <code>@Provides</code>-annotated method for <code>Executor</code>, or by marking the module as incomplete. Incomplete modules are permitted to have missing dependencies.</p>
+
+<pre class="prettyprint">
+@Module(complete = false)
+class DripCoffeeModule {
+  @Provides Heater provideHeater(Executor executor) {
+    return new CpuHeater(executor);
+  }
+}
+</pre>
+
+<p>To get the most out of compile-time validation, create a module that includes all of your application's modules as children. The annotation processor will detect problems across the modules and report them.</p>
+
+<pre class="prettyprint">
+@Module(
+    children = {
+        DripCoffeeModule.class,
+        ExecutorModule.class
+    }
+)
+public class CoffeeAppModule {
+}
+</pre>
+
+<p>The annotation processor is enabled automatically when you include Dagger's jar file on your compile classpath.</p>
+
+<h4>Compile-time Code Generation</h4>
+
+<p>Dagger's annotation processor may also generate source files with names like <code>CoffeeMaker$InjectAdapter.java</code> or <code>DripCoffeeModule$ModuleAdapter</code>. These files are Dagger implementation details. You shouldn't need to use them directly, though they can be handy when step-debugging through an injection.</p>
+
+<h4>Module overrides</h4>
+
+<p>Dagger will fail with an error if there are multiple competing <code>@Provides</code> methods for the same dependency. But sometimes it's necessary to replace production code with a substitute for development or testing. Using <code>overrides = true</code> in a module annotation lets you take precedence over the bindings of other modules.</p>
+
+<p>This JUnit test overrides <code>DripCoffeeModule</code>'s binding for <code>Heater</code> with a mock object from <a href="http://mockito.googlecode.com/">Mockito</a>. The mock gets injected into the <code>CoffeeMaker</code> and also into the test.</p>
+
+<pre class="prettyprint">
+public class CoffeeMakerTest {
+  @Inject CoffeeMaker coffeeMaker;
+  @Inject Heater heater;
+
+  @Before public void setUp() {
+    ObjectGraph.create(new TestModule()).inject(this);
+  }
+
+  @Module(
+      children = DripCoffeeModule.class,
+      entryPoints = CoffeeMakerTest.class,
+      overrides = true
+  )
+  static class TestModule {
+    @Provides @Singleton Heater provideHeater() {
+      return Mockito.mock(Heater.class);
+    }
+  }
+
+  @Test public void testHeaterIsTurnedOnAndThenOff() {
+    Mockito.when(heater.isHot()).thenReturn(true);
+    coffeeMaker.brew();
+    Mockito.verify(heater, Mockito.times(1)).on();
+    Mockito.verify(heater, Mockito.times(1)).off();
+  }
+}
+</pre>
+
+<p>Overrides are best suited for small variations on the application:</p>
+<ul>
+  <li>Replacing the real implementation with a mock for unit tests.</li>
+  <li>Replacing LDAP authentication with fake authentication for development.</li>
+</ul>
+
+<p>For more substantial variations it's often simpler to use a different combination of modules.</p>
+
+
+<h3>Using Dagger In Your Build</h3>
+
+<p>You will need to include the <code>dagger-${dagger.version}.jar</code> in your application's runtime.  In order to activate code generation you will need to include <code>dagger-compiler-${dagger.version}.jar</code> in your build at compile time.</p>
+
+<p>In a Maven project, one would include the runtime in the dependencies section of your <code>pom.xml</code> (replacing <code>${dagger.version}</code> with the appropriate current release), and the <code>dagger-compiler</code> artifact as a dependency of the compiler plugin:</p>
+
+<pre class="prettyprint">
+&lt;dependencies>
+  &lt;dependency>
+    &lt;groupId>com.squareup&lt;/groupId>
+    &lt;artifactId>dagger&lt;/artifactId>
+    &lt;version>${dagger.version}&lt;/version>
+  &lt;/dependency>
+&lt;/dependencies>
+&lt;build>
+  &lt;plugins>
+    &lt;plugin>
+      &lt;artifactId>maven-compiler-plugin&lt;/artifactId>
+      &lt;dependencies>
+        &lt;dependency>
+          &lt;groupId>com.squareup&lt;/groupId>
+          &lt;artifactId>dagger-compiler&lt;/artifactId>
+          &lt;version>${dagger.version}&lt;/version>
+        &lt;/dependency>
+      &lt;/dependencies>
+    &lt;/plugin>
+  &lt;/plugins>
+&lt;/build>
+</pre>
+
+
+
+<h3>Upgrading from Guice</h3>
+
+<p>Some notable Guice features that Dagger doesn't support:</p>
+<ul>
+  <li>Injecting <code>final</code> fields and <code>private</code> members. For best performance Dagger generates code. Work around this by using constructor injection.</li>
+  <li>Eager singletons. Work around this by creating an <code>EagerSingletons</code> class that declares static fields for each eager singleton.</li>
+  <li>Method injection.</li>
+  <li>Classes that lack <code>@Inject</code> annotations cannot be constructed by Dagger, even if they have a no-argument constructor.</li>
+</ul>
+
+
+<h3>License</h3>
+
+<pre>
+Copyright 2012 Square, Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+</pre>
/Fim/
/Fim/
diff --git a/deploy_website.sh b/deploy_website.sh
index 0714118..2afa5f0 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -29,7 +29,7 @@
 # Stage all files in git and create a commit
 git add .
 git add -u
-git commit -m "Website at ${date}"
+git commit -m "Website at $(date)"
 
 # Push the new files up to GitHub
 git push origin gh-pages
/Fim/
diff --git a/website/_layouts/default.html b/website/_layouts/default.html
index 7572fcc..f0d4bb4 100644
--- a/website/_layouts/default.html
+++ b/website/_layouts/default.html
@@ -6,16 +6,16 @@
     <title>Dagger &#x2020; A fast dependency injector for Android and Java.</title>
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <meta name="description" content="A fast dependency injector for Android and Java." />
-    <link href="/static/bootstrap.min.css" rel="stylesheet">
-    <link href="/static/bootstrap-responsive.min.css" rel="stylesheet">
-    <link href="/static/prettify.css" rel="stylesheet">
-    <link href="/static/app.css" rel="stylesheet">
+    <link href="static/bootstrap.min.css" rel="stylesheet">
+    <link href="static/bootstrap-responsive.min.css" rel="stylesheet">
+    <link href="static/prettify.css" rel="stylesheet">
+    <link href="static/app.css" rel="stylesheet">
 </head>
 <body>
 <div class="container">
     <div class="row">
         <div class="span4 side">
-            <h1><img src="/static/logo.png" alt="Dagger"></h1>
+            <h1><img src="static/logo.png" alt="Dagger"></h1>
             <h3>A fast dependency injector for Android and Java.</h3>
             <p><a href="https://squareup.com/"><img src="static/square.png" alt="by Square, Inc."></a></p>
       </div>
@@ -23,11 +23,11 @@
 
 {{ content }}
 
-            <a id="ribbon" href="https://github.com/square/dagger"><img src="/static/ribbon.png" alt="Fork me on GitHub"></a>
+            <a id="ribbon" href="https://github.com/square/dagger"><img src="static/ribbon.png" alt="Fork me on GitHub"></a>
         </div></div>
     </div>
 </div>
-<script src="/static/prettify.js"></script>
+<script src="static/prettify.js"></script>
 <script> prettyPrint(); </script>
 </body>
 </html>
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 91b4efb..72da10d 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -52,22 +52,20 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
-  
+
   <build>
     <plugins>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>2.5</version>
         <configuration>
-          <source>${java.version}</source>
-          <target>${java.version}</target>
           <compilerArgument>-proc:none</compilerArgument>
         </configuration>
       </plugin>
+
       <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-invoker-plugin</artifactId>
-        <version>1.7</version>
         <configuration>
           <addTestClassPath>true</addTestClassPath>
           <cloneProjectsTo>${project.build.directory}/it</cloneProjectsTo>
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 4598aa1..6ca8b14 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -48,9 +48,4 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
-
-  <build>
-    <plugins>
-    </plugins>
-  </build>
 </project>
/Fim/
diff --git a/example/pom.xml b/example/pom.xml
index 480bbed..837a0b2 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -38,10 +38,11 @@
       <version>${project.version}</version>
     </dependency>
   </dependencies>
-  
+
   <build>
     <plugins>
       <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
         <dependencies>
           <dependency>
/Fim/
diff --git a/pom.xml b/pom.xml
index ec0a86d..1fab4ac 100644
--- a/pom.xml
+++ b/pom.xml
@@ -35,10 +35,10 @@
   <url>https://github.com/square/dagger</url>
 
   <modules>
-    <module>core</module>
     <module>androidmanifest</module>
-    <module>example</module>
     <module>compiler</module>
+    <module>core</module>
+    <module>example</module>
   </modules>
 
   <properties>
@@ -108,8 +108,6 @@
   </dependencyManagement>
 
   <build>
-    <finalName>square-${project.artifactId}-${project.version}</finalName>
-
     <plugins>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
@@ -148,6 +146,12 @@
           <artifactId>maven-plugin-plugin</artifactId>
           <version>2.8</version>
         </plugin>
+
+        <plugin>
+          <groupId>org.apache.maven.plugins</groupId>
+          <artifactId>maven-invoker-plugin</artifactId>
+          <version>1.7</version>
+        </plugin>
       </plugins>
     </pluginManagement>
   </build>
/Fim/
diff --git a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorMojo.java b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorMojo.java
index 6b63949..fbae369 100644
--- a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorMojo.java
+++ b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorMojo.java
@@ -16,7 +16,7 @@
  * @goal generate
  * @phase generate-sources
  */
-@SuppressWarnings({ "JavaDoc", "UnusedDeclaration" }) // Class and non-standard Javadoc used by Maven.
+@SuppressWarnings({ "JavaDoc", "UnusedDeclaration" }) // Non-standard Javadoc used by Maven.
 public class ModuleGeneratorMojo extends AbstractMojo {
 
   /**
/Fim/
diff --git a/checkstyle.xml b/checkstyle.xml
index 658a417..2820b2a 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -49,7 +49,7 @@
         <!-- Checks for Size Violations.                    -->
         <!-- See http://checkstyle.sf.net/config_sizes.html -->
         <module name="LineLength">
-            <property name="max" value="120"/>
+            <property name="max" value="100"/>
         </module>
         <!--module name="MethodLength"/-->
         <!--module name="ParameterNumber"/-->
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 97330c1..c42eab1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -345,7 +345,8 @@
     final ExecutableElement constructor;
     final List<Element> fields;
 
-    InjectedClass(TypeElement type, List<Element> staticFields, ExecutableElement constructor, List<Element> fields) {
+    InjectedClass(TypeElement type, List<Element> staticFields, ExecutableElement constructor,
+        List<Element> fields) {
       this.type = type;
       this.staticFields = staticFields;
       this.constructor = constructor;
/Fim/
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index daf8ce4..83e20a5 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -28,7 +28,8 @@
  */
 public final class SetBinding<T> extends Binding<Set<T>> {
 
-  public static <T> void add(Map<String, Binding<?>> bindings, String elementKey, Binding<?> binding) {
+  public static <T> void add(Map<String, Binding<?>> bindings, String elementKey,
+      Binding<?> binding) {
     SetBinding<T> elementBinding = (SetBinding<T>) bindings.get(elementKey);
     if (elementBinding == null) {
       elementBinding = new SetBinding<T>(elementKey);
/Fim/
diff --git a/pom.xml b/pom.xml
index 108ca88..b242ed9 100644
--- a/pom.xml
+++ b/pom.xml
@@ -127,6 +127,15 @@
 
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-release-plugin</artifactId>
+        <version>2.3.2</version>
+        <configuration>
+          <autoVersionSubmodules>true</autoVersionSubmodules>
+        </configuration>
+      </plugin>
+
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
         <version>2.9.1</version>
         <configuration>
/Fim/
diff --git a/example/src/main/java/coffee/CoffeeApp.java b/example/src/main/java/coffee/CoffeeApp.java
index 4e23e3c..b6be33a 100644
--- a/example/src/main/java/coffee/CoffeeApp.java
+++ b/example/src/main/java/coffee/CoffeeApp.java
@@ -4,7 +4,7 @@
 
 import dagger.ObjectGraph;
 
-class CoffeeApp implements Runnable {
+public class CoffeeApp implements Runnable {
   @Inject CoffeeMaker coffeeMaker;
 
   @Override public void run() {
/Fim/
diff --git a/androidmanifest/pom.xml b/androidmanifest/pom.xml
index 20d6ce8..9973256 100644
--- a/androidmanifest/pom.xml
+++ b/androidmanifest/pom.xml
@@ -14,16 +14,13 @@
   See the License for the specific language governing permissions and
   limitations under the License.
 -->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0-SNAPSHOT</version>
+    <version>0.9</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 72da10d..08c3fd5 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -15,16 +15,13 @@
   See the License for the specific language governing permissions and
   limitations under the License.
 -->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0-SNAPSHOT</version>
+    <version>0.9</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 6ca8b14..05ed123 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -14,16 +14,13 @@
   See the License for the specific language governing permissions and
   limitations under the License.
 -->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0-SNAPSHOT</version>
+    <version>0.9</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/example/pom.xml b/example/pom.xml
index 837a0b2..f5f6ebb 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -14,16 +14,13 @@
   See the License for the specific language governing permissions and
   limitations under the License.
 -->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0-SNAPSHOT</version>
+    <version>0.9</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/pom.xml b/pom.xml
index b242ed9..b406fad 100644
--- a/pom.xml
+++ b/pom.xml
@@ -14,10 +14,7 @@
   See the License for the specific language governing permissions and
   limitations under the License.
 -->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
@@ -29,7 +26,7 @@
   <groupId>com.squareup</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.0-SNAPSHOT</version>
+  <version>0.9</version>
   <name>Dagger (Parent)</name>
   <description>A JSR-330 dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -59,6 +56,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
+    <tag>0.9</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/androidmanifest/pom.xml b/androidmanifest/pom.xml
index 9973256..c3d3ef7 100644
--- a/androidmanifest/pom.xml
+++ b/androidmanifest/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>0.9</version>
+    <version>1.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 08c3fd5..b9e29a3 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>0.9</version>
+    <version>1.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 05ed123..209c49a 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>0.9</version>
+    <version>1.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/example/pom.xml b/example/pom.xml
index f5f6ebb..1a63ca3 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>0.9</version>
+    <version>1.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/pom.xml b/pom.xml
index b406fad..3bc8ecf 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>0.9</version>
+  <version>1.0-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
   <description>A JSR-330 dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -56,7 +56,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>0.9</tag>
+    <tag>HEAD</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/androidmanifest/README.md b/androidmanifest/README.md
index b463b40..65aa544 100644
--- a/androidmanifest/README.md
+++ b/androidmanifest/README.md
@@ -9,7 +9,7 @@
 object graph. You will need to explicitly include it during construction:
 
 ```java
-ObjectGraph og = ObjectGraph.get(
+ObjectGraph og = ObjectGraph.create(
   new MyModule(),       // Your declared module.
   new ManifestModule()  // Module generated from this plugin.
 );
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 03de771..8982a4d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -170,8 +170,7 @@
       }
       ExecutableElement constructor = (ExecutableElement) element;
       if (constructor.getParameters().isEmpty()) {
-        Set<Modifier> modifiers = constructor.getModifiers();
-        if (modifiers.contains(Modifier.PRIVATE) || modifiers.contains(Modifier.PROTECTED)) {
+        if (constructor.getModifiers().contains(Modifier.PRIVATE)) {
           return null;
         } else {
           return constructor;
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java b/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
index 06c2977..ac4e4a5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
@@ -72,21 +72,6 @@
     return builder.toString();
   }
 
-  /** Returns a string like {@code java.util.List<java.lang.String>}. */
-  public static String parameterizedType(Class<?> raw, String... parameters) {
-    StringBuilder result = new StringBuilder();
-    result.append(raw.getCanonicalName());
-    result.append("<");
-    for (int i = 0; i < parameters.length; i++) {
-      if (i != 0) {
-        result.append(", ");
-      }
-      result.append(parameters[i]);
-    }
-    result.append(">");
-    return result.toString();
-  }
-
   /** Returns a string for {@code type}. Primitive types are always boxed. */
   public static String typeToString(TypeMirror type) {
     StringBuilder result = new StringBuilder();
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 57e68c3..be09da8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -204,23 +204,23 @@
     writer.emitEmptyLine();
     writer.emitJavadoc(binderTypeDocs(strippedTypeName, isAbstract, injectMembers, dependent));
     writer.beginType(adapterName, "class", PUBLIC | FINAL,
-        CodeGen.parameterizedType(Binding.class, strippedTypeName),
+        JavaWriter.type(Binding.class, strippedTypeName),
         interfaces(strippedTypeName, injectMembers, constructor != null));
 
     if (constructor != null) {
       for (VariableElement parameter : constructor.getParameters()) {
-        writer.emitField(CodeGen.parameterizedType(Binding.class,
+        writer.emitField(JavaWriter.type(Binding.class,
             CodeGen.typeToString(parameter.asType())),
             parameterName(disambiguateFields, parameter), PRIVATE);
       }
     }
     for (Element field : fields) {
-      writer.emitField(CodeGen.parameterizedType(Binding.class,
+      writer.emitField(JavaWriter.type(Binding.class,
           CodeGen.typeToString(field.asType())),
           fieldName(disambiguateFields, field), PRIVATE);
     }
     if (supertype != null) {
-      writer.emitField(CodeGen.parameterizedType(Binding.class,
+      writer.emitField(JavaWriter.type(Binding.class,
           CodeGen.rawTypeToString(supertype, '.')), "supertype", PRIVATE);
     }
 
@@ -244,7 +244,7 @@
         for (VariableElement parameter : constructor.getParameters()) {
           writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
               parameterName(disambiguateFields, parameter),
-              writer.compressType(CodeGen.parameterizedType(Binding.class,
+              writer.compressType(JavaWriter.type(Binding.class,
                   CodeGen.typeToString(parameter.asType()))),
               JavaWriter.stringLiteral(GeneratorKeys.get(parameter)),
               strippedTypeName);
@@ -253,7 +253,7 @@
       for (Element field : fields) {
         writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
             fieldName(disambiguateFields, field),
-            writer.compressType(CodeGen.parameterizedType(Binding.class,
+            writer.compressType(JavaWriter.type(Binding.class,
                 CodeGen.typeToString(field.asType()))),
             JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) field)),
             strippedTypeName);
@@ -261,7 +261,7 @@
       if (supertype != null) {
         writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class, false)",
             "supertype",
-            writer.compressType(CodeGen.parameterizedType(Binding.class,
+            writer.compressType(JavaWriter.type(Binding.class,
                 CodeGen.rawTypeToString(supertype, '.'))),
             JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(supertype)),
             strippedTypeName);
@@ -271,7 +271,7 @@
       writer.emitEmptyLine();
       writer.emitJavadoc(ProcessorJavadocs.GET_DEPENDENCIES_METHOD);
       writer.emitAnnotation(Override.class);
-      String setOfBindings = CodeGen.parameterizedType(Set.class, "Binding<?>");
+      String setOfBindings = JavaWriter.type(Set.class, "Binding<?>");
       writer.beginMethod("void", "getDependencies", PUBLIC, setOfBindings, "getBindings",
           setOfBindings, "injectMembersBindings");
       if (constructor != null) {
@@ -333,10 +333,10 @@
   private String[] interfaces(String strippedTypeName, boolean hasFields, boolean isProvider) {
     List<String> interfaces = new ArrayList<String>();
     if (isProvider) {
-      interfaces.add(CodeGen.parameterizedType(Provider.class, strippedTypeName));
+      interfaces.add(JavaWriter.type(Provider.class, strippedTypeName));
     }
     if (hasFields) {
-      interfaces.add(CodeGen.parameterizedType(MembersInjector.class, strippedTypeName));
+      interfaces.add(JavaWriter.type(MembersInjector.class, strippedTypeName));
     }
     return interfaces.toArray(new String[interfaces.size()]);
   }
@@ -382,7 +382,7 @@
     writer.beginType(adapterName, "class", PUBLIC | FINAL, StaticInjection.class.getSimpleName());
 
     for (Element field : fields) {
-      writer.emitField(CodeGen.parameterizedType(Binding.class,
+      writer.emitField(JavaWriter.type(Binding.class,
           CodeGen.typeToString(field.asType())),
           fieldName(false, field), PRIVATE);
     }
@@ -394,7 +394,7 @@
     for (Element field : fields) {
       writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
           fieldName(false, field),
-          writer.compressType(CodeGen.parameterizedType(Binding.class,
+          writer.compressType(JavaWriter.type(Binding.class,
               CodeGen.typeToString(field.asType()))),
           JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) field)),
           typeName);
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 8f1f05e..45f1ecc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -66,7 +66,7 @@
 public final class ProvidesProcessor extends AbstractProcessor {
   private final LinkedHashMap<String, List<ExecutableElement>> remainingTypes =
       new LinkedHashMap<String, List<ExecutableElement>>();
-  private static final String BINDINGS_MAP = CodeGen.parameterizedType(
+  private static final String BINDINGS_MAP = JavaWriter.type(
       Map.class, String.class.getCanonicalName(), Binding.class.getCanonicalName() + "<?>");
 
   // TODO: include @Provides methods from the superclass
@@ -183,7 +183,7 @@
     writer.emitEmptyLine();
     writer.emitJavadoc(ProcessorJavadocs.MODULE_TYPE);
     writer.beginType(adapterName, "class", PUBLIC | FINAL,
-        CodeGen.parameterizedType(ModuleAdapter.class, typeName));
+        JavaWriter.type(ModuleAdapter.class, typeName));
 
     StringBuilder entryPointsField = new StringBuilder().append("{ ");
     for (Object entryPoint : entryPoints) {
@@ -344,12 +344,12 @@
     writer.emitEmptyLine();
     writer.emitJavadoc(binderTypeDocs(returnType, false, false, dependent));
     writer.beginType(className, "class", PUBLIC | FINAL | STATIC,
-        CodeGen.parameterizedType(Binding.class, returnType),
-        CodeGen.parameterizedType(Provider.class, returnType));
+        JavaWriter.type(Binding.class, returnType),
+        JavaWriter.type(Provider.class, returnType));
     writer.emitField(moduleType, "module", PRIVATE | FINAL);
     for (Element parameter : parameters) {
       TypeMirror parameterType = parameter.asType();
-      writer.emitField(CodeGen.parameterizedType(Binding.class,
+      writer.emitField(JavaWriter.type(Binding.class,
           CodeGen.typeToString(parameterType)),
           parameterName(parameter), PRIVATE);
     }
@@ -374,7 +374,7 @@
         String parameterKey = GeneratorKeys.get(parameter);
         writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
             parameterName(parameter),
-            writer.compressType(CodeGen.parameterizedType(Binding.class,
+            writer.compressType(JavaWriter.type(Binding.class,
                 CodeGen.typeToString(parameter.asType()))),
             JavaWriter.stringLiteral(parameterKey),
             writer.compressType(moduleType));
@@ -384,7 +384,7 @@
       writer.emitEmptyLine();
       writer.emitJavadoc(ProcessorJavadocs.GET_DEPENDENCIES_METHOD);
       writer.emitAnnotation(Override.class);
-      String setOfBindings = CodeGen.parameterizedType(Set.class, "Binding<?>");
+      String setOfBindings = JavaWriter.type(Set.class, "Binding<?>");
       writer.beginMethod("void", "getDependencies", PUBLIC, setOfBindings, "getBindings",
           setOfBindings, "injectMembersBindings");
       for (Element parameter : parameters) {
/Fim/
diff --git a/pom.xml b/pom.xml
index d488e12..c9720c4 100644
--- a/pom.xml
+++ b/pom.xml
@@ -46,7 +46,7 @@
     <javax.inject.version>1</javax.inject.version>
     <maven.version>2.0.6</maven.version>
     <ant.version>1.8.2</ant.version>
-    <javawriter.version>1.0.1</javawriter.version>
+    <javawriter.version>1.0.2</javawriter.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
/Fim/
diff --git a/compiler/src/it/inner-classes-complaint-injection/invoker.properties b/compiler/src/it/inner-classes-complaint-injection/invoker.properties
new file mode 100644
index 0000000..324b5fb
--- /dev/null
+++ b/compiler/src/it/inner-classes-complaint-injection/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
\ No newline at end of file
/Fim/
diff --git a/compiler/src/it/inner-classes-complaint-injection/pom.xml b/compiler/src/it/inner-classes-complaint-injection/pom.xml
new file mode 100644
index 0000000..534def8
--- /dev/null
+++ b/compiler/src/it/inner-classes-complaint-injection/pom.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.squareup.dagger.tests</groupId>
+  <artifactId>inner-classes-complaint-injection</artifactId>
+  <version>@dagger.version@</version>
+  <packaging>jar</packaging>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/inner-classes-complaint-injection/src/main/java/test/TestApp.java b/compiler/src/it/inner-classes-complaint-injection/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..ab3ce3c
--- /dev/null
+++ b/compiler/src/it/inner-classes-complaint-injection/src/main/java/test/TestApp.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+
+import dagger.ObjectGraph;
+import dagger.Provides;
+
+import javax.inject.Inject;
+import java.lang.Override;
+
+class TestApp {
+
+  class Foo {
+    @Inject public Foo() {}
+  }
+}
/Fim/
diff --git a/compiler/src/it/inner-classes-complaint-injection/verify.bsh b/compiler/src/it/inner-classes-complaint-injection/verify.bsh
new file mode 100644
index 0000000..0b02b80
--- /dev/null
+++ b/compiler/src/it/inner-classes-complaint-injection/verify.bsh
@@ -0,0 +1,6 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Can't inject a non-static inner class: test.TestApp.Foo"});
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index be09da8..e1d9046 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -36,6 +36,7 @@
 import javax.inject.Singleton;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
@@ -113,12 +114,28 @@
     // First gather the set of classes that have @Inject-annotated members.
     Set<String> injectedTypeNames = new LinkedHashSet<String>();
     for (Element element : env.getElementsAnnotatedWith(Inject.class)) {
-      TypeMirror type = element.getEnclosingElement().asType();
-      injectedTypeNames.add(CodeGen.rawTypeToString(type, '.'));
+      Element enclosingType = element.getEnclosingElement();
+      if (!validateInjectable(enclosingType)) {
+        continue;
+      }
+      injectedTypeNames.add(CodeGen.rawTypeToString(enclosingType.asType(), '.'));
     }
     return injectedTypeNames;
   }
 
+  private boolean validateInjectable(Element injectableType) {
+    ElementKind elementKind = injectableType.getEnclosingElement().getKind();
+    boolean isClassOrInterface = elementKind.isClass() || elementKind.isInterface();
+    boolean isStatic = injectableType.getModifiers().contains(Modifier.STATIC);
+
+    if (isClassOrInterface && !isStatic) {
+      error("Can't inject a non-static inner class: " + injectableType, injectableType);
+      return false;
+    }
+
+    return true;
+  }
+
   /**
    * @param injectedClassName the name of a class with an @Inject-annotated member.
    */
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
new file mode 100644
index 0000000..293b6b9
--- /dev/null
+++ b/examples/pom.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2013 Google, Inc.
+ Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup</groupId>
+    <artifactId>dagger-parent</artifactId>
+    <version>1.0-SNAPSHOT</version>
+  </parent>
+
+  <groupId>com.squareup.dagger.example</groupId>
+  <artifactId>dagger-example-parent</artifactId>
+  <packaging>pom</packaging>
+  <name>Dagger Example (Parent)</name>
+
+  <modules>
+    <module>simple</module>
+  </modules>
+
+</project>
/Fim/
diff --git a/example/pom.xml b/examples/simple/pom.xml
similarity index 84%
rename from example/pom.xml
rename to examples/simple/pom.xml
index c6cd863..bc17f01 100644
--- a/example/pom.xml
+++ b/examples/simple/pom.xml
@@ -18,24 +18,23 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup</groupId>
-    <artifactId>dagger-parent</artifactId>
+    <groupId>com.squareup.dagger.example</groupId>
+    <artifactId>dagger-example-parent</artifactId>
     <version>1.0-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
   </parent>
 
-  <artifactId>dagger-example</artifactId>
+  <artifactId>simple-dagger-example</artifactId>
   <packaging>jar</packaging>
-  <name>Dagger Example</name>
+  <name>Dagger Example - Simple</name>
 
   <dependencies>
     <dependency>
-      <groupId>${project.groupId}</groupId>
+      <groupId>com.squareup</groupId>
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>${project.groupId}</groupId>
+      <groupId>com.squareup</groupId>
       <artifactId>dagger-compiler</artifactId>
       <version>${project.version}</version>
       <optional>true</optional>
/Fim/
diff --git a/example/src/main/java/coffee/CoffeeApp.java b/examples/simple/src/main/java/coffee/CoffeeApp.java
similarity index 100%
rename from example/src/main/java/coffee/CoffeeApp.java
rename to examples/simple/src/main/java/coffee/CoffeeApp.java
/Fim/
diff --git a/example/src/main/java/coffee/CoffeeMaker.java b/examples/simple/src/main/java/coffee/CoffeeMaker.java
similarity index 100%
rename from example/src/main/java/coffee/CoffeeMaker.java
rename to examples/simple/src/main/java/coffee/CoffeeMaker.java
/Fim/
diff --git a/example/src/main/java/coffee/DripCoffeeModule.java b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
similarity index 100%
rename from example/src/main/java/coffee/DripCoffeeModule.java
rename to examples/simple/src/main/java/coffee/DripCoffeeModule.java
/Fim/
diff --git a/example/src/main/java/coffee/ElectricHeater.java b/examples/simple/src/main/java/coffee/ElectricHeater.java
similarity index 100%
rename from example/src/main/java/coffee/ElectricHeater.java
rename to examples/simple/src/main/java/coffee/ElectricHeater.java
/Fim/
diff --git a/example/src/main/java/coffee/Heater.java b/examples/simple/src/main/java/coffee/Heater.java
similarity index 100%
rename from example/src/main/java/coffee/Heater.java
rename to examples/simple/src/main/java/coffee/Heater.java
/Fim/
diff --git a/example/src/main/java/coffee/Pump.java b/examples/simple/src/main/java/coffee/Pump.java
similarity index 100%
rename from example/src/main/java/coffee/Pump.java
rename to examples/simple/src/main/java/coffee/Pump.java
/Fim/
diff --git a/example/src/main/java/coffee/PumpModule.java b/examples/simple/src/main/java/coffee/PumpModule.java
similarity index 100%
rename from example/src/main/java/coffee/PumpModule.java
rename to examples/simple/src/main/java/coffee/PumpModule.java
/Fim/
diff --git a/example/src/main/java/coffee/Thermosiphon.java b/examples/simple/src/main/java/coffee/Thermosiphon.java
similarity index 100%
rename from example/src/main/java/coffee/Thermosiphon.java
rename to examples/simple/src/main/java/coffee/Thermosiphon.java
/Fim/
diff --git a/pom.xml b/pom.xml
index c9720c4..260a858 100644
--- a/pom.xml
+++ b/pom.xml
@@ -35,7 +35,7 @@
     <module>androidmanifest</module>
     <module>compiler</module>
     <module>core</module>
-    <module>example</module>
+    <module>examples</module>
   </modules>
 
   <properties>
/Fim/
diff --git a/compiler/src/it/method-injection/invoker.properties b/compiler/src/it/method-injection/invoker.properties
new file mode 100644
index 0000000..324b5fb
--- /dev/null
+++ b/compiler/src/it/method-injection/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
\ No newline at end of file
/Fim/
diff --git a/compiler/src/it/method-injection/pom.xml b/compiler/src/it/method-injection/pom.xml
new file mode 100644
index 0000000..20c3961
--- /dev/null
+++ b/compiler/src/it/method-injection/pom.xml
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>method-injection</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.0</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
+          <forceJavacCompilerUse>true</forceJavacCompilerUse>
+        </configuration>
+        <dependencies>
+          <dependency>
+            <groupId>@dagger.groupId@</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>@dagger.version@</version>
+          </dependency>
+        </dependencies>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/method-injection/src/main/java/test/TestApp.java b/compiler/src/it/method-injection/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..4103a20
--- /dev/null
+++ b/compiler/src/it/method-injection/src/main/java/test/TestApp.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class TestApp {
+  @Inject public void doThings(Object things) {
+  }
+}
/Fim/
diff --git a/compiler/src/it/method-injection/verify.bsh b/compiler/src/it/method-injection/verify.bsh
new file mode 100644
index 0000000..002cfbf
--- /dev/null
+++ b/compiler/src/it/method-injection/verify.bsh
@@ -0,0 +1,6 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Method injection is not supported: test.TestApp.doThings"});
/Fim/
diff --git a/compiler/src/it/private-inject/invoker.properties b/compiler/src/it/private-inject/invoker.properties
new file mode 100644
index 0000000..324b5fb
--- /dev/null
+++ b/compiler/src/it/private-inject/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
\ No newline at end of file
/Fim/
diff --git a/compiler/src/it/private-inject/pom.xml b/compiler/src/it/private-inject/pom.xml
new file mode 100644
index 0000000..c3c5dab
--- /dev/null
+++ b/compiler/src/it/private-inject/pom.xml
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>private-inject</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.0</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
+          <forceJavacCompilerUse>true</forceJavacCompilerUse>
+        </configuration>
+        <dependencies>
+          <dependency>
+            <groupId>@dagger.groupId@</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>@dagger.version@</version>
+          </dependency>
+        </dependencies>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/private-inject/src/main/java/test/TestApp.java b/compiler/src/it/private-inject/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..f3d3f97
--- /dev/null
+++ b/compiler/src/it/private-inject/src/main/java/test/TestApp.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class TestApp {
+  @Inject private Object nope;
+}
/Fim/
diff --git a/compiler/src/it/private-inject/src/main/java/test/TestFoo.java b/compiler/src/it/private-inject/src/main/java/test/TestFoo.java
new file mode 100644
index 0000000..61a6904
--- /dev/null
+++ b/compiler/src/it/private-inject/src/main/java/test/TestFoo.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class TestFoo {
+  @Inject private TestFoo() {
+  }
+}
/Fim/
diff --git a/compiler/src/it/private-inject/verify.bsh b/compiler/src/it/private-inject/verify.bsh
new file mode 100644
index 0000000..0adb8d2
--- /dev/null
+++ b/compiler/src/it/private-inject/verify.bsh
@@ -0,0 +1,8 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Can't inject a private field or constructor: test.TestApp.nope"});
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Can't inject a private field or constructor: test.TestFoo.TestFoo()"});
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 530f39b..a604e7f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -116,16 +116,27 @@
     // First gather the set of classes that have @Inject-annotated members.
     Set<String> injectedTypeNames = new LinkedHashSet<String>();
     for (Element element : env.getElementsAnnotatedWith(Inject.class)) {
-      Element enclosingType = element.getEnclosingElement();
-      if (!validateInjectable(enclosingType)) {
+      if (!validateInjectable(element)) {
         continue;
       }
-      injectedTypeNames.add(CodeGen.rawTypeToString(enclosingType.asType(), '.'));
+      injectedTypeNames.add(CodeGen.rawTypeToString(element.getEnclosingElement().asType(), '.'));
     }
     return injectedTypeNames;
   }
 
-  private boolean validateInjectable(Element injectableType) {
+  private boolean validateInjectable(Element injectable) {
+    Element injectableType = injectable.getEnclosingElement();
+
+    if (injectable.getKind() == ElementKind.METHOD) {
+      error("Method injection is not supported: " + injectableType + "." + injectable, injectable);
+      return false;
+    }
+    if (injectable.getModifiers().contains(Modifier.PRIVATE)) {
+      error("Can't inject a private field or constructor: " + injectableType + "." + injectable,
+          injectable);
+      return false;
+    }
+
     ElementKind elementKind = injectableType.getEnclosingElement().getKind();
     boolean isClassOrInterface = elementKind.isClass() || elementKind.isInterface();
     boolean isStatic = injectableType.getModifiers().contains(Modifier.STATIC);
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
index 9bc1740..c49aa12 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
@@ -156,6 +156,9 @@
         if (!field.isAnnotationPresent(Inject.class) || Modifier.isStatic(field.getModifiers())) {
           continue;
         }
+        if ((field.getModifiers() & Modifier.PRIVATE) != 0) {
+          throw new IllegalStateException("Can't inject private field: " + field);
+        }
         field.setAccessible(true);
         injectedFields.add(field);
         keys.add(Keys.get(field.getGenericType(), field.getAnnotations(), field));
@@ -189,6 +192,10 @@
     int parameterCount;
     String provideKey;
     if (injectedConstructor != null) {
+      if ((injectedConstructor.getModifiers() & Modifier.PRIVATE) != 0) {
+        throw new IllegalStateException("Can't inject private constructor: " + injectedConstructor);
+      }
+
       provideKey = Keys.get(type);
       injectedConstructor.setAccessible(true);
       Type[] types = injectedConstructor.getGenericParameterTypes();
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index af96bb8..ae2a445 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -750,4 +750,33 @@
     assertThat(extension.get(SingletonLinkedFromExtension.class).c).isSameAs(root.get(C.class));
   }
 
+  @Test(expected = IllegalStateException.class)
+  public void privateFieldsFail() {
+    class Test {
+      @Inject private Object nope;
+    }
+
+    @Module(entryPoints = Test.class)
+    class TestModule {
+      @Provides Object provideObject() {
+        return null;
+      }
+    }
+
+    ObjectGraph.create(new TestModule()).inject(new Test());
+  }
+
+  @Test(expected = IllegalStateException.class)
+  public void privateConstructorsFail() {
+    class Test {
+      @Inject private Test() {
+      }
+    }
+
+    @Module(entryPoints = Test.class)
+    class TestModule {
+    }
+
+    ObjectGraph.create(new TestModule()).get(Test.class);
+  }
 }
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index ae2a445..5ecb004 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -750,8 +750,7 @@
     assertThat(extension.get(SingletonLinkedFromExtension.class).c).isSameAs(root.get(C.class));
   }
 
-  @Test(expected = IllegalStateException.class)
-  public void privateFieldsFail() {
+  @Test public void privateFieldsFail() {
     class Test {
       @Inject private Object nope;
     }
@@ -763,11 +762,15 @@
       }
     }
 
-    ObjectGraph.create(new TestModule()).inject(new Test());
+    try {
+      ObjectGraph.create(new TestModule()).inject(new Test());
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).contains("Can't inject private field: ");
+    }
   }
 
-  @Test(expected = IllegalStateException.class)
-  public void privateConstructorsFail() {
+  @Test public void privateConstructorsFail() {
     class Test {
       @Inject private Test() {
       }
@@ -777,6 +780,11 @@
     class TestModule {
     }
 
-    ObjectGraph.create(new TestModule()).get(Test.class);
+    try {
+      ObjectGraph.create(new TestModule()).get(Test.class);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).contains("Can't inject private constructor: ");
+    }
   }
 }
/Fim/
diff --git a/compiler/src/it/module-type-validation/invoker.properties b/compiler/src/it/module-type-validation/invoker.properties
new file mode 100644
index 0000000..324b5fb
--- /dev/null
+++ b/compiler/src/it/module-type-validation/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
\ No newline at end of file
/Fim/
diff --git a/compiler/src/it/module-type-validation/pom.xml b/compiler/src/it/module-type-validation/pom.xml
new file mode 100644
index 0000000..d52111b
--- /dev/null
+++ b/compiler/src/it/module-type-validation/pom.xml
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>module-type-validation</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.0</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
+          <forceJavacCompilerUse>true</forceJavacCompilerUse>
+        </configuration>
+        <dependencies>
+          <dependency>
+            <groupId>@dagger.groupId@</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>@dagger.version@</version>
+          </dependency>
+        </dependencies>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/module-type-validation/src/main/java/test/TestModule.java b/compiler/src/it/module-type-validation/src/main/java/test/TestModule.java
new file mode 100644
index 0000000..ed55208
--- /dev/null
+++ b/compiler/src/it/module-type-validation/src/main/java/test/TestModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+
+@Module
+class ThreadModule extends Thread {
+}
+
+@Module
+enum EnumModule {
+}
+
+@Module
+interface InterfaceModule {
+}
/Fim/
diff --git a/compiler/src/it/module-type-validation/verify.bsh b/compiler/src/it/module-type-validation/verify.bsh
new file mode 100644
index 0000000..ce3f6a7
--- /dev/null
+++ b/compiler/src/it/module-type-validation/verify.bsh
@@ -0,0 +1,10 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Modules must not extend from other classes: test.ThreadModule"});
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Modules must be classes: test.EnumModule"});
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Modules must be classes: test.InterfaceModule"});
\ No newline at end of file
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 77c52db..b490e0f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -45,6 +45,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
@@ -71,7 +72,6 @@
     return SourceVersion.latestSupported();
   }
 
-  // TODO: include @Provides methods from the superclass
   @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
     remainingTypes.putAll(providerMethodsByClass(env));
     for (Iterator<String> i = remainingTypes.keySet().iterator(); i.hasNext();) {
@@ -148,14 +148,27 @@
       methods.add(providerMethodAsExecutable);
     }
 
+    Elements elementUtils = processingEnv.getElementUtils();
+    TypeMirror objectType = elementUtils.getTypeElement("java.lang.Object").asType();
+
     // Catch any stray modules without @Provides since their entry points
     // should still be registered and a ModuleAdapter should still be written.
-    for (Element type : env.getElementsAnnotatedWith(Module.class)) {
-      if (type.getKind().equals(ElementKind.CLASS)) {
-        String moduleType = ((TypeElement) type).getQualifiedName().toString();
-        if (result.containsKey(moduleType)) continue;
-        result.put(moduleType, new ArrayList<ExecutableElement>());
+    for (Element module : env.getElementsAnnotatedWith(Module.class)) {
+      if (!module.getKind().equals(ElementKind.CLASS)) {
+        error("Modules must be classes: " + module, module);
+        continue;
       }
+
+      TypeElement moduleType = (TypeElement) module;
+
+      // Verify that all modules do not extend from non-Object types.
+      if (!moduleType.getSuperclass().equals(objectType)) {
+        error("Modules must not extend from other classes: " + module, module);
+      }
+
+      String moduleName = moduleType.getQualifiedName().toString();
+      if (result.containsKey(moduleName)) continue;
+      result.put(moduleName, new ArrayList<ExecutableElement>());
     }
     return result;
   }
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
index 99ead70..44cd87c 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
@@ -52,6 +52,10 @@
     if (annotation == null) {
       throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
     }
+    if (moduleClass.getSuperclass() != Object.class) {
+      throw new IllegalArgumentException(
+          "Modules must not extend from other classes: " + moduleClass.getName());
+    }
     return (ModuleAdapter<T>) new ReflectiveModuleAdapter(moduleClass, annotation);
   }
 
/Fim/
diff --git a/core/src/test/java/dagger/ModuleIncludesTest.java b/core/src/test/java/dagger/ModuleTest.java
similarity index 93%
rename from core/src/test/java/dagger/ModuleIncludesTest.java
rename to core/src/test/java/dagger/ModuleTest.java
index 09d5ab6..223c987 100644
--- a/core/src/test/java/dagger/ModuleIncludesTest.java
+++ b/core/src/test/java/dagger/ModuleTest.java
@@ -24,7 +24,7 @@
 import static org.junit.Assert.fail;
 
 @RunWith(JUnit4.class)
-public final class ModuleIncludesTest {
+public final class ModuleTest {
   static class TestEntryPoint {
     @Inject String s;
   }
@@ -181,4 +181,16 @@
   public void childModuleMissingModuleAnnotation() {
     ObjectGraph.create(new ChildModuleMissingModuleAnnotation());
   }
+
+  @Module
+  static class ThreadModule extends Thread {}
+
+  @Test public void moduleExtendingClassThrowsException() {
+    try {
+      ObjectGraph.create(new ThreadModule());
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e.getMessage()).startsWith("Modules must not extend from other classes: ");
+    }
+  }
 }
/Fim/
diff --git a/README.md b/README.md
index b1f0bcf..1c4c86f 100644
--- a/README.md
+++ b/README.md
@@ -16,7 +16,8 @@
 
 In a Maven project, one would include the runtime in the dependencies section
 of your `pom.xml` (replacing `${dagger.version}` with the appropriate current
-release), and the `dagger-compiler` artifact as an "optional" dependency:
+release), and the `dagger-compiler` artifact as an "optional" or "provided"
+dependency:
 
 ```xml
 <dependencies>
@@ -25,27 +26,13 @@
     <artifactId>dagger</artifactId>
     <version>${dagger.version}</version>
   </dependency>
+  <dependency>
+    <groupId>com.squareup</groupId>
+    <artifactId>dagger-compiler</artifactId>
+    <version>${dagger.version}</version>
+    <optional>true</optional>
+  </dependency>
 </dependencies>
-
-<build>
-  <plugins>
-    <plugin>
-      <artifactId>maven-compiler-plugin</artifactId>
-      <version>3.0</version>
-      <configuration>
-        <!-- Workaround for http://jira.codehaus.org/browse/MCOMPILER-202. -->
-        <forceJavacCompilerUse>true</forceJavacCompilerUse>
-      </configuration>
-      <dependencies>
-        <dependency>
-          <groupId>com.squareup</groupId>
-          <artifactId>dagger-compiler</artifactId>
-          <version>${dagger.version}</version>
-        </dependency>
-      </dependencies>
-    </plugin>
-  </plugins>
-</build>
 ```
 
 You can also find downloadable .jars on the [GitHub download page][2].
/Fim/
diff --git a/compiler/src/it/cyclic-deps/pom.xml b/compiler/src/it/cyclic-deps/pom.xml
index d95abc0..d213a7a 100644
--- a/compiler/src/it/cyclic-deps/pom.xml
+++ b/compiler/src/it/cyclic-deps/pom.xml
@@ -30,25 +30,18 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.0</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
-          <forceJavacCompilerUse>true</forceJavacCompilerUse>
-        </configuration>
-        <dependencies>
-          <dependency>
-            <groupId>@dagger.groupId@</groupId>
-            <artifactId>dagger-compiler</artifactId>
-            <version>@dagger.version@</version>
-          </dependency>
-        </dependencies>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/default-package-injected-type/pom.xml b/compiler/src/it/default-package-injected-type/pom.xml
index e340e06..ee7e557 100644
--- a/compiler/src/it/default-package-injected-type/pom.xml
+++ b/compiler/src/it/default-package-injected-type/pom.xml
@@ -30,25 +30,18 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.0</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
-          <forceJavacCompilerUse>true</forceJavacCompilerUse>
-        </configuration>
-        <dependencies>
-          <dependency>
-            <groupId>@dagger.groupId@</groupId>
-            <artifactId>dagger-compiler</artifactId>
-            <version>@dagger.version@</version>
-          </dependency>
-        </dependencies>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/extension-graph/pom.xml b/compiler/src/it/extension-graph/pom.xml
index be602c6..76bde1e 100644
--- a/compiler/src/it/extension-graph/pom.xml
+++ b/compiler/src/it/extension-graph/pom.xml
@@ -30,25 +30,18 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.0</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
-          <forceJavacCompilerUse>true</forceJavacCompilerUse>
-        </configuration>
-        <dependencies>
-          <dependency>
-            <groupId>@dagger.groupId@</groupId>
-            <artifactId>dagger-compiler</artifactId>
-            <version>@dagger.version@</version>
-          </dependency>
-        </dependencies>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/include-non-module/pom.xml b/compiler/src/it/include-non-module/pom.xml
index 08ec774..7d2993d 100644
--- a/compiler/src/it/include-non-module/pom.xml
+++ b/compiler/src/it/include-non-module/pom.xml
@@ -30,25 +30,18 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.0</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
-          <forceJavacCompilerUse>true</forceJavacCompilerUse>
-        </configuration>
-        <dependencies>
-          <dependency>
-            <groupId>@dagger.groupId@</groupId>
-            <artifactId>dagger-compiler</artifactId>
-            <version>@dagger.version@</version>
-          </dependency>
-        </dependencies>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/inject-parameterized-type/pom.xml b/compiler/src/it/inject-parameterized-type/pom.xml
index ad37203..7b6bc48 100644
--- a/compiler/src/it/inject-parameterized-type/pom.xml
+++ b/compiler/src/it/inject-parameterized-type/pom.xml
@@ -30,25 +30,18 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.0</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
-          <forceJavacCompilerUse>true</forceJavacCompilerUse>
-        </configuration>
-        <dependencies>
-          <dependency>
-            <groupId>@dagger.groupId@</groupId>
-            <artifactId>dagger-compiler</artifactId>
-            <version>@dagger.version@</version>
-          </dependency>
-        </dependencies>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/inner-classes-complaint-injection/pom.xml b/compiler/src/it/inner-classes-complaint-injection/pom.xml
index ecaf63e..ff2dd01 100644
--- a/compiler/src/it/inner-classes-complaint-injection/pom.xml
+++ b/compiler/src/it/inner-classes-complaint-injection/pom.xml
@@ -29,25 +29,18 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.0</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
-          <forceJavacCompilerUse>true</forceJavacCompilerUse>
-        </configuration>
-        <dependencies>
-          <dependency>
-            <groupId>@dagger.groupId@</groupId>
-            <artifactId>dagger-compiler</artifactId>
-            <version>@dagger.version@</version>
-          </dependency>
-        </dependencies>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/method-injection/pom.xml b/compiler/src/it/method-injection/pom.xml
index 20c3961..3981dee 100644
--- a/compiler/src/it/method-injection/pom.xml
+++ b/compiler/src/it/method-injection/pom.xml
@@ -28,25 +28,21 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.0</version>
         <configuration>
           <source>1.5</source>
           <target>1.5</target>
-          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
-          <forceJavacCompilerUse>true</forceJavacCompilerUse>
         </configuration>
-        <dependencies>
-          <dependency>
-            <groupId>@dagger.groupId@</groupId>
-            <artifactId>dagger-compiler</artifactId>
-            <version>@dagger.version@</version>
-          </dependency>
-        </dependencies>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/missing-at-inject-constructor/pom.xml b/compiler/src/it/missing-at-inject-constructor/pom.xml
index 063eb41..4d9e947 100644
--- a/compiler/src/it/missing-at-inject-constructor/pom.xml
+++ b/compiler/src/it/missing-at-inject-constructor/pom.xml
@@ -30,25 +30,18 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.0</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
-          <forceJavacCompilerUse>true</forceJavacCompilerUse>
-        </configuration>
-        <dependencies>
-          <dependency>
-            <groupId>@dagger.groupId@</groupId>
-            <artifactId>dagger-compiler</artifactId>
-            <version>@dagger.version@</version>
-          </dependency>
-        </dependencies>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/multiple-provides-methods/pom.xml b/compiler/src/it/multiple-provides-methods/pom.xml
index ac580be..45fcba0 100644
--- a/compiler/src/it/multiple-provides-methods/pom.xml
+++ b/compiler/src/it/multiple-provides-methods/pom.xml
@@ -30,25 +30,18 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.0</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
-          <forceJavacCompilerUse>true</forceJavacCompilerUse>
-        </configuration>
-        <dependencies>
-          <dependency>
-            <groupId>@dagger.groupId@</groupId>
-            <artifactId>dagger-compiler</artifactId>
-            <version>@dagger.version@</version>
-          </dependency>
-        </dependencies>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/private-inject/pom.xml b/compiler/src/it/private-inject/pom.xml
index c3c5dab..ecf04c5 100644
--- a/compiler/src/it/private-inject/pom.xml
+++ b/compiler/src/it/private-inject/pom.xml
@@ -28,25 +28,21 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.0</version>
         <configuration>
           <source>1.5</source>
           <target>1.5</target>
-          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
-          <forceJavacCompilerUse>true</forceJavacCompilerUse>
         </configuration>
-        <dependencies>
-          <dependency>
-            <groupId>@dagger.groupId@</groupId>
-            <artifactId>dagger-compiler</artifactId>
-            <version>@dagger.version@</version>
-          </dependency>
-        </dependencies>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/provides-method-with-throws-clause/pom.xml b/compiler/src/it/provides-method-with-throws-clause/pom.xml
index c969dc8..7063ecc 100644
--- a/compiler/src/it/provides-method-with-throws-clause/pom.xml
+++ b/compiler/src/it/provides-method-with-throws-clause/pom.xml
@@ -30,25 +30,18 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.0</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
-          <forceJavacCompilerUse>true</forceJavacCompilerUse>
-        </configuration>
-        <dependencies>
-          <dependency>
-            <groupId>@dagger.groupId@</groupId>
-            <artifactId>dagger-compiler</artifactId>
-            <version>@dagger.version@</version>
-          </dependency>
-        </dependencies>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/same-provides-method-name/pom.xml b/compiler/src/it/same-provides-method-name/pom.xml
index 28003fb..2c41239 100644
--- a/compiler/src/it/same-provides-method-name/pom.xml
+++ b/compiler/src/it/same-provides-method-name/pom.xml
@@ -30,25 +30,18 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.0</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
-          <forceJavacCompilerUse>true</forceJavacCompilerUse>
-        </configuration>
-        <dependencies>
-          <dependency>
-            <groupId>@dagger.groupId@</groupId>
-            <artifactId>dagger-compiler</artifactId>
-            <version>@dagger.version@</version>
-          </dependency>
-        </dependencies>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/simple-missing-dependency-failure/pom.xml b/compiler/src/it/simple-missing-dependency-failure/pom.xml
index 1299081..1ec794d 100644
--- a/compiler/src/it/simple-missing-dependency-failure/pom.xml
+++ b/compiler/src/it/simple-missing-dependency-failure/pom.xml
@@ -29,27 +29,20 @@
     <dependency>
       <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
     </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.0</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
-          <forceJavacCompilerUse>true</forceJavacCompilerUse>
-        </configuration>
-        <dependencies>
-          <dependency>
-            <groupId>@dagger.groupId@</groupId>
-            <artifactId>dagger-compiler</artifactId>
-            <version>@dagger.version@</version>
-          </dependency>
-        </dependencies>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/uninjectable-supertype/pom.xml b/compiler/src/it/uninjectable-supertype/pom.xml
index 2ca553c..451108d 100644
--- a/compiler/src/it/uninjectable-supertype/pom.xml
+++ b/compiler/src/it/uninjectable-supertype/pom.xml
@@ -30,25 +30,18 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.0</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
-          <forceJavacCompilerUse>true</forceJavacCompilerUse>
-        </configuration>
-        <dependencies>
-          <dependency>
-            <groupId>@dagger.groupId@</groupId>
-            <artifactId>dagger-compiler</artifactId>
-            <version>@dagger.version@</version>
-          </dependency>
-        </dependencies>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index b05e936..0a25a1a 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -32,6 +32,12 @@
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.dagger</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
@@ -41,16 +47,7 @@
           <compilerArgument>-Xlint:all</compilerArgument>
           <showWarnings>true</showWarnings>
           <showDeprecation>true</showDeprecation>
-          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
-          <forceJavacCompilerUse>true</forceJavacCompilerUse>
         </configuration>
-        <dependencies>
-          <dependency>
-            <groupId>com.squareup.dagger</groupId>
-            <artifactId>dagger-compiler</artifactId>
-            <version>${project.version}</version>
-          </dependency>
-        </dependencies>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/pom.xml b/pom.xml
index c97fc2d..ef91b87 100644
--- a/pom.xml
+++ b/pom.xml
@@ -122,7 +122,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.0</version>
+        <version>2.5</version>
         <configuration>
           <source>${java.version}</source>
           <target>${java.version}</target>
/Fim/
diff --git a/website/index.html b/website/index.html
index 605234d..c3de327 100644
--- a/website/index.html
+++ b/website/index.html
@@ -366,7 +366,7 @@
 
 <p>You will need to include the <code>dagger-${dagger.version}.jar</code> in your application's runtime.  In order to activate code generation you will need to include <code>dagger-compiler-${dagger.version}.jar</code> in your build at compile time.</p>
 
-<p>In a Maven project, one would include the runtime in the dependencies section of your <code>pom.xml</code> (replacing <code>${dagger.version}</code> with the appropriate current release), and the <code>dagger-compiler</code> artifact as a dependency of the compiler plugin:</p>
+<p>In a Maven project, one would include the runtime in the dependencies section of your <code>pom.xml</code> (replacing <code>${dagger.version}</code> with the appropriate current release), and the <code>dagger-compiler</code> artifact as an "optional" or "provided" dependency:</p>
 
 <pre class="prettyprint">
 &lt;dependencies>
@@ -375,26 +375,13 @@
     &lt;artifactId>dagger&lt;/artifactId>
     &lt;version>${dagger.version}&lt;/version>
   &lt;/dependency>
+  &lt;dependency>
+    &lt;groupId>com.squareup&lt;/groupId>
+    &lt;artifactId>dagger-compiler&lt;/artifactId>
+    &lt;version>${dagger.version}&lt;/version>
+    &lt;optional>true&lt;/optional>
+  &lt;/dependency>
 &lt;/dependencies>
-&lt;build>
-  &lt;plugins>
-    &lt;plugin>
-      &lt;artifactId>maven-compiler-plugin&lt;/artifactId>
-      &lt;version>3.0&lt;/version>
-      &lt;configuration>
-        &lt;!-- Workaround for http://jira.codehaus.org/browse/MCOMPILER-202. -->
-        &lt;forceJavacCompilerUse>true&lt;/forceJavacCompilerUse>
-      &lt;/configuration>
-      &lt;dependencies>
-        &lt;dependency>
-          &lt;groupId>com.squareup&lt;/groupId>
-          &lt;artifactId>dagger-compiler&lt;/artifactId>
-          &lt;version>${dagger.version}&lt;/version>
-        &lt;/dependency>
-      &lt;/dependencies>
-    &lt;/plugin>
-  &lt;/plugins>
-&lt;/build>
 </pre>
 
 
/Fim/
diff --git a/README.md b/README.md
index 1c4c86f..ebd652f 100644
--- a/README.md
+++ b/README.md
@@ -35,7 +35,9 @@
 </dependencies>
 ```
 
-You can also find downloadable .jars on the [GitHub download page][2].
+You can also find downloadable .jars on Maven Central. You'll need both
+[Dagger](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup%22%20dagger) and
+[JavaWriter](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22javawriter%22).
 
 
 
@@ -59,4 +61,3 @@
 
 
  [1]: http://square.github.com/dagger/
- [2]: http://github.com/square/dagger/downloads
/Fim/
diff --git a/compiler/src/it/cyclic-deps/src/main/java/test/TestApp.java b/compiler/src/it/cyclic-deps/src/main/java/test/TestApp.java
index 274d733..5003503 100644
--- a/compiler/src/it/cyclic-deps/src/main/java/test/TestApp.java
+++ b/compiler/src/it/cyclic-deps/src/main/java/test/TestApp.java
@@ -17,7 +17,6 @@
 package test;
 
 import dagger.Module;
-import dagger.ObjectGraph;
 import dagger.Provides;
 import javax.inject.Inject;
 
@@ -39,7 +38,7 @@
     @Inject Foo f;
   }
 
-  @Module(entryPoints = EntryPoint.class)
+  @Module(injects = EntryPoint.class)
   static class TestModule {
     
   }
@@ -48,7 +47,7 @@
   static class B { }
   static class C { }
   static class D { }
-  @Module(entryPoints = D.class)
+  @Module(injects = D.class)
   static class CyclicModule {
     @Provides A a(@SuppressWarnings("unused") D d) { return null; }
     @Provides B b(@SuppressWarnings("unused") A a) { return null; }
/Fim/
diff --git a/compiler/src/it/cyclic-deps/verify.bsh b/compiler/src/it/cyclic-deps/verify.bsh
index b014da1..b376044 100644
--- a/compiler/src/it/cyclic-deps/verify.bsh
+++ b/compiler/src/it/cyclic-deps/verify.bsh
@@ -3,7 +3,7 @@
 
 File buildLog = new File(basedir, "build.log");
 new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "TestApp.java:[43", "Graph validation", "Dependency cycle"});
+    "TestApp.java:[42", "Graph validation", "Dependency cycle"});
 new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "TestApp.java:[52", "Graph validation", "Dependency cycle"});
+    "TestApp.java:[51", "Graph validation", "Dependency cycle"});
     
\ No newline at end of file
/Fim/
diff --git a/compiler/src/it/default-package-injected-type/src/main/java/TestApp.java b/compiler/src/it/default-package-injected-type/src/main/java/TestApp.java
index 3600ffd..ec414b4 100644
--- a/compiler/src/it/default-package-injected-type/src/main/java/TestApp.java
+++ b/compiler/src/it/default-package-injected-type/src/main/java/TestApp.java
@@ -31,7 +31,7 @@
     ObjectGraph.create(new TestModule()).get(TestApp.class).run();
   }
   
-  @Module(entryPoints = { TestApp.class })
+  @Module(injects = { TestApp.class })
   static class TestModule {}
 
   @Singleton
/Fim/
diff --git a/compiler/src/it/extension-graph/src/main/java/test/TestApp.java b/compiler/src/it/extension-graph/src/main/java/test/TestApp.java
index b26e098..5850d6c 100644
--- a/compiler/src/it/extension-graph/src/main/java/test/TestApp.java
+++ b/compiler/src/it/extension-graph/src/main/java/test/TestApp.java
@@ -34,10 +34,10 @@
     extension.get(TestApp.class).run();
   }
   
-  @Module(entryPoints = { A.class, B.class })
+  @Module(injects = { A.class, B.class })
   static class RootModule { }
 
-  @Module(addsTo=RootModule.class, entryPoints = { C.class, TestApp.class })
+  @Module(addsTo=RootModule.class, injects = { C.class, TestApp.class })
   static class ExtensionModule { }
 
   @Singleton
/Fim/
diff --git a/compiler/src/it/include-non-module/src/main/java/test/TestApp.java b/compiler/src/it/include-non-module/src/main/java/test/TestApp.java
index 3b790a8..f658f42 100644
--- a/compiler/src/it/include-non-module/src/main/java/test/TestApp.java
+++ b/compiler/src/it/include-non-module/src/main/java/test/TestApp.java
@@ -29,7 +29,7 @@
   @Inject String s;
 
   @Module(
-      entryPoints = TestApp.class,
+      injects = TestApp.class,
       includes = TestApp.class)
   static class TestModule {
     @Provides String provideString() {
/Fim/
diff --git a/compiler/src/it/inject-parameterized-type/src/main/java/test/TestApp.java b/compiler/src/it/inject-parameterized-type/src/main/java/test/TestApp.java
index 08243f2..b22dd6f 100644
--- a/compiler/src/it/inject-parameterized-type/src/main/java/test/TestApp.java
+++ b/compiler/src/it/inject-parameterized-type/src/main/java/test/TestApp.java
@@ -32,7 +32,7 @@
   static class Subtype extends Supertype<Integer> {
   }
 
-  @Module(entryPoints = Subtype.class)
+  @Module(injects = Subtype.class)
   static class TestModule {
     @Provides String provideString() {
       return "a";
/Fim/
diff --git a/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java b/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
index 6cd5948..935218f 100644
--- a/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
+++ b/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
@@ -37,7 +37,7 @@
     public void doit() { throw AssertionError(); };
   }
   
-  @Module(entryPoints = TestApp.class)
+  @Module(injects = TestApp.class)
   static class TestModule {
     /* missing */ // @Provides Dependency a() { return new Dependency(); }
   }
/Fim/
diff --git a/compiler/src/it/multiple-provides-methods/src/main/java/test/TestApp.java b/compiler/src/it/multiple-provides-methods/src/main/java/test/TestApp.java
index d5f0771..31823d1 100644
--- a/compiler/src/it/multiple-provides-methods/src/main/java/test/TestApp.java
+++ b/compiler/src/it/multiple-provides-methods/src/main/java/test/TestApp.java
@@ -29,7 +29,7 @@
     @Inject Integer integer;
   }
 
-  @Module(entryPoints = InjectableSubclass.class)
+  @Module(injects = InjectableSubclass.class)
   static class TestModule {
     @Provides String string() {
       return "string";
/Fim/
diff --git a/compiler/src/it/provides-method-with-throws-clause/src/main/java/test/TestApp.java b/compiler/src/it/provides-method-with-throws-clause/src/main/java/test/TestApp.java
index 60b9762..5171862 100644
--- a/compiler/src/it/provides-method-with-throws-clause/src/main/java/test/TestApp.java
+++ b/compiler/src/it/provides-method-with-throws-clause/src/main/java/test/TestApp.java
@@ -37,7 +37,7 @@
     ObjectGraph.create(new TestModule()).get(TestApp.class).run();
   }
 
-  @Module(entryPoints = TestApp.class)
+  @Module(injects = TestApp.class)
   static class TestModule {
 
     @Provides String string() throws IOException {
/Fim/
diff --git a/compiler/src/it/same-provides-method-name/src/main/java/test/TestApp.java b/compiler/src/it/same-provides-method-name/src/main/java/test/TestApp.java
index 200b3d2..6af417c 100644
--- a/compiler/src/it/same-provides-method-name/src/main/java/test/TestApp.java
+++ b/compiler/src/it/same-provides-method-name/src/main/java/test/TestApp.java
@@ -42,7 +42,7 @@
   static class MyFoo extends Foo {
   }
 
-  @Module(entryPoints = TestApp.class)
+  @Module(injects = TestApp.class)
   static class TestModule {
 
     @Provides Foo providesFoo(MyFoo foo) {
/Fim/
diff --git a/compiler/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java b/compiler/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java
index 4723bcc..836f94c 100644
--- a/compiler/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java
+++ b/compiler/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java
@@ -36,7 +36,7 @@
     void doit();
   }
   
-  @Module(entryPoints = TestApp.class)
+  @Module(injects = TestApp.class)
   static class TestModule {
     /* missing */ // @Provides Dependency a() { return new Dependency(); }
   }
/Fim/
diff --git a/compiler/src/it/uninjectable-supertype/src/main/java/test/TestApp.java b/compiler/src/it/uninjectable-supertype/src/main/java/test/TestApp.java
index 71b29f0..fa6d4cb 100644
--- a/compiler/src/it/uninjectable-supertype/src/main/java/test/TestApp.java
+++ b/compiler/src/it/uninjectable-supertype/src/main/java/test/TestApp.java
@@ -27,7 +27,7 @@
     @Inject String string;
   }
 
-  @Module(entryPoints = InjectableSubclass.class)
+  @Module(injects = InjectableSubclass.class)
   static class TestModule {
     @Provides String provideString() {
       return "string";
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 5d220d8..fe1732f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -148,9 +148,9 @@
         boolean library = (Boolean) annotation.get("library");
         Map<String, Binding<?>> addTo = overrides ? overrideBindings : baseBindings;
 
-        // Gather the entry points from the annotation.
-        for (Object entryPoint : (Object[]) annotation.get("entryPoints")) {
-          linker.requestBinding(GeneratorKeys.rawMembersKey((TypeMirror) entryPoint),
+        // Gather the injectable types from the annotation.
+        for (Object injectableType : (Object[]) annotation.get("injects")) {
+          linker.requestBinding(GeneratorKeys.rawMembersKey((TypeMirror) injectableType),
               module.getQualifiedName().toString(), false, true);
         }
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index be46839..1b969d6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -174,7 +174,7 @@
 
     TypeMirror objectType = elementUtils.getTypeElement("java.lang.Object").asType();
 
-    // Catch any stray modules without @Provides since their entry points
+    // Catch any stray modules without @Provides since their injectable types
     // should still be registered and a ModuleAdapter should still be written.
     for (Element module : env.getElementsAnnotatedWith(Module.class)) {
       if (!module.getKind().equals(ElementKind.CLASS)) {
@@ -214,7 +214,7 @@
     }
 
     Object[] staticInjections = (Object[]) module.get("staticInjections");
-    Object[] entryPoints = (Object[]) module.get("entryPoints");
+    Object[] injects = (Object[]) module.get("injects");
     Object[] includes = (Object[]) module.get("includes");
 
     boolean overrides = (Boolean) module.get("overrides");
@@ -241,15 +241,15 @@
     writer.beginType(adapterName, "class", PUBLIC | FINAL,
         JavaWriter.type(ModuleAdapter.class, typeName));
 
-    StringBuilder entryPointsField = new StringBuilder().append("{ ");
-    for (Object entryPoint : entryPoints) {
-      TypeMirror typeMirror = (TypeMirror) entryPoint;
+    StringBuilder injectsField = new StringBuilder().append("{ ");
+    for (Object injectableType : injects) {
+      TypeMirror typeMirror = (TypeMirror) injectableType;
       String key = GeneratorKeys.rawMembersKey(typeMirror);
-      entryPointsField.append(JavaWriter.stringLiteral(key)).append(", ");
+      injectsField.append(JavaWriter.stringLiteral(key)).append(", ");
     }
-    entryPointsField.append("}");
-    writer.emitField("String[]", "ENTRY_POINTS", PRIVATE | STATIC | FINAL,
-        entryPointsField.toString());
+    injectsField.append("}");
+    writer.emitField("String[]", "INJECTS", PRIVATE | STATIC | FINAL,
+        injectsField.toString());
 
     StringBuilder staticInjectionsField = new StringBuilder().append("{ ");
     for (Object staticInjection : staticInjections) {
@@ -276,7 +276,7 @@
 
     writer.emitEmptyLine();
     writer.beginMethod(null, adapterName, PUBLIC);
-    writer.emitStatement("super(ENTRY_POINTS, STATIC_INJECTIONS, %s /*overrides*/, "
+    writer.emitStatement("super(INJECTS, STATIC_INJECTIONS, %s /*overrides*/, "
         + "INCLUDES, %s /*complete*/, %s /*library*/)", overrides, complete, library);
     writer.endMethod();
 
/Fim/
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
index 8a5b34a..1e28f4f 100644
--- a/core/src/main/java/dagger/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -26,7 +26,29 @@
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.TYPE)
 public @interface Module {
-  Class<?>[] entryPoints() default { };
+  /**
+   * Returns classes that object graphs created with this module must be able to
+   * inject. This includes both classes passed to {@link ObjectGraph#get} and
+   * the types of instances passed {@link ObjectGraph#inject}.
+   *
+   * <p>It is an error to call {@link ObjectGraph#get} or {@link
+   * ObjectGraph#inject} with a type that isn't listed in the {@code injects}
+   * set for any of the object graph's modules. Making such a call will trigger
+   * an {@code IllegalArgumentException} at runtime.
+   *
+   * <p>Maintaining this set is onerous, but doing so provides benefits to the
+   * application. This set enables dagger to perform more aggressive static
+   * analysis than would be otherwise possible:
+   * <ul>
+   *   <li><strong>Detect missing bindings.</strong> Dagger can check that all
+   *       injected dependencies can be satisfied. Set {@code complete=false} to
+   *       disable this check for the current module.
+   *   <li><strong>Detect unused bindings.</strong> Dagger can check that all
+   *       provides methods are used to satisfy injected dependencies. Set
+   *       {@code library=true} to disable this check for the current module.
+   * </ul>
+   */
+  Class<?>[] injects() default { };
   Class<?>[] staticInjections() default { };
 
   /**
@@ -62,12 +84,12 @@
 
   /**
    * False if all the included bindings in this module are necessary to satisfy
-   * all of its entry points. If a module is not a library module, it is eligible
-   * for additional static checking: tools can detect if included bindings are not
-   * necessary. If you provide bindings that are not used by this module's graph,
-   * then you must declare {@code library = true}.
-   * <p>
-   * This is intended to help you detect dead code.
+   * all of its {@link #injects injectable types}. If a module is not a library
+   * module, it is eligible for additional static checking: tools can detect if
+   * included bindings are not necessary. If you provide bindings that are not
+   * used by this module's graph, then you must declare {@code library = true}.
+   *
+   * <p>This is intended to help you detect dead code.
    */
   boolean library() default false;
 }
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 7769327..09c2883 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -66,7 +66,7 @@
    * Returns an instance of {@code type}.
    *
    * @throws IllegalArgumentException if {@code type} is not one of this object
-   *     graph's entry point types.
+   *     graph's {@link Module#injects injectable types}.
    */
   public abstract <T> T get(Class<T> type);
 
@@ -75,7 +75,7 @@
    * inherited from its supertypes.
    *
    * @throws IllegalArgumentException if the runtime type of {@code instance} is
-   *     not one of this object graph's entry point types.
+   *     not one of this object graph's {@link Module#injects injectable types}.
    */
   public abstract <T> T inject(T instance);
 
@@ -132,28 +132,28 @@
     private final DaggerObjectGraph base;
     private final Linker linker;
     private final Map<Class<?>, StaticInjection> staticInjections;
-    private final Map<String, Class<?>> entryPoints;
+    private final Map<String, Class<?>> injectableTypes;
     private final Plugin plugin;
 
     DaggerObjectGraph(DaggerObjectGraph base,
         Linker linker,
         Plugin plugin,
         Map<Class<?>, StaticInjection> staticInjections,
-        Map<String, Class<?>> entryPoints) {
+        Map<String, Class<?>> injectableTypes) {
       if (linker == null) throw new NullPointerException("linker");
       if (plugin == null) throw new NullPointerException("plugin");
       if (staticInjections == null) throw new NullPointerException("staticInjections");
-      if (entryPoints == null) throw new NullPointerException("entryPoints");
+      if (injectableTypes == null) throw new NullPointerException("injectableTypes");
 
       this.base = base;
       this.linker = linker;
       this.plugin = plugin;
       this.staticInjections = staticInjections;
-      this.entryPoints = entryPoints;
+      this.injectableTypes = injectableTypes;
     }
 
     private static ObjectGraph makeGraph(DaggerObjectGraph base, Plugin plugin, Object... modules) {
-      Map<String, Class<?>> entryPoints = new LinkedHashMap<String, Class<?>>();
+      Map<String, Class<?>> injectableTypes = new LinkedHashMap<String, Class<?>>();
       Map<Class<?>, StaticInjection> staticInjections
           = new LinkedHashMap<Class<?>, StaticInjection>();
 
@@ -162,8 +162,8 @@
       Map<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>();
       Map<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>();
       for (ModuleAdapter<?> moduleAdapter : getAllModuleAdapters(plugin, modules).values()) {
-        for (String key : moduleAdapter.entryPoints) {
-          entryPoints.put(key, moduleAdapter.getModule().getClass());
+        for (String key : moduleAdapter.injectableTypes) {
+          injectableTypes.put(key, moduleAdapter.getModule().getClass());
         }
         for (Class<?> c : moduleAdapter.staticInjections) {
           staticInjections.put(c, null);
@@ -178,7 +178,7 @@
       linker.installBindings(baseBindings);
       linker.installBindings(overrideBindings);
 
-      return new DaggerObjectGraph(base, linker, plugin, staticInjections, entryPoints);
+      return new DaggerObjectGraph(base, linker, plugin, staticInjections, injectableTypes);
     }
 
 
@@ -198,8 +198,8 @@
       }
     }
 
-    private void linkEntryPoints() {
-      for (Map.Entry<String, Class<?>> entry : entryPoints.entrySet()) {
+    private void linkInjectableTypes() {
+      for (Map.Entry<String, Class<?>> entry : injectableTypes.entrySet()) {
         linker.requestBinding(entry.getKey(), entry.getValue(), false, true);
       }
     }
@@ -210,12 +210,12 @@
     }
 
     /**
-     * Links all bindings, entry points and static injections.
+     * Links all bindings, injectable types and static injections.
      */
     private Map<String, Binding<?>> linkEverything() {
       synchronized (linker) {
         linkStaticInjections();
-        linkEntryPoints();
+        linkInjectableTypes();
         return linker.linkAll();
       }
     }
@@ -239,36 +239,36 @@
 
     @Override public <T> T get(Class<T> type) {
       String key = Keys.get(type);
-      String entryPointKey = Keys.getMembersKey(type);
+      String injectableTypeKey = Keys.getMembersKey(type);
       @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
-      Binding<T> binding = (Binding<T>) getEntryPointBinding(entryPointKey, key);
+      Binding<T> binding = (Binding<T>) getInjectableTypeBinding(injectableTypeKey, key);
       return binding.get();
     }
 
     @Override public <T> T inject(T instance) {
       String membersKey = Keys.getMembersKey(instance.getClass());
       @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
-      Binding<Object> binding = (Binding<Object>) getEntryPointBinding(membersKey, membersKey);
+      Binding<Object> binding = (Binding<Object>) getInjectableTypeBinding(membersKey, membersKey);
       binding.injectMembers(instance);
       return instance;
     }
 
     /**
-     * @param entryPointKey the key used to store the entry point. This is always
-     *     a members injection key because those keys can always be created, even
-     *     if the type has no injectable constructor.
+     * @param injectableTypeKey the key used to store the injectable type. This
+     *     is always a members injection key because those keys can always be
+     *     created, even if the type has no injectable constructor.
      * @param key the key to use when retrieving the binding. This may be a
      *     regular (provider) key or a members key.
      */
-    private Binding<?> getEntryPointBinding(String entryPointKey, String key) {
+    private Binding<?> getInjectableTypeBinding(String injectableTypeKey, String key) {
       Class<?> moduleClass = null;
       for (DaggerObjectGraph graph = this; graph != null; graph = graph.base) {
-        moduleClass = graph.entryPoints.get(entryPointKey);
+        moduleClass = graph.injectableTypes.get(injectableTypeKey);
         if (moduleClass != null) break;
       }
       if (moduleClass == null) {
-        throw new IllegalArgumentException("No entry point for " + entryPointKey
-            + ". You must explicitly add an entry point to one of your modules.");
+        throw new IllegalArgumentException("No inject registered for " + injectableTypeKey
+            + ". You must explicitly add it to the 'injects' option in one of your modules.");
       }
 
       synchronized (linker) {
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 7574892..880a71c 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -204,9 +204,9 @@
    * enqueued to be linked.
    *
    * @param mustBeInjectable true if the the referenced key doesn't need to be
-   *     injectable. This is necessary for entry points (so that framework code
-   *     can inject arbitrary entry points like JUnit test cases or Android
-   *     activities) and for supertypes.
+   *     injectable. This is necessary for injectable types (so that framework
+   *     code can inject arbitrary classes like JUnit test cases or Android
+   *     activities) and also for supertypes.
    */
   public Binding<?> requestBinding(String key, Object requiredBy, boolean mustBeInjectable,
       boolean library) {
/Fim/
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index 92310cc..ab255ce 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -23,7 +23,7 @@
  * Extracts bindings from an {@code @Module}-annotated class.
  */
 public abstract class ModuleAdapter<T> {
-  public final String[] entryPoints;
+  public final String[] injectableTypes;
   public final Class<?>[] staticInjections;
   public final boolean overrides;
   public final Class<?>[] includes;
@@ -31,9 +31,9 @@
   public final boolean library;
   protected T module;
 
-  protected ModuleAdapter(String[] entryPoints, Class<?>[] staticInjections, boolean overrides,
+  protected ModuleAdapter(String[] injectableTypes, Class<?>[] staticInjections, boolean overrides,
       Class<?>[] includes, boolean complete, boolean library) {
-    this.entryPoints = entryPoints;
+    this.injectableTypes = injectableTypes;
     this.staticInjections = staticInjections;
     this.overrides = overrides;
     this.includes = includes;
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
index 6d00ca0..805a710 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
@@ -39,7 +39,7 @@
 
   public ReflectiveModuleAdapter(Class<?> moduleClass, Module annotation) {
     super(
-        toMemberKeys(annotation.entryPoints()),
+        toMemberKeys(annotation.injects()),
         annotation.staticInjections(),
         annotation.overrides(),
         annotation.includes(),
@@ -48,10 +48,10 @@
     this.moduleClass = moduleClass;
   }
 
-  private static String[] toMemberKeys(Class<?>[] entryPoints) {
-    String[] result = new String[entryPoints.length];
-    for (int i = 0; i < entryPoints.length; i++) {
-      result[i] = Keys.getMembersKey(entryPoints[i]);
+  private static String[] toMemberKeys(Class<?>[] injectableTypes) {
+    String[] result = new String[injectableTypes.length];
+    for (int i = 0; i < injectableTypes.length; i++) {
+      result[i] = Keys.getMembersKey(injectableTypes[i]);
     }
     return result;
   }
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionTest.java b/core/src/test/java/dagger/ExtensionTest.java
index b9bd652..f688f2d 100644
--- a/core/src/test/java/dagger/ExtensionTest.java
+++ b/core/src/test/java/dagger/ExtensionTest.java
@@ -49,9 +49,9 @@
     @Inject C c;
   }
 
-  @Module(entryPoints = { A.class, B.class }) static class RootModule { }
+  @Module(injects = { A.class, B.class }) static class RootModule { }
 
-  @Module(addsTo = RootModule.class, entryPoints = { C.class, D.class })
+  @Module(addsTo = RootModule.class, injects = { C.class, D.class })
   static class ExtensionModule { }
 
   @Test public void basicExtension() {
@@ -63,8 +63,8 @@
     assertThat(root.get(A.class)).isNotNull();
     assertThat(root.get(A.class)).isSameAs(root.get(A.class)); // Present and Singleton.
     assertThat(root.get(B.class)).isNotSameAs(root.get(B.class)); // Not singleton.
-    assertFailNoEntryPoint(root, C.class); // Not declared in RootModule.
-    assertFailNoEntryPoint(root, D.class); // Not declared in RootModule.
+    assertFailInjectNotRegistered(root, C.class); // Not declared in RootModule.
+    assertFailInjectNotRegistered(root, D.class); // Not declared in RootModule.
 
     // Extension graph behaves as the root graph would for root-ish things.
     ObjectGraph extension = root.plus(new ExtensionModule());
@@ -81,8 +81,8 @@
     assertThat(app.get(A.class)).isNotNull();
     assertThat(app.get(A.class)).isSameAs(app.get(A.class));
     assertThat(app.get(B.class)).isNotSameAs(app.get(B.class));
-    assertFailNoEntryPoint(app, C.class);
-    assertFailNoEntryPoint(app, D.class);
+    assertFailInjectNotRegistered(app, C.class);
+    assertFailInjectNotRegistered(app, D.class);
 
     ObjectGraph request1 = app.plus(new ExtensionModule());
     ObjectGraph request2 = app.plus(new ExtensionModule());
@@ -101,11 +101,11 @@
     assertThat(request1.get(C.class).a).isSameAs(request2.get(C.class).a);
   }
 
-  private void assertFailNoEntryPoint(ObjectGraph graph, Class<?> clazz) {
+  private void assertFailInjectNotRegistered(ObjectGraph graph, Class<?> clazz) {
     try {
       assertThat(graph.get(clazz)).isNull();
     } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).contains("No entry point");
+      assertThat(e.getMessage()).contains("No inject");
     }
   }
 }
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionWithStateTest.java b/core/src/test/java/dagger/ExtensionWithStateTest.java
index af485b3..da2f7ac 100644
--- a/core/src/test/java/dagger/ExtensionWithStateTest.java
+++ b/core/src/test/java/dagger/ExtensionWithStateTest.java
@@ -32,7 +32,7 @@
   }
 
   @Module(
-      entryPoints = A.class, // for testing
+      injects = A.class, // for testing
       complete = false
   )
   static class RootModule {
@@ -43,7 +43,7 @@
     @Provides A provideA() { return a; }
   }
 
-  @Module(addsTo = RootModule.class, entryPoints = { B.class })
+  @Module(addsTo = RootModule.class, injects = { B.class })
   static class ExtensionModule { }
 
   @Test public void basicInjectionWithExtension() {
/Fim/
diff --git a/core/src/test/java/dagger/InjectStaticsTest.java b/core/src/test/java/dagger/InjectStaticsTest.java
index 47ad0f9..0421b1e 100644
--- a/core/src/test/java/dagger/InjectStaticsTest.java
+++ b/core/src/test/java/dagger/InjectStaticsTest.java
@@ -56,7 +56,7 @@
   @Test public void instanceFieldsNotInjectedByInjectStatics() {
     @Module(
         staticInjections = InjectsStaticAndNonStatic.class,
-        entryPoints = InjectsStaticAndNonStatic.class)
+        injects = InjectsStaticAndNonStatic.class)
     class TestModule {
       @Provides String provideString() {
         return "static";
@@ -75,7 +75,7 @@
   @Test public void staticFieldsNotInjectedByInjectMembers() {
     @Module(
         staticInjections = InjectsStaticAndNonStatic.class,
-        entryPoints = InjectsStaticAndNonStatic.class)
+        injects = InjectsStaticAndNonStatic.class)
     class TestModule {
       @Provides String provideString() {
         throw new AssertionError();
/Fim/
diff --git a/core/src/test/java/dagger/InjectionOfLazyTest.java b/core/src/test/java/dagger/InjectionOfLazyTest.java
index 84e208b..1133f3b 100644
--- a/core/src/test/java/dagger/InjectionOfLazyTest.java
+++ b/core/src/test/java/dagger/InjectionOfLazyTest.java
@@ -38,7 +38,7 @@
       @Inject Lazy<Integer> j;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides Integer provideInteger() {
         return counter.incrementAndGet();
@@ -59,7 +59,7 @@
     class TestEntryPoint {
       @Inject Lazy<String> i;
     }
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides String provideInteger() {
         provideCounter.incrementAndGet();
@@ -81,7 +81,7 @@
       @Inject Provider<Lazy<Integer>> providerOfLazyInteger;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides Integer provideInteger() {
         return counter.incrementAndGet();
@@ -107,7 +107,7 @@
       @Inject Lazy<Integer> lazyInteger;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides Integer provideInteger() {
         return counter.incrementAndGet();
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index 3538444..bbb671e 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -41,7 +41,7 @@
       @Inject Provider<G> gProvider;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides E provideE(F f) {
         return new E(f);
@@ -106,7 +106,7 @@
       @Inject Provider<A> aProvider;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
     }
 
@@ -125,7 +125,7 @@
       @Inject Provider<I> iProvider;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides @Singleton F provideF() {
         return new F();
@@ -153,7 +153,7 @@
       @Inject @Named("two") A aTwo;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides @Named("one") A getOne() {
         return one;
@@ -175,7 +175,7 @@
       @Inject Provider<L> lProvider;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       A a1;
       A a2;
@@ -212,7 +212,7 @@
       @Inject F f2;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides @Singleton F provideF() {
         return new F();
@@ -242,7 +242,7 @@
       @Inject @Named("a") A a;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
     }
 
@@ -259,7 +259,7 @@
       @Inject Q q;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides F provideF() {
         return new F();
@@ -276,7 +276,7 @@
       @Inject T t;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
     }
 
@@ -305,7 +305,7 @@
       @Inject Provider<A> aProvider;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       boolean sInjected = false;
 
@@ -377,7 +377,7 @@
       @Inject Provider<A> aProvider;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides @Singleton A provideA() {
         return new A();
@@ -394,7 +394,7 @@
       @Inject Provider<E> eProvider;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class BaseModule {
       @Provides F provideF() {
         throw new AssertionError();
@@ -423,7 +423,7 @@
       @Inject RandomAccess randomAccess;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
     }
 
@@ -440,7 +440,7 @@
       @Inject AbstractList<?> abstractList;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
     }
 
@@ -471,7 +471,7 @@
       @Inject ExtendsParameterizedType extendsParameterizedType;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides String provideString() {
         return "injected";
@@ -488,7 +488,7 @@
       @Inject List<String> listOfStrings;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides List<String> provideList() {
         return Arrays.asList("a", "b");
@@ -505,7 +505,7 @@
       @Inject List<? extends Number> listOfNumbers;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides List<? extends Number> provideList() {
         return Arrays.asList(1, 2);
@@ -529,7 +529,7 @@
       @Inject Parameterized<Long> parameterized;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides String provideString() {
         return "injected";
@@ -555,7 +555,7 @@
   @Test public void getInstance() {
     final AtomicInteger next = new AtomicInteger(0);
 
-    @Module(entryPoints = Integer.class)
+    @Module(injects = Integer.class)
     class TestModule {
       @Provides Integer provideInteger() {
         return next.getAndIncrement();
@@ -584,7 +584,7 @@
   }
 
   @Test public void getInstanceOfPrimitive() {
-    @Module(entryPoints = int.class)
+    @Module(injects = int.class)
     class TestModule {
       @Provides int provideInt() {
         return 1;
@@ -596,7 +596,7 @@
   }
 
   @Test public void getInstanceOfArray() {
-    @Module(entryPoints = int[].class)
+    @Module(injects = int[].class)
     class TestModule {
       @Provides int[] provideIntArray() {
         return new int[] { 1, 2, 3 };
@@ -612,7 +612,7 @@
       @Inject String s;
     }
 
-    @Module(entryPoints = BoundTwoWays.class)
+    @Module(injects = BoundTwoWays.class)
     class TestModule {
       @Provides
       BoundTwoWays provideBoundTwoWays() {
@@ -641,7 +641,7 @@
   }
 
   @Test public void entryPointNeedsNoInjectAnnotation() {
-    @Module(entryPoints = NoInjections.class)
+    @Module(injects = NoInjections.class)
     class TestModule {
     }
 
@@ -655,7 +655,7 @@
   }
 
   @Test public void cannotGetOnMembersOnlyInjectionPoint() {
-    @Module(entryPoints = InjectMembersOnly.class)
+    @Module(injects = InjectMembersOnly.class)
     class TestModule {
       @Provides String provideString() {
         return "injected";
@@ -698,7 +698,7 @@
   }
 
   @Test public void twoAtInjectConstructorsIsRejected() {
-    @Module(entryPoints = TwoAtInjectConstructors.class)
+    @Module(injects = TwoAtInjectConstructors.class)
     class TestModule {
       @Provides String provideString() {
         throw new AssertionError();
@@ -718,7 +718,7 @@
       @Inject String string;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides String provideString() {
         throw new ClassCastException("foo");
@@ -740,7 +740,7 @@
   }
 
   @Test public void runtimeConstructorExceptionsAreNotWrapped() {
-    @Module(entryPoints = ThrowsOnConstruction.class)
+    @Module(injects = ThrowsOnConstruction.class)
     class TestModule {
     }
 
@@ -756,10 +756,10 @@
     @Inject C c; // Singleton.
   }
 
-  @Module(complete=false, entryPoints=C.class)
+  @Module(complete=false, injects =C.class)
   static class RootModule { }
 
-  @Module(addsTo=RootModule.class, entryPoints=SingletonLinkedFromExtension.class)
+  @Module(addsTo=RootModule.class, injects =SingletonLinkedFromExtension.class)
   static class ExtensionModule { }
 
   @Test public void testSingletonLinkingThroughExtensionGraph() {
@@ -774,7 +774,7 @@
       @Inject private Object nope;
     }
 
-    @Module(entryPoints = Test.class)
+    @Module(injects = Test.class)
     class TestModule {
       @Provides Object provideObject() {
         return null;
@@ -795,7 +795,7 @@
       }
     }
 
-    @Module(entryPoints = Test.class)
+    @Module(injects = Test.class)
     class TestModule {
     }
 
/Fim/
diff --git a/core/src/test/java/dagger/LazyInjectionTest.java b/core/src/test/java/dagger/LazyInjectionTest.java
index e80995d..522a344 100644
--- a/core/src/test/java/dagger/LazyInjectionTest.java
+++ b/core/src/test/java/dagger/LazyInjectionTest.java
@@ -24,8 +24,8 @@
 
 @RunWith(JUnit4.class)
 public final class LazyInjectionTest {
-  @Test public void getLazyDoesNotCauseEntryPointsToBeLoaded() {
-    @Module(entryPoints = LazyEntryPoint.class)
+  @Test public void getLazyDoesNotCauseInjectedTypesToBeLoaded() {
+    @Module(injects = LazyEntryPoint.class)
     class TestModule {
     }
 
@@ -99,7 +99,7 @@
       @Inject String injected;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides String provideString(Integer integer) {
         return integer.toString();
/Fim/
diff --git a/core/src/test/java/dagger/MembersInjectorTest.java b/core/src/test/java/dagger/MembersInjectorTest.java
index 1707f17..75408eb 100644
--- a/core/src/test/java/dagger/MembersInjectorTest.java
+++ b/core/src/test/java/dagger/MembersInjectorTest.java
@@ -36,7 +36,7 @@
       @Inject MembersInjector<Injectable> membersInjector;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class StringModule {
       @Provides String provideString() {
         return "injected";
@@ -67,7 +67,7 @@
       @Inject MembersInjector<Unconstructable> membersInjector;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class StringModule {
       @Provides String provideString() {
         return "injected";
@@ -88,7 +88,7 @@
       @Inject Unconstructable unconstructable;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
     }
 
@@ -105,7 +105,7 @@
       @Inject Provider<Unconstructable> provider;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
     }
 
@@ -122,7 +122,7 @@
       @Inject MembersInjector<UnconstructableSingleton> membersInjector;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
     }
 
@@ -152,7 +152,7 @@
       @Inject MembersInjector<NonStaticInner> membersInjector;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides String provideString() {
         return "injected";
@@ -171,7 +171,7 @@
       @Inject NonStaticInner nonStaticInner;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
     }
 
@@ -193,7 +193,7 @@
       @Inject MembersInjector<InjectsString> membersInjector;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides InjectsString provideInjectsString() {
         InjectsString result = new InjectsString();
/Fim/
diff --git a/core/src/test/java/dagger/ModuleTest.java b/core/src/test/java/dagger/ModuleTest.java
index 3d07fbe..571d1b2 100644
--- a/core/src/test/java/dagger/ModuleTest.java
+++ b/core/src/test/java/dagger/ModuleTest.java
@@ -30,7 +30,7 @@
     @Inject String s;
   }
 
-  @Module(entryPoints = TestEntryPoint.class)
+  @Module(injects = TestEntryPoint.class)
   static class ModuleWithEntryPoint {
   }
 
@@ -79,7 +79,7 @@
   @Test public void childModuleWithBinding() {
 
     @Module(
-        entryPoints = TestEntryPoint.class,
+        injects = TestEntryPoint.class,
         includes = ModuleWithBinding.class
     )
     class TestModule {
@@ -98,7 +98,7 @@
   @Test public void childModuleWithChildModule() {
 
     @Module(
-        entryPoints = TestEntryPoint.class,
+        injects = TestEntryPoint.class,
         includes = ModuleWithChildModule.class
     )
     class TestModule {
@@ -138,7 +138,7 @@
   @Test public void childModuleWithManualConstruction() {
 
     @Module(
-        entryPoints = TestEntryPoint.class,
+        injects = TestEntryPoint.class,
         includes = ModuleWithConstructor.class
     )
     class TestModule {
@@ -154,11 +154,11 @@
 
   static class B { @Inject A a; }
 
-  @Module(entryPoints = A.class) public static class TestModuleA {
+  @Module(injects = A.class) public static class TestModuleA {
     @Provides A a() { return new A(); }
   }
 
-  @Module(includes = TestModuleA.class, entryPoints = B.class) public static class TestModuleB {}
+  @Module(includes = TestModuleA.class, injects = B.class) public static class TestModuleB {}
 
   @Test public void autoInstantiationOfModules() {
     // Have to make these non-method-scoped or instantiation errors occur.
/Fim/
diff --git a/core/src/test/java/dagger/ProblemDetectorTest.java b/core/src/test/java/dagger/ProblemDetectorTest.java
index d601edd..83b1124 100644
--- a/core/src/test/java/dagger/ProblemDetectorTest.java
+++ b/core/src/test/java/dagger/ProblemDetectorTest.java
@@ -29,7 +29,7 @@
       @Inject Rock rock;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
     }
 
/Fim/
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index e837f42..7be7a9e 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -43,7 +43,7 @@
       @Inject Set<String> strings;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides(type=SET) String provideFirstString() { return "string1"; }
       @Provides(type=SET) String provideSecondString() { return "string2"; }
@@ -63,7 +63,7 @@
       @Provides(type=SET) String provideSecondString() { return "string2"; }
     }
 
-    @Module(entryPoints = TestEntryPoint.class, includes = TestIncludesModule.class)
+    @Module(injects = TestEntryPoint.class, includes = TestIncludesModule.class)
     class TestModule {
       @Provides(type=SET) String provideFirstString() { return "string1"; }
     }
@@ -81,7 +81,7 @@
       @Inject Set<Integer> objects2;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides(type=SET) @Singleton Integer a() { return singletonCounter.getAndIncrement(); }
       @Provides(type=SET) Integer b() { return defaultCounter.getAndIncrement(); }
@@ -92,7 +92,7 @@
     assertEquals(set(100, 201), ep.objects2);
   }
 
-  @Test public void multiValueBindings_WithSingletonsAcrossMultipleEntryPoints() {
+  @Test public void multiValueBindings_WithSingletonsAcrossMultipleInjectableTypes() {
     final AtomicInteger singletonCounter = new AtomicInteger(100);
     final AtomicInteger defaultCounter = new AtomicInteger(200);
     class TestEntryPoint1 {
@@ -102,7 +102,7 @@
       @Inject Set<Integer> objects2;
     }
 
-    @Module(entryPoints = { TestEntryPoint1.class, TestEntryPoint2.class })
+    @Module(injects = { TestEntryPoint1.class, TestEntryPoint2.class })
     class TestModule {
       @Provides(type=SET) @Singleton Integer a() { return singletonCounter.getAndIncrement(); }
       @Provides(type=SET) Integer b() { return defaultCounter.getAndIncrement(); }
@@ -122,7 +122,7 @@
       @Inject @Named("foo") Set<String> fooStrings;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides(type=SET) String provideString1() { return "string1"; }
       @Provides(type=SET) String provideString2() { return "string2"; }
@@ -158,7 +158,7 @@
         };
       }
     }
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides(type=SET) LogSink nullLogger() {
         return new LogSink() { @Override public void log(LogMessage message) {} };
@@ -178,7 +178,7 @@
       @Inject Set<String> strings;
     }
 
-    @Module(entryPoints = TestEntryPoint.class)
+    @Module(injects = TestEntryPoint.class)
     class TestModule {
       @Provides(type=SET) String provideString1() { return "string1"; }
       @Provides(type=SET) String provideString2() { return "string2"; }
/Fim/
diff --git a/core/src/test/java/dagger/ThreadSafetyTest.java b/core/src/test/java/dagger/ThreadSafetyTest.java
index c30a580..2622d12 100644
--- a/core/src/test/java/dagger/ThreadSafetyTest.java
+++ b/core/src/test/java/dagger/ThreadSafetyTest.java
@@ -49,7 +49,7 @@
     @Inject Lazy<Integer> lazy;
   }
 
-  @Module(entryPoints = { Long.class, LazyEntryPoint.class })
+  @Module(injects = { Long.class, LazyEntryPoint.class })
   static class LatchingModule {
     private final AtomicInteger count = new AtomicInteger(FIRST_VALUE);
     private final CountDownLatch latch;
/Fim/
diff --git a/core/src/test/java/dagger/UnusedProviderTest.java b/core/src/test/java/dagger/UnusedProviderTest.java
index 37f12cb..c6cc975 100644
--- a/core/src/test/java/dagger/UnusedProviderTest.java
+++ b/core/src/test/java/dagger/UnusedProviderTest.java
@@ -26,7 +26,7 @@
     }
     class BagOfMoney {
     }
-    @Module(entryPoints = EntryPoint.class, library = true) class TestModule {
+    @Module(injects = EntryPoint.class, library = true) class TestModule {
       @Provides BagOfMoney providesMoney() {
         return new BagOfMoney();
       }
@@ -42,7 +42,7 @@
     class BagOfMoney {
     }
 
-    @Module(entryPoints = EntryPoint.class) class TestModule {
+    @Module(injects = EntryPoint.class) class TestModule {
       @Provides BagOfMoney providesMoney() {
         return new BagOfMoney();
       }
@@ -63,13 +63,13 @@
     class BagOfMoney {
     }
 
-    @Module(entryPoints = EntryPoint.class, library = true) class ExampleLibraryModule {
+    @Module(injects = EntryPoint.class, library = true) class ExampleLibraryModule {
       @Provides BagOfMoney providesMoney() {
         return new BagOfMoney();
       }
     }
 
-    @Module(entryPoints = EntryPoint.class) class TestModule {
+    @Module(injects = EntryPoint.class) class TestModule {
     }
 
     ObjectGraph graph = ObjectGraph.create(new TestModule());
/Fim/
diff --git a/examples/simple/src/main/java/coffee/DripCoffeeModule.java b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
index 1b1d3fe..da0bbaa 100644
--- a/examples/simple/src/main/java/coffee/DripCoffeeModule.java
+++ b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
@@ -5,7 +5,7 @@
 import javax.inject.Singleton;
 
 @Module(
-    entryPoints = CoffeeApp.class,
+    injects = CoffeeApp.class,
     includes = PumpModule.class
 )
 class DripCoffeeModule {
/Fim/
diff --git a/website/index.html b/website/index.html
index 7141b4d..cd42c13 100644
--- a/website/index.html
+++ b/website/index.html
@@ -108,7 +108,7 @@
 ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());
 </pre>
 
-<p>In order to put the graph to use we need to create an <strong>entry point</strong>. This is usually the main class that starts the application. In this example, the <code>CoffeeApp</code> class serves as the entry point. We ask the graph to provide an injected instance of this type:</p>
+<p>In order to put the graph to use we need to <strong>bootstrap injection</strong>. This usually requires injecting the main class of a command line app, or the activity classes of an Android app. In our coffee example, the <code>CoffeeApp</code> class is used to start dependency injection. We ask the graph to provide an injected instance of the class:</p>
 
 <pre class="prettyprint">
 class CoffeeApp implements Runnable {
@@ -126,20 +126,20 @@
 }
 </pre>
 
-<p>The only thing that's missing is that the entry point class <code>CoffeeApp</code> isn't included in the graph. We need to explicitly register it as an entry point in the <code>@Module</code> annotation.</p>
+<p>The only thing that's missing is that the injectable class <code>CoffeeApp</code> isn't known by the graph. We need to explicitly register it as an injected type in the <code>@Module</code> annotation.</p>
 
 <pre class="prettyprint">
 @Module(
-    entryPoints = CoffeeApp.class
+    injects = { CoffeeApp.class }
 )
 class DripCoffeeModule {
   ...
 }
 </pre>
 
-<p>Entry points enable the complete graph to be validated <strong>at compile time</strong>. Detecting problems early speeds up development and takes some of the danger out of refactoring.</p>
+<p>The <code>injects</code> option enables the complete graph to be validated <strong>at compile time</strong>. Detecting problems early speeds up development and takes some of the danger out of refactoring.</p>
 
-<p>Now that the graph is constructed and the entry point is injected, we run our coffee maker app. Fun.</p>
+<p>Now that the graph is constructed and the root object is injected, we run our coffee maker app. Fun.</p>
 
 <pre>
 $ java -cp ... coffee.CoffeeApp
@@ -335,7 +335,7 @@
 
   @Module(
       includes = DripCoffeeModule.class,
-      entryPoints = CoffeeMakerTest.class,
+      injects = CoffeeMakerTest.class,
       overrides = true
   )
   static class TestModule {
/Fim/
/Fim/
/Fim/
/Fim/
diff --git a/website/index.html b/website/index.html
index cd42c13..0d9529c 100644
--- a/website/index.html
+++ b/website/index.html
@@ -1,32 +1,49 @@
----
-layout: default
----
+<!DOCTYPE html>
 
-<h3>Introduction</h3>
+<html lang="en">
+<head>
+    <meta charset="utf-8">
+    <title>Dagger &#x2020; A fast dependency injector for Android and Java.</title>
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <meta name="description" content="A fast dependency injector for Android and Java." />
+    <link href="static/bootstrap.min.css" rel="stylesheet">
+    <link href="static/bootstrap-responsive.min.css" rel="stylesheet">
+    <link href="static/prettify.css" rel="stylesheet">
+    <link href="static/app.css" rel="stylesheet">
+</head>
+<body>
+<div class="container">
+    <div class="row">
+        <div class="span4 side">
+            <h1><img src="static/logo.png" alt="Dagger"></h1>
+            <h3>A fast dependency injector for Android and Java.</h3>
+            <p><a href="https://squareup.com/"><img src="static/square.png" alt="by Square, Inc."></a></p>
+      </div>
+        <div class="offset4 span8 main"><div class="main-inner">
+            <h3>Introduction</h3>
 
-<p>The best classes in any application are the ones that do stuff: the <code>BarcodeDecoder</code>, the <code>KoopaPhysicsEngine</code>, and the <code>AudioStreamer</code>. These classes have dependencies; perhaps a <code>BarcodeCameraFinder</code>, <code>DefaultPhysicsEngine</code>, and an <code>HttpStreamer</code>.</p>
+            <p>The best classes in any application are the ones that do stuff: the <code>BarcodeDecoder</code>, the <code>KoopaPhysicsEngine</code>, and the <code>AudioStreamer</code>. These classes have dependencies; perhaps a <code>BarcodeCameraFinder</code>, <code>DefaultPhysicsEngine</code>, and an <code>HttpStreamer</code>.</p>
 
-<p>To contrast, the worst classes in any application are the ones that take up space without doing much at all: the <code>BarcodeDecoderFactory</code>, the <code>CameraServiceLoader</code>, and the <code>MutableContextWrapper</code>. These classes are the clumsy duct tape that wires the interesting stuff together.</p>
+            <p>To contrast, the worst classes in any application are the ones that take up space without doing much at all: the <code>BarcodeDecoderFactory</code>, the <code>CameraServiceLoader</code>, and the <code>MutableContextWrapper</code>. These classes are the clumsy duct tape that wires the interesting stuff together.</p>
 
-<p>Dagger is a replacement for these <code>FactoryFactory</code> classes. It allows you to focus on the interesting classes. Declare dependencies, specify how to satisfy them, and ship your app.</p>
+            <p>Dagger is a replacement for these <code>FactoryFactory</code> classes. It allows you to focus on the interesting classes. Declare dependencies, specify how to satisfy them, and ship your app.</p>
 
-<p>By building on standard <a href="http://atinject.googlecode.com/svn/trunk/javadoc/javax/inject/package-summary.html">javax.inject</a> annotations (JSR-330), each class is <strong>easy to test</strong>. You don't need a bunch of boilerplate just to swap the <code>RpcCreditCardService</code> out for a <code>FakeCreditCardService</code>.</p>
+            <p>By building on standard <a href="http://atinject.googlecode.com/svn/trunk/javadoc/javax/inject/package-summary.html">javax.inject</a> annotations (JSR-330), each class is <strong>easy to test</strong>. You don't need a bunch of boilerplate just to swap the <code>RpcCreditCardService</code> out for a <code>FakeCreditCardService</code>.</p>
 
-<p>Dependency injection isn't just for testing. It also makes it easy to create <strong>reusable, interchangeable modules</strong>. You can share the same <code>AuthenticationModule</code>  across all of your apps. And you can run <code>DevLoggingModule</code> during development and <code>ProdLoggingModule</code> in production to get the right behavior in each situation.</p>
+            <p>Dependency injection isn't just for testing. It also makes it easy to create <strong>reusable, interchangeable modules</strong>. You can share the same <code>AuthenticationModule</code>  across all of your apps. And you can run <code>DevLoggingModule</code> during development and <code>ProdLoggingModule</code> in production to get the right behavior in each situation.</p>
 
-<p>For more information, <a href="http://www.infoq.com/presentations/Dagger">watch an introductory talk</a> by Jesse Wilson at QCon 2012.</p>
+            <p>For more information, <a href="http://www.infoq.com/presentations/Dagger">watch an introductory talk</a> by Jesse Wilson at QCon 2012.</p>
 
-<h3>Using Dagger</h3>
-<p>We'll demonstrate dependency injection and Dagger by building a coffee maker. For complete sample code that you can compile and run, see Dagger's <a href="https://github.com/square/dagger/tree/master/examples/simple/src/main/java/coffee">coffee example</a>.</p>
+            <h3>Using Dagger</h3>
+            <p>We'll demonstrate dependency injection and Dagger by building a coffee maker. For complete sample code that you can compile and run, see Dagger's <a href="https://github.com/square/dagger/tree/master/examples/simple/src/main/java/coffee">coffee example</a>.</p>
 
-<h4>Declaring Dependencies</h4>
+            <h4>Declaring Dependencies</h4>
 
-<p>Dagger constructs instances of your application classes and satisfies their dependencies. It uses the <code>javax.inject.Inject</code> annotation to identify which constructors and fields it is interested in.</p>
+            <p>Dagger constructs instances of your application classes and satisfies their dependencies. It uses the <code>javax.inject.Inject</code> annotation to identify which constructors and fields it is interested in.</p>
 
-<p>Use <code>@Inject</code> to annotate the constructor that Dagger should use to create instances of a class. When a new instance is requested, Dagger will obtain the required parameters values and invoke this constructor.</p>
+            <p>Use <code>@Inject</code> to annotate the constructor that Dagger should use to create instances of a class. When a new instance is requested, Dagger will obtain the required parameters values and invoke this constructor.</p>
 
-<pre class="prettyprint">
-class Thermosiphon implements Pump {
+            <pre class="prettyprint">class Thermosiphon implements Pump {
   private final Heater heater;
 
   @Inject
@@ -35,58 +52,50 @@
   }
 
   ...
-}
-</pre>
+}</pre>
 
-<p>Dagger can inject fields directly. In this example it obtains a <code>Heater</code> instance for the <code>heater</code> field and a <code>Pump</code> instance for the <code>pump</code> field.</p>
+            <p>Dagger can inject fields directly. In this example it obtains a <code>Heater</code> instance for the <code>heater</code> field and a <code>Pump</code> instance for the <code>pump</code> field.</p>
 
-<pre class="prettyprint">
-class CoffeeMaker {
+            <pre class="prettyprint">class CoffeeMaker {
   @Inject Heater heater;
   @Inject Pump pump;
 
   ...
-}
-</pre>
+}</pre>
 
-<p>If your class has <code>@Inject</code>-annotated fields but no <code>@Inject</code>-annotated constructor, Dagger will use a no-argument constructor if it exists. Classes that lack <code>@Inject</code> annotations cannot be constructed by Dagger.</p>
+            <p>If your class has <code>@Inject</code>-annotated fields but no <code>@Inject</code>-annotated constructor, Dagger will use a no-argument constructor if it exists. Classes that lack <code>@Inject</code> annotations cannot be constructed by Dagger.</p>
 
-<p>Dagger does not support method injection.</p>
+            <p>Dagger does not support method injection.</p>
 
-<h4>Satisfying Dependencies</h4>
+            <h4>Satisfying Dependencies</h4>
 
-<p>By default, Dagger satisfies each dependency by constructing an instance of the requested type as described above. When you request a <code>CoffeeMaker</code>, it'll obtain one by calling <code>new CoffeeMaker()</code> and setting its injectable fields.</p>
+            <p>By default, Dagger satisfies each dependency by constructing an instance of the requested type as described above. When you request a <code>CoffeeMaker</code>, it'll obtain one by calling <code>new CoffeeMaker()</code> and setting its injectable fields.</p>
 
-<p>But <code>@Inject</code> doesn't work everywhere:</p>
+            <p>But <code>@Inject</code> doesn't work everywhere:</p>
 
-<ul>
-  <li>Interfaces can't be constructed.</li>
-  <li>Third-party classes can't be annotated.</li>
-  <li>Configurable objects must be configured!</li>
-</ul>
+            <ul>
+                <li>Interfaces can't be constructed.</li>
+                <li>Third-party classes can't be annotated.</li>
+                <li>Configurable objects must be configured!</li>
+            </ul>
 
-<p>For these cases where <code>@Inject</code> is insufficient or awkward, use an <code>@Provides</code>-annotated method to satisfy a dependency. The method's return type defines which dependency it satisfies.</p>
+            <p>For these cases where <code>@Inject</code> is insufficient or awkward, use an <code>@Provides</code>-annotated method to satisfy a dependency. The method's return type defines which dependency it satisfies.</p>
 
-<p>For example, <code>provideHeater()</code> is invoked whenever a <code>Heater</code> is required:</p>
+            <p>For example, <code>provideHeater()</code> is invoked whenever a <code>Heater</code> is required:</p>
 
-<pre class="prettyprint">
-@Provides Heater provideHeater() {
+            <pre class="prettyprint">@Provides Heater provideHeater() {
   return new ElectricHeater();
-}
-</pre>
+}</pre>
 
-<p>It's possible for <code>@Provides</code> methods to have dependencies of their own. This one returns a <code>Thermosiphon</code> whenever a <code>Pump</code> is required:</p>
+            <p>It's possible for <code>@Provides</code> methods to have dependencies of their own. This one returns a <code>Thermosiphon</code> whenever a <code>Pump</code> is required:</p>
 
-<pre class="prettyprint">
-@Provides Pump providePump(Thermosiphon pump) {
+            <pre class="prettyprint">@Provides Pump providePump(Thermosiphon pump) {
   return pump;
-}
-</pre>
+}</pre>
 
-<p>All <code>@Provides</code> methods must belong to a module. These are just classes that have an <code>@Module</code> annotation.</p>
+            <p>All <code>@Provides</code> methods must belong to a module. These are just classes that have an <code>@Module</code> annotation.</p>
 
-<pre class="prettyprint">
-@Module
+<pre class="prettyprint">@Module
 class DripCoffeeModule {
   @Provides Heater provideHeater() {
     return new ElectricHeater();
@@ -95,23 +104,19 @@
   @Provides Pump providePump(Thermosiphon pump) {
     return pump;
   }
-}
-</pre>
+}</pre>
 
-<p>By convention, <code>@Provides</code> methods are named with a <code>provide</code> prefix and module classes are named with a <code>Module</code> suffix.</p>
+            <p>By convention, <code>@Provides</code> methods are named with a <code>provide</code> prefix and module classes are named with a <code>Module</code> suffix.</p>
 
-<h4>Building the Graph</h4>
+            <h4>Building the Graph</h4>
 
-<p>The <code>@Inject</code> and <code>@Provides</code>-annotated classes form a graph of objects, linked by their dependencies. Obtain this graph by calling <code>ObjectGraph.create()</code>, which accepts one or more modules:</p>
+            <p>The <code>@Inject</code> and <code>@Provides</code>-annotated classes form a graph of objects, linked by their dependencies. Obtain this graph by calling <code>ObjectGraph.create()</code>, which accepts one or more modules:</p>
 
-<pre class="prettyprint">
-ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());
-</pre>
+            <pre class="prettyprint">ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());</pre>
 
-<p>In order to put the graph to use we need to <strong>bootstrap injection</strong>. This usually requires injecting the main class of a command line app, or the activity classes of an Android app. In our coffee example, the <code>CoffeeApp</code> class is used to start dependency injection. We ask the graph to provide an injected instance of the class:</p>
+            <p>In order to put the graph to use we need to <strong>bootstrap injection</strong>. This usually requires injecting the main class of a command line app, or the activity classes of an Android app. In our coffee example, the <code>CoffeeApp</code> class is used to start dependency injection. We ask the graph to provide an injected instance of the class:</p>
 
-<pre class="prettyprint">
-class CoffeeApp implements Runnable {
+            <pre class="prettyprint">class CoffeeApp implements Runnable {
   @Inject CoffeeMaker coffeeMaker;
 
   @Override public void run() {
@@ -123,56 +128,46 @@
     CoffeeApp coffeeApp = objectGraph.get(CoffeeApp.class);
     ...
   }
-}
-</pre>
+}</pre>
 
-<p>The only thing that's missing is that the injectable class <code>CoffeeApp</code> isn't known by the graph. We need to explicitly register it as an injected type in the <code>@Module</code> annotation.</p>
+            <p>The only thing that's missing is that the injectable class <code>CoffeeApp</code> isn't known by the graph. We need to explicitly register it as an injected type in the <code>@Module</code> annotation.</p>
 
-<pre class="prettyprint">
-@Module(
-    injects = { CoffeeApp.class }
+            <pre class="prettyprint">@Module(
+    injects = CoffeeApp.class
 )
 class DripCoffeeModule {
   ...
-}
-</pre>
+}</pre>
 
-<p>The <code>injects</code> option enables the complete graph to be validated <strong>at compile time</strong>. Detecting problems early speeds up development and takes some of the danger out of refactoring.</p>
+            <p>The <code>injects</code> option enables the complete graph to be validated <strong>at compile time</strong>. Detecting problems early speeds up development and takes some of the danger out of refactoring.</p>
 
-<p>Now that the graph is constructed and the root object is injected, we run our coffee maker app. Fun.</p>
+            <p>Now that the graph is constructed and the root object is injected, we run our coffee maker app. Fun.</p>
 
-<pre>
-$ java -cp ... coffee.CoffeeApp
+            <pre>$ java -cp ... coffee.CoffeeApp
 ~ ~ ~ heating ~ ~ ~
 =&gt; =&gt; pumping =&gt; =&gt;
- [_]P coffee! [_]P
-</pre>
+ [_]P coffee! [_]P</pre>
 
-<h4>Singletons</h4>
+            <h4>Singletons</h4>
 
-<p>Annotate an <code>@Provides</code> method or injectable class with <code>@Singleton</code>. The graph will use a single instance of the value for all of its clients.</p>
+            <p>Annotate an <code>@Provides</code> method or injectable class with <code>@Singleton</code>. The graph will use a single instance of the value for all of its clients.</p>
 
-<pre class="prettyprint">
-@Provides @Singleton Heater provideHeater() {
+            <pre class="prettyprint">@Provides @Singleton Heater provideHeater() {
   return new ElectricHeater();
-}
-</pre>
+}</pre>
 
-<p>The <code>@Singleton</code> annotation on an injectable class also serves as documentation. It reminds potential maintainers that this class may be shared by multiple threads.</p>
+            <p>The <code>@Singleton</code> annotation on an injectable class also serves as documentation. It reminds potential maintainers that this class may be shared by multiple threads.</p>
 
-<pre class="prettyprint">
-@Singleton
+            <pre class="prettyprint">@Singleton
 class CoffeeMaker {
   ...
-}
-</pre>
+}</pre>
 
-<h4>Lazy injections</h4>
+            <h4>Lazy injections</h4>
 
-<p>Sometimes you need an object to be instantiated lazily.  For any binding <code>T</code>, you can create a <code>Lazy&lt;T></code> which defers instantiation until the first call to <code>Lazy&lt;T></code>'s <code>get()</code> method. If <code>T</code> is a singleton, then <code>Lazy&lt;T></code> will be the same instance for all injections within the <code>ObjectGraph</code>.  Otherwise, each injection site will get its own <code>Lazy&lt;T></code> instance.  Regardless, subsequent calls to any given instance of <code>Lazy&lt;T></code> will return the same underlying instance of <code>T</code>.</p>
+            <p>Sometimes you need an object to be instantiated lazily.  For any binding <code>T</code>, you can create a <code>Lazy&lt;T></code> which defers instantiation until the first call to <code>Lazy&lt;T></code>'s <code>get()</code> method. If <code>T</code> is a singleton, then <code>Lazy&lt;T></code> will be the same instance for all injections within the <code>ObjectGraph</code>.  Otherwise, each injection site will get its own <code>Lazy&lt;T></code> instance.  Regardless, subsequent calls to any given instance of <code>Lazy&lt;T></code> will return the same underlying instance of <code>T</code>.</p>
 
-<pre class="prettyprint">
-class GridingCoffeeMaker {
+            <pre class="prettyprint">class GridingCoffeeMaker {
   @Inject Lazy&lt;Grinder&gt; lazyGrinder;
 
   public void brew() {
@@ -181,20 +176,17 @@
       lazyGrinder.get().grind();
     }
   }
-}
-</pre>
+}</pre>
 
-<h4>Provider injections</h4>
+            <h4>Provider injections</h4>
 
-<p>Sometimes you need multiple instances to be returned instead of just injecting a single value.  While you have several options (Factories, Builders, etc.)   one option is to inject a <code>Provider&lt;T></code> instead of just <code>T</code>.  A <code>Provider&lt;T></code> creates a new instance of <code>T</code> each time <code>.get()</code> is called.</p>
+            <p>Sometimes you need multiple instances to be returned instead of just injecting a single value.  While you have several options (Factories, Builders, etc.)   one option is to inject a <code>Provider&lt;T></code> instead of just <code>T</code>.  A <code>Provider&lt;T></code> creates a new instance of <code>T</code> each time <code>.get()</code> is called.</p>
 
-<pre class="prettyprint">
-
-class BigCoffeeMaker {
+            <pre class="prettyprint">class BigCoffeeMaker {
   @Inject Provider&lt;Filter&gt; filterProvider;
 
   public void brew(int numberOfPots) {
-	...
+    ...
     for (int p = 0; p &lt; numberOfPots; p++) {
       maker.addFilter(filterProvider.get()); //new filter every time.
       maker.addCoffee(...);
@@ -202,130 +194,110 @@
       ...
     }
   }
-}
-</pre>
+}</pre>
 
-<p><span class="label label-inverse">Note:</span><em> Injecting <code>Provider&lt;T></code> has the possibility of creating confusing code, and may be a design smell of mis-scoped or mis-structured objects in your graph.  Often you will want to use a <code>Factory&lt;T></code> or a <code>Lazy&lt;T></code> or re-organize the lifetimes and structure of your code to be able to just inject a <code>T</code>.  Injecting <code>Provider&lt;T></code> can, however, be a life saver in some cases.  A common use is when you must use a legacy architecture that doesn't line up with your object's natural lifetimes (e.g. servlets are singletons by design, but only are valid in the context of request-specfic data).</em></p>
+            <p><span class="label label-inverse">Note:</span><em> Injecting <code>Provider&lt;T></code> has the possibility of creating confusing code, and may be a design smell of mis-scoped or mis-structured objects in your graph.  Often you will want to use a <code>Factory&lt;T></code> or a <code>Lazy&lt;T></code> or re-organize the lifetimes and structure of your code to be able to just inject a <code>T</code>.  Injecting <code>Provider&lt;T></code> can, however, be a life saver in some cases.  A common use is when you must use a legacy architecture that doesn't line up with your object's natural lifetimes (e.g. servlets are singletons by design, but only are valid in the context of request-specfic data).</em></p>
 
-<h4>Qualifiers</h4>
+            <h4>Qualifiers</h4>
 
-<p>Sometimes the type alone is insufficient to identify a dependency. For example, a sophisticated coffee maker app may want separate heaters for the water and the hot plate.</p>
+            <p>Sometimes the type alone is insufficient to identify a dependency. For example, a sophisticated coffee maker app may want separate heaters for the water and the hot plate.</p>
 
-<p>In this case, we add a <strong>qualifier annotation</strong>. This is any annotation that itself has a <code>@Qualifier</code> annotation. Here's the declaration of <code>@Named</code>, a qualifier annotation included in <code>javax.inject</code>:</p>
+            <p>In this case, we add a <strong>qualifier annotation</strong>. This is any annotation that itself has a <code>@Qualifier</code> annotation. Here's the declaration of <code>@Named</code>, a qualifier annotation included in <code>javax.inject</code>:</p>
 
-<pre class="prettyprint">
-@Qualifier
+            <pre class="prettyprint">@Qualifier
 @Documented
 @Retention(RUNTIME)
 public @interface Named {
   String value() default "";
-}
-</pre>
+}</pre>
 
-<p>You can create your own qualifier annotations, or just use <code>@Named</code>. Apply qualifiers by annotating the field or parameter of interest. The type and qualifier annotation will both be used to identify the dependency.</p>
+            <p>You can create your own qualifier annotations, or just use <code>@Named</code>. Apply qualifiers by annotating the field or parameter of interest. The type and qualifier annotation will both be used to identify the dependency.</p>
 
-<pre class="prettyprint">
-class ExpensiveCoffeeMaker {
+            <pre class="prettyprint">class ExpensiveCoffeeMaker {
   @Inject @Named("water") Heater waterHeater;
   @Inject @Named("hot plate") Heater hotPlateHeater;
   ...
-}
-</pre>
+}</pre>
 
-<p>Supply qualified values by annotating the corresponding <code>@Provides</code> method.</p>
+            <p>Supply qualified values by annotating the corresponding <code>@Provides</code> method.</p>
 
-<pre class="prettyprint">
-@Provides @Named("hot plate") Heater provideHotPlateHeater() {
+            <pre class="prettyprint">@Provides @Named("hot plate") Heater provideHotPlateHeater() {
   return new ElectricHeater(70);
 }
 
 @Provides @Named("water") Heater provideWaterHeater() {
   return new ElectricHeater(93);
-}
-</pre>
+}</pre>
 
-<p>Dependencies may not have multiple qualifier annotations.</p>
+            <p>Dependencies may not have multiple qualifier annotations.</p>
 
-<h4>Static Injection</h4>
+            <h4>Static Injection</h4>
 
-<p><span class="label label-important">Warning:</span> This feature should be used sparingly because static dependencies are difficult to test and reuse.</p>
+            <p><span class="label label-important">Warning:</span> This feature should be used sparingly because static dependencies are difficult to test and reuse.</p>
 
-<p>Dagger can inject static fields. Classes that declare static fields with <code>@Inject</code> annotations must be listed as <code>staticInjections</code> in a module annotation.</p>
+            <p>Dagger can inject static fields. Classes that declare static fields with <code>@Inject</code> annotations must be listed as <code>staticInjections</code> in a module annotation.</p>
 
-<pre class="prettyprint">
-@Module(
+            <pre class="prettyprint">@Module(
     staticInjections = LegacyCoffeeUtils.class
 )
 class LegacyModule {
-}
-</pre>
+}</pre>
 
-<p>Use <code>ObjectGraph.injectStatics()</code> to populate these static fields with their injected values:</p>
+            <p>Use <code>ObjectGraph.injectStatics()</code> to populate these static fields with their injected values:</p>
 
-<pre class="prettyprint">
-ObjectGraph objectGraph = ObjectGraph.create(new LegacyModule());
-objectGraph.injectStatics();
-</pre>
+            <pre class="prettyprint">ObjectGraph objectGraph = ObjectGraph.create(new LegacyModule());
+objectGraph.injectStatics();</pre>
 
-<h4>Compile-time Validation</h4>
+            <h4>Compile-time Validation</h4>
 
-<p>Dagger includes an <a href="http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html">annotation processor</a> that validates modules and injections. This processor is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is missing a binding for <code>Executor</code>:</p>
+            <p>Dagger includes an <a href="http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html">annotation processor</a> that validates modules and injections. This processor is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is missing a binding for <code>Executor</code>:</p>
 
-<pre class="prettyprint">
-@Module
+            <pre class="prettyprint">@Module
 class DripCoffeeModule {
   @Provides Heater provideHeater(Executor executor) {
     return new CpuHeater(executor);
   }
-}
-</pre>
+}</pre>
 
-<p>When compiling it, <code>javac</code> rejects the missing binding:</p>
+            <p>When compiling it, <code>javac</code> rejects the missing binding:</p>
 
-<pre>
-[ERROR] COMPILATION ERROR :
+            <pre>[ERROR] COMPILATION ERROR :
 [ERROR] error: No binding for java.util.concurrent.Executor
-               required by provideHeater(java.util.concurrent.Executor)
-</pre>
+               required by provideHeater(java.util.concurrent.Executor)</pre>
 
-<p>Fix the problem either by adding an <code>@Provides</code>-annotated method for <code>Executor</code>, or by marking the module as incomplete. Incomplete modules are permitted to have missing dependencies.</p>
+            <p>Fix the problem either by adding an <code>@Provides</code>-annotated method for <code>Executor</code>, or by marking the module as incomplete. Incomplete modules are permitted to have missing dependencies.</p>
 
-<pre class="prettyprint">
-@Module(complete = false)
+            <pre class="prettyprint">@Module(complete = false)
 class DripCoffeeModule {
   @Provides Heater provideHeater(Executor executor) {
     return new CpuHeater(executor);
   }
-}
-</pre>
+}</pre>
 
-<p>To get the most out of compile-time validation, create a module that includes all of your application's modules. The annotation processor will detect problems across the modules and report them.</p>
+            <p>To get the most out of compile-time validation, create a module that includes all of your application's modules. The annotation processor will detect problems across the modules and report them.</p>
 
-<pre class="prettyprint">
-@Module(
+            <pre class="prettyprint">@Module(
     includes = {
         DripCoffeeModule.class,
         ExecutorModule.class
     }
 )
 public class CoffeeAppModule {
-}
-</pre>
+}</pre>
 
-<p>The annotation processor is enabled automatically when you include Dagger's jar file on your compile classpath.</p>
+            <p>The annotation processor is enabled automatically when you include Dagger's jar file on your compile classpath.</p>
 
-<h4>Compile-time Code Generation</h4>
+            <h4>Compile-time Code Generation</h4>
 
-<p>Dagger's annotation processor may also generate source files with names like <code>CoffeeMaker$InjectAdapter.java</code> or <code>DripCoffeeModule$ModuleAdapter</code>. These files are Dagger implementation details. You shouldn't need to use them directly, though they can be handy when step-debugging through an injection.</p>
+            <p>Dagger's annotation processor may also generate source files with names like <code>CoffeeMaker$InjectAdapter.java</code> or <code>DripCoffeeModule$ModuleAdapter</code>. These files are Dagger implementation details. You shouldn't need to use them directly, though they can be handy when step-debugging through an injection.</p>
 
-<h4>Module overrides</h4>
+            <h4>Module overrides</h4>
 
-<p>Dagger will fail with an error if there are multiple competing <code>@Provides</code> methods for the same dependency. But sometimes it's necessary to replace production code with a substitute for development or testing. Using <code>overrides = true</code> in a module annotation lets you take precedence over the bindings of other modules.</p>
+            <p>Dagger will fail with an error if there are multiple competing <code>@Provides</code> methods for the same dependency. But sometimes it's necessary to replace production code with a substitute for development or testing. Using <code>overrides = true</code> in a module annotation lets you take precedence over the bindings of other modules.</p>
 
-<p>This JUnit test overrides <code>DripCoffeeModule</code>'s binding for <code>Heater</code> with a mock object from <a href="http://mockito.googlecode.com/">Mockito</a>. The mock gets injected into the <code>CoffeeMaker</code> and also into the test.</p>
+            <p>This JUnit test overrides <code>DripCoffeeModule</code>'s binding for <code>Heater</code> with a mock object from <a href="http://mockito.googlecode.com/">Mockito</a>. The mock gets injected into the <code>CoffeeMaker</code> and also into the test.</p>
 
-<pre class="prettyprint">
-public class CoffeeMakerTest {
+            <pre class="prettyprint">public class CoffeeMakerTest {
   @Inject CoffeeMaker coffeeMaker;
   @Inject Heater heater;
 
@@ -350,26 +322,23 @@
     Mockito.verify(heater, Mockito.times(1)).on();
     Mockito.verify(heater, Mockito.times(1)).off();
   }
-}
-</pre>
+}</pre>
 
-<p>Overrides are best suited for small variations on the application:</p>
-<ul>
-  <li>Replacing the real implementation with a mock for unit tests.</li>
-  <li>Replacing LDAP authentication with fake authentication for development.</li>
-</ul>
+            <p>Overrides are best suited for small variations on the application:</p>
+            <ul>
+                <li>Replacing the real implementation with a mock for unit tests.</li>
+                <li>Replacing LDAP authentication with fake authentication for development.</li>
+            </ul>
 
-<p>For more substantial variations it's often simpler to use a different combination of modules.</p>
+            <p>For more substantial variations it's often simpler to use a different combination of modules.</p>
 
+            <h3>Using Dagger In Your Build</h3>
 
-<h3>Using Dagger In Your Build</h3>
+            <p>You will need to include the <code>dagger-${dagger.version}.jar</code> in your application's runtime.  In order to activate code generation you will need to include <code>dagger-compiler-${dagger.version}.jar</code> in your build at compile time.</p>
 
-<p>You will need to include the <code>dagger-${dagger.version}.jar</code> in your application's runtime.  In order to activate code generation you will need to include <code>dagger-compiler-${dagger.version}.jar</code> in your build at compile time.</p>
+            <p>In a Maven project, one would include the runtime in the dependencies section of your <code>pom.xml</code> (replacing <code>${dagger.version}</code> with the appropriate current release), and the <code>dagger-compiler</code> artifact as an "optional" or "provided" dependency:</p>
 
-<p>In a Maven project, one would include the runtime in the dependencies section of your <code>pom.xml</code> (replacing <code>${dagger.version}</code> with the appropriate current release), and the <code>dagger-compiler</code> artifact as an "optional" or "provided" dependency:</p>
-
-<pre class="prettyprint">
-&lt;dependencies>
+            <pre class="prettyprint">&lt;dependencies>
   &lt;dependency>
     &lt;groupId>com.squareup&lt;/groupId>
     &lt;artifactId>dagger&lt;/artifactId>
@@ -381,26 +350,22 @@
     &lt;version>${dagger.version}&lt;/version>
     &lt;optional>true&lt;/optional>
   &lt;/dependency>
-&lt;/dependencies>
-</pre>
+&lt;/dependencies></pre>
 
 
+            <h3>Upgrading from Guice</h3>
 
-<h3>Upgrading from Guice</h3>
+            <p>Some notable Guice features that Dagger doesn't support:</p>
+            <ul>
+                <li>Injecting <code>final</code> fields and <code>private</code> members. For best performance Dagger generates code. Work around this by using constructor injection.</li>
+                <li>Eager singletons. Work around this by creating an <code>EagerSingletons</code> class that declares static fields for each eager singleton.</li>
+                <li>Method injection.</li>
+                <li>Classes that lack <code>@Inject</code> annotations cannot be constructed by Dagger, even if they have a no-argument constructor.</li>
+            </ul>
 
-<p>Some notable Guice features that Dagger doesn't support:</p>
-<ul>
-  <li>Injecting <code>final</code> fields and <code>private</code> members. For best performance Dagger generates code. Work around this by using constructor injection.</li>
-  <li>Eager singletons. Work around this by creating an <code>EagerSingletons</code> class that declares static fields for each eager singleton.</li>
-  <li>Method injection.</li>
-  <li>Classes that lack <code>@Inject</code> annotations cannot be constructed by Dagger, even if they have a no-argument constructor.</li>
-</ul>
+            <h3>License</h3>
 
-
-<h3>License</h3>
-
-<pre>
-Copyright 2012 Square, Inc.
+            <pre>Copyright 2012 Square, Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -412,5 +377,13 @@
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
-limitations under the License.
-</pre>
+limitations under the License.</pre>
+
+            <a id="ribbon" href="https://github.com/square/dagger"><img src="static/ribbon.png" alt="Fork me on GitHub"></a>
+        </div></div>
+    </div>
+</div>
+<script src="static/prettify.js"></script>
+<script> prettyPrint(); </script>
+</body>
+</html>
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java b/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
index e0050d9..8513e58 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
@@ -296,4 +296,9 @@
     return ((TypeElement) method.getEnclosingElement()).getQualifiedName()
         + "." + method.getSimpleName() + "()";
   }
+
+  public static boolean isInterface(TypeMirror typeMirror) {
+    return typeMirror instanceof DeclaredType
+        && ((DeclaredType) typeMirror).asElement().getKind() == ElementKind.INTERFACE;
+  }
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index fe1732f..9d9bdd4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -149,9 +149,12 @@
         Map<String, Binding<?>> addTo = overrides ? overrideBindings : baseBindings;
 
         // Gather the injectable types from the annotation.
-        for (Object injectableType : (Object[]) annotation.get("injects")) {
-          linker.requestBinding(GeneratorKeys.rawMembersKey((TypeMirror) injectableType),
-              module.getQualifiedName().toString(), false, true);
+        for (Object injectableTypeObject : (Object[]) annotation.get("injects")) {
+          TypeMirror injectableType = (TypeMirror) injectableTypeObject;
+          String key = CodeGen.isInterface(injectableType)
+              ? GeneratorKeys.get(injectableType)
+              : GeneratorKeys.rawMembersKey(injectableType);
+          linker.requestBinding(key, module.getQualifiedName().toString(), false, true);
         }
 
         // Gather the static injections.
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 1b969d6..75a37d2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -244,7 +244,9 @@
     StringBuilder injectsField = new StringBuilder().append("{ ");
     for (Object injectableType : injects) {
       TypeMirror typeMirror = (TypeMirror) injectableType;
-      String key = GeneratorKeys.rawMembersKey(typeMirror);
+      String key = CodeGen.isInterface(typeMirror)
+          ? GeneratorKeys.get(typeMirror)
+          : GeneratorKeys.rawMembersKey(typeMirror);
       injectsField.append(JavaWriter.stringLiteral(key)).append(", ");
     }
     injectsField.append("}");
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 09c2883..33d5705 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -239,7 +239,7 @@
 
     @Override public <T> T get(Class<T> type) {
       String key = Keys.get(type);
-      String injectableTypeKey = Keys.getMembersKey(type);
+      String injectableTypeKey = type.isInterface() ? key : Keys.getMembersKey(type);
       @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
       Binding<T> binding = (Binding<T>) getInjectableTypeBinding(injectableTypeKey, key);
       return binding.get();
@@ -255,8 +255,9 @@
 
     /**
      * @param injectableTypeKey the key used to store the injectable type. This
-     *     is always a members injection key because those keys can always be
-     *     created, even if the type has no injectable constructor.
+     *     is a provides key for interfaces and a members injection key for
+     *     other types. That way keys can always be created, even if the type
+     *     has no injectable constructor.
      * @param key the key to use when retrieving the binding. This may be a
      *     regular (provider) key or a members key.
      */
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
index 805a710..2745001 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
@@ -39,7 +39,7 @@
 
   public ReflectiveModuleAdapter(Class<?> moduleClass, Module annotation) {
     super(
-        toMemberKeys(annotation.injects()),
+        injectableTypesToKeys(annotation.injects()),
         annotation.staticInjections(),
         annotation.overrides(),
         annotation.includes(),
@@ -48,10 +48,13 @@
     this.moduleClass = moduleClass;
   }
 
-  private static String[] toMemberKeys(Class<?>[] injectableTypes) {
+  private static String[] injectableTypesToKeys(Class<?>[] injectableTypes) {
     String[] result = new String[injectableTypes.length];
     for (int i = 0; i < injectableTypes.length; i++) {
-      result[i] = Keys.getMembersKey(injectableTypes[i]);
+      Class<?> injectableType = injectableTypes[i];
+      result[i] = injectableType.isInterface()
+          ? Keys.get(injectableType)
+          : Keys.getMembersKey(injectableType);
     }
     return result;
   }
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index bbb671e..09df5c2 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -435,6 +435,24 @@
     }
   }
 
+  @Test public void objectGraphGetInterface() {
+    final Runnable runnable = new Runnable() {
+      @Override public void run() {
+      }
+    };
+
+    @Module(injects = Runnable.class)
+    class TestModule {
+      @Provides Runnable provideRunnable() {
+        return runnable;
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    graph.validate();
+    assertThat(graph.get(Runnable.class)).isSameAs(runnable);
+  }
+
   @Test public void noProvideBindingsForAbstractClasses() {
     class TestEntryPoint {
       @Inject AbstractList<?> abstractList;
@@ -563,8 +581,8 @@
     }
 
     ObjectGraph graph = ObjectGraph.create(new TestModule());
-    assertEquals(0, (int) graph.get(Integer.class));
-    assertEquals(1, (int) graph.get(Integer.class));
+    assertThat((int) graph.get(Integer.class)).isEqualTo(0);
+    assertThat((int) graph.get(Integer.class)).isEqualTo(1);
   }
 
   @Test public void getInstanceRequiresEntryPoint() {
/Fim/
diff --git a/.travis.yml b/.travis.yml
index d6c3e3d..bbfcc54 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,6 +1,7 @@
 language: java
-install: mvn install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
-script: mvn verify
+
+install: mvn install clean -P!android --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
+script: mvn verify -P!android
 
 notifications:
   email: false
/Fim/
diff --git a/examples/android-activity-graphs/AndroidManifest.xml b/examples/android-activity-graphs/AndroidManifest.xml
new file mode 100644
index 0000000..adac7a8
--- /dev/null
+++ b/examples/android-activity-graphs/AndroidManifest.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    android:versionCode="1"
+    android:versionName="1.0.0"
+    package="com.example.dagger.activitygraphs">
+
+  <uses-sdk android:minSdkVersion="4" android:targetSdkVersion="17"/>
+
+  <application android:label="@string/app_name">
+    <activity
+        android:label="@string/app_name"
+        android:name=".ui.HomeActivity">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+        <category android:name="android.intent.category.LAUNCHER"/>
+        <category android:name="android.intent.category.DEFAULT"/>
+      </intent-filter>
+    </activity>
+  </application>
+</manifest>
/Fim/
diff --git a/examples/android-activity-graphs/README.md b/examples/android-activity-graphs/README.md
new file mode 100644
index 0000000..533d40a
--- /dev/null
+++ b/examples/android-activity-graphs/README.md
@@ -0,0 +1,17 @@
+Example: Android Activity Graphs
+================================
+
+Building on top of the simple Android example, this example demonstrates how it is possible to
+create child graphs for each activity which extend from the global graph.
+
+Some of the advantages of the activity scope:
+
+ * Provides the ability to inject objects which require the activity to be constructed.
+ * Allows for the use of singletons on a per-activity basis. This is a great way to manage a
+   resource that is shared by a bunch of fragments in an activity.
+ * Keeps the global object graph clear of things that can be used only be activities.
+
+While this example only shows the presence of an activity scope, you should be able to see the
+potential for other useful scopes that can be used. For example, having a dedicated object graph
+for the current user sessions is a great way to manage data that is tied to the currently logged-in
+user.
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
new file mode 100644
index 0000000..be3b39f
--- /dev/null
+++ b/examples/android-activity-graphs/pom.xml
@@ -0,0 +1,63 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.dagger.example</groupId>
+    <artifactId>dagger-example-parent</artifactId>
+    <version>1.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>android-activity-graphs</artifactId>
+  <name>Examples: Android - Activity Graphs</name>
+  <packaging>apk</packaging>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.dagger</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.dagger</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
+
+    <dependency>
+      <groupId>com.google.android</groupId>
+      <artifactId>android</artifactId>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.android</groupId>
+      <artifactId>support-v4</artifactId>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+        <artifactId>android-maven-plugin</artifactId>
+        <extensions>true</extensions>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/examples/android-activity-graphs/res/values/strings.xml b/examples/android-activity-graphs/res/values/strings.xml
new file mode 100644
index 0000000..4247e03
--- /dev/null
+++ b/examples/android-activity-graphs/res/values/strings.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <string name="app_name">Dagger Activity Graph</string>
+</resources>
/Fim/
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
new file mode 100644
index 0000000..465d66d
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs;
+
+import android.content.Context;
+import com.example.dagger.activitygraphs.ui.ActivityTitleController;
+import com.example.dagger.activitygraphs.ui.HomeActivity;
+import com.example.dagger.activitygraphs.ui.HomeFragment;
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Singleton;
+
+/**
+ * This module represents objects which exist only for the scope of a single activity. We can
+ * safely create singletons using the activity instance because ths entire object graph will only
+ * ever exist inside of that activity.
+ */
+@Module(
+    injects = {
+        HomeActivity.class,
+        HomeFragment.class
+    },
+    complete = false,
+    library = true
+)
+public class ActivityModule {
+  private final DemoBaseActivity activity;
+
+  public ActivityModule(DemoBaseActivity activity) {
+    this.activity = activity;
+  }
+
+  /**
+   * Allow the activity context to be injected but require that it be annotated with
+   * {@link ForActivity @ForActivity} to explicitly differentiate it from application context.
+   */
+  @Provides @Singleton @ForActivity Context provideActivityContext() {
+    return activity;
+  }
+
+  @Provides @Singleton ActivityTitleController provideTitleController() {
+    return new ActivityTitleController(activity);
+  }
+}
/Fim/
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AndroidModule.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AndroidModule.java
new file mode 100644
index 0000000..78a02a4
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AndroidModule.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs;
+
+import android.content.Context;
+import android.location.LocationManager;
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Singleton;
+
+import static android.content.Context.LOCATION_SERVICE;
+
+/**
+ * A module for Android-specific dependencies which require a {@link Context} or
+ * {@link android.app.Application} to create.
+ */
+@Module(library = true)
+public class AndroidModule {
+  private final DemoApplication application;
+
+  public AndroidModule(DemoApplication application) {
+    this.application = application;
+  }
+
+  /**
+   * Allow the application context to be injected but require that it be annotated with
+   * {@link ForApplication @Annotation} to explicitly differentiate it from an activity context.
+   */
+  @Provides @Singleton @ForApplication Context provideApplicationContext() {
+    return application;
+  }
+
+  @Provides @Singleton LocationManager provideLocationManager() {
+    return (LocationManager) application.getSystemService(LOCATION_SERVICE);
+  }
+}
/Fim/
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
new file mode 100644
index 0000000..56e1ab4
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs;
+
+import android.app.Application;
+import dagger.ObjectGraph;
+import java.util.Arrays;
+import java.util.List;
+
+public class DemoApplication extends Application {
+  private ObjectGraph applicationGraph;
+
+  @Override public void onCreate() {
+    super.onCreate();
+
+    applicationGraph = ObjectGraph.create(getModules().toArray());
+  }
+
+  /**
+   * A list of modules to use for the application graph. Subclasses can override this method to
+   * provide additional modules provided they call {@code super.getModules()}.
+   */
+  protected List<Object> getModules() {
+    return Arrays.<Object>asList(new AndroidModule(this));
+  }
+
+  ObjectGraph getApplicationGraph() {
+    return applicationGraph;
+  }
+}
/Fim/
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoBaseActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoBaseActivity.java
new file mode 100644
index 0000000..44693dc
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoBaseActivity.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs;
+
+import android.os.Bundle;
+import android.support.v4.app.FragmentActivity;
+import dagger.ObjectGraph;
+import java.util.Arrays;
+import java.util.List;
+
+/** Base activity which sets up a per-activity object graph and performs injection. */
+public abstract class DemoBaseActivity extends FragmentActivity {
+  private ObjectGraph activityGraph;
+
+  @Override protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+
+    // Create the activity graph by .plus-ing our modules onto the application graph.
+    DemoApplication application = (DemoApplication) getApplication();
+    activityGraph = application.getApplicationGraph().plus(getModules().toArray());
+
+    // Inject ourselves so subclasses will have dependencies fulfilled when this method returns.
+    activityGraph.inject(this);
+  }
+
+  @Override protected void onDestroy() {
+    // Eagerly clear the reference to the activity graph to allow it to be garbage collected as
+    // soon as possible.
+    activityGraph = null;
+
+    super.onDestroy();
+  }
+
+  /**
+   * A list of modules to use for the individual activity graph. Subclasses can override this
+   * method to provide additional modules provided they call and include the modules returned by
+   * calling {@code super.getModules()}.
+   */
+  protected List<Object> getModules() {
+    return Arrays.<Object>asList(new ActivityModule(this));
+  }
+
+  /** Inject the supplied {@code object} using the activity-specific graph. */
+  public void inject(Object object) {
+    activityGraph.inject(object);
+  }
+}
/Fim/
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoBaseFragment.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoBaseFragment.java
new file mode 100644
index 0000000..ef7960c
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoBaseFragment.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs;
+
+import android.app.Activity;
+import android.support.v4.app.Fragment;
+
+/** Base fragment which performs injection using the activity object graph of its parent. */
+public class DemoBaseFragment extends Fragment {
+  @Override public void onAttach(Activity activity) {
+    ((DemoBaseActivity) activity).inject(this);
+  }
+}
/Fim/
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ForActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ForActivity.java
new file mode 100644
index 0000000..abd423b
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ForActivity.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs;
+
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Qualifier @Retention(RUNTIME)
+public @interface ForActivity {
+}
/Fim/
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ForApplication.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ForApplication.java
new file mode 100644
index 0000000..585d46b
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ForApplication.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs;
+
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Qualifier @Retention(RUNTIME)
+public @interface ForApplication {
+}
/Fim/
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/ActivityTitleController.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/ActivityTitleController.java
new file mode 100644
index 0000000..f42dbee
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/ActivityTitleController.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs.ui;
+
+import android.app.Activity;
+
+/**
+ * A simple abstraction which provides the ability to set the title on an activity.
+ * <p>
+ * Fragments should not directly modify any part of an activity outside of the view or dialog that
+ * it creates. This class provides a way for fragments to inject a controller that will allow for
+ * control of the activity title. While not exceedingly useful in practice, this concept could be
+ * expanded to things like facilitating control over the action bar, dialogs, notifications, etc.
+ */
+public class ActivityTitleController {
+  private final Activity activity;
+
+  public ActivityTitleController(Activity activity) {
+    this.activity = activity;
+  }
+
+  public void setTitle(CharSequence title) {
+    activity.setTitle(title);
+  }
+}
/Fim/
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
new file mode 100644
index 0000000..36125cf
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs.ui;
+
+import android.location.LocationManager;
+import android.os.Bundle;
+import com.example.dagger.activitygraphs.DemoBaseActivity;
+import javax.inject.Inject;
+
+public class HomeActivity extends DemoBaseActivity {
+  @Inject LocationManager locationManager;
+
+  @Override protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    // After the super.onCreate call returns we are guaranteed our injections are available.
+
+    if (savedInstanceState == null) {
+      getSupportFragmentManager().beginTransaction()
+          .add(android.R.id.content, HomeFragment.newInstance())
+          .commit();
+    }
+
+    // TODO do something with the injected dependencies here!
+  }
+}
/Fim/
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeFragment.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeFragment.java
new file mode 100644
index 0000000..56bbd58
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeFragment.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.activitygraphs.ui;
+
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.TextView;
+import com.example.dagger.activitygraphs.DemoBaseFragment;
+import javax.inject.Inject;
+
+import static android.view.Gravity.CENTER;
+
+public class HomeFragment extends DemoBaseFragment {
+  public static HomeFragment newInstance() {
+    return new HomeFragment();
+  }
+
+  @Inject ActivityTitleController titleController;
+
+  @Override public View onCreateView(LayoutInflater inflater, ViewGroup container,
+      Bundle savedInstanceState) {
+    TextView tv = new TextView(getActivity());
+    tv.setGravity(CENTER);
+    tv.setText("Hello, World");
+    return tv;
+  }
+
+  @Override public void onResume() {
+    super.onResume();
+
+    // Fragments should not modify things outside of their own view. Use an external controller to
+    // ask the activity to change its title.
+    titleController.setTitle("Home Fragment");
+  }
+}
/Fim/
diff --git a/examples/android-simple/AndroidManifest.xml b/examples/android-simple/AndroidManifest.xml
new file mode 100644
index 0000000..8f0fce3
--- /dev/null
+++ b/examples/android-simple/AndroidManifest.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    android:versionCode="1"
+    android:versionName="1.0.0"
+    package="com.example.dagger.simple">
+
+  <uses-sdk android:minSdkVersion="4" android:targetSdkVersion="17"/>
+
+  <application android:label="@string/app_name">
+    <activity
+        android:label="@string/app_name"
+        android:name=".ui.HomeActivity">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+        <category android:name="android.intent.category.LAUNCHER"/>
+        <category android:name="android.intent.category.DEFAULT"/>
+      </intent-filter>
+    </activity>
+  </application>
+</manifest>
/Fim/
diff --git a/examples/android-simple/README.md b/examples/android-simple/README.md
new file mode 100644
index 0000000..2a9c1fe
--- /dev/null
+++ b/examples/android-simple/README.md
@@ -0,0 +1,13 @@
+Example: Android Simple
+=======================
+
+This example demonstrates how to structure an Android application with Dagger.
+
+A custom `Application` class is used to manage a global object graph of objects. Modules are
+assembled with a `getModules` method on the application that can be overridden to add additional
+modules in development versions of your applications or in tests.
+
+Injection of activities is done automatically in a base activity.
+
+_Note: The app does not actually do anything when it is run. It is only to show how you can
+ structure Dagger within an Android app_
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
new file mode 100644
index 0000000..3650700
--- /dev/null
+++ b/examples/android-simple/pom.xml
@@ -0,0 +1,59 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.dagger.example</groupId>
+    <artifactId>dagger-example-parent</artifactId>
+    <version>1.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>android-simple</artifactId>
+  <name>Examples: Android - Simple</name>
+  <packaging>apk</packaging>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.dagger</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.dagger</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
+
+    <dependency>
+      <groupId>com.google.android</groupId>
+      <artifactId>android</artifactId>
+      <scope>provided</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+        <artifactId>android-maven-plugin</artifactId>
+        <extensions>true</extensions>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/examples/android-simple/res/values/strings.xml b/examples/android-simple/res/values/strings.xml
new file mode 100644
index 0000000..7c398f5
--- /dev/null
+++ b/examples/android-simple/res/values/strings.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <string name="app_name">Dagger Simple</string>
+</resources>
/Fim/
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java b/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
new file mode 100644
index 0000000..e6b8aa5
--- /dev/null
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.simple;
+
+import android.content.Context;
+import android.location.LocationManager;
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Singleton;
+
+import static android.content.Context.LOCATION_SERVICE;
+
+/**
+ * A module for Android-specific dependencies which require a {@link Context} or
+ * {@link android.app.Application} to create.
+ */
+@Module(library = true)
+public class AndroidModule {
+  private final DemoApplication application;
+
+  public AndroidModule(DemoApplication application) {
+    this.application = application;
+  }
+
+  /**
+   * Allow the application context to be injected but require that it be annotated with
+   * {@link ForApplication @Annotation} to explicitly differentiate it from an activity context.
+   */
+  @Provides @Singleton @ForApplication Context provideApplicationContext() {
+    return application;
+  }
+
+  @Provides @Singleton LocationManager provideLocationManager() {
+    return (LocationManager) application.getSystemService(LOCATION_SERVICE);
+  }
+}
/Fim/
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
new file mode 100644
index 0000000..8bc75bf
--- /dev/null
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.simple;
+
+import android.app.Application;
+import dagger.ObjectGraph;
+import java.util.Arrays;
+import java.util.List;
+
+public class DemoApplication extends Application {
+  private ObjectGraph graph;
+
+  @Override public void onCreate() {
+    super.onCreate();
+
+    graph = ObjectGraph.create(getModules().toArray());
+  }
+
+  protected List<Object> getModules() {
+    return Arrays.<Object>asList(
+        new AndroidModule(this)
+    );
+  }
+
+  public void inject(Object object) {
+    graph.inject(object);
+  }
+}
/Fim/
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoBaseActivity.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoBaseActivity.java
new file mode 100644
index 0000000..c037ac0
--- /dev/null
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoBaseActivity.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.simple;
+
+import android.app.Activity;
+import android.os.Bundle;
+
+public abstract class DemoBaseActivity extends Activity {
+  @Override protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+
+    // Perform injection so that when this call returns all dependencies will be available for use.
+    ((DemoApplication) getApplication()).inject(this);
+  }
+}
/Fim/
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoModule.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoModule.java
new file mode 100644
index 0000000..33d7278
--- /dev/null
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.simple;
+
+import com.example.dagger.simple.ui.HomeActivity;
+import dagger.Module;
+
+@Module(
+    injects = HomeActivity.class,
+    complete = false
+)
+public class DemoModule {
+  // TODO put your application-specific providers here!
+}
/Fim/
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/ForApplication.java b/examples/android-simple/src/main/java/com/example/dagger/simple/ForApplication.java
new file mode 100644
index 0000000..84d2247
--- /dev/null
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/ForApplication.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.simple;
+
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Qualifier @Retention(RUNTIME)
+public @interface ForApplication {
+}
/Fim/
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java b/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
new file mode 100644
index 0000000..5c22127
--- /dev/null
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.dagger.simple.ui;
+
+import android.location.LocationManager;
+import android.os.Bundle;
+import com.example.dagger.simple.DemoBaseActivity;
+import javax.inject.Inject;
+
+public class HomeActivity extends DemoBaseActivity {
+  @Inject LocationManager locationManager;
+
+  @Override protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    // After the super.onCreate call returns we are guaranteed our injections are available.
+
+    // TODO do something with the injected dependencies here!
+  }
+}
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index fe0346f..875aab5 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -27,9 +27,58 @@
   <groupId>com.squareup.dagger.example</groupId>
   <artifactId>dagger-example-parent</artifactId>
   <packaging>pom</packaging>
-  <name>Dagger Example (Parent)</name>
+  <name>Examples</name>
 
   <modules>
     <module>simple</module>
   </modules>
+
+  <!-- Travis CI currently has a problem building Android so we disable this profile -->
+  <profiles>
+    <profile>
+      <id>android</id>
+      <activation>
+        <activeByDefault>true</activeByDefault>
+      </activation>
+      <modules>
+        <module>simple</module>
+        <module>android-simple</module>
+        <module>android-activity-graphs</module>
+      </modules>
+    </profile>
+  </profiles>
+
+  <!-- Example-only dependencies. -->
+  <dependencyManagement>
+    <dependencies>
+      <dependency>
+        <groupId>com.google.android</groupId>
+        <artifactId>android</artifactId>
+        <version>4.1.1.4</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.android</groupId>
+        <artifactId>support-v4</artifactId>
+        <version>r7</version>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <!-- Example-only plugins -->
+  <build>
+    <pluginManagement>
+      <plugins>
+        <plugin>
+          <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+          <artifactId>android-maven-plugin</artifactId>
+          <version>3.5.3</version>
+          <configuration>
+            <sdk>
+              <platform>16</platform>
+            </sdk>
+          </configuration>
+        </plugin>
+      </plugins>
+    </pluginManagement>
+  </build>
 </project>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 0a25a1a..5e11afa 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -23,8 +23,8 @@
     <version>1.0-SNAPSHOT</version>
   </parent>
 
-  <artifactId>simple-dagger-example</artifactId>
-  <name>Dagger Example - Simple</name>
+  <artifactId>simple</artifactId>
+  <name>Examples: Simple</name>
 
   <dependencies>
     <dependency>
@@ -39,16 +39,4 @@
       <optional>true</optional>
     </dependency>
   </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <configuration>
-          <compilerArgument>-Xlint:all</compilerArgument>
-          <showWarnings>true</showWarnings>
-          <showDeprecation>true</showDeprecation>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
 </project>
/Fim/
diff --git a/pom.xml b/pom.xml
index 67689a0..49bd024 100644
--- a/pom.xml
+++ b/pom.xml
@@ -100,11 +100,26 @@
   </dependencyManagement>
 
   <build>
+    <pluginManagement>
+      <plugins>
+        <plugin>
+          <groupId>org.apache.maven.plugins</groupId>
+          <artifactId>maven-invoker-plugin</artifactId>
+          <version>1.7</version>
+        </plugin>
+
+        <plugin>
+          <groupId>org.apache.maven.plugins</groupId>
+          <artifactId>maven-compiler-plugin</artifactId>
+          <version>3.1</version>
+        </plugin>
+      </plugins>
+    </pluginManagement>
+
     <plugins>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>2.5</version>
         <configuration>
           <source>${java.version}</source>
           <target>${java.version}</target>
@@ -142,15 +157,5 @@
         </executions>
       </plugin>
     </plugins>
-
-    <pluginManagement>
-      <plugins>
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-invoker-plugin</artifactId>
-          <version>1.7</version>
-        </plugin>
-      </plugins>
-    </pluginManagement>
   </build>
 </project>
/Fim/
/Fim/
/Fim/
/Fim/
diff --git a/website/index.html b/website/index.html
index cd42c13..eae44f0 100644
--- a/website/index.html
+++ b/website/index.html
@@ -1,32 +1,71 @@
----
-layout: default
----
+<!DOCTYPE html>
+<html lang="en">
+  <head>
+    <meta charset="utf-8">
+    <title>Dagger</title>
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <meta name="description" content="A fast dependency injector for Android and Java">
+    <link href="static/bootstrap-combined.min.css" rel="stylesheet">
+    <link href="static/app.css" rel="stylesheet">
+    <link href="static/app-theme.css" rel="stylesheet">
+    <link href="http://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet" type="text/css">
+    <!--[if lt IE 9]><script src="static/html5shiv.min.js"></script><![endif]-->
+  </head>
+  <body data-target=".content-nav">
+    <header>
+      <div class="container">
+        <div class="row">
+          <div class="span5">
+            <h1>Dagger</h1>
+          </div>
+          <div class="span7">
+            <menu>
+              <ul>
+                <li><a href="#download" class="menu download">Download <span class="version-tag">Latest</span></a></li>
+                <li><a href="http://github.com/square/dagger" data-title="View GitHub Project" class="menu github"><img src="static/icon-github.png" alt="GitHub"/></a></li>
+                <li><a href="http://square.github.io/" data-title="Square Open Source Portal" class="menu square"><img src="static/icon-square.png" alt="Square"/></a></li>
+              </ul>
+            </menu>
+          </div>
+      </div>
+    </header>
+    <section id="subtitle">
+      <div class="container">
+        <div class="row">
+          <div class="span12">
+            <h2>A fast <strong>dependency injector</strong> for Android and Java</h2>
+          </div>
+        </div>
+      </div>
+    </section>
+    <section id="body">
+      <div class="container">
+        <div class="row">
+          <div class="span9">
+            <h3 id="introduction">Introduction</h3>
 
-<h3>Introduction</h3>
+            <p>The best classes in any application are the ones that do stuff: the <code>BarcodeDecoder</code>, the <code>KoopaPhysicsEngine</code>, and the <code>AudioStreamer</code>. These classes have dependencies; perhaps a <code>BarcodeCameraFinder</code>, <code>DefaultPhysicsEngine</code>, and an <code>HttpStreamer</code>.</p>
 
-<p>The best classes in any application are the ones that do stuff: the <code>BarcodeDecoder</code>, the <code>KoopaPhysicsEngine</code>, and the <code>AudioStreamer</code>. These classes have dependencies; perhaps a <code>BarcodeCameraFinder</code>, <code>DefaultPhysicsEngine</code>, and an <code>HttpStreamer</code>.</p>
+            <p>To contrast, the worst classes in any application are the ones that take up space without doing much at all: the <code>BarcodeDecoderFactory</code>, the <code>CameraServiceLoader</code>, and the <code>MutableContextWrapper</code>. These classes are the clumsy duct tape that wires the interesting stuff together.</p>
 
-<p>To contrast, the worst classes in any application are the ones that take up space without doing much at all: the <code>BarcodeDecoderFactory</code>, the <code>CameraServiceLoader</code>, and the <code>MutableContextWrapper</code>. These classes are the clumsy duct tape that wires the interesting stuff together.</p>
+            <p>Dagger is a replacement for these <code>FactoryFactory</code> classes. It allows you to focus on the interesting classes. Declare dependencies, specify how to satisfy them, and ship your app.</p>
 
-<p>Dagger is a replacement for these <code>FactoryFactory</code> classes. It allows you to focus on the interesting classes. Declare dependencies, specify how to satisfy them, and ship your app.</p>
+            <p>By building on standard <a href="http://atinject.googlecode.com/svn/trunk/javadoc/javax/inject/package-summary.html">javax.inject</a> annotations (JSR-330), each class is <strong>easy to test</strong>. You don't need a bunch of boilerplate just to swap the <code>RpcCreditCardService</code> out for a <code>FakeCreditCardService</code>.</p>
 
-<p>By building on standard <a href="http://atinject.googlecode.com/svn/trunk/javadoc/javax/inject/package-summary.html">javax.inject</a> annotations (JSR-330), each class is <strong>easy to test</strong>. You don't need a bunch of boilerplate just to swap the <code>RpcCreditCardService</code> out for a <code>FakeCreditCardService</code>.</p>
+            <p>Dependency injection isn't just for testing. It also makes it easy to create <strong>reusable, interchangeable modules</strong>. You can share the same <code>AuthenticationModule</code>  across all of your apps. And you can run <code>DevLoggingModule</code> during development and <code>ProdLoggingModule</code> in production to get the right behavior in each situation.</p>
 
-<p>Dependency injection isn't just for testing. It also makes it easy to create <strong>reusable, interchangeable modules</strong>. You can share the same <code>AuthenticationModule</code>  across all of your apps. And you can run <code>DevLoggingModule</code> during development and <code>ProdLoggingModule</code> in production to get the right behavior in each situation.</p>
+            <p>For more information, <a href="http://www.infoq.com/presentations/Dagger">watch an introductory talk</a> by Jesse Wilson at QCon 2012.</p>
 
-<p>For more information, <a href="http://www.infoq.com/presentations/Dagger">watch an introductory talk</a> by Jesse Wilson at QCon 2012.</p>
+            <h3 id="using">Using Dagger</h3>
+            <p>We'll demonstrate dependency injection and Dagger by building a coffee maker. For complete sample code that you can compile and run, see Dagger's <a href="https://github.com/square/dagger/tree/master/examples/simple/src/main/java/coffee">coffee example</a>.</p>
 
-<h3>Using Dagger</h3>
-<p>We'll demonstrate dependency injection and Dagger by building a coffee maker. For complete sample code that you can compile and run, see Dagger's <a href="https://github.com/square/dagger/tree/master/examples/simple/src/main/java/coffee">coffee example</a>.</p>
+            <h4>Declaring Dependencies</h4>
 
-<h4>Declaring Dependencies</h4>
+            <p>Dagger constructs instances of your application classes and satisfies their dependencies. It uses the <code>javax.inject.Inject</code> annotation to identify which constructors and fields it is interested in.</p>
 
-<p>Dagger constructs instances of your application classes and satisfies their dependencies. It uses the <code>javax.inject.Inject</code> annotation to identify which constructors and fields it is interested in.</p>
+            <p>Use <code>@Inject</code> to annotate the constructor that Dagger should use to create instances of a class. When a new instance is requested, Dagger will obtain the required parameters values and invoke this constructor.</p>
 
-<p>Use <code>@Inject</code> to annotate the constructor that Dagger should use to create instances of a class. When a new instance is requested, Dagger will obtain the required parameters values and invoke this constructor.</p>
-
-<pre class="prettyprint">
-class Thermosiphon implements Pump {
+            <pre class="prettyprint">class Thermosiphon implements Pump {
   private final Heater heater;
 
   @Inject
@@ -35,58 +74,50 @@
   }
 
   ...
-}
-</pre>
+}</pre>
 
-<p>Dagger can inject fields directly. In this example it obtains a <code>Heater</code> instance for the <code>heater</code> field and a <code>Pump</code> instance for the <code>pump</code> field.</p>
+            <p>Dagger can inject fields directly. In this example it obtains a <code>Heater</code> instance for the <code>heater</code> field and a <code>Pump</code> instance for the <code>pump</code> field.</p>
 
-<pre class="prettyprint">
-class CoffeeMaker {
+            <pre class="prettyprint">class CoffeeMaker {
   @Inject Heater heater;
   @Inject Pump pump;
 
   ...
-}
-</pre>
+}</pre>
 
-<p>If your class has <code>@Inject</code>-annotated fields but no <code>@Inject</code>-annotated constructor, Dagger will use a no-argument constructor if it exists. Classes that lack <code>@Inject</code> annotations cannot be constructed by Dagger.</p>
+            <p>If your class has <code>@Inject</code>-annotated fields but no <code>@Inject</code>-annotated constructor, Dagger will use a no-argument constructor if it exists. Classes that lack <code>@Inject</code> annotations cannot be constructed by Dagger.</p>
 
-<p>Dagger does not support method injection.</p>
+            <p>Dagger does not support method injection.</p>
 
-<h4>Satisfying Dependencies</h4>
+            <h4>Satisfying Dependencies</h4>
 
-<p>By default, Dagger satisfies each dependency by constructing an instance of the requested type as described above. When you request a <code>CoffeeMaker</code>, it'll obtain one by calling <code>new CoffeeMaker()</code> and setting its injectable fields.</p>
+            <p>By default, Dagger satisfies each dependency by constructing an instance of the requested type as described above. When you request a <code>CoffeeMaker</code>, it'll obtain one by calling <code>new CoffeeMaker()</code> and setting its injectable fields.</p>
 
-<p>But <code>@Inject</code> doesn't work everywhere:</p>
+            <p>But <code>@Inject</code> doesn't work everywhere:</p>
 
-<ul>
-  <li>Interfaces can't be constructed.</li>
-  <li>Third-party classes can't be annotated.</li>
-  <li>Configurable objects must be configured!</li>
-</ul>
+            <ul>
+                <li>Interfaces can't be constructed.</li>
+                <li>Third-party classes can't be annotated.</li>
+                <li>Configurable objects must be configured!</li>
+            </ul>
 
-<p>For these cases where <code>@Inject</code> is insufficient or awkward, use an <code>@Provides</code>-annotated method to satisfy a dependency. The method's return type defines which dependency it satisfies.</p>
+            <p>For these cases where <code>@Inject</code> is insufficient or awkward, use an <code>@Provides</code>-annotated method to satisfy a dependency. The method's return type defines which dependency it satisfies.</p>
 
-<p>For example, <code>provideHeater()</code> is invoked whenever a <code>Heater</code> is required:</p>
+            <p>For example, <code>provideHeater()</code> is invoked whenever a <code>Heater</code> is required:</p>
 
-<pre class="prettyprint">
-@Provides Heater provideHeater() {
+            <pre class="prettyprint">@Provides Heater provideHeater() {
   return new ElectricHeater();
-}
-</pre>
+}</pre>
 
-<p>It's possible for <code>@Provides</code> methods to have dependencies of their own. This one returns a <code>Thermosiphon</code> whenever a <code>Pump</code> is required:</p>
+            <p>It's possible for <code>@Provides</code> methods to have dependencies of their own. This one returns a <code>Thermosiphon</code> whenever a <code>Pump</code> is required:</p>
 
-<pre class="prettyprint">
-@Provides Pump providePump(Thermosiphon pump) {
+            <pre class="prettyprint">@Provides Pump providePump(Thermosiphon pump) {
   return pump;
-}
-</pre>
+}</pre>
 
-<p>All <code>@Provides</code> methods must belong to a module. These are just classes that have an <code>@Module</code> annotation.</p>
+            <p>All <code>@Provides</code> methods must belong to a module. These are just classes that have an <code>@Module</code> annotation.</p>
 
-<pre class="prettyprint">
-@Module
+<pre class="prettyprint">@Module
 class DripCoffeeModule {
   @Provides Heater provideHeater() {
     return new ElectricHeater();
@@ -95,23 +126,19 @@
   @Provides Pump providePump(Thermosiphon pump) {
     return pump;
   }
-}
-</pre>
+}</pre>
 
-<p>By convention, <code>@Provides</code> methods are named with a <code>provide</code> prefix and module classes are named with a <code>Module</code> suffix.</p>
+            <p>By convention, <code>@Provides</code> methods are named with a <code>provide</code> prefix and module classes are named with a <code>Module</code> suffix.</p>
 
-<h4>Building the Graph</h4>
+            <h4>Building the Graph</h4>
 
-<p>The <code>@Inject</code> and <code>@Provides</code>-annotated classes form a graph of objects, linked by their dependencies. Obtain this graph by calling <code>ObjectGraph.create()</code>, which accepts one or more modules:</p>
+            <p>The <code>@Inject</code> and <code>@Provides</code>-annotated classes form a graph of objects, linked by their dependencies. Obtain this graph by calling <code>ObjectGraph.create()</code>, which accepts one or more modules:</p>
 
-<pre class="prettyprint">
-ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());
-</pre>
+            <pre class="prettyprint">ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());</pre>
 
-<p>In order to put the graph to use we need to <strong>bootstrap injection</strong>. This usually requires injecting the main class of a command line app, or the activity classes of an Android app. In our coffee example, the <code>CoffeeApp</code> class is used to start dependency injection. We ask the graph to provide an injected instance of the class:</p>
+            <p>In order to put the graph to use we need to <strong>bootstrap injection</strong>. This usually requires injecting the main class of a command line app, or the activity classes of an Android app. In our coffee example, the <code>CoffeeApp</code> class is used to start dependency injection. We ask the graph to provide an injected instance of the class:</p>
 
-<pre class="prettyprint">
-class CoffeeApp implements Runnable {
+            <pre class="prettyprint">class CoffeeApp implements Runnable {
   @Inject CoffeeMaker coffeeMaker;
 
   @Override public void run() {
@@ -123,56 +150,46 @@
     CoffeeApp coffeeApp = objectGraph.get(CoffeeApp.class);
     ...
   }
-}
-</pre>
+}</pre>
 
-<p>The only thing that's missing is that the injectable class <code>CoffeeApp</code> isn't known by the graph. We need to explicitly register it as an injected type in the <code>@Module</code> annotation.</p>
+            <p>The only thing that's missing is that the injectable class <code>CoffeeApp</code> isn't known by the graph. We need to explicitly register it as an injected type in the <code>@Module</code> annotation.</p>
 
-<pre class="prettyprint">
-@Module(
-    injects = { CoffeeApp.class }
+            <pre class="prettyprint">@Module(
+    injects = CoffeeApp.class
 )
 class DripCoffeeModule {
   ...
-}
-</pre>
+}</pre>
 
-<p>The <code>injects</code> option enables the complete graph to be validated <strong>at compile time</strong>. Detecting problems early speeds up development and takes some of the danger out of refactoring.</p>
+            <p>The <code>injects</code> option enables the complete graph to be validated <strong>at compile time</strong>. Detecting problems early speeds up development and takes some of the danger out of refactoring.</p>
 
-<p>Now that the graph is constructed and the root object is injected, we run our coffee maker app. Fun.</p>
+            <p>Now that the graph is constructed and the root object is injected, we run our coffee maker app. Fun.</p>
 
-<pre>
-$ java -cp ... coffee.CoffeeApp
+            <pre>$ java -cp ... coffee.CoffeeApp
 ~ ~ ~ heating ~ ~ ~
 =&gt; =&gt; pumping =&gt; =&gt;
- [_]P coffee! [_]P
-</pre>
+ [_]P coffee! [_]P</pre>
 
-<h4>Singletons</h4>
+            <h4>Singletons</h4>
 
-<p>Annotate an <code>@Provides</code> method or injectable class with <code>@Singleton</code>. The graph will use a single instance of the value for all of its clients.</p>
+            <p>Annotate an <code>@Provides</code> method or injectable class with <code>@Singleton</code>. The graph will use a single instance of the value for all of its clients.</p>
 
-<pre class="prettyprint">
-@Provides @Singleton Heater provideHeater() {
+            <pre class="prettyprint">@Provides @Singleton Heater provideHeater() {
   return new ElectricHeater();
-}
-</pre>
+}</pre>
 
-<p>The <code>@Singleton</code> annotation on an injectable class also serves as documentation. It reminds potential maintainers that this class may be shared by multiple threads.</p>
+            <p>The <code>@Singleton</code> annotation on an injectable class also serves as documentation. It reminds potential maintainers that this class may be shared by multiple threads.</p>
 
-<pre class="prettyprint">
-@Singleton
+            <pre class="prettyprint">@Singleton
 class CoffeeMaker {
   ...
-}
-</pre>
+}</pre>
 
-<h4>Lazy injections</h4>
+            <h4>Lazy injections</h4>
 
-<p>Sometimes you need an object to be instantiated lazily.  For any binding <code>T</code>, you can create a <code>Lazy&lt;T></code> which defers instantiation until the first call to <code>Lazy&lt;T></code>'s <code>get()</code> method. If <code>T</code> is a singleton, then <code>Lazy&lt;T></code> will be the same instance for all injections within the <code>ObjectGraph</code>.  Otherwise, each injection site will get its own <code>Lazy&lt;T></code> instance.  Regardless, subsequent calls to any given instance of <code>Lazy&lt;T></code> will return the same underlying instance of <code>T</code>.</p>
+            <p>Sometimes you need an object to be instantiated lazily.  For any binding <code>T</code>, you can create a <code>Lazy&lt;T></code> which defers instantiation until the first call to <code>Lazy&lt;T></code>'s <code>get()</code> method. If <code>T</code> is a singleton, then <code>Lazy&lt;T></code> will be the same instance for all injections within the <code>ObjectGraph</code>.  Otherwise, each injection site will get its own <code>Lazy&lt;T></code> instance.  Regardless, subsequent calls to any given instance of <code>Lazy&lt;T></code> will return the same underlying instance of <code>T</code>.</p>
 
-<pre class="prettyprint">
-class GridingCoffeeMaker {
+            <pre class="prettyprint">class GridingCoffeeMaker {
   @Inject Lazy&lt;Grinder&gt; lazyGrinder;
 
   public void brew() {
@@ -181,20 +198,17 @@
       lazyGrinder.get().grind();
     }
   }
-}
-</pre>
+}</pre>
 
-<h4>Provider injections</h4>
+            <h4>Provider injections</h4>
 
-<p>Sometimes you need multiple instances to be returned instead of just injecting a single value.  While you have several options (Factories, Builders, etc.)   one option is to inject a <code>Provider&lt;T></code> instead of just <code>T</code>.  A <code>Provider&lt;T></code> creates a new instance of <code>T</code> each time <code>.get()</code> is called.</p>
+            <p>Sometimes you need multiple instances to be returned instead of just injecting a single value.  While you have several options (Factories, Builders, etc.)   one option is to inject a <code>Provider&lt;T></code> instead of just <code>T</code>.  A <code>Provider&lt;T></code> creates a new instance of <code>T</code> each time <code>.get()</code> is called.</p>
 
-<pre class="prettyprint">
-
-class BigCoffeeMaker {
+            <pre class="prettyprint">class BigCoffeeMaker {
   @Inject Provider&lt;Filter&gt; filterProvider;
 
   public void brew(int numberOfPots) {
-	...
+    ...
     for (int p = 0; p &lt; numberOfPots; p++) {
       maker.addFilter(filterProvider.get()); //new filter every time.
       maker.addCoffee(...);
@@ -202,130 +216,110 @@
       ...
     }
   }
-}
-</pre>
+}</pre>
 
-<p><span class="label label-inverse">Note:</span><em> Injecting <code>Provider&lt;T></code> has the possibility of creating confusing code, and may be a design smell of mis-scoped or mis-structured objects in your graph.  Often you will want to use a <code>Factory&lt;T></code> or a <code>Lazy&lt;T></code> or re-organize the lifetimes and structure of your code to be able to just inject a <code>T</code>.  Injecting <code>Provider&lt;T></code> can, however, be a life saver in some cases.  A common use is when you must use a legacy architecture that doesn't line up with your object's natural lifetimes (e.g. servlets are singletons by design, but only are valid in the context of request-specfic data).</em></p>
+            <p><span class="label">Note:</span><em> Injecting <code>Provider&lt;T></code> has the possibility of creating confusing code, and may be a design smell of mis-scoped or mis-structured objects in your graph.  Often you will want to use a <code>Factory&lt;T></code> or a <code>Lazy&lt;T></code> or re-organize the lifetimes and structure of your code to be able to just inject a <code>T</code>.  Injecting <code>Provider&lt;T></code> can, however, be a life saver in some cases.  A common use is when you must use a legacy architecture that doesn't line up with your object's natural lifetimes (e.g. servlets are singletons by design, but only are valid in the context of request-specfic data).</em></p>
 
-<h4>Qualifiers</h4>
+            <h4>Qualifiers</h4>
 
-<p>Sometimes the type alone is insufficient to identify a dependency. For example, a sophisticated coffee maker app may want separate heaters for the water and the hot plate.</p>
+            <p>Sometimes the type alone is insufficient to identify a dependency. For example, a sophisticated coffee maker app may want separate heaters for the water and the hot plate.</p>
 
-<p>In this case, we add a <strong>qualifier annotation</strong>. This is any annotation that itself has a <code>@Qualifier</code> annotation. Here's the declaration of <code>@Named</code>, a qualifier annotation included in <code>javax.inject</code>:</p>
+            <p>In this case, we add a <strong>qualifier annotation</strong>. This is any annotation that itself has a <code>@Qualifier</code> annotation. Here's the declaration of <code>@Named</code>, a qualifier annotation included in <code>javax.inject</code>:</p>
 
-<pre class="prettyprint">
-@Qualifier
+            <pre class="prettyprint">@Qualifier
 @Documented
 @Retention(RUNTIME)
 public @interface Named {
   String value() default "";
-}
-</pre>
+}</pre>
 
-<p>You can create your own qualifier annotations, or just use <code>@Named</code>. Apply qualifiers by annotating the field or parameter of interest. The type and qualifier annotation will both be used to identify the dependency.</p>
+            <p>You can create your own qualifier annotations, or just use <code>@Named</code>. Apply qualifiers by annotating the field or parameter of interest. The type and qualifier annotation will both be used to identify the dependency.</p>
 
-<pre class="prettyprint">
-class ExpensiveCoffeeMaker {
+            <pre class="prettyprint">class ExpensiveCoffeeMaker {
   @Inject @Named("water") Heater waterHeater;
   @Inject @Named("hot plate") Heater hotPlateHeater;
   ...
-}
-</pre>
+}</pre>
 
-<p>Supply qualified values by annotating the corresponding <code>@Provides</code> method.</p>
+            <p>Supply qualified values by annotating the corresponding <code>@Provides</code> method.</p>
 
-<pre class="prettyprint">
-@Provides @Named("hot plate") Heater provideHotPlateHeater() {
+            <pre class="prettyprint">@Provides @Named("hot plate") Heater provideHotPlateHeater() {
   return new ElectricHeater(70);
 }
 
 @Provides @Named("water") Heater provideWaterHeater() {
   return new ElectricHeater(93);
-}
-</pre>
+}</pre>
 
-<p>Dependencies may not have multiple qualifier annotations.</p>
+            <p>Dependencies may not have multiple qualifier annotations.</p>
 
-<h4>Static Injection</h4>
+            <h4>Static Injection</h4>
 
-<p><span class="label label-important">Warning:</span> This feature should be used sparingly because static dependencies are difficult to test and reuse.</p>
+            <p><span class="label label-important">Warning:</span> This feature should be used sparingly because static dependencies are difficult to test and reuse.</p>
 
-<p>Dagger can inject static fields. Classes that declare static fields with <code>@Inject</code> annotations must be listed as <code>staticInjections</code> in a module annotation.</p>
+            <p>Dagger can inject static fields. Classes that declare static fields with <code>@Inject</code> annotations must be listed as <code>staticInjections</code> in a module annotation.</p>
 
-<pre class="prettyprint">
-@Module(
+            <pre class="prettyprint">@Module(
     staticInjections = LegacyCoffeeUtils.class
 )
 class LegacyModule {
-}
-</pre>
+}</pre>
 
-<p>Use <code>ObjectGraph.injectStatics()</code> to populate these static fields with their injected values:</p>
+            <p>Use <code>ObjectGraph.injectStatics()</code> to populate these static fields with their injected values:</p>
 
-<pre class="prettyprint">
-ObjectGraph objectGraph = ObjectGraph.create(new LegacyModule());
-objectGraph.injectStatics();
-</pre>
+            <pre class="prettyprint">ObjectGraph objectGraph = ObjectGraph.create(new LegacyModule());
+objectGraph.injectStatics();</pre>
 
-<h4>Compile-time Validation</h4>
+            <h4>Compile-time Validation</h4>
 
-<p>Dagger includes an <a href="http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html">annotation processor</a> that validates modules and injections. This processor is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is missing a binding for <code>Executor</code>:</p>
+            <p>Dagger includes an <a href="http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html">annotation processor</a> that validates modules and injections. This processor is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is missing a binding for <code>Executor</code>:</p>
 
-<pre class="prettyprint">
-@Module
+            <pre class="prettyprint">@Module
 class DripCoffeeModule {
   @Provides Heater provideHeater(Executor executor) {
     return new CpuHeater(executor);
   }
-}
-</pre>
+}</pre>
 
-<p>When compiling it, <code>javac</code> rejects the missing binding:</p>
+            <p>When compiling it, <code>javac</code> rejects the missing binding:</p>
 
-<pre>
-[ERROR] COMPILATION ERROR :
+            <pre>[ERROR] COMPILATION ERROR :
 [ERROR] error: No binding for java.util.concurrent.Executor
-               required by provideHeater(java.util.concurrent.Executor)
-</pre>
+               required by provideHeater(java.util.concurrent.Executor)</pre>
 
-<p>Fix the problem either by adding an <code>@Provides</code>-annotated method for <code>Executor</code>, or by marking the module as incomplete. Incomplete modules are permitted to have missing dependencies.</p>
+            <p>Fix the problem either by adding an <code>@Provides</code>-annotated method for <code>Executor</code>, or by marking the module as incomplete. Incomplete modules are permitted to have missing dependencies.</p>
 
-<pre class="prettyprint">
-@Module(complete = false)
+            <pre class="prettyprint">@Module(complete = false)
 class DripCoffeeModule {
   @Provides Heater provideHeater(Executor executor) {
     return new CpuHeater(executor);
   }
-}
-</pre>
+}</pre>
 
-<p>To get the most out of compile-time validation, create a module that includes all of your application's modules. The annotation processor will detect problems across the modules and report them.</p>
+            <p>To get the most out of compile-time validation, create a module that includes all of your application's modules. The annotation processor will detect problems across the modules and report them.</p>
 
-<pre class="prettyprint">
-@Module(
+            <pre class="prettyprint">@Module(
     includes = {
         DripCoffeeModule.class,
         ExecutorModule.class
     }
 )
 public class CoffeeAppModule {
-}
-</pre>
+}</pre>
 
-<p>The annotation processor is enabled automatically when you include Dagger's jar file on your compile classpath.</p>
+            <p>The annotation processor is enabled automatically when you include Dagger's jar file on your compile classpath.</p>
 
-<h4>Compile-time Code Generation</h4>
+            <h4>Compile-time Code Generation</h4>
 
-<p>Dagger's annotation processor may also generate source files with names like <code>CoffeeMaker$InjectAdapter.java</code> or <code>DripCoffeeModule$ModuleAdapter</code>. These files are Dagger implementation details. You shouldn't need to use them directly, though they can be handy when step-debugging through an injection.</p>
+            <p>Dagger's annotation processor may also generate source files with names like <code>CoffeeMaker$InjectAdapter.java</code> or <code>DripCoffeeModule$ModuleAdapter</code>. These files are Dagger implementation details. You shouldn't need to use them directly, though they can be handy when step-debugging through an injection.</p>
 
-<h4>Module overrides</h4>
+            <h4>Module overrides</h4>
 
-<p>Dagger will fail with an error if there are multiple competing <code>@Provides</code> methods for the same dependency. But sometimes it's necessary to replace production code with a substitute for development or testing. Using <code>overrides = true</code> in a module annotation lets you take precedence over the bindings of other modules.</p>
+            <p>Dagger will fail with an error if there are multiple competing <code>@Provides</code> methods for the same dependency. But sometimes it's necessary to replace production code with a substitute for development or testing. Using <code>overrides = true</code> in a module annotation lets you take precedence over the bindings of other modules.</p>
 
-<p>This JUnit test overrides <code>DripCoffeeModule</code>'s binding for <code>Heater</code> with a mock object from <a href="http://mockito.googlecode.com/">Mockito</a>. The mock gets injected into the <code>CoffeeMaker</code> and also into the test.</p>
+            <p>This JUnit test overrides <code>DripCoffeeModule</code>'s binding for <code>Heater</code> with a mock object from <a href="http://mockito.googlecode.com/">Mockito</a>. The mock gets injected into the <code>CoffeeMaker</code> and also into the test.</p>
 
-<pre class="prettyprint">
-public class CoffeeMakerTest {
+            <pre class="prettyprint">public class CoffeeMakerTest {
   @Inject CoffeeMaker coffeeMaker;
   @Inject Heater heater;
 
@@ -350,57 +344,52 @@
     Mockito.verify(heater, Mockito.times(1)).on();
     Mockito.verify(heater, Mockito.times(1)).off();
   }
-}
-</pre>
+}</pre>
 
-<p>Overrides are best suited for small variations on the application:</p>
-<ul>
-  <li>Replacing the real implementation with a mock for unit tests.</li>
-  <li>Replacing LDAP authentication with fake authentication for development.</li>
-</ul>
+            <p>Overrides are best suited for small variations on the application:</p>
+            <ul>
+                <li>Replacing the real implementation with a mock for unit tests.</li>
+                <li>Replacing LDAP authentication with fake authentication for development.</li>
+            </ul>
 
-<p>For more substantial variations it's often simpler to use a different combination of modules.</p>
+            <p>For more substantial variations it's often simpler to use a different combination of modules.</p>
 
+            <h3 id="download">Download</h3>
+            <p><a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.dagger&a=dagger-core&v=LATEST" class="dl core-version-href">&darr; <span class="version-tag">Latest</span> JAR</a> <a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.dagger&a=dagger-compiler&v=LATEST" class="dl compiler-version-href">&darr; <span class="version-tag">Latest</span> Compiler JAR</a></p>
+            <p>You will need to include the Dagger JAR in your application's runtime.  In order to activate code generation you will need to include the compiler JAR in your build at compile time.</p>
+            <p>The source code to the Dagger, its samples, and this website is <a href="http://github.com/square/okhttp">available on GitHub</a>.</p>
 
-<h3>Using Dagger In Your Build</h3>
-
-<p>You will need to include the <code>dagger-${dagger.version}.jar</code> in your application's runtime.  In order to activate code generation you will need to include <code>dagger-compiler-${dagger.version}.jar</code> in your build at compile time.</p>
-
-<p>In a Maven project, one would include the runtime in the dependencies section of your <code>pom.xml</code> (replacing <code>${dagger.version}</code> with the appropriate current release), and the <code>dagger-compiler</code> artifact as an "optional" or "provided" dependency:</p>
-
-<pre class="prettyprint">
-&lt;dependencies>
-  &lt;dependency>
-    &lt;groupId>com.squareup&lt;/groupId>
-    &lt;artifactId>dagger&lt;/artifactId>
-    &lt;version>${dagger.version}&lt;/version>
-  &lt;/dependency>
+            <h4>Maven</h4>
+            <pre class="prettyprint">&lt;dependency>
+  &lt;groupId>com.squareup.dagger&lt;/groupId>
+  &lt;artifactId>dagger&lt;/artifactId>
+  &lt;version><em class="version">(insert latest version)</em>&lt;/version>
+&lt;/dependency>
   &lt;dependency>
     &lt;groupId>com.squareup&lt;/groupId>
     &lt;artifactId>dagger-compiler&lt;/artifactId>
-    &lt;version>${dagger.version}&lt;/version>
+    &lt;version><em class="version">(insert latest version)</em>&lt;/version>
     &lt;optional>true&lt;/optional>
   &lt;/dependency>
-&lt;/dependencies>
-</pre>
+&lt;/dependencies></pre>
 
+            <h3 id="upgrading">Upgrading from Guice</h3>
 
+            <p>Some notable Guice features that Dagger doesn't support:</p>
+            <ul>
+                <li>Injecting <code>final</code> fields and <code>private</code> members. For best performance Dagger generates code. Work around this by using constructor injection.</li>
+                <li>Eager singletons. Work around this by creating an <code>EagerSingletons</code> class that declares static fields for each eager singleton.</li>
+                <li>Method injection.</li>
+                <li>Classes that lack <code>@Inject</code> annotations cannot be constructed by Dagger, even if they have a no-argument constructor.</li>
+            </ul>
 
-<h3>Upgrading from Guice</h3>
+            <h3 id="contributing">Contributing</h3>
+            <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
+            <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
+            <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
 
-<p>Some notable Guice features that Dagger doesn't support:</p>
-<ul>
-  <li>Injecting <code>final</code> fields and <code>private</code> members. For best performance Dagger generates code. Work around this by using constructor injection.</li>
-  <li>Eager singletons. Work around this by creating an <code>EagerSingletons</code> class that declares static fields for each eager singleton.</li>
-  <li>Method injection.</li>
-  <li>Classes that lack <code>@Inject</code> annotations cannot be constructed by Dagger, even if they have a no-argument constructor.</li>
-</ul>
-
-
-<h3>License</h3>
-
-<pre>
-Copyright 2012 Square, Inc.
+            <h3 id="license">License</h3>
+            <pre>Copyright 2013 Square, Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -412,5 +401,70 @@
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
-limitations under the License.
-</pre>
+limitations under the License.</pre>
+          </div>
+          <div class="span3">
+            <div class="content-nav" data-spy="affix" data-offset-top="80">
+              <ul class="nav nav-tabs nav-stacked primary">
+                <li><a href="#introduction">Introduction</a></li>
+                <li><a href="#using">Using Dagger</a></li>
+                <li><a href="#download">Download</a></li>
+                <li><a href="#upgrading">Upgrading from Guice</a></li>
+                <li><a href="#contributing">Contributing</a></li>
+                <li><a href="#license">License</a></li>
+              </ul>
+              <ul class="nav nav-pills nav-stacked secondary">
+                <li><a href="#">Javadoc</a></li>
+                <li><a href="https://groups.google.com/forum/#!forum/dagger-discuss">dagger-discuss@</a></li>
+                <li><a href="https://plus.google.com/communities/109244258569782858265/stream/bab12891-7685-4e0c-8dcb-f85cd0ca31c0">Google+</a></li>
+              </ul>
+            </div>
+          </div>
+        </div>
+        <div class="row">
+          <div class="span12 logo">
+            <a href="https://squareup.com"><img src="static/logo-square.png" alt="Square, Inc."/></a>
+          </div>
+        </div>
+      </div>
+    </section>
+    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
+    <script src="static/bootstrap.min.js"></script>
+    <script src="static/jquery.smooth-scroll.min.js"></script>
+    <script src="static/jquery-maven-artifact.min.js"></script>
+    <script src="static/prettify.js"></script>
+    <script type="text/javascript">
+      $(function() {
+        // Syntax highlight code blocks.
+        prettyPrint();
+
+        // Spy on scroll position for real-time updating of current section.
+        $('body').scrollspy();
+        
+        // Use smooth-scroll for internal links.
+        $('a').smoothScroll();
+
+        // Enable tooltips on the header nav image items.
+        $('.menu').tooltip({
+          placement: 'bottom',
+          trigger: 'hover',
+          container: 'body',
+          delay: {
+            show: 500,
+            hide: 0
+          }
+        });
+
+        // Look up the latest version of the library.
+        $.fn.artifactVersion('com.squareup.dagger', 'dagger', function(version, url) {
+          $('.version').text(version);
+          $('.version-tag').text('v' + version);
+          $('.core-version-href').attr('href', url);
+        });
+        $.fn.artifactVersion('com.squareup.dagger', 'dagger-compiler', function(version, url) {
+          $('.compiler-version-href').attr('href', url);
+        });
+      });
+    </script>
+  </body>
+</html>
/Fim/
diff --git a/website/static/app-theme.css b/website/static/app-theme.css
new file mode 100644
index 0000000..d3f35f1
--- /dev/null
+++ b/website/static/app-theme.css
@@ -0,0 +1,51 @@
+/* http://www.colorhexa.com/487fb9 */
+
+/*** Primary ***/
+
+header,
+#subtitle,
+a.dl {
+  background-color: #487fb9;
+}
+
+.content-nav li.active a,
+.content-nav li.active a:hover {
+  border-left-color: #487fb9;
+}
+
+/*** One step left on the monochromatic scale ***/
+
+header menu li a:hover,
+a.dl:hover {
+  background-color: #4072a7;
+}
+a {
+  color: #4072a7;
+}
+
+/*** Three steps left on the monochromatic scale ***/
+
+a:hover {
+  color: #325983;
+}
+
+
+/****************************************************************\
+ **** Syntax highlighting styles ********************************
+\****************************************************************/
+
+.pln { color: #000; }
+.str { color: #396695; }
+.kwd { color: #666; }
+.com { color: #800; }
+.typ { color: #222; }
+.lit { color: #666; }
+.pun { color: #888; }
+.opn { color: #888; }
+.clo { color: #888; }
+.tag { color: #396695; }
+.atn { color: #606; }
+.atv { color: #080; }
+.dec { color: #606; }
+.var { color: #606; }
+.fun { color: #f00; }
/Fim/
diff --git a/website/static/app.css b/website/static/app.css
index 9a479d1..e3574b7 100644
--- a/website/static/app.css
+++ b/website/static/app.css
@@ -1,99 +1,188 @@
+html, body {
+  font-family: 'Roboto', sans-serif;
+  font-size: 15px;
+}
 body {
-    background: #212121 url('debut_dark.png') fixed repeat;
-    margin-top: 40px;
-    color: #c6c6c6;
-    text-shadow: 1px 0px 1px black;
-    line-height: 20px;
+  background-color: #f6f6f6;
+  padding-bottom: 50px;
+  padding-top: 80px;
 }
 
-code, pre {
-    color: #bbb;
-    background: none;
-    border: none;
+header {
+  min-height: 80px;
+  color: #f6f6f6;
+  position: fixed;
+  top: 0;
+  left: 0;
+  width: 100%;
+  z-index: 99;
 }
-pre {
-    font-size: 10px;
+header h1 {
+  margin: 10px 0;
+  font-size: 50px;
+  line-height: 60px;
+  font-weight: 100;
+  text-rendering: auto;
+}
+header menu {
+  margin: 20px 0 0;
+  padding: 0;
+  height: 40px;
+}
+header menu ul {
+  margin: 0;
+  padding: 0;
+  float: right;
+}
+header menu li {
+  list-style: none;
+  float: left;
+  margin: 0;
+  padding: 0;
+}
+header menu li a {
+  display: inline-block;
+  height: 40px;
+  font-size: 17px;
+  line-height: 40px;
+  padding: 0 20px;
+  color: #f6f6f6;
+}
+header menu li a:hover {
+  color: #f6f6f6;
+  text-decoration: none;
+}
+header menu li a img {
+  margin: 0;
+  padding: 5px 0;
+  vertical-align: bottom;
+  width: 30px;
+  height: 30px;
+}
+
+#subtitle {
+  position: absolute;
+  top: 80px;
+  left: 0;
+  width: 100%;
+}
+h2 {
+  font-weight: 200;
+  font-size: 26px;
+  line-height: 30px;
+  padding: 15px 0;
+  margin: 0;
+  color: #eee;
+}
+h2 strong {
+  font-weight: 300;
+}
+
+a.dl {
+  font-weight: 300;
+  font-size: 30px;
+  line-height: 40px;
+  padding: 3px 10px;
+  display: inline-block;
+  border-radius: 6px;
+  color: #f0f0f0;
+  margin: 5px 0;
+}
+a.dl:hover {
+  color: #f0f0f0;
+  text-decoration: none;
+}
+
+.content-nav {
+  margin-top: 130px;
+  width: 220px;
+}
+.content-nav.affix {
+  top: 0;
+}
+.content-nav li.active a, .content-nav li.active a:hover {
+  background-color: transparent;
+  color: #555;
+  border-left-width: 2px;
+}
+.content-nav .secondary a {
+  color: #aaa;
+}
+.content-nav .secondary a:hover {
+  color: #888;
+}
+
+h3 {
+  font-weight: 300;
+  font-style: italic;
+  color: #888;
+  font-size: 20px;
+  padding-top: 115px;
+  margin-top: 0;
+}
+
+h4 {
+  font-weight: 400;
+  text-transform: uppercase;
+  color: #888;
+  font-size: 15px;
+  padding-top: 20px;
+}
+
+p.license {
+  font-family: fixed-width;
+}
+
+.row .logo {
+  text-align: center;
+  margin-top: 150px;
+}
+.row .logo img {
+  height: 30px;
+}
+
+pre, code {
+  color: #666;
 }
 code {
-    white-space: nowrap;
+  border: 0;
+  background-color: transparent;
 }
 
-.side h1 {
-    font-weight: normal;
-    font-size: 90px;
-    line-height: 90px;
-    margin-bottom: 25px;
-    color: #f0f0f0;
-}
-.side h3 {
-    font-weight: normal;
-    margin-bottom: 40px;
-    color: #aaa;
-}
-.side ul {
-    margin-bottom: 30px;
+/* Widescreen desktop. */
+@media (min-width: 1200px) {
+  .content-nav {
+    width: 270px;
+  }
 }
 
-.main {
-    padding-top: 40px;
-    padding-bottom: 40px;
-}
-.main h3 {
-    padding-top: 40px;
-    margin-top: 0;
-    margin-bottom: 10px;
-}
-.main h4 {
-    padding-top: 30px;
-    margin-top: 0;
-    margin-bottom: 8px;
-    text-transform: uppercase;
-}
-.main h4:first-child, .main h3:first-child {
-    padding-top: 0;
-}
-.main h5 {
-    font-size: 12px;
-    margin-top: 14px;
-    margin-bottom: 4px;
-    color: #666;
-    text-transform: uppercase;
+/* Smaller width browser, tablets. */
+@media (max-width: 979px) {
+  .content-nav {
+    width: 166px;
+  }
 }
 
-#ribbon img {
+/* One-column mobile display. */
+@media (max-width: 767px) {
+  header {
     position: absolute;
     top: 0;
-    right: 0;
-    border: 0;
-}
-
-a:link, a:visited, a:active, a:hover {
-    color: #89B8C7;
-}
-a:hover {
-    text-decoration: underline;
-}
-
-@media(min-width:768px) {
-    body {
-        margin-top: 60px;
-    }
-    .side {
-        text-align: right;
-        position: fixed;
-    }
-    .side ul {
-        margin-bottom: 60px;
-    }
-    .main {
-        padding-top: 28px;
-        padding-bottom: 100px;
-    }
-    .main-inner {
-        margin-left: 25px;
-    }
-
-    #ribbon img {
-        position: fixed;
-    }
+    left: 0;
+    width: 100%;
+    padding-left: 20px;
+  }
+  header menu {
+    display: none;
+  }
+  #subtitle {
+    position: absolute;
+    top: 80px;
+    left: 0;
+    width: 100%;
+    padding-left: 20px;
+  }
+  .content-nav {
+    display: none;
+  }
 }
\ No newline at end of file
/Fim/
-- TOO BIG --/Fim/
/Fim/
/Fim/
diff --git a/website/static/bootstrap.min.js b/website/static/bootstrap.min.js
new file mode 100644
index 0000000..95c5ac5
--- /dev/null
+++ b/website/static/bootstrap.min.js
@@ -0,0 +1,6 @@
+/*!
+* Bootstrap.js by @fat & @mdo
+* Copyright 2012 Twitter, Inc.
+* http://www.apache.org/licenses/LICENSE-2.0.txt
+*/
+!function(e){"use strict";e(function(){e.support.transition=function(){var e=function(){var e=document.createElement("bootstrap"),t={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"},n;for(n in t)if(e.style[n]!==undefined)return t[n]}();return e&&{end:e}}()})}(window.jQuery),!function(e){"use strict";var t='[data-dismiss="alert"]',n=function(n){e(n).on("click",t,this.close)};n.prototype.close=function(t){function s(){i.trigger("closed").remove()}var n=e(this),r=n.attr("data-target"),i;r||(r=n.attr("href"),r=r&&r.replace(/.*(?=#[^\s]*$)/,"")),i=e(r),t&&t.preventDefault(),i.length||(i=n.hasClass("alert")?n:n.parent()),i.trigger(t=e.Event("close"));if(t.isDefaultPrevented())return;i.removeClass("in"),e.support.transition&&i.hasClass("fade")?i.on(e.support.transition.end,s):s()};var r=e.fn.alert;e.fn.alert=function(t){return this.each(function(){var r=e(this),i=r.data("alert");i||r.data("alert",i=new n(this)),typeof t=="string"&&i[t].call(r)})},e.fn.alert.Constructor=n,e.fn.alert.noConflict=function(){return e.fn.alert=r,this},e(document).on("click.alert.data-api",t,n.prototype.close)}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.button.defaults,n)};t.prototype.setState=function(e){var t="disabled",n=this.$element,r=n.data(),i=n.is("input")?"val":"html";e+="Text",r.resetText||n.data("resetText",n[i]()),n[i](r[e]||this.options[e]),setTimeout(function(){e=="loadingText"?n.addClass(t).attr(t,t):n.removeClass(t).removeAttr(t)},0)},t.prototype.toggle=function(){var e=this.$element.closest('[data-toggle="buttons-radio"]');e&&e.find(".active").removeClass("active"),this.$element.toggleClass("active")};var n=e.fn.button;e.fn.button=function(n){return this.each(function(){var r=e(this),i=r.data("button"),s=typeof n=="object"&&n;i||r.data("button",i=new t(this,s)),n=="toggle"?i.toggle():n&&i.setState(n)})},e.fn.button.defaults={loadingText:"loading..."},e.fn.button.Constructor=t,e.fn.button.noConflict=function(){return e.fn.button=n,this},e(document).on("click.button.data-api","[data-toggle^=button]",function(t){var n=e(t.target);n.hasClass("btn")||(n=n.closest(".btn")),n.button("toggle")})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.$indicators=this.$element.find(".carousel-indicators"),this.options=n,this.options.pause=="hover"&&this.$element.on("mouseenter",e.proxy(this.pause,this)).on("mouseleave",e.proxy(this.cycle,this))};t.prototype={cycle:function(t){return t||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(e.proxy(this.next,this),this.options.interval)),this},getActiveIndex:function(){return this.$active=this.$element.find(".item.active"),this.$items=this.$active.parent().children(),this.$items.index(this.$active)},to:function(t){var n=this.getActiveIndex(),r=this;if(t>this.$items.length-1||t<0)return;return this.sliding?this.$element.one("slid",function(){r.to(t)}):n==t?this.pause().cycle():this.slide(t>n?"next":"prev",e(this.$items[t]))},pause:function(t){return t||(this.paused=!0),this.$element.find(".next, .prev").length&&e.support.transition.end&&(this.$element.trigger(e.support.transition.end),this.cycle(!0)),clearInterval(this.interval),this.interval=null,this},next:function(){if(this.sliding)return;return this.slide("next")},prev:function(){if(this.sliding)return;return this.slide("prev")},slide:function(t,n){var r=this.$element.find(".item.active"),i=n||r[t](),s=this.interval,o=t=="next"?"left":"right",u=t=="next"?"first":"last",a=this,f;this.sliding=!0,s&&this.pause(),i=i.length?i:this.$element.find(".item")[u](),f=e.Event("slide",{relatedTarget:i[0],direction:o});if(i.hasClass("active"))return;this.$indicators.length&&(this.$indicators.find(".active").removeClass("active"),this.$element.one("slid",function(){var t=e(a.$indicators.children()[a.getActiveIndex()]);t&&t.addClass("active")}));if(e.support.transition&&this.$element.hasClass("slide")){this.$element.trigger(f);if(f.isDefaultPrevented())return;i.addClass(t),i[0].offsetWidth,r.addClass(o),i.addClass(o),this.$element.one(e.support.transition.end,function(){i.removeClass([t,o].join(" ")).addClass("active"),r.removeClass(["active",o].join(" ")),a.sliding=!1,setTimeout(function(){a.$element.trigger("slid")},0)})}else{this.$element.trigger(f);if(f.isDefaultPrevented())return;r.removeClass("active"),i.addClass("active"),this.sliding=!1,this.$element.trigger("slid")}return s&&this.cycle(),this}};var n=e.fn.carousel;e.fn.carousel=function(n){return this.each(function(){var r=e(this),i=r.data("carousel"),s=e.extend({},e.fn.carousel.defaults,typeof n=="object"&&n),o=typeof n=="string"?n:s.slide;i||r.data("carousel",i=new t(this,s)),typeof n=="number"?i.to(n):o?i[o]():s.interval&&i.pause().cycle()})},e.fn.carousel.defaults={interval:5e3,pause:"hover"},e.fn.carousel.Constructor=t,e.fn.carousel.noConflict=function(){return e.fn.carousel=n,this},e(document).on("click.carousel.data-api","[data-slide], [data-slide-to]",function(t){var n=e(this),r,i=e(n.attr("data-target")||(r=n.attr("href"))&&r.replace(/.*(?=#[^\s]+$)/,"")),s=e.extend({},i.data(),n.data()),o;i.carousel(s),(o=n.attr("data-slide-to"))&&i.data("carousel").pause().to(o).cycle(),t.preventDefault()})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.collapse.defaults,n),this.options.parent&&(this.$parent=e(this.options.parent)),this.options.toggle&&this.toggle()};t.prototype={constructor:t,dimension:function(){var e=this.$element.hasClass("width");return e?"width":"height"},show:function(){var t,n,r,i;if(this.transitioning||this.$element.hasClass("in"))return;t=this.dimension(),n=e.camelCase(["scroll",t].join("-")),r=this.$parent&&this.$parent.find("> .accordion-group > .in");if(r&&r.length){i=r.data("collapse");if(i&&i.transitioning)return;r.collapse("hide"),i||r.data("collapse",null)}this.$element[t](0),this.transition("addClass",e.Event("show"),"shown"),e.support.transition&&this.$element[t](this.$element[0][n])},hide:function(){var t;if(this.transitioning||!this.$element.hasClass("in"))return;t=this.dimension(),this.reset(this.$element[t]()),this.transition("removeClass",e.Event("hide"),"hidden"),this.$element[t](0)},reset:function(e){var t=this.dimension();return this.$element.removeClass("collapse")[t](e||"auto")[0].offsetWidth,this.$element[e!==null?"addClass":"removeClass"]("collapse"),this},transition:function(t,n,r){var i=this,s=function(){n.type=="show"&&i.reset(),i.transitioning=0,i.$element.trigger(r)};this.$element.trigger(n);if(n.isDefaultPrevented())return;this.transitioning=1,this.$element[t]("in"),e.support.transition&&this.$element.hasClass("collapse")?this.$element.one(e.support.transition.end,s):s()},toggle:function(){this[this.$element.hasClass("in")?"hide":"show"]()}};var n=e.fn.collapse;e.fn.collapse=function(n){return this.each(function(){var r=e(this),i=r.data("collapse"),s=e.extend({},e.fn.collapse.defaults,r.data(),typeof n=="object"&&n);i||r.data("collapse",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.collapse.defaults={toggle:!0},e.fn.collapse.Constructor=t,e.fn.collapse.noConflict=function(){return e.fn.collapse=n,this},e(document).on("click.collapse.data-api","[data-toggle=collapse]",function(t){var n=e(this),r,i=n.attr("data-target")||t.preventDefault()||(r=n.attr("href"))&&r.replace(/.*(?=#[^\s]+$)/,""),s=e(i).data("collapse")?"toggle":n.data();n[e(i).hasClass("in")?"addClass":"removeClass"]("collapsed"),e(i).collapse(s)})}(window.jQuery),!function(e){"use strict";function r(){e(t).each(function(){i(e(this)).removeClass("open")})}function i(t){var n=t.attr("data-target"),r;n||(n=t.attr("href"),n=n&&/#/.test(n)&&n.replace(/.*(?=#[^\s]*$)/,"")),r=n&&e(n);if(!r||!r.length)r=t.parent();return r}var t="[data-toggle=dropdown]",n=function(t){var n=e(t).on("click.dropdown.data-api",this.toggle);e("html").on("click.dropdown.data-api",function(){n.parent().removeClass("open")})};n.prototype={constructor:n,toggle:function(t){var n=e(this),s,o;if(n.is(".disabled, :disabled"))return;return s=i(n),o=s.hasClass("open"),r(),o||s.toggleClass("open"),n.focus(),!1},keydown:function(n){var r,s,o,u,a,f;if(!/(38|40|27)/.test(n.keyCode))return;r=e(this),n.preventDefault(),n.stopPropagation();if(r.is(".disabled, :disabled"))return;u=i(r),a=u.hasClass("open");if(!a||a&&n.keyCode==27)return n.which==27&&u.find(t).focus(),r.click();s=e("[role=menu] li:not(.divider):visible a",u);if(!s.length)return;f=s.index(s.filter(":focus")),n.keyCode==38&&f>0&&f--,n.keyCode==40&&f<s.length-1&&f++,~f||(f=0),s.eq(f).focus()}};var s=e.fn.dropdown;e.fn.dropdown=function(t){return this.each(function(){var r=e(this),i=r.data("dropdown");i||r.data("dropdown",i=new n(this)),typeof t=="string"&&i[t].call(r)})},e.fn.dropdown.Constructor=n,e.fn.dropdown.noConflict=function(){return e.fn.dropdown=s,this},e(document).on("click.dropdown.data-api",r).on("click.dropdown.data-api",".dropdown form",function(e){e.stopPropagation()}).on("click.dropdown-menu",function(e){e.stopPropagation()}).on("click.dropdown.data-api",t,n.prototype.toggle).on("keydown.dropdown.data-api",t+", [role=menu]",n.prototype.keydown)}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.options=n,this.$element=e(t).delegate('[data-dismiss="modal"]',"click.dismiss.modal",e.proxy(this.hide,this)),this.options.remote&&this.$element.find(".modal-body").load(this.options.remote)};t.prototype={constructor:t,toggle:function(){return this[this.isShown?"hide":"show"]()},show:function(){var t=this,n=e.Event("show");this.$element.trigger(n);if(this.isShown||n.isDefaultPrevented())return;this.isShown=!0,this.escape(),this.backdrop(function(){var n=e.support.transition&&t.$element.hasClass("fade");t.$element.parent().length||t.$element.appendTo(document.body),t.$element.show(),n&&t.$element[0].offsetWidth,t.$element.addClass("in").attr("aria-hidden",!1),t.enforceFocus(),n?t.$element.one(e.support.transition.end,function(){t.$element.focus().trigger("shown")}):t.$element.focus().trigger("shown")})},hide:function(t){t&&t.preventDefault();var n=this;t=e.Event("hide"),this.$element.trigger(t);if(!this.isShown||t.isDefaultPrevented())return;this.isShown=!1,this.escape(),e(document).off("focusin.modal"),this.$element.removeClass("in").attr("aria-hidden",!0),e.support.transition&&this.$element.hasClass("fade")?this.hideWithTransition():this.hideModal()},enforceFocus:function(){var t=this;e(document).on("focusin.modal",function(e){t.$element[0]!==e.target&&!t.$element.has(e.target).length&&t.$element.focus()})},escape:function(){var e=this;this.isShown&&this.options.keyboard?this.$element.on("keyup.dismiss.modal",function(t){t.which==27&&e.hide()}):this.isShown||this.$element.off("keyup.dismiss.modal")},hideWithTransition:function(){var t=this,n=setTimeout(function(){t.$element.off(e.support.transition.end),t.hideModal()},500);this.$element.one(e.support.transition.end,function(){clearTimeout(n),t.hideModal()})},hideModal:function(){var e=this;this.$element.hide(),this.backdrop(function(){e.removeBackdrop(),e.$element.trigger("hidden")})},removeBackdrop:function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},backdrop:function(t){var n=this,r=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var i=e.support.transition&&r;this.$backdrop=e('<div class="modal-backdrop '+r+'" />').appendTo(document.body),this.$backdrop.click(this.options.backdrop=="static"?e.proxy(this.$element[0].focus,this.$element[0]):e.proxy(this.hide,this)),i&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in");if(!t)return;i?this.$backdrop.one(e.support.transition.end,t):t()}else!this.isShown&&this.$backdrop?(this.$backdrop.removeClass("in"),e.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one(e.support.transition.end,t):t()):t&&t()}};var n=e.fn.modal;e.fn.modal=function(n){return this.each(function(){var r=e(this),i=r.data("modal"),s=e.extend({},e.fn.modal.defaults,r.data(),typeof n=="object"&&n);i||r.data("modal",i=new t(this,s)),typeof n=="string"?i[n]():s.show&&i.show()})},e.fn.modal.defaults={backdrop:!0,keyboard:!0,show:!0},e.fn.modal.Constructor=t,e.fn.modal.noConflict=function(){return e.fn.modal=n,this},e(document).on("click.modal.data-api",'[data-toggle="modal"]',function(t){var n=e(this),r=n.attr("href"),i=e(n.attr("data-target")||r&&r.replace(/.*(?=#[^\s]+$)/,"")),s=i.data("modal")?"toggle":e.extend({remote:!/#/.test(r)&&r},i.data(),n.data());t.preventDefault(),i.modal(s).one("hide",function(){n.focus()})})}(window.jQuery),!function(e){"use strict";var t=function(e,t){this.init("tooltip",e,t)};t.prototype={constructor:t,init:function(t,n,r){var i,s,o,u,a;this.type=t,this.$element=e(n),this.options=this.getOptions(r),this.enabled=!0,o=this.options.trigger.split(" ");for(a=o.length;a--;)u=o[a],u=="click"?this.$element.on("click."+this.type,this.options.selector,e.proxy(this.toggle,this)):u!="manual"&&(i=u=="hover"?"mouseenter":"focus",s=u=="hover"?"mouseleave":"blur",this.$element.on(i+"."+this.type,this.options.selector,e.proxy(this.enter,this)),this.$element.on(s+"."+this.type,this.options.selector,e.proxy(this.leave,this)));this.options.selector?this._options=e.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},getOptions:function(t){return t=e.extend({},e.fn[this.type].defaults,this.$element.data(),t),t.delay&&typeof t.delay=="number"&&(t.delay={show:t.delay,hide:t.delay}),t},enter:function(t){var n=e.fn[this.type].defaults,r={},i;this._options&&e.each(this._options,function(e,t){n[e]!=t&&(r[e]=t)},this),i=e(t.currentTarget)[this.type](r).data(this.type);if(!i.options.delay||!i.options.delay.show)return i.show();clearTimeout(this.timeout),i.hoverState="in",this.timeout=setTimeout(function(){i.hoverState=="in"&&i.show()},i.options.delay.show)},leave:function(t){var n=e(t.currentTarget)[this.type](this._options).data(this.type);this.timeout&&clearTimeout(this.timeout);if(!n.options.delay||!n.options.delay.hide)return n.hide();n.hoverState="out",this.timeout=setTimeout(function(){n.hoverState=="out"&&n.hide()},n.options.delay.hide)},show:function(){var t,n,r,i,s,o,u=e.Event("show");if(this.hasContent()&&this.enabled){this.$element.trigger(u);if(u.isDefaultPrevented())return;t=this.tip(),this.setContent(),this.options.animation&&t.addClass("fade"),s=typeof this.options.placement=="function"?this.options.placement.call(this,t[0],this.$element[0]):this.options.placement,t.detach().css({top:0,left:0,display:"block"}),this.options.container?t.appendTo(this.options.container):t.insertAfter(this.$element),n=this.getPosition(),r=t[0].offsetWidth,i=t[0].offsetHeight;switch(s){case"bottom":o={top:n.top+n.height,left:n.left+n.width/2-r/2};break;case"top":o={top:n.top-i,left:n.left+n.width/2-r/2};break;case"left":o={top:n.top+n.height/2-i/2,left:n.left-r};break;case"right":o={top:n.top+n.height/2-i/2,left:n.left+n.width}}this.applyPlacement(o,s),this.$element.trigger("shown")}},applyPlacement:function(e,t){var n=this.tip(),r=n[0].offsetWidth,i=n[0].offsetHeight,s,o,u,a;n.offset(e).addClass(t).addClass("in"),s=n[0].offsetWidth,o=n[0].offsetHeight,t=="top"&&o!=i&&(e.top=e.top+i-o,a=!0),t=="bottom"||t=="top"?(u=0,e.left<0&&(u=e.left*-2,e.left=0,n.offset(e),s=n[0].offsetWidth,o=n[0].offsetHeight),this.replaceArrow(u-r+s,s,"left")):this.replaceArrow(o-i,o,"top"),a&&n.offset(e)},replaceArrow:function(e,t,n){this.arrow().css(n,e?50*(1-e/t)+"%":"")},setContent:function(){var e=this.tip(),t=this.getTitle();e.find(".tooltip-inner")[this.options.html?"html":"text"](t),e.removeClass("fade in top bottom left right")},hide:function(){function i(){var t=setTimeout(function(){n.off(e.support.transition.end).detach()},500);n.one(e.support.transition.end,function(){clearTimeout(t),n.detach()})}var t=this,n=this.tip(),r=e.Event("hide");this.$element.trigger(r);if(r.isDefaultPrevented())return;return n.removeClass("in"),e.support.transition&&this.$tip.hasClass("fade")?i():n.detach(),this.$element.trigger("hidden"),this},fixTitle:function(){var e=this.$element;(e.attr("title")||typeof e.attr("data-original-title")!="string")&&e.attr("data-original-title",e.attr("title")||"").attr("title","")},hasContent:function(){return this.getTitle()},getPosition:function(){var t=this.$element[0];return e.extend({},typeof t.getBoundingClientRect=="function"?t.getBoundingClientRect():{width:t.offsetWidth,height:t.offsetHeight},this.$element.offset())},getTitle:function(){var e,t=this.$element,n=this.options;return e=t.attr("data-original-title")||(typeof n.title=="function"?n.title.call(t[0]):n.title),e},tip:function(){return this.$tip=this.$tip||e(this.options.template)},arrow:function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},validate:function(){this.$element[0].parentNode||(this.hide(),this.$element=null,this.options=null)},enable:function(){this.enabled=!0},disable:function(){this.enabled=!1},toggleEnabled:function(){this.enabled=!this.enabled},toggle:function(t){var n=t?e(t.currentTarget)[this.type](this._options).data(this.type):this;n.tip().hasClass("in")?n.hide():n.show()},destroy:function(){this.hide().$element.off("."+this.type).removeData(this.type)}};var n=e.fn.tooltip;e.fn.tooltip=function(n){return this.each(function(){var r=e(this),i=r.data("tooltip"),s=typeof n=="object"&&n;i||r.data("tooltip",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.tooltip.Constructor=t,e.fn.tooltip.defaults={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1},e.fn.tooltip.noConflict=function(){return e.fn.tooltip=n,this}}(window.jQuery),!function(e){"use strict";var t=function(e,t){this.init("popover",e,t)};t.prototype=e.extend({},e.fn.tooltip.Constructor.prototype,{constructor:t,setContent:function(){var e=this.tip(),t=this.getTitle(),n=this.getContent();e.find(".popover-title")[this.options.html?"html":"text"](t),e.find(".popover-content")[this.options.html?"html":"text"](n),e.removeClass("fade top bottom left right in")},hasContent:function(){return this.getTitle()||this.getContent()},getContent:function(){var e,t=this.$element,n=this.options;return e=(typeof n.content=="function"?n.content.call(t[0]):n.content)||t.attr("data-content"),e},tip:function(){return this.$tip||(this.$tip=e(this.options.template)),this.$tip},destroy:function(){this.hide().$element.off("."+this.type).removeData(this.type)}});var n=e.fn.popover;e.fn.popover=function(n){return this.each(function(){var r=e(this),i=r.data("popover"),s=typeof n=="object"&&n;i||r.data("popover",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.popover.Constructor=t,e.fn.popover.defaults=e.extend({},e.fn.tooltip.defaults,{placement:"right",trigger:"click",content:"",template:'<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),e.fn.popover.noConflict=function(){return e.fn.popover=n,this}}(window.jQuery),!function(e){"use strict";function t(t,n){var r=e.proxy(this.process,this),i=e(t).is("body")?e(window):e(t),s;this.options=e.extend({},e.fn.scrollspy.defaults,n),this.$scrollElement=i.on("scroll.scroll-spy.data-api",r),this.selector=(this.options.target||(s=e(t).attr("href"))&&s.replace(/.*(?=#[^\s]+$)/,"")||"")+" .nav li > a",this.$body=e("body"),this.refresh(),this.process()}t.prototype={constructor:t,refresh:function(){var t=this,n;this.offsets=e([]),this.targets=e([]),n=this.$body.find(this.selector).map(function(){var n=e(this),r=n.data("target")||n.attr("href"),i=/^#\w/.test(r)&&e(r);return i&&i.length&&[[i.position().top+(!e.isWindow(t.$scrollElement.get(0))&&t.$scrollElement.scrollTop()),r]]||null}).sort(function(e,t){return e[0]-t[0]}).each(function(){t.offsets.push(this[0]),t.targets.push(this[1])})},process:function(){var e=this.$scrollElement.scrollTop()+this.options.offset,t=this.$scrollElement[0].scrollHeight||this.$body[0].scrollHeight,n=t-this.$scrollElement.height(),r=this.offsets,i=this.targets,s=this.activeTarget,o;if(e>=n)return s!=(o=i.last()[0])&&this.activate(o);for(o=r.length;o--;)s!=i[o]&&e>=r[o]&&(!r[o+1]||e<=r[o+1])&&this.activate(i[o])},activate:function(t){var n,r;this.activeTarget=t,e(this.selector).parent(".active").removeClass("active"),r=this.selector+'[data-target="'+t+'"],'+this.selector+'[href="'+t+'"]',n=e(r).parent("li").addClass("active"),n.parent(".dropdown-menu").length&&(n=n.closest("li.dropdown").addClass("active")),n.trigger("activate")}};var n=e.fn.scrollspy;e.fn.scrollspy=function(n){return this.each(function(){var r=e(this),i=r.data("scrollspy"),s=typeof n=="object"&&n;i||r.data("scrollspy",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.scrollspy.Constructor=t,e.fn.scrollspy.defaults={offset:10},e.fn.scrollspy.noConflict=function(){return e.fn.scrollspy=n,this},e(window).on("load",function(){e('[data-spy="scroll"]').each(function(){var t=e(this);t.scrollspy(t.data())})})}(window.jQuery),!function(e){"use strict";var t=function(t){this.element=e(t)};t.prototype={constructor:t,show:function(){var t=this.element,n=t.closest("ul:not(.dropdown-menu)"),r=t.attr("data-target"),i,s,o;r||(r=t.attr("href"),r=r&&r.replace(/.*(?=#[^\s]*$)/,""));if(t.parent("li").hasClass("active"))return;i=n.find(".active:last a")[0],o=e.Event("show",{relatedTarget:i}),t.trigger(o);if(o.isDefaultPrevented())return;s=e(r),this.activate(t.parent("li"),n),this.activate(s,s.parent(),function(){t.trigger({type:"shown",relatedTarget:i})})},activate:function(t,n,r){function o(){i.removeClass("active").find("> .dropdown-menu > .active").removeClass("active"),t.addClass("active"),s?(t[0].offsetWidth,t.addClass("in")):t.removeClass("fade"),t.parent(".dropdown-menu")&&t.closest("li.dropdown").addClass("active"),r&&r()}var i=n.find("> .active"),s=r&&e.support.transition&&i.hasClass("fade");s?i.one(e.support.transition.end,o):o(),i.removeClass("in")}};var n=e.fn.tab;e.fn.tab=function(n){return this.each(function(){var r=e(this),i=r.data("tab");i||r.data("tab",i=new t(this)),typeof n=="string"&&i[n]()})},e.fn.tab.Constructor=t,e.fn.tab.noConflict=function(){return e.fn.tab=n,this},e(document).on("click.tab.data-api",'[data-toggle="tab"], [data-toggle="pill"]',function(t){t.preventDefault(),e(this).tab("show")})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.typeahead.defaults,n),this.matcher=this.options.matcher||this.matcher,this.sorter=this.options.sorter||this.sorter,this.highlighter=this.options.highlighter||this.highlighter,this.updater=this.options.updater||this.updater,this.source=this.options.source,this.$menu=e(this.options.menu),this.shown=!1,this.listen()};t.prototype={constructor:t,select:function(){var e=this.$menu.find(".active").attr("data-value");return this.$element.val(this.updater(e)).change(),this.hide()},updater:function(e){return e},show:function(){var t=e.extend({},this.$element.position(),{height:this.$element[0].offsetHeight});return this.$menu.insertAfter(this.$element).css({top:t.top+t.height,left:t.left}).show(),this.shown=!0,this},hide:function(){return this.$menu.hide(),this.shown=!1,this},lookup:function(t){var n;return this.query=this.$element.val(),!this.query||this.query.length<this.options.minLength?this.shown?this.hide():this:(n=e.isFunction(this.source)?this.source(this.query,e.proxy(this.process,this)):this.source,n?this.process(n):this)},process:function(t){var n=this;return t=e.grep(t,function(e){return n.matcher(e)}),t=this.sorter(t),t.length?this.render(t.slice(0,this.options.items)).show():this.shown?this.hide():this},matcher:function(e){return~e.toLowerCase().indexOf(this.query.toLowerCase())},sorter:function(e){var t=[],n=[],r=[],i;while(i=e.shift())i.toLowerCase().indexOf(this.query.toLowerCase())?~i.indexOf(this.query)?n.push(i):r.push(i):t.push(i);return t.concat(n,r)},highlighter:function(e){var t=this.query.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&");return e.replace(new RegExp("("+t+")","ig"),function(e,t){return"<strong>"+t+"</strong>"})},render:function(t){var n=this;return t=e(t).map(function(t,r){return t=e(n.options.item).attr("data-value",r),t.find("a").html(n.highlighter(r)),t[0]}),t.first().addClass("active"),this.$menu.html(t),this},next:function(t){var n=this.$menu.find(".active").removeClass("active"),r=n.next();r.length||(r=e(this.$menu.find("li")[0])),r.addClass("active")},prev:function(e){var t=this.$menu.find(".active").removeClass("active"),n=t.prev();n.length||(n=this.$menu.find("li").last()),n.addClass("active")},listen:function(){this.$element.on("focus",e.proxy(this.focus,this)).on("blur",e.proxy(this.blur,this)).on("keypress",e.proxy(this.keypress,this)).on("keyup",e.proxy(this.keyup,this)),this.eventSupported("keydown")&&this.$element.on("keydown",e.proxy(this.keydown,this)),this.$menu.on("click",e.proxy(this.click,this)).on("mouseenter","li",e.proxy(this.mouseenter,this)).on("mouseleave","li",e.proxy(this.mouseleave,this))},eventSupported:function(e){var t=e in this.$element;return t||(this.$element.setAttribute(e,"return;"),t=typeof this.$element[e]=="function"),t},move:function(e){if(!this.shown)return;switch(e.keyCode){case 9:case 13:case 27:e.preventDefault();break;case 38:e.preventDefault(),this.prev();break;case 40:e.preventDefault(),this.next()}e.stopPropagation()},keydown:function(t){this.suppressKeyPressRepeat=~e.inArray(t.keyCode,[40,38,9,13,27]),this.move(t)},keypress:function(e){if(this.suppressKeyPressRepeat)return;this.move(e)},keyup:function(e){switch(e.keyCode){case 40:case 38:case 16:case 17:case 18:break;case 9:case 13:if(!this.shown)return;this.select();break;case 27:if(!this.shown)return;this.hide();break;default:this.lookup()}e.stopPropagation(),e.preventDefault()},focus:function(e){this.focused=!0},blur:function(e){this.focused=!1,!this.mousedover&&this.shown&&this.hide()},click:function(e){e.stopPropagation(),e.preventDefault(),this.select(),this.$element.focus()},mouseenter:function(t){this.mousedover=!0,this.$menu.find(".active").removeClass("active"),e(t.currentTarget).addClass("active")},mouseleave:function(e){this.mousedover=!1,!this.focused&&this.shown&&this.hide()}};var n=e.fn.typeahead;e.fn.typeahead=function(n){return this.each(function(){var r=e(this),i=r.data("typeahead"),s=typeof n=="object"&&n;i||r.data("typeahead",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.typeahead.defaults={source:[],items:8,menu:'<ul class="typeahead dropdown-menu"></ul>',item:'<li><a href="#"></a></li>',minLength:1},e.fn.typeahead.Constructor=t,e.fn.typeahead.noConflict=function(){return e.fn.typeahead=n,this},e(document).on("focus.typeahead.data-api",'[data-provide="typeahead"]',function(t){var n=e(this);if(n.data("typeahead"))return;n.typeahead(n.data())})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.options=e.extend({},e.fn.affix.defaults,n),this.$window=e(window).on("scroll.affix.data-api",e.proxy(this.checkPosition,this)).on("click.affix.data-api",e.proxy(function(){setTimeout(e.proxy(this.checkPosition,this),1)},this)),this.$element=e(t),this.checkPosition()};t.prototype.checkPosition=function(){if(!this.$element.is(":visible"))return;var t=e(document).height(),n=this.$window.scrollTop(),r=this.$element.offset(),i=this.options.offset,s=i.bottom,o=i.top,u="affix affix-top affix-bottom",a;typeof i!="object"&&(s=o=i),typeof o=="function"&&(o=i.top()),typeof s=="function"&&(s=i.bottom()),a=this.unpin!=null&&n+this.unpin<=r.top?!1:s!=null&&r.top+this.$element.height()>=t-s?"bottom":o!=null&&n<=o?"top":!1;if(this.affixed===a)return;this.affixed=a,this.unpin=a=="bottom"?r.top-n:null,this.$element.removeClass(u).addClass("affix"+(a?"-"+a:""))};var n=e.fn.affix;e.fn.affix=function(n){return this.each(function(){var r=e(this),i=r.data("affix"),s=typeof n=="object"&&n;i||r.data("affix",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.affix.Constructor=t,e.fn.affix.defaults={offset:0},e.fn.affix.noConflict=function(){return e.fn.affix=n,this},e(window).on("load",function(){e('[data-spy="affix"]').each(function(){var t=e(this),n=t.data();n.offset=n.offset||{},n.offsetBottom&&(n.offset.bottom=n.offsetBottom),n.offsetTop&&(n.offset.top=n.offsetTop),t.affix(n)})})}(window.jQuery);
\ No newline at end of file
/Fim/
/Fim/
diff --git a/website/static/html5shiv.min.js b/website/static/html5shiv.min.js
new file mode 100644
index 0000000..784f221
--- /dev/null
+++ b/website/static/html5shiv.min.js
@@ -0,0 +1,8 @@
+/*
+ HTML5 Shiv v3.6.2pre | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
+*/
+(function(l,f){function m(){var a=e.elements;return"string"==typeof a?a.split(" "):a}function i(a){var b=n[a[o]];b||(b={},h++,a[o]=h,n[h]=b);return b}function p(a,b,c){b||(b=f);if(g)return b.createElement(a);c||(c=i(b));b=c.cache[a]?c.cache[a].cloneNode():r.test(a)?(c.cache[a]=c.createElem(a)).cloneNode():c.createElem(a);return b.canHaveChildren&&!s.test(a)?c.frag.appendChild(b):b}function t(a,b){if(!b.cache)b.cache={},b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag();
+a.createElement=function(c){return!e.shivMethods?b.createElem(c):p(c,a,b)};a.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+m().join().replace(/\w+/g,function(a){b.createElem(a);b.frag.createElement(a);return'c("'+a+'")'})+");return n}")(e,b.frag)}function q(a){a||(a=f);var b=i(a);if(e.shivCSS&&!j&&!b.hasCSS){var c,d=a;c=d.createElement("p");d=d.getElementsByTagName("head")[0]||d.documentElement;c.innerHTML="x<style>article,aside,figcaption,figure,footer,header,hgroup,nav,section{display:block}mark{background:#FF0;color:#000}</style>";
+c=d.insertBefore(c.lastChild,d.firstChild);b.hasCSS=!!c}g||t(a,b);return a}var k=l.html5||{},s=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,r=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,j,o="_html5shiv",h=0,n={},g;(function(){try{var a=f.createElement("a");a.innerHTML="<xyz></xyz>";j="hidden"in a;var b;if(!(b=1==a.childNodes.length)){f.createElement("a");var c=f.createDocumentFragment();b="undefined"==typeof c.cloneNode||
+"undefined"==typeof c.createDocumentFragment||"undefined"==typeof c.createElement}g=b}catch(d){g=j=!0}})();var e={elements:k.elements||"abbr article aside audio bdi canvas data datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video",version:"3.6.2pre",shivCSS:!1!==k.shivCSS,supportsUnknownElements:g,shivMethods:!1!==k.shivMethods,type:"default",shivDocument:q,createElement:p,createDocumentFragment:function(a,b){a||(a=f);if(g)return a.createDocumentFragment();
+for(var b=b||i(a),c=b.frag.cloneNode(),d=0,e=m(),h=e.length;d<h;d++)c.createElement(e[d]);return c}};l.html5=e;q(f)})(this,document);
/Fim/
diff --git a/website/static/icon-github.png b/website/static/icon-github.png
new file mode 100644
index 0000000..a9c6940
--- /dev/null
+++ b/website/static/icon-github.png
Binary files differ
/Fim/
diff --git a/website/static/icon-square.png b/website/static/icon-square.png
new file mode 100644
index 0000000..bdc98d1
--- /dev/null
+++ b/website/static/icon-square.png
Binary files differ
/Fim/
diff --git a/website/static/jquery-maven-artifact.min.js b/website/static/jquery-maven-artifact.min.js
new file mode 100644
index 0000000..08a0304
--- /dev/null
+++ b/website/static/jquery-maven-artifact.min.js
@@ -0,0 +1,8 @@
+/**
+ * jQuery Maven Artifact Plugin
+ *
+ * Version: 1.0.1
+ * Author: Jake Wharton
+ * License: Apache 2.0
+ */
+(function($){function downloadUrl(groupId,artifactId,version,type){var groupPath=groupId.replace(/\./g,"/");return"http://repo1.maven.org/maven2/"+groupPath+"/"+artifactId+"/"+version+"/"+artifactId+"-"+version+type}$.fn.artifactVersion=function(groupId,artifactId,callback){if(typeof groupId!=="string"||typeof artifactId!=="string"){console.log("Error: groupId and artifactId are required.");return}if(typeof callback==="undefined"){console.log("Error: callback function required.");return}var url='http://search.maven.org/solrsearch/select/?q=g:"'+groupId+'"+AND+a:"'+artifactId+'"&wt=json&json.wrf=?';$.getJSON(url,function(response){var versions=response.response.docs;if(versions.length==0){return}var version=versions[0].latestVersion;var versionUrl=downloadUrl(groupId,artifactId,version,".jar");callback(version,versionUrl)})};$.fn.artifactVersions=function(groupId,artifactId,callback){if(typeof groupId!=="string"||typeof artifactId!=="string"){console.log("Error: groupId and artifactId are required.");return}if(typeof callback==="undefined"){console.log("Error: callback function required.");return}var url='http://search.maven.org/solrsearch/select/?q=g:"'+groupId+'"+AND+a:"'+artifactId+'"&wt=json&rows=10&core=gav&json.wrf=?';$.getJSON(url,function(response){var versions=response.response.docs;if(versions.length==0){return}versions.sort(function(o1,o2){return o1.v>o2.v?-1:1});var newVersions=[];for(var i=0;i<versions.length;i++){var version=versions[i].v;newVersions.push({name:version,url:downloadUrl(groupId,artifactId,version,".jar")})}callback(newVersions)})}})(jQuery);
\ No newline at end of file
/Fim/
diff --git a/website/static/jquery.smooth-scroll.min.js b/website/static/jquery.smooth-scroll.min.js
new file mode 100644
index 0000000..2af596e
--- /dev/null
+++ b/website/static/jquery.smooth-scroll.min.js
@@ -0,0 +1,7 @@
+/*!
+ * Smooth Scroll - v1.4.10 - 2013-03-02
+ * https://github.com/kswedberg/jquery-smooth-scroll
+ * Copyright (c) 2013 Karl Swedberg
+ * Licensed MIT (https://github.com/kswedberg/jquery-smooth-scroll/blob/master/LICENSE-MIT)
+ */
+(function(l){function t(l){return l.replace(/(:|\.)/g,"\\$1")}var e="1.4.10",o={exclude:[],excludeWithin:[],offset:0,direction:"top",scrollElement:null,scrollTarget:null,beforeScroll:function(){},afterScroll:function(){},easing:"swing",speed:400,autoCoefficent:2},r=function(t){var e=[],o=!1,r=t.dir&&"left"==t.dir?"scrollLeft":"scrollTop";return this.each(function(){if(this!=document&&this!=window){var t=l(this);t[r]()>0?e.push(this):(t[r](1),o=t[r]()>0,o&&e.push(this),t[r](0))}}),e.length||this.each(function(){"BODY"===this.nodeName&&(e=[this])}),"first"===t.el&&e.length>1&&(e=[e[0]]),e};l.fn.extend({scrollable:function(l){var t=r.call(this,{dir:l});return this.pushStack(t)},firstScrollable:function(l){var t=r.call(this,{el:"first",dir:l});return this.pushStack(t)},smoothScroll:function(e){e=e||{};var o=l.extend({},l.fn.smoothScroll.defaults,e),r=l.smoothScroll.filterPath(location.pathname);return this.unbind("click.smoothscroll").bind("click.smoothscroll",function(e){var n=this,s=l(this),c=o.exclude,i=o.excludeWithin,a=0,f=0,h=!0,u={},d=location.hostname===n.hostname||!n.hostname,m=o.scrollTarget||(l.smoothScroll.filterPath(n.pathname)||r)===r,p=t(n.hash);if(o.scrollTarget||d&&m&&p){for(;h&&c.length>a;)s.is(t(c[a++]))&&(h=!1);for(;h&&i.length>f;)s.closest(i[f++]).length&&(h=!1)}else h=!1;h&&(e.preventDefault(),l.extend(u,o,{scrollTarget:o.scrollTarget||p,link:n}),l.smoothScroll(u))}),this}}),l.smoothScroll=function(t,e){var o,r,n,s,c=0,i="offset",a="scrollTop",f={},h={};"number"==typeof t?(o=l.fn.smoothScroll.defaults,n=t):(o=l.extend({},l.fn.smoothScroll.defaults,t||{}),o.scrollElement&&(i="position","static"==o.scrollElement.css("position")&&o.scrollElement.css("position","relative"))),o=l.extend({link:null},o),a="left"==o.direction?"scrollLeft":a,o.scrollElement?(r=o.scrollElement,c=r[a]()):r=l("html, body").firstScrollable(),o.beforeScroll.call(r,o),n="number"==typeof t?t:e||l(o.scrollTarget)[i]()&&l(o.scrollTarget)[i]()[o.direction]||0,f[a]=n+c+o.offset,s=o.speed,"auto"===s&&(s=f[a]||r.scrollTop(),s/=o.autoCoefficent),h={duration:s,easing:o.easing,complete:function(){o.afterScroll.call(o.link,o)}},o.step&&(h.step=o.step),r.length?r.stop().animate(f,h):o.afterScroll.call(o.link,o)},l.smoothScroll.version=e,l.smoothScroll.filterPath=function(l){return l.replace(/^\//,"").replace(/(index|default).[a-zA-Z]{3,4}$/,"").replace(/\/$/,"")},l.fn.smoothScroll.defaults=o})(jQuery);
\ No newline at end of file
/Fim/
diff --git a/website/static/logo-square.png b/website/static/logo-square.png
new file mode 100644
index 0000000..788b301
--- /dev/null
+++ b/website/static/logo-square.png
Binary files differ
/Fim/
/Fim/
/Fim/
/Fim/
diff --git a/website/static/prettify.js b/website/static/prettify.js
index eef5ad7..7b99049 100644
--- a/website/static/prettify.js
+++ b/website/static/prettify.js
@@ -1,28 +1,30 @@
-var q=null;window.PR_SHOULD_USE_CONTINUATION=!0;
-(function(){function L(a){function m(a){var f=a.charCodeAt(0);if(f!==92)return f;var b=a.charAt(1);return(f=r[b])?f:"0"<=b&&b<="7"?parseInt(a.substring(1),8):b==="u"||b==="x"?parseInt(a.substring(2),16):a.charCodeAt(1)}function e(a){if(a<32)return(a<16?"\\x0":"\\x")+a.toString(16);a=String.fromCharCode(a);if(a==="\\"||a==="-"||a==="["||a==="]")a="\\"+a;return a}function h(a){for(var f=a.substring(1,a.length-1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g),a=
-[],b=[],o=f[0]==="^",c=o?1:0,i=f.length;c<i;++c){var j=f[c];if(/\\[bdsw]/i.test(j))a.push(j);else{var j=m(j),d;c+2<i&&"-"===f[c+1]?(d=m(f[c+2]),c+=2):d=j;b.push([j,d]);d<65||j>122||(d<65||j>90||b.push([Math.max(65,j)|32,Math.min(d,90)|32]),d<97||j>122||b.push([Math.max(97,j)&-33,Math.min(d,122)&-33]))}}b.sort(function(a,f){return a[0]-f[0]||f[1]-a[1]});f=[];j=[NaN,NaN];for(c=0;c<b.length;++c)i=b[c],i[0]<=j[1]+1?j[1]=Math.max(j[1],i[1]):f.push(j=i);b=["["];o&&b.push("^");b.push.apply(b,a);for(c=0;c<
-f.length;++c)i=f[c],b.push(e(i[0])),i[1]>i[0]&&(i[1]+1>i[0]&&b.push("-"),b.push(e(i[1])));b.push("]");return b.join("")}function y(a){for(var f=a.source.match(/\[(?:[^\\\]]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g),b=f.length,d=[],c=0,i=0;c<b;++c){var j=f[c];j==="("?++i:"\\"===j.charAt(0)&&(j=+j.substring(1))&&j<=i&&(d[j]=-1)}for(c=1;c<d.length;++c)-1===d[c]&&(d[c]=++t);for(i=c=0;c<b;++c)j=f[c],j==="("?(++i,d[i]===void 0&&(f[c]="(?:")):"\\"===j.charAt(0)&&
-(j=+j.substring(1))&&j<=i&&(f[c]="\\"+d[i]);for(i=c=0;c<b;++c)"^"===f[c]&&"^"!==f[c+1]&&(f[c]="");if(a.ignoreCase&&s)for(c=0;c<b;++c)j=f[c],a=j.charAt(0),j.length>=2&&a==="["?f[c]=h(j):a!=="\\"&&(f[c]=j.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return f.join("")}for(var t=0,s=!1,l=!1,p=0,d=a.length;p<d;++p){var g=a[p];if(g.ignoreCase)l=!0;else if(/[a-z]/i.test(g.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi,""))){s=!0;l=!1;break}}for(var r=
-{b:8,t:9,n:10,v:11,f:12,r:13},n=[],p=0,d=a.length;p<d;++p){g=a[p];if(g.global||g.multiline)throw Error(""+g);n.push("(?:"+y(g)+")")}return RegExp(n.join("|"),l?"gi":"g")}function M(a){function m(a){switch(a.nodeType){case 1:if(e.test(a.className))break;for(var g=a.firstChild;g;g=g.nextSibling)m(g);g=a.nodeName;if("BR"===g||"LI"===g)h[s]="\n",t[s<<1]=y++,t[s++<<1|1]=a;break;case 3:case 4:g=a.nodeValue,g.length&&(g=p?g.replace(/\r\n?/g,"\n"):g.replace(/[\t\n\r ]+/g," "),h[s]=g,t[s<<1]=y,y+=g.length,
-t[s++<<1|1]=a)}}var e=/(?:^|\s)nocode(?:\s|$)/,h=[],y=0,t=[],s=0,l;a.currentStyle?l=a.currentStyle.whiteSpace:window.getComputedStyle&&(l=document.defaultView.getComputedStyle(a,q).getPropertyValue("white-space"));var p=l&&"pre"===l.substring(0,3);m(a);return{a:h.join("").replace(/\n$/,""),c:t}}function B(a,m,e,h){m&&(a={a:m,d:a},e(a),h.push.apply(h,a.e))}function x(a,m){function e(a){for(var l=a.d,p=[l,"pln"],d=0,g=a.a.match(y)||[],r={},n=0,z=g.length;n<z;++n){var f=g[n],b=r[f],o=void 0,c;if(typeof b===
-"string")c=!1;else{var i=h[f.charAt(0)];if(i)o=f.match(i[1]),b=i[0];else{for(c=0;c<t;++c)if(i=m[c],o=f.match(i[1])){b=i[0];break}o||(b="pln")}if((c=b.length>=5&&"lang-"===b.substring(0,5))&&!(o&&typeof o[1]==="string"))c=!1,b="src";c||(r[f]=b)}i=d;d+=f.length;if(c){c=o[1];var j=f.indexOf(c),k=j+c.length;o[2]&&(k=f.length-o[2].length,j=k-c.length);b=b.substring(5);B(l+i,f.substring(0,j),e,p);B(l+i+j,c,C(b,c),p);B(l+i+k,f.substring(k),e,p)}else p.push(l+i,b)}a.e=p}var h={},y;(function(){for(var e=a.concat(m),
-l=[],p={},d=0,g=e.length;d<g;++d){var r=e[d],n=r[3];if(n)for(var k=n.length;--k>=0;)h[n.charAt(k)]=r;r=r[1];n=""+r;p.hasOwnProperty(n)||(l.push(r),p[n]=q)}l.push(/[\S\s]/);y=L(l)})();var t=m.length;return e}function u(a){var m=[],e=[];a.tripleQuotedStrings?m.push(["str",/^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/,q,"'\""]):a.multiLineStrings?m.push(["str",/^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,
-q,"'\"`"]):m.push(["str",/^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/,q,"\"'"]);a.verbatimStrings&&e.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,q]);var h=a.hashComments;h&&(a.cStyleComments?(h>1?m.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,q,"#"]):m.push(["com",/^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\b|[^\n\r]*)/,q,"#"]),e.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h|[a-z]\w*)>/,q])):m.push(["com",/^#[^\n\r]*/,
-q,"#"]));a.cStyleComments&&(e.push(["com",/^\/\/[^\n\r]*/,q]),e.push(["com",/^\/\*[\S\s]*?(?:\*\/|$)/,q]));a.regexLiterals&&e.push(["lang-regex",/^(?:^^\.?|[!+-]|!=|!==|#|%|%=|&|&&|&&=|&=|\(|\*|\*=|\+=|,|-=|->|\/|\/=|:|::|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|[?@[^]|\^=|\^\^|\^\^=|{|\||\|=|\|\||\|\|=|~|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\s*(\/(?=[^*/])(?:[^/[\\]|\\[\S\s]|\[(?:[^\\\]]|\\[\S\s])*(?:]|$))+\/)/]);(h=a.types)&&e.push(["typ",h]);a=(""+a.keywords).replace(/^ | $/g,
-"");a.length&&e.push(["kwd",RegExp("^(?:"+a.replace(/[\s,]+/g,"|")+")\\b"),q]);m.push(["pln",/^\s+/,q," \r\n\t\xa0"]);e.push(["lit",/^@[$_a-z][\w$@]*/i,q],["typ",/^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/,q],["pln",/^[$_a-z][\w$@]*/i,q],["lit",/^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i,q,"0123456789"],["pln",/^\\[\S\s]?/,q],["pun",/^.[^\s\w"-$'./@\\`]*/,q]);return x(m,e)}function D(a,m){function e(a){switch(a.nodeType){case 1:if(k.test(a.className))break;if("BR"===a.nodeName)h(a),
-a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)e(a);break;case 3:case 4:if(p){var b=a.nodeValue,d=b.match(t);if(d){var c=b.substring(0,d.index);a.nodeValue=c;(b=b.substring(d.index+d[0].length))&&a.parentNode.insertBefore(s.createTextNode(b),a.nextSibling);h(a);c||a.parentNode.removeChild(a)}}}}function h(a){function b(a,d){var e=d?a.cloneNode(!1):a,f=a.parentNode;if(f){var f=b(f,1),g=a.nextSibling;f.appendChild(e);for(var h=g;h;h=g)g=h.nextSibling,f.appendChild(h)}return e}
-for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),e;(e=a.parentNode)&&e.nodeType===1;)a=e;d.push(a)}var k=/(?:^|\s)nocode(?:\s|$)/,t=/\r\n?|\n/,s=a.ownerDocument,l;a.currentStyle?l=a.currentStyle.whiteSpace:window.getComputedStyle&&(l=s.defaultView.getComputedStyle(a,q).getPropertyValue("white-space"));var p=l&&"pre"===l.substring(0,3);for(l=s.createElement("LI");a.firstChild;)l.appendChild(a.firstChild);for(var d=[l],g=0;g<d.length;++g)e(d[g]);m===(m|0)&&d[0].setAttribute("value",
-m);var r=s.createElement("OL");r.className="linenums";for(var n=Math.max(0,m-1|0)||0,g=0,z=d.length;g<z;++g)l=d[g],l.className="L"+(g+n)%10,l.firstChild||l.appendChild(s.createTextNode("\xa0")),r.appendChild(l);a.appendChild(r)}function k(a,m){for(var e=m.length;--e>=0;){var h=m[e];A.hasOwnProperty(h)?window.console&&console.warn("cannot override language handler %s",h):A[h]=a}}function C(a,m){if(!a||!A.hasOwnProperty(a))a=/^\s*</.test(m)?"default-markup":"default-code";return A[a]}function E(a){var m=
-a.g;try{var e=M(a.h),h=e.a;a.a=h;a.c=e.c;a.d=0;C(m,h)(a);var k=/\bMSIE\b/.test(navigator.userAgent),m=/\n/g,t=a.a,s=t.length,e=0,l=a.c,p=l.length,h=0,d=a.e,g=d.length,a=0;d[g]=s;var r,n;for(n=r=0;n<g;)d[n]!==d[n+2]?(d[r++]=d[n++],d[r++]=d[n++]):n+=2;g=r;for(n=r=0;n<g;){for(var z=d[n],f=d[n+1],b=n+2;b+2<=g&&d[b+1]===f;)b+=2;d[r++]=z;d[r++]=f;n=b}for(d.length=r;h<p;){var o=l[h+2]||s,c=d[a+2]||s,b=Math.min(o,c),i=l[h+1],j;if(i.nodeType!==1&&(j=t.substring(e,b))){k&&(j=j.replace(m,"\r"));i.nodeValue=
-j;var u=i.ownerDocument,v=u.createElement("SPAN");v.className=d[a+1];var x=i.parentNode;x.replaceChild(v,i);v.appendChild(i);e<o&&(l[h+1]=i=u.createTextNode(t.substring(b,o)),x.insertBefore(i,v.nextSibling))}e=b;e>=o&&(h+=2);e>=c&&(a+=2)}}catch(w){"console"in window&&console.log(w&&w.stack?w.stack:w)}}var v=["break,continue,do,else,for,if,return,while"],w=[[v,"auto,case,char,const,default,double,enum,extern,float,goto,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],
-"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],F=[w,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,dynamic_cast,explicit,export,friend,inline,late_check,mutable,namespace,nullptr,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],G=[w,"abstract,boolean,byte,extends,final,finally,implements,import,instanceof,null,native,package,strictfp,super,synchronized,throws,transient"],
-H=[G,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,interface,internal,into,is,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var"],w=[w,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],I=[v,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],
-J=[v,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],v=[v,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],K=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)/,N=/\S/,O=u({keywords:[F,H,w,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END"+
-I,J,v],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),A={};k(O,["default-code"]);k(x([],[["pln",/^[^<?]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\S\s]*?(?:--\>|$)/],["lang-",/^<\?([\S\s]+?)(?:\?>|$)/],["lang-",/^<%([\S\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",/^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i]]),
-["default-markup","htm","html","mxml","xhtml","xml","xsl"]);k(x([["pln",/^\s+/,q," \t\r\n"],["atv",/^(?:"[^"]*"?|'[^']*'?)/,q,"\"'"]],[["tag",/^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/],["pun",/^[/<->]+/],["lang-js",/^on\w+\s*=\s*"([^"]+)"/i],["lang-js",/^on\w+\s*=\s*'([^']+)'/i],["lang-js",/^on\w+\s*=\s*([^\s"'>]+)/i],["lang-css",/^style\s*=\s*"([^"]+)"/i],["lang-css",/^style\s*=\s*'([^']+)'/i],["lang-css",
-/^style\s*=\s*([^\s"'>]+)/i]]),["in.tag"]);k(x([],[["atv",/^[\S\s]+/]]),["uq.val"]);k(u({keywords:F,hashComments:!0,cStyleComments:!0,types:K}),["c","cc","cpp","cxx","cyc","m"]);k(u({keywords:"null,true,false"}),["json"]);k(u({keywords:H,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:K}),["cs"]);k(u({keywords:G,cStyleComments:!0}),["java"]);k(u({keywords:v,hashComments:!0,multiLineStrings:!0}),["bsh","csh","sh"]);k(u({keywords:I,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),
-["cv","py"]);k(u({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["perl","pl","pm"]);k(u({keywords:J,hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb"]);k(u({keywords:w,cStyleComments:!0,regexLiterals:!0}),["js"]);k(u({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,true,try,unless,until,when,while,yes",
-hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);k(x([],[["str",/^[\S\s]+/]]),["regex"]);window.prettyPrintOne=function(a,m,e){var h=document.createElement("PRE");h.innerHTML=a;e&&D(h,e);E({g:m,i:e,h:h});return h.innerHTML};window.prettyPrint=function(a){function m(){for(var e=window.PR_SHOULD_USE_CONTINUATION?l.now()+250:Infinity;p<h.length&&l.now()<e;p++){var n=h[p],k=n.className;if(k.indexOf("prettyprint")>=0){var k=k.match(g),f,b;if(b=
-!k){b=n;for(var o=void 0,c=b.firstChild;c;c=c.nextSibling)var i=c.nodeType,o=i===1?o?b:c:i===3?N.test(c.nodeValue)?b:o:o;b=(f=o===b?void 0:o)&&"CODE"===f.tagName}b&&(k=f.className.match(g));k&&(k=k[1]);b=!1;for(o=n.parentNode;o;o=o.parentNode)if((o.tagName==="pre"||o.tagName==="code"||o.tagName==="xmp")&&o.className&&o.className.indexOf("prettyprint")>=0){b=!0;break}b||((b=(b=n.className.match(/\blinenums\b(?::(\d+))?/))?b[1]&&b[1].length?+b[1]:!0:!1)&&D(n,b),d={g:k,h:n,i:b},E(d))}}p<h.length?setTimeout(m,
-250):a&&a()}for(var e=[document.getElementsByTagName("pre"),document.getElementsByTagName("code"),document.getElementsByTagName("xmp")],h=[],k=0;k<e.length;++k)for(var t=0,s=e[k].length;t<s;++t)h.push(e[k][t]);var e=q,l=Date;l.now||(l={now:function(){return+new Date}});var p=0,d,g=/\blang(?:uage)?-([\w.]+)(?!\S)/;m()};window.PR={createSimpleLexer:x,registerLangHandler:k,sourceDecorator:u,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",
-PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ"}})();
+!function(){var q=null;window.PR_SHOULD_USE_CONTINUATION=!0;
+(function(){function S(a){function d(e){var b=e.charCodeAt(0);if(b!==92)return b;var a=e.charAt(1);return(b=r[a])?b:"0"<=a&&a<="7"?parseInt(e.substring(1),8):a==="u"||a==="x"?parseInt(e.substring(2),16):e.charCodeAt(1)}function g(e){if(e<32)return(e<16?"\\x0":"\\x")+e.toString(16);e=String.fromCharCode(e);return e==="\\"||e==="-"||e==="]"||e==="^"?"\\"+e:e}function b(e){var b=e.substring(1,e.length-1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g),e=[],a=
+b[0]==="^",c=["["];a&&c.push("^");for(var a=a?1:0,f=b.length;a<f;++a){var h=b[a];if(/\\[bdsw]/i.test(h))c.push(h);else{var h=d(h),l;a+2<f&&"-"===b[a+1]?(l=d(b[a+2]),a+=2):l=h;e.push([h,l]);l<65||h>122||(l<65||h>90||e.push([Math.max(65,h)|32,Math.min(l,90)|32]),l<97||h>122||e.push([Math.max(97,h)&-33,Math.min(l,122)&-33]))}}e.sort(function(e,a){return e[0]-a[0]||a[1]-e[1]});b=[];f=[];for(a=0;a<e.length;++a)h=e[a],h[0]<=f[1]+1?f[1]=Math.max(f[1],h[1]):b.push(f=h);for(a=0;a<b.length;++a)h=b[a],c.push(g(h[0])),
+h[1]>h[0]&&(h[1]+1>h[0]&&c.push("-"),c.push(g(h[1])));c.push("]");return c.join("")}function s(e){for(var a=e.source.match(/\[(?:[^\\\]]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g),c=a.length,d=[],f=0,h=0;f<c;++f){var l=a[f];l==="("?++h:"\\"===l.charAt(0)&&(l=+l.substring(1))&&(l<=h?d[l]=-1:a[f]=g(l))}for(f=1;f<d.length;++f)-1===d[f]&&(d[f]=++x);for(h=f=0;f<c;++f)l=a[f],l==="("?(++h,d[h]||(a[f]="(?:")):"\\"===l.charAt(0)&&(l=+l.substring(1))&&l<=h&&
+(a[f]="\\"+d[l]);for(f=0;f<c;++f)"^"===a[f]&&"^"!==a[f+1]&&(a[f]="");if(e.ignoreCase&&m)for(f=0;f<c;++f)l=a[f],e=l.charAt(0),l.length>=2&&e==="["?a[f]=b(l):e!=="\\"&&(a[f]=l.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return a.join("")}for(var x=0,m=!1,j=!1,k=0,c=a.length;k<c;++k){var i=a[k];if(i.ignoreCase)j=!0;else if(/[a-z]/i.test(i.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi,""))){m=!0;j=!1;break}}for(var r={b:8,t:9,n:10,v:11,
+f:12,r:13},n=[],k=0,c=a.length;k<c;++k){i=a[k];if(i.global||i.multiline)throw Error(""+i);n.push("(?:"+s(i)+")")}return RegExp(n.join("|"),j?"gi":"g")}function T(a,d){function g(a){var c=a.nodeType;if(c==1){if(!b.test(a.className)){for(c=a.firstChild;c;c=c.nextSibling)g(c);c=a.nodeName.toLowerCase();if("br"===c||"li"===c)s[j]="\n",m[j<<1]=x++,m[j++<<1|1]=a}}else if(c==3||c==4)c=a.nodeValue,c.length&&(c=d?c.replace(/\r\n?/g,"\n"):c.replace(/[\t\n\r ]+/g," "),s[j]=c,m[j<<1]=x,x+=c.length,m[j++<<1|1]=
+a)}var b=/(?:^|\s)nocode(?:\s|$)/,s=[],x=0,m=[],j=0;g(a);return{a:s.join("").replace(/\n$/,""),d:m}}function H(a,d,g,b){d&&(a={a:d,e:a},g(a),b.push.apply(b,a.g))}function U(a){for(var d=void 0,g=a.firstChild;g;g=g.nextSibling)var b=g.nodeType,d=b===1?d?a:g:b===3?V.test(g.nodeValue)?a:d:d;return d===a?void 0:d}function C(a,d){function g(a){for(var j=a.e,k=[j,"pln"],c=0,i=a.a.match(s)||[],r={},n=0,e=i.length;n<e;++n){var z=i[n],w=r[z],t=void 0,f;if(typeof w==="string")f=!1;else{var h=b[z.charAt(0)];
+if(h)t=z.match(h[1]),w=h[0];else{for(f=0;f<x;++f)if(h=d[f],t=z.match(h[1])){w=h[0];break}t||(w="pln")}if((f=w.length>=5&&"lang-"===w.substring(0,5))&&!(t&&typeof t[1]==="string"))f=!1,w="src";f||(r[z]=w)}h=c;c+=z.length;if(f){f=t[1];var l=z.indexOf(f),B=l+f.length;t[2]&&(B=z.length-t[2].length,l=B-f.length);w=w.substring(5);H(j+h,z.substring(0,l),g,k);H(j+h+l,f,I(w,f),k);H(j+h+B,z.substring(B),g,k)}else k.push(j+h,w)}a.g=k}var b={},s;(function(){for(var g=a.concat(d),j=[],k={},c=0,i=g.length;c<i;++c){var r=
+g[c],n=r[3];if(n)for(var e=n.length;--e>=0;)b[n.charAt(e)]=r;r=r[1];n=""+r;k.hasOwnProperty(n)||(j.push(r),k[n]=q)}j.push(/[\S\s]/);s=S(j)})();var x=d.length;return g}function v(a){var d=[],g=[];a.tripleQuotedStrings?d.push(["str",/^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/,q,"'\""]):a.multiLineStrings?d.push(["str",/^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,
+q,"'\"`"]):d.push(["str",/^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/,q,"\"'"]);a.verbatimStrings&&g.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,q]);var b=a.hashComments;b&&(a.cStyleComments?(b>1?d.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,q,"#"]):d.push(["com",/^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\b|[^\n\r]*)/,q,"#"]),g.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h(?:h|pp|\+\+)?|[a-z]\w*)>/,q])):d.push(["com",
+/^#[^\n\r]*/,q,"#"]));a.cStyleComments&&(g.push(["com",/^\/\/[^\n\r]*/,q]),g.push(["com",/^\/\*[\S\s]*?(?:\*\/|$)/,q]));if(b=a.regexLiterals){var s=(b=b>1?"":"\n\r")?".":"[\\S\\s]";g.push(["lang-regex",RegExp("^(?:^^\\.?|[+-]|[!=]=?=?|\\#|%=?|&&?=?|\\(|\\*=?|[+\\-]=|->|\\/=?|::?|<<?=?|>>?>?=?|,|;|\\?|@|\\[|~|{|\\^\\^?=?|\\|\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*("+("/(?=[^/*"+b+"])(?:[^/\\x5B\\x5C"+b+"]|\\x5C"+s+"|\\x5B(?:[^\\x5C\\x5D"+b+"]|\\x5C"+
+s+")*(?:\\x5D|$))+/")+")")])}(b=a.types)&&g.push(["typ",b]);b=(""+a.keywords).replace(/^ | $/g,"");b.length&&g.push(["kwd",RegExp("^(?:"+b.replace(/[\s,]+/g,"|")+")\\b"),q]);d.push(["pln",/^\s+/,q," \r\n\t\u00a0"]);b="^.[^\\s\\w.$@'\"`/\\\\]*";a.regexLiterals&&(b+="(?!s*/)");g.push(["lit",/^@[$_a-z][\w$@]*/i,q],["typ",/^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/,q],["pln",/^[$_a-z][\w$@]*/i,q],["lit",/^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i,q,"0123456789"],["pln",/^\\[\S\s]?/,
+q],["pun",RegExp(b),q]);return C(d,g)}function J(a,d,g){function b(a){var c=a.nodeType;if(c==1&&!x.test(a.className))if("br"===a.nodeName)s(a),a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)b(a);else if((c==3||c==4)&&g){var d=a.nodeValue,i=d.match(m);if(i)c=d.substring(0,i.index),a.nodeValue=c,(d=d.substring(i.index+i[0].length))&&a.parentNode.insertBefore(j.createTextNode(d),a.nextSibling),s(a),c||a.parentNode.removeChild(a)}}function s(a){function b(a,c){var d=
+c?a.cloneNode(!1):a,e=a.parentNode;if(e){var e=b(e,1),g=a.nextSibling;e.appendChild(d);for(var i=g;i;i=g)g=i.nextSibling,e.appendChild(i)}return d}for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),d;(d=a.parentNode)&&d.nodeType===1;)a=d;c.push(a)}for(var x=/(?:^|\s)nocode(?:\s|$)/,m=/\r\n?|\n/,j=a.ownerDocument,k=j.createElement("li");a.firstChild;)k.appendChild(a.firstChild);for(var c=[k],i=0;i<c.length;++i)b(c[i]);d===(d|0)&&c[0].setAttribute("value",d);var r=j.createElement("ol");
+r.className="linenums";for(var d=Math.max(0,d-1|0)||0,i=0,n=c.length;i<n;++i)k=c[i],k.className="L"+(i+d)%10,k.firstChild||k.appendChild(j.createTextNode("\u00a0")),r.appendChild(k);a.appendChild(r)}function p(a,d){for(var g=d.length;--g>=0;){var b=d[g];F.hasOwnProperty(b)?D.console&&console.warn("cannot override language handler %s",b):F[b]=a}}function I(a,d){if(!a||!F.hasOwnProperty(a))a=/^\s*</.test(d)?"default-markup":"default-code";return F[a]}function K(a){var d=a.h;try{var g=T(a.c,a.i),b=g.a;
+a.a=b;a.d=g.d;a.e=0;I(d,b)(a);var s=/\bMSIE\s(\d+)/.exec(navigator.userAgent),s=s&&+s[1]<=8,d=/\n/g,x=a.a,m=x.length,g=0,j=a.d,k=j.length,b=0,c=a.g,i=c.length,r=0;c[i]=m;var n,e;for(e=n=0;e<i;)c[e]!==c[e+2]?(c[n++]=c[e++],c[n++]=c[e++]):e+=2;i=n;for(e=n=0;e<i;){for(var p=c[e],w=c[e+1],t=e+2;t+2<=i&&c[t+1]===w;)t+=2;c[n++]=p;c[n++]=w;e=t}c.length=n;var f=a.c,h;if(f)h=f.style.display,f.style.display="none";try{for(;b<k;){var l=j[b+2]||m,B=c[r+2]||m,t=Math.min(l,B),A=j[b+1],G;if(A.nodeType!==1&&(G=x.substring(g,
+t))){s&&(G=G.replace(d,"\r"));A.nodeValue=G;var L=A.ownerDocument,o=L.createElement("span");o.className=c[r+1];var v=A.parentNode;v.replaceChild(o,A);o.appendChild(A);g<l&&(j[b+1]=A=L.createTextNode(x.substring(t,l)),v.insertBefore(A,o.nextSibling))}g=t;g>=l&&(b+=2);g>=B&&(r+=2)}}finally{if(f)f.style.display=h}}catch(u){D.console&&console.log(u&&u.stack||u)}}var D=window,y=["break,continue,do,else,for,if,return,while"],E=[[y,"auto,case,char,const,default,double,enum,extern,float,goto,inline,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],
+"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],M=[E,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,delegate,dynamic_cast,explicit,export,friend,generic,late_check,mutable,namespace,nullptr,property,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],N=[E,"abstract,assert,boolean,byte,extends,final,finally,implements,import,instanceof,interface,null,native,package,strictfp,super,synchronized,throws,transient"],
+O=[N,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,internal,into,is,let,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var,virtual,where"],E=[E,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],P=[y,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],
+Q=[y,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],W=[y,"as,assert,const,copy,drop,enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,pub,pure,ref,self,static,struct,true,trait,type,unsafe,use"],y=[y,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],R=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)\b/,
+V=/\S/,X=v({keywords:[M,O,E,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",P,Q,y],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),F={};p(X,["default-code"]);p(C([],[["pln",/^[^<?]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\S\s]*?(?:--\>|$)/],["lang-",/^<\?([\S\s]+?)(?:\?>|$)/],["lang-",/^<%([\S\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",
+/^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i]]),["default-markup","htm","html","mxml","xhtml","xml","xsl"]);p(C([["pln",/^\s+/,q," \t\r\n"],["atv",/^(?:"[^"]*"?|'[^']*'?)/,q,"\"'"]],[["tag",/^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/],["pun",/^[/<->]+/],
+["lang-js",/^on\w+\s*=\s*"([^"]+)"/i],["lang-js",/^on\w+\s*=\s*'([^']+)'/i],["lang-js",/^on\w+\s*=\s*([^\s"'>]+)/i],["lang-css",/^style\s*=\s*"([^"]+)"/i],["lang-css",/^style\s*=\s*'([^']+)'/i],["lang-css",/^style\s*=\s*([^\s"'>]+)/i]]),["in.tag"]);p(C([],[["atv",/^[\S\s]+/]]),["uq.val"]);p(v({keywords:M,hashComments:!0,cStyleComments:!0,types:R}),["c","cc","cpp","cxx","cyc","m"]);p(v({keywords:"null,true,false"}),["json"]);p(v({keywords:O,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:R}),
+["cs"]);p(v({keywords:N,cStyleComments:!0}),["java"]);p(v({keywords:y,hashComments:!0,multiLineStrings:!0}),["bash","bsh","csh","sh"]);p(v({keywords:P,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),["cv","py","python"]);p(v({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:2}),["perl","pl","pm"]);p(v({keywords:Q,
+hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb","ruby"]);p(v({keywords:E,cStyleComments:!0,regexLiterals:!0}),["javascript","js"]);p(v({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,throw,true,try,unless,until,when,while,yes",hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);p(v({keywords:W,cStyleComments:!0,multilineStrings:!0}),["rc","rs","rust"]);
+p(C([],[["str",/^[\S\s]+/]]),["regex"]);var Y=D.PR={createSimpleLexer:C,registerLangHandler:p,sourceDecorator:v,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ",prettyPrintOne:D.prettyPrintOne=function(a,d,g){var b=document.createElement("div");b.innerHTML="<pre>"+a+"</pre>";b=b.firstChild;g&&J(b,g,!0);K({h:d,j:g,c:b,i:1});
+return b.innerHTML},prettyPrint:D.prettyPrint=function(a,d){function g(){for(var b=D.PR_SHOULD_USE_CONTINUATION?c.now()+250:Infinity;i<p.length&&c.now()<b;i++){for(var d=p[i],j=h,k=d;k=k.previousSibling;){var m=k.nodeType,o=(m===7||m===8)&&k.nodeValue;if(o?!/^\??prettify\b/.test(o):m!==3||/\S/.test(k.nodeValue))break;if(o){j={};o.replace(/\b(\w+)=([\w%+\-.:]+)/g,function(a,b,c){j[b]=c});break}}k=d.className;if((j!==h||e.test(k))&&!v.test(k)){m=!1;for(o=d.parentNode;o;o=o.parentNode)if(f.test(o.tagName)&&
+o.className&&e.test(o.className)){m=!0;break}if(!m){d.className+=" prettyprinted";m=j.lang;if(!m){var m=k.match(n),y;if(!m&&(y=U(d))&&t.test(y.tagName))m=y.className.match(n);m&&(m=m[1])}if(w.test(d.tagName))o=1;else var o=d.currentStyle,u=s.defaultView,o=(o=o?o.whiteSpace:u&&u.getComputedStyle?u.getComputedStyle(d,q).getPropertyValue("white-space"):0)&&"pre"===o.substring(0,3);u=j.linenums;if(!(u=u==="true"||+u))u=(u=k.match(/\blinenums\b(?::(\d+))?/))?u[1]&&u[1].length?+u[1]:!0:!1;u&&J(d,u,o);r=
+{h:m,c:d,j:u,i:o};K(r)}}}i<p.length?setTimeout(g,250):"function"===typeof a&&a()}for(var b=d||document.body,s=b.ownerDocument||document,b=[b.getElementsByTagName("pre"),b.getElementsByTagName("code"),b.getElementsByTagName("xmp")],p=[],m=0;m<b.length;++m)for(var j=0,k=b[m].length;j<k;++j)p.push(b[m][j]);var b=q,c=Date;c.now||(c={now:function(){return+new Date}});var i=0,r,n=/\blang(?:uage)?-([\w.]+)(?!\S)/,e=/\bprettyprint\b/,v=/\bprettyprinted\b/,w=/pre|xmp/i,t=/^code$/i,f=/^(?:pre|code|xmp)$/i,
+h={};g()}};typeof define==="function"&&define.amd&&define("google-code-prettify",[],function(){return Y})})();}()
/Fim/
/Fim/
/Fim/
diff --git a/compiler/src/it/multiple-provides-methods/verify.bsh b/compiler/src/it/multiple-provides-methods/verify.bsh
index 2337e04..5890213 100644
--- a/compiler/src/it/multiple-provides-methods/verify.bsh
+++ b/compiler/src/it/multiple-provides-methods/verify.bsh
@@ -2,11 +2,11 @@
 
 File classes = new File(basedir, "target/classes/test/");
 
-File moduleAdapter = new File(classes, "TestApp$TestModule$ModuleAdapter.class");
-if (!moduleAdapter.exists()) throw new Exception("No binding generated for module"); 
+File moduleAdapter = new File(classes, "TestApp$TestModule$$ModuleAdapter.class");
+if (!moduleAdapter.exists()) throw new Exception("No binding generated for module");
 
-File integerBinding = new File(classes, "TestApp$TestModule$ModuleAdapter$IntegerProvidesAdapter.class");
-if (!integerBinding.exists()) throw new Exception("No binding generated for integer()"); 
+File integerBinding = new File(classes, "TestApp$TestModule$$ModuleAdapter$IntegerProvidesAdapter.class");
+if (!integerBinding.exists()) throw new Exception("No binding generated for integer()");
 
-File stringBinding = new File(classes, "TestApp$TestModule$ModuleAdapter$StringProvidesAdapter.class");
-if (!stringBinding.exists()) throw new Exception("No binding generated for string()"); 
+File stringBinding = new File(classes, "TestApp$TestModule$$ModuleAdapter$StringProvidesAdapter.class");
+if (!stringBinding.exists()) throw new Exception("No binding generated for string()");
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java b/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java
index c6646a2..b2415e5 100644
--- a/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java
+++ b/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java
@@ -25,9 +25,9 @@
  * A runtime {@link Plugin} that loads generated classes.
  */
 public final class ClassloadingPlugin implements Plugin {
-  public static final String INJECT_ADAPTER_SUFFIX = "$InjectAdapter";
-  public static final String MODULE_ADAPTER_SUFFIX = "$ModuleAdapter";
-  public static final String STATIC_INJECTION_SUFFIX = "$StaticInjection";
+  public static final String INJECT_ADAPTER_SUFFIX = "$$InjectAdapter";
+  public static final String MODULE_ADAPTER_SUFFIX = "$$ModuleAdapter";
+  public static final String STATIC_INJECTION_SUFFIX = "$$StaticInjection";
 
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
     return instantiate(moduleClass.getName(), MODULE_ADAPTER_SUFFIX);
/Fim/
diff --git a/website/index.html b/website/index.html
index eae44f0..0a5008b 100644
--- a/website/index.html
+++ b/website/index.html
@@ -363,12 +363,12 @@
             <pre class="prettyprint">&lt;dependency>
   &lt;groupId>com.squareup.dagger&lt;/groupId>
   &lt;artifactId>dagger&lt;/artifactId>
-  &lt;version><em class="version">(insert latest version)</em>&lt;/version>
+  &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
 &lt;/dependency>
   &lt;dependency>
     &lt;groupId>com.squareup&lt;/groupId>
     &lt;artifactId>dagger-compiler&lt;/artifactId>
-    &lt;version><em class="version">(insert latest version)</em>&lt;/version>
+    &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
     &lt;optional>true&lt;/optional>
   &lt;/dependency>
 &lt;/dependencies></pre>
/Fim/
diff --git a/website/index.html b/website/index.html
index 0a5008b..97e0b16 100644
--- a/website/index.html
+++ b/website/index.html
@@ -270,6 +270,8 @@
             <pre class="prettyprint">ObjectGraph objectGraph = ObjectGraph.create(new LegacyModule());
 objectGraph.injectStatics();</pre>
 
+            <p><span class="label">Note:</span> <em>Static injection only operates for modules in the immediate graph. If you call <code>injectStatics()</code> on a graph created from a call to <code>plus()</code>, static injections on modules in the extended graph will not be performed.</em></p>
+
             <h4>Compile-time Validation</h4>
 
             <p>Dagger includes an <a href="http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html">annotation processor</a> that validates modules and injections. This processor is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is missing a binding for <code>Executor</code>:</p>
/Fim/
diff --git a/compiler/src/it/static-injected-binding-doesnt-fail-providers/pom.xml b/compiler/src/it/static-injected-binding-doesnt-fail-providers/pom.xml
new file mode 100644
index 0000000..b93d3bf
--- /dev/null
+++ b/compiler/src/it/static-injected-binding-doesnt-fail-providers/pom.xml
@@ -0,0 +1,52 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.squareup.dagger.tests</groupId>
+  <artifactId>static-injected-binding-doesnt-fail-providers</artifactId>
+  <version>@dagger.version@</version>
+  <packaging>jar</packaging>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/static-injected-binding-doesnt-fail-providers/src/main/java/test/Test.java b/compiler/src/it/static-injected-binding-doesnt-fail-providers/src/main/java/test/Test.java
new file mode 100644
index 0000000..450f794
--- /dev/null
+++ b/compiler/src/it/static-injected-binding-doesnt-fail-providers/src/main/java/test/Test.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+
+import dagger.ObjectGraph;
+import dagger.Provides;
+import javax.inject.Inject;
+
+import java.lang.Override;
+
+public class Test {
+
+  public static class InjectsOneField {
+    @Inject static String staticallyInjectedString;
+  }
+
+  @Module(staticInjections = { InjectsOneField.class })
+  public static class TestModule {
+    @Provides String string() {
+      return "string";
+    }
+  }
+}
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java b/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
index 8513e58..d765e80 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
@@ -301,4 +301,13 @@
     return typeMirror instanceof DeclaredType
         && ((DeclaredType) typeMirror).asElement().getKind() == ElementKind.INTERFACE;
   }
+
+  static boolean isStatic(Element element) {
+    for (Modifier modifier : element.getModifiers()) {
+      if (modifier.equals(Modifier.STATIC)) {
+        return true;
+      }
+    }
+    return false;
+  }
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeGenStaticInjection.java b/compiler/src/main/java/dagger/internal/codegen/CodeGenStaticInjection.java
new file mode 100644
index 0000000..7d6c6de
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeGenStaticInjection.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import dagger.internal.Linker;
+import dagger.internal.StaticInjection;
+import javax.inject.Inject;
+import javax.lang.model.element.Element;
+
+public final class CodeGenStaticInjection extends StaticInjection {
+
+  private final Element enclosingClass;
+
+  public CodeGenStaticInjection(Element enclosingClass) {
+    this.enclosingClass = enclosingClass;
+  }
+
+  @Override public void attach(Linker linker) {
+    for (Element enclosedElement : enclosingClass.getEnclosedElements()) {
+      if (enclosedElement.getKind().isField() && CodeGen.isStatic(enclosedElement)) {
+        Inject injectAnnotation = enclosedElement.getAnnotation(Inject.class);
+        if (injectAnnotation != null) {
+          String key = GeneratorKeys.get(enclosedElement.asType());
+          linker.requestBinding(key, enclosingClass.toString());
+        }
+      }
+    }
+  }
+
+  @Override public void inject() {
+    throw new UnsupportedOperationException();
+  }
+}
\ No newline at end of file
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 9d9bdd4..7ca3756 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -132,6 +132,7 @@
       boolean ignoreCompletenessErrors) {
     Map<String, TypeElement> allModules = new LinkedHashMap<String, TypeElement>();
     collectIncludesRecursively(rootModule, allModules, new LinkedList<String>());
+    ArrayList<CodeGenStaticInjection> staticInjections = new ArrayList<CodeGenStaticInjection>();
 
     Linker.ErrorHandler errorHandler = ignoreCompletenessErrors ? Linker.ErrorHandler.NULL
         : new ReportingErrorHandler(processingEnv, rootModule.getQualifiedName().toString());
@@ -158,7 +159,11 @@
         }
 
         // Gather the static injections.
-        // TODO.
+        for (Object staticInjection : (Object[]) annotation.get("staticInjections")) {
+          TypeMirror staticInjectionTypeMirror = (TypeMirror) staticInjection;
+          Element element = processingEnv.getTypeUtils().asElement(staticInjectionTypeMirror);
+          staticInjections.add(new CodeGenStaticInjection(element));
+        }
 
         // Gather the enclosed @Provides methods.
         for (Element enclosed : module.getEnclosedElements()) {
@@ -202,6 +207,9 @@
 
       linker.installBindings(baseBindings);
       linker.installBindings(overrideBindings);
+      for (CodeGenStaticInjection staticInjection : staticInjections) {
+        staticInjection.attach(linker);
+      }
 
       // Link the bindings. This will traverse the dependency graph, and report
       // errors if any dependencies are missing.
/Fim/
diff --git a/examples/android-activity-graphs/AndroidManifest.xml b/examples/android-activity-graphs/AndroidManifest.xml
index adac7a8..e80464f 100644
--- a/examples/android-activity-graphs/AndroidManifest.xml
+++ b/examples/android-activity-graphs/AndroidManifest.xml
@@ -7,7 +7,9 @@
 
   <uses-sdk android:minSdkVersion="4" android:targetSdkVersion="17"/>
 
-  <application android:label="@string/app_name">
+  <application
+      android:label="@string/app_name"
+      android:name=".DemoApplication">
     <activity
         android:label="@string/app_name"
         android:name=".ui.HomeActivity">
/Fim/
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoBaseFragment.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoBaseFragment.java
index ef7960c..f2e1fda 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoBaseFragment.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoBaseFragment.java
@@ -15,12 +15,13 @@
  */
 package com.example.dagger.activitygraphs;
 
-import android.app.Activity;
+import android.os.Bundle;
 import android.support.v4.app.Fragment;
 
 /** Base fragment which performs injection using the activity object graph of its parent. */
 public class DemoBaseFragment extends Fragment {
-  @Override public void onAttach(Activity activity) {
-    ((DemoBaseActivity) activity).inject(this);
+  @Override public void onActivityCreated(Bundle savedInstanceState) {
+    super.onActivityCreated(savedInstanceState);
+    ((DemoBaseActivity) getActivity()).inject(this);
   }
 }
/Fim/
diff --git a/website/index.html b/website/index.html
index 97e0b16..5d201aa 100644
--- a/website/index.html
+++ b/website/index.html
@@ -467,6 +467,16 @@
           $('.compiler-version-href').attr('href', url);
         });
       });
+
+      var _gaq = _gaq || [];
+      _gaq.push(['_setAccount', 'UA-40704740-3']);
+      _gaq.push(['_trackPageview']);
+
+      (function() {
+        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
+        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
+        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
+      })();
     </script>
   </body>
 </html>
/Fim/
diff --git a/website/index.html b/website/index.html
index 5d201aa..eecc931 100644
--- a/website/index.html
+++ b/website/index.html
@@ -418,7 +418,7 @@
               <ul class="nav nav-pills nav-stacked secondary">
                 <li><a href="#">Javadoc</a></li>
                 <li><a href="https://groups.google.com/forum/#!forum/dagger-discuss">dagger-discuss@</a></li>
-                <li><a href="https://plus.google.com/communities/109244258569782858265/stream/bab12891-7685-4e0c-8dcb-f85cd0ca31c0">Google+</a></li>
+                <li><a href="https://plus.google.com/communities/109244258569782858265/stream/bab12891-7685-4e0c-8dcb-f85cd0ca31c0">Google+ Community</a></li>
               </ul>
             </div>
           </div>
/Fim/
diff --git a/compiler/src/it/unused-provider-methods-fail-compilation/verify.bsh b/compiler/src/it/unused-provider-methods-fail-compilation/verify.bsh
index f32569d..44d8029 100644
--- a/compiler/src/it/unused-provider-methods-fail-compilation/verify.bsh
+++ b/compiler/src/it/unused-provider-methods-fail-compilation/verify.bsh
@@ -4,6 +4,6 @@
 File buildLog = new File(basedir, "build.log");
 new BuildLogValidator().assertHasText(buildLog, new String[]{
     "You have these unused @Provider methods:",
-    "0. test.TestModule.string()",
+    "1. test.TestModule.string()",
     "Set library=true in your module to disable this check."
     });
\ No newline at end of file
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
index 07f8af4..d5c5903 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
@@ -50,14 +50,10 @@
     this.supertypeKey = supertypeKey;
   }
 
-  /**
-   * @param mustBeInjectable true if the binding must have {@code @Inject}
-   *     annotations.
-   */
-  static AtInjectBinding create(TypeElement type, boolean mustBeInjectable) {
+  static AtInjectBinding create(TypeElement type, boolean mustHaveInjections) {
     List<String> requiredKeys = new ArrayList<String>();
-    boolean hasInjectAnnotatedConstructor = false;
-    boolean isConstructable = false;
+    boolean hasInjectConstructor = false;
+    boolean hasNoArgsConstructor = false;
 
     for (Element enclosed : type.getEnclosedElements()) {
       switch (enclosed.getKind()) {
@@ -72,17 +68,16 @@
         ExecutableElement constructor = (ExecutableElement) enclosed;
         List<? extends VariableElement> parameters = constructor.getParameters();
         if (hasAtInject(enclosed)) {
-          if (hasInjectAnnotatedConstructor) {
+          if (hasInjectConstructor) {
             throw new IllegalArgumentException("Too many injectable constructors on "
                 + type.getQualifiedName().toString());
           }
-          hasInjectAnnotatedConstructor = true;
-          isConstructable = true;
+          hasInjectConstructor = true;
           for (VariableElement parameter : parameters) {
             requiredKeys.add(GeneratorKeys.get(parameter));
           }
         } else if (parameters.isEmpty()) {
-          isConstructable = true;
+          hasNoArgsConstructor = true;
         }
         break;
 
@@ -93,7 +88,7 @@
       }
     }
 
-    if (!hasInjectAnnotatedConstructor && requiredKeys.isEmpty() && mustBeInjectable) {
+    if (!hasInjectConstructor && requiredKeys.isEmpty() && mustHaveInjections) {
       throw new IllegalArgumentException("No injectable members on "
           + type.getQualifiedName().toString() + ". Do you want to add an injectable constructor?");
     }
@@ -104,7 +99,9 @@
         ? GeneratorKeys.rawMembersKey(supertype)
         : null;
 
-    String provideKey = isConstructable ? GeneratorKeys.get(type.asType()) : null;
+    String provideKey = hasInjectConstructor || (hasNoArgsConstructor && !requiredKeys.isEmpty())
+        ? GeneratorKeys.get(type.asType())
+        : null;
     String membersKey = GeneratorKeys.rawMembersKey(type.asType());
     return new AtInjectBinding(provideKey, membersKey, type, requiredKeys, supertypeKey);
   }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java b/compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java
index 61e0f4a..30d364e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java
@@ -38,7 +38,7 @@
   }
 
   @Override public Binding<?> getAtInjectBinding(
-      String key, String className, boolean mustBeInjectable) {
+      String key, String className, boolean mustHaveInjections) {
     String sourceClassName = className.replace('$', '.');
     TypeElement type = processingEnv.getElementUtils().getTypeElement(sourceClassName);
     if (type == null) {
@@ -51,7 +51,7 @@
     if (type.getKind() == ElementKind.INTERFACE) {
       return null;
     }
-    return AtInjectBinding.create(type, mustBeInjectable);
+    return AtInjectBinding.create(type, mustHaveInjections);
   }
 
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 75a37d2..b80751c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -420,8 +420,9 @@
     boolean singleton = providerMethod.getAnnotation(Singleton.class) != null;
     String key = JavaWriter.stringLiteral(GeneratorKeys.get(providerMethod));
     String membersKey = null;
-    writer.emitStatement("super(%s, %s, %s, %s.class)",
-        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"), moduleType);
+    writer.emitStatement("super(%s, %s, %s, %s)",
+        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"),
+        JavaWriter.stringLiteral(moduleType + "." + methodName + "()"));
     writer.emitStatement("this.module = module");
     writer.emitStatement("setLibrary(%s)", library);
     writer.endMethod();
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 880a71c..cd0c507 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -101,12 +101,12 @@
       if (binding instanceof DeferredBinding) {
         DeferredBinding deferredBinding = (DeferredBinding) binding;
         String key = deferredBinding.deferredKey;
-        boolean mustBeInjectable = deferredBinding.mustBeInjectable;
+        boolean mustHaveInjections = deferredBinding.mustHaveInjections;
         if (bindings.containsKey(key)) {
           continue; // A binding for this key has since been linked.
         }
         try {
-          Binding<?> jitBinding = createJitBinding(key, binding.requiredBy, mustBeInjectable);
+          Binding<?> jitBinding = createJitBinding(key, binding.requiredBy, mustHaveInjections);
           jitBinding.setLibrary(binding.library());
           jitBinding.setDependedOn(binding.dependedOn());
           // Fail if the type of binding we got wasn't capable of what was requested.
@@ -167,7 +167,7 @@
    *   <li>Injections of other types will use the injectable constructors of those classes.
    * </ul>
    */
-  private Binding<?> createJitBinding(String key, Object requiredBy, boolean mustBeInjectable)
+  private Binding<?> createJitBinding(String key, Object requiredBy, boolean mustHaveInjections)
       throws ClassNotFoundException {
     String builtInBindingsKey = Keys.getBuiltInBindingsKey(key);
     if (builtInBindingsKey != null) {
@@ -180,7 +180,7 @@
 
     String className = Keys.getClassName(key);
     if (className != null && !Keys.isAnnotated(key)) {
-      Binding<?> atInjectBinding = plugin.getAtInjectBinding(key, className, mustBeInjectable);
+      Binding<?> atInjectBinding = plugin.getAtInjectBinding(key, className, mustHaveInjections);
       if (atInjectBinding != null) {
         return atInjectBinding;
       }
@@ -203,12 +203,13 @@
    * null. If the returned binding didn't exist or was unlinked, it will be
    * enqueued to be linked.
    *
-   * @param mustBeInjectable true if the the referenced key doesn't need to be
-   *     injectable. This is necessary for injectable types (so that framework
-   *     code can inject arbitrary classes like JUnit test cases or Android
-   *     activities) and also for supertypes.
+   * @param mustHaveInjections true if the the referenced key requires either an
+   *     {@code @Inject} annotation is produced by a {@code @Provides} method.
+   *     This isn't necessary for Module.injects types because frameworks need
+   *     to inject arbitrary classes like JUnit test cases and Android
+   *     activities. It also isn't necessary for supertypes.
    */
-  public Binding<?> requestBinding(String key, Object requiredBy, boolean mustBeInjectable,
+  public Binding<?> requestBinding(String key, Object requiredBy, boolean mustHaveInjections,
       boolean library) {
     assertLockHeld();
 
@@ -223,7 +224,7 @@
 
     if (binding == null) {
       // We can't satisfy this binding. Make sure it'll work next time!
-      Binding<?> deferredBinding = new DeferredBinding(key, requiredBy, mustBeInjectable);
+      Binding<?> deferredBinding = new DeferredBinding(key, requiredBy, mustHaveInjections);
       deferredBinding.setLibrary(library);
       deferredBinding.setDependedOn(true);
       toLink.add(deferredBinding);
@@ -328,6 +329,14 @@
       return binding.isVisiting();
     }
 
+    @Override public boolean library() {
+      return binding.library();
+    }
+
+    @Override public boolean dependedOn() {
+      return binding.dependedOn();
+    }
+
     @Override public void setCycleFree(final boolean cycleFree) {
       binding.setCycleFree(cycleFree);
     }
@@ -336,6 +345,14 @@
       binding.setVisiting(visiting);
     }
 
+    @Override public void setLibrary(boolean library) {
+      binding.setLibrary(true);
+    }
+
+    @Override public void setDependedOn(boolean dependedOn) {
+      binding.setDependedOn(dependedOn);
+    }
+
     @Override protected boolean isSingleton() {
       return true;
     }
@@ -368,12 +385,12 @@
 
   private static class DeferredBinding extends Binding<Object> {
     final String deferredKey;
-    final boolean mustBeInjectable;
+    final boolean mustHaveInjections;
 
-    private DeferredBinding(String deferredKey, Object requiredBy, boolean mustBeInjectable) {
+    private DeferredBinding(String deferredKey, Object requiredBy, boolean mustHaveInjections) {
       super(null, null, false, requiredBy);
       this.deferredKey = deferredKey;
-      this.mustBeInjectable = mustBeInjectable;
+      this.mustHaveInjections = mustHaveInjections;
     }
     @Override public void injectMembers(Object t) {
       throw new UnsupportedOperationException("Deferred bindings must resolve first.");
/Fim/
diff --git a/core/src/main/java/dagger/internal/Plugin.java b/core/src/main/java/dagger/internal/Plugin.java
index db803a3..24fdf92 100644
--- a/core/src/main/java/dagger/internal/Plugin.java
+++ b/core/src/main/java/dagger/internal/Plugin.java
@@ -24,7 +24,7 @@
   /**
    * Returns a binding that uses {@code @Inject} annotations.
    */
-  Binding<?> getAtInjectBinding(String key, String className, boolean mustBeInjectable);
+  Binding<?> getAtInjectBinding(String key, String className, boolean mustHaveInjections);
 
   /**
    * Returns a module adapter for {@code module}.
/Fim/
diff --git a/core/src/main/java/dagger/internal/ProblemDetector.java b/core/src/main/java/dagger/internal/ProblemDetector.java
index a2a9ff5..8df0915 100644
--- a/core/src/main/java/dagger/internal/ProblemDetector.java
+++ b/core/src/main/java/dagger/internal/ProblemDetector.java
@@ -40,7 +40,8 @@
       StringBuilder builder = new StringBuilder();
       builder.append("You have these unused @Provider methods:");
       for (int i = 0; i < unusedBindings.size(); i++) {
-        builder.append("\n    ").append(i).append(". ").append(unusedBindings.get(i).requiredBy);
+        builder.append("\n    ").append(i + 1).append(". ")
+            .append(unusedBindings.get(i).requiredBy);
       }
       builder.append("\n    Set library=true in your module to disable this check.");
       throw new IllegalStateException(builder.toString());
/Fim/
diff --git a/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java b/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
index 75b0253..93514e9 100644
--- a/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
+++ b/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
@@ -107,10 +107,10 @@
   }
 
   @Override public Binding<?> getAtInjectBinding(String key, String className,
-      boolean mustBeInjectable) {
+      boolean mustHaveInjections) {
     for (int i = 0; i < plugins.length; i++) {
       try {
-        return plugins[i].getAtInjectBinding(key, className, mustBeInjectable);
+        return plugins[i].getAtInjectBinding(key, className, mustHaveInjections);
       } catch (RuntimeException e) {
         if (i == plugins.length - 1) throw e;
         logNotFound("Binding", className, e);
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java b/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java
index b2415e5..93cf1a8 100644
--- a/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java
+++ b/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java
@@ -34,7 +34,7 @@
   }
 
   @Override public Binding<?> getAtInjectBinding(
-      String key, String className, boolean mustBeInjectable) {
+      String key, String className, boolean mustHaveInjections) {
     return instantiate(className, INJECT_ADAPTER_SUFFIX);
   }
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
index 78ea1ff..4fce92c 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
@@ -139,11 +139,7 @@
     return provideKey != null ? provideKey : membersKey;
   }
 
-  /**
-   * @param mustBeInjectable true if the binding must have {@code @Inject}
-   *     annotations.
-   */
-  public static <T> Binding<T> create(Class<T> type, boolean mustBeInjectable) {
+  public static <T> Binding<T> create(Class<T> type, boolean mustHaveInjections) {
     boolean singleton = type.isAnnotationPresent(Singleton.class);
     List<String> keys = new ArrayList<String>();
 
@@ -177,14 +173,15 @@
       injectedConstructor = constructor;
     }
     if (injectedConstructor == null) {
-      if (injectedFields.isEmpty() && mustBeInjectable) {
+      if (!injectedFields.isEmpty()) {
+        try {
+          injectedConstructor = type.getDeclaredConstructor();
+        } catch (NoSuchMethodException ignored) {
+        }
+      } else if (mustHaveInjections) {
         throw new IllegalArgumentException("No injectable members on " + type.getName()
             + ". Do you want to add an injectable constructor?");
       }
-      try {
-        injectedConstructor = type.getDeclaredConstructor();
-      } catch (NoSuchMethodException ignored) {
-      }
     }
 
     int parameterCount;
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
index 44cd87c..d5ad9de 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
@@ -31,7 +31,7 @@
  */
 public final class ReflectivePlugin implements Plugin {
   @Override public Binding<?> getAtInjectBinding(
-      String key, String className, boolean mustBeInjectable) {
+      String key, String className, boolean mustHaveInjections) {
     Class<?> c;
     try {
       c = Class.forName(className);
@@ -43,7 +43,7 @@
       return null;
     }
 
-    return ReflectiveAtInjectBinding.create(c, mustBeInjectable);
+    return ReflectiveAtInjectBinding.create(c, mustHaveInjections);
   }
 
   @SuppressWarnings("unchecked") // Runtime checks validate that the result type matches 'T'.
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index 09df5c2..a12fb2c 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -17,6 +17,7 @@
 package dagger;
 
 import java.util.AbstractList;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.RandomAccess;
@@ -824,4 +825,20 @@
       assertThat(e.getMessage()).contains("Can't inject private constructor: ");
     }
   }
+
+  /** https://github.com/square/dagger/issues/231 */
+  @Test public void atInjectAlwaysRequiredForConstruction() {
+    @Module(injects = ArrayList.class)
+    class TestModule {
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
+    objectGraph.validate();
+    try {
+      objectGraph.get(ArrayList.class);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).contains("Unable to create binding for java.util.ArrayList");
+    }
+  }
 }
/Fim/
diff --git a/pom.xml b/pom.xml
index 49bd024..32f356e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -156,6 +156,14 @@
           </execution>
         </executions>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.9</version>
+        <configuration>
+          <excludePackageNames>dagger.internal:dagger.internal.*</excludePackageNames>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
/Fim/
diff --git a/website/index.html b/website/index.html
index eecc931..dd4e59d 100644
--- a/website/index.html
+++ b/website/index.html
@@ -298,6 +298,40 @@
   }
 }</pre>
 
+            <p>Modules which provide types that are unused by the listed injects classes will also trigger an error.</p>
+
+            <pre class="prettyprint">@Module(injects = Example.class)
+class DripCoffeeModule {
+  @Provides Heater provideHeater() {
+    return new ElectricHeater();
+  }
+  @Provides Chiller provideChiller() {
+    return new ElectricChiller();
+  }
+}</pre>
+
+            <p>Because the <code>Example</code> inject in the module only uses the <code>Heater</code>, <code>javac</code> rejects the unused binding:</p>
+
+            <pre>[ERROR] COMPILATION ERROR:
+[ERROR]: Graph validation failed: You have these unused @Provider methods:
+      1. coffee.DripCoffeeModule.provideChiller()
+      Set library=true in your module to disable this check.</pre>
+
+            <p>If your module's bindings will be used outside of the listed injects then mark the module as a library.</p>
+
+            <pre class="prettyprint">@Module(
+  injects = Example.class,
+  library = true
+)
+class DripCoffeeModule {
+  @Provides Heater provideHeater() {
+    return new ElectricHeater();
+  }
+  @Provides Chiller provideChiller() {
+    return new ElectricChiller();
+  }
+}</pre>
+
             <p>To get the most out of compile-time validation, create a module that includes all of your application's modules. The annotation processor will detect problems across the modules and report them.</p>
 
             <pre class="prettyprint">@Module(
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 33d5705..db91c37 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -61,6 +61,8 @@
  * </ul>
  */
 public abstract class ObjectGraph {
+  ObjectGraph() {
+  }
 
   /**
    * Returns an instance of {@code type}.
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index ec7434c..113f197 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0-SNAPSHOT</version>
+    <version>1.0.0</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 63515f8..4fc25fe 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0-SNAPSHOT</version>
+    <version>1.0.0</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index be3b39f..9661f6c 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.0-SNAPSHOT</version>
+    <version>1.0.0</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 3650700..5dc7e8c 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.0-SNAPSHOT</version>
+    <version>1.0.0</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index 875aab5..bfbee53 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0-SNAPSHOT</version>
+    <version>1.0.0</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 5e11afa..cc01cca 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.0-SNAPSHOT</version>
+    <version>1.0.0</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index 32f356e..699dc58 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.0-SNAPSHOT</version>
+  <version>1.0.0</version>
   <name>Dagger (Parent)</name>
   <description>A JSR-330 dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -54,7 +54,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>HEAD</tag>
+    <tag>dagger-parent-1.0.0</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 113f197..1e51195 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0.0</version>
+    <version>1.0.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 4fc25fe..039db61 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0.0</version>
+    <version>1.0.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 9661f6c..1e7b0f7 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.0.0</version>
+    <version>1.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 5dc7e8c..a300147 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.0.0</version>
+    <version>1.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index bfbee53..847cd8f 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0.0</version>
+    <version>1.0.1-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index cc01cca..83efedd 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.0.0</version>
+    <version>1.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index 699dc58..cfb0355 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.0.0</version>
+  <version>1.0.1-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
   <description>A JSR-330 dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -54,7 +54,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>dagger-parent-1.0.0</tag>
+    <tag>HEAD</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/examples/android-activity-graphs/README.md b/examples/android-activity-graphs/README.md
index 533d40a..efdc038 100644
--- a/examples/android-activity-graphs/README.md
+++ b/examples/android-activity-graphs/README.md
@@ -9,9 +9,9 @@
  * Provides the ability to inject objects which require the activity to be constructed.
  * Allows for the use of singletons on a per-activity basis. This is a great way to manage a
    resource that is shared by a bunch of fragments in an activity.
- * Keeps the global object graph clear of things that can be used only be activities.
+ * Keeps the global object graph clear of things that can be used only by activities.
 
 While this example only shows the presence of an activity scope, you should be able to see the
 potential for other useful scopes that can be used. For example, having a dedicated object graph
-for the current user sessions is a great way to manage data that is tied to the currently logged-in
+for the current user session is a great way to manage data that is tied to the currently logged-in
 user.
/Fim/
diff --git a/deploy_website.sh b/deploy_website.sh
index 2afa5f0..1fde1bd 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -6,13 +6,17 @@
 
 set -ex
 
+REPO="git@github.com:square/dagger.git"
+GROUP_ID="com.squareup.dagger"
+ARTIFACT_ID="dagger"
+
 DIR=temp-dagger-clone
 
 # Delete any existing temporary website clone
 rm -rf $DIR
 
 # Clone the current repo into temp folder
-git clone git@github.com:square/dagger.git $DIR
+git clone $REPO $DIR
 
 # Move working directory into temp folder
 cd $DIR
@@ -26,6 +30,12 @@
 # Copy website files from real repo
 cp -R ../website/* .
 
+# Download the latest javadoc
+curl -L "http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
+mkdir javadoc
+unzip javadoc.zip -d javadoc
+rm javadoc.zip
+
 # Stage all files in git and create a commit
 git add .
 git add -u
/Fim/
diff --git a/website/index.html b/website/index.html
index dd4e59d..80728c9 100644
--- a/website/index.html
+++ b/website/index.html
@@ -450,7 +450,7 @@
                 <li><a href="#license">License</a></li>
               </ul>
               <ul class="nav nav-pills nav-stacked secondary">
-                <li><a href="#">Javadoc</a></li>
+                <li><a href="javadoc/index.html">Javadoc</a></li>
                 <li><a href="https://groups.google.com/forum/#!forum/dagger-discuss">dagger-discuss@</a></li>
                 <li><a href="https://plus.google.com/communities/109244258569782858265/stream/bab12891-7685-4e0c-8dcb-f85cd0ca31c0">Google+ Community</a></li>
               </ul>
/Fim/
diff --git a/website/index.html b/website/index.html
index 80728c9..f0189d0 100644
--- a/website/index.html
+++ b/website/index.html
@@ -391,7 +391,7 @@
             <p>For more substantial variations it's often simpler to use a different combination of modules.</p>
 
             <h3 id="download">Download</h3>
-            <p><a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.dagger&a=dagger-core&v=LATEST" class="dl core-version-href">&darr; <span class="version-tag">Latest</span> JAR</a> <a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.dagger&a=dagger-compiler&v=LATEST" class="dl compiler-version-href">&darr; <span class="version-tag">Latest</span> Compiler JAR</a></p>
+            <p><a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.dagger&a=dagger&v=LATEST" class="dl core-version-href">&darr; <span class="version-tag">Latest</span> JAR</a> <a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.dagger&a=dagger-compiler&v=LATEST" class="dl compiler-version-href">&darr; <span class="version-tag">Latest</span> Compiler JAR</a></p>
             <p>You will need to include the Dagger JAR in your application's runtime.  In order to activate code generation you will need to include the compiler JAR in your build at compile time.</p>
             <p>The source code to the Dagger, its samples, and this website is <a href="http://github.com/square/okhttp">available on GitHub</a>.</p>
 
/Fim/
diff --git a/README.md b/README.md
index ebd652f..d4aa279 100644
--- a/README.md
+++ b/README.md
@@ -22,12 +22,12 @@
 ```xml
 <dependencies>
   <dependency>
-    <groupId>com.squareup</groupId>
+    <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger</artifactId>
     <version>${dagger.version}</version>
   </dependency>
   <dependency>
-    <groupId>com.squareup</groupId>
+    <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-compiler</artifactId>
     <version>${dagger.version}</version>
     <optional>true</optional>
/Fim/
diff --git a/website/index.html b/website/index.html
index f0189d0..058e373 100644
--- a/website/index.html
+++ b/website/index.html
@@ -402,7 +402,7 @@
   &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
 &lt;/dependency>
   &lt;dependency>
-    &lt;groupId>com.squareup&lt;/groupId>
+    &lt;groupId>com.squareup.dagger&lt;/groupId>
     &lt;artifactId>dagger-compiler&lt;/artifactId>
     &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
     &lt;optional>true&lt;/optional>
/Fim/
diff --git a/website/index.html b/website/index.html
index 058e373..9647d51 100644
--- a/website/index.html
+++ b/website/index.html
@@ -393,7 +393,7 @@
             <h3 id="download">Download</h3>
             <p><a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.dagger&a=dagger&v=LATEST" class="dl core-version-href">&darr; <span class="version-tag">Latest</span> JAR</a> <a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.dagger&a=dagger-compiler&v=LATEST" class="dl compiler-version-href">&darr; <span class="version-tag">Latest</span> Compiler JAR</a></p>
             <p>You will need to include the Dagger JAR in your application's runtime.  In order to activate code generation you will need to include the compiler JAR in your build at compile time.</p>
-            <p>The source code to the Dagger, its samples, and this website is <a href="http://github.com/square/okhttp">available on GitHub</a>.</p>
+            <p>The source code to the Dagger, its samples, and this website is <a href="http://github.com/square/dagger">available on GitHub</a>.</p>
 
             <h4>Maven</h4>
             <pre class="prettyprint">&lt;dependency>
/Fim/
diff --git a/website/index.html b/website/index.html
index 9647d51..7d8b0d4 100644
--- a/website/index.html
+++ b/website/index.html
@@ -401,13 +401,12 @@
   &lt;artifactId>dagger&lt;/artifactId>
   &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
 &lt;/dependency>
-  &lt;dependency>
-    &lt;groupId>com.squareup.dagger&lt;/groupId>
-    &lt;artifactId>dagger-compiler&lt;/artifactId>
-    &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
-    &lt;optional>true&lt;/optional>
-  &lt;/dependency>
-&lt;/dependencies></pre>
+&lt;dependency>
+  &lt;groupId>com.squareup.dagger&lt;/groupId>
+  &lt;artifactId>dagger-compiler&lt;/artifactId>
+  &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
+  &lt;optional>true&lt;/optional>
+&lt;/dependency></pre>
 
             <h3 id="upgrading">Upgrading from Guice</h3>
 
/Fim/
diff --git a/core/src/test/java/dagger/UnusedProviderTest.java b/core/src/test/java/dagger/UnusedProviderTest.java
index c6cc975..f9ffbef 100644
--- a/core/src/test/java/dagger/UnusedProviderTest.java
+++ b/core/src/test/java/dagger/UnusedProviderTest.java
@@ -16,9 +16,12 @@
 package dagger;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.junit.Assert.fail;
 
+@RunWith(JUnit4.class)
 public class UnusedProviderTest {
 
   @Test public void unusedProvidesMethod_whenModuleLibrary_passes() throws Exception {
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index 847cd8f..e213030 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -65,13 +65,20 @@
   </dependencyManagement>
 
   <!-- Example-only plugins -->
+  <pluginRepositories>
+    <pluginRepository>
+      <id>jayway.snapshots</id>
+      <url>https://oss.sonatype.org/content/repositories/jayway-snapshots</url>
+    </pluginRepository>
+  </pluginRepositories>
+
   <build>
     <pluginManagement>
       <plugins>
         <plugin>
           <groupId>com.jayway.maven.plugins.android.generation2</groupId>
           <artifactId>android-maven-plugin</artifactId>
-          <version>3.5.3</version>
+          <version>3.5.4-SNAPSHOT</version>
           <configuration>
             <sdk>
               <platform>16</platform>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index e213030..0f68bec 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -64,21 +64,13 @@
     </dependencies>
   </dependencyManagement>
 
-  <!-- Example-only plugins -->
-  <pluginRepositories>
-    <pluginRepository>
-      <id>jayway.snapshots</id>
-      <url>https://oss.sonatype.org/content/repositories/jayway-snapshots</url>
-    </pluginRepository>
-  </pluginRepositories>
-
   <build>
     <pluginManagement>
       <plugins>
         <plugin>
           <groupId>com.jayway.maven.plugins.android.generation2</groupId>
           <artifactId>android-maven-plugin</artifactId>
-          <version>3.5.4-SNAPSHOT</version>
+          <version>3.6.0</version>
           <configuration>
             <sdk>
               <platform>16</platform>
/Fim/
diff --git a/README.md b/README.md
index d4aa279..290c716 100644
--- a/README.md
+++ b/README.md
@@ -35,9 +35,8 @@
 </dependencies>
 ```
 
-You can also find downloadable .jars on Maven Central. You'll need both
-[Dagger](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup%22%20dagger) and
-[JavaWriter](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22javawriter%22).
+You can also find downloadable .jars on Maven Central. You'll need
+[Dagger][dl-dagger], [JavaWriter][dl-javawriter], and [javax.inject][dl-inject].
 
 
 
@@ -61,3 +60,6 @@
 
 
  [1]: http://square.github.com/dagger/
+ [dl-dagger]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.dagger%22%20a%3A%22dagger%22
+ [dl-javawriter]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup%22%20a%3A%22javawriter%22
+ [dl-inject]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22javax.inject%22%20a%3A%22javax.inject%22
/Fim/
diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 0000000..ff5ba9c
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,14 @@
+Change Log
+==========
+
+Version 1.0.1 *(2013-06-03)*
+----------------------------
+
+ * Explicitly forbid declaring `@Inject` on a class type (e.g., `@Inject class Foo {}`).
+ * Update JavaWriter to 1.0.5.
+
+
+Version 1.0.0 *(2013-05-07)*
+----------------------------
+
+Initial release.
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 1e51195..7442053 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0.1-SNAPSHOT</version>
+    <version>1.0.1</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 0965c90..09b8342 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0.1-SNAPSHOT</version>
+    <version>1.0.1</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 1e7b0f7..3c56671 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.0.1-SNAPSHOT</version>
+    <version>1.0.1</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index a300147..4576b6f 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.0.1-SNAPSHOT</version>
+    <version>1.0.1</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index 0f68bec..e918ee9 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0.1-SNAPSHOT</version>
+    <version>1.0.1</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 83efedd..5f56b2b 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.0.1-SNAPSHOT</version>
+    <version>1.0.1</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index a9c84dd..81c55a3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.0.1-SNAPSHOT</version>
+  <version>1.0.1</version>
   <name>Dagger (Parent)</name>
   <description>A JSR-330 dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -54,7 +54,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>HEAD</tag>
+    <tag>dagger-parent-1.0.1</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 7442053..cb7b5e6 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0.1</version>
+    <version>1.0.2-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 09b8342..9782025 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0.1</version>
+    <version>1.0.2-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 3c56671..14715d9 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.0.1</version>
+    <version>1.0.2-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 4576b6f..1bd5f10 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.0.1</version>
+    <version>1.0.2-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index e918ee9..953c3ed 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0.1</version>
+    <version>1.0.2-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 5f56b2b..f160be2 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.0.1</version>
+    <version>1.0.2-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index 81c55a3..74e6f8b 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.0.1</version>
+  <version>1.0.2-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
   <description>A JSR-330 dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -54,7 +54,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>dagger-parent-1.0.1</tag>
+    <tag>HEAD</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
index 8bc75bf..e082c0f 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
@@ -30,8 +30,9 @@
   }
 
   protected List<Object> getModules() {
-    return Arrays.<Object>asList(
-        new AndroidModule(this)
+    return Arrays.asList(
+        new AndroidModule(this),
+        new DemoModule()
     );
   }
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java b/compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java
index 519309e..d149d16 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java
@@ -15,7 +15,7 @@
  */
 package dagger.internal.codegen;
 
-import com.squareup.java.JavaWriter;
+import com.squareup.javawriter.JavaWriter;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.Writer;
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
index de890dc..cb47831 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
@@ -15,7 +15,7 @@
  */
 package dagger.internal.codegen;
 
-import com.squareup.java.JavaWriter;
+import com.squareup.javawriter.JavaWriter;
 import dagger.MembersInjector;
 import dagger.internal.Binding;
 import dagger.internal.Linker;
@@ -239,7 +239,7 @@
     boolean dependent = injectMembers
         || ((constructor != null) && !constructor.getParameters().isEmpty());
 
-    writer.emitEndOfLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
+    writer.emitSingleLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
     writer.emitPackage(packageName);
     writer.emitEmptyLine();
     writer.emitImports(getImports(dependent, injectMembers, constructor != null));
@@ -411,7 +411,7 @@
         .createSourceFile(adapterName, type);
     JavaWriter writer = new JavaWriter(sourceFile.openWriter());
 
-    writer.emitEndOfLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
+    writer.emitSingleLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
     writer.emitPackage(getPackage(type).getQualifiedName().toString());
 
     writer.emitEmptyLine();
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 420388d..1a81463 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -15,7 +15,7 @@
  */
 package dagger.internal.codegen;
 
-import com.squareup.java.JavaWriter;
+import com.squareup.javawriter.JavaWriter;
 import dagger.Module;
 import dagger.Provides;
 import dagger.internal.Binding;
@@ -231,7 +231,7 @@
     boolean multibindings = checkForMultibindings(providerMethods);
     boolean providerMethodDependencies = checkForDependencies(providerMethods);
 
-    writer.emitEndOfLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
+    writer.emitSingleLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
     writer.emitPackage(getPackage(type).getQualifiedName().toString());
     writer.emitEmptyLine();
     writer.emitImports(
/Fim/
diff --git a/pom.xml b/pom.xml
index 74e6f8b..c189633 100644
--- a/pom.xml
+++ b/pom.xml
@@ -43,7 +43,7 @@
     <!-- Compilation -->
     <java.version>1.6</java.version>
     <javax.inject.version>1</javax.inject.version>
-    <javawriter.version>1.0.5</javawriter.version>
+    <javawriter.version>2.0.1</javawriter.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
/Fim/
diff --git a/pom.xml b/pom.xml
index c189633..4668e86 100644
--- a/pom.xml
+++ b/pom.xml
@@ -43,7 +43,7 @@
     <!-- Compilation -->
     <java.version>1.6</java.version>
     <javax.inject.version>1</javax.inject.version>
-    <javawriter.version>2.0.1</javawriter.version>
+    <javawriter.version>2.1.1</javawriter.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index d7d5962..1f5c7fc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.squareup.javawriter.JavaWriter;
+import dagger.Lazy;
 import dagger.Module;
 import dagger.Provides;
 import dagger.internal.Binding;
@@ -121,6 +122,8 @@
     Types types = processingEnv.getTypeUtils();
 
     Map<String, List<ExecutableElement>> result = new HashMap<String, List<ExecutableElement>>();
+
+    provides:
     for (Element providerMethod : providesMethods(env)) {
       switch (providerMethod.getEnclosingElement().getKind()) {
         case CLASS:
@@ -157,14 +160,14 @@
 
       // Invalidate return types.
       TypeMirror returnType = types.erasure(providerMethodAsExecutable.getReturnType());
-      for (String invalidTypeName : Arrays.asList("javax.inject.Provider", "dagger.Lazy")) {
+      for (String invalidTypeName : Arrays.asList(Provider.class.getCanonicalName(),
+          Lazy.class.getCanonicalName())) {
         TypeElement invalidTypeElement = elementUtils.getTypeElement(invalidTypeName);
-        if (invalidTypeElement != null) {
-          if (types.isSameType(returnType, types.erasure(invalidTypeElement.asType()))) {
-            error(String.format("@Provides method must not return %s directly: %s.%s",
-                invalidTypeElement, type.getQualifiedName(), providerMethod), providerMethod);
-            continue; // skip to next provides method.
-          }
+        if (invalidTypeElement != null && types.isSameType(returnType,
+            types.erasure(invalidTypeElement.asType()))) {
+          error(String.format("@Provides method must not return %s directly: %s.%s",
+              invalidTypeElement, type.getQualifiedName(), providerMethod), providerMethod);
+          continue provides; // Skip to next provides method.
         }
       }
 
/Fim/
diff --git a/CHANGELOG.md b/CHANGELOG.md
index cac577d..93799cf 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,10 +1,16 @@
 Change Log
 ==========
 
-Version 1.1.0 *(TBD)*
+Version 1.1.0 *(2013-07-26)*
 ----------------------------
 
- * Allow multiple contributions to Set binding via `Provides.Type.SET_VALUES`
+ * Module loading now requires code generation via the 'dagger-compiler' artifact.
+ * Allow multiple contributions to Set binding via `Provides.Type.SET_VALUES`.
+ * Request classloading from the classloader of the requesting object, not the current thread's
+   context classloader.
+ * Cache class loading at the root injector to reduce costs of loading adapters.
+ * Fix: Primitive array types are no longer incorrectly changed to their boxed type.
+ * Update JavaWriter to 2.1.1.
 
 
 Version 1.0.1 *(2013-06-03)*
/Fim/
diff --git a/pom.xml b/pom.xml
index 4668e86..10a1625 100644
--- a/pom.xml
+++ b/pom.xml
@@ -149,7 +149,7 @@
         </configuration>
         <executions>
           <execution>
-            <phase>verify</phase>
+            <phase>compile</phase>
             <goals>
               <goal>checkstyle</goal>
             </goals>
/Fim/
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AndroidModule.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AndroidModule.java
index 78a02a4..d31f738 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AndroidModule.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AndroidModule.java
@@ -37,7 +37,7 @@
 
   /**
    * Allow the application context to be injected but require that it be annotated with
-   * {@link ForApplication @Annotation} to explicitly differentiate it from an activity context.
+   * {@link ForApplication @ForApplication} to explicitly differentiate it from an activity context.
    */
   @Provides @Singleton @ForApplication Context provideApplicationContext() {
     return application;
/Fim/
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 93799cf..b2e20e9 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,7 +1,7 @@
 Change Log
 ==========
 
-Version 1.1.0 *(2013-07-26)*
+Version 1.1.0 *(2013-08-05)*
 ----------------------------
 
  * Module loading now requires code generation via the 'dagger-compiler' artifact.
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 7244949..b5e596e 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0.2-SNAPSHOT</version>
+    <version>1.1.0</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index dd1b1ab..4bcf868 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0.2-SNAPSHOT</version>
+    <version>1.1.0</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 14715d9..dc32674 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.0.2-SNAPSHOT</version>
+    <version>1.1.0</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 1bd5f10..d2ceed1 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.0.2-SNAPSHOT</version>
+    <version>1.1.0</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index 953c3ed..27b4268 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0.2-SNAPSHOT</version>
+    <version>1.1.0</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index f160be2..c155e45 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.0.2-SNAPSHOT</version>
+    <version>1.1.0</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index 10a1625..59ec160 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.0.2-SNAPSHOT</version>
+  <version>1.1.0</version>
   <name>Dagger (Parent)</name>
   <description>A JSR-330 dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -54,7 +54,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>HEAD</tag>
+    <tag>dagger-parent-1.1.0</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index b5e596e..a9f1fd5 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.1.0</version>
+    <version>1.1.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 4bcf868..c5e94d0 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.1.0</version>
+    <version>1.1.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index dc32674..87a3dc3 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.1.0</version>
+    <version>1.1.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index d2ceed1..593ccdc 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.1.0</version>
+    <version>1.1.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index 27b4268..909721b 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.1.0</version>
+    <version>1.1.1-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index c155e45..f6d31bb 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.1.0</version>
+    <version>1.1.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index 59ec160..ec9fa18 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.1.0</version>
+  <version>1.1.1-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
   <description>A JSR-330 dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -54,7 +54,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>dagger-parent-1.1.0</tag>
+    <tag>HEAD</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index e9a3292..f95285c 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -62,7 +62,13 @@
     <dependency>
       <groupId>com.google.testing.compile</groupId>
       <artifactId>compile-testing</artifactId>
-      <version>0.1</version>
+      <version>0.3</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <version>15.0</version>
       <scope>test</scope>
     </dependency>
     <dependency>
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index 9030479..b11c5e3 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -36,22 +36,22 @@
         "class Basic {",
         "  static class A { @Inject A() { } }",
         "  @Module(injects = A.class)",
-        "  static class CyclicModule { }",
+        "  static class AModule { }",
         "}"));
 
     JavaFileObject expectedModuleAdapter =
-        JavaFileObjects.forSourceString("Basic$A$$InjectAdapter", Joiner.on("\n").join(
+        JavaFileObjects.forSourceString("Basic$AModule$$ModuleAdapter", Joiner.on("\n").join(
             "import dagger.internal.ModuleAdapter;",
-            "public final class Basic$CyclicModule$$ModuleAdapter",
-            "    extends ModuleAdapter<Basic.CyclicModule> {",
+            "public final class Basic$AModule$$ModuleAdapter",
+            "    extends ModuleAdapter<Basic.AModule> {",
             "  private static final String[] INJECTS = {\"members/Basic$A\"};",
             "  private static final Class<?>[] STATIC_INJECTIONS = {};",
             "  private static final Class<?>[] INCLUDES = {};",
-            "  public Basic$CyclicModule$$ModuleAdapter() {",
+            "  public Basic$AModule$$ModuleAdapter() {",
             "    super(INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
             "  }",
-            "  @Override public Basic.CyclicModule newModule() {",
-            "    return new Basic.CyclicModule();",
+            "  @Override public Basic.AModule newModule() {",
+            "    return new Basic.AModule();",
             "  }",
             "}"));
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index cb2d34f..b0cfe10 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -22,6 +22,7 @@
 import dagger.internal.Linker;
 import dagger.internal.ProblemDetector;
 import dagger.internal.SetBinding;
+import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
@@ -95,9 +96,14 @@
     }
 
     for (Element element : modules) {
-      Map<String, Object> annotation = getAnnotation(Module.class, element);
-      TypeElement moduleType = (TypeElement) element;
+      Map<String, Object> annotation = null;
+      try {
+        annotation = getAnnotation(Module.class, element);
+      } catch (CodeGenerationIncompleteException e) {
+        continue; // skip this element. An up-stream compiler error is in play.
+      }
 
+      TypeElement moduleType = (TypeElement) element;
       if (annotation == null) {
         error("Missing @Module annotation.", moduleType);
         continue;
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index a5ca6a5..4e65315 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -23,7 +23,10 @@
 import dagger.internal.Linker;
 import dagger.internal.ModuleAdapter;
 import dagger.internal.SetBinding;
+import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
 import java.io.IOException;
+import java.io.StringWriter;
+import java.io.Writer;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.EnumSet;
@@ -47,6 +50,7 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -77,10 +81,13 @@
  */
 @SupportedAnnotationTypes({ "*" })
 public final class ModuleAdapterProcessor extends AbstractProcessor {
-  private final LinkedHashMap<String, List<ExecutableElement>> remainingTypes =
-      new LinkedHashMap<String, List<ExecutableElement>>();
   private static final String BINDINGS_MAP = JavaWriter.type(
       Map.class, String.class.getCanonicalName(), Binding.class.getCanonicalName() + "<?>");
+  private static final List<String> INVALID_RETURN_TYPES =
+      Arrays.asList(Provider.class.getCanonicalName(), Lazy.class.getCanonicalName());
+
+  private final LinkedHashMap<String, List<ExecutableElement>> remainingTypes =
+      new LinkedHashMap<String, List<ExecutableElement>>();
 
   @Override public SourceVersion getSupportedSourceVersion() {
     return SourceVersion.latestSupported();
@@ -92,19 +99,26 @@
       String typeName = i.next();
       TypeElement type = processingEnv.getElementUtils().getTypeElement(typeName);
       List<ExecutableElement> providesTypes = remainingTypes.get(typeName);
+
       try {
         // Attempt to get the annotation. If types are missing, this will throw
-        // IllegalStateException.
+        // CodeGenerationIncompleteException.
         Map<String, Object> parsedAnnotation = getAnnotation(Module.class, type);
-        try {
-          generateModuleAdapter(type, parsedAnnotation, providesTypes);
-        } catch (IOException e) {
-          error("Code gen failed: " + e, type);
-        }
-        i.remove();
-      } catch (IllegalStateException e) {
-        // a dependent type was not defined, we'll catch it on another pass
+
+        //TODO(cgruber): Figure out an initial sizing of the StringWriter.
+        StringWriter stringWriter = new StringWriter();
+        String adapterName = adapterName(type, MODULE_ADAPTER_SUFFIX);
+        generateModuleAdapter(stringWriter, adapterName, type, parsedAnnotation, providesTypes);
+        JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(adapterName, type);
+        Writer sourceWriter = sourceFile.openWriter();
+        sourceWriter.append(stringWriter.getBuffer());
+        sourceWriter.close();
+      } catch (CodeGenerationIncompleteException e) {
+        continue; // A dependent type was not defined, we'll try to catch it on another pass.
+      } catch (IOException e) {
+        error("Code gen failed: " + e, type);
       }
+      i.remove();
     }
     if (env.processingOver() && remainingTypes.size() > 0) {
       processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
@@ -163,14 +177,17 @@
 
       // Invalidate return types.
       TypeMirror returnType = types.erasure(providerMethodAsExecutable.getReturnType());
-      for (String invalidTypeName : Arrays.asList(Provider.class.getCanonicalName(),
-          Lazy.class.getCanonicalName())) {
-        TypeElement invalidTypeElement = elementUtils.getTypeElement(invalidTypeName);
-        if (invalidTypeElement != null && types.isSameType(returnType,
-            types.erasure(invalidTypeElement.asType()))) {
-          error(String.format("@Provides method must not return %s directly: %s.%s",
-              invalidTypeElement, type.getQualifiedName(), providerMethod), providerMethod);
-          continue provides; // Skip to next provides method.
+      if (!returnType.getKind().equals(TypeKind.ERROR)) {
+        // Validate if we have a type to validate (a type yet to be generated by other
+        // processors is not "invalid" in this way, so ignore).
+        for (String invalidTypeName : INVALID_RETURN_TYPES) {
+          TypeElement invalidTypeElement = elementUtils.getTypeElement(invalidTypeName);
+          if (invalidTypeElement != null && types.isSameType(returnType,
+              types.erasure(invalidTypeElement.asType()))) {
+            error(String.format("@Provides method must not return %s directly: %s.%s",
+                invalidTypeElement, type.getQualifiedName(), providerMethod), providerMethod);
+            continue provides; // Skip to next provides method.
+          }
         }
       }
 
@@ -216,8 +233,8 @@
    * Write a companion class for {@code type} that implements {@link
    * ModuleAdapter} to expose its provider methods.
    */
-  private void generateModuleAdapter(TypeElement type, Map<String, Object> module,
-      List<ExecutableElement> providerMethods) throws IOException {
+  private void generateModuleAdapter(Writer ioWriter, String adapterName, TypeElement type,
+      Map<String, Object> module, List<ExecutableElement> providerMethods) throws IOException {
     if (module == null) {
       error(type + " has @Provides methods but no @Module annotation", type);
       return;
@@ -231,10 +248,7 @@
     boolean complete = (Boolean) module.get("complete");
     boolean library = (Boolean) module.get("library");
 
-    String adapterName = adapterName(type, MODULE_ADAPTER_SUFFIX);
-    JavaFileObject sourceFile = processingEnv.getFiler()
-        .createSourceFile(adapterName, type);
-    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
+    JavaWriter writer = new JavaWriter(ioWriter);
 
     boolean multibindings = checkForMultibindings(providerMethods);
     boolean providerMethodDependencies = checkForDependencies(providerMethods);
@@ -342,8 +356,8 @@
     }
 
     for (ExecutableElement providerMethod : providerMethods) {
-      generateProvidesAdapter(writer, providerMethod, methodToClassName, methodNameToNextId,
-          library);
+      generateProvidesAdapter(
+          writer, providerMethod, methodToClassName, methodNameToNextId, library);
     }
 
     writer.endType();
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 0826adf..0f8b36c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -137,10 +137,17 @@
         return null;
       }
       @Override public Void visitError(ErrorType errorType, Void v) {
-        // There's already an error but it may not have been reported (most likely
-        // a missing import). If we throw an UnsupportedOperationException here
-        // we'll obscure the real error, so just continue.
-        result.append("error");
+        // Error type found, a type may not yet have been generated, but we need the type
+        // so we can generate the correct code in anticipation of the type being available
+        // to the compiler.
+
+        // Paramterized types which don't exist are returned as an error type whose name is "<any>"
+        if ("<any>".equals(errorType.toString())) {
+          throw new CodeGenerationIncompleteException(
+              "Type reported as <any> is likely a not-yet generated parameterized type.");
+        }
+        // TODO(cgruber): Figure out a strategy for non-FQCN cases.
+        result.append(errorType.toString());
         return null;
       }
       @Override protected Void defaultAction(TypeMirror typeMirror, Void v) {
@@ -150,19 +157,30 @@
     }, null);
   }
 
-  private static final AnnotationValueVisitor<Object, Void> VALUE_EXTRACTOR
-      = new SimpleAnnotationValueVisitor6<Object, Void>() {
-    @Override protected Object defaultAction(Object o, Void v) {
-      return o;
-    }
-    @Override public Object visitArray(List<? extends AnnotationValue> values, Void v) {
-      Object[] result = new Object[values.size()];
-      for (int i = 0; i < values.size(); i++) {
-        result[i] = values.get(i).accept(this, null);
-      }
-      return result;
-    }
-  };
+  private static final AnnotationValueVisitor<Object, Void> VALUE_EXTRACTOR =
+      new SimpleAnnotationValueVisitor6<Object, Void>() {
+        @Override public Object visitString(String s, Void p) {
+          if ("<error>".equals(s)) {
+            throw new CodeGenerationIncompleteException("Unknown type returned as <error>.");
+          } else if ("<any>".equals(s)) {
+            throw new CodeGenerationIncompleteException("Unknown type returned as <any>.");
+          }
+          return s;
+        }
+        @Override public Object visitType(TypeMirror t, Void p) {
+          return t;
+        }
+        @Override protected Object defaultAction(Object o, Void v) {
+          return o;
+        }
+        @Override public Object visitArray(List<? extends AnnotationValue> values, Void v) {
+          Object[] result = new Object[values.size()];
+          for (int i = 0; i < values.size(); i++) {
+            result[i] = values.get(i).accept(this, null);
+          }
+          return result;
+        }
+      };
 
   /**
    * Returns the annotation on {@code element} formatted as a Map. This returns
@@ -196,7 +214,6 @@
       }
       return result;
     }
-
     return null; // Annotation not found.
   }
 
@@ -327,4 +344,15 @@
     }
     return false;
   }
+
+  /**
+   * An exception thrown when a type is not extant (returns as an error type),
+   * usually as a result of another processor not having yet generated its types upon
+   * which a dagger-annotated type depends.
+   */
+  final static class CodeGenerationIncompleteException extends IllegalStateException {
+    public CodeGenerationIncompleteException(String s) {
+      super(s);
+    }
+  }
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java
index 3bbac71..578bdb3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java
@@ -18,6 +18,7 @@
 
 import dagger.Module;
 import dagger.Provides;
+import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
@@ -64,16 +65,20 @@
     Map<Element, Element> parametersToTheirMethods = new LinkedHashMap<Element, Element>();
     getAllElements(env, allElements, parametersToTheirMethods);
     for (Element element : allElements) {
+      try {
         validateProvides(element);
-        validateScoping(element);
-        validateQualifiers(element, parametersToTheirMethods);
+      } catch (CodeGenerationIncompleteException e) {
+        continue; // Upstream compiler issue in play. Ignore this element.
+      }
+      validateScoping(element);
+      validateQualifiers(element, parametersToTheirMethods);
     }
     return false;
   }
 
   private void validateProvides(Element element) {
     if (element.getAnnotation(Provides.class) != null
-        && element.getEnclosingElement().getAnnotation(Module.class) == null) {
+        && Util.getAnnotation(Module.class, element.getEnclosingElement()) == null) {
       error("@Provides methods must be declared in modules: " + elementToString(element), element);
     }
   }
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java
new file mode 100644
index 0000000..ad8ca17
--- /dev/null
+++ b/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java
@@ -0,0 +1,211 @@
+/**
+ * Copyright (c) 2013 Google, Inc.
+ * Copyright (c) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.tests.integration.validation;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.JavaFileObjects;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.annotation.processing.SupportedAnnotationTypes;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.TypeElement;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.collect.Iterables.concat;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+import static java.util.Arrays.asList;
+import static org.truth0.Truth.ASSERT;
+
+/**
+ * Tests that the annotation processor(s) will properly handle the case where
+ * code they are processing and depending on is generated by other processors
+ * in the environment, and so the types they need may not exist yet.
+ */
+@RunWith(JUnit4.class)
+public class GeneratedTypesNotReadyTest {
+  private final JavaFileObject foo = JavaFileObjects.forSourceString("Foo", Joiner.on("\n").join(
+      "package myPackage;",
+      "public interface Foo {}"
+  ));
+  private final JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
+      "import javax.inject.Inject;",
+      "import myPackage.Foo;",
+      "class Main {",
+      "  @Inject Foo f;",
+      "}"));
+
+  @Test public void withstandsMissingTypeReferencedInInjects() {
+    // TODO(cgruber): remove Foo (interface) from this when injects= analysis is fixed.
+    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import myPackage.Foo;",
+        "@Module(injects = { Main.class, myPackage.FooImpl.class })",
+        "class FooModule {",
+        "  @Provides Foo provideFoo(myPackage.FooImpl impl) {",
+        "    return impl;",
+        "  }",
+        "}"));
+
+    ASSERT.about(javaSources()).that(asList(foo, main, module))
+        .processedWith(concat(asList(new FooImplGenerator()), daggerProcessors()))
+        .compilesWithoutError();
+  }
+
+  @Test public void withstandsMissingTypeReferencedInsideModule() {
+    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import myPackage.Foo;",
+        "@Module(injects = { Main.class })",
+        "class FooModule {",
+        "  @Provides Foo provideFoo(myPackage.FooImpl impl) {",
+        "    return impl;",
+        "  }",
+        "}"));
+
+    ASSERT.about(javaSources()).that(asList(foo, module, main))
+        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
+        .compilesWithoutError();
+  }
+
+  @Test public void withstandsMissingTypeReferencedByProvidesReturnType() {
+    JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
+        "import javax.inject.Inject;",
+        "class Main {",
+        "  @Inject myPackage.FooImpl f;",
+        "}"));
+    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "@Module(injects = { Main.class })",
+        "class FooModule {",
+        "  @Provides myPackage.FooImpl provideFoo() {",
+        "    return new myPackage.FooImpl();",
+        "  }",
+        "}"));
+
+    ASSERT.about(javaSources()).that(asList(foo, module, main))
+        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
+        .compilesWithoutError();
+  }
+
+  @Test public void failsWhenMissingGenericTypeReferencedByProvidesReturnType() {
+    JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
+        "import javax.inject.Inject;",
+        "class Main {",
+        "  @Inject myPackage.FooImpl2<String> f;",
+        "}"));
+    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "@Module(injects = { Main.class })",
+        "class FooModule {",
+        "  @Provides myPackage.FooImpl2<String> provideFoo() {",
+        "    return new myPackage.FooImpl2<String>();",
+        "  }",
+        "}"));
+
+    ASSERT.about(javaSources()).that(asList(foo, module, main))
+        .processedWith(new FooImplGenerator())
+        .compilesWithoutError();
+    ASSERT.about(javaSources()).that(asList(foo, module, main))
+        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
+        .failsToCompile()
+        .withErrorContaining("Could not find types required by provides methods for [FooModule]");
+  }
+
+  @Test public void withstandsMissingTypeReferencedInTransitiveJITDependency() {
+    JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
+        "import javax.inject.Inject;",
+        "import myPackage.FooImpl;",
+        "class Main {",
+        "  @Inject FooImpl f;",
+        "}"));
+    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "@Module(injects = { Main.class })",
+        "class FooModule {",
+        "}"));
+
+    ASSERT.about(javaSources()).that(asList(foo, module, main))
+        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
+        .compilesWithoutError();
+  }
+
+  @Test public void verifyFooImplGeneratorIsCompilingWithoutDagger() {
+    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import myPackage.Foo;",
+        "@Module(injects = { Main.class })",
+        "class FooModule {",
+        "  @Provides Foo provideFoo(myPackage.FooImpl impl) {",
+        "    return impl;",
+        "  }",
+        "}"));
+    ASSERT.about(javaSources()).that(asList(foo, module, main))
+        .processedWith(new FooImplGenerator())
+        .compilesWithoutError();
+  }
+
+  @SupportedAnnotationTypes("*")
+  private final class FooImplGenerator extends AbstractProcessor {
+    boolean written = false;
+    @Override public boolean process(Set<? extends TypeElement> na1, RoundEnvironment na2) {
+      if (!written) {
+        try {
+          JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile("FooImpl");
+          Writer writer = sourceFile.openWriter();
+          writer.write(Joiner.on("\n").join(
+              "package myPackage;",
+              "import javax.inject.Inject;",
+              "public final class FooImpl implements Foo {",
+              "  @Inject public FooImpl() { }",
+              "}"));
+          writer.close();
+          sourceFile = processingEnv.getFiler().createSourceFile("FooImpl2");
+          writer = sourceFile.openWriter();
+          writer.write(Joiner.on("\n").join(
+              "package myPackage;",
+              "import javax.inject.Inject;",
+              "public final class FooImpl2<T> implements Foo {",
+              "  @Inject public FooImpl2() { }",
+              "}"));
+          writer.close();
+          written = true;
+        } catch (IOException e) {
+          throw new RuntimeException(e);
+        }
+      }
+      return false;
+    }
+
+    @Override public SourceVersion getSupportedSourceVersion() {
+      return SourceVersion.latestSupported();
+    }
+  }
+
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
index 1c27451..0f2a6e1 100644
--- a/core/src/main/java/dagger/internal/FailoverLoader.java
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -30,13 +30,18 @@
  * reflective equivalent.
  */
 public final class FailoverLoader extends Loader {
+  /*
+   * Note that String.concat is used throughout this code because it is the most efficient way to
+   * concatenate _two_ strings.  javac uses StringBuilder for the + operator and it has proven to
+   * be wasteful in terms of both CPU and memory allocated.
+   */
 
   /**
    * Obtains a module adapter for {@code module} from the first responding resolver.
    */
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> type, T instance) {
     ModuleAdapter<T> result =
-        instantiate(type.getName() + MODULE_ADAPTER_SUFFIX, type.getClassLoader());
+        instantiate(type.getName().concat(MODULE_ADAPTER_SUFFIX), type.getClassLoader());
     if (result == null) {
       throw new IllegalStateException("Module adapter for " + type + " could not be loaded. "
           + "Please ensure that code generation was run for this module.");
@@ -47,7 +52,7 @@
 
   @Override public Binding<?> getAtInjectBinding(
       String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
-    Binding<?> result = instantiate(className + INJECT_ADAPTER_SUFFIX, classLoader);
+    Binding<?> result = instantiate(className.concat(INJECT_ADAPTER_SUFFIX), classLoader);
     if (result != null) {
       return result; // Found loadable adapter, returning it.
     }
@@ -64,7 +69,7 @@
 
   @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
     StaticInjection result = instantiate(
-          injectedClass.getName() + STATIC_INJECTION_SUFFIX, injectedClass.getClassLoader());
+          injectedClass.getName().concat(STATIC_INJECTION_SUFFIX), injectedClass.getClassLoader());
     if (result != null) {
       return result;
     }
/Fim/
diff --git a/checkstyle.xml b/checkstyle.xml
index 830f252..6c0b11e 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -55,8 +55,9 @@
         <module name="AvoidStarImport"/>
         <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
         <module name="RedundantImport"/>
-        <module name="UnusedImports"/>
-
+        <module name="UnusedImports">
+            <property name="processJavadoc" value="true"/>
+        </module>
 
         <!-- Checks for Size Violations.                    -->
         <!-- See http://checkstyle.sf.net/config_sizes.html -->
/Fim/
diff --git a/core/src/main/java/dagger/internal/Loader.java b/core/src/main/java/dagger/internal/Loader.java
index ed81ede..35b5e67 100644
--- a/core/src/main/java/dagger/internal/Loader.java
+++ b/core/src/main/java/dagger/internal/Loader.java
@@ -16,8 +16,8 @@
  */
 package dagger.internal;
 
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.AccessibleObject;
+
 
 /**
  * Provides a point of configuration of the basic resolving functions within Dagger, namely
@@ -71,7 +71,8 @@
   }
 
   /**
-   * Instantiates a class using its default constructor and the given {@link ClassLoader}.
+   * Instantiates a class using its default constructor and the given {@link ClassLoader}. This
+   * method does not attempt to {@linkplain AccessibleObject#setAccessible set accessibility}.
    */
   protected <T> T instantiate(String name, ClassLoader classLoader) {
     try {
@@ -79,17 +80,13 @@
       if (generatedClass == Void.class) {
         return null;
       }
-      Constructor<?> constructor = generatedClass.getDeclaredConstructor();
-      constructor.setAccessible(true);
-      return (T) constructor.newInstance();
-    } catch (NoSuchMethodException e) {
-      throw new RuntimeException("No default constructor found on " + name, e);
+      @SuppressWarnings("unchecked")
+      T instance = (T) generatedClass.newInstance();
+      return instance;
     } catch (InstantiationException e) {
       throw new RuntimeException("Failed to initialize " + name, e);
     } catch (IllegalAccessException e) {
       throw new RuntimeException("Failed to initialize " + name, e);
-    } catch (InvocationTargetException e) {
-      throw new RuntimeException("Error while initializing " + name, e.getCause());
     }
   }
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index 0f0c280..8be0c96 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -167,7 +167,7 @@
 
     Linker.ErrorHandler errorHandler = ignoreCompletenessErrors ? Linker.ErrorHandler.NULL
         : new GraphAnalysisErrorHandler(processingEnv, rootModule.getQualifiedName().toString());
-    Linker linker = new Linker(new GraphAnalysisLoader(processingEnv), errorHandler);
+    Linker linker = new Linker(null, new GraphAnalysisLoader(processingEnv), errorHandler);
     // Linker requires synchronization for calls to requestBinding and linkAll.
     // We know statically that we're single threaded, but we synchronize anyway
     // to make the linker happy.
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 03b3d8c..bbe7b00 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -160,26 +160,8 @@
       Map<String, Class<?>> injectableTypes = new LinkedHashMap<String, Class<?>>();
       Map<Class<?>, StaticInjection> staticInjections
           = new LinkedHashMap<Class<?>, StaticInjection>();
-
-      // Extract bindings in the 'base' and 'overrides' set. Within each set no
-      // duplicates are permitted.
-      UniqueMap<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>() {
-        @Override public Binding<?> put(String key, Binding<?> value) {
-          return super.put(key, (value instanceof SetBinding)
-              ? new SetBinding<Object>((SetBinding<Object>) value) : value);
-        }
-      };
-      if (base != null) {
-        baseBindings.putAll(base.linkEverything()); // Add parent bindings
-      }
-      UniqueMap<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>() {
-        @Override public Binding<?> put(String key, Binding<?> value) {
-          if (value instanceof SetBinding) {
-            throw new IllegalArgumentException("Module overrides cannot contribute set bindings.");
-          }
-          return super.put(key, value);
-        }
-      };
+      UniqueMap<String, Binding<?>> baseBindings = initBaseBindings(base);
+      UniqueMap<String, Binding<?>> overrideBindings = initOverrideBindings();
 
       Map<ModuleAdapter<?>, Object> loadedModules = Modules.loadModules(plugin, modules);
       for (Entry<ModuleAdapter<?>, Object> loadedModule : loadedModules.entrySet()) {
@@ -201,12 +183,48 @@
       }
 
       // Create a linker and install all of the user's bindings
-      Linker linker = new Linker(plugin, new ThrowingErrorHandler());
+      Linker linker =
+          new Linker((base != null) ? base.linker : null, plugin, new ThrowingErrorHandler());
       linker.installBindings(baseBindings);
       linker.installBindings(overrideBindings);
 
-      return new DaggerObjectGraph(base, linker, plugin, staticInjections,
-          injectableTypes);
+      return new DaggerObjectGraph(base, linker, plugin, staticInjections, injectableTypes);
+    }
+
+    /**
+     * Returns an empty {@code UniqueMap} which will throw errors if a SetBinding is added
+     * to it.
+     */
+    private static UniqueMap<String, Binding<?>> initOverrideBindings() {
+      return new UniqueMap<String, Binding<?>>() {
+        @Override public Binding<?> put(String key, Binding<?> value) {
+          if (value instanceof SetBinding) {
+            throw new IllegalArgumentException("Module overrides cannot contribute set bindings.");
+          }
+          return super.put(key, value);
+        }
+      };
+    }
+
+    /**
+     * Extract bindings in the 'base' and 'overrides' set. Within each set no
+     * duplicates are permitted.  Set-bindings are propagated (and cloned) from the parent
+     * to ensure that parent graph participants only see parent bindings, but the child
+     * graph sees parent+child contributions.
+     */
+    private static UniqueMap<String, Binding<?>> initBaseBindings(
+        DaggerObjectGraph base) {
+      UniqueMap<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>();
+      if (base != null) {
+        Map<String, Binding<?>> parentBindings = base.linkEverything();
+        for (Map.Entry<String, Binding<?>> bindingEntry : parentBindings.entrySet()) {
+          if (bindingEntry.getValue() instanceof SetBinding) {
+            baseBindings.put(bindingEntry.getKey(),
+                new SetBinding<Object>((SetBinding<Object>) bindingEntry.getValue()));
+          }
+        }
+      }
+      return baseBindings;
     }
 
     @Override public ObjectGraph plus(Object... modules) {
@@ -240,10 +258,17 @@
      * Links all bindings, injectable types and static injections.
      */
     private Map<String, Binding<?>> linkEverything() {
+      Map<String, Binding<?>> bindings = linker.fullyLinkedBindings();
+      if (bindings != null) {
+        return bindings;
+      }
       synchronized (linker) {
+        if ((bindings = linker.fullyLinkedBindings()) != null) {
+          return bindings;
+        }
         linkStaticInjections();
         linkInjectableTypes();
-        return linker.linkAll();
+        return linker.linkAll(); // Linker.linkAll() implicitly does Linker.linkRequested().
       }
     }
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index adc9396..d68256b 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -17,6 +17,7 @@
 
 import dagger.internal.Binding.InvalidBindingException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
@@ -30,6 +31,13 @@
 public final class Linker {
   private static final Object UNINITIALIZED = new Object();
 
+  /**
+   * The base {@code Linker} which will be consulted to satisfy bindings not
+   * otherwise satisfiable from this {@code Linker}. The top-most {@code Linker}
+   * in a chain will have a null base linker.
+   */
+  private final Linker base;
+
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
   private final Queue<Binding<?>> toLink = new LinkedList<Binding<?>>();
 
@@ -42,14 +50,23 @@
   /** All of the object graph's bindings. This may contain unlinked bindings. */
   private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
 
+  /**
+   * An unmodifiable map containing all of the bindings available in this linker, fully linked.
+   * This will be null if the bindings are not yet fully linked. It provides both a signal
+   * of completion of the {@link #linkAll()} method, as well as a place to reference the final,
+   * fully linked map of bindings.
+   */
+  private volatile Map<String, Binding<?>> linkedBindings = null;
+
   private final Loader plugin;
 
   private final ErrorHandler errorHandler;
 
-  public Linker(Loader plugin, ErrorHandler errorHandler) {
+  public Linker(Linker base, Loader plugin, ErrorHandler errorHandler) {
     if (plugin == null) throw new NullPointerException("plugin");
     if (errorHandler == null) throw new NullPointerException("errorHandler");
 
+    this.base = base;
     this.plugin = plugin;
     this.errorHandler = errorHandler;
   }
@@ -58,37 +75,60 @@
    * Adds all bindings in {@code toInstall}. The caller must call either {@link
    * #linkAll} or {@link #requestBinding} and {@link #linkRequested} before the
    * bindings can be used.
+   *
+   * This method may only be called before {@link #linkAll()}. Subsequent calls to
+   * {@link #installBindings()} will throw an {@link IllegalStateException}.
    */
   public void installBindings(Map<String, ? extends Binding<?>> toInstall) {
+    if (linkedBindings != null) {
+      throw new IllegalStateException("Cannot install further bindings after calling linkAll().");
+    }
     for (Map.Entry<String, ? extends Binding<?>> entry : toInstall.entrySet()) {
       bindings.put(entry.getKey(), scope(entry.getValue()));
     }
   }
 
   /**
-   * Links requested bindings and installed bindings, plus all of their
-   * transitive dependencies. This creates JIT bindings as necessary to fill in
-   * the gaps.
+   * Links all known bindings (whether requested or installed), plus all of their
+   * transitive dependencies. This loads injectable types' bindings as necessary to fill in
+   * the gaps.  If this method has returned successfully at least once, all further
+   * work is short-circuited.
    *
-   * @return all bindings known by this linker, which will all be linked.
+   * @throws AssertionError if this method is not called within a synchronized block which
+   *     holds this {@link Linker} as the lock object.
    */
   public Map<String, Binding<?>> linkAll() {
+    assertLockHeld();
+    if (linkedBindings != null) {
+      return linkedBindings;
+    }
     for (Binding<?> binding : bindings.values()) {
       if (!binding.isLinked()) {
         toLink.add(binding);
       }
     }
-    linkRequested();
-    return bindings;
+    linkRequested(); // This method throws if bindings are not resolvable/linkable.
+    linkedBindings = Collections.unmodifiableMap(bindings);
+    return linkedBindings;
+  }
+
+  /**
+   * Returns the map of all bindings available to this {@link Linker}, if and only if
+   * {@link #linkAll()} has successfully returned at least once, otherwise it returns null;
+   */
+  public Map<String, Binding<?>> fullyLinkedBindings() {
+    return linkedBindings;
   }
 
   /**
    * Links all requested bindings plus their transitive dependencies. This
    * creates JIT bindings as necessary to fill in the gaps.
+   *
+   * @throws AssertionError if this method is not called within a synchronized block which
+   *     holds this {@link Linker} as the lock object.
    */
   public void linkRequested() {
     assertLockHeld();
-
     Binding<?> binding;
     while ((binding = toLink.poll()) != null) {
       if (binding instanceof DeferredBinding) {
@@ -229,7 +269,15 @@
       boolean mustHaveInjections, boolean library) {
     assertLockHeld();
 
-    Binding<?> binding = bindings.get(key);
+    Binding<?> binding = null;
+    for (Linker linker = this; linker != null; linker = linker.base) {
+      binding = linker.bindings.get(key);
+      if (binding != null) {
+        if (linker != this && !binding.isLinked()) throw new AssertionError();
+        break;
+      }
+    }
+
     if (binding == null) {
       // We can't satisfy this binding. Make sure it'll work next time!
       Binding<?> deferredBinding =
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index 909721b..0693929 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -70,7 +70,7 @@
         <plugin>
           <groupId>com.jayway.maven.plugins.android.generation2</groupId>
           <artifactId>android-maven-plugin</artifactId>
-          <version>3.6.0</version>
+          <version>3.8.0</version>
           <configuration>
             <sdk>
               <platform>16</platform>
/Fim/
diff --git a/pom.xml b/pom.xml
index ec9fa18..2374958 100644
--- a/pom.xml
+++ b/pom.xml
@@ -43,7 +43,7 @@
     <!-- Compilation -->
     <java.version>1.6</java.version>
     <javax.inject.version>1</javax.inject.version>
-    <javawriter.version>2.1.1</javawriter.version>
+    <javawriter.version>2.3.0</javawriter.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 741ea2a..3d4635b 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -41,6 +41,11 @@
       <groupId>com.squareup</groupId>
       <artifactId>javawriter</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <version>15.0</version>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -66,12 +71,6 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <version>15.0</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
       <groupId>org.truth0</groupId>
       <artifactId>truth</artifactId>
       <version>0.13</version>
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 5503e17..586a693 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -15,6 +15,11 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Ordering;
 import com.squareup.javawriter.JavaWriter;
 import dagger.Lazy;
 import dagger.Module;
@@ -66,9 +71,9 @@
 import static dagger.internal.codegen.Util.getNoArgsConstructor;
 import static dagger.internal.codegen.Util.getPackage;
 import static dagger.internal.codegen.Util.isCallableConstructor;
-import static dagger.internal.codegen.Util.isInterface;
 import static dagger.internal.codegen.Util.typeToString;
 import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
+import static java.util.Arrays.asList;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -264,15 +269,33 @@
     writer.beginType(adapterName, "class", EnumSet.of(PUBLIC, FINAL),
         JavaWriter.type(ModuleAdapter.class, typeName));
 
-    StringBuilder injectsField = new StringBuilder().append("{ ");
-    for (Object injectableType : injects) {
-      TypeMirror typeMirror = (TypeMirror) injectableType;
-      String key = isInterface(typeMirror)
-          ? GeneratorKeys.get(typeMirror)
-          : GeneratorKeys.rawMembersKey(typeMirror);
-      injectsField.append(JavaWriter.stringLiteral(key)).append(", ");
-    }
-    injectsField.append("}");
+    final List<String> providedTypes = FluentIterable.from(providerMethods)
+        .transform(new Function<ExecutableElement, String>() {
+          @Override public String apply(ExecutableElement element) {
+            return GeneratorKeys.get(element.getReturnType());
+          }
+        }).toList();
+    StringBuilder injectsField = new StringBuilder("{");
+    Iterable<String> injectsFieldKeys = FluentIterable.<Object>from(asList(injects))
+        .transform(new Cast<TypeMirror>())
+        .transformAndConcat(new Function<TypeMirror, Iterable<String>>() {
+          @Override public Iterable<String> apply(TypeMirror type) {
+            String key = GeneratorKeys.get(type);
+            if (!providedTypes.contains(key) && Util.needsMemberInjection(type)) {
+              String membersKey = GeneratorKeys.rawMembersKey(type);
+              Iterable<String> keys = ImmutableList.of(membersKey, key);
+              return keys;
+            }
+            return ImmutableList.of(key);
+          }
+        })
+        .transform(new Function<String, String>() {
+          @Override public String apply(String key) {
+            return JavaWriter.stringLiteral(key);
+          }
+        })
+        .toSortedSet(Ordering.natural());
+    Joiner.on(", ").appendTo(injectsField, injectsFieldKeys).append("}");
     writer.emitField("String[]", "INJECTS", EnumSet.of(PRIVATE, STATIC, FINAL),
         injectsField.toString());
 
@@ -513,4 +536,17 @@
     }
     return parameter.getSimpleName().toString();
   }
+
+  /**
+   * A function used to perform a cast to a strongly known type.  This does not actually
+   * perform any casting logic, but bridges Java's typesystem.  {@link Cast} should only
+   * be used in circumstances where the cast is bullet-proof and safe.
+   */
+  private static final class Cast<T> implements Function<Object, T> {
+    @SuppressWarnings("unchecked")
+    @Override
+    public T apply(Object o) {
+      return (T) o;
+    }
+  }
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 0f8b36c..0007859 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,12 +16,15 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
 import dagger.internal.Keys;
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.AnnotationValueVisitor;
@@ -31,12 +34,14 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ErrorType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVariable;
+import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
@@ -238,6 +243,23 @@
     }
   }
 
+  /**
+   * Returns true if the type reflected by this TypeMirror contains @Inject fields.
+   */
+  public static boolean needsMemberInjection(TypeMirror type) {
+    return type.accept(new SimpleTypeVisitor6<Boolean, Void>() {
+      @Override public Boolean visitDeclared(DeclaredType declaredType, Void v) {
+        List<? extends Element> enclosed = declaredType.asElement().getEnclosedElements();
+        return FluentIterable.<VariableElement>from(ElementFilter.fieldsIn(enclosed))
+            .anyMatch(new Predicate<VariableElement>() {
+              @Override public boolean apply(VariableElement e) {
+                return e.getAnnotation(Inject.class) != null;
+              }
+            });
+      }
+    }, null);
+  }
+
   // TODO(sgoldfed): better format for other types of elements?
   static String elementToString(Element element) {
     switch (element.getKind()) {
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index aec56e5..857b546 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -44,7 +44,7 @@
             "import dagger.internal.ModuleAdapter;",
             "public final class Basic$AModule$$ModuleAdapter",
             "    extends ModuleAdapter<Basic.AModule> {",
-            "  private static final String[] INJECTS = {\"members/Basic$A\"};",
+            "  private static final String[] INJECTS = {\"Basic$A\"};",
             "  private static final Class<?>[] STATIC_INJECTIONS = {};",
             "  private static final Class<?>[] INCLUDES = {};",
             "  public Basic$AModule$$ModuleAdapter() {",
@@ -99,7 +99,7 @@
         "import javax.inject.Inject;",
         "class Field {",
         "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
-        "  @Module(injects = A.class)",
+        "  @Module(injects = { A.class, String.class })",
         "  static class AModule { @Provides String name() { return \"foo\"; }}",
         "}"));
 
@@ -111,7 +111,8 @@
         "import javax.inject.Provider;",
         "public final class Field$AModule$$ModuleAdapter",
         "    extends ModuleAdapter<Field.AModule> {",
-        "  private static final String[] INJECTS = {\"members/Field$A\"};",
+        "  private static final String[] INJECTS = ",
+        "      {\"Field$A\", \"java.lang.String\"};",
         "  private static final Class<?>[] STATIC_INJECTIONS = {};",
         "  private static final Class<?>[] INCLUDES = {};",
         "  public Field$AModule$$ModuleAdapter() {",
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
index b321126..d7af842 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
@@ -23,6 +23,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static java.util.Arrays.asList;
@@ -30,6 +31,115 @@
 
 @RunWith(JUnit4.class)
 public final class ModuleAdapterGenerationTest {
+  @Test public void injectsMembersInjectedAndProvidedAndConstructedTypes() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "class Field {",
+        "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
+        "  static class B { @Inject String name; }",
+        "  @Module(injects = { A.class, String.class, B.class })",
+        "  static class AModule { @Provides String name() { return \"foo\"; }}",
+        "}"));
+
+    JavaFileObject expectedModuleAdapter =
+        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
+        "import dagger.internal.Binding;",
+        "import dagger.internal.ModuleAdapter;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "public final class Field$AModule$$ModuleAdapter extends ModuleAdapter<Field.AModule> {",
+        "  private static final String[] INJECTS = ",
+        "      {\"Field$A\", \"Field$B\", \"java.lang.String\", \"members/Field$B\"};",
+        "  private static final Class<?>[] STATIC_INJECTIONS = {};",
+        "  private static final Class<?>[] INCLUDES = {};",
+        "  public Field$AModule$$ModuleAdapter() {",
+        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
+        "  }",
+        "  @Override public Field.AModule newModule() {",
+        "    return new Field.AModule();",
+        "  }",
+        "  @Override public void getBindings(Map<String, Binding<?>> map, Field.AModule module) {",
+        "    map.put(\"java.lang.String\", new NameProvidesAdapter(module));", // eager new!
+        "  }",
+        "  public static final class NameProvidesAdapter", // corresponds to method name
+        "      extends Binding<String> implements Provider<String> {",
+        "    private final Field.AModule module;",
+        "    public NameProvidesAdapter(Field.AModule module) {",
+        "      super(\"java.lang.String\", null, NOT_SINGLETON, \"Field.AModule.name()\");",
+        "      this.module = module;",
+        "      setLibrary(false);",
+        "    }",
+        "    @Override public String get() {",
+        "      return module.name();", // corresponds to @Provides method
+        "    }",
+        "  }",
+        "}"));
+
+    JavaFileObject expectedInjectAdapterA =
+        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
+            "import dagger.internal.Binding;",
+            "import dagger.internal.Linker;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "public final class Field$A$$InjectAdapter",
+            "    extends Binding<Field.A> implements Provider<Field.A> {",
+            "  private Binding<String> name;", // For Constructor.
+            "  public Field$A$$InjectAdapter() {",
+            "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
+            "  }",
+            "  @Override @SuppressWarnings(\"unchecked\")",
+            "  public void attach(Linker linker) {",
+            "    name = (Binding<String>)linker.requestBinding(",
+            "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());",
+            "  }",
+            "  @Override public void getDependencies(",
+            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
+            "    getBindings.add(name);", // Name is added to dependencies.
+            "  }",
+            "  @Override public Field.A get() {",
+            "    Field.A result = new Field.A(name.get());", // Adds constructor parameter.
+            "    return result;",
+            "  }",
+            "}"));
+
+    JavaFileObject expectedInjectAdapterB =
+        JavaFileObjects.forSourceString("Field$B$$InjectAdapter", Joiner.on("\n").join(
+            "import dagger.MembersInjector;",
+            "import dagger.internal.Binding;",
+            "import dagger.internal.Linker;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "public final class Field$B$$InjectAdapter",
+            "    extends Binding<Field.B> implements Provider<Field.B>, MembersInjector<Field.B> {",
+            "  private Binding<String> name;", // For field.
+            "  public Field$B$$InjectAdapter() {",
+            "    super(\"Field$B\", \"members/Field$B\", NOT_SINGLETON, Field.B.class);",
+            "  }",
+            "  @Override @SuppressWarnings(\"unchecked\")",
+            "  public void attach(Linker linker) {",
+            "    name = (Binding<String>)linker.requestBinding(",
+            "      \"java.lang.String\", Field.B.class, getClass().getClassLoader());",
+            "  }",
+            "  @Override public void getDependencies(",
+            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
+            "    injectMembersBindings.add(name);", // Name is added to dependencies.
+            "  }",
+            "  @Override public Field.B get() {",
+            "    Field.B result = new Field.B();",
+            "    injectMembers(result);",
+            "    return result;",
+            "  }",
+            "  @Override public void injectMembers(Field.B object) {",
+            "    object.name = name.get();", // Inject field.
+            "  }",
+            "}"));
+    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expectedModuleAdapter, expectedInjectAdapterA, expectedInjectAdapterB);
+  }
 
   @Test public void providesHasParameterNamedModule() {
     JavaFileObject a = JavaFileObjects.forSourceString("A", Joiner.on("\n").join(
@@ -42,12 +152,10 @@
     JavaFileObject module = JavaFileObjects.forSourceString("BModule", Joiner.on("\n").join(
         "import dagger.Module;",
         "import dagger.Provides;",
-        "import javax.inject.Inject;",
         "@Module(injects = B.class)",
         "class BModule { @Provides B b(A module) { return new B(); }}"));
 
     ASSERT.about(javaSources()).that(asList(a, b, module)).processedWith(daggerProcessors())
         .compilesWithoutError();
   }
-
 }
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 3d4635b..af04081 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -44,7 +44,6 @@
     <dependency>
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
-      <version>15.0</version>
     </dependency>
 
     <dependency>
@@ -67,13 +66,11 @@
     <dependency>
       <groupId>com.google.testing.compile</groupId>
       <artifactId>compile-testing</artifactId>
-      <version>0.4</version>
       <scope>test</scope>
     </dependency>
     <dependency>
       <groupId>org.truth0</groupId>
       <artifactId>truth</artifactId>
-      <version>0.13</version>
       <scope>test</scope>
     </dependency>
   </dependencies>
/Fim/
diff --git a/pom.xml b/pom.xml
index 2374958..9b9e3e9 100644
--- a/pom.xml
+++ b/pom.xml
@@ -44,10 +44,13 @@
     <java.version>1.6</java.version>
     <javax.inject.version>1</javax.inject.version>
     <javawriter.version>2.3.0</javawriter.version>
+    <guava.version>15.0</guava.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
     <fest.version>1.4</fest.version>
+    <truth.version>0.13</truth.version>
+    <compile-testing.version>0.4</compile-testing.version>
   </properties>
 
   <scm>
@@ -87,6 +90,11 @@
         <version>${javawriter.version}</version>
       </dependency>
       <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava</artifactId>
+        <version>${guava.version}</version>
+      </dependency>
+      <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
         <version>${junit.version}</version>
@@ -96,6 +104,16 @@
         <artifactId>fest-assert</artifactId>
         <version>${fest.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.testing.compile</groupId>
+        <artifactId>compile-testing</artifactId>
+        <version>${compile-testing.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.truth0</groupId>
+        <artifactId>truth</artifactId>
+        <version>${truth.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
/Fim/
diff --git a/pom.xml b/pom.xml
index 9b9e3e9..c47825c 100644
--- a/pom.xml
+++ b/pom.xml
@@ -28,7 +28,7 @@
   <packaging>pom</packaging>
   <version>1.1.1-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
-  <description>A JSR-330 dependency injector for Android and Java.</description>
+  <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
 
   <modules>
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index af04081..1d5d587 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -129,6 +129,24 @@
           </execution>
         </executions>
       </plugin>
+
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-assembly-plugin</artifactId>
+        <configuration>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
     </plugins>
   </build>
 </project>
/Fim/
diff --git a/CHANGELOG.md b/CHANGELOG.md
index b2e20e9..2d88fe6 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,20 @@
 Change Log
 ==========
 
+Version 1.2.0 *(2013-11-25)*
+----------------------------
+
+ * Numerous performance improvements in both the compiler and runtime.
+   * Use more efficient `String` concatenation.
+   * Module adapters are now stateless.
+   * Use read/write locks over global locks.
+   * Reflective constructor invocation is now cached with `Class.newInstance`.
+   * Avoid re-linking all bindings when calling `.plus()`.
+ * Set bindings are now unioned when calling `.plus()`.
+ * Fix: Tolerate missing type information during compilation by deferring writing
+   module adapters.
+
+
 Version 1.1.0 *(2013-08-05)*
 ----------------------------
 
/Fim/
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 2d88fe6..957840e 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,7 +1,7 @@
 Change Log
 ==========
 
-Version 1.2.0 *(2013-11-25)*
+Version 1.2.0 *(2013-12-13)*
 ----------------------------
 
  * Numerous performance improvements in both the compiler and runtime.
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 1d5d587..ac63bcf 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.0</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index c5e94d0..984482e 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.0</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 87a3dc3..eab6e70 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.0</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 593ccdc..2612386 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.0</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index 0693929..760cf5d 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.0</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index f6d31bb..7f8dee3 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.1.1-SNAPSHOT</version>
+    <version>1.2.0</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index c47825c..ece0bd8 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.1.1-SNAPSHOT</version>
+  <version>1.2.0</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -57,7 +57,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>HEAD</tag>
+    <tag>dagger-parent-1.2.0</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index ac63bcf..0321791 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.0</version>
+    <version>1.2.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 984482e..f77c919 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.0</version>
+    <version>1.2.1-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index eab6e70..893da12 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.0</version>
+    <version>1.2.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 2612386..8744874 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.0</version>
+    <version>1.2.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index 760cf5d..fb0367d 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.0</version>
+    <version>1.2.1-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 7f8dee3..5f04bca 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.0</version>
+    <version>1.2.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index ece0bd8..abd22dc 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.2.0</version>
+  <version>1.2.1-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -57,7 +57,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>dagger-parent-1.2.0</tag>
+    <tag>HEAD</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 1341639..795a59e 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -16,13 +16,13 @@
 package dagger.internal;
 
 import dagger.internal.Binding.InvalidBindingException;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Deque;
 import java.util.HashMap;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
-import java.util.Queue;
 import java.util.Set;
 
 /**
@@ -39,7 +39,7 @@
   private final Linker base;
 
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
-  private final Queue<Binding<?>> toLink = new LinkedList<Binding<?>>();
+  private final Deque<Binding<?>> toLink = new ArrayDeque<Binding<?>>();
 
   /** True unless calls to requestBinding() were unable to satisfy the binding. */
   private boolean attachSuccess = true;
/Fim/
diff --git a/.travis.yml b/.travis.yml
index 2420f98..9f3fd48 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -2,21 +2,17 @@
 
 jdk:
   - oraclejdk7
-  - openjdk7 
+  - openjdk7
 
 before_install:
-  - sudo apt-get update -qq
-  - if [ `uname -m` = x86_64 ]; then sudo apt-get install -qq --force-yes libgd2-xpm ia32-libs ia32-libs-multiarch; fi
-  - wget http://dl.google.com/android/android-sdk_r21.0.1-linux.tgz
-  - echo "Installing android SDK into ${PWD}/android-sdk-linux"
-  - tar -xzf android-sdk_r21.0.1-linux.tgz
-  - export ANDROID_HOME=${PWD}/android-sdk-linux
-  - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
-  - android update sdk --filter platform-tools,android-16 --no-ui --force
+  - sudo apt-get install -qq libstdc++6:i386 lib32z1
+  - export COMPONENTS=build-tools-19.0.1,android-16
+  - curl -L https://raw.github.com/embarkmobile/android-sdk-installer/version-1/android-sdk-installer | bash /dev/stdin --install=$COMPONENTS
+  - source ~/.android-sdk-installer/env
 
 install: mvn install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
 
-script: mvn verify 
+script: mvn verify
 
 notifications:
   email: false
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index e5d5428..a1736d2 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -184,8 +184,8 @@
           BindingsGroup addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
           moduleAdapter.getBindings(addTo, loadedModule.getValue());
         } catch (IllegalArgumentException e) {
-          throw new IllegalArgumentException(moduleAdapter.moduleClass.getSimpleName()
-              + " is an overriding module and cannot contribute set bindings.");
+          throw new IllegalArgumentException(
+              moduleAdapter.moduleClass.getSimpleName() + ": " + e.getMessage(), e);
         }
       }
 
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java b/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
index 30b4929..2a62953 100644
--- a/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
+++ b/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
@@ -28,6 +28,7 @@
 import static dagger.Provides.Type.SET;
 import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 @RunWith(JUnit4.class)
@@ -56,6 +57,16 @@
     @Provides(type=SET) @Singleton Integer provideD() { return counter.getAndIncrement(); }
   }
 
+  @Module
+  static class EmptyModule {
+  }
+
+  @Module(library = true)
+  static class DuplicateModule {
+    @Provides @Singleton String provideFoo() { return "foo"; }
+    @Provides @Singleton String provideBar() { return "bar"; }
+  }
+
   @Test public void basicInjectionWithExtension() {
     ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule());
     RealSingleton rs = root.get(RealSingleton.class);
@@ -81,8 +92,16 @@
       ObjectGraph.createWith(new TestingLoader(), new RootModule()).plus(new TestModule());
       fail("Should throw exception.");
     } catch (IllegalArgumentException e) {
-      assertEquals("TestModule is an overriding module and cannot contribute set bindings.",
-          e.getMessage());
+      assertEquals("TestModule: Module overrides cannot contribute set bindings.", e.getMessage());
+    }
+  }
+
+  @Test public void duplicateBindingsInSecondaryModule() {
+    try {
+      ObjectGraph.createWith(new TestingLoader(), new EmptyModule(), new DuplicateModule());
+      fail("Should throw exception.");
+    } catch (IllegalArgumentException e) {
+      assertTrue(e.getMessage().startsWith("DuplicateModule: Duplicate"));
     }
   }
 }
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index f77c919..b11be09 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -48,6 +48,24 @@
   <build>
     <plugins>
       <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>1.8</version><!-- 1.9+ requires JDK7 -->
+        <executions>
+          <execution>
+            <id>sniff-api</id>
+            <goals><goal>check</goal></goals>
+          </execution>
+        </executions>
+        <configuration>
+          <signature>
+            <groupId>org.codehaus.mojo.signature</groupId>
+            <artifactId>java15</artifactId>
+            <version>1.0</version>
+          </signature>
+        </configuration>
+      </plugin>
+      <plugin>
         <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
           <excludePackageNames>dagger.internal:dagger.internal.*</excludePackageNames>
/Fim/
diff --git a/core/src/main/java/dagger/internal/ArrayQueue.java b/core/src/main/java/dagger/internal/ArrayQueue.java
new file mode 100644
index 0000000..690b6d9
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ArrayQueue.java
@@ -0,0 +1,607 @@
+/*
+ * Written by Josh Bloch of Google Inc. and released to the public domain,
+ * as explained at http://creativecommons.org/publicdomain/zero/1.0/.
+ *
+ * Adapted from https://android.googlesource.com/platform/libcore/+
+ *     android-4.2.2_r1/luni/src/main/java/java/util/ArrayDeque.java
+ */
+package dagger.internal;
+
+import java.lang.reflect.Array;
+import java.util.AbstractCollection;
+import java.util.Collection;
+import java.util.ConcurrentModificationException;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.Queue;
+
+/**
+ * Resizable-array implementation of the {@link Queue} interface.  Array
+ * queues have no capacity restrictions; they grow as necessary to support
+ * usage.  They are not thread-safe; in the absence of external
+ * synchronization, they do not support concurrent access by multiple threads.
+ * Null elements are prohibited.  This class is likely to be faster than
+ * {@link LinkedList} when used as a queue.
+ *
+ * <p>Most <tt>ArrayBackedQueue</tt> operations run in amortized constant time.
+ * Exceptions include {@link #remove(Object) remove}, {@link
+ * #removeFirstOccurrence removeFirstOccurrence}, {@link #contains contains},
+ * {@link #iterator iterator.remove()}, and the bulk operations, all of which
+ * run in linear time.
+ *
+ * <p>The iterators returned by this class's <tt>iterator</tt> method are
+ * <i>fail-fast</i>: If the queue is modified at any time after the iterator
+ * is created, in any way except through the iterator's own <tt>remove</tt>
+ * method, the iterator will generally throw a {@link
+ * ConcurrentModificationException}.  Thus, in the face of concurrent
+ * modification, the iterator fails quickly and cleanly, rather than risking
+ * arbitrary, non-deterministic behavior at an undetermined time in the
+ * future.
+ *
+ * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed
+ * as it is, generally speaking, impossible to make any hard guarantees in the
+ * presence of unsynchronized concurrent modification.  Fail-fast iterators
+ * throw <tt>ConcurrentModificationException</tt> on a best-effort basis.
+ * Therefore, it would be wrong to write a program that depended on this
+ * exception for its correctness: <i>the fail-fast behavior of iterators
+ * should be used only to detect bugs.</i>
+ *
+ * <p>This class and its iterator implement all of the
+ * <em>optional</em> methods of the {@link Collection} and {@link
+ * Iterator} interfaces.
+ *
+ * @author  Josh Bloch and Doug Lea
+ * @param <E> the type of elements held in this collection
+ */
+public class ArrayQueue<E> extends AbstractCollection<E>
+                           implements Queue<E>, Cloneable, java.io.Serializable {
+    /**
+     * The array in which the elements of the queue are stored.
+     * The capacity of the queue is the length of this array, which is
+     * always a power of two. The array is never allowed to become
+     * full, except transiently within an addX method where it is
+     * resized (see doubleCapacity) immediately upon becoming full,
+     * thus avoiding head and tail wrapping around to equal each
+     * other.  We also guarantee that all array cells not holding
+     * queue elements are always null.
+     */
+    private transient Object[] elements;
+
+    /**
+     * The index of the element at the head of the queue (which is the
+     * element that would be removed by remove() or pop()); or an
+     * arbitrary number equal to tail if the queue is empty.
+     */
+    private transient int head;
+
+    /**
+     * The index at which the next element would be added to the tail
+     * of the queue (via addLast(E), add(E), or push(E)).
+     */
+    private transient int tail;
+
+    /**
+     * The minimum capacity that we'll use for a newly created queue.
+     * Must be a power of 2.
+     */
+    private static final int MIN_INITIAL_CAPACITY = 8;
+
+    // ******  Array allocation and resizing utilities ******
+
+    /**
+     * Allocate empty array to hold the given number of elements.
+     *
+     * @param numElements  the number of elements to hold
+     */
+    private void allocateElements(int numElements) {
+        int initialCapacity = MIN_INITIAL_CAPACITY;
+        // Find the best power of two to hold elements.
+        // Tests "<=" because arrays aren't kept full.
+        if (numElements >= initialCapacity) {
+            initialCapacity = numElements;
+            initialCapacity |= (initialCapacity >>>  1);
+            initialCapacity |= (initialCapacity >>>  2);
+            initialCapacity |= (initialCapacity >>>  4);
+            initialCapacity |= (initialCapacity >>>  8);
+            initialCapacity |= (initialCapacity >>> 16);
+            initialCapacity++;
+
+            if (initialCapacity < 0)   // Too many elements, must back off
+                initialCapacity >>>= 1; // Good luck allocating 2 ^ 30 elements
+        }
+        elements = new Object[initialCapacity];
+    }
+
+    /**
+     * Double the capacity of this queue.  Call only when full, i.e.,
+     * when head and tail have wrapped around to become equal.
+     */
+    private void doubleCapacity() {
+        // assert head == tail;
+        int p = head;
+        int n = elements.length;
+        int r = n - p; // number of elements to the right of p
+        int newCapacity = n << 1;
+        if (newCapacity < 0)
+            throw new IllegalStateException("Sorry, queue too big");
+        Object[] a = new Object[newCapacity];
+        System.arraycopy(elements, p, a, 0, r);
+        System.arraycopy(elements, 0, a, r, p);
+        elements = a;
+        head = 0;
+        tail = n;
+    }
+
+    /**
+     * Constructs an empty array queue with an initial capacity
+     * sufficient to hold 16 elements.
+     */
+    public ArrayQueue() {
+        elements = new Object[16];
+    }
+
+    /**
+     * Constructs an empty array queue with an initial capacity
+     * sufficient to hold the specified number of elements.
+     *
+     * @param numElements  lower bound on initial capacity of the queue
+     */
+    public ArrayQueue(int numElements) {
+        allocateElements(numElements);
+    }
+
+    /**
+     * Constructs a queue containing the elements of the specified
+     * collection, in the order they are returned by the collection's
+     * iterator.  (The first element returned by the collection's
+     * iterator becomes the first element, or <i>front</i> of the
+     * queue.)
+     *
+     * @param c the collection whose elements are to be placed into the queue
+     * @throws NullPointerException if the specified collection is null
+     */
+    public ArrayQueue(Collection<? extends E> c) {
+        allocateElements(c.size());
+        addAll(c);
+    }
+
+    /**
+     * Inserts the specified element at the end of this queue.
+     *
+     * <p>This method is equivalent to {@link #offer}.
+     *
+     * @param e the element to add
+     * @return <tt>true</tt> (as specified by {@link Collection#add})
+     * @throws NullPointerException if the specified element is null
+     */
+    @Override
+    public boolean add(E e) {
+        if (e == null)
+            throw new NullPointerException("e == null");
+        elements[tail] = e;
+        if ((tail = (tail + 1) & (elements.length - 1)) == head)
+            doubleCapacity();
+        return true;
+    }
+
+    /**
+     * Inserts the specified element at the end of this queue.
+     *
+     * @param e the element to add
+     * @return <tt>true</tt> (as specified by {@link Queue#offer})
+     * @throws NullPointerException if the specified element is null
+     */
+    @Override
+    public boolean offer(E e) {
+        return add(e);
+    }
+
+    /**
+     * Retrieves and removes the head of the queue represented by this queue.
+     *
+     * This method differs from {@link #poll poll} only in that it throws an
+     * exception if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue
+     * @throws NoSuchElementException {@inheritDoc}
+     */
+    @Override
+    public E remove() {
+        E x = poll();
+        if (x == null)
+            throw new NoSuchElementException();
+        return x;
+    }
+
+    /**
+     * Retrieves and removes the head of the queue represented by this queue
+     * (in other words, the first element of this queue), or returns
+     * <tt>null</tt> if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue, or
+     *         <tt>null</tt> if this queue is empty
+     */
+    @Override
+    public E poll() {
+        int h = head;
+        @SuppressWarnings("unchecked") E result = (E) elements[h];
+        // Element is null if queue empty
+        if (result == null)
+            return null;
+        elements[h] = null;     // Must null out slot
+        head = (h + 1) & (elements.length - 1);
+        return result;
+    }
+
+    /**
+     * Retrieves, but does not remove, the head of the queue represented by
+     * this queue.  This method differs from {@link #peek peek} only in
+     * that it throws an exception if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue
+     * @throws NoSuchElementException {@inheritDoc}
+     */
+    @Override
+    public E element() {
+        @SuppressWarnings("unchecked") E result = (E) elements[head];
+        if (result == null)
+            throw new NoSuchElementException();
+        return result;
+    }
+
+    /**
+     * Retrieves, but does not remove, the head of the queue represented by
+     * this queue, or returns <tt>null</tt> if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue, or
+     *         <tt>null</tt> if this queue is empty
+     */
+    @Override
+    public E peek() {
+        @SuppressWarnings("unchecked") E result = (E) elements[head];
+        // elements[head] is null if queue empty
+        return result;
+    }
+
+    /**
+     * Removes the element at the specified position in the elements array,
+     * adjusting head and tail as necessary.  This can result in motion of
+     * elements backwards or forwards in the array.
+     *
+     * <p>This method is called delete rather than remove to emphasize
+     * that its semantics differ from those of {@link List#remove(int)}.
+     *
+     * @return true if elements moved backwards
+     */
+    private boolean delete(int i) {
+        //checkInvariants();
+        final Object[] elements = this.elements;
+        final int mask = elements.length - 1;
+        final int h = head;
+        final int t = tail;
+        final int front = (i - h) & mask;
+        final int back  = (t - i) & mask;
+
+        // Invariant: head <= i < tail mod circularity
+        if (front >= ((t - h) & mask))
+            throw new ConcurrentModificationException();
+
+        // Optimize for least element motion
+        if (front < back) {
+            if (h <= i) {
+                System.arraycopy(elements, h, elements, h + 1, front);
+            } else { // Wrap around
+                System.arraycopy(elements, 0, elements, 1, i);
+                elements[0] = elements[mask];
+                System.arraycopy(elements, h, elements, h + 1, mask - h);
+            }
+            elements[h] = null;
+            head = (h + 1) & mask;
+            return false;
+        } else {
+            if (i < t) { // Copy the null tail as well
+                System.arraycopy(elements, i + 1, elements, i, back);
+                tail = t - 1;
+            } else { // Wrap around
+                System.arraycopy(elements, i + 1, elements, i, mask - i);
+                elements[mask] = elements[0];
+                System.arraycopy(elements, 1, elements, 0, t);
+                tail = (t - 1) & mask;
+            }
+            return true;
+        }
+    }
+
+    // *** Collection Methods ***
+
+    /**
+     * Returns the number of elements in this queue.
+     *
+     * @return the number of elements in this queue
+     */
+    @Override
+    public int size() {
+        return (tail - head) & (elements.length - 1);
+    }
+
+    /**
+     * Returns <tt>true</tt> if this queue contains no elements.
+     *
+     * @return <tt>true</tt> if this queue contains no elements
+     */
+    @Override
+    public boolean isEmpty() {
+        return head == tail;
+    }
+
+    /**
+     * Returns an iterator over the elements in this queue.  The elements
+     * will be ordered from first (head) to last (tail).  This is the same
+     * order that elements would be queueued (via successive calls to
+     * {@link #remove} or popped (via successive calls to {@link #pop}).
+     *
+     * @return an iterator over the elements in this queue
+     */
+    @Override
+    public Iterator<E> iterator() {
+        return new QueueIterator();
+    }
+
+
+    private class QueueIterator implements Iterator<E> {
+        /**
+         * Index of element to be returned by subsequent call to next.
+         */
+        private int cursor = head;
+
+        /**
+         * Tail recorded at construction (also in remove), to stop
+         * iterator and also to check for comodification.
+         */
+        private int fence = tail;
+
+        /**
+         * Index of element returned by most recent call to next.
+         * Reset to -1 if element is deleted by a call to remove.
+         */
+        private int lastRet = -1;
+
+        @Override
+        public boolean hasNext() {
+            return cursor != fence;
+        }
+
+        @Override
+        public E next() {
+            if (cursor == fence)
+                throw new NoSuchElementException();
+            @SuppressWarnings("unchecked") E result = (E) elements[cursor];
+            // This check doesn't catch all possible comodifications,
+            // but does catch the ones that corrupt traversal
+            if (tail != fence || result == null)
+                throw new ConcurrentModificationException();
+            lastRet = cursor;
+            cursor = (cursor + 1) & (elements.length - 1);
+            return result;
+        }
+
+        @Override
+        public void remove() {
+            if (lastRet < 0)
+                throw new IllegalStateException();
+            if (delete(lastRet)) { // if left-shifted, undo increment in next()
+                cursor = (cursor - 1) & (elements.length - 1);
+                fence = tail;
+            }
+            lastRet = -1;
+        }
+    }
+
+    /**
+     * Returns <tt>true</tt> if this queue contains the specified element.
+     * More formally, returns <tt>true</tt> if and only if this queue contains
+     * at least one element <tt>e</tt> such that <tt>o.equals(e)</tt>.
+     *
+     * @param o object to be checked for containment in this queue
+     * @return <tt>true</tt> if this queue contains the specified element
+     */
+    @Override
+    public boolean contains(Object o) {
+        if (o == null)
+            return false;
+        int mask = elements.length - 1;
+        int i = head;
+        Object x;
+        while ((x = elements[i]) != null) {
+            if (o.equals(x))
+                return true;
+            i = (i + 1) & mask;
+        }
+        return false;
+    }
+
+    /**
+     * Removes a single instance of the specified element from this queue.
+     * If the queue does not contain the element, it is unchanged.
+     * More formally, removes the first element <tt>e</tt> such that
+     * <tt>o.equals(e)</tt> (if such an element exists).
+     * Returns <tt>true</tt> if this queue contained the specified element
+     * (or equivalently, if this queue changed as a result of the call).
+     *
+     * @param o element to be removed from this queue, if present
+     * @return <tt>true</tt> if this queue contained the specified element
+     */
+    @Override
+    public boolean remove(Object o) {
+        if (o == null)
+            return false;
+        int mask = elements.length - 1;
+        int i = head;
+        Object x;
+        while ((x = elements[i]) != null) {
+            if (o.equals(x)) {
+                delete(i);
+                return true;
+            }
+            i = (i + 1) & mask;
+        }
+        return false;
+    }
+
+    /**
+     * Removes all of the elements from this queue.
+     * The queue will be empty after this call returns.
+     */
+    @Override
+    public void clear() {
+        int h = head;
+        int t = tail;
+        if (h != t) { // clear all cells
+            head = tail = 0;
+            int i = h;
+            int mask = elements.length - 1;
+            do {
+                elements[i] = null;
+                i = (i + 1) & mask;
+            } while (i != t);
+        }
+    }
+
+    /**
+     * Returns an array containing all of the elements in this queue
+     * in proper sequence (from first to last element).
+     *
+     * <p>The returned array will be "safe" in that no references to it are
+     * maintained by this queue.  (In other words, this method must allocate
+     * a new array).  The caller is thus free to modify the returned array.
+     *
+     * <p>This method acts as bridge between array-based and collection-based
+     * APIs.
+     *
+     * @return an array containing all of the elements in this queue
+     */
+    @Override
+    public Object[] toArray() {
+        return toArray(new Object[size()]);
+    }
+
+    /**
+     * Returns an array containing all of the elements in this queue in
+     * proper sequence (from first to last element); the runtime type of the
+     * returned array is that of the specified array.  If the queue fits in
+     * the specified array, it is returned therein.  Otherwise, a new array
+     * is allocated with the runtime type of the specified array and the
+     * size of this queue.
+     *
+     * <p>If this queue fits in the specified array with room to spare
+     * (i.e., the array has more elements than this queue), the element in
+     * the array immediately following the end of the queue is set to
+     * <tt>null</tt>.
+     *
+     * <p>Like the {@link #toArray()} method, this method acts as bridge between
+     * array-based and collection-based APIs.  Further, this method allows
+     * precise control over the runtime type of the output array, and may,
+     * under certain circumstances, be used to save allocation costs.
+     *
+     * <p>Suppose <tt>x</tt> is a queue known to contain only strings.
+     * The following code can be used to dump the queue into a newly
+     * allocated array of <tt>String</tt>:
+     *
+     *  <pre> {@code String[] y = x.toArray(new String[0]);}</pre>
+     *
+     * Note that <tt>toArray(new Object[0])</tt> is identical in function to
+     * <tt>toArray()</tt>.
+     *
+     * @param a the array into which the elements of the queue are to
+     *          be stored, if it is big enough; otherwise, a new array of the
+     *          same runtime type is allocated for this purpose
+     * @return an array containing all of the elements in this queue
+     * @throws ArrayStoreException if the runtime type of the specified array
+     *         is not a supertype of the runtime type of every element in
+     *         this queue
+     * @throws NullPointerException if the specified array is null
+     */
+    @Override
+    public <T> T[] toArray(T[] a) {
+        int size = size();
+        if (a.length < size)
+            a = (T[]) java.lang.reflect.Array.newInstance(
+                    a.getClass().getComponentType(), size);
+        if (head < tail) {
+            System.arraycopy(elements, head, a, 0, size());
+        } else if (head > tail) {
+            int headPortionLen = elements.length - head;
+            System.arraycopy(elements, head, a, 0, headPortionLen);
+            System.arraycopy(elements, 0, a, headPortionLen, tail);
+        }
+        if (a.length > size)
+            a[size] = null;
+        return a;
+    }
+
+    // *** Object methods ***
+
+    /**
+     * Returns a copy of this queue.
+     *
+     * @return a copy of this queue
+     */
+    @Override
+    public ArrayQueue<E> clone() {
+        try {
+            ArrayQueue<E> result = (ArrayQueue<E>) super.clone();
+            E[] newElements = (E[]) Array.newInstance(elements.getClass().getComponentType(),
+                elements.length);
+            System.arraycopy(elements, 0, newElements, 0, elements.length);
+            result.elements = newElements;
+            return result;
+        } catch (CloneNotSupportedException e) {
+            throw new AssertionError();
+        }
+    }
+
+    /**
+     * Appease the serialization gods.
+     */
+    private static final long serialVersionUID = 2340985798034038923L;
+
+    /**
+     * Serialize this queue.
+     *
+     * @serialData The current size (<tt>int</tt>) of the queue,
+     * followed by all of its elements (each an object reference) in
+     * first-to-last order.
+     */
+    private void writeObject(java.io.ObjectOutputStream s)
+            throws java.io.IOException {
+        s.defaultWriteObject();
+
+        // Write out size
+        s.writeInt(size());
+
+        // Write out elements in order.
+        int mask = elements.length - 1;
+        for (int i = head; i != tail; i = (i + 1) & mask)
+            s.writeObject(elements[i]);
+    }
+
+    /**
+     * Deserialize this queue.
+     */
+    private void readObject(java.io.ObjectInputStream s)
+            throws java.io.IOException, ClassNotFoundException {
+        s.defaultReadObject();
+
+        // Read in size and allocate array
+        int size = s.readInt();
+        allocateElements(size);
+        head = 0;
+        tail = size;
+
+        // Read in all elements in the proper order.
+        for (int i = 0; i < size; i++)
+            elements[i] = s.readObject();
+    }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 795a59e..5852e26 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -16,13 +16,12 @@
 package dagger.internal;
 
 import dagger.internal.Binding.InvalidBindingException;
-import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Deque;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
 import java.util.Set;
 
 /**
@@ -39,7 +38,7 @@
   private final Linker base;
 
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
-  private final Deque<Binding<?>> toLink = new ArrayDeque<Binding<?>>();
+  private final Queue<Binding<?>> toLink = new ArrayQueue<Binding<?>>();
 
   /** True unless calls to requestBinding() were unable to satisfy the binding. */
   private boolean attachSuccess = true;
/Fim/
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 957840e..da3a586 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,14 @@
 Change Log
 ==========
 
+Version 1.2.1 *(2014-02-16)*
+----------------------------
+
+ * Restore Java 5 compatibility.
+ * New: Improve performance of `.plus()` with large volumes of set bindings.
+ * Fix: Do not mask underlying exception message from binding problems when constructing a graph.
+
+
 Version 1.2.0 *(2013-12-13)*
 ----------------------------
 
/Fim/
diff --git a/pom.xml b/pom.xml
index abd22dc..dbe464a 100644
--- a/pom.xml
+++ b/pom.xml
@@ -150,7 +150,14 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-release-plugin</artifactId>
-        <version>2.3.2</version>
+        <version>2.4.2</version>
+        <dependencies>
+          <dependency>
+            <groupId>org.apache.maven.scm</groupId>
+            <artifactId>maven-scm-provider-gitexe</artifactId>
+            <version>1.9</version>
+          </dependency>
+        </dependencies>
         <configuration>
           <autoVersionSubmodules>true</autoVersionSubmodules>
         </configuration>
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 0321791..328cd1f 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.1-SNAPSHOT</version>
+    <version>1.2.1</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index b11be09..6f2682d 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.1-SNAPSHOT</version>
+    <version>1.2.1</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 893da12..3bad599 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.1-SNAPSHOT</version>
+    <version>1.2.1</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 8744874..848134f 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.1-SNAPSHOT</version>
+    <version>1.2.1</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index 34ceb17..098ab51 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.1-SNAPSHOT</version>
+    <version>1.2.1</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 5f04bca..66503e9 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.1-SNAPSHOT</version>
+    <version>1.2.1</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index dbe464a..4146392 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.2.1-SNAPSHOT</version>
+  <version>1.2.1</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -57,7 +57,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>HEAD</tag>
+    <tag>dagger-parent-1.2.1</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 328cd1f..61dde23 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.1</version>
+    <version>1.2.2-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 6f2682d..ffc7b14 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.1</version>
+    <version>1.2.2-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 3bad599..4d231ca 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.1</version>
+    <version>1.2.2-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 848134f..e37a0a3 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.1</version>
+    <version>1.2.2-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index 098ab51..492d6eb 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.1</version>
+    <version>1.2.2-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 66503e9..7264be7 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.1</version>
+    <version>1.2.2-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index 4146392..d242f68 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.2.1</version>
+  <version>1.2.2-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -57,7 +57,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>dagger-parent-1.2.1</tag>
+    <tag>HEAD</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/website/index.html b/website/index.html
index 7d8b0d4..f29a511 100644
--- a/website/index.html
+++ b/website/index.html
@@ -451,7 +451,7 @@
               <ul class="nav nav-pills nav-stacked secondary">
                 <li><a href="javadoc/index.html">Javadoc</a></li>
                 <li><a href="https://groups.google.com/forum/#!forum/dagger-discuss">dagger-discuss@</a></li>
-                <li><a href="https://plus.google.com/communities/109244258569782858265/stream/bab12891-7685-4e0c-8dcb-f85cd0ca31c0">Google+ Community</a></li>
+                <li><a href="http://stackoverflow.com/questions/tagged/dagger?sort=active">StackOverflow</a></li>
               </ul>
             </div>
           </div>
@@ -475,7 +475,7 @@
 
         // Spy on scroll position for real-time updating of current section.
         $('body').scrollspy();
-        
+
         // Use smooth-scroll for internal links.
         $('a').smoothScroll();
 
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
index 1afd4d9..153bf9d 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
@@ -52,9 +52,7 @@
         "}"));
 
     ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining("0. CyclicDeps$Foo bound by").in(sourceFile).onLine(17).and()
-        .withErrorContaining("1. CyclicDeps$Bar bound by").in(sourceFile).onLine(17).and()
-        .withErrorContaining("2. CyclicDeps$Blah bound by").in(sourceFile).onLine(17);
+        .withErrorContaining("Dependency cycle:").in(sourceFile).onLine(17);
   }
 
   @Test public void cyclicDepsWithProvidesMethods() {
@@ -76,10 +74,7 @@
         "}"));
 
     ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining("0. CyclicDeps$A bound by Provides").in(sourceFile).onLine(9).and()
-        .withErrorContaining("1. CyclicDeps$D bound by Provides").in(sourceFile).onLine(9).and()
-        .withErrorContaining("2. CyclicDeps$C bound by Provides").in(sourceFile).onLine(9).and()
-        .withErrorContaining("3. CyclicDeps$B bound by Provides").in(sourceFile).onLine(9);
+        .withErrorContaining("Dependency cycle:").in(sourceFile).onLine(9);
   }
 
 }
/Fim/
diff --git a/.travis.yml b/.travis.yml
index 9f3fd48..9c633cb 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,6 +1,7 @@
 language: java
 
 jdk:
+  - oraclejdk8
   - oraclejdk7
   - openjdk7
 
/Fim/
diff --git a/CHANGELOG.md b/CHANGELOG.md
index da3a586..40dc58d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,13 @@
 Change Log
 ==========
 
+Version 1.2.2 *(2014-07-21)*
+----------------------------
+
+ * Update JavaWriter to 2.5.0. This fixes incorrectly compressing fully-qualified class names
+   in child packages of `java.lang` (e.g., `java.lang.ref.WeakReference`).
+
+
 Version 1.2.1 *(2014-02-16)*
 ----------------------------
 
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 61dde23..3c571f3 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>1.2.2</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index ffc7b14..df59306 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>1.2.2</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 4d231ca..c7b65b9 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>1.2.2</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index e37a0a3..d9759b2 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>1.2.2</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index 492d6eb..8ba70ba 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>1.2.2</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 7264be7..c11150d 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>1.2.2</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index 27cd3f4..b82035f 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.2.2-SNAPSHOT</version>
+  <version>1.2.2</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -57,7 +57,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>HEAD</tag>
+    <tag>dagger-parent-1.2.2</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 3c571f3..50f7c67 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.2</version>
+    <version>1.2.3-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index df59306..c61aeb7 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.2</version>
+    <version>1.2.3-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index c7b65b9..0bc2598 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.2</version>
+    <version>1.2.3-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index d9759b2..f99b22d 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.2</version>
+    <version>1.2.3-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index 8ba70ba..0b9b984 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.2</version>
+    <version>1.2.3-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index c11150d..19df04d 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.2</version>
+    <version>1.2.3-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index b82035f..7639984 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.2.2</version>
+  <version>1.2.3-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -57,7 +57,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>dagger-parent-1.2.2</tag>
+    <tag>HEAD</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/FailureModeErrorsTest.java b/compiler/src/test/java/dagger/tests/integration/operation/FailureModeErrorsTest.java
new file mode 100644
index 0000000..fe4d0ee
--- /dev/null
+++ b/compiler/src/test/java/dagger/tests/integration/operation/FailureModeErrorsTest.java
@@ -0,0 +1,76 @@
+/**
+ * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.tests.integration.operation;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import javax.inject.Inject;
+import javax.inject.Qualifier;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static junit.framework.Assert.fail;
+import static org.fest.assertions.Assertions.assertThat;
+
+@RunWith(JUnit4.class)
+public final class FailureModeErrorsTest {
+
+  @Module
+  static class CompleteModule {}
+
+  static class ArrayFoo {
+    @Inject ArrayFoo(String[] ignored) {}
+  }
+
+  @Module(injects = ArrayFoo.class, complete = false)
+  static class ArrayFooModule {}
+
+  @Test public void failOnMissingModule_arrayorgenerics() {
+    // Generics here are crazy to try to test for, but this code path is legit regardless.
+    try {
+      ObjectGraph.create(new CompleteModule(), new ArrayFooModule()).get(ArrayFoo.class);
+      fail("Should have thrown.");
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).contains(
+          "java.lang.String[] is a generic class or an array and can only be bound with "
+          + "concrete type parameter(s) in a @Provides method. required by class "
+          + "dagger.tests.integration.operation.FailureModeErrorsTest$ArrayFoo");
+    }
+  }
+
+  @Qualifier @interface MyFoo {}
+
+  static class QualifyingFoo {
+    @Inject QualifyingFoo(@MyFoo String ignored) {}
+  }
+
+  @Module(injects = QualifyingFoo.class, complete = false)
+  static class QualifyingFooModule {}
+
+  @Test public void failOnMissingModule_qualified() {
+    try {
+      ObjectGraph.create(new CompleteModule(), new QualifyingFooModule()).get(QualifyingFoo.class);
+      fail("Should have thrown.");
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()).contains(
+          "@dagger.tests.integration.operation.FailureModeErrorsTest$MyFoo()/java.lang.String "
+          + "is a @Qualifier-annotated type and must be bound by a @Provides method. required by "
+          + "class dagger.tests.integration.operation.FailureModeErrorsTest$QualifyingFoo");
+    }
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 5852e26..e9cf9f4 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -217,9 +217,14 @@
     }
 
     String className = Keys.getClassName(key);
-    if (className == null || Keys.isAnnotated(key)) {
-      // Cannot jit-bind annotated keys or generic types.
-      throw new IllegalArgumentException(key);
+    if (className == null) {
+      throw new InvalidBindingException(key,
+          "is a generic class or an array and can only be bound with concrete type parameter(s) "
+          + "in a @Provides method.");
+    }
+    if (Keys.isAnnotated(key)) {
+      throw new InvalidBindingException(key,
+          "is a @Qualifier-annotated type and must be bound by a @Provides method.");
     }
     Binding<?> binding =
         plugin.getAtInjectBinding(key, className, classLoader, mustHaveInjections);
/Fim/
diff --git a/.travis.yml b/.travis.yml
index 9c633cb..59ef3a2 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,15 +1,16 @@
-language: java
+language: android
 
 jdk:
   - oraclejdk8
   - oraclejdk7
   - openjdk7
 
-before_install:
-  - sudo apt-get install -qq libstdc++6:i386 lib32z1
-  - export COMPONENTS=build-tools-19.0.1,android-16
-  - curl -L https://raw.github.com/embarkmobile/android-sdk-installer/version-1/android-sdk-installer | bash /dev/stdin --install=$COMPONENTS
-  - source ~/.android-sdk-installer/env
+android:
+  components:
+    - build-tools-20.0.0
+    - android-16
+  licenses:
+    - android-sdk-license-5be876d5
 
 install: mvn install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index e2d74f2..32c5a8b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -213,7 +213,7 @@
       TypeElement moduleType = (TypeElement) module;
 
       // Verify that all modules do not extend from non-Object types.
-      if (!moduleType.getSuperclass().equals(objectType)) {
+      if (!types.isSameType(moduleType.getSuperclass(), objectType)) {
         error("Modules must not extend from other classes: " + elementToString(module), module);
       }
 
/Fim/
diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
new file mode 100755
index 0000000..c667dd0
--- /dev/null
+++ b/.buildscript/deploy_snapshot.sh
@@ -0,0 +1,24 @@
+#!/bin/bash
+#
+# Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
+#
+# Adapted from https://coderwall.com/p/9b_lfq and
+# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
+
+SLUG="square/dagger"
+JDK="oraclejdk7" # Dagger integration tests fail on JDK 8 :(
+BRANCH="master"
+
+if [ "$TRAVIS_REPO_SLUG" != "$SLUG" ]; then
+  echo "Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'."
+elif [ "$TRAVIS_JDK_VERSION" != "$JDK" ]; then
+  echo "Skipping snapshot deployment: wrong JDK. Expected '$JDK' but was '$TRAVIS_JDK_VERSION'."
+elif [ "$TRAVIS_PULL_REQUEST" != "false" ]; then
+  echo "Skipping snapshot deployment: was pull request."
+elif [ "$TRAVIS_BRANCH" != "$BRANCH" ]; then
+  echo "Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'."
+else
+  echo "Deploying snapshot..."
+  mvn clean source:jar javadoc:jar deploy --settings=".buildscript/settings.xml" -Dmaven.test.skip=true
+  echo "Snapshot deployed!"
+fi
/Fim/
diff --git a/.buildscript/settings.xml b/.buildscript/settings.xml
new file mode 100644
index 0000000..91f444b
--- /dev/null
+++ b/.buildscript/settings.xml
@@ -0,0 +1,9 @@
+<settings>
+  <servers>
+    <server>
+      <id>sonatype-nexus-snapshots</id>
+      <username>${env.CI_DEPLOY_USERNAME}</username>
+      <password>${env.CI_DEPLOY_PASSWORD}</password>
+    </server>
+  </servers>
+</settings>
/Fim/
diff --git a/.travis.yml b/.travis.yml
index 59ef3a2..b8ca075 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,10 +1,5 @@
 language: android
 
-jdk:
-  - oraclejdk8
-  - oraclejdk7
-  - openjdk7
-
 android:
   components:
     - build-tools-20.0.0
@@ -12,13 +7,31 @@
   licenses:
     - android-sdk-license-5be876d5
 
+jdk:
+  - oraclejdk7
+  # - oraclejdk8 Dagger integration tests fail with JDK 8 :(
+
 install: mvn install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
 
 script: mvn verify
 
-notifications:
-  email: false
+after_success:
+  - .buildscript/deploy_snapshot.sh
+
+env:
+  global:
+    - secure: "MhR0Wr+bSbdyO6a6CM2MVHLwmFZoi8ZWWncMCNSi8/xdRoykpC1HkwJjQK+HJv7j3VNbVTPNJ/yTpzJsL4JV9aTF/S28mka8GmHSmQSeQzTuNMqnE30GDbhS3S73azGHvC9/wjh1mAA0Gz/zUX/rzCYvDVZ/DmK1HppomN+P32A="
+    - secure: "fnHK/ei7tdcUDlQZcXWVPRgXoIFv6h0TWSzz4spgNtFlYqa47Qr4HQOLyEpWRqZHjgfR5eXD+CCI049Z73cg5oVOp1krV0aGX/wHc5lDMJuCrBZ/YoWZnDygiPzM4CvrpxRE7DjqzC0InVdbEbuECiFsI2WotLdQ6efgaxjpZCk="
 
 branches:
   except:
     - gh-pages
+
+notifications:
+  email: false
+
+sudo: false
+
+cache:
+  directories:
+    - $HOME/.m2
/Fim/
diff --git a/README.md b/README.md
index 290c716..8fdc4e3 100644
--- a/README.md
+++ b/README.md
@@ -38,6 +38,8 @@
 You can also find downloadable .jars on Maven Central. You'll need
 [Dagger][dl-dagger], [JavaWriter][dl-javawriter], and [javax.inject][dl-inject].
 
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+
 
 
 License
@@ -63,3 +65,4 @@
  [dl-dagger]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.dagger%22%20a%3A%22dagger%22
  [dl-javawriter]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup%22%20a%3A%22javawriter%22
  [dl-inject]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22javax.inject%22%20a%3A%22javax.inject%22
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
/Fim/
diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
index c667dd0..53601b2 100755
--- a/.buildscript/deploy_snapshot.sh
+++ b/.buildscript/deploy_snapshot.sh
@@ -9,6 +9,8 @@
 JDK="oraclejdk7" # Dagger integration tests fail on JDK 8 :(
 BRANCH="master"
 
+set -e
+
 if [ "$TRAVIS_REPO_SLUG" != "$SLUG" ]; then
   echo "Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'."
 elif [ "$TRAVIS_JDK_VERSION" != "$JDK" ]; then
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 50f7c67..8810067 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -39,7 +39,7 @@
     </dependency>
     <dependency>
       <groupId>com.squareup</groupId>
-      <artifactId>javawriter</artifactId>
+      <artifactId>javapoet</artifactId>
     </dependency>
     <dependency>
       <groupId>com.google.guava</groupId>
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java b/compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java
index c525ea3..33c73aa 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java
@@ -15,6 +15,9 @@
  */
 package dagger.internal.codegen;
 
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.TypeName;
+
 /**
  * Utility class providing some commonly used boilerplate between {@code InjectAdapterProcessor}
  * and {@code ModuleAdapterProcessor}.
@@ -23,46 +26,46 @@
   static final String GENERATED_BY_DAGGER = "Code generated by dagger-compiler.  Do not edit.";
   static final String MEMBERS_INJECT_METHOD = ""
       + "Injects any {@code @Inject} annotated fields in the given instance,\n"
-      + "satisfying the contract for {@code Provider<%s>}.";
+      + "satisfying the contract for {@code Provider<$T>}.\n";
   static final String GET_METHOD = ""
       + "Returns the fully provisioned instance satisfying the contract for\n"
-      + "{@code Provider<%s>}.";
+      + "{@code Provider<$T>}.\n";
   static final String GET_DEPENDENCIES_METHOD = ""
       + "Used internally obtain dependency information, such as for cyclical\n"
-      + "graph detection.";
+      + "graph detection.\n";
   static final String ATTACH_METHOD = ""
       + "Used internally to link bindings/providers together at run time\n"
-      + "according to their dependency graph.";
+      + "according to their dependency graph.\n";
   static final String STATIC_INJECT_METHOD = ""
       + "Performs the injections of dependencies into static fields when requested by\n"
-      + "the {@code dagger.ObjectGraph}.";
+      + "the {@code $T}.\n";
   static final String MODULE_TYPE = ""
       + "A manager of modules and provides adapters allowing for proper linking and\n"
-      + "instance provision of types served by {@code @Provides} methods.";
+      + "instance provision of types served by {@code @$T} methods.\n";
   static final String STATIC_INJECTION_TYPE = ""
-      + "A manager for {@code %s}'s injections into static fields.";
+      + "A manager for {@code $T}'s injections into static fields.\n";
 
   /** Creates an appropriate javadoc depending on aspects of the type in question. */
-  static String bindingTypeDocs(String type, boolean abstrakt, boolean members, boolean dependent) {
-    StringBuffer sb = new StringBuffer();
-    sb.append("A {@code Binding<").append(type).append(">} implementation which satisfies\n");
-    sb.append("Dagger's infrastructure requirements including:");
+  static CodeBlock bindingTypeDocs(
+      TypeName type, boolean abstrakt, boolean members, boolean dependent) {
+    CodeBlock.Builder result = CodeBlock.builder()
+        .add("A {@code Binding<$T>} implementation which satisfies\n", type)
+        .add("Dagger's infrastructure requirements including:\n");
     if (dependent) {
-      sb.append("\n\n");
-      sb.append("Owning the dependency links between {@code " + type + "} and its\n");
-      sb.append("dependencies.");
+      result.add("\n")
+          .add("Owning the dependency links between {@code $T} and its\n", type)
+          .add("dependencies.\n");
     }
     if (!abstrakt) {
-      sb.append("\n\n");
-      sb.append("Being a {@code Provider<" + type + ">} and handling creation and\n");
-      sb.append("preparation of object instances.");
+      result.add("\n")
+          .add("Being a {@code Provider<$T>} and handling creation and\n", type)
+          .add("preparation of object instances.\n");
     }
     if (members) {
-      sb.append("\n\n");
-      sb.append("Being a {@code MembersInjector<" + type + ">} and handling injection\n");
-      sb.append("of annotated fields.");
+      result.add("\n")
+          .add("Being a {@code MembersInjector<$T>} and handling injection\n", type)
+          .add("of annotated fields.\n");
     }
-    return sb.toString();
+    return result.build();
   }
-
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java b/compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java
index d149d16..fcfd252 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphVizWriter.java
@@ -15,7 +15,7 @@
  */
 package dagger.internal.codegen;
 
-import com.squareup.javawriter.JavaWriter;
+import com.squareup.javapoet.CodeBlock;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.Writer;
@@ -128,7 +128,11 @@
   }
 
   private String literal(String raw) {
-    return raw.matches("\\w+") ? raw : JavaWriter.stringLiteral(raw);
+    if (raw.matches("\\w+")) return raw;
+    return CodeBlock.builder()
+        .add("$S", raw)
+        .build()
+        .toString();
   }
 
   private void indent() throws IOException {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
index dca009d..e06002e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
@@ -16,16 +16,20 @@
  */
 package dagger.internal.codegen;
 
-import com.squareup.javawriter.JavaWriter;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeSpec;
 import dagger.MembersInjector;
+import dagger.ObjectGraph;
 import dagger.internal.Binding;
 import dagger.internal.Linker;
 import dagger.internal.StaticInjection;
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
-import java.util.EnumSet;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.List;
@@ -45,17 +49,18 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.tools.Diagnostic;
-import javax.tools.JavaFileObject;
 
 import static dagger.internal.codegen.AdapterJavadocs.bindingTypeDocs;
+import static dagger.internal.codegen.Util.SET_OF_BINDINGS;
 import static dagger.internal.codegen.Util.adapterName;
+import static dagger.internal.codegen.Util.bindingOf;
 import static dagger.internal.codegen.Util.elementToString;
 import static dagger.internal.codegen.Util.getApplicationSupertype;
 import static dagger.internal.codegen.Util.getNoArgsConstructor;
 import static dagger.internal.codegen.Util.getPackage;
+import static dagger.internal.codegen.Util.injectableType;
 import static dagger.internal.codegen.Util.isCallableConstructor;
 import static dagger.internal.codegen.Util.rawTypeToString;
-import static dagger.internal.codegen.Util.typeToString;
 import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
 import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -239,12 +244,10 @@
   private void generateInjectAdapter(TypeElement type, ExecutableElement constructor,
       List<Element> fields) throws IOException {
     String packageName = getPackage(type).getQualifiedName().toString();
-    String strippedTypeName =
-        strippedTypeName(type.getQualifiedName().toString(), packageName);
     TypeMirror supertype = getApplicationSupertype(type);
-    String adapterName = adapterName(type, INJECT_ADAPTER_SUFFIX);
-    JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(adapterName, type);
-    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
+    ClassName injectedClassName = ClassName.get(type);
+    ClassName adapterClassName = adapterName(injectedClassName, INJECT_ADAPTER_SUFFIX);
+
     boolean isAbstract = type.getModifiers().contains(ABSTRACT);
     boolean injectMembers = !fields.isEmpty() || supertype != null;
     boolean disambiguateFields = !fields.isEmpty()
@@ -253,252 +256,226 @@
     boolean dependent = injectMembers
         || ((constructor != null) && !constructor.getParameters().isEmpty());
 
-    writer.emitSingleLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
-    writer.emitPackage(packageName);
-    writer.emitImports(findImports(dependent, injectMembers, constructor != null));
-    writer.emitEmptyLine();
-    writer.emitJavadoc(bindingTypeDocs(strippedTypeName, isAbstract, injectMembers, dependent));
-    writer.beginType(adapterName, "class", EnumSet.of(PUBLIC, FINAL),
-        JavaWriter.type(Binding.class, strippedTypeName),
-        implementedInterfaces(strippedTypeName, injectMembers, constructor != null));
-    writeMemberBindingsFields(writer, fields, disambiguateFields);
+    TypeSpec.Builder result = TypeSpec.classBuilder(adapterClassName.simpleName())
+        .addOriginatingElement(type)
+        .addModifiers(PUBLIC, FINAL)
+        .superclass(ParameterizedTypeName.get(ClassName.get(Binding.class), injectedClassName))
+        .addJavadoc("$L", bindingTypeDocs(injectableType(type.asType()), isAbstract,
+            injectMembers, dependent).toString());
+
     if (constructor != null) {
-      writeParameterBindingsFields(writer, constructor, disambiguateFields);
-     }
-    if (supertype != null) {
-      writeSupertypeInjectorField(writer, supertype);
-    }
-    writer.emitEmptyLine();
-    writeInjectAdapterConstructor(writer, constructor, type, strippedTypeName, adapterName);
-    if (dependent) {
-      writeAttachMethod(writer, constructor, fields, disambiguateFields, strippedTypeName,
-          supertype, true);
-      writeGetDependenciesMethod(writer, constructor, fields, disambiguateFields, supertype, true);
-    }
-    if (constructor != null) {
-      writeGetMethod(writer, constructor, disambiguateFields, injectMembers, strippedTypeName);
+      result.addSuperinterface(ParameterizedTypeName.get(
+          ClassName.get(Provider.class), injectedClassName));
     }
     if (injectMembers) {
-      writeMembersInjectMethod(writer, fields, disambiguateFields, strippedTypeName, supertype);
+      result.addSuperinterface(ParameterizedTypeName.get(
+          ClassName.get(MembersInjector.class), injectedClassName));
     }
-    writer.endType();
-    writer.close();
+
+    for (Element field : fields) {
+      result.addField(memberBindingField(disambiguateFields, field));
+    }
+    if (constructor != null) {
+      for (VariableElement parameter : constructor.getParameters()) {
+        result.addField(parameterBindingField(disambiguateFields, parameter));
+      }
+    }
+    if (supertype != null) {
+      result.addField(supertypeBindingField(supertype));
+    }
+
+    result.addMethod(writeInjectAdapterConstructor(constructor, type, injectedClassName));
+    if (dependent) {
+      result.addMethod(attachMethod(
+          constructor, fields, disambiguateFields, injectedClassName, supertype, true));
+      result.addMethod(getDependenciesMethod(
+          constructor, fields, disambiguateFields, supertype, true));
+    }
+    if (constructor != null) {
+      result.addMethod(
+          getMethod(constructor, disambiguateFields, injectMembers, injectedClassName));
+    }
+    if (injectMembers) {
+      result.addMethod(
+          membersInjectMethod(fields, disambiguateFields, injectedClassName, supertype));
+    }
+
+    JavaFile javaFile = JavaFile.builder(packageName, result.build())
+        .addFileComment(AdapterJavadocs.GENERATED_BY_DAGGER)
+        .build();
+    javaFile.writeTo(processingEnv.getFiler());
   }
 
   /**
    * Write a companion class for {@code type} that extends {@link StaticInjection}.
    */
   private void generateStaticInjection(TypeElement type, List<Element> fields) throws IOException {
-    String typeName = type.getQualifiedName().toString();
-    String adapterName = adapterName(type, STATIC_INJECTION_SUFFIX);
-    JavaFileObject sourceFile = processingEnv.getFiler()
-        .createSourceFile(adapterName, type);
-    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
+    ClassName typeName = ClassName.get(type);
+    ClassName adapterClassName = adapterName(ClassName.get(type), STATIC_INJECTION_SUFFIX);
 
-    writer.emitSingleLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
-    writer.emitPackage(getPackage(type).getQualifiedName().toString());
-    writer.emitImports(Arrays.asList(
-        StaticInjection.class.getName(),
-        Binding.class.getName(),
-        Linker.class.getName()));
-    writer.emitEmptyLine();
-    writer.emitJavadoc(AdapterJavadocs.STATIC_INJECTION_TYPE, type.getSimpleName());
-    writer.beginType(
-        adapterName, "class", EnumSet.of(PUBLIC, FINAL), StaticInjection.class.getSimpleName());
-    writeMemberBindingsFields(writer, fields, false);
-    writer.emitEmptyLine();
-    writeAttachMethod(writer, null, fields, false, typeName, null, true);
-    writeStaticInjectMethod(writer, fields, typeName);
-    writer.endType();
-    writer.close();
-  }
-
-  private void writeMemberBindingsFields(
-      JavaWriter writer, List<Element> fields, boolean disambiguateFields) throws IOException {
+    TypeSpec.Builder result = TypeSpec.classBuilder(adapterClassName.simpleName())
+        .addOriginatingElement(type)
+        .addJavadoc(AdapterJavadocs.STATIC_INJECTION_TYPE, type)
+        .addModifiers(PUBLIC, FINAL)
+        .superclass(StaticInjection.class);
     for (Element field : fields) {
-      writer.emitField(JavaWriter.type(Binding.class, typeToString(field.asType())),
-          fieldName(disambiguateFields, field), EnumSet.of(PRIVATE));
+      result.addField(memberBindingField(false, field));
     }
+    result.addMethod(attachMethod(null, fields, false, typeName, null, true));
+    result.addMethod(staticInjectMethod(fields, typeName));
+
+    String packageName = getPackage(type).getQualifiedName().toString();
+    JavaFile javaFile = JavaFile.builder(packageName, result.build())
+        .addFileComment(AdapterJavadocs.GENERATED_BY_DAGGER)
+        .build();
+    javaFile.writeTo(processingEnv.getFiler());
   }
 
-  private void writeParameterBindingsFields(
-      JavaWriter writer, ExecutableElement constructor, boolean disambiguateFields)
-      throws IOException {
-    for (VariableElement parameter : constructor.getParameters()) {
-      writer.emitField(JavaWriter.type(Binding.class,
-          typeToString(parameter.asType())),
-          parameterName(disambiguateFields, parameter), EnumSet.of(PRIVATE));
-    }
+  private FieldSpec memberBindingField(boolean disambiguateFields, Element field) {
+    return FieldSpec.builder(bindingOf(field.asType()), fieldName(disambiguateFields, field),
+        PRIVATE).build();
   }
 
-  private void writeSupertypeInjectorField(JavaWriter writer, TypeMirror supertype)
-      throws IOException {
-    writer.emitField(JavaWriter.type(Binding.class, rawTypeToString(supertype, '.')), "supertype",
-        EnumSet.of(PRIVATE));
+  private FieldSpec parameterBindingField(boolean disambiguateFields, VariableElement parameter) {
+    return FieldSpec.builder(bindingOf(parameter.asType()),
+        parameterName(disambiguateFields, parameter), PRIVATE).build();
   }
 
-  private void writeInjectAdapterConstructor(JavaWriter writer, ExecutableElement constructor,
-      TypeElement type, String strippedTypeName, String adapterName) throws IOException {
-    writer.beginMethod(null, adapterName, EnumSet.of(PUBLIC));
+  private FieldSpec supertypeBindingField(TypeMirror supertype) {
+    return FieldSpec.builder(bindingOf(supertype), "supertype", PRIVATE).build();
+  }
+
+  private MethodSpec writeInjectAdapterConstructor(ExecutableElement constructor, TypeElement type,
+      ClassName strippedTypeName) {
     String key = (constructor != null)
-        ? JavaWriter.stringLiteral(GeneratorKeys.get(type.asType()))
+        ? GeneratorKeys.get(type.asType())
         : null;
-    String membersKey = JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(type.asType()));
+    String membersKey = GeneratorKeys.rawMembersKey(type.asType());
     boolean singleton = type.getAnnotation(Singleton.class) != null;
-    writer.emitStatement("super(%s, %s, %s, %s.class)",
-        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"), strippedTypeName);
-    writer.endMethod();
-    writer.emitEmptyLine();
+
+    return MethodSpec.constructorBuilder()
+        .addModifiers(PUBLIC)
+        .addStatement("super($S, $S, $N, $T.class)",
+            key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"), strippedTypeName)
+        .build();
   }
 
-  private void writeAttachMethod(JavaWriter writer, ExecutableElement constructor,
-      List<Element> fields, boolean disambiguateFields, String typeName, TypeMirror supertype,
+  private MethodSpec attachMethod(ExecutableElement constructor,
+      List<Element> fields, boolean disambiguateFields, ClassName typeName, TypeMirror supertype,
       boolean extendsBinding) throws IOException {
-    writer.emitJavadoc(AdapterJavadocs.ATTACH_METHOD);
+    MethodSpec.Builder result = MethodSpec.methodBuilder("attach")
+        .addJavadoc(AdapterJavadocs.ATTACH_METHOD)
+        .addModifiers(PUBLIC)
+        .addParameter(Linker.class, "linker");
+
     if (extendsBinding) {
-      writer.emitAnnotation(Override.class);
+      result.addAnnotation(Override.class);
     }
-    writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
-    writer.beginMethod(
-        "void", "attach", EnumSet.of(PUBLIC), Linker.class.getCanonicalName(), "linker");
+    result.addAnnotation(Util.UNCHECKED);
     if (constructor != null) {
       for (VariableElement parameter : constructor.getParameters()) {
-        writer.emitStatement(
-            "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
-            parameterName(disambiguateFields, parameter),
-            writer.compressType(JavaWriter.type(Binding.class, typeToString(parameter.asType()))),
-            JavaWriter.stringLiteral(GeneratorKeys.get(parameter)), typeName);
+        result.addStatement(
+            "$N = ($T) linker.requestBinding($S, $T.class, getClass().getClassLoader())",
+            parameterName(disambiguateFields, parameter), bindingOf(parameter.asType()),
+            GeneratorKeys.get(parameter), typeName);
       }
     }
     for (Element field : fields) {
-      writer.emitStatement(
-          "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
-          fieldName(disambiguateFields, field),
-          writer.compressType(JavaWriter.type(Binding.class, typeToString(field.asType()))),
-          JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) field)), typeName);
+      result.addStatement(
+          "$N = ($T) linker.requestBinding($S, $T.class, getClass().getClassLoader())",
+          fieldName(disambiguateFields, field), bindingOf(field.asType()),
+          GeneratorKeys.get((VariableElement) field), typeName);
     }
     if (supertype != null) {
-      writer.emitStatement(
-          "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader()"
+      result.addStatement(
+          "$N = ($T) linker.requestBinding($S, $T.class, getClass().getClassLoader()"
               + ", false, true)",
           "supertype",
-          writer.compressType(JavaWriter.type(Binding.class, rawTypeToString(supertype, '.'))),
-          JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(supertype)), typeName);
+          bindingOf(supertype),
+          GeneratorKeys.rawMembersKey(supertype), typeName);
     }
-    writer.endMethod();
-    writer.emitEmptyLine();
+    return result.build();
   }
 
-  private void writeGetDependenciesMethod(JavaWriter writer, ExecutableElement constructor,
+  private MethodSpec getDependenciesMethod(ExecutableElement constructor,
       List<Element> fields, boolean disambiguateFields, TypeMirror supertype,
       boolean extendsBinding) throws IOException {
-    writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
+    MethodSpec.Builder result = MethodSpec.methodBuilder("getDependencies")
+        .addJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD)
+        .addModifiers(PUBLIC)
+        .addParameter(SET_OF_BINDINGS, "getBindings")
+        .addParameter(SET_OF_BINDINGS, "injectMembersBindings");
+
     if (extendsBinding) {
-      writer.emitAnnotation(Override.class);
+      result.addAnnotation(Override.class);
     }
-    String setOfBindings = JavaWriter.type(Set.class, "Binding<?>");
-    writer.beginMethod("void", "getDependencies", EnumSet.of(PUBLIC), setOfBindings, "getBindings",
-        setOfBindings, "injectMembersBindings");
     if (constructor != null) {
       for (Element parameter : constructor.getParameters()) {
-        writer.emitStatement("getBindings.add(%s)", parameterName(disambiguateFields, parameter));
+        result.addStatement("getBindings.add($N)", parameterName(disambiguateFields, parameter));
       }
     }
     for (Element field : fields) {
-      writer.emitStatement("injectMembersBindings.add(%s)", fieldName(disambiguateFields, field));
+      result.addStatement("injectMembersBindings.add($N)", fieldName(disambiguateFields, field));
     }
     if (supertype != null) {
-      writer.emitStatement("injectMembersBindings.add(%s)", "supertype");
+      result.addStatement("injectMembersBindings.add($N)", "supertype");
     }
-    writer.endMethod();
-    writer.emitEmptyLine();
+    return result.build();
   }
 
-  private void writeGetMethod(JavaWriter writer, ExecutableElement constructor,
-      boolean disambiguateFields, boolean injectMembers, String strippedTypeName)
-      throws IOException {
-    writer.emitJavadoc(AdapterJavadocs.GET_METHOD, strippedTypeName);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod(strippedTypeName, "get", EnumSet.of(PUBLIC));
-    StringBuilder newInstance = new StringBuilder();
-    newInstance.append(strippedTypeName).append(" result = new ");
-    newInstance.append(strippedTypeName).append('(');
+  private MethodSpec getMethod(ExecutableElement constructor, boolean disambiguateFields,
+      boolean injectMembers, ClassName injectedClassName) {
+    MethodSpec.Builder result = MethodSpec.methodBuilder("get")
+        .addJavadoc(AdapterJavadocs.GET_METHOD, injectedClassName)
+        .addAnnotation(Override.class)
+        .returns(injectedClassName)
+        .addModifiers(PUBLIC);
+
+    result.addCode("$T result = new $T(", injectedClassName, injectedClassName);
     boolean first = true;
     for (VariableElement parameter : constructor.getParameters()) {
-      if (!first) newInstance.append(", ");
+      if (!first) result.addCode(", ");
       else first = false;
-      newInstance.append(parameterName(disambiguateFields, parameter)).append(".get()");
+      result.addCode("$N.get()", parameterName(disambiguateFields, parameter));
     }
-    newInstance.append(')');
-    writer.emitStatement(newInstance.toString());
+    result.addCode(");\n");
     if (injectMembers) {
-      writer.emitStatement("injectMembers(result)");
+      result.addStatement("injectMembers(result)");
     }
-    writer.emitStatement("return result");
-    writer.endMethod();
-    writer.emitEmptyLine();
+    result.addStatement("return result");
+    return result.build();
   }
 
-  private void writeMembersInjectMethod(JavaWriter writer, List<Element> fields,
-      boolean disambiguateFields, String strippedTypeName, TypeMirror supertype)
-      throws IOException {
-    writer.emitJavadoc(AdapterJavadocs.MEMBERS_INJECT_METHOD, strippedTypeName);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod("void", "injectMembers", EnumSet.of(PUBLIC), strippedTypeName, "object");
+  private MethodSpec membersInjectMethod(List<Element> fields, boolean disambiguateFields,
+      ClassName injectedClassName, TypeMirror supertype) {
+    MethodSpec.Builder result = MethodSpec.methodBuilder("injectMembers")
+        .addJavadoc(AdapterJavadocs.MEMBERS_INJECT_METHOD, injectedClassName)
+        .addAnnotation(Override.class)
+        .addModifiers(PUBLIC)
+        .addParameter(injectedClassName, "object");
     for (Element field : fields) {
-      writer.emitStatement("object.%s = %s.get()",
+      result.addStatement("object.$N = $N.get()",
           field.getSimpleName(),
           fieldName(disambiguateFields, field));
     }
     if (supertype != null) {
-      writer.emitStatement("supertype.injectMembers(object)");
+      result.addStatement("supertype.injectMembers(object)");
     }
-    writer.endMethod();
-    writer.emitEmptyLine();
+    return result.build();
   }
 
-  private void writeStaticInjectMethod(JavaWriter writer, List<Element> fields, String typeName)
-      throws IOException {
-    writer.emitEmptyLine();
-    writer.emitJavadoc(AdapterJavadocs.STATIC_INJECT_METHOD);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod("void", "inject", EnumSet.of(PUBLIC));
+  private MethodSpec staticInjectMethod(List<Element> fields, ClassName typeName) {
+    MethodSpec.Builder result = MethodSpec.methodBuilder("inject")
+        .addJavadoc(AdapterJavadocs.STATIC_INJECT_METHOD, ObjectGraph.class)
+        .addAnnotation(Override.class)
+        .addModifiers(PUBLIC);
     for (Element field : fields) {
-      writer.emitStatement("%s.%s = %s.get()",
-          writer.compressType(typeName),
+      result.addStatement("$T.$N = $N.get()",
+          typeName,
           field.getSimpleName().toString(),
           fieldName(false, field));
     }
-    writer.endMethod();
-    writer.emitEmptyLine();
-  }
-
-  private Set<String> findImports(boolean dependent, boolean injectMembers, boolean isProvider) {
-    Set<String> imports = new LinkedHashSet<String>();
-    imports.add(Binding.class.getCanonicalName());
-    if (dependent) {
-      imports.add(Linker.class.getCanonicalName());
-      imports.add(Set.class.getCanonicalName());
-    }
-    if (injectMembers) imports.add(MembersInjector.class.getCanonicalName());
-    if (isProvider) imports.add(Provider.class.getCanonicalName());
-    return imports;
-  }
-
-  private String[] implementedInterfaces(
-      String strippedTypeName, boolean hasFields, boolean isProvider) {
-    List<String> interfaces = new ArrayList<String>();
-    if (isProvider) {
-      interfaces.add(JavaWriter.type(Provider.class, strippedTypeName));
-    }
-    if (hasFields) {
-      interfaces.add(JavaWriter.type(MembersInjector.class, strippedTypeName));
-    }
-    return interfaces.toArray(new String[interfaces.size()]);
-  }
-
-  private String strippedTypeName(String type, String packageName) {
-    return type.substring(packageName.isEmpty() ? 0 : packageName.length() + 1);
+    return result.build();
   }
 
   private String fieldName(boolean disambiguateFields, Element field) {
@@ -527,5 +504,4 @@
       this.fields = fields;
     }
   }
-
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 32c5a8b..e83a1e9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -15,11 +15,17 @@
  */
 package dagger.internal.codegen;
 
-import com.squareup.javawriter.JavaWriter;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
 import dagger.Lazy;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.Binding;
 import dagger.internal.BindingsGroup;
 import dagger.internal.Linker;
 import dagger.internal.ModuleAdapter;
@@ -27,11 +33,8 @@
 import dagger.internal.SetBinding;
 import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
 import java.io.IOException;
-import java.io.StringWriter;
-import java.io.Writer;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
@@ -57,16 +60,13 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
-import javax.tools.JavaFileObject;
 
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
 import static dagger.internal.codegen.AdapterJavadocs.bindingTypeDocs;
-import static dagger.internal.codegen.Util.adapterName;
+import static dagger.internal.codegen.Util.ARRAY_OF_CLASS;
+import static dagger.internal.codegen.Util.bindingOf;
 import static dagger.internal.codegen.Util.elementToString;
 import static dagger.internal.codegen.Util.getAnnotation;
 import static dagger.internal.codegen.Util.getNoArgsConstructor;
-import static dagger.internal.codegen.Util.getPackage;
 import static dagger.internal.codegen.Util.isCallableConstructor;
 import static dagger.internal.codegen.Util.isInterface;
 import static dagger.internal.codegen.Util.typeToString;
@@ -83,7 +83,6 @@
  */
 @SupportedAnnotationTypes({ "*" })
 public final class ModuleAdapterProcessor extends AbstractProcessor {
-  private static final String BINDINGS_MAP = JavaWriter.type(BindingsGroup.class);
   private static final List<String> INVALID_RETURN_TYPES =
       Arrays.asList(Provider.class.getCanonicalName(), Lazy.class.getCanonicalName());
 
@@ -105,15 +104,12 @@
         // Attempt to get the annotation. If types are missing, this will throw
         // CodeGenerationIncompleteException.
         Map<String, Object> parsedAnnotation = getAnnotation(Module.class, type);
-
-        //TODO(cgruber): Figure out an initial sizing of the StringWriter.
-        StringWriter stringWriter = new StringWriter();
-        String adapterName = adapterName(type, MODULE_ADAPTER_SUFFIX);
-        generateModuleAdapter(stringWriter, adapterName, type, parsedAnnotation, providesTypes);
-        JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(adapterName, type);
-        Writer sourceWriter = sourceFile.openWriter();
-        sourceWriter.append(stringWriter.getBuffer());
-        sourceWriter.close();
+        if (parsedAnnotation == null) {
+          error(type + " has @Provides methods but no @Module annotation", type);
+          continue;
+        }
+        JavaFile javaFile = generateModuleAdapter(type, parsedAnnotation, providesTypes);
+        javaFile.writeTo(processingEnv.getFiler());
       } catch (CodeGenerationIncompleteException e) {
         continue; // A dependent type was not defined, we'll try to catch it on another pass.
       } catch (IOException e) {
@@ -234,59 +230,136 @@
    * Write a companion class for {@code type} that implements {@link
    * ModuleAdapter} to expose its provider methods.
    */
-  private void generateModuleAdapter(Writer ioWriter, String adapterName, TypeElement type,
-      Map<String, Object> module, List<ExecutableElement> providerMethods) throws IOException {
-    if (module == null) {
-      error(type + " has @Provides methods but no @Module annotation", type);
-      return;
-    }
-
+  private JavaFile generateModuleAdapter(TypeElement type,
+      Map<String, Object> module, List<ExecutableElement> providerMethods) {
     Object[] staticInjections = (Object[]) module.get("staticInjections");
     Object[] injects = (Object[]) module.get("injects");
     Object[] includes = (Object[]) module.get("includes");
-
     boolean overrides = (Boolean) module.get("overrides");
     boolean complete = (Boolean) module.get("complete");
     boolean library = (Boolean) module.get("library");
 
-    JavaWriter writer = new JavaWriter(ioWriter);
+    ClassName moduleClassName = ClassName.get(type);
+    ClassName adapterClassName = Util.adapterName(moduleClassName, MODULE_ADAPTER_SUFFIX);
 
-    boolean multibindings = checkForMultibindings(providerMethods);
-    boolean providerMethodDependencies = checkForDependencies(providerMethods);
+    TypeSpec.Builder adapterBuilder = TypeSpec.classBuilder(adapterClassName.simpleName())
+        .addOriginatingElement(type)
+        .addJavadoc(AdapterJavadocs.MODULE_TYPE, Provides.class)
+        .superclass(ParameterizedTypeName.get(ClassName.get(ModuleAdapter.class), moduleClassName))
+        .addModifiers(PUBLIC, FINAL);
 
-    writer.emitSingleLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
-    writer.emitPackage(getPackage(type).getQualifiedName().toString());
-    writer.emitImports(
-        findImports(multibindings, !providerMethods.isEmpty(), providerMethodDependencies));
+    adapterBuilder.addField(FieldSpec.builder(String[].class, "INJECTS")
+        .addModifiers(PRIVATE, STATIC, FINAL)
+        .initializer("$L", injectsInitializer(injects))
+        .build());
+    adapterBuilder.addField(FieldSpec.builder(ARRAY_OF_CLASS, "STATIC_INJECTIONS")
+        .addModifiers(PRIVATE, STATIC, FINAL)
+        .initializer("$L", staticInjectionsInitializer(staticInjections))
+        .build());
+    adapterBuilder.addField(FieldSpec.builder(ARRAY_OF_CLASS, "INCLUDES")
+        .addModifiers(PRIVATE, STATIC, FINAL)
+        .initializer("$L", includesInitializer(type, includes))
+        .build());
+    adapterBuilder.addMethod(MethodSpec.constructorBuilder()
+        .addModifiers(PUBLIC)
+        .addStatement("super($T.class, INJECTS, STATIC_INJECTIONS, $L /*overrides*/, "
+                + "INCLUDES, $L /*complete*/, $L /*library*/)",
+            type.asType(), overrides, complete, library)
+        .build());
 
-    String typeName = type.getQualifiedName().toString();
-    writer.emitEmptyLine();
-    writer.emitJavadoc(AdapterJavadocs.MODULE_TYPE);
-    writer.beginType(adapterName, "class", EnumSet.of(PUBLIC, FINAL),
-        JavaWriter.type(ModuleAdapter.class, typeName));
+    ExecutableElement noArgsConstructor = getNoArgsConstructor(type);
+    if (noArgsConstructor != null && isCallableConstructor(noArgsConstructor)) {
+      adapterBuilder.addMethod(MethodSpec.methodBuilder("newModule")
+          .addAnnotation(Override.class)
+          .addModifiers(PUBLIC)
+          .returns(moduleClassName)
+          .addStatement("return new $T()", type.asType())
+          .build());
+    }
 
-    StringBuilder injectsField = new StringBuilder().append("{ ");
+    // Caches.
+    Map<ExecutableElement, ClassName> methodToClassName
+        = new LinkedHashMap<ExecutableElement, ClassName>();
+    Map<String, AtomicInteger> methodNameToNextId = new LinkedHashMap<String, AtomicInteger>();
+
+    if (!providerMethods.isEmpty()) {
+      MethodSpec.Builder getBindings = MethodSpec.methodBuilder("getBindings")
+          .addJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD)
+          .addAnnotation(Override.class)
+          .addModifiers(PUBLIC)
+          .addParameter(BindingsGroup.class, "bindings")
+          .addParameter(moduleClassName, "module");
+
+      for (ExecutableElement providerMethod : providerMethods) {
+        Provides provides = providerMethod.getAnnotation(Provides.class);
+        switch (provides.type()) {
+          case UNIQUE: {
+            getBindings.addStatement("bindings.contributeProvidesBinding($S, new $T(module))",
+                GeneratorKeys.get(providerMethod),
+                bindingClassName(adapterClassName, providerMethod, methodToClassName,
+                    methodNameToNextId));
+            break;
+          }
+          case SET: {
+            getBindings.addStatement("$T.add(bindings, $S, new $T(module))",
+                SetBinding.class,
+                GeneratorKeys.getSetKey(providerMethod),
+                bindingClassName(adapterClassName, providerMethod, methodToClassName,
+                    methodNameToNextId));
+            break;
+          }
+          case SET_VALUES: {
+            getBindings.addStatement("$T.add(bindings, $S, new $T(module))",
+                SetBinding.class,
+                GeneratorKeys.get(providerMethod),
+                bindingClassName(adapterClassName, providerMethod, methodToClassName,
+                    methodNameToNextId));
+            break;
+          }
+          default:
+            throw new AssertionError("Unknown @Provides type " + provides.type());
+        }
+      }
+      adapterBuilder.addMethod(getBindings.build());
+    }
+
+    for (ExecutableElement providerMethod : providerMethods) {
+      adapterBuilder.addType(generateProvidesAdapter(moduleClassName, adapterClassName,
+          providerMethod, methodToClassName, methodNameToNextId, library));
+    }
+
+    return JavaFile.builder(adapterClassName.packageName(), adapterBuilder.build())
+        .addFileComment(AdapterJavadocs.GENERATED_BY_DAGGER)
+        .build();
+  }
+
+  private CodeBlock injectsInitializer(Object[] injects) {
+    CodeBlock.Builder result = CodeBlock.builder()
+        .add("{ ");
     for (Object injectableType : injects) {
       TypeMirror typeMirror = (TypeMirror) injectableType;
       String key = isInterface(typeMirror)
           ? GeneratorKeys.get(typeMirror)
           : GeneratorKeys.rawMembersKey(typeMirror);
-      injectsField.append(JavaWriter.stringLiteral(key)).append(", ");
+      result.add("$S, ", key);
     }
-    injectsField.append("}");
-    writer.emitField("String[]", "INJECTS", EnumSet.of(PRIVATE, STATIC, FINAL),
-        injectsField.toString());
+    result.add("}");
+    return result.build();
+  }
 
-    StringBuilder staticInjectionsField = new StringBuilder().append("{ ");
+  private CodeBlock staticInjectionsInitializer(Object[] staticInjections) {
+    CodeBlock.Builder result = CodeBlock.builder()
+        .add("{ ");
     for (Object staticInjection : staticInjections) {
-      TypeMirror typeMirror = (TypeMirror) staticInjection;
-      staticInjectionsField.append(typeToString(typeMirror)).append(".class, ");
+      result.add("$T.class, ", staticInjection);
     }
-    staticInjectionsField.append("}");
-    writer.emitField("Class<?>[]", "STATIC_INJECTIONS", EnumSet.of(PRIVATE, STATIC, FINAL),
-        staticInjectionsField.toString());
+    result.add("}");
+    return result.build();
+  }
 
-    StringBuilder includesField = new StringBuilder().append("{ ");
+  private CodeBlock includesInitializer(TypeElement type, Object[] includes) {
+    CodeBlock.Builder result = CodeBlock.builder();
+    result.add("{ ");
     for (Object include : includes) {
       if (!(include instanceof TypeMirror)) {
         // TODO(tbroyer): pass annotation information
@@ -295,120 +368,16 @@
         continue;
       }
       TypeMirror typeMirror = (TypeMirror) include;
-      includesField.append(typeToString(typeMirror)).append(".class, ");
+      result.add("$T.class, ", typeMirror);
     }
-    includesField.append("}");
-    writer.emitField(
-        "Class<?>[]", "INCLUDES", EnumSet.of(PRIVATE, STATIC, FINAL), includesField.toString());
-
-    writer.emitEmptyLine();
-    writer.beginMethod(null, adapterName, EnumSet.of(PUBLIC));
-    writer.emitStatement("super(%s.class, INJECTS, STATIC_INJECTIONS, %s /*overrides*/, "
-        + "INCLUDES, %s /*complete*/, %s /*library*/)", typeName,  overrides, complete, library);
-    writer.endMethod();
-
-    ExecutableElement noArgsConstructor = getNoArgsConstructor(type);
-    if (noArgsConstructor != null && isCallableConstructor(noArgsConstructor)) {
-      writer.emitEmptyLine();
-      writer.emitAnnotation(Override.class);
-      writer.beginMethod(typeName, "newModule", EnumSet.of(PUBLIC));
-      writer.emitStatement("return new %s()", typeName);
-      writer.endMethod();
-    }
-    // caches
-    Map<ExecutableElement, String> methodToClassName
-        = new LinkedHashMap<ExecutableElement, String>();
-    Map<String, AtomicInteger> methodNameToNextId = new LinkedHashMap<String, AtomicInteger>();
-
-    if (!providerMethods.isEmpty()) {
-      writer.emitEmptyLine();
-      writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
-      writer.emitAnnotation(Override.class);
-      writer.beginMethod("void", "getBindings", EnumSet.of(PUBLIC), BINDINGS_MAP, "bindings",
-          typeName, "module");
-
-      for (ExecutableElement providerMethod : providerMethods) {
-        Provides provides = providerMethod.getAnnotation(Provides.class);
-        switch (provides.type()) {
-          case UNIQUE: {
-            String key = GeneratorKeys.get(providerMethod);
-            writer.emitStatement("bindings.contributeProvidesBinding(%s, new %s(module))",
-                JavaWriter.stringLiteral(key),
-                bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
-            break;
-          }
-          case SET: {
-            String key = GeneratorKeys.getSetKey(providerMethod);
-            writer.emitStatement("SetBinding.add(bindings, %s, new %s(module))",
-                JavaWriter.stringLiteral(key),
-                bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
-            break;
-          }
-          case SET_VALUES: {
-            String key = GeneratorKeys.get(providerMethod);
-            writer.emitStatement("SetBinding.add(bindings, %s, new %s(module))",
-                JavaWriter.stringLiteral(key),
-                bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
-            break;
-          }
-          default:
-            throw new AssertionError("Unknown @Provides type " + provides.type());
-        }
-      }
-      writer.endMethod();
-    }
-
-    for (ExecutableElement providerMethod : providerMethods) {
-      generateProvidesAdapter(
-          writer, providerMethod, methodToClassName, methodNameToNextId, library);
-    }
-
-    writer.endType();
-    writer.close();
+    result.add("}");
+    return result.build();
   }
 
-  private Set<String> findImports(boolean multibindings, boolean providers, boolean dependencies) {
-    Set<String> imports = new LinkedHashSet<String>();
-    imports.add(ModuleAdapter.class.getCanonicalName());
-    if (providers) {
-      imports.add(BindingsGroup.class.getCanonicalName());
-      imports.add(Provider.class.getCanonicalName());
-      imports.add(ProvidesBinding.class.getCanonicalName());
-    }
-    if (dependencies) {
-      imports.add(Linker.class.getCanonicalName());
-      imports.add(Set.class.getCanonicalName());
-      imports.add(Binding.class.getCanonicalName());
-    }
-    if (multibindings) {
-      imports.add(SetBinding.class.getCanonicalName());
-    }
-    return imports;
-  }
-
-  private boolean checkForDependencies(List<ExecutableElement> providerMethods) {
-    for (ExecutableElement element : providerMethods) {
-      if (!element.getParameters().isEmpty()) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private boolean checkForMultibindings(List<ExecutableElement> providerMethods) {
-    for (ExecutableElement element : providerMethods) {
-      Provides.Type providesType = element.getAnnotation(Provides.class).type();
-      if (providesType == SET || providesType == SET_VALUES) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private String bindingClassName(ExecutableElement providerMethod,
-      Map<ExecutableElement, String> methodToClassName,
+  private ClassName bindingClassName(ClassName adapterName, ExecutableElement providerMethod,
+      Map<ExecutableElement, ClassName> methodToClassName,
       Map<String, AtomicInteger> methodNameToNextId) {
-    String className = methodToClassName.get(providerMethod);
+    ClassName className = methodToClassName.get(providerMethod);
     if (className != null) return className;
 
     String methodName = providerMethod.getSimpleName().toString();
@@ -422,92 +391,93 @@
     }
     String uppercaseMethodName = Character.toUpperCase(methodName.charAt(0))
         + methodName.substring(1);
-    className = uppercaseMethodName + "ProvidesAdapter" + suffix;
+    className = adapterName.nestedClass(uppercaseMethodName + "ProvidesAdapter" + suffix);
     methodToClassName.put(providerMethod, className);
     return className;
   }
 
-  private void generateProvidesAdapter(JavaWriter writer, ExecutableElement providerMethod,
-      Map<ExecutableElement, String> methodToClassName,
-      Map<String, AtomicInteger> methodNameToNextId, boolean library)
-      throws IOException {
+  private TypeSpec generateProvidesAdapter(ClassName moduleClassName, ClassName adapterName,
+      ExecutableElement providerMethod, Map<ExecutableElement, ClassName> methodToClassName,
+      Map<String, AtomicInteger> methodNameToNextId, boolean library) {
     String methodName = providerMethod.getSimpleName().toString();
-    String moduleType = typeToString(providerMethod.getEnclosingElement().asType());
-    String className =
-        bindingClassName(providerMethod, methodToClassName, methodNameToNextId);
-    String returnType = typeToString(providerMethod.getReturnType());
+    TypeMirror moduleType = providerMethod.getEnclosingElement().asType();
+    ClassName className = bindingClassName(
+        adapterName, providerMethod, methodToClassName, methodNameToNextId);
+    TypeName returnType = Util.injectableType(providerMethod.getReturnType());
     List<? extends VariableElement> parameters = providerMethod.getParameters();
     boolean dependent = !parameters.isEmpty();
 
-    writer.emitEmptyLine();
-    writer.emitJavadoc(bindingTypeDocs(returnType, false, false, dependent));
-    writer.beginType(className, "class", EnumSet.of(PUBLIC, STATIC, FINAL),
-        JavaWriter.type(ProvidesBinding.class, returnType),
-        JavaWriter.type(Provider.class, returnType));
-    writer.emitField(moduleType, "module", EnumSet.of(PRIVATE, FINAL));
+    TypeSpec.Builder result = TypeSpec.classBuilder(className.simpleName())
+        .addJavadoc("$L", bindingTypeDocs(returnType, false, false, dependent))
+        .addModifiers(PUBLIC, STATIC, FINAL)
+        .superclass(ParameterizedTypeName.get(ClassName.get(ProvidesBinding.class), returnType))
+        .addSuperinterface(ParameterizedTypeName.get(ClassName.get(Provider.class), returnType));
+
+    result.addField(moduleClassName, "module", PRIVATE, FINAL);
     for (Element parameter : parameters) {
-      TypeMirror parameterType = parameter.asType();
-      writer.emitField(JavaWriter.type(Binding.class, typeToString(parameterType)),
-          parameterName(parameter), EnumSet.of(PRIVATE));
+      result.addField(bindingOf(parameter.asType()), parameterName(parameter), PRIVATE);
     }
 
-    writer.emitEmptyLine();
-    writer.beginMethod(null, className, EnumSet.of(PUBLIC), moduleType, "module");
     boolean singleton = providerMethod.getAnnotation(Singleton.class) != null;
-    String key = JavaWriter.stringLiteral(GeneratorKeys.get(providerMethod));
-    writer.emitStatement("super(%s, %s, %s, %s)",
-        key, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"),
-        JavaWriter.stringLiteral(moduleType),
-        JavaWriter.stringLiteral(methodName));
-    writer.emitStatement("this.module = module");
-    writer.emitStatement("setLibrary(%s)", library);
-    writer.endMethod();
+    String key = GeneratorKeys.get(providerMethod);
+    result.addMethod(MethodSpec.constructorBuilder()
+        .addModifiers(PUBLIC)
+        .addParameter(moduleClassName, "module")
+        .addStatement("super($S, $L, $S, $S)",
+            key,
+            (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"),
+            typeToString(moduleType),
+            methodName)
+        .addStatement("this.module = module")
+        .addStatement("setLibrary($L)", library)
+        .build());
 
     if (dependent) {
-      writer.emitEmptyLine();
-      writer.emitJavadoc(AdapterJavadocs.ATTACH_METHOD);
-      writer.emitAnnotation(Override.class);
-      writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
-      writer.beginMethod(
-          "void", "attach", EnumSet.of(PUBLIC), Linker.class.getCanonicalName(), "linker");
+      MethodSpec.Builder attachBuilder = MethodSpec.methodBuilder("attach")
+          .addJavadoc(AdapterJavadocs.ATTACH_METHOD)
+          .addAnnotation(Override.class)
+          .addAnnotation(Util.UNCHECKED)
+          .addModifiers(PUBLIC)
+          .addParameter(Linker.class, "linker");
       for (VariableElement parameter : parameters) {
         String parameterKey = GeneratorKeys.get(parameter);
-        writer.emitStatement(
-            "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
+        attachBuilder.addStatement(
+            "$N = ($T) linker.requestBinding($S, $T.class, getClass().getClassLoader())",
             parameterName(parameter),
-            writer.compressType(JavaWriter.type(Binding.class, typeToString(parameter.asType()))),
-            JavaWriter.stringLiteral(parameterKey),
-            writer.compressType(moduleType));
+            bindingOf(parameter.asType()),
+            parameterKey,
+            moduleClassName);
       }
-      writer.endMethod();
+      result.addMethod(attachBuilder.build());
 
-      writer.emitEmptyLine();
-      writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
-      writer.emitAnnotation(Override.class);
-      String setOfBindings = JavaWriter.type(Set.class, "Binding<?>");
-      writer.beginMethod("void", "getDependencies", EnumSet.of(PUBLIC), setOfBindings,
-          "getBindings", setOfBindings, "injectMembersBindings");
+      MethodSpec.Builder getDependenciesBuilder = MethodSpec.methodBuilder("getDependencies")
+          .addJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD)
+          .addAnnotation(Override.class)
+          .addModifiers(PUBLIC)
+          .addParameter(Util.SET_OF_BINDINGS, "getBindings")
+          .addParameter(Util.SET_OF_BINDINGS, "injectMembersBindings");
       for (Element parameter : parameters) {
-        writer.emitStatement("getBindings.add(%s)", parameterName(parameter));
+        getDependenciesBuilder.addStatement("getBindings.add($N)", parameterName(parameter));
       }
-      writer.endMethod();
+      result.addMethod(getDependenciesBuilder.build());
     }
 
-    writer.emitEmptyLine();
-    writer.emitJavadoc(AdapterJavadocs.GET_METHOD, returnType);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod(returnType, "get", EnumSet.of(PUBLIC));
-    StringBuilder args = new StringBuilder();
+    MethodSpec.Builder getBuilder = MethodSpec.methodBuilder("get")
+        .addJavadoc(AdapterJavadocs.GET_METHOD, returnType)
+        .addAnnotation(Override.class)
+        .addModifiers(PUBLIC)
+        .returns(returnType)
+        .addCode("return module.$N(", methodName);
     boolean first = true;
     for (Element parameter : parameters) {
-      if (!first) args.append(", ");
-      else first = false;
-      args.append(String.format("%s.get()", parameterName(parameter)));
+      if (!first) getBuilder.addCode(", ");
+      getBuilder.addCode("$N.get()", parameterName(parameter));
+      first = false;
     }
-    writer.emitStatement("return module.%s(%s)", methodName, args.toString());
-    writer.endMethod();
+    getBuilder.addCode(");\n");
+    result.addMethod(getBuilder.build());
 
-    writer.endType();
+    return result.build();
   }
 
   private String parameterName(Element parameter) {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 86d587e..b432093 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,12 +16,21 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Joiner;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ArrayTypeName;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.WildcardTypeName;
+import dagger.internal.Binding;
 import dagger.internal.Keys;
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.AnnotationValueVisitor;
@@ -44,6 +53,20 @@
  * Utilities for handling types in annotation processors
  */
 final class Util {
+  // Binding<?>.
+  public static final TypeName BINDING_OF_ANY = ParameterizedTypeName.get(
+      ClassName.get(Binding.class), WildcardTypeName.subtypeOf(Object.class));
+  // Set<Binding<?>>.
+  public static final TypeName SET_OF_BINDINGS = ParameterizedTypeName.get(
+      ClassName.get(Set.class), BINDING_OF_ANY);
+  // Class<?>[].
+  public static final TypeName ARRAY_OF_CLASS = ArrayTypeName.of(ParameterizedTypeName.get(
+      ClassName.get(Class.class), WildcardTypeName.subtypeOf(Object.class)));
+  // @SuppressWarnings("unchecked")
+  public static final AnnotationSpec UNCHECKED = AnnotationSpec.builder(SuppressWarnings.class)
+      .addMember("value", "$S", "unchecked")
+      .build();
+
   private Util() {
   }
 
@@ -64,12 +87,10 @@
     return Keys.isPlatformType(supertype.toString()) ? null : supertype;
   }
 
-  /** Returns a fully qualified class name to complement {@code type}. */
-  public static String adapterName(TypeElement typeElement, String suffix) {
-    StringBuilder builder = new StringBuilder();
-    rawTypeToString(builder, typeElement, '$');
-    builder.append(suffix);
-    return builder.toString();
+  /** Returns a class name to complement {@code type}. */
+  public static ClassName adapterName(ClassName type, String suffix) {
+    return ClassName.get(type.packageName(),
+        Joiner.on('$').join(type.simpleNames()) + suffix);
   }
 
   /** Returns a string for {@code type}. Primitive types are always boxed. */
@@ -119,7 +140,7 @@
         return null;
       }
       @Override public Void visitPrimitive(PrimitiveType primitiveType, Void v) {
-        result.append(box((PrimitiveType) type).getName());
+        result.append(box((PrimitiveType) type));
         return null;
       }
       @Override public Void visitArray(ArrayType arrayType, Void v) {
@@ -157,6 +178,33 @@
     }, null);
   }
 
+  /** Returns a string for {@code type}. Primitive types are always boxed. */
+  public static TypeName injectableType(TypeMirror type) {
+    return type.accept(new SimpleTypeVisitor6<TypeName, Void>() {
+      @Override public TypeName visitPrimitive(PrimitiveType primitiveType, Void v) {
+        return box(primitiveType);
+      }
+
+      @Override public TypeName visitError(ErrorType errorType, Void v) {
+        // Error type found, a type may not yet have been generated, but we need the type
+        // so we can generate the correct code in anticipation of the type being available
+        // to the compiler.
+
+        // Paramterized types which don't exist are returned as an error type whose name is "<any>"
+        if ("<any>".equals(errorType.toString())) {
+          throw new CodeGenerationIncompleteException(
+              "Type reported as <any> is likely a not-yet generated parameterized type.");
+        }
+
+        return ClassName.bestGuess(errorType.toString());
+      }
+
+      @Override protected TypeName defaultAction(TypeMirror typeMirror, Void v) {
+        return TypeName.get(typeMirror);
+      }
+    }, null);
+  }
+
   private static final AnnotationValueVisitor<Object, Void> VALUE_EXTRACTOR =
       new SimpleAnnotationValueVisitor6<Object, Void>() {
         @Override public Object visitString(String s, Void p) {
@@ -266,26 +314,26 @@
     }
   }
 
-  private static Class<?> box(PrimitiveType primitiveType) {
+  private static TypeName box(PrimitiveType primitiveType) {
     switch (primitiveType.getKind()) {
       case BYTE:
-        return Byte.class;
+        return ClassName.get(Byte.class);
       case SHORT:
-        return Short.class;
+        return ClassName.get(Short.class);
       case INT:
-        return Integer.class;
+        return ClassName.get(Integer.class);
       case LONG:
-        return Long.class;
+        return ClassName.get(Long.class);
       case FLOAT:
-        return Float.class;
+        return ClassName.get(Float.class);
       case DOUBLE:
-        return Double.class;
+        return ClassName.get(Double.class);
       case BOOLEAN:
-        return Boolean.class;
+        return ClassName.get(Boolean.class);
       case CHAR:
-        return Character.class;
+        return ClassName.get(Character.class);
       case VOID:
-        return Void.class;
+        return ClassName.get(Void.class);
       default:
         throw new AssertionError();
     }
@@ -344,6 +392,10 @@
     return false;
   }
 
+  static ParameterizedTypeName bindingOf(TypeMirror type) {
+    return ParameterizedTypeName.get(ClassName.get(Binding.class), injectableType(type));
+  }
+
   /**
    * An exception thrown when a type is not extant (returns as an error type),
    * usually as a result of another processor not having yet generated its types upon
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index 59aff69..fb2e566 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -42,6 +42,9 @@
     JavaFileObject expectedModuleAdapter =
         JavaFileObjects.forSourceString("Basic$AModule$$ModuleAdapter", Joiner.on("\n").join(
             "import dagger.internal.ModuleAdapter;",
+            "import java.lang.Class;",
+            "import java.lang.Override;",
+            "import java.lang.String;",
             "public final class Basic$AModule$$ModuleAdapter",
             "    extends ModuleAdapter<Basic.AModule> {",
             "  private static final String[] INJECTS = {\"members/Basic$A\"};",
@@ -59,6 +62,7 @@
     JavaFileObject expectedInjectAdapter =
         JavaFileObjects.forSourceString("Basic$A$$InjectAdapter", Joiner.on("\n").join(
             "import dagger.internal.Binding;",
+            "import java.lang.Override;",
             "import javax.inject.Provider;",
             "public final class Basic$A$$InjectAdapter",
             "    extends Binding<Basic.A> implements Provider<Basic.A> {",
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
index 3bf7a96..add10ec 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
@@ -62,6 +62,9 @@
         "import dagger.internal.BindingsGroup;",
         "import dagger.internal.ModuleAdapter;",
         "import dagger.internal.ProvidesBinding;",
+        "import java.lang.Class;",
+        "import java.lang.Override;",
+        "import java.lang.String;",
         "import javax.inject.Provider;",
         "public final class Field$AModule$$ModuleAdapter",
         "    extends ModuleAdapter<Field.AModule> {",
@@ -97,6 +100,9 @@
         JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
             "import dagger.internal.Binding;",
             "import dagger.internal.Linker;",
+            "import java.lang.Override;",
+            "import java.lang.String;",
+            "import java.lang.SuppressWarnings;",
             "import java.util.Set;",
             "import javax.inject.Provider;",
             "public final class Field$A$$InjectAdapter",
@@ -144,6 +150,9 @@
         "import dagger.internal.BindingsGroup;",
         "import dagger.internal.ModuleAdapter;",
         "import dagger.internal.ProvidesBinding;",
+        "import java.lang.Class;",
+        "import java.lang.Override;",
+        "import java.lang.String;",
         "import javax.inject.Provider;",
         "public final class Field$AModule$$ModuleAdapter extends ModuleAdapter<Field.AModule> {",
         "  private static final String[] INJECTS = ",
@@ -178,6 +187,9 @@
         JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
             "import dagger.internal.Binding;",
             "import dagger.internal.Linker;",
+            "import java.lang.Override;",
+            "import java.lang.String;",
+            "import java.lang.SuppressWarnings;",
             "import java.util.Set;",
             "import javax.inject.Provider;",
             "public final class Field$A$$InjectAdapter",
@@ -206,6 +218,9 @@
             "import dagger.MembersInjector;",
             "import dagger.internal.Binding;",
             "import dagger.internal.Linker;",
+            "import java.lang.Override;",
+            "import java.lang.String;",
+            "import java.lang.SuppressWarnings;",
             "import java.util.Set;",
             "import javax.inject.Provider;",
             "public final class Field$B$$InjectAdapter",
/Fim/
diff --git a/pom.xml b/pom.xml
index 7639984..89f9331 100644
--- a/pom.xml
+++ b/pom.xml
@@ -43,8 +43,8 @@
     <!-- Compilation -->
     <java.version>1.6</java.version>
     <javax.inject.version>1</javax.inject.version>
-    <javawriter.version>2.5.0</javawriter.version>
-    <guava.version>15.0</guava.version>
+    <javapoet.version>1.0.0</javapoet.version>
+    <guava.version>18.0</guava.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
@@ -86,8 +86,8 @@
       </dependency>
       <dependency>
         <groupId>com.squareup</groupId>
-        <artifactId>javawriter</artifactId>
-        <version>${javawriter.version}</version>
+        <artifactId>javapoet</artifactId>
+        <version>${javapoet.version}</version>
       </dependency>
       <dependency>
         <groupId>com.google.guava</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 19df04d..54ba98e 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -38,5 +38,16 @@
       <version>${project.version}</version>
       <optional>true</optional>
     </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-core</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 </project>
/Fim/
diff --git a/examples/simple/src/test/java/coffee/CoffeeMakerTest.java b/examples/simple/src/test/java/coffee/CoffeeMakerTest.java
new file mode 100644
index 0000000..310a188
--- /dev/null
+++ b/examples/simple/src/test/java/coffee/CoffeeMakerTest.java
@@ -0,0 +1,54 @@
+/**
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package coffee;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import dagger.Provides;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mockito;
+
+public class CoffeeMakerTest {
+  @Inject CoffeeMaker coffeeMaker;
+  @Inject Heater heater;
+
+  @Before public void setUp() {
+    ObjectGraph.create(new TestModule()).inject(this);
+  }
+
+  @Module(
+      includes = DripCoffeeModule.class,
+      injects = CoffeeMakerTest.class,
+      overrides = true
+  )
+  static class TestModule {
+    @Provides @Singleton Heater provideHeater() {
+      return Mockito.mock(Heater.class);
+    }
+  }
+
+  @Test public void testHeaterIsTurnedOnAndThenOff() {
+    Mockito.when(heater.isHot()).thenReturn(true);
+    coffeeMaker.brew();
+    Mockito.verify(heater, Mockito.times(1)).on();
+    Mockito.verify(heater, Mockito.times(1)).off();
+  }
+}
/Fim/
diff --git a/pom.xml b/pom.xml
index 89f9331..7d08bed 100644
--- a/pom.xml
+++ b/pom.xml
@@ -51,6 +51,7 @@
     <fest.version>1.4</fest.version>
     <truth.version>0.13</truth.version>
     <compile-testing.version>0.4</compile-testing.version>
+    <mockito.version>1.10.19</mockito.version>
   </properties>
 
   <scm>
@@ -114,6 +115,11 @@
         <artifactId>truth</artifactId>
         <version>${truth.version}</version>
       </dependency>
+      <dependency>
+        <groupId>org.mockito</groupId>
+        <artifactId>mockito-core</artifactId>
+        <version>${mockito.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
/Fim/
diff --git a/README.md b/README.md
index 8fdc4e3..02f4072 100644
--- a/README.md
+++ b/README.md
@@ -36,7 +36,7 @@
 ```
 
 You can also find downloadable .jars on Maven Central. You'll need
-[Dagger][dl-dagger], [JavaWriter][dl-javawriter], and [javax.inject][dl-inject].
+[Dagger][dl-dagger], [JavaPoet][dl-javapoet], and [javax.inject][dl-inject].
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
@@ -63,6 +63,6 @@
 
  [1]: http://square.github.com/dagger/
  [dl-dagger]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup.dagger%22%20a%3A%22dagger%22
- [dl-javawriter]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup%22%20a%3A%22javawriter%22
+ [dl-javapoet]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.squareup%22%20a%3A%22javapoet%22
  [dl-inject]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22javax.inject%22%20a%3A%22javax.inject%22
  [snap]: https://oss.sonatype.org/content/repositories/snapshots/
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 1b24640..07af929 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -48,24 +48,6 @@
   <build>
     <plugins>
       <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <version>1.8</version><!-- 1.9+ requires JDK7 -->
-        <executions>
-          <execution>
-            <id>sniff-api</id>
-            <goals><goal>check</goal></goals>
-          </execution>
-        </executions>
-        <configuration>
-          <signature>
-            <groupId>org.codehaus.mojo.signature</groupId>
-            <artifactId>java15</artifactId>
-            <version>1.0</version>
-          </signature>
-        </configuration>
-      </plugin>
-      <plugin>
         <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
           <excludePackageNames>dagger.internal:dagger.internal.*</excludePackageNames>
/Fim/
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index b5cf55e..e88ffce 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -16,12 +16,13 @@
 package dagger.internal;
 
 import dagger.internal.Binding.InvalidBindingException;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Deque;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Queue;
 import java.util.Set;
 
 /**
@@ -38,7 +39,7 @@
   private final Linker base;
 
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
-  private final Queue<Binding<?>> toLink = new ArrayQueue<Binding<?>>();
+  private final Deque<Binding<?>> toLink = new ArrayDeque<Binding<?>>();
 
   /** True unless calls to requestBinding() were unable to satisfy the binding. */
   private boolean attachSuccess = true;
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index e1bdfb1..3545ffb 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -57,11 +57,6 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.easytesting</groupId>
-      <artifactId>fest-assert</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
@@ -74,7 +69,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.truth0</groupId>
+      <groupId>com.google.truth</groupId>
       <artifactId>truth</artifactId>
       <scope>test</scope>
     </dependency>
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java
index e1ce8e2..cb17fc6 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java
@@ -21,7 +21,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static org.fest.assertions.Assertions.assertThat;
+import static com.google.common.truth.Truth.assertThat;
 
 @RunWith(JUnit4.class)
 public final class DotWriterTest {
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
index e511c65..319c15c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
@@ -24,7 +24,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static org.fest.assertions.Assertions.assertThat;
+import static com.google.common.truth.Truth.assertThat;
 
 @RunWith(JUnit4.class)
 public final class GraphVisualizerTest {
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index c4f07eb..e04348c 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -16,119 +16,128 @@
  */
 package dagger.tests.integration.codegen;
 
-import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public final class InjectAdapterGenerationTest {
   @Test public void basicInjectAdapter() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Basic", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import javax.inject.Inject;",
-        "class Basic {",
-        "  static class A { @Inject A() { } }",
-        "  static class Foo$Bar {",
-        "    @Inject Foo$Bar() { }",
-        "    static class Baz { @Inject Baz() { } }",
-        "  }",
-        "  @Module(injects = { A.class, Foo$Bar.class, Foo$Bar.Baz.class })",
-        "  static class AModule { }",
-        "}"));
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Basic", ""
+        + "import dagger.Module;\n"
+        + "import javax.inject.Inject;\n"
+        + "class Basic {\n"
+        + "  static class A { @Inject A() { } }\n"
+        + "  static class Foo$Bar {\n"
+        + "    @Inject Foo$Bar() { }\n"
+        + "    static class Baz { @Inject Baz() { } }\n"
+        + "  }\n"
+        + "  @Module(injects = { A.class, Foo$Bar.class, Foo$Bar.Baz.class })\n"
+        + "  static class AModule { }\n"
+        + "}\n"
+    );
 
     JavaFileObject expectedModuleAdapter =
-        JavaFileObjects.forSourceString("Basic$AModule$$ModuleAdapter", Joiner.on("\n").join(
-            "import dagger.internal.ModuleAdapter;",
-            "import java.lang.Class;",
-            "import java.lang.Override;",
-            "import java.lang.String;",
-            "public final class Basic$AModule$$ModuleAdapter",
-            "    extends ModuleAdapter<Basic.AModule> {",
-            "  private static final String[] INJECTS = {",
-            "      \"members/Basic$A\", \"members/Basic$Foo$Bar\", \"members/Basic$Foo$Bar$Baz\"};",
-            "  private static final Class<?>[] INCLUDES = {};",
-            "  public Basic$AModule$$ModuleAdapter() {",
-            "    super(Basic.AModule.class, INJECTS, false, INCLUDES,",
-            "      true, false);",
-            "  }",
-            "  @Override public Basic.AModule newModule() {",
-            "    return new Basic.AModule();",
-            "  }",
-            "}"));
+        JavaFileObjects.forSourceString("Basic$AModule$$ModuleAdapter", ""
+            + "import dagger.internal.ModuleAdapter;\n"
+            + "import java.lang.Class;\n"
+            + "import java.lang.Override;\n"
+            + "import java.lang.String;\n"
+            + "public final class Basic$AModule$$ModuleAdapter\n"
+            + "    extends ModuleAdapter<Basic.AModule> {\n"
+            + "  private static final String[] INJECTS = {\n"
+            + "      \"members/Basic$A\", \"members/Basic$Foo$Bar\", \"members/Basic$Foo$Bar$Baz\"};\n"
+            + "  private static final Class<?>[] INCLUDES = {};\n"
+            + "  public Basic$AModule$$ModuleAdapter() {\n"
+            + "    super(Basic.AModule.class, INJECTS, false, INCLUDES,\n"
+            + "      true, false);\n"
+            + "  }\n"
+            + "  @Override public Basic.AModule newModule() {\n"
+            + "    return new Basic.AModule();\n"
+            + "  }\n"
+            +"}\n"
+    );
 
     JavaFileObject expectedInjectAdapterA =
-        JavaFileObjects.forSourceString("Basic$A$$InjectAdapter", Joiner.on("\n").join(
-            "import dagger.internal.Binding;",
-            "import java.lang.Override;",
-            "public final class Basic$A$$InjectAdapter",
-            "    extends Binding<Basic.A> {",
-            "  public Basic$A$$InjectAdapter() {",
-            "    super(\"Basic$A\", \"members/Basic$A\", NOT_SINGLETON, Basic.A.class);",
-            "  }",
-            "  @Override public Basic.A get() {",
-            "    Basic.A result = new Basic.A();",
-            "    return result;",
-            "  }",
-            "}"));
+        JavaFileObjects.forSourceString("Basic$A$$InjectAdapter", ""
+            + "import dagger.internal.Binding;\n"
+            + "import java.lang.Override;\n"
+            + "public final class Basic$A$$InjectAdapter\n"
+            + "    extends Binding<Basic.A> {\n"
+            + "  public Basic$A$$InjectAdapter() {\n"
+            + "    super(\"Basic$A\", \"members/Basic$A\", NOT_SINGLETON, Basic.A.class);\n"
+            + "  }\n"
+            + "  @Override public Basic.A get() {\n"
+            + "    Basic.A result = new Basic.A();\n"
+            + "    return result;\n"
+            + "  }\n"
+            + "}\n"
+        );
 
     JavaFileObject expectedInjectAdapterFooBar =
-        JavaFileObjects.forSourceString("Basic$Foo$Bar$$InjectAdapter", Joiner.on("\n").join(
-            "import dagger.internal.Binding;",
-            "import java.lang.Override;",
-            "public final class Basic$Foo$Bar$$InjectAdapter",
-            "    extends Binding<Basic.Foo$Bar> {",
-            "  public Basic$Foo$Bar$$InjectAdapter() {",
-            "    super(\"Basic$Foo$Bar\", \"members/Basic$Foo$Bar\",",
-            "        NOT_SINGLETON, Basic.Foo$Bar.class);",
-            "  }",
-            "  @Override public Basic.Foo$Bar get() {",
-            "    Basic.Foo$Bar result = new Basic.Foo$Bar();",
-            "    return result;",
-            "  }",
-            "}"));
+        JavaFileObjects.forSourceString("Basic$Foo$Bar$$InjectAdapter", ""
+            + "import dagger.internal.Binding;\n"
+            + "import java.lang.Override;\n"
+            + "public final class Basic$Foo$Bar$$InjectAdapter\n"
+            + "    extends Binding<Basic.Foo$Bar> {\n"
+            + "  public Basic$Foo$Bar$$InjectAdapter() {\n"
+            + "    super(\"Basic$Foo$Bar\", \"members/Basic$Foo$Bar\",\n"
+            + "        NOT_SINGLETON, Basic.Foo$Bar.class);\n"
+            + "  }\n"
+            + "  @Override public Basic.Foo$Bar get() {\n"
+            + "    Basic.Foo$Bar result = new Basic.Foo$Bar();\n"
+            + "    return result;\n"
+            + "  }\n"
+            + "}\n"
+        );
 
     JavaFileObject expectedInjectAdapterFooBarBaz =
-        JavaFileObjects.forSourceString("Basic$Foo$Bar$Baz$$InjectAdapter", Joiner.on("\n").join(
-            "import dagger.internal.Binding;",
-            "import java.lang.Override;",
-            "public final class Basic$Foo$Bar$Baz$$InjectAdapter",
-            "    extends Binding<Basic.Foo$Bar.Baz> {",
-            "  public Basic$Foo$Bar$Baz$$InjectAdapter() {",
-            "    super(\"Basic$Foo$Bar$Baz\", \"members/Basic$Foo$Bar$Baz\",",
-            "        NOT_SINGLETON, Basic.Foo$Bar.Baz.class);",
-            "  }",
-            "  @Override public Basic.Foo$Bar.Baz get() {",
-            "    Basic.Foo$Bar.Baz result = new Basic.Foo$Bar.Baz();",
-            "    return result;",
-            "  }",
-            "}"));
+        JavaFileObjects.forSourceString("Basic$Foo$Bar$Baz$$InjectAdapter", ""
+            + "import dagger.internal.Binding;\n"
+            + "import java.lang.Override;\n"
+            + "public final class Basic$Foo$Bar$Baz$$InjectAdapter\n"
+            + "    extends Binding<Basic.Foo$Bar.Baz> {\n"
+            + "  public Basic$Foo$Bar$Baz$$InjectAdapter() {\n"
+            + "    super(\"Basic$Foo$Bar$Baz\", \"members/Basic$Foo$Bar$Baz\",\n"
+            + "        NOT_SINGLETON, Basic.Foo$Bar.Baz.class);\n"
+            + "  }\n"
+            + "  @Override public Basic.Foo$Bar.Baz get() {\n"
+            + "    Basic.Foo$Bar.Baz result = new Basic.Foo$Bar.Baz();\n"
+            + "    return result;\n"
+            + "  }\n"
+            + "}\n"
+        );
 
-    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
-        .compilesWithoutError().and()
+    assertAbout(javaSource())
+        .that(sourceFile)
+        .processedWith(daggerProcessors())
+        .compilesWithoutError()
+        .and()
         .generatesSources(expectedModuleAdapter, expectedInjectAdapterA,
             expectedInjectAdapterFooBar, expectedInjectAdapterFooBarBaz);
 
   }
 
   @Test public void injectStaticFails() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Basic", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import javax.inject.Inject;",
-        "class Basic {",
-        "  static class A { @Inject A() { } }",
-        "  static class B { @Inject static A a; }",
-        "  @Module(injects = B.class)",
-        "  static class AModule { }",
-        "}"));
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Basic", ""
+        + "import dagger.Module;\n"
+        + "import javax.inject.Inject;\n"
+        + "class Basic {\n"
+        + "  static class A { @Inject A() { } }\n"
+        + "  static class B { @Inject static A a; }\n"
+        + "  @Module(injects = B.class)\n"
+        + "  static class AModule { }\n"
+        + "}\n"
+    );
 
-    ASSERT.about(javaSource()).that(sourceFile)
+    assertAbout(javaSource())
+        .that(sourceFile)
         .processedWith(daggerProcessors())
         .failsToCompile()
         .withErrorContaining("@Inject not supported on static field Basic.B")
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
index 351388c..a2a1f24 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
@@ -16,18 +16,17 @@
  */
 package dagger.tests.integration.codegen;
 
-import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static java.util.Arrays.asList;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public final class ModuleAdapterGenerationTest {
@@ -47,83 +46,88 @@
    * </ul>
    */
   @Test public void providerForCtorInjection() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "class Field {",
-        "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
-        "  @Module(injects = { A.class, String.class })",
-        "  static class AModule { @Provides String name() { return \"foo\"; }}",
-        "}"));
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", ""
+        + "import dagger.Module;\n"
+        + "import dagger.Provides;\n"
+        + "import javax.inject.Inject;\n"
+        + "class Field {\n"
+        + "  static class A { final String name; @Inject A(String name) { this.name = name; }}\n"
+        + "  @Module(injects = { A.class, String.class })\n"
+        + "  static class AModule { @Provides String name() { return \"foo\"; }}\n"
+        + "}\n"
+    );
 
     JavaFileObject expectedModuleAdapter =
-        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
-        "import dagger.internal.BindingsGroup;",
-        "import dagger.internal.ModuleAdapter;",
-        "import dagger.internal.ProvidesBinding;",
-        "import java.lang.Class;",
-        "import java.lang.Override;",
-        "import java.lang.String;",
-        "public final class Field$AModule$$ModuleAdapter",
-        "    extends ModuleAdapter<Field.AModule> {",
-        "  private static final String[] INJECTS = ",
-        "      {\"members/Field$A\", \"members/java.lang.String\"};",
-        "  private static final Class<?>[] INCLUDES = {};",
-        "  public Field$AModule$$ModuleAdapter() {",
-        "    super(Field.AModule.class, INJECTS, false, INCLUDES, true, false);",
-        "  }",
-        "  @Override public Field.AModule newModule() {",
-        "    return new Field.AModule();",
-        "  }",
-        "  @Override public void getBindings(BindingsGroup bindings, Field.AModule module) {",
-        "    bindings.contributeProvidesBinding(\"java.lang.String\",",
-        "        new NameProvidesAdapter(module));", // eager new!
-        "  }",
-        "  public static final class NameProvidesAdapter", // corresponds to method name
-        "      extends ProvidesBinding<String> {",
-        "    private final Field.AModule module;",
-        "    public NameProvidesAdapter(Field.AModule module) {",
-        "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");",
-        "      this.module = module;",
-        "      setLibrary(false);",
-        "    }",
-        "    @Override public String get() {",
-        "      return module.name();", // corresponds to @Provides method
-        "    }",
-        "  }",
-        "}"));
+        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", ""
+            + "import dagger.internal.BindingsGroup;\n"
+            + "import dagger.internal.ModuleAdapter;\n"
+            + "import dagger.internal.ProvidesBinding;\n"
+            + "import java.lang.Class;\n"
+            + "import java.lang.Override;\n"
+            + "import java.lang.String;\n"
+            + "public final class Field$AModule$$ModuleAdapter\n"
+            + "    extends ModuleAdapter<Field.AModule> {\n"
+            + "  private static final String[] INJECTS = \n"
+            + "      {\"members/Field$A\", \"members/java.lang.String\"};\n"
+            + "  private static final Class<?>[] INCLUDES = {};\n"
+            + "  public Field$AModule$$ModuleAdapter() {\n"
+            + "    super(Field.AModule.class, INJECTS, false, INCLUDES, true, false);\n"
+            + "  }\n"
+            + "  @Override public Field.AModule newModule() {\n"
+            + "    return new Field.AModule();\n"
+            + "  }\n"
+            + "  @Override public void getBindings(BindingsGroup bindings, Field.AModule module) {\n"
+            + "    bindings.contributeProvidesBinding(\"java.lang.String\",\n"
+            + "        new NameProvidesAdapter(module));\n" // eager new!
+            + "  }\n"
+            + "  public static final class NameProvidesAdapter\n" // corresponds to method name
+            + "      extends ProvidesBinding<String> {\n"
+            + "    private final Field.AModule module;\n"
+            + "    public NameProvidesAdapter(Field.AModule module) {\n"
+            + "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");\n"
+            + "      this.module = module;\n"
+            + "      setLibrary(false);\n"
+            + "    }\n"
+            + "    @Override public String get() {\n"
+            + "      return module.name();\n" // corresponds to @Provides method
+            + "    }\n"
+            + "  }\n"
+            + "}\n"
+        );
 
     JavaFileObject expectedInjectAdapter =
-        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
-            "import dagger.internal.Binding;",
-            "import dagger.internal.Linker;",
-            "import java.lang.Override;",
-            "import java.lang.String;",
-            "import java.lang.SuppressWarnings;",
-            "import java.util.Set;",
-            "public final class Field$A$$InjectAdapter",
-            "    extends Binding<Field.A> {",
-            "  private Binding<String> name;", // for ctor
-            "  public Field$A$$InjectAdapter() {",
-            "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
-            "  }",
-            "  @Override @SuppressWarnings(\"unchecked\")",
-            "  public void attach(Linker linker) {",
-            "    name = (Binding<String>)linker.requestBinding(", // binding key is not a class
-            "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());",
-            "  }",
-            "  @Override public void getDependencies(",
-            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
-            "    getBindings.add(name);", // name is added to dependencies
-            "  }",
-            "  @Override public Field.A get() {",
-            "    Field.A result = new Field.A(name.get());", // adds ctor param
-            "    return result;",
-            "  }",
-            "}"));
+        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", ""
+            + "import dagger.internal.Binding;\n"
+            + "import dagger.internal.Linker;\n"
+            + "import java.lang.Override;\n"
+            + "import java.lang.String;\n"
+            + "import java.lang.SuppressWarnings;\n"
+            + "import java.util.Set;\n"
+            + "public final class Field$A$$InjectAdapter\n"
+            + "    extends Binding<Field.A> {\n"
+            + "  private Binding<String> name;\n" // for ctor
+            + "  public Field$A$$InjectAdapter() {\n"
+            + "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);\n"
+            + "  }\n"
+            + "  @Override @SuppressWarnings(\"unchecked\")\n"
+            + "  public void attach(Linker linker) {\n"
+            + "    name = (Binding<String>)linker.requestBinding(\n" // binding key is not a class
+            + "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());\n"
+            + "  }\n"
+            + "  @Override public void getDependencies(\n"
+            + "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {\n"
+            + "    getBindings.add(name);\n" // name is added to dependencies
+            + "  }\n"
+            + "  @Override public Field.A get() {\n"
+            + "    Field.A result = new Field.A(name.get());\n" // adds ctor param
+            + "    return result;\n"
+            + "  }\n"
+            + "}\n"
+        );
 
-    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
+    assertAbout(javaSource())
+        .that(sourceFile)
+        .processedWith(daggerProcessors())
         .compilesWithoutError()
         .and()
         .generatesSources(expectedModuleAdapter, expectedInjectAdapter);
@@ -131,149 +135,169 @@
   }
 
   @Test public void injectsMembersInjectedAndProvidedAndConstructedTypes() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "class Field {",
-        "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
-        "  static class B { @Inject String name; }",
-        "  @Module(injects = { A.class, String.class, B.class })",
-        "  static class AModule { @Provides String name() { return \"foo\"; }}",
-        "}"));
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", ""
+        + "import dagger.Module;\n"
+        + "import dagger.Provides;\n"
+        + "import javax.inject.Inject;\n"
+        + "class Field {\n"
+        + "  static class A { final String name; @Inject A(String name) { this.name = name; }}\n"
+        + "  static class B { @Inject String name; }\n"
+        + "  @Module(injects = { A.class, String.class, B.class })\n"
+        + "  static class AModule { @Provides String name() { return \"foo\"; }}\n"
+        + "}\n"
+    );
 
     JavaFileObject expectedModuleAdapter =
-        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
-        "import dagger.internal.BindingsGroup;",
-        "import dagger.internal.ModuleAdapter;",
-        "import dagger.internal.ProvidesBinding;",
-        "import java.lang.Class;",
-        "import java.lang.Override;",
-        "import java.lang.String;",
-        "public final class Field$AModule$$ModuleAdapter extends ModuleAdapter<Field.AModule> {",
-        "  private static final String[] INJECTS = ",
-        "      {\"members/Field$A\", \"members/java.lang.String\", \"members/Field$B\"};",
-        "  private static final Class<?>[] INCLUDES = {};",
-        "  public Field$AModule$$ModuleAdapter() {",
-        "    super(Field.AModule.class, INJECTS, false, INCLUDES, true, false);",
-        "  }",
-        "  @Override public Field.AModule newModule() {",
-        "    return new Field.AModule();",
-        "  }",
-        "  @Override public void getBindings(BindingsGroup bindings, Field.AModule module) {",
-        "    bindings.contributeProvidesBinding(\"java.lang.String\",",
-        "        new NameProvidesAdapter(module));", // eager new!
-        "  }",
-        "  public static final class NameProvidesAdapter", // corresponds to method name
-        "      extends ProvidesBinding<String> {",
-        "    private final Field.AModule module;",
-        "    public NameProvidesAdapter(Field.AModule module) {",
-        "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");",
-        "      this.module = module;",
-        "      setLibrary(false);",
-        "    }",
-        "    @Override public String get() {",
-        "      return module.name();", // corresponds to @Provides method
-        "    }",
-        "  }",
-        "}"));
+        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", ""
+            + "import dagger.internal.BindingsGroup;\n"
+            + "import dagger.internal.ModuleAdapter;\n"
+            + "import dagger.internal.ProvidesBinding;\n"
+            + "import java.lang.Class;\n"
+            + "import java.lang.Override;\n"
+            + "import java.lang.String;\n"
+            + "public final class Field$AModule$$ModuleAdapter extends ModuleAdapter<Field.AModule> {\n"
+            + "  private static final String[] INJECTS = \n"
+            + "      {\"members/Field$A\", \"members/java.lang.String\", \"members/Field$B\"};\n"
+            + "  private static final Class<?>[] INCLUDES = {};\n"
+            + "  public Field$AModule$$ModuleAdapter() {\n"
+            + "    super(Field.AModule.class, INJECTS, false, INCLUDES, true, false);\n"
+            + "  }\n"
+            + "  @Override public Field.AModule newModule() {\n"
+            + "    return new Field.AModule();\n"
+            + "  }\n"
+            + "  @Override public void getBindings(BindingsGroup bindings, Field.AModule module) {\n"
+            + "    bindings.contributeProvidesBinding(\"java.lang.String\",\n"
+            + "        new NameProvidesAdapter(module));\n" // eager new!
+            + "  }\n"
+            + "  public static final class NameProvidesAdapter\n" // corresponds to method name
+            + "      extends ProvidesBinding<String> {\n"
+            + "    private final Field.AModule module;\n"
+            + "    public NameProvidesAdapter(Field.AModule module) {\n"
+            + "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");\n"
+            + "      this.module = module;\n"
+            + "      setLibrary(false);\n"
+            + "    }\n"
+            + "    @Override public String get() {\n"
+            + "      return module.name();\n" // corresponds to @Provides method
+            + "    }\n"
+            + "  }\n"
+            + "}\n"
+        );
 
     JavaFileObject expectedInjectAdapterA =
-        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
-            "import dagger.internal.Binding;",
-            "import dagger.internal.Linker;",
-            "import java.lang.Override;",
-            "import java.lang.String;",
-            "import java.lang.SuppressWarnings;",
-            "import java.util.Set;",
-            "public final class Field$A$$InjectAdapter",
-            "    extends Binding<Field.A> {",
-            "  private Binding<String> name;", // For Constructor.
-            "  public Field$A$$InjectAdapter() {",
-            "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
-            "  }",
-            "  @Override @SuppressWarnings(\"unchecked\")",
-            "  public void attach(Linker linker) {",
-            "    name = (Binding<String>)linker.requestBinding(",
-            "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());",
-            "  }",
-            "  @Override public void getDependencies(",
-            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
-            "    getBindings.add(name);", // Name is added to dependencies.
-            "  }",
-            "  @Override public Field.A get() {",
-            "    Field.A result = new Field.A(name.get());", // Adds constructor parameter.
-            "    return result;",
-            "  }",
-            "}"));
+        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", ""
+            + "import dagger.internal.Binding;\n"
+            + "import dagger.internal.Linker;\n"
+            + "import java.lang.Override;\n"
+            + "import java.lang.String;\n"
+            + "import java.lang.SuppressWarnings;\n"
+            + "import java.util.Set;\n"
+            + "public final class Field$A$$InjectAdapter\n"
+            + "    extends Binding<Field.A> {\n"
+            + "  private Binding<String> name;\n" // For Constructor.
+            + "  public Field$A$$InjectAdapter() {\n"
+            + "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);\n"
+            + "  }\n"
+            + "  @Override @SuppressWarnings(\"unchecked\")\n"
+            + "  public void attach(Linker linker) {\n"
+            + "    name = (Binding<String>)linker.requestBinding(\n"
+            + "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());\n"
+            + "  }\n"
+            + "  @Override public void getDependencies(\n"
+            + "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {\n"
+            + "    getBindings.add(name);\n" // Name is added to dependencies.
+            + "  }\n"
+            + "  @Override public Field.A get() {\n"
+            + "    Field.A result = new Field.A(name.get());\n" // Adds constructor parameter.
+            + "    return result;\n"
+            + "  }\n"
+            + "}\n"
+        );
 
     JavaFileObject expectedInjectAdapterB =
-        JavaFileObjects.forSourceString("Field$B$$InjectAdapter", Joiner.on("\n").join(
-            "import dagger.internal.Binding;",
-            "import dagger.internal.Linker;",
-            "import java.lang.Override;",
-            "import java.lang.String;",
-            "import java.lang.SuppressWarnings;",
-            "import java.util.Set;",
-            "public final class Field$B$$InjectAdapter",
-            "    extends Binding<Field.B> {",
-            "  private Binding<String> name;", // For field.
-            "  public Field$B$$InjectAdapter() {",
-            "    super(\"Field$B\", \"members/Field$B\", NOT_SINGLETON, Field.B.class);",
-            "  }",
-            "  @Override @SuppressWarnings(\"unchecked\")",
-            "  public void attach(Linker linker) {",
-            "    name = (Binding<String>)linker.requestBinding(",
-            "      \"java.lang.String\", Field.B.class, getClass().getClassLoader());",
-            "  }",
-            "  @Override public void getDependencies(",
-            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
-            "    injectMembersBindings.add(name);", // Name is added to dependencies.
-            "  }",
-            "  @Override public Field.B get() {",
-            "    Field.B result = new Field.B();",
-            "    injectMembers(result);",
-            "    return result;",
-            "  }",
-            "  @Override public void injectMembers(Field.B object) {",
-            "    object.name = name.get();", // Inject field.
-            "  }",
-            "}"));
-    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
+        JavaFileObjects.forSourceString("Field$B$$InjectAdapter", ""
+            + "import dagger.internal.Binding;\n"
+            + "import dagger.internal.Linker;\n"
+            + "import java.lang.Override;\n"
+            + "import java.lang.String;\n"
+            + "import java.lang.SuppressWarnings;\n"
+            + "import java.util.Set;\n"
+            + "public final class Field$B$$InjectAdapter\n"
+            + "    extends Binding<Field.B> {\n"
+            + "  private Binding<String> name;\n" // For field.
+            + "  public Field$B$$InjectAdapter() {\n"
+            + "    super(\"Field$B\", \"members/Field$B\", NOT_SINGLETON, Field.B.class);\n"
+            + "  }\n"
+            + "  @Override @SuppressWarnings(\"unchecked\")\n"
+            + "  public void attach(Linker linker) {\n"
+            + "    name = (Binding<String>)linker.requestBinding(\n"
+            + "      \"java.lang.String\", Field.B.class, getClass().getClassLoader());\n"
+            + "  }\n"
+            + "  @Override public void getDependencies(\n"
+            + "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {\n"
+            + "    injectMembersBindings.add(name);\n" // Name is added to dependencies.
+            + "  }\n"
+            + "  @Override public Field.B get() {\n"
+            + "    Field.B result = new Field.B();\n"
+            + "    injectMembers(result);\n"
+            + "    return result;\n"
+            + "  }\n"
+            + "  @Override public void injectMembers(Field.B object) {\n"
+            + "    object.name = name.get();\n" // Inject field.
+            + "  }\n"
+            + "}\n"
+        );
+    assertAbout(javaSource())
+        .that(sourceFile)
+        .processedWith(daggerProcessors())
         .compilesWithoutError()
         .and()
         .generatesSources(expectedModuleAdapter, expectedInjectAdapterA, expectedInjectAdapterB);
   }
 
   @Test public void providesHasParameterNamedModule() {
-    JavaFileObject a = JavaFileObjects.forSourceString("A", Joiner.on("\n").join(
-        "import javax.inject.Inject;",
-        "class A { @Inject A(){ }}"));
-    JavaFileObject b = JavaFileObjects.forSourceString("B", Joiner.on("\n").join(
-        "import javax.inject.Inject;",
-        "class B { @Inject B(){ }}"));
+    JavaFileObject a = JavaFileObjects.forSourceString("A", ""
+        + "import javax.inject.Inject;\n"
+        + "class A {\n"
+        + "  @Inject A(){ }\n"
+        + "}\n"
+    );
+    JavaFileObject b = JavaFileObjects.forSourceString("B", ""
+        + "import javax.inject.Inject;\n"
+        + "class B {\n"
+        + "  @Inject B(){ }\n"
+        + "}\n"
+    );
 
-    JavaFileObject module = JavaFileObjects.forSourceString("BModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "@Module(injects = B.class)",
-        "class BModule { @Provides B b(A module) { return new B(); }}"));
+    JavaFileObject module = JavaFileObjects.forSourceString("BModule", ""
+        + "import dagger.Module;\n"
+        + "import dagger.Provides;\n"
+        + "import javax.inject.Inject;\n"
+        + "@Module(injects = B.class)\n"
+        + "class BModule {\n"
+        + "  @Provides B b(A module) {\n"
+        + "    return new B();\n"
+        + "  }\n"
+        + "}\n"
+    );
 
-    ASSERT.about(javaSources()).that(asList(a, b, module)).processedWith(daggerProcessors())
+    assertAbout(javaSources())
+        .that(asList(a, b, module))
+        .processedWith(daggerProcessors())
         .compilesWithoutError();
   }
 
   @Test public void duplicateInjectsFails() {
-    JavaFileObject module = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "class A {}",
-        "@Module(injects = { A.class, A.class })",
-        "class BModule { }"));
+    JavaFileObject module = JavaFileObjects.forSourceString("Test", ""
+        + "import dagger.Module;\n"
+        + "import dagger.Provides;\n"
+        + "import javax.inject.Inject;\n"
+        + "class A {}\n"
+        + "@Module(injects = { A.class, A.class })\n"
+        + "class BModule { }\n"
+    );
 
-    ASSERT.about(javaSource())
+    assertAbout(javaSource())
         .that(module)
         .processedWith(daggerProcessors())
         .failsToCompile()
@@ -282,16 +306,17 @@
   }
 
   @Test public void duplicateIncludesFails() {
-    JavaFileObject module = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "@Module",
-        "class AModule {}",
-        "@Module(includes = { AModule.class, AModule.class })",
-        "class BModule { }"));
+    JavaFileObject module = JavaFileObjects.forSourceString("Test", ""
+        + "import dagger.Module;\n"
+        + "import dagger.Provides;\n"
+        + "import javax.inject.Inject;\n"
+        + "@Module\n"
+        + "class AModule {}\n"
+        + "@Module(includes = { AModule.class, AModule.class })\n"
+        + "class BModule { }\n"
+    );
 
-    ASSERT.about(javaSource())
+    assertAbout(javaSource())
         .that(module)
         .processedWith(daggerProcessors())
         .failsToCompile()
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/FailureModeErrorsTest.java b/compiler/src/test/java/dagger/tests/integration/operation/FailureModeErrorsTest.java
index fe4d0ee..4938470 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/FailureModeErrorsTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/FailureModeErrorsTest.java
@@ -24,8 +24,8 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assertThat;
 import static junit.framework.Assert.fail;
-import static org.fest.assertions.Assertions.assertThat;
 
 @RunWith(JUnit4.class)
 public final class FailureModeErrorsTest {
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 5f7451c..569a4a0 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -24,7 +24,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static org.fest.assertions.Assertions.assertThat;
+import static com.google.common.truth.Truth.assertThat;
 
 @RunWith(JUnit4.class)
 public final class PrimitiveInjectionTest {
@@ -58,7 +58,7 @@
     assertThat(result.booleanArray).isEqualTo(new boolean[] { true });
     assertThat(result.charArray).isEqualTo(new char[] { Character.MAX_VALUE });
     assertThat(result.longArray).isEqualTo(new long[] { Long.MAX_VALUE });
-    assertThat(result.floatArray).isEqualTo(new float[] { Float.MAX_VALUE });
-    assertThat(result.doubleArray).isEqualTo(new double[] { Double.MAX_VALUE });
+    assertThat(result.floatArray).hasValuesWithin(0).of(new float[] { Float.MAX_VALUE });
+    assertThat(result.doubleArray).hasValuesWithin(0).of(new double[] { Double.MAX_VALUE });
   }
 }
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
index 994c780..46274f8 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
@@ -24,7 +24,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static org.truth0.Truth.ASSERT;
+import static com.google.common.truth.Truth.assertThat;
 
 @RunWith(JUnit4.class)
 public final class SimpleInjectionTest {
@@ -52,18 +52,18 @@
   @Test public void memberInject_WithoutProvidesMethod() {
     Foo foo = new Foo();
     ObjectGraph.create(FooModule.class).inject(foo);
-    ASSERT.that(foo.blah).equals("blah");
+    assertThat(foo.blah).isEqualTo("blah");
   }
 
   @Test public void membersInject_WithProvidesMethod() {
     Foo foo = new Foo();
     ObjectGraph.create(ProvidingFooModule.class).inject(foo);
-    ASSERT.that(foo.blah).equals("blah");
+    assertThat(foo.blah).isEqualTo("blah");
   }
 
   @Test public void get_WithProvidesMethod() {
     Foo foo = ObjectGraph.create(ProvidingFooModule.class).get(Foo.class);
-    ASSERT.that(foo.blah).equals("blah");
+    assertThat(foo.blah).isEqualTo("blah");
   }
 
   static class Bar { }
@@ -84,7 +84,7 @@
 
   @Test public void membersInject_WithProvidedNonInjectable() {
     Bar bar = ObjectGraph.create(ProvidingBarModule.class).get(Bar.class);
-    ASSERT.that(bar).isNotNull();
+    assertThat(bar).isNotNull();
   }
 
 }
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
index 153bf9d..881f3b4 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
@@ -16,64 +16,65 @@
  */
 package dagger.tests.integration.validation;
 
-import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public class CyclicDependencyTest {
 
   @Test public void cyclicDepsWithInjectables() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("CyclicDeps", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import javax.inject.Inject;",
-        "class CyclicDeps {",
-        "  static class Foo {",
-        "    @Inject Foo(Bar b) { }",
-        "  }",
-        "  static class Bar {",
-        "    @Inject Bar(Blah b) { }",
-        "  }",
-        "  static class Blah {",
-        "    @Inject Blah(Foo f) { }",
-        "  }",
-        "  static class EntryPoint {",
-        "    @Inject Foo f;",
-        "  }",
-        "  @Module(injects = EntryPoint.class)",
-        "  static class TestModule { }",
-        "}"));
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("CyclicDeps", ""
+        + "import dagger.Module;\n"
+        + "import javax.inject.Inject;\n"
+        + "class CyclicDeps {\n"
+        + "  static class Foo {\n"
+        + "    @Inject Foo(Bar b) { }\n"
+        + "  }\n"
+        + "  static class Bar {\n"
+        + "    @Inject Bar(Blah b) { }\n"
+        + "  }\n"
+        + "  static class Blah {\n"
+        + "    @Inject Blah(Foo f) { }\n"
+        + "  }\n"
+        + "  static class EntryPoint {\n"
+        + "    @Inject Foo f;\n"
+        + "  }\n"
+        + "  @Module(injects = EntryPoint.class)\n"
+        + "  static class TestModule { }\n"
+        + "}\n"
+    );
 
-    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+    assertAbout(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
         .withErrorContaining("Dependency cycle:").in(sourceFile).onLine(17);
   }
 
   @Test public void cyclicDepsWithProvidesMethods() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("CyclicDeps", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "class CyclicDeps {",
-        "  static class A { }",
-        "  static class B { }",
-        "  static class C { }",
-        "  static class D { }",
-        "  @Module(injects = D.class)",
-        "  static class CyclicModule {",
-        "    @Provides A a(D d) { return null; }",
-        "    @Provides B b(A a) { return null; }",
-        "    @Provides C c(B b) { return null; }",
-        "    @Provides D d(C c) { return null; }",
-        "  }",
-        "}"));
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("CyclicDeps", ""
+        + "import dagger.Module;\n"
+        + "import dagger.Provides;\n"
+        + "class CyclicDeps {\n"
+        + "  static class A { }\n"
+        + "  static class B { }\n"
+        + "  static class C { }\n"
+        + "  static class D { }\n"
+        + "  @Module(injects = D.class)\n"
+        + "  static class CyclicModule {\n"
+        + "    @Provides A a(D d) { return null; }\n"
+        + "    @Provides B b(A a) { return null; }\n"
+        + "    @Provides C c(B b) { return null; }\n"
+        + "    @Provides D d(C c) { return null; }\n"
+        + "  }\n"
+        + "}\n"
+    );
 
-    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
+    assertAbout(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
         .withErrorContaining("Dependency cycle:").in(sourceFile).onLine(9);
   }
 
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java b/compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java
index a152518..fbfe5b5 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/CyclicModuleIncludesTest.java
@@ -16,59 +16,68 @@
  */
 package dagger.tests.integration.validation;
 
-import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public class CyclicModuleIncludesTest {
   private final JavaFileObject javaFile =
-      JavaFileObjects.forSourceString("CyclicModules", Joiner.on("\n").join(
-          "import dagger.Module;",
-          "class CyclicModules {",
-          "  @Module(includes = SelfReferencingModule.class)",
-          "  static class SelfReferencingModule { }",
-          "  @Module(includes = Spock.class)",
-          "  static class Rock {}",
-          "  @Module(includes = Rock.class)",
-          "  static class Paper {}",
-          "  @Module(includes = Paper.class)",
-          "  static class Scissors {}",
-          "  @Module(includes = Scissors.class)",
-          "  static class Lizard {}",
-          "  @Module(includes = Lizard.class)",
-          "  static class Spock {}",
-          "}"));
+      JavaFileObjects.forSourceString("CyclicModules", ""
+          + "import dagger.Module;\n"
+          + "class CyclicModules {\n"
+          + "  @Module(includes = SelfReferencingModule.class)\n"
+          + "  static class SelfReferencingModule { }\n"
+          + "  @Module(includes = Spock.class)\n"
+          + "  static class Rock {}\n"
+          + "  @Module(includes = Rock.class)\n"
+          + "  static class Paper {}\n"
+          + "  @Module(includes = Paper.class)\n"
+          + "  static class Scissors {}\n"
+          + "  @Module(includes = Scissors.class)\n"
+          + "  static class Lizard {}\n"
+          + "  @Module(includes = Lizard.class)\n"
+          + "  static class Spock {}\n"
+          + "}"
+      );
 
   @Test public void cyclicModuleSelfIncludes() {
-    ASSERT.about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
+    assertAbout(javaSource())
+        .that(javaFile)
+        .processedWith(daggerProcessors())
+        .failsToCompile()
         .withErrorContaining("CyclicModules.SelfReferencingModule includes itself directly")
-            .in(javaFile).onLine(4);
+        .in(javaFile).onLine(4);
   }
 
   @Test public void cyclicModuleIncludes_full_cycle() {
-    ASSERT.about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
+    assertAbout(javaSource())
+        .that(javaFile)
+        .processedWith(daggerProcessors())
+        .failsToCompile()
         .withErrorContaining("0. CyclicModules.Rock included by CyclicModules.Paper")
-            .in(javaFile).onLine(6).and()
+        .in(javaFile).onLine(6).and()
         .withErrorContaining("1. CyclicModules.Paper included by CyclicModules.Scissors")
-            .in(javaFile).onLine(6).and()
+        .in(javaFile).onLine(6).and()
         .withErrorContaining("2. CyclicModules.Scissors included by CyclicModules.Lizard")
-            .in(javaFile).onLine(6).and()
+        .in(javaFile).onLine(6).and()
         .withErrorContaining("3. CyclicModules.Lizard included by CyclicModules.Spock")
-            .in(javaFile).onLine(6).and()
+        .in(javaFile).onLine(6).and()
         .withErrorContaining("4. CyclicModules.Spock included by CyclicModules.Rock")
-            .in(javaFile).onLine(6);
+        .in(javaFile).onLine(6);
   }
 
   @Test public void cyclicModuleIncludes_initial_inclusion() {
-    ASSERT.about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
+    assertAbout(javaSource())
+        .that(javaFile)
+        .processedWith(daggerProcessors())
+        .failsToCompile()
         .withErrorContaining("0. CyclicModules.Rock included by CyclicModules.Paper")
             .in(javaFile).onLine(6).and()
         .withErrorContaining("0. CyclicModules.Paper included by CyclicModules.Scissors")
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java
index ad8ca17..5042b2f 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/GeneratedTypesNotReadyTest.java
@@ -35,7 +35,7 @@
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static java.util.Arrays.asList;
-import static org.truth0.Truth.ASSERT;
+import static com.google.common.truth.Truth.assertAbout;
 
 /**
  * Tests that the annotation processor(s) will properly handle the case where
@@ -44,69 +44,77 @@
  */
 @RunWith(JUnit4.class)
 public class GeneratedTypesNotReadyTest {
-  private final JavaFileObject foo = JavaFileObjects.forSourceString("Foo", Joiner.on("\n").join(
-      "package myPackage;",
-      "public interface Foo {}"
-  ));
-  private final JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
-      "import javax.inject.Inject;",
-      "import myPackage.Foo;",
-      "class Main {",
-      "  @Inject Foo f;",
-      "}"));
+  private final JavaFileObject foo = JavaFileObjects.forSourceString("Foo", ""
+      + "package myPackage;\n"
+      + "public interface Foo {}\n"
+  );
+  private final JavaFileObject main = JavaFileObjects.forSourceString("Main", ""
+      + "import javax.inject.Inject;\n"
+      + "import myPackage.Foo;\n"
+      + "class Main {\n"
+      + "  @Inject Foo f;\n"
+      + "}\n"
+  );
 
   @Test public void withstandsMissingTypeReferencedInInjects() {
     // TODO(cgruber): remove Foo (interface) from this when injects= analysis is fixed.
-    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import myPackage.Foo;",
-        "@Module(injects = { Main.class, myPackage.FooImpl.class })",
-        "class FooModule {",
-        "  @Provides Foo provideFoo(myPackage.FooImpl impl) {",
-        "    return impl;",
-        "  }",
-        "}"));
+    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", ""
+        + "import dagger.Module;\n"
+        + "import dagger.Provides;\n"
+        + "import myPackage.Foo;\n"
+        + "@Module(injects = { Main.class, myPackage.FooImpl.class })\n"
+        + "class FooModule {\n"
+        + "  @Provides Foo provideFoo(myPackage.FooImpl impl) {\n"
+        + "    return impl;\n"
+        + "  }\n"
+        + "}\n"
+    );
 
-    ASSERT.about(javaSources()).that(asList(foo, main, module))
+    assertAbout(javaSources())
+        .that(asList(foo, main, module))
         .processedWith(concat(asList(new FooImplGenerator()), daggerProcessors()))
         .compilesWithoutError();
   }
 
   @Test public void withstandsMissingTypeReferencedInsideModule() {
-    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import myPackage.Foo;",
-        "@Module(injects = { Main.class })",
-        "class FooModule {",
-        "  @Provides Foo provideFoo(myPackage.FooImpl impl) {",
-        "    return impl;",
-        "  }",
-        "}"));
+    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", ""
+        + "import dagger.Module;\n"
+        + "import dagger.Provides;\n"
+        + "import myPackage.Foo;\n"
+        + "@Module(injects = { Main.class })\n"
+        + "class FooModule {\n"
+        + "  @Provides Foo provideFoo(myPackage.FooImpl impl) {\n"
+        + "    return impl;\n"
+        + "  }\n"
+        + "}\n"
+    );
 
-    ASSERT.about(javaSources()).that(asList(foo, module, main))
+    assertAbout(javaSources())
+        .that(asList(foo, module, main))
         .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
         .compilesWithoutError();
   }
 
   @Test public void withstandsMissingTypeReferencedByProvidesReturnType() {
-    JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
-        "import javax.inject.Inject;",
-        "class Main {",
-        "  @Inject myPackage.FooImpl f;",
-        "}"));
-    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "@Module(injects = { Main.class })",
-        "class FooModule {",
-        "  @Provides myPackage.FooImpl provideFoo() {",
-        "    return new myPackage.FooImpl();",
-        "  }",
-        "}"));
+    JavaFileObject main = JavaFileObjects.forSourceString("Main", ""
+        + "import javax.inject.Inject;\n"
+        + "class Main {\n"
+        + "  @Inject myPackage.FooImpl f;\n"
+        + "}\n"
+    );
+    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", ""
+        + "import dagger.Module;\n"
+        + "import dagger.Provides;\n"
+        + "@Module(injects = { Main.class })\n"
+        + "class FooModule {\n"
+        + "  @Provides myPackage.FooImpl provideFoo() {\n"
+        + "    return new myPackage.FooImpl();\n"
+        + "  }\n"
+        + "}\n"
+    );
 
-    ASSERT.about(javaSources()).that(asList(foo, module, main))
+    assertAbout(javaSources())
+        .that(asList(foo, module, main))
         .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
         .compilesWithoutError();
   }
@@ -127,46 +135,53 @@
         "  }",
         "}"));
 
-    ASSERT.about(javaSources()).that(asList(foo, module, main))
+    assertAbout(javaSources())
+        .that(asList(foo, module, main))
         .processedWith(new FooImplGenerator())
         .compilesWithoutError();
-    ASSERT.about(javaSources()).that(asList(foo, module, main))
+    assertAbout(javaSources())
+        .that(asList(foo, module, main))
         .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
         .failsToCompile()
         .withErrorContaining("Could not find types required by provides methods for [FooModule]");
   }
 
   @Test public void withstandsMissingTypeReferencedInTransitiveJITDependency() {
-    JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
-        "import javax.inject.Inject;",
-        "import myPackage.FooImpl;",
-        "class Main {",
-        "  @Inject FooImpl f;",
-        "}"));
-    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "@Module(injects = { Main.class })",
-        "class FooModule {",
-        "}"));
+    JavaFileObject main = JavaFileObjects.forSourceString("Main", ""
+        + "import javax.inject.Inject;\n"
+        + "import myPackage.FooImpl;\n"
+        + "class Main {\n"
+        + "  @Inject FooImpl f;\n"
+        + "}\n"
+    );
+    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", ""
+        + "import dagger.Module;\n"
+        + "import dagger.Provides;\n"
+        + "@Module(injects = { Main.class })\n"
+        + "class FooModule {\n"
+        + "}\n"
+    );
 
-    ASSERT.about(javaSources()).that(asList(foo, module, main))
+    assertAbout(javaSources())
+        .that(asList(foo, module, main))
         .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
         .compilesWithoutError();
   }
 
   @Test public void verifyFooImplGeneratorIsCompilingWithoutDagger() {
-    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import myPackage.Foo;",
-        "@Module(injects = { Main.class })",
-        "class FooModule {",
-        "  @Provides Foo provideFoo(myPackage.FooImpl impl) {",
-        "    return impl;",
-        "  }",
-        "}"));
-    ASSERT.about(javaSources()).that(asList(foo, module, main))
+    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", ""
+        + "import dagger.Module;\n"
+        + "import dagger.Provides;\n"
+        + "import myPackage.Foo;\n"
+        + "@Module(injects = { Main.class })\n"
+        + "class FooModule {\n"
+        + "  @Provides Foo provideFoo(myPackage.FooImpl impl) {\n"
+        + "    return impl;\n"
+        + "  }\n"
+        + "}\n"
+    );
+    assertAbout(javaSources())
+        .that(asList(foo, module, main))
         .processedWith(new FooImplGenerator())
         .compilesWithoutError();
   }
@@ -179,21 +194,23 @@
         try {
           JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile("FooImpl");
           Writer writer = sourceFile.openWriter();
-          writer.write(Joiner.on("\n").join(
-              "package myPackage;",
-              "import javax.inject.Inject;",
-              "public final class FooImpl implements Foo {",
-              "  @Inject public FooImpl() { }",
-              "}"));
+          writer.write(""
+              + "package myPackage;\n"
+              + "import javax.inject.Inject;\n"
+              + "public final class FooImpl implements Foo {\n"
+              + "  @Inject public FooImpl() { }\n"
+              + "}\n"
+          );
           writer.close();
           sourceFile = processingEnv.getFiler().createSourceFile("FooImpl2");
           writer = sourceFile.openWriter();
-          writer.write(Joiner.on("\n").join(
-              "package myPackage;",
-              "import javax.inject.Inject;",
-              "public final class FooImpl2<T> implements Foo {",
-              "  @Inject public FooImpl2() { }",
-              "}"));
+          writer.write(""
+              + "package myPackage;\n"
+              + "import javax.inject.Inject;\n"
+              + "public final class FooImpl2<T> implements Foo {\n"
+              + "  @Inject public FooImpl2() { }\n"
+              + "}\n"
+          );
           writer.close();
           written = true;
         } catch (IOException e) {
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java b/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
index edc8816..de55a78 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/LibraryModuleTest.java
@@ -16,7 +16,6 @@
  */
 package dagger.tests.integration.validation;
 
-import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
 import java.util.Arrays;
 import javax.tools.JavaFileObject;
@@ -24,40 +23,47 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public final class LibraryModuleTest {
   @Test public void unusedProviderMethodsPassOnLibrary() {
-    JavaFileObject source = JavaFileObjects.forSourceString("Library", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import java.lang.Override;",
-        "@Module(library = true)",
-        "class TestModule {",
-        "  @Provides String string() {",
-        "    return \"string\";",
-        "  }",
-        "}"));
-    ASSERT.about(javaSource())
-        .that(source).processedWith(daggerProcessors()).compilesWithoutError();
+    JavaFileObject source = JavaFileObjects.forSourceString("Library", ""
+        + "import dagger.Module;\n"
+        + "import dagger.Provides;\n"
+        + "import java.lang.Override;\n"
+        + "@Module(library = true)\n"
+        + "class TestModule {\n"
+        + "  @Provides String string() {\n"
+        + "    return \"string\";\n"
+        + "  }\n"
+        + "}\n"
+    );
+    assertAbout(javaSource())
+        .that(source)
+        .processedWith(daggerProcessors())
+        .compilesWithoutError();
   }
 
   @Test public void unusedProviderMethodsFailOnNonLibrary() {
-    JavaFileObject source = JavaFileObjects.forSourceString("Library", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import java.lang.Override;",
-        "@Module(library = false)",
-        "class TestModule {",
-        "  @Provides String string() {",
-        "    return \"string\";",
-        "  }",
-        "}"));
-    ASSERT.about(javaSource()).that(source).processedWith(daggerProcessors()).failsToCompile()
+    JavaFileObject source = JavaFileObjects.forSourceString("Library", ""
+        + "import dagger.Module;\n"
+        + "import dagger.Provides;\n"
+        + "import java.lang.Override;\n"
+        + "@Module(library = false)\n"
+        + "class TestModule {\n"
+        + "  @Provides String string() {\n"
+        + "    return \"string\";\n"
+        + "  }\n"
+        + "}\n"
+    );
+    assertAbout(javaSource())
+        .that(source)
+        .processedWith(daggerProcessors())
+        .failsToCompile()
         .withErrorContaining("Graph validation failed:").in(source).onLine(5).and()
         .withErrorContaining("You have these unused @Provider methods:").in(source).onLine(5).and()
         .withErrorContaining("1. TestModule.string()").in(source).onLine(5).and()
@@ -66,34 +72,38 @@
 
   @Test public void injectsOfInterfaceMakesProvidesBindingNotAnOrphan() {
     JavaFileObject foo = JavaFileObjects.forSourceString("Foo", "interface Foo {}");
-    JavaFileObject module = JavaFileObjects.forSourceString("TestModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "@Module(injects = Foo.class, library = false)",
-        "class TestModule {",
-        "  @Singleton @Provides Foo provideFoo() {",
-        "    return new Foo() {};",
-        "  }",
-        "}"));
-    ASSERT.about(javaSources()).that(Arrays.asList(foo, module))
+    JavaFileObject module = JavaFileObjects.forSourceString("TestModule", ""
+        + "import dagger.Module;\n"
+        + "import dagger.Provides;\n"
+        + "import javax.inject.Singleton;\n"
+        + "@Module(injects = Foo.class, library = false)\n"
+        + "class TestModule {\n"
+        + "  @Singleton @Provides Foo provideFoo() {\n"
+        + "    return new Foo() {};\n"
+        + "  }\n"
+        + "}\n"
+    );
+    assertAbout(javaSources())
+        .that(Arrays.asList(foo, module))
         .processedWith(daggerProcessors())
         .compilesWithoutError();
   }
 
   @Test public void injectsOfClassMakesProvidesBindingNotAnOrphan() {
     JavaFileObject foo = JavaFileObjects.forSourceString("Foo", "class Foo {}");
-    JavaFileObject module = JavaFileObjects.forSourceString("TestModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "@Module(injects = Foo.class, library = false)",
-        "class TestModule {",
-        "  @Singleton @Provides Foo provideFoo() {",
-        "    return new Foo() {};",
-        "  }",
-        "}"));
-    ASSERT.about(javaSources()).that(Arrays.asList(foo, module))
+    JavaFileObject module = JavaFileObjects.forSourceString("TestModule", ""
+        + "import dagger.Module;\n"
+        + "import dagger.Provides;\n"
+        + "import javax.inject.Singleton;\n"
+        + "@Module(injects = Foo.class, library = false)\n"
+        + "class TestModule {\n"
+        + "  @Singleton @Provides Foo provideFoo() {\n"
+        + "    return new Foo() {};\n"
+        + "  }\n"
+        + "}\n"
+    );
+    assertAbout(javaSources())
+        .that(Arrays.asList(foo, module))
         .processedWith(daggerProcessors())
         .compilesWithoutError();
   }
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java b/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java
index 61b1737..54886e5 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/ScopeAnnotationUseTest.java
@@ -16,18 +16,17 @@
  */
 package dagger.tests.integration.validation;
 
-import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
 import static java.util.Arrays.asList;
-import static org.truth0.Truth.ASSERT;
 
 /**
  * Integration tests for the validation processors related to the use
@@ -45,208 +44,260 @@
   //    "Dagger will ignore scoping annotations on methods that are not @Provides methods:";
 
   @Test public void compileSucceedsScopeOnConcreteType() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import javax.inject.Inject;",
-        "import javax.inject.Singleton;",
-        "@Singleton",
-        "class Test {",
-        "  @Inject public Test() { }",
-        "}"));
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", ""
+        + "import javax.inject.Inject;\n"
+        + "import javax.inject.Singleton;\n"
+        + "@Singleton\n"
+        + "class Test {\n"
+        + "  @Inject public Test() { }\n"
+        + "}\n"
+    );
 
     // TODO(cgruber): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
-    ASSERT.about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
+    assertAbout(javaSource())
+        .that(sourceFile)
+        .processedWith(daggerProcessors())
+        .compilesWithoutError();
         //.and().hasNoWarnings();
   }
 
   @Test public void compileSucceedsScopeOnProvidesMethod() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "@Module(library = true, injects = String.class)",
-        "class Test {",
-        "  @Provides @Singleton public String provideString() { return \"\"; }",
-        "}"));
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", ""
+        + "import dagger.Module;\n"
+        + "import dagger.Provides;\n"
+        + "import javax.inject.Singleton;\n"
+        + "@Module(library = true, injects = String.class)\n"
+        + "class Test {\n"
+        + "  @Provides @Singleton public String provideString() { return \"\"; }\n"
+        + "}\n"
+    );
 
     // TODO(cgruber): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
-    ASSERT.about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
+    assertAbout(javaSource())
+        .that(sourceFile)
+        .processedWith(daggerProcessors())
+        .compilesWithoutError();
         //.and().hasNoWarnings();
   }
 
   @Test public void compileSucceedsWithScopedSuppressedNonProvidesMethod() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import javax.inject.Singleton;",
-        "class Test {",
-        "  @SuppressWarnings(\"scoping\")",
-        "  @Singleton void method() { }",
-        "}"));
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", ""
+        + "import javax.inject.Singleton;\n"
+        + "class Test {\n"
+        + "  @SuppressWarnings(\"scoping\")\n"
+        + "  @Singleton void method() { }\n"
+        + "}\n"
+    );
 
     // TODO(cgruber): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
-    ASSERT.about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
+    assertAbout(javaSource())
+        .that(sourceFile)
+        .processedWith(daggerProcessors())
+        .compilesWithoutError();
         //.and().hasNoWarnings();
   }
 
   @Test public void compileSucceedsWithScopedMultiplySuppressedNonProvidesMethod() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import javax.inject.Singleton;",
-        "class Test {",
-        "  @SuppressWarnings({\"blah\", \"scoping\", \"foo\"})",
-        "  @Singleton void method() { }",
-        "}"));
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", ""
+        + "import javax.inject.Singleton;\n"
+        + "class Test {\n"
+        + "  @SuppressWarnings({\"blah\", \"scoping\", \"foo\"})\n"
+        + "  @Singleton void method() { }\n"
+        + "}\n"
+    );
 
     // TODO(cgruber): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
-    ASSERT.about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
+    assertAbout(javaSource())
+        .that(sourceFile)
+        .processedWith(daggerProcessors())
+        .compilesWithoutError();
         //.and().hasNoWarnings();
   }
 
   @Test public void compileWarnsWithScopedNonProvidesMethod() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import javax.inject.Singleton;",
-        "class Test {",
-        "  @Singleton void method() { }",
-        "}"));
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", ""
+        + "import javax.inject.Singleton;\n"
+        + "class Test {\n"
+        + "  @Singleton void method() { }\n"
+        + "}\n"
+    );
 
     // TODO(cgruber): uncomment when http://github.com/google/compile-testing supports warnings.
-    ASSERT.about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
+    assertAbout(javaSource())
+        .that(sourceFile)
+        .processedWith(daggerProcessors())
+        .compilesWithoutError();
         //.withWarningContaining(MISUSED_SCOPE_TEXT).in(sourceFile).onLine(3).atColumn(49).and()
         //.withWarningContaining("Test.method()").in(sourceFile).onLine(3).atColumn(49);
   }
 
   @Test public void compileWarnsWithScopedIncorrectlySuppressedNonProvidesMethod() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import javax.inject.Singleton;",
-        "class Test {",
-        "  @SuppressWarnings(\"some string other than 'scoping'\")",
-        "  @Singleton void method() { }",
-        "}"));
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", ""
+        + "import javax.inject.Singleton;\n"
+        + "class Test {\n"
+        + "  @SuppressWarnings(\"some string other than 'scoping'\")\n"
+        + "  @Singleton void method() { }\n"
+        + "}\n"
+    );
 
     // TODO(cgruber): uncomment when http://github.com/google/compile-testing supports warnings.
-    ASSERT.about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
+    assertAbout(javaSource())
+        .that(sourceFile)
+        .processedWith(daggerProcessors())
+        .compilesWithoutError();
         //.withWarningContaining(MISUSED_SCOPE_TEXT).in(sourceFile).onLine(4).atColumn(49).and()
         //.withWarningContaining("Test.method()").in(sourceFile).onLine(4).atColumn(49);
   }
 
   @Test public void compileFailsWithScopeOnInterface() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import javax.inject.Singleton;",
-        "class Test {",
-        "  @Module(injects = TestType.class) class TestModule { }",
-        "  @Singleton interface TestType { }",
-        "}"));
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", ""
+        + "import dagger.Module;\n"
+        + "import javax.inject.Singleton;\n"
+        + "class Test {\n"
+        + "  @Module(injects = TestType.class) class TestModule { }\n"
+        + "  @Singleton interface TestType { }\n"
+        + "}\n"
+    );
 
-    ASSERT.about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(14).and()
-        .withErrorContaining("Test.TestType").in(sourceFile).onLine(5).atColumn(14);
+    assertAbout(javaSource())
+        .that(sourceFile)
+        .processedWith(daggerProcessors())
+        .failsToCompile()
+        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile)
+        .onLine(5).atColumn(14).and()
+        .withErrorContaining("Test.TestType")
+        .in(sourceFile).onLine(5).atColumn(14);
   }
 
   @Test public void compileFailsWithScopeOnAbstractClass() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import javax.inject.Singleton;",
-        "class Test {",
-        "  @Module(injects = TestType.class) class TestModule { }",
-        "  @Singleton abstract class TestType { }",
-        "}"));
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", ""
+        + "import dagger.Module;\n"
+        + "import javax.inject.Singleton;\n"
+        + "class Test {\n"
+        + "  @Module(injects = TestType.class) class TestModule { }\n"
+        + "  @Singleton abstract class TestType { }\n"
+        + "}\n"
+    );
 
-    ASSERT.about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(23).and()
-        .withErrorContaining("Test.TestType").in(sourceFile).onLine(5).atColumn(23);
+    assertAbout(javaSource())
+        .that(sourceFile)
+        .processedWith(daggerProcessors())
+        .failsToCompile()
+        .withErrorContaining(ABSTRACTION_SCOPING_TEXT)
+        .in(sourceFile).onLine(5).atColumn(23).and()
+        .withErrorContaining("Test.TestType")
+        .in(sourceFile).onLine(5).atColumn(23);
   }
 
   @Test public void compileFailsWithScopeOnField() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import javax.inject.Inject;",
-        "import javax.inject.Singleton;",
-        "class Test {",
-        "  @Singleton String field;",
-        "  @Inject public Test() { }",
-        "  @Module(injects = Test.class) class TestModule { }",
-        "}"));
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", ""
+        + "import dagger.Module;\n"
+        + "import javax.inject.Inject;\n"
+        + "import javax.inject.Singleton;\n"
+        + "class Test {\n"
+        + "  @Singleton String field;\n"
+        + "  @Inject public Test() { }\n"
+        + "  @Module(injects = Test.class) class TestModule { }\n"
+        + "}\n"
+    );
 
-    ASSERT.about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(21).and()
-        .withErrorContaining("Test.field").in(sourceFile).onLine(5).atColumn(21);
+    assertAbout(javaSource())
+        .that(sourceFile)
+        .processedWith(daggerProcessors())
+        .failsToCompile()
+        .withErrorContaining(ABSTRACTION_SCOPING_TEXT)
+        .in(sourceFile).onLine(5).atColumn(21).and()
+        .withErrorContaining("Test.field")
+        .in(sourceFile).onLine(5).atColumn(21);
   }
 
   @Test public void compileFailsWithScopeOnMethodParameter() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "@Module(library = true, injects = String.class)",
-        "class Test {",
-        "  @Provides int provideInteger() { return 0; }",
-        "  @Provides String provideString(@Singleton int intParam) { return \"\"; }",
-        "}"));
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", ""
+        + "import dagger.Module;\n"
+        + "import dagger.Provides;\n"
+        + "import javax.inject.Singleton;\n"
+        + "@Module(library = true, injects = String.class)\n"
+        + "class Test {\n"
+        + "  @Provides int provideInteger() { return 0; }\n"
+        + "  @Provides String provideString(@Singleton int intParam) { return \"\"; }\n"
+        + "}\n"
+    );
 
-    ASSERT.about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(7).atColumn(49).and()
-        .withErrorContaining("intParam").in(sourceFile).onLine(7).atColumn(49);
+    assertAbout(javaSource())
+        .that(sourceFile)
+        .processedWith(daggerProcessors())
+        .failsToCompile()
+        .withErrorContaining(ABSTRACTION_SCOPING_TEXT)
+        .in(sourceFile).onLine(7).atColumn(49).and()
+        .withErrorContaining("intParam")
+        .in(sourceFile).onLine(7).atColumn(49);
   }
 
   @Test public void compileFailsWithMultipleScopeAnnotations() {
-    JavaFileObject annotation = JavaFileObjects.forSourceString("MyScope", Joiner.on("\n").join(
-        "import java.lang.annotation.Retention;",
-        "import javax.inject.Scope;",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "@Scope @Retention(RUNTIME) public @interface MyScope { }"));
+    JavaFileObject annotation = JavaFileObjects.forSourceString("MyScope", ""
+        + "import java.lang.annotation.Retention;\n"
+        + "import javax.inject.Scope;\n"
+        + "import static java.lang.annotation.RetentionPolicy.RUNTIME;\n"
+        + "@Scope @Retention(RUNTIME)\n"
+        + "public @interface MyScope { }\n"
+    );
 
-    JavaFileObject module = JavaFileObjects.forSourceString("MyModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "@Module(library = true, injects = Injectable.class)",
-        "class MyModule {",
-        "  @Provides @Singleton @MyScope String method() { return \"\"; }",
-        "}"));
+    JavaFileObject module = JavaFileObjects.forSourceString("MyModule", ""
+        + "import dagger.Module;\n"
+        + "import dagger.Provides;\n"
+        + "import javax.inject.Singleton;\n"
+        + "@Module(library = true, injects = Injectable.class)\n"
+        + "class MyModule {\n"
+        + "  @Provides @Singleton @MyScope String method() { return \"\"; }\n"
+        + "}\n"
+    );
 
-    JavaFileObject injectable = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import javax.inject.Inject;",
-        "import javax.inject.Singleton;",
-        "@Singleton @MyScope",
-        "class Injectable {",
-        "  @Inject String string;",
-        "}"));
+    JavaFileObject injectable = JavaFileObjects.forSourceString("Test", ""
+        + "import javax.inject.Inject;\n"
+        + "import javax.inject.Singleton;\n"
+        + "@Singleton @MyScope\n"
+        + "class Injectable {\n"
+        + "  @Inject String string;\n"
+        + "}\n"
+    );
 
     String error = "Only one scoping annotation is allowed per element: ";
 
-    ASSERT.about(javaSources()).that(asList(annotation, module, injectable))
-        .processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining(error + "MyModule.method()").in(module).onLine(6).atColumn(40).and()
-        .withErrorContaining(error + "Injectable").in(injectable).onLine(4).atColumn(1);
+    assertAbout(javaSources())
+        .that(asList(annotation, module, injectable))
+        .processedWith(daggerProcessors())
+        .failsToCompile()
+        .withErrorContaining(error + "MyModule.method()")
+        .in(module).onLine(6).atColumn(40).and()
+        .withErrorContaining(error + "Injectable")
+        .in(injectable).onLine(4).atColumn(1);
   }
 
   @Test public void compileFailsWithScopeOnConstructor() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import javax.inject.Inject;",
-        "import javax.inject.Singleton;",
-        "class Test {",
-        "  @Singleton @Inject public Test() { }",
-        "  @Module(injects = Test.class) class TestModule { }",
-        "}"));
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", ""
+        + "import dagger.Module;\n"
+        + "import javax.inject.Inject;\n"
+        + "import javax.inject.Singleton;\n"
+        + "class Test {\n"
+        + "  @Singleton @Inject public Test() { }\n"
+        + "  @Module(injects = Test.class) class TestModule { }\n"
+        + "}\n"
+    );
 
    String singletonErrorText = ""
         + "Singleton annotations have no effect on constructors. "
         + "Did you mean to annotate the class?";
 
-    ASSERT.about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(29).and()
-        .withErrorContaining("Test.Test()").in(sourceFile).onLine(5).atColumn(29).and()
-        .withErrorContaining(singletonErrorText).in(sourceFile).onLine(6).atColumn(33);
+    assertAbout(javaSource())
+        .that(sourceFile)
+        .processedWith(daggerProcessors())
+        .failsToCompile()
+        .withErrorContaining(ABSTRACTION_SCOPING_TEXT)
+        .in(sourceFile).onLine(5).atColumn(29).and()
+        .withErrorContaining("Test.Test()")
+        .in(sourceFile).onLine(5).atColumn(29).and()
+        .withErrorContaining(singletonErrorText)
+        .in(sourceFile).onLine(6).atColumn(33);
   }
 }
 
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java
index 5dfe21f..4cb8e70 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/SimpleMissingDependencyTest.java
@@ -16,39 +16,42 @@
  */
 package dagger.tests.integration.validation;
 
-import com.google.common.base.Joiner;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
-import static org.truth0.Truth.ASSERT;
 
 @RunWith(JUnit4.class)
 public class SimpleMissingDependencyTest {
 
   @Test public void missingDependency() {
-    JavaFileObject file = JavaFileObjects.forSourceString("MissingDep", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import javax.inject.Inject;",
-        "class MissingDep {",
-        "  @Inject Dependency dep;",
-        "  static interface Dependency {",
-        "    void doit();",
-        "  }",
-        "  @Module(injects = MissingDep.class)",
-        "  static class DaModule {",
-        "    /* missing */ // @Provides Dependency a() { return new Dependency(); }",
-        "  }",
-        "}"));
+    JavaFileObject file = JavaFileObjects.forSourceString("MissingDep", ""
+        + "import dagger.Module;\n"
+        + "import javax.inject.Inject;\n"
+        + "class MissingDep {\n"
+        + "  @Inject Dependency dep;\n"
+        + "  static interface Dependency {\n"
+        + "    void doit();\n"
+        + "  }\n"
+        + "  @Module(injects = MissingDep.class)\n"
+        + "  static class DaModule {\n"
+        + "    /* missing */ // @Provides Dependency a() { return new Dependency(); }\n"
+        + "  }\n"
+        + "}\n"
+    );
 
-    ASSERT.about(javaSource())
-        .that(file).processedWith(daggerProcessors())
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(daggerProcessors())
         .failsToCompile()
-        .withErrorContaining("MissingDep$Dependency could not be bound").in(file).onLine(9).and()
-        .withErrorContaining("required by MissingDep for MissingDep.DaModule").in(file).onLine(9);
+        .withErrorContaining("MissingDep$Dependency could not be bound")
+        .in(file).onLine(9).and()
+        .withErrorContaining("required by MissingDep for MissingDep.DaModule")
+        .in(file).onLine(9);
   }
 }
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 07af929..2321d59 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -39,8 +39,8 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.easytesting</groupId>
-      <artifactId>fest-assert</artifactId>
+      <groupId>com.google.truth</groupId>
+      <artifactId>truth</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionTest.java b/core/src/test/java/dagger/ExtensionTest.java
index 06f9b86..5b2fc29 100644
--- a/core/src/test/java/dagger/ExtensionTest.java
+++ b/core/src/test/java/dagger/ExtensionTest.java
@@ -24,7 +24,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static org.fest.assertions.Assertions.assertThat;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertNotNull;
 
 @RunWith(JUnit4.class)
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java b/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
index 2a62953..7b81631 100644
--- a/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
+++ b/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
@@ -25,8 +25,8 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assertThat;
 import static dagger.Provides.Type.SET;
-import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -70,16 +70,16 @@
   @Test public void basicInjectionWithExtension() {
     ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule());
     RealSingleton rs = root.get(RealSingleton.class);
-    assertThat(rs.ints).containsOnly(0, 1);
+    assertThat(rs.ints).containsExactly(0, 1);
 
     ObjectGraph extension = root.plus(new ExtensionModule());
     Main main = extension.get(Main.class);
-    assertThat(main.ints).containsOnly(0, 1, 2, 3);
+    assertThat(main.ints).containsExactly(0, 1, 2, 3);
 
     // Second time around.
     ObjectGraph extension2 = root.plus(new ExtensionModule());
     Main main2 = extension2.get(Main.class);
-    assertThat(main2.ints).containsOnly(0, 1, 4, 5);
+    assertThat(main2.ints).containsExactly(0, 1, 4, 5);
   }
 
   @Module(includes = ExtensionModule.class, overrides = true)
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionWithStateTest.java b/core/src/test/java/dagger/ExtensionWithStateTest.java
index ff35e2a..31af585 100644
--- a/core/src/test/java/dagger/ExtensionWithStateTest.java
+++ b/core/src/test/java/dagger/ExtensionWithStateTest.java
@@ -22,7 +22,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static org.fest.assertions.Assertions.assertThat;
+import static com.google.common.truth.Truth.assertThat;
 
 @RunWith(JUnit4.class)
 public final class ExtensionWithStateTest {
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index ef5b275..b3c7b11 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -33,7 +33,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static org.fest.assertions.Assertions.assertThat;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
/Fim/
diff --git a/core/src/test/java/dagger/LazyInjectionTest.java b/core/src/test/java/dagger/LazyInjectionTest.java
index ee6f6f6..a1175de 100644
--- a/core/src/test/java/dagger/LazyInjectionTest.java
+++ b/core/src/test/java/dagger/LazyInjectionTest.java
@@ -21,7 +21,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static org.fest.assertions.Assertions.assertThat;
+import static com.google.common.truth.Truth.assertThat;
 
 @RunWith(JUnit4.class)
 public final class LazyInjectionTest {
/Fim/
diff --git a/core/src/test/java/dagger/MembersInjectorTest.java b/core/src/test/java/dagger/MembersInjectorTest.java
index 5a0197f..00072f0 100644
--- a/core/src/test/java/dagger/MembersInjectorTest.java
+++ b/core/src/test/java/dagger/MembersInjectorTest.java
@@ -23,7 +23,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static org.fest.assertions.Assertions.assertThat;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
 /**
@@ -216,4 +216,4 @@
     entryPoint.membersInjector.injectMembers(membersInjected);
     assertThat(membersInjected.value).isEqualTo("members");
   }
-}
\ No newline at end of file
+}
/Fim/
diff --git a/core/src/test/java/dagger/ModuleTest.java b/core/src/test/java/dagger/ModuleTest.java
index 19ec9eb..827e43c 100644
--- a/core/src/test/java/dagger/ModuleTest.java
+++ b/core/src/test/java/dagger/ModuleTest.java
@@ -22,7 +22,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static org.fest.assertions.Assertions.assertThat;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
 //TODO: Migrate to compiler.
@@ -196,9 +196,8 @@
       ObjectGraph.createWith(new TestingLoader(), new ProvidesProviderModule());
       fail();
     } catch (IllegalStateException e) {
-      assertThat(e.getMessage()) //
-          .startsWith("@Provides method must not return Provider directly: ")
-          .endsWith("ProvidesProviderModule.provideObject");
+      assertThat(e.getMessage()).startsWith("@Provides method must not return Provider directly: ");
+      assertThat(e.getMessage()).endsWith("ProvidesProviderModule.provideObject");
     }
   }
 
@@ -213,9 +212,8 @@
       ObjectGraph.createWith(new TestingLoader(), new ProvidesRawProviderModule());
       fail();
     } catch (IllegalStateException e) {
-      assertThat(e.getMessage()) //
-          .startsWith("@Provides method must not return Provider directly: ")
-          .endsWith("ProvidesRawProviderModule.provideObject");
+      assertThat(e.getMessage()).startsWith("@Provides method must not return Provider directly: ");
+      assertThat(e.getMessage()).endsWith("ProvidesRawProviderModule.provideObject");
     }
   }
 
@@ -230,9 +228,8 @@
       ObjectGraph.createWith(new TestingLoader(), new ProvidesLazyModule());
       fail();
     } catch (IllegalStateException e) {
-      assertThat(e.getMessage()) //
-          .startsWith("@Provides method must not return Lazy directly: ")
-          .endsWith("ProvidesLazyModule.provideObject");
+      assertThat(e.getMessage()).startsWith("@Provides method must not return Lazy directly: ");
+      assertThat(e.getMessage()).endsWith("ProvidesLazyModule.provideObject");
     }
   }
 
@@ -247,9 +244,8 @@
       ObjectGraph.createWith(new TestingLoader(), new ProvidesRawLazyModule());
       fail();
     } catch (IllegalStateException e) {
-      assertThat(e.getMessage()) //
-          .startsWith("@Provides method must not return Lazy directly: ")
-          .endsWith("ProvidesRawLazyModule.provideObject");
+      assertThat(e.getMessage()).startsWith("@Provides method must not return Lazy directly: ");
+      assertThat(e.getMessage()).endsWith("ProvidesRawLazyModule.provideObject");
     }
   }
 }
/Fim/
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index 6a02906..c94c983 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -31,10 +31,10 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assertThat;
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
 import static java.util.Collections.emptySet;
-import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
@@ -222,7 +222,7 @@
     }
 
     TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
-    assertThat(ep.strings).containsOnly("a", "b");
+    assertThat(ep.strings).containsExactly("a", "b");
   }
 
   @Test public void validateSetBinding() {
/Fim/
diff --git a/core/src/test/java/dagger/ThreadSafetyTest.java b/core/src/test/java/dagger/ThreadSafetyTest.java
index ba4986d..1f5fd1a 100644
--- a/core/src/test/java/dagger/ThreadSafetyTest.java
+++ b/core/src/test/java/dagger/ThreadSafetyTest.java
@@ -32,7 +32,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static org.fest.assertions.Assertions.assertThat;
+import static com.google.common.truth.Truth.assertThat;
 
 /**
  * Test Singleton and Lazy bindings for thread-safety.
@@ -87,7 +87,7 @@
     latch.countDown();
     for (Future<Long> future : futures) {
       assertThat(future.get(1, TimeUnit.SECONDS))
-          .overridingErrorMessage("Lock failure - count should never increment")
+          .named("Lock failure - count should never increment")
           .isEqualTo(0);
     }
   }
@@ -108,7 +108,7 @@
     latch.countDown();
     for (Future<Integer> future : futures) {
       assertThat(future.get(1, TimeUnit.SECONDS))
-          .overridingErrorMessage("Lock failure - count should never increment")
+          .named("Lock failure - count should never increment")
           .isEqualTo(0);
     }
   }
/Fim/
diff --git a/core/src/test/java/dagger/internal/FailoverLoaderTest.java b/core/src/test/java/dagger/internal/FailoverLoaderTest.java
index 5cde6a6..7721159 100644
--- a/core/src/test/java/dagger/internal/FailoverLoaderTest.java
+++ b/core/src/test/java/dagger/internal/FailoverLoaderTest.java
@@ -24,7 +24,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static org.fest.assertions.Assertions.assertThat;
+import static com.google.common.truth.Truth.assertThat;
 
 /**
  * A test case to deal with fall-back to reflection where the concrete type has been generated
/Fim/
diff --git a/core/src/test/java/dagger/internal/KeysTest.java b/core/src/test/java/dagger/internal/KeysTest.java
index d012560..1ac9ca4 100644
--- a/core/src/test/java/dagger/internal/KeysTest.java
+++ b/core/src/test/java/dagger/internal/KeysTest.java
@@ -28,8 +28,8 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assertThat;
 import static dagger.Provides.Type.SET;
-import static org.fest.assertions.Assertions.assertThat;
 
 @RunWith(JUnit4.class)
 public final class KeysTest {
/Fim/
diff --git a/core/src/test/java/dagger/internal/SingletonBindingTest.java b/core/src/test/java/dagger/internal/SingletonBindingTest.java
index 515a2eb..3b265ca 100644
--- a/core/src/test/java/dagger/internal/SingletonBindingTest.java
+++ b/core/src/test/java/dagger/internal/SingletonBindingTest.java
@@ -20,7 +20,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
-import static org.fest.assertions.Assertions.assertThat;
+
+import static com.google.common.truth.Truth.assertThat;
 
 @RunWith(JUnit4.class)
 public final class SingletonBindingTest {
/Fim/
diff --git a/pom.xml b/pom.xml
index a65dd3f..855e4a3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -44,13 +44,12 @@
     <java.version>1.6</java.version>
     <javax.inject.version>1</javax.inject.version>
     <javapoet.version>1.4.0</javapoet.version>
-    <guava.version>18.0</guava.version>
+    <guava.version>19.0</guava.version>
 
     <!-- Test Dependencies -->
-    <junit.version>4.10</junit.version>
-    <fest.version>1.4</fest.version>
-    <truth.version>0.13</truth.version>
-    <compile-testing.version>0.4</compile-testing.version>
+    <junit.version>4.12</junit.version>
+    <truth.version>0.28</truth.version>
+    <compile-testing.version>0.8</compile-testing.version>
     <mockito.version>1.10.19</mockito.version>
   </properties>
 
@@ -111,7 +110,7 @@
         <version>${compile-testing.version}</version>
       </dependency>
       <dependency>
-        <groupId>org.truth0</groupId>
+        <groupId>com.google.truth</groupId>
         <artifactId>truth</artifactId>
         <version>${truth.version}</version>
       </dependency>
/Fim/
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index d799002..edcb27b 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -25,7 +25,7 @@
 
 /**
  * Annotates methods of a module to create a provider method binding. The
- * method's return type is bound to it's returned value. The object graph will
+ * method's return type is bound to its returned value. The object graph will
  * pass dependencies to the method as parameters.
  *
  * @author Bob Lee
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 2321d59..1c00f9e 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -48,6 +48,24 @@
   <build>
     <plugins>
       <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>1.8</version><!-- 1.9+ requires JDK7 -->
+        <executions>
+          <execution>
+            <id>sniff-api</id>
+            <goals><goal>check</goal></goals>
+          </execution>
+        </executions>
+        <configuration>
+          <signature>
+            <groupId>org.codehaus.mojo.signature</groupId>
+            <artifactId>java15</artifactId>
+            <version>1.0</version>
+          </signature>
+        </configuration>
+      </plugin>
+      <plugin>
         <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
           <excludePackageNames>dagger.internal:dagger.internal.*</excludePackageNames>
/Fim/
diff --git a/core/src/main/java/dagger/internal/ArrayQueue.java b/core/src/main/java/dagger/internal/ArrayQueue.java
new file mode 100644
index 0000000..690b6d9
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ArrayQueue.java
@@ -0,0 +1,607 @@
+/*
+ * Written by Josh Bloch of Google Inc. and released to the public domain,
+ * as explained at http://creativecommons.org/publicdomain/zero/1.0/.
+ *
+ * Adapted from https://android.googlesource.com/platform/libcore/+
+ *     android-4.2.2_r1/luni/src/main/java/java/util/ArrayDeque.java
+ */
+package dagger.internal;
+
+import java.lang.reflect.Array;
+import java.util.AbstractCollection;
+import java.util.Collection;
+import java.util.ConcurrentModificationException;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.Queue;
+
+/**
+ * Resizable-array implementation of the {@link Queue} interface.  Array
+ * queues have no capacity restrictions; they grow as necessary to support
+ * usage.  They are not thread-safe; in the absence of external
+ * synchronization, they do not support concurrent access by multiple threads.
+ * Null elements are prohibited.  This class is likely to be faster than
+ * {@link LinkedList} when used as a queue.
+ *
+ * <p>Most <tt>ArrayBackedQueue</tt> operations run in amortized constant time.
+ * Exceptions include {@link #remove(Object) remove}, {@link
+ * #removeFirstOccurrence removeFirstOccurrence}, {@link #contains contains},
+ * {@link #iterator iterator.remove()}, and the bulk operations, all of which
+ * run in linear time.
+ *
+ * <p>The iterators returned by this class's <tt>iterator</tt> method are
+ * <i>fail-fast</i>: If the queue is modified at any time after the iterator
+ * is created, in any way except through the iterator's own <tt>remove</tt>
+ * method, the iterator will generally throw a {@link
+ * ConcurrentModificationException}.  Thus, in the face of concurrent
+ * modification, the iterator fails quickly and cleanly, rather than risking
+ * arbitrary, non-deterministic behavior at an undetermined time in the
+ * future.
+ *
+ * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed
+ * as it is, generally speaking, impossible to make any hard guarantees in the
+ * presence of unsynchronized concurrent modification.  Fail-fast iterators
+ * throw <tt>ConcurrentModificationException</tt> on a best-effort basis.
+ * Therefore, it would be wrong to write a program that depended on this
+ * exception for its correctness: <i>the fail-fast behavior of iterators
+ * should be used only to detect bugs.</i>
+ *
+ * <p>This class and its iterator implement all of the
+ * <em>optional</em> methods of the {@link Collection} and {@link
+ * Iterator} interfaces.
+ *
+ * @author  Josh Bloch and Doug Lea
+ * @param <E> the type of elements held in this collection
+ */
+public class ArrayQueue<E> extends AbstractCollection<E>
+                           implements Queue<E>, Cloneable, java.io.Serializable {
+    /**
+     * The array in which the elements of the queue are stored.
+     * The capacity of the queue is the length of this array, which is
+     * always a power of two. The array is never allowed to become
+     * full, except transiently within an addX method where it is
+     * resized (see doubleCapacity) immediately upon becoming full,
+     * thus avoiding head and tail wrapping around to equal each
+     * other.  We also guarantee that all array cells not holding
+     * queue elements are always null.
+     */
+    private transient Object[] elements;
+
+    /**
+     * The index of the element at the head of the queue (which is the
+     * element that would be removed by remove() or pop()); or an
+     * arbitrary number equal to tail if the queue is empty.
+     */
+    private transient int head;
+
+    /**
+     * The index at which the next element would be added to the tail
+     * of the queue (via addLast(E), add(E), or push(E)).
+     */
+    private transient int tail;
+
+    /**
+     * The minimum capacity that we'll use for a newly created queue.
+     * Must be a power of 2.
+     */
+    private static final int MIN_INITIAL_CAPACITY = 8;
+
+    // ******  Array allocation and resizing utilities ******
+
+    /**
+     * Allocate empty array to hold the given number of elements.
+     *
+     * @param numElements  the number of elements to hold
+     */
+    private void allocateElements(int numElements) {
+        int initialCapacity = MIN_INITIAL_CAPACITY;
+        // Find the best power of two to hold elements.
+        // Tests "<=" because arrays aren't kept full.
+        if (numElements >= initialCapacity) {
+            initialCapacity = numElements;
+            initialCapacity |= (initialCapacity >>>  1);
+            initialCapacity |= (initialCapacity >>>  2);
+            initialCapacity |= (initialCapacity >>>  4);
+            initialCapacity |= (initialCapacity >>>  8);
+            initialCapacity |= (initialCapacity >>> 16);
+            initialCapacity++;
+
+            if (initialCapacity < 0)   // Too many elements, must back off
+                initialCapacity >>>= 1; // Good luck allocating 2 ^ 30 elements
+        }
+        elements = new Object[initialCapacity];
+    }
+
+    /**
+     * Double the capacity of this queue.  Call only when full, i.e.,
+     * when head and tail have wrapped around to become equal.
+     */
+    private void doubleCapacity() {
+        // assert head == tail;
+        int p = head;
+        int n = elements.length;
+        int r = n - p; // number of elements to the right of p
+        int newCapacity = n << 1;
+        if (newCapacity < 0)
+            throw new IllegalStateException("Sorry, queue too big");
+        Object[] a = new Object[newCapacity];
+        System.arraycopy(elements, p, a, 0, r);
+        System.arraycopy(elements, 0, a, r, p);
+        elements = a;
+        head = 0;
+        tail = n;
+    }
+
+    /**
+     * Constructs an empty array queue with an initial capacity
+     * sufficient to hold 16 elements.
+     */
+    public ArrayQueue() {
+        elements = new Object[16];
+    }
+
+    /**
+     * Constructs an empty array queue with an initial capacity
+     * sufficient to hold the specified number of elements.
+     *
+     * @param numElements  lower bound on initial capacity of the queue
+     */
+    public ArrayQueue(int numElements) {
+        allocateElements(numElements);
+    }
+
+    /**
+     * Constructs a queue containing the elements of the specified
+     * collection, in the order they are returned by the collection's
+     * iterator.  (The first element returned by the collection's
+     * iterator becomes the first element, or <i>front</i> of the
+     * queue.)
+     *
+     * @param c the collection whose elements are to be placed into the queue
+     * @throws NullPointerException if the specified collection is null
+     */
+    public ArrayQueue(Collection<? extends E> c) {
+        allocateElements(c.size());
+        addAll(c);
+    }
+
+    /**
+     * Inserts the specified element at the end of this queue.
+     *
+     * <p>This method is equivalent to {@link #offer}.
+     *
+     * @param e the element to add
+     * @return <tt>true</tt> (as specified by {@link Collection#add})
+     * @throws NullPointerException if the specified element is null
+     */
+    @Override
+    public boolean add(E e) {
+        if (e == null)
+            throw new NullPointerException("e == null");
+        elements[tail] = e;
+        if ((tail = (tail + 1) & (elements.length - 1)) == head)
+            doubleCapacity();
+        return true;
+    }
+
+    /**
+     * Inserts the specified element at the end of this queue.
+     *
+     * @param e the element to add
+     * @return <tt>true</tt> (as specified by {@link Queue#offer})
+     * @throws NullPointerException if the specified element is null
+     */
+    @Override
+    public boolean offer(E e) {
+        return add(e);
+    }
+
+    /**
+     * Retrieves and removes the head of the queue represented by this queue.
+     *
+     * This method differs from {@link #poll poll} only in that it throws an
+     * exception if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue
+     * @throws NoSuchElementException {@inheritDoc}
+     */
+    @Override
+    public E remove() {
+        E x = poll();
+        if (x == null)
+            throw new NoSuchElementException();
+        return x;
+    }
+
+    /**
+     * Retrieves and removes the head of the queue represented by this queue
+     * (in other words, the first element of this queue), or returns
+     * <tt>null</tt> if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue, or
+     *         <tt>null</tt> if this queue is empty
+     */
+    @Override
+    public E poll() {
+        int h = head;
+        @SuppressWarnings("unchecked") E result = (E) elements[h];
+        // Element is null if queue empty
+        if (result == null)
+            return null;
+        elements[h] = null;     // Must null out slot
+        head = (h + 1) & (elements.length - 1);
+        return result;
+    }
+
+    /**
+     * Retrieves, but does not remove, the head of the queue represented by
+     * this queue.  This method differs from {@link #peek peek} only in
+     * that it throws an exception if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue
+     * @throws NoSuchElementException {@inheritDoc}
+     */
+    @Override
+    public E element() {
+        @SuppressWarnings("unchecked") E result = (E) elements[head];
+        if (result == null)
+            throw new NoSuchElementException();
+        return result;
+    }
+
+    /**
+     * Retrieves, but does not remove, the head of the queue represented by
+     * this queue, or returns <tt>null</tt> if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue, or
+     *         <tt>null</tt> if this queue is empty
+     */
+    @Override
+    public E peek() {
+        @SuppressWarnings("unchecked") E result = (E) elements[head];
+        // elements[head] is null if queue empty
+        return result;
+    }
+
+    /**
+     * Removes the element at the specified position in the elements array,
+     * adjusting head and tail as necessary.  This can result in motion of
+     * elements backwards or forwards in the array.
+     *
+     * <p>This method is called delete rather than remove to emphasize
+     * that its semantics differ from those of {@link List#remove(int)}.
+     *
+     * @return true if elements moved backwards
+     */
+    private boolean delete(int i) {
+        //checkInvariants();
+        final Object[] elements = this.elements;
+        final int mask = elements.length - 1;
+        final int h = head;
+        final int t = tail;
+        final int front = (i - h) & mask;
+        final int back  = (t - i) & mask;
+
+        // Invariant: head <= i < tail mod circularity
+        if (front >= ((t - h) & mask))
+            throw new ConcurrentModificationException();
+
+        // Optimize for least element motion
+        if (front < back) {
+            if (h <= i) {
+                System.arraycopy(elements, h, elements, h + 1, front);
+            } else { // Wrap around
+                System.arraycopy(elements, 0, elements, 1, i);
+                elements[0] = elements[mask];
+                System.arraycopy(elements, h, elements, h + 1, mask - h);
+            }
+            elements[h] = null;
+            head = (h + 1) & mask;
+            return false;
+        } else {
+            if (i < t) { // Copy the null tail as well
+                System.arraycopy(elements, i + 1, elements, i, back);
+                tail = t - 1;
+            } else { // Wrap around
+                System.arraycopy(elements, i + 1, elements, i, mask - i);
+                elements[mask] = elements[0];
+                System.arraycopy(elements, 1, elements, 0, t);
+                tail = (t - 1) & mask;
+            }
+            return true;
+        }
+    }
+
+    // *** Collection Methods ***
+
+    /**
+     * Returns the number of elements in this queue.
+     *
+     * @return the number of elements in this queue
+     */
+    @Override
+    public int size() {
+        return (tail - head) & (elements.length - 1);
+    }
+
+    /**
+     * Returns <tt>true</tt> if this queue contains no elements.
+     *
+     * @return <tt>true</tt> if this queue contains no elements
+     */
+    @Override
+    public boolean isEmpty() {
+        return head == tail;
+    }
+
+    /**
+     * Returns an iterator over the elements in this queue.  The elements
+     * will be ordered from first (head) to last (tail).  This is the same
+     * order that elements would be queueued (via successive calls to
+     * {@link #remove} or popped (via successive calls to {@link #pop}).
+     *
+     * @return an iterator over the elements in this queue
+     */
+    @Override
+    public Iterator<E> iterator() {
+        return new QueueIterator();
+    }
+
+
+    private class QueueIterator implements Iterator<E> {
+        /**
+         * Index of element to be returned by subsequent call to next.
+         */
+        private int cursor = head;
+
+        /**
+         * Tail recorded at construction (also in remove), to stop
+         * iterator and also to check for comodification.
+         */
+        private int fence = tail;
+
+        /**
+         * Index of element returned by most recent call to next.
+         * Reset to -1 if element is deleted by a call to remove.
+         */
+        private int lastRet = -1;
+
+        @Override
+        public boolean hasNext() {
+            return cursor != fence;
+        }
+
+        @Override
+        public E next() {
+            if (cursor == fence)
+                throw new NoSuchElementException();
+            @SuppressWarnings("unchecked") E result = (E) elements[cursor];
+            // This check doesn't catch all possible comodifications,
+            // but does catch the ones that corrupt traversal
+            if (tail != fence || result == null)
+                throw new ConcurrentModificationException();
+            lastRet = cursor;
+            cursor = (cursor + 1) & (elements.length - 1);
+            return result;
+        }
+
+        @Override
+        public void remove() {
+            if (lastRet < 0)
+                throw new IllegalStateException();
+            if (delete(lastRet)) { // if left-shifted, undo increment in next()
+                cursor = (cursor - 1) & (elements.length - 1);
+                fence = tail;
+            }
+            lastRet = -1;
+        }
+    }
+
+    /**
+     * Returns <tt>true</tt> if this queue contains the specified element.
+     * More formally, returns <tt>true</tt> if and only if this queue contains
+     * at least one element <tt>e</tt> such that <tt>o.equals(e)</tt>.
+     *
+     * @param o object to be checked for containment in this queue
+     * @return <tt>true</tt> if this queue contains the specified element
+     */
+    @Override
+    public boolean contains(Object o) {
+        if (o == null)
+            return false;
+        int mask = elements.length - 1;
+        int i = head;
+        Object x;
+        while ((x = elements[i]) != null) {
+            if (o.equals(x))
+                return true;
+            i = (i + 1) & mask;
+        }
+        return false;
+    }
+
+    /**
+     * Removes a single instance of the specified element from this queue.
+     * If the queue does not contain the element, it is unchanged.
+     * More formally, removes the first element <tt>e</tt> such that
+     * <tt>o.equals(e)</tt> (if such an element exists).
+     * Returns <tt>true</tt> if this queue contained the specified element
+     * (or equivalently, if this queue changed as a result of the call).
+     *
+     * @param o element to be removed from this queue, if present
+     * @return <tt>true</tt> if this queue contained the specified element
+     */
+    @Override
+    public boolean remove(Object o) {
+        if (o == null)
+            return false;
+        int mask = elements.length - 1;
+        int i = head;
+        Object x;
+        while ((x = elements[i]) != null) {
+            if (o.equals(x)) {
+                delete(i);
+                return true;
+            }
+            i = (i + 1) & mask;
+        }
+        return false;
+    }
+
+    /**
+     * Removes all of the elements from this queue.
+     * The queue will be empty after this call returns.
+     */
+    @Override
+    public void clear() {
+        int h = head;
+        int t = tail;
+        if (h != t) { // clear all cells
+            head = tail = 0;
+            int i = h;
+            int mask = elements.length - 1;
+            do {
+                elements[i] = null;
+                i = (i + 1) & mask;
+            } while (i != t);
+        }
+    }
+
+    /**
+     * Returns an array containing all of the elements in this queue
+     * in proper sequence (from first to last element).
+     *
+     * <p>The returned array will be "safe" in that no references to it are
+     * maintained by this queue.  (In other words, this method must allocate
+     * a new array).  The caller is thus free to modify the returned array.
+     *
+     * <p>This method acts as bridge between array-based and collection-based
+     * APIs.
+     *
+     * @return an array containing all of the elements in this queue
+     */
+    @Override
+    public Object[] toArray() {
+        return toArray(new Object[size()]);
+    }
+
+    /**
+     * Returns an array containing all of the elements in this queue in
+     * proper sequence (from first to last element); the runtime type of the
+     * returned array is that of the specified array.  If the queue fits in
+     * the specified array, it is returned therein.  Otherwise, a new array
+     * is allocated with the runtime type of the specified array and the
+     * size of this queue.
+     *
+     * <p>If this queue fits in the specified array with room to spare
+     * (i.e., the array has more elements than this queue), the element in
+     * the array immediately following the end of the queue is set to
+     * <tt>null</tt>.
+     *
+     * <p>Like the {@link #toArray()} method, this method acts as bridge between
+     * array-based and collection-based APIs.  Further, this method allows
+     * precise control over the runtime type of the output array, and may,
+     * under certain circumstances, be used to save allocation costs.
+     *
+     * <p>Suppose <tt>x</tt> is a queue known to contain only strings.
+     * The following code can be used to dump the queue into a newly
+     * allocated array of <tt>String</tt>:
+     *
+     *  <pre> {@code String[] y = x.toArray(new String[0]);}</pre>
+     *
+     * Note that <tt>toArray(new Object[0])</tt> is identical in function to
+     * <tt>toArray()</tt>.
+     *
+     * @param a the array into which the elements of the queue are to
+     *          be stored, if it is big enough; otherwise, a new array of the
+     *          same runtime type is allocated for this purpose
+     * @return an array containing all of the elements in this queue
+     * @throws ArrayStoreException if the runtime type of the specified array
+     *         is not a supertype of the runtime type of every element in
+     *         this queue
+     * @throws NullPointerException if the specified array is null
+     */
+    @Override
+    public <T> T[] toArray(T[] a) {
+        int size = size();
+        if (a.length < size)
+            a = (T[]) java.lang.reflect.Array.newInstance(
+                    a.getClass().getComponentType(), size);
+        if (head < tail) {
+            System.arraycopy(elements, head, a, 0, size());
+        } else if (head > tail) {
+            int headPortionLen = elements.length - head;
+            System.arraycopy(elements, head, a, 0, headPortionLen);
+            System.arraycopy(elements, 0, a, headPortionLen, tail);
+        }
+        if (a.length > size)
+            a[size] = null;
+        return a;
+    }
+
+    // *** Object methods ***
+
+    /**
+     * Returns a copy of this queue.
+     *
+     * @return a copy of this queue
+     */
+    @Override
+    public ArrayQueue<E> clone() {
+        try {
+            ArrayQueue<E> result = (ArrayQueue<E>) super.clone();
+            E[] newElements = (E[]) Array.newInstance(elements.getClass().getComponentType(),
+                elements.length);
+            System.arraycopy(elements, 0, newElements, 0, elements.length);
+            result.elements = newElements;
+            return result;
+        } catch (CloneNotSupportedException e) {
+            throw new AssertionError();
+        }
+    }
+
+    /**
+     * Appease the serialization gods.
+     */
+    private static final long serialVersionUID = 2340985798034038923L;
+
+    /**
+     * Serialize this queue.
+     *
+     * @serialData The current size (<tt>int</tt>) of the queue,
+     * followed by all of its elements (each an object reference) in
+     * first-to-last order.
+     */
+    private void writeObject(java.io.ObjectOutputStream s)
+            throws java.io.IOException {
+        s.defaultWriteObject();
+
+        // Write out size
+        s.writeInt(size());
+
+        // Write out elements in order.
+        int mask = elements.length - 1;
+        for (int i = head; i != tail; i = (i + 1) & mask)
+            s.writeObject(elements[i]);
+    }
+
+    /**
+     * Deserialize this queue.
+     */
+    private void readObject(java.io.ObjectInputStream s)
+            throws java.io.IOException, ClassNotFoundException {
+        s.defaultReadObject();
+
+        // Read in size and allocate array
+        int size = s.readInt();
+        allocateElements(size);
+        head = 0;
+        tail = size;
+
+        // Read in all elements in the proper order.
+        for (int i = 0; i < size; i++)
+            elements[i] = s.readObject();
+    }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index e88ffce..b5cf55e 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -16,13 +16,12 @@
 package dagger.internal;
 
 import dagger.internal.Binding.InvalidBindingException;
-import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Deque;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
 import java.util.Set;
 
 /**
@@ -39,7 +38,7 @@
   private final Linker base;
 
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
-  private final Deque<Binding<?>> toLink = new ArrayDeque<Binding<?>>();
+  private final Queue<Binding<?>> toLink = new ArrayQueue<Binding<?>>();
 
   /** True unless calls to requestBinding() were unable to satisfy the binding. */
   private boolean attachSuccess = true;
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 3545ffb..385428d 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.3.0-SNAPSHOT</version>
+    <version>1.2.3-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 1c00f9e..18a15ce 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.3.0-SNAPSHOT</version>
+    <version>1.2.3-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index ff785ab..9b239b0 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.3.0-SNAPSHOT</version>
+    <version>1.2.3-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index f2eb769..0cc0591 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.3.0-SNAPSHOT</version>
+    <version>1.2.3-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index b2376a2..a0fe83b 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.3.0-SNAPSHOT</version>
+    <version>1.2.3-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 767bce3..54ba98e 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.3.0-SNAPSHOT</version>
+    <version>1.2.3-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index 855e4a3..cea95f3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.3.0-SNAPSHOT</version>
+  <version>1.2.3-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
/Fim/
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 40dc58d..8644fff 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,16 @@
 Change Log
 ==========
 
+Version 1.2.3 *(2016-05-02)*
+----------------------------
+
+ * Fix: Correct detection of module base classes. This previously erroneously failed compilation
+   on modules which extended from `Object` but were not detected as such.
+ * Fix: Allow the use of dollar signs in processed class names.
+ * Fix: Remove the need for `javac` to generate synthetic accessor methods for internal classes.
+ * Fix: Error when duplicate classes are listed in `injects=` or `includes=` lists.
+
+
 Version 1.2.2 *(2014-07-21)*
 ----------------------------
 
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 385428d..3587f57 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.3-SNAPSHOT</version>
+    <version>1.2.3</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 18a15ce..4434422 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.3-SNAPSHOT</version>
+    <version>1.2.3</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 9b239b0..a7fc1fe 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.3-SNAPSHOT</version>
+    <version>1.2.3</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 0cc0591..bb34fb2 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.3-SNAPSHOT</version>
+    <version>1.2.3</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index a0fe83b..e547a20 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.3-SNAPSHOT</version>
+    <version>1.2.3</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 54ba98e..87c8578 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.3-SNAPSHOT</version>
+    <version>1.2.3</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index 4c1ee48..c0d655f 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.2.3-SNAPSHOT</version>
+  <version>1.2.3</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -57,7 +57,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>HEAD</tag>
+    <tag>dagger-parent-1.2.3</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 3587f57..8901c97 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.3</version>
+    <version>1.2.4-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 4434422..3e47082 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.3</version>
+    <version>1.2.4-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index a7fc1fe..b0c48a7 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.3</version>
+    <version>1.2.4-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index bb34fb2..6f65084 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.3</version>
+    <version>1.2.4-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index e547a20..5d8ef1a 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.3</version>
+    <version>1.2.4-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 87c8578..8077a9b 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.3</version>
+    <version>1.2.4-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index c0d655f..ea932e4 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.2.3</version>
+  <version>1.2.4-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -57,7 +57,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>dagger-parent-1.2.3</tag>
+    <tag>HEAD</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/compiler/src/it/static-injected-binding-doesnt-fail-providers/pom.xml b/compiler/src/it/static-injected-binding-doesnt-fail-providers/pom.xml
new file mode 100644
index 0000000..b93d3bf
--- /dev/null
+++ b/compiler/src/it/static-injected-binding-doesnt-fail-providers/pom.xml
@@ -0,0 +1,52 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.squareup.dagger.tests</groupId>
+  <artifactId>static-injected-binding-doesnt-fail-providers</artifactId>
+  <version>@dagger.version@</version>
+  <packaging>jar</packaging>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/static-injected-binding-doesnt-fail-providers/src/main/java/test/Test.java b/compiler/src/it/static-injected-binding-doesnt-fail-providers/src/main/java/test/Test.java
new file mode 100644
index 0000000..450f794
--- /dev/null
+++ b/compiler/src/it/static-injected-binding-doesnt-fail-providers/src/main/java/test/Test.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+
+import dagger.ObjectGraph;
+import dagger.Provides;
+import javax.inject.Inject;
+
+import java.lang.Override;
+
+public class Test {
+
+  public static class InjectsOneField {
+    @Inject static String staticallyInjectedString;
+  }
+
+  @Module(staticInjections = { InjectsOneField.class })
+  public static class TestModule {
+    @Provides String string() {
+      return "string";
+    }
+  }
+}
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index 13878c9..d009f75 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -164,6 +164,8 @@
       boolean ignoreCompletenessErrors) {
     Map<String, TypeElement> allModules = new LinkedHashMap<String, TypeElement>();
     collectIncludesRecursively(rootModule, allModules, new LinkedList<String>());
+    ArrayList<GraphAnalysisStaticInjection> staticInjections =
+        new ArrayList<GraphAnalysisStaticInjection>();
 
     Linker.ErrorHandler errorHandler = ignoreCompletenessErrors ? Linker.ErrorHandler.NULL
         : new GraphAnalysisErrorHandler(processingEnv, rootModule.getQualifiedName().toString());
@@ -201,6 +203,13 @@
               getClass().getClassLoader(), false, true);
         }
 
+        // Gather the static injections.
+        for (Object staticInjection : (Object[]) annotation.get("staticInjections")) {
+          TypeMirror staticInjectionTypeMirror = (TypeMirror) staticInjection;
+          Element element = processingEnv.getTypeUtils().asElement(staticInjectionTypeMirror);
+          staticInjections.add(new GraphAnalysisStaticInjection(element));
+        }
+
         // Gather the enclosed @Provides methods.
         for (Element enclosed : module.getEnclosedElements()) {
           Provides provides = enclosed.getAnnotation(Provides.class);
@@ -255,6 +264,9 @@
 
       linker.installBindings(baseBindings);
       linker.installBindings(overrideBindings);
+      for (GraphAnalysisStaticInjection staticInjection : staticInjections) {
+        staticInjection.attach(linker);
+      }
 
       // Link the bindings. This will traverse the dependency graph, and report
       // errors if any dependencies are missing.
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
index 442d493..5248663 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
@@ -22,8 +22,10 @@
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeSpec;
+import dagger.ObjectGraph;
 import dagger.internal.Binding;
 import dagger.internal.Linker;
+import dagger.internal.StaticInjection;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -58,6 +60,7 @@
 import static dagger.internal.codegen.Util.isCallableConstructor;
 import static dagger.internal.codegen.Util.rawTypeToString;
 import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -84,7 +87,8 @@
       boolean missingDependentClasses =
           !allTypesExist(injectedClass.fields)
           || (injectedClass.constructor != null && !allTypesExist(injectedClass.constructor
-              .getParameters()));
+              .getParameters()))
+          || !allTypesExist(injectedClass.staticFields);
       if (!missingDependentClasses) {
         try {
           generateInjectionsForClass(injectedClass);
@@ -105,6 +109,9 @@
     if (injectedClass.constructor != null || !injectedClass.fields.isEmpty()) {
       generateInjectAdapter(injectedClass.type, injectedClass.constructor, injectedClass.fields);
     }
+    if (!injectedClass.staticFields.isEmpty()) {
+      generateStaticInjection(injectedClass.type, injectedClass.staticFields);
+    }
   }
 
   /**
@@ -182,6 +189,7 @@
   private InjectedClass createInjectedClass(String injectedClassName) {
     TypeElement type = processingEnv.getElementUtils().getTypeElement(injectedClassName);
     boolean isAbstract = type.getModifiers().contains(ABSTRACT);
+    List<Element> staticFields = new ArrayList<Element>();
     ExecutableElement constructor = null;
     List<Element> fields = new ArrayList<Element>();
     for (Element member : type.getEnclosedElements()) {
@@ -192,7 +200,7 @@
       switch (member.getKind()) {
         case FIELD:
           if (member.getModifiers().contains(STATIC)) {
-            error("@Inject not supported on static field " + type.getQualifiedName(), member);
+            staticFields.add(member);
           } else {
             fields.add(member);
           }
@@ -222,7 +230,7 @@
       }
     }
 
-    return new InjectedClass(type, constructor, fields);
+    return new InjectedClass(type, staticFields, constructor, fields);
   }
 
   /**
@@ -287,6 +295,31 @@
     javaFile.writeTo(processingEnv.getFiler());
   }
 
+  /**
+   * Write a companion class for {@code type} that extends {@link StaticInjection}.
+   */
+  private void generateStaticInjection(TypeElement type, List<Element> fields) throws IOException {
+    ClassName typeName = ClassName.get(type);
+    ClassName adapterClassName = adapterName(ClassName.get(type), STATIC_INJECTION_SUFFIX);
+
+    TypeSpec.Builder result = TypeSpec.classBuilder(adapterClassName.simpleName())
+        .addOriginatingElement(type)
+        .addJavadoc(AdapterJavadocs.STATIC_INJECTION_TYPE, type)
+        .addModifiers(PUBLIC, FINAL)
+        .superclass(StaticInjection.class);
+    for (Element field : fields) {
+      result.addField(memberBindingField(false, field));
+    }
+    result.addMethod(attachMethod(null, fields, false, typeName, null, true));
+    result.addMethod(staticInjectMethod(fields, typeName));
+
+    String packageName = getPackage(type).getQualifiedName().toString();
+    JavaFile javaFile = JavaFile.builder(packageName, result.build())
+        .addFileComment(AdapterJavadocs.GENERATED_BY_DAGGER)
+        .build();
+    javaFile.writeTo(processingEnv.getFiler());
+  }
+
   private FieldSpec memberBindingField(boolean disambiguateFields, Element field) {
     return FieldSpec.builder(bindingOf(field.asType()), fieldName(disambiguateFields, field),
         PRIVATE).build();
@@ -420,6 +453,20 @@
     return result.build();
   }
 
+  private MethodSpec staticInjectMethod(List<Element> fields, ClassName typeName) {
+    MethodSpec.Builder result = MethodSpec.methodBuilder("inject")
+        .addJavadoc(AdapterJavadocs.STATIC_INJECT_METHOD, ObjectGraph.class)
+        .addAnnotation(Override.class)
+        .addModifiers(PUBLIC);
+    for (Element field : fields) {
+      result.addStatement("$T.$N = $N.get()",
+          typeName,
+          field.getSimpleName().toString(),
+          fieldName(false, field));
+    }
+    return result.build();
+  }
+
   private String fieldName(boolean disambiguateFields, Element field) {
     return (disambiguateFields ? "field_" : "") + field.getSimpleName().toString();
   }
@@ -434,11 +481,14 @@
 
   static class InjectedClass {
     final TypeElement type;
+    final List<Element> staticFields;
     final ExecutableElement constructor;
     final List<Element> fields;
 
-    InjectedClass(TypeElement type, ExecutableElement constructor, List<Element> fields) {
+    InjectedClass(TypeElement type, List<Element> staticFields, ExecutableElement constructor,
+        List<Element> fields) {
       this.type = type;
+      this.staticFields = staticFields;
       this.constructor = constructor;
       this.fields = fields;
     }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 6cd8ed8..d204d4a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -232,6 +232,7 @@
    */
   private JavaFile generateModuleAdapter(TypeElement type,
       Map<String, Object> module, List<ExecutableElement> providerMethods) {
+    Object[] staticInjections = (Object[]) module.get("staticInjections");
     Object[] injects = (Object[]) module.get("injects");
     Object[] includes = (Object[]) module.get("includes");
     boolean overrides = (Boolean) module.get("overrides");
@@ -260,13 +261,17 @@
         .addModifiers(PRIVATE, STATIC, FINAL)
         .initializer("$L", injectsInitializer(injects))
         .build());
+    adapterBuilder.addField(FieldSpec.builder(ARRAY_OF_CLASS, "STATIC_INJECTIONS")
+        .addModifiers(PRIVATE, STATIC, FINAL)
+        .initializer("$L", staticInjectionsInitializer(staticInjections))
+        .build());
     adapterBuilder.addField(FieldSpec.builder(ARRAY_OF_CLASS, "INCLUDES")
         .addModifiers(PRIVATE, STATIC, FINAL)
         .initializer("$L", includesInitializer(type, includes))
         .build());
     adapterBuilder.addMethod(MethodSpec.constructorBuilder()
         .addModifiers(PUBLIC)
-        .addStatement("super($T.class, INJECTS, $L /*overrides*/, "
+        .addStatement("super($T.class, INJECTS, STATIC_INJECTIONS, $L /*overrides*/, "
                 + "INCLUDES, $L /*complete*/, $L /*library*/)",
             type.asType(), overrides, complete, library)
         .build());
@@ -360,6 +365,16 @@
     return result.build();
   }
 
+  private CodeBlock staticInjectionsInitializer(Object[] staticInjections) {
+    CodeBlock.Builder result = CodeBlock.builder()
+        .add("{ ");
+    for (Object staticInjection : staticInjections) {
+      result.add("$T.class, ", staticInjection);
+    }
+    result.add("}");
+    return result.build();
+  }
+
   private CodeBlock includesInitializer(TypeElement type, Object[] includes) {
     CodeBlock.Builder result = CodeBlock.builder();
     result.add("{ ");
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index e04348c..1fc8cb2 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -53,9 +53,10 @@
             + "    extends ModuleAdapter<Basic.AModule> {\n"
             + "  private static final String[] INJECTS = {\n"
             + "      \"members/Basic$A\", \"members/Basic$Foo$Bar\", \"members/Basic$Foo$Bar$Baz\"};\n"
+            + "  private static final Class<?>[] STATIC_INJECTIONS = {};\n"
             + "  private static final Class<?>[] INCLUDES = {};\n"
             + "  public Basic$AModule$$ModuleAdapter() {\n"
-            + "    super(Basic.AModule.class, INJECTS, false, INCLUDES,\n"
+            + "    super(Basic.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES,\n"
             + "      true, false);\n"
             + "  }\n"
             + "  @Override public Basic.AModule newModule() {\n"
@@ -123,24 +124,4 @@
             expectedInjectAdapterFooBar, expectedInjectAdapterFooBarBaz);
 
   }
-
-  @Test public void injectStaticFails() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Basic", ""
-        + "import dagger.Module;\n"
-        + "import javax.inject.Inject;\n"
-        + "class Basic {\n"
-        + "  static class A { @Inject A() { } }\n"
-        + "  static class B { @Inject static A a; }\n"
-        + "  @Module(injects = B.class)\n"
-        + "  static class AModule { }\n"
-        + "}\n"
-    );
-
-    assertAbout(javaSource())
-        .that(sourceFile)
-        .processedWith(daggerProcessors())
-        .failsToCompile()
-        .withErrorContaining("@Inject not supported on static field Basic.B")
-        .in(sourceFile).onLine(5);
-  }
 }
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
index a2a1f24..a5ab919 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
@@ -69,9 +69,10 @@
             + "    extends ModuleAdapter<Field.AModule> {\n"
             + "  private static final String[] INJECTS = \n"
             + "      {\"members/Field$A\", \"members/java.lang.String\"};\n"
+            + "  private static final Class<?>[] STATIC_INJECTIONS = {};\n"
             + "  private static final Class<?>[] INCLUDES = {};\n"
             + "  public Field$AModule$$ModuleAdapter() {\n"
-            + "    super(Field.AModule.class, INJECTS, false, INCLUDES, true, false);\n"
+            + "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);\n"
             + "  }\n"
             + "  @Override public Field.AModule newModule() {\n"
             + "    return new Field.AModule();\n"
@@ -158,9 +159,10 @@
             + "public final class Field$AModule$$ModuleAdapter extends ModuleAdapter<Field.AModule> {\n"
             + "  private static final String[] INJECTS = \n"
             + "      {\"members/Field$A\", \"members/java.lang.String\", \"members/Field$B\"};\n"
+            + "  private static final Class<?>[] STATIC_INJECTIONS = {};\n"
             + "  private static final Class<?>[] INCLUDES = {};\n"
             + "  public Field$AModule$$ModuleAdapter() {\n"
-            + "    super(Field.AModule.class, INJECTS, false, INCLUDES, true, false);\n"
+            + "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);\n"
             + "  }\n"
             + "  @Override public Field.AModule newModule() {\n"
             + "    return new Field.AModule();\n"
/Fim/
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
index f2c560a..893a543 100644
--- a/core/src/main/java/dagger/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -51,6 +51,7 @@
    * </ul>
    */
   Class<?>[] injects() default { };
+  Class<?>[] staticInjections() default { };
 
   /**
    * True if {@code @Provides} methods from this module are permitted to
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 36077e2..d8b8f5a 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -26,6 +26,7 @@
 import dagger.internal.Modules;
 import dagger.internal.ProblemDetector;
 import dagger.internal.SetBinding;
+import dagger.internal.StaticInjection;
 import dagger.internal.ThrowingErrorHandler;
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
@@ -106,11 +107,18 @@
   public abstract void validate();
 
   /**
+   * Injects the static fields of the classes listed in the object graph's
+   * {@code staticInjections} property.
+   */
+  public abstract void injectStatics();
+
+  /**
    * Returns a new dependency graph using the {@literal @}{@link
    * Module}-annotated modules.
    *
    * <p>This <strong>does not</strong> inject any members. Most applications
-   * should call {@link #inject} or get {@link #get(Class)} to inject instance members when this
+   * should call {@link #injectStatics} to inject static members and {@link
+   * #inject} or get {@link #get(Class)} to inject instance members when this
    * method has returned.
    *
    * <p>This <strong>does not</strong> validate the graph. Rely on build time
@@ -131,18 +139,21 @@
     private final DaggerObjectGraph base;
     private final Linker linker;
     private final Loader plugin;
+    private final Map<Class<?>, StaticInjection> staticInjections;
     private final Map<String, Class<?>> injectableTypes;
     private final List<SetBinding<?>> setBindings;
 
     DaggerObjectGraph(DaggerObjectGraph base,
         Linker linker,
         Loader plugin,
+        Map<Class<?>, StaticInjection> staticInjections,
         Map<String, Class<?>> injectableTypes,
         List<SetBinding<?>> setBindings) {
 
       this.base = base;
       this.linker = checkNotNull(linker, "linker");
       this.plugin = checkNotNull(plugin, "plugin");
+      this.staticInjections = checkNotNull(staticInjections, "staticInjections");
       this.injectableTypes = checkNotNull(injectableTypes, "injectableTypes");
       this.setBindings = checkNotNull(setBindings, "setBindings");
     }
@@ -154,6 +165,8 @@
 
     static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Object... modules) {
       Map<String, Class<?>> injectableTypes = new LinkedHashMap<String, Class<?>>();
+      Map<Class<?>, StaticInjection> staticInjections
+          = new LinkedHashMap<Class<?>, StaticInjection>();
       StandardBindings baseBindings =
           (base == null) ? new StandardBindings() : new StandardBindings(base.setBindings);
       BindingsGroup overrideBindings = new OverridesBindings();
@@ -164,6 +177,9 @@
         for (int i = 0; i < moduleAdapter.injectableTypes.length; i++) {
           injectableTypes.put(moduleAdapter.injectableTypes[i], moduleAdapter.moduleClass);
         }
+        for (int i = 0; i < moduleAdapter.staticInjections.length; i++) {
+          staticInjections.put(moduleAdapter.staticInjections[i], null);
+        }
         try {
           BindingsGroup addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
           moduleAdapter.getBindings(addTo, loadedModule.getValue());
@@ -180,7 +196,7 @@
       linker.installBindings(overrideBindings);
 
       return new DaggerObjectGraph(
-          base, linker, plugin, injectableTypes, baseBindings.setBindings);
+          base, linker, plugin, staticInjections, injectableTypes, baseBindings.setBindings);
     }
 
     @Override public ObjectGraph plus(Object... modules) {
@@ -188,6 +204,17 @@
       return makeGraph(this, plugin, modules);
     }
 
+    private void linkStaticInjections() {
+      for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
+        StaticInjection staticInjection = entry.getValue();
+        if (staticInjection == null) {
+          staticInjection = plugin.getStaticInjection(entry.getKey());
+          entry.setValue(staticInjection);
+        }
+        staticInjection.attach(linker);
+      }
+    }
+
     private void linkInjectableTypes() {
       for (Map.Entry<String, Class<?>> entry : injectableTypes.entrySet()) {
         linker.requestBinding(entry.getKey(), entry.getValue(), entry.getValue().getClassLoader(),
@@ -212,11 +239,29 @@
         if ((bindings = linker.fullyLinkedBindings()) != null) {
           return bindings;
         }
+        linkStaticInjections();
         linkInjectableTypes();
         return linker.linkAll(); // Linker.linkAll() implicitly does Linker.linkRequested().
       }
     }
 
+    @Override public void injectStatics() {
+      // We call linkStaticInjections() twice on purpose. The first time through
+      // we request all of the bindings we need. The linker returns null for
+      // bindings it doesn't have. Then we ask the linker to link all of those
+      // requested bindings. Finally we call linkStaticInjections() again: this
+      // time the linker won't return null because everything has been linked.
+      synchronized (linker) {
+        linkStaticInjections();
+        linker.linkRequested();
+        linkStaticInjections();
+      }
+
+      for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
+        entry.getValue().inject();
+      }
+    }
+
     @Override public <T> T get(Class<T> type) {
       String key = Keys.get(type);
       String injectableTypeKey = type.isInterface() ? key : Keys.getMembersKey(type);
/Fim/
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index e7f7dd3..2986ad6 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -23,16 +23,18 @@
 public abstract class ModuleAdapter<T> {
   public final Class<T> moduleClass;
   public final String[] injectableTypes;
+  public final Class<?>[] staticInjections;
   public final boolean overrides;
   public final Class<?>[] includes;
   public final boolean complete;
   public final boolean library;
 
   protected ModuleAdapter(Class<T> moduleClass, String[] injectableTypes,
-      boolean overrides, Class<?>[] includes, boolean complete,
+      Class<?>[] staticInjections, boolean overrides, Class<?>[] includes, boolean complete,
       boolean library) {
     this.moduleClass = moduleClass;
     this.injectableTypes = injectableTypes;
+    this.staticInjections = staticInjections;
     this.overrides = overrides;
     this.includes = includes;
     this.complete = complete;
/Fim/
diff --git a/core/src/test/java/dagger/InjectStaticsTest.java b/core/src/test/java/dagger/InjectStaticsTest.java
new file mode 100644
index 0000000..1eb0250
--- /dev/null
+++ b/core/src/test/java/dagger/InjectStaticsTest.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2012 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import dagger.internal.TestingLoader;
+import javax.inject.Inject;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public final class InjectStaticsTest {
+  @Before public void setUp() {
+    InjectsOneField.staticField = null;
+    InjectsStaticAndNonStatic.staticField = null;
+  }
+
+  public static class InjectsOneField {
+    @Inject static String staticField;
+  }
+
+  public static class InjectsStaticAndNonStatic {
+    @Inject Integer nonStaticField;
+    @Inject static String staticField;
+  }
+
+  @Test public void injectStatics() {
+    @Module(staticInjections = InjectsOneField.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "static";
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(),new TestModule());
+    assertThat(InjectsOneField.staticField).isNull();
+    graph.injectStatics();
+    assertThat(InjectsOneField.staticField).isEqualTo("static");
+  }
+
+  @Test public void instanceFieldsNotInjectedByInjectStatics() {
+    @Module(
+        staticInjections = InjectsStaticAndNonStatic.class,
+        injects = InjectsStaticAndNonStatic.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "static";
+      }
+      @Provides Integer provideInteger() {
+        throw new AssertionError();
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
+    assertThat(InjectsStaticAndNonStatic.staticField).isNull();
+    graph.injectStatics();
+    assertThat(InjectsStaticAndNonStatic.staticField).isEqualTo("static");
+  }
+
+  @Test public void staticFieldsNotInjectedByInjectMembers() {
+    @Module(
+        staticInjections = InjectsStaticAndNonStatic.class,
+        injects = InjectsStaticAndNonStatic.class)
+    class TestModule {
+      @Provides String provideString() {
+        throw new AssertionError();
+      }
+      @Provides Integer provideInteger() {
+        return 5;
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
+    assertThat(InjectsStaticAndNonStatic.staticField).isNull();
+    InjectsStaticAndNonStatic object = new InjectsStaticAndNonStatic();
+    graph.inject(object);
+    assertThat(InjectsStaticAndNonStatic.staticField).isNull();
+    assertThat(object.nonStaticField).isEqualTo(5);
+  }
+}
/Fim/
diff --git a/core/src/test/java/dagger/LazyInjectionTest.java b/core/src/test/java/dagger/LazyInjectionTest.java
index a1175de..44b17a0 100644
--- a/core/src/test/java/dagger/LazyInjectionTest.java
+++ b/core/src/test/java/dagger/LazyInjectionTest.java
@@ -79,6 +79,22 @@
     }
   }
 
+  @Test public void getLazyDoesNotCauseStaticsToBeLoaded() {
+    @Module(staticInjections = LazyInjectStatics.class)
+    class TestModule {
+    }
+
+    ObjectGraph.createWith(new TestingLoader(), new TestModule());
+    assertThat(LazyInjectStaticsLoaded).isFalse();
+  }
+
+  private static boolean LazyInjectStaticsLoaded = false;
+  static class LazyInjectStatics {
+    static {
+      LazyInjectStaticsLoaded = true;
+    }
+  }
+
   @Test public void lazyInjectionRequiresProvidesMethod() {
     class TestEntryPoint {
       @Inject String injected;
/Fim/
diff --git a/core/src/test/java/dagger/ModuleTest.java b/core/src/test/java/dagger/ModuleTest.java
index 827e43c..9d17a9d 100644
--- a/core/src/test/java/dagger/ModuleTest.java
+++ b/core/src/test/java/dagger/ModuleTest.java
@@ -54,6 +54,24 @@
     @Inject static String s;
   }
 
+  @Module(staticInjections = TestStaticInjection.class)
+  static class ModuleWithStaticInjection {
+  }
+
+  @Test public void childModuleWithStaticInjection() {
+    @Module(includes = ModuleWithStaticInjection.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
+    TestStaticInjection.s = null;
+    objectGraph.injectStatics();
+    assertThat(TestStaticInjection.s).isEqualTo("injected");
+  }
+
   @Module
   static class ModuleWithBinding {
     @Provides String provideString() {
/Fim/
diff --git a/core/src/test/java/dagger/internal/TestingModuleAdapter.java b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
index 188b6ee..b5d54f0 100644
--- a/core/src/test/java/dagger/internal/TestingModuleAdapter.java
+++ b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
@@ -34,6 +34,7 @@
     super(
         moduleClass,
         injectableTypesToKeys(annotation.injects()),
+        annotation.staticInjections(),
         annotation.overrides(),
         annotation.includes(),
         annotation.complete(),
/Fim/
diff --git a/website/index.html b/website/index.html
index 2e0b696..815e9be 100644
--- a/website/index.html
+++ b/website/index.html
@@ -253,6 +253,25 @@
 
             <p>Dependencies may not have multiple qualifier annotations.</p>
 
+            <h4>Static Injection</h4>
+
+            <p><span class="label label-important">Warning:</span> This feature should be used sparingly because static dependencies are difficult to test and reuse.</p>
+
+            <p>Dagger can inject static fields. Classes that declare static fields with <code>@Inject</code> annotations must be listed as <code>staticInjections</code> in a module annotation.</p>
+
+            <pre class="prettyprint">@Module(
+    staticInjections = LegacyCoffeeUtils.class
+)
+class LegacyModule {
+}</pre>
+
+            <p>Use <code>ObjectGraph.injectStatics()</code> to populate these static fields with their injected values:</p>
+
+            <pre class="prettyprint">ObjectGraph objectGraph = ObjectGraph.create(new LegacyModule());
+objectGraph.injectStatics();</pre>
+
+            <p><span class="label">Note:</span> <em>Static injection only operates for modules in the immediate graph. If you call <code>injectStatics()</code> on a graph created from a call to <code>plus()</code>, static injections on modules in the extended graph will not be performed.</em></p>
+
             <h4>Compile-time Validation</h4>
 
             <p>Dagger includes an <a href="http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html">annotation processor</a> that validates modules and injections. This processor is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is missing a binding for <code>Executor</code>:</p>
/Fim/
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 8644fff..1d23ba7 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,12 @@
 Change Log
 ==========
 
+Version 1.2.4 *(2015-05-03)*
+----------------------------
+
+ * Fix: Restore static injection support to work correctly.
+
+
 Version 1.2.3 *(2016-05-02)*
 ----------------------------
 
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 8901c97..8855d1b 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.4-SNAPSHOT</version>
+    <version>1.2.4</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 3e47082..dc0c9b1 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.4-SNAPSHOT</version>
+    <version>1.2.4</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index b0c48a7..e434d40 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.4-SNAPSHOT</version>
+    <version>1.2.4</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 6f65084..c0de899 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.4-SNAPSHOT</version>
+    <version>1.2.4</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index 5d8ef1a..7f4a8d3 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.4-SNAPSHOT</version>
+    <version>1.2.4</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 8077a9b..bc7854d 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.4-SNAPSHOT</version>
+    <version>1.2.4</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index ea932e4..3def387 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.2.4-SNAPSHOT</version>
+  <version>1.2.4</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -57,7 +57,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>HEAD</tag>
+    <tag>dagger-parent-1.2.4</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 8855d1b..e4868ea 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.4</version>
+    <version>1.2.5-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index dc0c9b1..465eff2 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.4</version>
+    <version>1.2.5-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index e434d40..8871575 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.4</version>
+    <version>1.2.5-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index c0de899..c4978ed 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.4</version>
+    <version>1.2.5-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index 7f4a8d3..ecdff68 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.4</version>
+    <version>1.2.5-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index bc7854d..276ca6e 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.4</version>
+    <version>1.2.5-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index 3def387..5bb07f7 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.2.4</version>
+  <version>1.2.5-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -57,7 +57,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>dagger-parent-1.2.4</tag>
+    <tag>HEAD</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 1d23ba7..fabb53a 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,7 +1,7 @@
 Change Log
 ==========
 
-Version 1.2.4 *(2015-05-03)*
+Version 1.2.4 *(2016-05-03)*
 ----------------------------
 
  * Fix: Restore static injection support to work correctly.
/Fim/
diff --git a/CHANGELOG.md b/CHANGELOG.md
index fabb53a..db85cce 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,12 @@
 Change Log
 ==========
 
+Version 1.2.5 *(2016-05-09)*
+----------------------------
+
+ * Fix: Correctly emit generated code for binding parameterized types.
+
+
 Version 1.2.4 *(2016-05-03)*
 ----------------------------
 
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index e4868ea..b62d46e 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.5-SNAPSHOT</version>
+    <version>1.2.5</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 465eff2..b50b919 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.5-SNAPSHOT</version>
+    <version>1.2.5</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 8871575..4e813b4 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.5-SNAPSHOT</version>
+    <version>1.2.5</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index c4978ed..4a3a7da 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.5-SNAPSHOT</version>
+    <version>1.2.5</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index ecdff68..f5d34ba 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.5-SNAPSHOT</version>
+    <version>1.2.5</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 276ca6e..67121fa 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.5-SNAPSHOT</version>
+    <version>1.2.5</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index 5bb07f7..c323a07 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.2.5-SNAPSHOT</version>
+  <version>1.2.5</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -57,7 +57,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>HEAD</tag>
+    <tag>dagger-parent-1.2.5</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index b62d46e..7b46abd 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.5</version>
+    <version>1.2.6-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index b50b919..f89a107 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.5</version>
+    <version>1.2.6-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 4e813b4..2fcc864 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.5</version>
+    <version>1.2.6-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 4a3a7da..403ca1a 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.5</version>
+    <version>1.2.6-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index f5d34ba..dbea3cd 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.5</version>
+    <version>1.2.6-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 67121fa..a610956 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.5</version>
+    <version>1.2.6-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index c323a07..3c5d533 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.2.5</version>
+  <version>1.2.6-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -57,7 +57,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>dagger-parent-1.2.5</tag>
+    <tag>HEAD</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/README.md b/README.md
index 02f4072..2178773 100644
--- a/README.md
+++ b/README.md
@@ -1,14 +1,19 @@
-Dagger
-======
+Dagger 1
+========
 
 A fast dependency injector for Android and Java.
 
-For more information please see [the website][1].
+
+Deprecated  Please upgrade to Dagger 2
+---------------------------------------
+
+Square's Dagger 1.x is deprecated in favor of [Google's Dagger 2](https://github.com/google/dagger).
+Please see [the migration guide](http://google.github.io/dagger/dagger-1-migration.html) for help
+with the upgrade.
 
 
-
-Download
---------
+Download Dagger 1
+-----------------
 
 You will need to include the `dagger-${dagger.version}.jar` in your
 application's runtime.  In order to activate code generation you will need to
/Fim/
