diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index d036d53..7f2e623 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -71,15 +71,15 @@
 public final class MockWebServer {
   private static final byte[] NPN_PROTOCOLS = {
       // TODO: support HTTP/2.0.
-      // 17, 'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '4', '/', '2', '.', '0',
+      // 17, 'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '6', '/', '2', '.', '0',
       6, 's', 'p', 'd', 'y', '/', '3',
       8, 'h', 't', 't', 'p', '/', '1', '.', '1'
   };
   private static final byte[] SPDY3 = new byte[] {
       's', 'p', 'd', 'y', '/', '3'
   };
-  private static final byte[] HTTP_20_DRAFT_04 = new byte[] {
-      'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '4', '/', '2', '.', '0'
+  private static final byte[] HTTP_20_DRAFT_06 = new byte[] {
+      'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '6', '/', '2', '.', '0'
   };
   private static final byte[] HTTP_11 = new byte[] {
       'h', 't', 't', 'p', '/', '1', '.', '1'
@@ -327,8 +327,8 @@
             byte[] selectedProtocol = Platform.get().getNpnSelectedProtocol(sslSocket);
             if (selectedProtocol == null || Arrays.equals(selectedProtocol, HTTP_11)) {
               transport = Transport.HTTP_11;
-            } else if (Arrays.equals(selectedProtocol, HTTP_20_DRAFT_04)) {
-              transport = Transport.HTTP_20_DRAFT_04;
+            } else if (Arrays.equals(selectedProtocol, HTTP_20_DRAFT_06)) {
+              transport = Transport.HTTP_20_DRAFT_06;
             } else if (Arrays.equals(selectedProtocol, SPDY3)) {
               transport = Transport.SPDY_3;
             } else {
@@ -341,14 +341,14 @@
           socket = raw;
         }
 
-        if (transport == Transport.SPDY_3 || transport == Transport.HTTP_20_DRAFT_04) {
+        if (transport == Transport.SPDY_3 || transport == Transport.HTTP_20_DRAFT_06) {
           SpdySocketHandler spdySocketHandler = new SpdySocketHandler(socket, transport);
           SpdyConnection.Builder builder = new SpdyConnection.Builder(false, socket)
               .handler(spdySocketHandler);
           if (transport == Transport.SPDY_3) {
             builder.spdy3();
           } else {
-            builder.http20Draft04();
+            builder.http20Draft06();
           }
           SpdyConnection spdyConnection = builder.build();
           openSpdyConnections.put(spdyConnection, Boolean.TRUE);
@@ -717,6 +717,6 @@
   }
 
   enum Transport {
-    HTTP_11, SPDY_3, HTTP_20_DRAFT_04
+    HTTP_11, SPDY_3, HTTP_20_DRAFT_06
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
index 1e799b4..e4a0622 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
@@ -9,8 +9,8 @@
 import java.util.List;
 
 /**
- * Read and write HPACK v01.
- * http://http2.github.io/compression-spec/compression-spec.html#rfc.status
+ * Read and write HPACK v03.
+ * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-03
  */
 final class Hpack {
   static final int PREFIX_5_BITS = 0x1f;
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft04.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft06.java
similarity index 93%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft04.java
rename to okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft06.java
index 1d48def..3d53f48 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft04.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft06.java
@@ -26,7 +26,11 @@
 import java.util.Arrays;
 import java.util.List;
 
-final class Http20Draft04 implements Variant {
+/**
+ * Read and write http/2 v06 frames.
+ * http://tools.ietf.org/html/draft-ietf-httpbis-http2-06
+ */
+final class Http20Draft06 implements Variant {
   private static final byte[] CONNECTION_HEADER;
   static {
     try {
@@ -45,8 +49,10 @@
   static final int TYPE_PING = 0x6;
   static final int TYPE_GOAWAY = 0x7;
   static final int TYPE_WINDOW_UPDATE = 0x9;
+  static final int TYPE_CONTINUATION = 0xa;
 
   static final int FLAG_END_STREAM = 0x1;
+  /** Used for headers, push-promise and continuation. */
   static final int FLAG_END_HEADERS = 0x4;
   static final int FLAG_PRIORITY = 0x8;
   static final int FLAG_PONG = 0x1;
@@ -141,31 +147,38 @@
         throws IOException {
       if (streamId == 0) throw ioException("TYPE_HEADERS streamId == 0");
 
+      boolean inFinished = (flags & FLAG_END_STREAM) != 0;
+
       while (true) {
         hpackReader.readHeaders(length);
 
         if ((flags & FLAG_END_HEADERS) != 0) {
           hpackReader.emitReferenceSet();
           List<String> namesAndValues = hpackReader.getAndReset();
-          boolean inFinished = (flags & FLAG_END_STREAM) != 0;
           int priority = -1; // TODO: priority
           handler.headers(false, inFinished, streamId, -1, priority, namesAndValues,
               HeadersMode.HTTP_20_HEADERS);
           return;
         }
 
-        // Read another frame of headers.
+        // Read another continuation frame.
         int w1 = in.readInt();
         int w2 = in.readInt();
 
         length = (w1 & 0xffff0000) >> 16;
         int newType = (w1 & 0xff00) >> 8;
         flags = w1 & 0xff;
-        // boolean r = (w2 & 0x80000000) != 0; // Reserved.
+
+        // TODO: remove in draft 8: CONTINUATION no longer sets END_STREAM
+        inFinished = (flags & FLAG_END_STREAM) != 0;
+
+        // boolean u = (w2 & 0x80000000) != 0; // Unused.
         int newStreamId = (w2 & 0x7fffffff);
 
-        if (newType != TYPE_HEADERS) throw ioException("TYPE_HEADERS didn't have FLAG_END_HEADERS");
-        if (newStreamId != streamId) throw ioException("TYPE_HEADERS streamId changed");
+        if (newType != TYPE_CONTINUATION) {
+          throw ioException("TYPE_CONTINUATION didn't have FLAG_END_HEADERS");
+        }
+        if (newStreamId != streamId) throw ioException("TYPE_CONTINUATION streamId changed");
       }
     }
 
@@ -302,6 +315,7 @@
       hpackBuffer.reset();
       hpackWriter.writeHeaders(nameValueBlock);
       int type = TYPE_HEADERS;
+      // TODO: implement CONTINUATION
       int length = hpackBuffer.size();
       int flags = FLAG_END_HEADERS;
       if (outFinished) flags |= FLAG_END_STREAM;
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index b19bd44..41724f0 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -59,7 +59,7 @@
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
       Util.daemonThreadFactory("OkHttp SpdyConnection"));
 
-  /** The protocol variant, like SPDY/3 or HTTP-draft-04/2.0. */
+  /** The protocol variant, like SPDY/3 or HTTP-draft-06/2.0. */
   final Variant variant;
 
   /** True if this peer initiated the connection. */
@@ -416,8 +416,8 @@
       return this;
     }
 
-    public Builder http20Draft04() {
-      this.variant = Variant.HTTP_20_DRAFT_04;
+    public Builder http20Draft06() {
+      this.variant = Variant.HTTP_20_DRAFT_06;
       return this;
     }
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
index 06de317..8f48bcd 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
@@ -21,7 +21,7 @@
 /** A version and dialect of the framed socket protocol. */
 interface Variant {
   Variant SPDY3 = new Spdy3();
-  Variant HTTP_20_DRAFT_04 = new Http20Draft04();
+  Variant HTTP_20_DRAFT_06 = new Http20Draft06();
 
   /**
    * @param client true if this is the HTTP client's reader, reading frames from
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft04Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft06Test.java
similarity index 86%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft04Test.java
rename to okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft06Test.java
index a22f0a6..135bd3d 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft04Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft06Test.java
@@ -27,7 +27,7 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
-public class Http20Draft04Test {
+public class Http20Draft06Test {
 
   @Test public void onlyOneLiteralHeadersFrame() throws IOException {
     final int expectedStreamId = 15;
@@ -40,13 +40,13 @@
     {
       byte[] headerBytes = literalHeaders(sentHeaders);
       dataOut.writeShort(headerBytes.length);
-      dataOut.write(Http20Draft04.TYPE_HEADERS);
-      dataOut.write(Http20Draft04.FLAG_END_HEADERS | Http20Draft04.FLAG_END_STREAM);
+      dataOut.write(Http20Draft06.TYPE_HEADERS);
+      dataOut.write(Http20Draft06.FLAG_END_HEADERS | Http20Draft06.FLAG_END_STREAM);
       dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
       dataOut.write(headerBytes);
     }
 
-    FrameReader fr = new Http20Draft04.Reader(new ByteArrayInputStream(out.toByteArray()), false);
+    FrameReader fr = new Http20Draft06.Reader(new ByteArrayInputStream(out.toByteArray()), false);
 
     // Consume the headers frame.
     fr.nextFrame(new BaseTestHandler() {
@@ -66,7 +66,7 @@
     });
   }
 
-  @Test public void twoLiteralHeadersFrames() throws IOException {
+  @Test public void headersFrameThenContinuation() throws IOException {
     final int expectedStreamId = 15;
 
     ByteArrayOutputStream out = new ByteArrayOutputStream();
@@ -76,23 +76,23 @@
     {
       byte[] headerBytes = literalHeaders(Arrays.asList("foo", "bar"));
       dataOut.writeShort(headerBytes.length);
-      dataOut.write(Http20Draft04.TYPE_HEADERS);
+      dataOut.write(Http20Draft06.TYPE_HEADERS);
       dataOut.write(0); // no flags
       dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
       dataOut.write(headerBytes);
     }
 
-    // Write the second headers frame, specifying no more frames are expected.
+    // Write the continuation frame, specifying no more frames are expected.
     {
       byte[] headerBytes = literalHeaders(Arrays.asList("baz", "qux"));
       dataOut.writeShort(headerBytes.length);
-      dataOut.write(Http20Draft04.TYPE_HEADERS);
-      dataOut.write(Http20Draft04.FLAG_END_HEADERS | Http20Draft04.FLAG_END_STREAM);
+      dataOut.write(Http20Draft06.TYPE_CONTINUATION);
+      dataOut.write(Http20Draft06.FLAG_END_HEADERS | Http20Draft06.FLAG_END_STREAM);
       dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
       dataOut.write(headerBytes);
     }
 
-    FrameReader fr = new Http20Draft04.Reader(new ByteArrayInputStream(out.toByteArray()), false);
+    FrameReader fr = new Http20Draft06.Reader(new ByteArrayInputStream(out.toByteArray()), false);
 
     // Reading the above frames should result in a concatenated nameValueBlock.
     fr.nextFrame(new BaseTestHandler() {
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 7f2e623..9bdcd7b 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -70,8 +70,7 @@
  */
 public final class MockWebServer {
   private static final byte[] NPN_PROTOCOLS = {
-      // TODO: support HTTP/2.0.
-      // 17, 'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '6', '/', '2', '.', '0',
+      17, 'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '6', '/', '2', '.', '0',
       6, 's', 'p', 'd', 'y', '/', '3',
       8, 'h', 't', 't', 'p', '/', '1', '.', '1'
   };
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
index e4a0622..c3ca8f1 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
@@ -13,77 +13,97 @@
  * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-03
  */
 final class Hpack {
+
+  static class HeaderEntry {
+    private final String name;
+    private final String value;
+
+    HeaderEntry(String name, String value) {
+      this.name = name;
+      this.value = value;
+    }
+
+    // TODO: This needs to be the length in UTF-8 bytes, not the length in chars.
+    int length() {
+      return 32 + name.length() + value.length();
+    }
+  }
+
   static final int PREFIX_5_BITS = 0x1f;
   static final int PREFIX_6_BITS = 0x3f;
   static final int PREFIX_7_BITS = 0x7f;
   static final int PREFIX_8_BITS = 0xff;
 
-  static final List<String> INITIAL_CLIENT_TO_SERVER_HEADER_TABLE = Arrays.asList(
-      ":scheme", "http",
-      ":scheme", "https",
-      ":host", "",
-      ":path", "/",
-      ":method", "GET",
-      "accept", "",
-      "accept-charset", "",
-      "accept-encoding", "",
-      "accept-language", "",
-      "cookie", "",
-      "if-modified-since", "",
-      "user-agent", "",
-      "referer", "",
-      "authorization", "",
-      "allow", "",
-      "cache-control", "",
-      "connection", "",
-      "content-length", "",
-      "content-type", "",
-      "date", "",
-      "expect", "",
-      "from", "",
-      "if-match", "",
-      "if-none-match", "",
-      "if-range", "",
-      "if-unmodified-since", "",
-      "max-forwards", "",
-      "proxy-authorization", "",
-      "range", "",
-      "via", ""
+  static final List<HeaderEntry> INITIAL_CLIENT_TO_SERVER_HEADER_TABLE = Arrays.asList(
+      new HeaderEntry(":scheme", "http"),
+      new HeaderEntry(":scheme", "https"),
+      new HeaderEntry(":host", ""),
+      new HeaderEntry(":path", "/"),
+      new HeaderEntry(":method", "GET"),
+      new HeaderEntry("accept", ""),
+      new HeaderEntry("accept-charset", ""),
+      new HeaderEntry("accept-encoding", ""),
+      new HeaderEntry("accept-language", ""),
+      new HeaderEntry("cookie", ""),
+      new HeaderEntry("if-modified-since", ""),
+      new HeaderEntry("user-agent", ""),
+      new HeaderEntry("referer", ""),
+      new HeaderEntry("authorization", ""),
+      new HeaderEntry("allow", ""),
+      new HeaderEntry("cache-control", ""),
+      new HeaderEntry("connection", ""),
+      new HeaderEntry("content-length", ""),
+      new HeaderEntry("content-type", ""),
+      new HeaderEntry("date", ""),
+      new HeaderEntry("expect", ""),
+      new HeaderEntry("from", ""),
+      new HeaderEntry("if-match", ""),
+      new HeaderEntry("if-none-match", ""),
+      new HeaderEntry("if-range", ""),
+      new HeaderEntry("if-unmodified-since", ""),
+      new HeaderEntry("max-forwards", ""),
+      new HeaderEntry("proxy-authorization", ""),
+      new HeaderEntry("range", ""),
+      new HeaderEntry("via", "")
   );
 
-  static final List<String> INITIAL_SERVER_TO_CLIENT_HEADER_TABLE = Arrays.asList(
-      ":status", "200",
-      "age", "",
-      "cache-control", "",
-      "content-length", "",
-      "content-type", "",
-      "date", "",
-      "etag", "",
-      "expires", "",
-      "last-modified", "",
-      "server", "",
-      "set-cookie", "",
-      "vary", "",
-      "via", "",
-      "access-control-allow-origin", "",
-      "accept-ranges", "",
-      "allow", "",
-      "connection", "",
-      "content-disposition", "",
-      "content-encoding", "",
-      "content-language", "",
-      "content-location", "",
-      "content-range", "",
-      "link", "",
-      "location", "",
-      "proxy-authenticate", "",
-      "refresh", "",
-      "retry-after", "",
-      "strict-transport-security", "",
-      "transfer-encoding", "",
-      "www-authenticate", ""
+  static final List<HeaderEntry> INITIAL_SERVER_TO_CLIENT_HEADER_TABLE = Arrays.asList(
+      new HeaderEntry(":status", "200"),
+      new HeaderEntry("age", ""),
+      new HeaderEntry("cache-control", ""),
+      new HeaderEntry("content-length", ""),
+      new HeaderEntry("content-type", ""),
+      new HeaderEntry("date", ""),
+      new HeaderEntry("etag", ""),
+      new HeaderEntry("expires", ""),
+      new HeaderEntry("last-modified", ""),
+      new HeaderEntry("server", ""),
+      new HeaderEntry("set-cookie", ""),
+      new HeaderEntry("vary", ""),
+      new HeaderEntry("via", ""),
+      new HeaderEntry("access-control-allow-origin", ""),
+      new HeaderEntry("accept-ranges", ""),
+      new HeaderEntry("allow", ""),
+      new HeaderEntry("connection", ""),
+      new HeaderEntry("content-disposition", ""),
+      new HeaderEntry("content-encoding", ""),
+      new HeaderEntry("content-language", ""),
+      new HeaderEntry("content-location", ""),
+      new HeaderEntry("content-range", ""),
+      new HeaderEntry("link", ""),
+      new HeaderEntry("location", ""),
+      new HeaderEntry("proxy-authenticate", ""),
+      new HeaderEntry("refresh", ""),
+      new HeaderEntry("retry-after", ""),
+      new HeaderEntry("strict-transport-security", ""),
+      new HeaderEntry("transfer-encoding", ""),
+      new HeaderEntry("www-authenticate", "")
   );
 
+  // Update these when initial tables change to sum of each entry length.
+  static final int INITIAL_CLIENT_TO_SERVER_HEADER_TABLE_LENGTH = 1262;
+  static final int INITIAL_SERVER_TO_CLIENT_HEADER_TABLE_LENGTH = 1304;
+
   private Hpack() {
   }
 
@@ -92,16 +112,20 @@
     private final DataInputStream in;
 
     private final BitSet referenceSet = new BitSet();
-    private final List<String> headerTable;
+    private final List<HeaderEntry> headerTable;
     private final List<String> emittedHeaders = new ArrayList<String>();
-    private long bufferSize = 4096;
+    private long bufferSize = 0;
     private long bytesLeft = 0;
 
     Reader(DataInputStream in, boolean client) {
       this.in = in;
-      this.headerTable = new ArrayList<String>(client
-          ? INITIAL_CLIENT_TO_SERVER_HEADER_TABLE
-          : INITIAL_SERVER_TO_CLIENT_HEADER_TABLE);
+      if (client) {  // we are reading from the server
+        this.headerTable = new ArrayList<HeaderEntry>(INITIAL_SERVER_TO_CLIENT_HEADER_TABLE);
+        this.bufferSize = INITIAL_SERVER_TO_CLIENT_HEADER_TABLE_LENGTH;
+      } else {
+        this.headerTable = new ArrayList<HeaderEntry>(INITIAL_CLIENT_TO_SERVER_HEADER_TABLE);
+        this.bufferSize = INITIAL_CLIENT_TO_SERVER_HEADER_TABLE_LENGTH;
+      }
     }
 
     /**
@@ -161,8 +185,6 @@
         referenceSet.clear(index);
       } else {
         referenceSet.set(index);
-        emittedHeaders.add(getName(index));
-        emittedHeaders.add(getValue(index));
       }
     }
 
@@ -184,23 +206,17 @@
 
     private void readLiteralHeaderWithIncrementalIndexingIndexedName(int nameIndex)
         throws IOException {
-      int index = headerTable.size();
       String name = getName(nameIndex);
       String value = readString();
-      appendToHeaderTable(name, value);
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
-      referenceSet.set(index);
+      int index = headerTable.size(); // append to tail
+      insertIntoHeaderTable(index, new HeaderEntry(name, value));
     }
 
     private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
-      int index = headerTable.size();
       String name = readString();
       String value = readString();
-      appendToHeaderTable(name, value);
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
-      referenceSet.set(index);
+      int index = headerTable.size(); // append to tail
+      insertIntoHeaderTable(index, new HeaderEntry(name, value));
     }
 
     private void readLiteralHeaderWithSubstitutionIndexingIndexedName(int nameIndex)
@@ -208,43 +224,39 @@
       int index = readInt(readByte(), PREFIX_8_BITS);
       String name = getName(nameIndex);
       String value = readString();
-      replaceInHeaderTable(index, name, value);
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
-      referenceSet.set(index);
+      insertIntoHeaderTable(index, new HeaderEntry(name, value));
     }
 
     private void readLiteralHeaderWithSubstitutionIndexingNewName() throws IOException {
       String name = readString();
       int index = readInt(readByte(), PREFIX_8_BITS);
       String value = readString();
-      replaceInHeaderTable(index, name, value);
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
-      referenceSet.set(index);
+      insertIntoHeaderTable(index, new HeaderEntry(name, value));
     }
 
     private String getName(int index) {
-      return headerTable.get(index * 2);
+      return headerTable.get(index).name;
     }
 
     private String getValue(int index) {
-      return headerTable.get(index * 2 + 1);
+      return headerTable.get(index).value;
     }
 
-    private void appendToHeaderTable(String name, String value) {
-      insertIntoHeaderTable(headerTable.size() * 2, name, value);
-    }
+    private void insertIntoHeaderTable(int index, HeaderEntry entry) {
+      int delta = entry.length();
+      if (index != headerTable.size()) {
+        delta -= headerTable.get(index).length();
+      }
 
-    private void replaceInHeaderTable(int index, String name, String value) {
-      remove(index);
-      insertIntoHeaderTable(index, name, value);
-    }
-
-    private void insertIntoHeaderTable(int index, String name, String value) {
-      // TODO: This needs to be the length in UTF-8 bytes, not the length in chars.
-
-      int delta = 32 + name.length() + value.length();
+      // if the new or replacement header is too big, drop all entries.
+      if (delta > maxBufferSize) {
+        headerTable.clear();
+        bufferSize = 0;
+        // emit the large header to the callback.
+        emittedHeaders.add(entry.name);
+        emittedHeaders.add(entry.value);
+        return;
+      }
 
       // Prune headers to the required length.
       while (bufferSize + delta > maxBufferSize) {
@@ -252,22 +264,21 @@
         index--;
       }
 
-      if (delta > maxBufferSize) {
-        return; // New values won't fit in the buffer; skip 'em.
+      if (index < 0) { // we pruned it, so insert at beginning
+        index = 0;
+        headerTable.add(index, entry);
+      } else if (index == headerTable.size()) { // append to the end
+        headerTable.add(index, entry);
+      } else { // replace value at same position
+        headerTable.set(index, entry);
       }
 
-      if (index == 0) index = 0;
-
-      headerTable.add(index * 2, name);
-      headerTable.add(index * 2 + 1, value);
       bufferSize += delta;
+      referenceSet.set(index);
     }
 
     private void remove(int index) {
-      String name = headerTable.remove(index * 2);
-      String value = headerTable.remove(index * 2); // No +1 because it's shifted by remove() above.
-      // TODO: This needs to be the length in UTF-8 bytes, not the length in chars.
-      bufferSize -= (32 + name.length() + value.length());
+      bufferSize -= headerTable.remove(index).length();
     }
 
     private int readByte() throws IOException {
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft06Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft06Test.java
index 135bd3d..c0e0fe6 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft06Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft06Test.java
@@ -28,9 +28,9 @@
 import static org.junit.Assert.assertTrue;
 
 public class Http20Draft06Test {
+  static final int expectedStreamId = 15;
 
   @Test public void onlyOneLiteralHeadersFrame() throws IOException {
-    final int expectedStreamId = 15;
     final List<String> sentHeaders = Arrays.asList("name", "value");
 
     ByteArrayOutputStream out = new ByteArrayOutputStream();
@@ -67,7 +67,6 @@
   }
 
   @Test public void headersFrameThenContinuation() throws IOException {
-    final int expectedStreamId = 15;
 
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     DataOutputStream dataOut = new DataOutputStream(out);
@@ -112,6 +111,122 @@
     });
   }
 
+  /**
+   * HPACK has a max header table size, which can be smaller than the max header message.
+   * Ensure the larger header content is not lost.
+   */
+  @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
+    char[] tooLarge = new char[4096];
+    Arrays.fill(tooLarge, 'a');
+    final List<String> sentHeaders = Arrays.asList("foo", new String(tooLarge));
+
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    writeOnlyHeadersFrame(literalHeaders(sentHeaders), dataOut);
+
+    FrameReader fr = new Http20Draft06.Reader(new ByteArrayInputStream(out.toByteArray()), false);
+
+    // Consume the large header set.
+    fr.nextFrame(new BaseTestHandler() {
+
+      @Override
+      public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, int priority, List<String> nameValueBlock,
+          HeadersMode headersMode) {
+        assertEquals(sentHeaders, nameValueBlock);
+      }
+    });
+  }
+
+  @Test public void usingDraft06Examples() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    writeOnlyHeadersFrame(firstHeaderSetBytes(), dataOut);
+    writeOnlyHeadersFrame(secondHeaderSetBytes(), dataOut);
+
+    FrameReader fr = new Http20Draft06.Reader(new ByteArrayInputStream(out.toByteArray()), false);
+
+    // Consume the first header set.
+    fr.nextFrame(new BaseTestHandler() {
+
+      @Override
+      public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, int priority, List<String> nameValueBlock,
+          HeadersMode headersMode) {
+        assertEquals(Arrays.asList(":path", "/my-example/index.html", "user-agent", "my-user-agent",
+            "mynewheader", "first"), nameValueBlock);
+      }
+    });
+
+    // Consume the second header set.
+    fr.nextFrame(new BaseTestHandler() {
+
+      @Override
+      public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, int priority, List<String> nameValueBlock,
+          HeadersMode headersMode) {
+        assertEquals(Arrays.asList(
+            ":path", "/my-example/resources/script.js",
+            "user-agent", "my-user-agent",
+            "mynewheader", "second"
+        ), nameValueBlock);
+      }
+    });
+  }
+
+  // Deviates from draft only to fix doc bugs noted in https://github.com/igrigorik/http-2 specs.
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-03#appendix-C.1
+  static byte[] firstHeaderSetBytes() {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x44); // literal header with incremental indexing, name index = 3
+    out.write(0x16); // header value string length = 22
+    out.write("/my-example/index.html".getBytes(), 0, 22);
+
+    out.write(0x4C); // literal header with incremental indexing, name index = 11
+    out.write(0x0D); // header value string length = 13
+    out.write("my-user-agent".getBytes(), 0, 13);
+
+    out.write(0x40); // literal header with incremental indexing, new name
+    out.write(0x0B); // header name string length = 11
+    out.write("mynewheader".getBytes(), 0, 11);
+    out.write(0x05); // header value string length = 5
+    out.write("first".getBytes(), 0, 5);
+
+    return out.toByteArray();
+  }
+
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-03#appendix-C.2
+  static byte[] secondHeaderSetBytes() {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x9e); // indexed header, index = 30: removal from reference set
+    out.write(0xa0); // indexed header, index = 32: removal from reference set
+    out.write(0x04); // literal header, substitution indexing, name index = 3
+
+    out.write(0x1e); // replaced entry index = 30
+    out.write(0x1f); // header value string length = 31
+    out.write("/my-example/resources/script.js".getBytes(), 0, 31);
+
+    out.write(0x5f);
+    out.write(0x02); // literal header, incremental indexing, name index = 32
+    out.write(0x06); // header value string length = 6
+    out.write("second".getBytes(), 0, 6);
+
+    return out.toByteArray();
+  }
+
+  static void writeOnlyHeadersFrame(byte[] headersSet, DataOutputStream dataOut)
+      throws IOException {
+    dataOut.writeShort(headersSet.length);
+    dataOut.write(Http20Draft06.TYPE_HEADERS);
+    dataOut.write(Http20Draft06.FLAG_END_HEADERS | Http20Draft06.FLAG_END_STREAM);
+    dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream 15 with reserved bit set
+    dataOut.write(headersSet);
+  }
+
   static byte[] literalHeaders(List<String> sentHeaders) throws IOException {
     ByteArrayOutputStream headerBytes = new ByteArrayOutputStream();
     new Hpack.Writer(new DataOutputStream(headerBytes)).writeHeaders(sentHeaders);
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index a6b798d..a304845 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -105,14 +105,9 @@
 
     if (route.address.sslSocketFactory != null) {
       upgradeToTls(tunnelRequest);
+    } else {
+      streamWrapper();
     }
-
-    // Use MTU-sized buffers to send fewer packets.
-    int mtu = Platform.get().getMtu(socket);
-    if (mtu < 1024) mtu = 1024;
-    if (mtu > 8192) mtu = 8192;
-    in = new BufferedInputStream(in, mtu);
-    out = new BufferedOutputStream(out, mtu);
   }
 
   /**
@@ -152,6 +147,7 @@
 
     out = sslSocket.getOutputStream();
     in = sslSocket.getInputStream();
+    streamWrapper();
 
     byte[] selectedProtocol;
     if (useNpn && (selectedProtocol = platform.getNpnSelectedProtocol(sslSocket)) != null) {
@@ -332,4 +328,13 @@
       }
     }
   }
+
+  private void streamWrapper() throws IOException {
+    //Use MTU-sized buffers to send fewer packets.
+    int mtu = Platform.get().getMtu(socket);
+    if (mtu < 1024) mtu = 1024;
+    if (mtu > 8192) mtu = 8192;
+    in = new BufferedInputStream(in, mtu);
+    out = new BufferedOutputStream(out, mtu);
+  }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index a304845..a46bb31 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -330,11 +330,7 @@
   }
 
   private void streamWrapper() throws IOException {
-    //Use MTU-sized buffers to send fewer packets.
-    int mtu = Platform.get().getMtu(socket);
-    if (mtu < 1024) mtu = 1024;
-    if (mtu > 8192) mtu = 8192;
-    in = new BufferedInputStream(in, mtu);
-    out = new BufferedOutputStream(out, mtu);
+    in = new BufferedInputStream(in, 4096);
+    out = new BufferedOutputStream(out, 256);
   }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 5ed9510..5f35582 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -28,7 +28,7 @@
 import java.net.ProtocolException;
 import java.net.URL;
 import java.util.ArrayList;
-import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;
@@ -102,8 +102,8 @@
    * values, they are concatenated using "\0" as a delimiter.
    */
   public static List<String> writeNameValueBlock(Headers headers) {
-    Set<String> names = new HashSet<String>();
-    List<String> result = new ArrayList<String>();
+    Set<String> names = new LinkedHashSet<String>();
+    List<String> result = new ArrayList<String>(headers.length() * 2);
     for (int i = 0; i < headers.length(); i++) {
       String name = headers.getFieldName(i).toLowerCase(Locale.US);
       String value = headers.getValue(i);
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index 6eb8d83..b392196 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -444,8 +444,9 @@
       return this;
     }
 
-    public void removeHeader(String name) {
+    public Builder removeHeader(String name) {
       headers.removeAll(name);
+      return this;
     }
 
     public Builder setChunked() {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 7120b29..841e98a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -182,7 +182,6 @@
       }
 
       transport = (Transport) connection.newTransport(this);
-      request = transport.prepareRequest(request);
 
       // Create a request body if we don't have one already. We'll already have
       // one if we're retrying a failed POST.
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
index 1db10cc..b754310 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
@@ -61,10 +61,6 @@
     this.socketIn = inputStream;
   }
 
-  public Request prepareRequest(Request request) {
-    return request;
-  }
-
   @Override public OutputStream createRequestBody(Request request) throws IOException {
     long contentLength = request.getContentLength();
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 978764b..2665125 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -42,19 +42,6 @@
     this.spdyConnection = spdyConnection;
   }
 
-  @Override public Request prepareRequest(Request request) {
-    Request.Builder builder = request.newBuilder()
-        .header(":method", request.method())
-        .header(":scheme", request.url().getProtocol())
-        .header(":path", RequestLine.requestPath(request.url()))
-        .header(":version", RequestLine.version(httpEngine.connection.getHttpMinorVersion()))
-        .header(":host", HttpEngine.hostHeader(request.url()));
-
-    builder.removeHeader("Transfer-Encoding"); // SPDY doesn't use chunked encoding.
-
-    return builder.build();
-  }
-
   @Override public OutputStream createRequestBody(Request request) throws IOException {
     // TODO: if bufferRequestBody is set, we must buffer the whole request
     writeRequestHeaders(request);
@@ -67,8 +54,9 @@
     httpEngine.writingRequestHeaders();
     boolean hasRequestBody = httpEngine.hasRequestBody();
     boolean hasResponseBody = true;
+    String version = RequestLine.version(httpEngine.connection.getHttpMinorVersion());
     stream = spdyConnection.newStream(
-        writeNameValueBlock(request.getHeaders()), hasRequestBody, hasResponseBody);
+        writeNameValueBlock(request, version), hasRequestBody, hasResponseBody);
     stream.setReadTimeout(httpEngine.client.getReadTimeout());
   }
 
@@ -89,12 +77,23 @@
    * Names are all lower case. No names are repeated. If any name has multiple
    * values, they are concatenated using "\0" as a delimiter.
    */
-  public static List<String> writeNameValueBlock(Headers headers) {
+  public static List<String> writeNameValueBlock(Request request, String version) {
+    List<String> result = new ArrayList<String>(request.headerCount() + 10);
+    result.add(":method");
+    result.add(request.method());
+    result.add(":path");
+    result.add(RequestLine.requestPath(request.url()));
+    result.add(":version");
+    result.add(version);
+    result.add(":host");
+    result.add(HttpEngine.hostHeader(request.url()));
+    result.add(":scheme");
+    result.add(request.url().getProtocol());
+
     Set<String> names = new LinkedHashSet<String>();
-    List<String> result = new ArrayList<String>(headers.length() * 2);
-    for (int i = 0; i < headers.length(); i++) {
-      String name = headers.getFieldName(i).toLowerCase(Locale.US);
-      String value = headers.getValue(i);
+    for (int i = 0; i < request.headerCount(); i++) {
+      String name = request.headerName(i).toLowerCase(Locale.US);
+      String value = request.headerValue(i);
 
       // Drop headers that are forbidden when layering HTTP over SPDY.
       if (name.equals("connection")
@@ -105,6 +104,15 @@
         continue;
       }
 
+      // They shouldn't be set, but if they are, drop them. We've already written them!
+      if (name.equals(":method")
+          || name.equals(":path")
+          || name.equals(":version")
+          || name.equals(":host")
+          || name.equals(":scheme")) {
+        continue;
+      }
+
       // If we haven't seen this name before, add the pair to the end of the list...
       if (names.add(name)) {
         result.add(name);
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
index cbe12fe..59e986f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
@@ -25,13 +25,6 @@
 
 interface Transport {
   /**
-   * Returns a request equivalent to {@code request} but with transport-specific
-   * changes. For example, this may set a Transfer-Encoding header if it is
-   * required but not present for the current transport.
-   */
-  Request prepareRequest(Request request);
-
-  /**
    * Returns an output stream where the request body can be written. The
    * returned stream will of one of two types:
    * <ul>
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
index 1dce009..dc08b65 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
@@ -53,13 +53,20 @@
   }
 
   @Test public void toNameValueBlock() {
-    Headers.Builder builder = new Headers.Builder();
-    builder.add("cache-control", "no-cache, no-store");
-    builder.add("set-cookie", "Cookie1");
-    builder.add("set-cookie", "Cookie2");
-    builder.add(":status", "200 OK");
-    List<String> nameValueBlock = SpdyTransport.writeNameValueBlock(builder.build());
+    Request request = new Request.Builder()
+        .url("http://square.com/")
+        .header("cache-control", "no-cache, no-store")
+        .addHeader("set-cookie", "Cookie1")
+        .addHeader("set-cookie", "Cookie2")
+        .header(":status", "200 OK")
+        .build();
+    List<String> nameValueBlock = SpdyTransport.writeNameValueBlock(request, "HTTP/1.1");
     List<String> expected = Arrays.asList(
+        ":method", "GET",
+        ":path", "/",
+        ":version", "HTTP/1.1",
+        ":host", "square.com",
+        ":scheme", "http",
         "cache-control", "no-cache, no-store",
         "set-cookie", "Cookie1\u0000Cookie2",
         ":status", "200 OK");
@@ -67,9 +74,17 @@
   }
 
   @Test public void toNameValueBlockDropsForbiddenHeaders() {
-    Headers.Builder builder = new Headers.Builder();
-    builder.add("Connection", "close");
-    builder.add("Transfer-Encoding", "chunked");
-    assertEquals(Arrays.<String>asList(), SpdyTransport.writeNameValueBlock(builder.build()));
+    Request request = new Request.Builder()
+        .url("http://square.com/")
+        .header("Connection", "close")
+        .header("Transfer-Encoding", "chunked")
+        .build();
+    List<String> expected = Arrays.asList(
+        ":method", "GET",
+        ":path", "/",
+        ":version", "HTTP/1.1",
+        ":host", "square.com",
+        ":scheme", "http");
+    assertEquals(expected, SpdyTransport.writeNameValueBlock(request, "HTTP/1.1"));
   }
 }
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 5030943..51ad1df 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -690,6 +690,9 @@
     }
 
     private void writeResponse(SpdyStream stream, MockResponse response) throws IOException {
+      if (response.getSocketPolicy() == SocketPolicy.NO_RESPONSE) {
+        return;
+      }
       List<String> spdyHeaders = new ArrayList<String>();
       String[] statusParts = response.getStatus().split(" ", 2);
       if (statusParts.length != 2) {
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
index 7912f3a..76701c4 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
@@ -57,5 +57,11 @@
    * Shutdown the socket output after sending the response. For testing bad
    * behavior.
    */
-  SHUTDOWN_OUTPUT_AT_END
+  SHUTDOWN_OUTPUT_AT_END,
+
+  /**
+   * Don't response to the request but keep the socket open. For testing
+   * read response header timeout issue.
+   */
+  NO_RESPONSE
 }
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index 035d5d2..d3ee224 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -23,6 +23,8 @@
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.SocketPolicy;
+
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
@@ -226,6 +228,16 @@
     assertEquals(-1, in.read());
   }
 
+  @Test(timeout = 3000) public void readResponseHeaderTimeout() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection.setReadTimeout(1000);
+    assertContent("A", connection, Integer.MAX_VALUE);
+  }
+
   @Test public void responsesAreCached() throws IOException {
     client.setResponseCache(cache);
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index e550022..a3ab3a4 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -116,9 +116,23 @@
    * have not been received yet.
    */
   public synchronized List<String> getResponseHeaders() throws IOException {
+    long remaining = 0;
+    long start = 0;
+    if (readTimeoutMillis != 0) {
+      start = (System.nanoTime() / 1000000);
+      remaining = readTimeoutMillis;
+    }
     try {
       while (responseHeaders == null && errorCode == null) {
-        wait();
+        if (readTimeoutMillis == 0) { // No timeout configured.
+          wait();
+        } else if (remaining > 0) {
+          wait(remaining);
+          remaining = start + readTimeoutMillis - (System.nanoTime() / 1000000);
+        } else {
+          throw new SocketTimeoutException("Read response header timeout. readTimeoutMillis: "
+                            + readTimeoutMillis);
+        }
       }
       if (responseHeaders != null) {
         return responseHeaders;
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index 9caac63..cacb4a5 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -53,8 +53,8 @@
   /** Headers sent in the stream reply. Null if reply is either not sent or not sent yet. */
   private List<String> responseHeaders;
 
-  private final SpdyDataInputStream in = new SpdyDataInputStream();
-  private final SpdyDataOutputStream out = new SpdyDataOutputStream();
+  private final SpdyDataInputStream in;
+  private final SpdyDataOutputStream out;
 
   /**
    * The reason why this stream was abnormally closed. If there are multiple
@@ -69,6 +69,8 @@
     if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
     this.id = id;
     this.connection = connection;
+    this.in = new SpdyDataInputStream();
+    this.out = new SpdyDataOutputStream();
     this.in.finished = inFinished;
     this.out.finished = outFinished;
     this.priority = priority;
@@ -350,8 +352,8 @@
     //         ^       ^
     //       limit    pos
 
-    private final byte[] buffer = SpdyStream.this.connection.bufferPool.
-            getBuf(Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+    private final byte[] buffer = SpdyStream.this.connection.bufferPool.getBuf(
+        Settings.DEFAULT_INITIAL_WINDOW_SIZE);
 
     /** the next byte to be read, or -1 if the buffer is empty. Never buffer.length */
     private int pos = -1;
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
index d3a32e1..045677b 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
@@ -1,5 +1,7 @@
 package com.squareup.okhttp.internal.spdy;
 
+// TODO: revisit for http/2 draft 9
+// http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-7
 public enum ErrorCode {
   /** Not an error! For SPDY stream resets, prefer null over NO_ERROR. */
   NO_ERROR(0, -1, 0),
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index c3f8d8e..b8b0730 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -7,7 +7,6 @@
 import java.util.Arrays;
 import java.util.BitSet;
 import java.util.List;
-import java.util.ListIterator;
 
 /**
  * Read and write HPACK v05.
@@ -45,7 +44,6 @@
     }
   }
 
-  static final int PREFIX_5_BITS = 0x1f;
   static final int PREFIX_6_BITS = 0x3f;
   static final int PREFIX_7_BITS = 0x7f;
   static final int PREFIX_8_BITS = 0xff;
@@ -133,16 +131,6 @@
       this.in = in;
     }
 
-    // Visible for testing.
-    void reset() {
-      bytesLeft = 0;
-      headerTableSize = 0;
-      maxHeaderTableSize = 4096;
-      staticReferenceSet.clear();
-      headerTable.clear();
-      emittedHeaders.clear();
-    }
-
     /**
      * Read {@code byteCount} bytes of headers from the source stream into the
      * set of emitted headers.
@@ -157,7 +145,7 @@
         if ((b & 0x80) != 0) {
           int index = readInt(b, PREFIX_7_BITS);
           if (index == 0) {
-            emptyReferenceSet();
+            clearReferenceSet();
           } else {
             readIndexedHeader(index - 1);
           }
@@ -172,12 +160,13 @@
           int index = readInt(b, PREFIX_6_BITS);
           readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
         } else {
-          throw new AssertionError();
+          // TODO: we should throw something that we can coerce to a PROTOCOL_ERROR
+          throw new AssertionError("unhandled byte: " + Integer.toBinaryString(b));
         }
       }
     }
 
-    private void emptyReferenceSet() {
+    private void clearReferenceSet() {
       staticReferenceSet.clear();
       for (HeaderEntry entry : headerTable) {
         entry.referenced = false;
@@ -189,9 +178,8 @@
           i = staticReferenceSet.nextSetBit(i + 1)) {
         STATIC_HEADER_TABLE.get(i).addTo(emittedHeaders);
       }
-      for (ListIterator<HeaderEntry> li = headerTable.listIterator(headerTable.size());
-          li.hasPrevious(); ) {
-        li.previous().addTo(emittedHeaders);
+      for (int i = headerTable.size() - 1; i != -1; i--) {
+        headerTable.get(i).addTo(emittedHeaders);
       }
     }
 
@@ -217,6 +205,9 @@
         HeaderEntry existing = headerTable.get(index);
         existing.referenced = true;
         insertIntoHeaderTable(index, existing);
+      } else {
+        // TODO: we should throw something that we can coerce to a PROTOCOL_ERROR
+        throw new AssertionError("invalid index " + index);
       }
     }
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index caaf8ab..69bc2f2 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -25,7 +25,6 @@
 import java.io.UnsupportedEncodingException;
 import java.util.Arrays;
 import java.util.List;
-import java.util.Locale;
 
 /**
  * Read and write http/2 v09 frames.
@@ -159,13 +158,12 @@
 
         if ((flags & FLAG_END_HEADERS) != 0) {
           hpackReader.emitReferenceSet();
-          List<String> namesAndValues = hpackReader.getAndReset();
-          // TODO: throw malformed if any present:
-          // Connection, Keep-Alive, Proxy-Connection, TE, Transfer-Encoding, Encoding, Upgrade.
+          // not filtering out illegal headers on read.
+          List<String> nameValueBlock = hpackReader.getAndReset();
           // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
           // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3
           int priority = -1; // TODO: priority
-          handler.headers(false, inFinished, streamId, -1, priority, namesAndValues,
+          handler.headers(false, inFinished, streamId, -1, priority, nameValueBlock,
               HeadersMode.HTTP_20_HEADERS);
           return;
         }
@@ -325,13 +323,19 @@
         List<String> nameValueBlock) throws IOException {
       hpackBuffer.reset();
       for (int i = 0, size = nameValueBlock.size(); i < size; i += 2) {
-        String headerName = nameValueBlock.get(i).toLowerCase(Locale.US);
+        String name = nameValueBlock.get(i);
         // our SpdyTransport.writeNameValueBlock hard-codes :host
-        if (":host".equals(headerName)) headerName = ":authority";
-        nameValueBlock.set(i, headerName);
+        // TODO: is :authority literally the same value as :host?
+        // https://github.com/http2/http2-spec/issues/334
+        if (":host".equals(name)) {
+          nameValueBlock.set(i, ":authority");
+        } else if (shouldDropHeader(name)) {
+          //TODO: Avoid creating headers like these.
+          nameValueBlock.remove(i);
+          nameValueBlock.remove(i);
+          i -= 2;
+        }
       }
-      // TODO: throw malformed if any present:
-      // Connection, Keep-Alive, Proxy-Connection, TE, Transfer-Encoding, Encoding, Upgrade.
       hpackWriter.writeHeaders(nameValueBlock);
       int type = TYPE_HEADERS;
       // TODO: implement CONTINUATION
@@ -354,7 +358,7 @@
       int length = 4;
       out.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
       out.writeInt(streamId & 0x7fffffff);
-      out.writeInt(errorCode.spdyRstCode);
+      out.writeInt(errorCode.httpCode);
       out.flush();
     }
 
@@ -367,6 +371,7 @@
       int type = TYPE_DATA;
       int flags = 0;
       if (outFinished) flags |= FLAG_END_STREAM;
+      // TODO: Implement looping strategy.
       checkFrameSize(byteCount);
       out.writeInt((byteCount & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
       out.writeInt(streamId & 0x7fffffff);
@@ -418,4 +423,19 @@
   private static IOException ioException(String message, Object... args) throws IOException {
     throw new IOException(String.format(message, args));
   }
+
+  /**
+   * Leniently drop as opposed to throwing malformed.
+   * http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3
+   */
+  private static boolean shouldDropHeader(String name) {
+    return name.equals("connection")
+        || name.equals("host") // host is not supported in http/2
+        || name.equals("keep-alive")
+        || name.equals("proxy-connection")
+        || name.equals("te")
+        || name.equals("transfer-encoding")
+        || name.equals("encoding")
+        || name.equals("upgrade");
+  }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
index f5b3a15..f8b13ae 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
@@ -40,7 +40,7 @@
   static final int HEADER_TABLE_SIZE = 1;
   /** spdy/3: Sender's estimate of max outgoing kbps. */
   static final int DOWNLOAD_BANDWIDTH = 2;
-  /** http/2: An endpoint must not send a PUSH_PROMISE frame this is 0. */
+  /** http/2: An endpoint must not send a PUSH_PROMISE frame when this is 0. */
   static final int ENABLE_PUSH = 2;
   /** spdy/3: Sender's estimate of millis between sending a request and receiving a response. */
   static final int ROUND_TRIP_TIME = 3;
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index 43fff2c..877fe20 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -22,20 +22,18 @@
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.List;
-import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
 
 public class HpackDraft05Test {
 
   private final MutableByteArrayInputStream bytesIn = new MutableByteArrayInputStream();
-  private final HpackDraft05.Reader hpackReader = new HpackDraft05.Reader(new DataInputStream(bytesIn));
+  private HpackDraft05.Reader hpackReader;
 
-  @After public void resetReader(){
-    hpackReader.reset();
+  @Before public void resetReader() {
+    hpackReader = new HpackDraft05.Reader(new DataInputStream(bytesIn));
   }
 
   /**
@@ -47,8 +45,9 @@
     Arrays.fill(tooLarge, 'a');
     final List<String> sentHeaders = Arrays.asList("foo", new String(tooLarge));
 
-    bytesIn.set(literalHeaders(sentHeaders));
-    hpackReader.readHeaders(bytesIn.available());
+    ByteArrayOutputStream out = literalHeaders(sentHeaders);
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
     assertEquals(0, hpackReader.headerTable.size());
@@ -70,16 +69,14 @@
     out.write("custom-header".getBytes(), 0, 13);
 
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(bytesIn.available());
+    hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
     assertEquals(1, hpackReader.headerTable.size());
+    assertEquals(55, hpackReader.headerTableSize);
 
     HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
-    assertEquals("custom-key", entry.name);
-    assertEquals("custom-header", entry.value);
-    assertEquals(55, entry.size);
-    assertEquals(entry.size, hpackReader.headerTableSize);
+    checkEntry(entry, "custom-key", "custom-header", 55, true);
 
     assertEquals(Arrays.asList("custom-key", "custom-header"), hpackReader.getAndReset());
   }
@@ -96,7 +93,7 @@
     out.write("/sample/path".getBytes(), 0, 12);
 
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(bytesIn.available());
+    hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
     assertEquals(0, hpackReader.headerTable.size());
@@ -114,16 +111,14 @@
                      // idx = 2 -> :method: GET
 
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(bytesIn.available());
+    hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
     assertEquals(1, hpackReader.headerTable.size());
+    assertEquals(42, hpackReader.headerTableSize);
 
     HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
-    assertEquals(":method", entry.name);
-    assertEquals("GET", entry.value);
-    assertEquals(42, entry.size);
-    assertEquals(entry.size, hpackReader.headerTableSize);
+    checkEntry(entry, ":method", "GET", 42, true);
 
     assertEquals(Arrays.asList(":method", "GET"), hpackReader.getAndReset());
   }
@@ -139,7 +134,7 @@
 
     bytesIn.set(out.toByteArray());
     hpackReader.maxHeaderTableSize = 0; // SETTINGS_HEADER_TABLE_SIZE == 0
-    hpackReader.readHeaders(bytesIn.available());
+    hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
     // Not buffered in header table.
@@ -152,23 +147,26 @@
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.2
    */
   @Test public void decodeRequestExamplesWithoutHuffman() throws IOException {
-    bytesIn.set(firstRequestWithoutHuffman());
-    hpackReader.readHeaders(bytesIn.available());
+    ByteArrayOutputStream out = firstRequestWithoutHuffman();
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
     checkFirstRequestWithoutHuffman();
 
-    bytesIn.set(secondRequestWithoutHuffman());
-    hpackReader.readHeaders(bytesIn.available());
+    out = secondRequestWithoutHuffman();
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
     checkSecondRequestWithoutHuffman();
 
-    bytesIn.set(thirdRequestWithoutHuffman());
-    hpackReader.readHeaders(bytesIn.available());
+    out = thirdRequestWithoutHuffman();
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
     checkThirdRequestWithoutHuffman();
   }
 
-  private byte[] firstRequestWithoutHuffman() {
+  private ByteArrayOutputStream firstRequestWithoutHuffman() {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
 
     out.write(0x82); // == Indexed - Add ==
@@ -182,7 +180,7 @@
     out.write(0x0f); // Literal value (len = 15)
     out.write("www.example.com".getBytes(), 0, 15);
 
-    return out.toByteArray();
+    return out;
   }
 
   private void checkFirstRequestWithoutHuffman() {
@@ -190,31 +188,19 @@
 
     // [  1] (s =  57) :authority: www.example.com
     HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
-    assertEquals(":authority", entry.name);
-    assertEquals("www.example.com", entry.value);
-    assertEquals(57, entry.size);
-    assertTrue(entry.referenced);
+    checkEntry(entry, ":authority", "www.example.com", 57, true);
 
     // [  2] (s =  38) :path: /
     entry = hpackReader.headerTable.get(1);
-    assertEquals(":path", entry.name);
-    assertEquals("/", entry.value);
-    assertEquals(38, entry.size);
-    assertTrue(entry.referenced);
+    checkEntry(entry, ":path", "/", 38, true);
 
     // [  3] (s =  43) :scheme: http
     entry = hpackReader.headerTable.get(2);
-    assertEquals(":scheme", entry.name);
-    assertEquals("http", entry.value);
-    assertEquals(43, entry.size);
-    assertTrue(entry.referenced);
+    checkEntry(entry, ":scheme", "http", 43, true);
 
     // [  4] (s =  42) :method: GET
     entry = hpackReader.headerTable.get(3);
-    assertEquals(":method", entry.name);
-    assertEquals("GET", entry.value);
-    assertEquals(42, entry.size);
-    assertTrue(entry.referenced);
+    checkEntry(entry, ":method", "GET", 42, true);
 
     // Table size: 180
     assertEquals(180, hpackReader.headerTableSize);
@@ -227,7 +213,7 @@
         ":authority", "www.example.com"), hpackReader.getAndReset());
   }
 
-  private byte[] secondRequestWithoutHuffman() {
+  private ByteArrayOutputStream secondRequestWithoutHuffman() {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
 
     out.write(0x1b); // == Literal indexed ==
@@ -235,7 +221,7 @@
     out.write(0x08); // Literal value (len = 8)
     out.write("no-cache".getBytes(), 0, 8);
 
-    return out.toByteArray();
+    return out;
   }
 
   private void checkSecondRequestWithoutHuffman() {
@@ -243,38 +229,23 @@
 
     // [  1] (s =  53) cache-control: no-cache
     HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
-    assertEquals("cache-control", entry.name);
-    assertEquals("no-cache", entry.value);
-    assertEquals(53, entry.size);
-    assertTrue(entry.referenced);
+    checkEntry(entry, "cache-control", "no-cache", 53, true);
 
     // [  2] (s =  57) :authority: www.example.com
     entry = hpackReader.headerTable.get(1);
-    assertEquals(":authority", entry.name);
-    assertEquals("www.example.com", entry.value);
-    assertEquals(57, entry.size);
-    assertTrue(entry.referenced);
+    checkEntry(entry, ":authority", "www.example.com", 57, true);
 
     // [  3] (s =  38) :path: /
     entry = hpackReader.headerTable.get(2);
-    assertEquals(":path", entry.name);
-    assertEquals("/", entry.value);
-    assertEquals(38, entry.size);
-    assertTrue(entry.referenced);
+    checkEntry(entry, ":path", "/", 38, true);
 
     // [  4] (s =  43) :scheme: http
     entry = hpackReader.headerTable.get(3);
-    assertEquals(":scheme", entry.name);
-    assertEquals("http", entry.value);
-    assertEquals(43, entry.size);
-    assertTrue(entry.referenced);
+    checkEntry(entry, ":scheme", "http", 43, true);
 
     // [  5] (s =  42) :method: GET
     entry = hpackReader.headerTable.get(4);
-    assertEquals(":method", entry.name);
-    assertEquals("GET", entry.value);
-    assertEquals(42, entry.size);
-    assertTrue(entry.referenced);
+    checkEntry(entry, ":method", "GET", 42, true);
 
     // Table size: 233
     assertEquals(233, hpackReader.headerTableSize);
@@ -288,7 +259,7 @@
         "cache-control", "no-cache"), hpackReader.getAndReset());
   }
 
-  private byte[] thirdRequestWithoutHuffman() {
+  private ByteArrayOutputStream thirdRequestWithoutHuffman() {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
 
     out.write(0x80); // == Empty reference set ==
@@ -306,7 +277,7 @@
     out.write(0x0c); // Literal value (len = 12)
     out.write("custom-value".getBytes(), 0, 12);
 
-    return out.toByteArray();
+    return out;
   }
 
   private void checkThirdRequestWithoutHuffman() {
@@ -314,59 +285,35 @@
 
     // [  1] (s =  54) custom-key: custom-value
     HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
-    assertEquals("custom-key", entry.name);
-    assertEquals("custom-value", entry.value);
-    assertEquals(54, entry.size);
-    assertTrue(entry.referenced);
+    checkEntry(entry, "custom-key", "custom-value", 54, true);
 
     // [  2] (s =  48) :path: /index.html
     entry = hpackReader.headerTable.get(1);
-    assertEquals(":path", entry.name);
-    assertEquals("/index.html", entry.value);
-    assertEquals(48, entry.size);
-    assertTrue(entry.referenced);
+    checkEntry(entry, ":path", "/index.html", 48, true);
 
     // [  3] (s =  44) :scheme: https
     entry = hpackReader.headerTable.get(2);
-    assertEquals(":scheme", entry.name);
-    assertEquals("https", entry.value);
-    assertEquals(44, entry.size);
-    assertTrue(entry.referenced);
+    checkEntry(entry, ":scheme", "https", 44, true);
 
     // [  4] (s =  53) cache-control: no-cache
     entry = hpackReader.headerTable.get(3);
-    assertEquals("cache-control", entry.name);
-    assertEquals("no-cache", entry.value);
-    assertEquals(53, entry.size);
-    assertFalse(entry.referenced);
+    checkEntry(entry, "cache-control", "no-cache", 53, false);
 
     // [  5] (s =  57) :authority: www.example.com
     entry = hpackReader.headerTable.get(4);
-    assertEquals(":authority", entry.name);
-    assertEquals("www.example.com", entry.value);
-    assertEquals(57, entry.size);
-    assertTrue(entry.referenced);
+    checkEntry(entry, ":authority", "www.example.com", 57, true);
 
     // [  6] (s =  38) :path: /
     entry = hpackReader.headerTable.get(5);
-    assertEquals(":path", entry.name);
-    assertEquals("/", entry.value);
-    assertEquals(38, entry.size);
-    assertFalse(entry.referenced);
+    checkEntry(entry, ":path", "/", 38, false);
 
     // [  7] (s =  43) :scheme: http
     entry = hpackReader.headerTable.get(6);
-    assertEquals(":scheme", entry.name);
-    assertEquals("http", entry.value);
-    assertEquals(43, entry.size);
-    assertFalse(entry.referenced);
+    checkEntry(entry, ":scheme", "http", 43, false);
 
     // [  8] (s =  42) :method: GET
     entry = hpackReader.headerTable.get(7);
-    assertEquals(":method", entry.name);
-    assertEquals("GET", entry.value);
-    assertEquals(42, entry.size);
-    assertTrue(entry.referenced);
+    checkEntry(entry, ":method", "GET", 42, true);
 
     // Table size: 379
     assertEquals(379, hpackReader.headerTableSize);
@@ -460,10 +407,18 @@
     return new DataInputStream(new ByteArrayInputStream(data));
   }
 
-  private byte[] literalHeaders(List<String> sentHeaders) throws IOException {
+  private ByteArrayOutputStream literalHeaders(List<String> sentHeaders) throws IOException {
     ByteArrayOutputStream headerBytes = new ByteArrayOutputStream();
     new HpackDraft05.Writer(new DataOutputStream(headerBytes)).writeHeaders(sentHeaders);
-    return headerBytes.toByteArray();
+    return headerBytes;
+  }
+
+  private void checkEntry(HpackDraft05.HeaderEntry entry, String name, String value, int size,
+      boolean referenced) {
+    assertEquals(name, entry.name);
+    assertEquals(value, entry.value);
+    assertEquals(size, entry.size);
+    assertEquals(referenced, entry.referenced);
   }
 
   private void assertBytes(int... bytes) {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index 17b236d..4331220 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -70,7 +70,7 @@
       8, 'h', 't', 't', 'p', '/', '1', '.', '1'
   };
 
-  private static final byte[] SPDY_AND_HTTP = new byte[] {
+  private static final byte[] SPDY3_AND_HTTP11 = new byte[] {
       6, 's', 'p', 'd', 'y', '/', '3',
       8, 'h', 't', 't', 'p', '/', '1', '.', '1'
   };
@@ -157,7 +157,7 @@
       } else if (route.address.transports.contains("HTTP-draft-09/2.0")) {
         platform.setNpnProtocols(sslSocket, HTTP2_AND_HTTP);
       } else {
-        platform.setNpnProtocols(sslSocket, SPDY_AND_HTTP);
+        platform.setNpnProtocols(sslSocket, SPDY3_AND_HTTP11);
       }
     }
 
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
index 412e3db..dfc962b 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
@@ -19,6 +19,8 @@
 
   public HttpOverHttp20Draft09Test() {
     super("HTTP-draft-09/2.0");
+    // TODO: is this really the whole authority, or just the host/port?
+    // https://github.com/http2/http2-spec/issues/334
     this.hostHeader = ":authority";
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
index 905641a..d5884b1 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -25,7 +25,6 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.net.InetSocketAddress;
-import java.net.NetworkInterface;
 import java.net.Socket;
 import java.net.SocketException;
 import java.net.URI;
@@ -135,27 +134,8 @@
     }
   }
 
-  /**
-   * Returns the maximum transmission unit of the network interface used by
-   * {@code socket}, or a reasonable default if this platform doesn't expose the
-   * MTU to the application layer.
-   *
-   * <p>The returned value should only be used as an optimization; such as to
-   * size buffers efficiently.
-   */
-  public int getMtu(Socket socket) throws IOException {
-    return 1400; // Smaller than 1500 to leave room for headers on interfaces like PPPoE.
-  }
-
   /** Attempt to match the host runtime to a capable Platform implementation. */
   private static Platform findPlatform() {
-    Method getMtu;
-    try {
-      getMtu = NetworkInterface.class.getMethod("getMTU");
-    } catch (NoSuchMethodException e) {
-      return new Platform(); // No Java 1.6 APIs. It's either Java 1.5, Android 2.2 or earlier.
-    }
-
     // Attempt to find Android 2.3+ APIs.
     Class<?> openSslSocketClass;
     Method setUseSessionTickets;
@@ -176,10 +156,10 @@
       try {
         Method setNpnProtocols = openSslSocketClass.getMethod("setNpnProtocols", byte[].class);
         Method getNpnSelectedProtocol = openSslSocketClass.getMethod("getNpnSelectedProtocol");
-        return new Android41(getMtu, openSslSocketClass, setUseSessionTickets, setHostname,
+        return new Android41(openSslSocketClass, setUseSessionTickets, setHostname,
             setNpnProtocols, getNpnSelectedProtocol);
       } catch (NoSuchMethodException ignored) {
-        return new Android23(getMtu, openSslSocketClass, setUseSessionTickets, setHostname);
+        return new Android23(openSslSocketClass, setUseSessionTickets, setHostname);
       }
     } catch (ClassNotFoundException ignored) {
       // This isn't an Android runtime.
@@ -196,56 +176,25 @@
       Class<?> serverProviderClass = Class.forName(npnClassName + "$ServerProvider");
       Method putMethod = nextProtoNegoClass.getMethod("put", SSLSocket.class, providerClass);
       Method getMethod = nextProtoNegoClass.getMethod("get", SSLSocket.class);
-      return new JdkWithJettyNpnPlatform(getMtu, putMethod, getMethod, clientProviderClass,
-          serverProviderClass);
+      return new JdkWithJettyNpnPlatform(
+          putMethod, getMethod, clientProviderClass, serverProviderClass);
     } catch (ClassNotFoundException ignored) {
       // NPN isn't on the classpath.
     } catch (NoSuchMethodException ignored) {
       // The NPN version isn't what we expect.
     }
 
-    return new Java6(getMtu);
-  }
-
-  private static class Java6 extends Platform {
-    private final Method getMtu;
-
-    private Java6(Method getMtu) {
-      this.getMtu = getMtu;
-    }
-
-    @Override public int getMtu(Socket socket) throws IOException {
-      try {
-        NetworkInterface networkInterface = NetworkInterface.getByInetAddress(
-            socket.getLocalAddress());
-        if (networkInterface == null) {
-          return super.getMtu(socket); // There's no longer an interface with this local address.
-        }
-        return (Integer) getMtu.invoke(networkInterface);
-      } catch (NullPointerException e) {
-        // Certain Alcatel devices throw on getByInetAddress. Return default.
-        return super.getMtu(socket);
-      } catch (SocketException e) {
-        // Certain Motorola devices always throw on getByInetAddress. Return the default for those.
-        return super.getMtu(socket);
-      } catch (IllegalAccessException e) {
-        throw new AssertionError(e);
-      } catch (InvocationTargetException e) {
-        if (e.getCause() instanceof IOException) throw (IOException) e.getCause();
-        throw new RuntimeException(e.getCause());
-      }
-    }
+    return new Platform();
   }
 
   /** Android version 2.3 and newer support TLS session tickets and server name indication (SNI). */
-  private static class Android23 extends Java6 {
+  private static class Android23 extends Platform {
     protected final Class<?> openSslSocketClass;
     private final Method setUseSessionTickets;
     private final Method setHostname;
 
-    private Android23(Method getMtu, Class<?> openSslSocketClass, Method setUseSessionTickets,
-        Method setHostname) {
-      super(getMtu);
+    private Android23(
+        Class<?> openSslSocketClass, Method setUseSessionTickets, Method setHostname) {
       this.openSslSocketClass = openSslSocketClass;
       this.setUseSessionTickets = setUseSessionTickets;
       this.setHostname = setHostname;
@@ -285,9 +234,9 @@
     private final Method setNpnProtocols;
     private final Method getNpnSelectedProtocol;
 
-    private Android41(Method getMtu, Class<?> openSslSocketClass, Method setUseSessionTickets,
-        Method setHostname, Method setNpnProtocols, Method getNpnSelectedProtocol) {
-      super(getMtu, openSslSocketClass, setUseSessionTickets, setHostname);
+    private Android41(Class<?> openSslSocketClass, Method setUseSessionTickets, Method setHostname,
+        Method setNpnProtocols, Method getNpnSelectedProtocol) {
+      super(openSslSocketClass, setUseSessionTickets, setHostname);
       this.setNpnProtocols = setNpnProtocols;
       this.getNpnSelectedProtocol = getNpnSelectedProtocol;
     }
@@ -320,15 +269,14 @@
   }
 
   /** OpenJDK 7 plus {@code org.mortbay.jetty.npn/npn-boot} on the boot class path. */
-  private static class JdkWithJettyNpnPlatform extends Java6 {
+  private static class JdkWithJettyNpnPlatform extends Platform {
     private final Method getMethod;
     private final Method putMethod;
     private final Class<?> clientProviderClass;
     private final Class<?> serverProviderClass;
 
-    public JdkWithJettyNpnPlatform(Method getMtu, Method putMethod, Method getMethod,
-        Class<?> clientProviderClass, Class<?> serverProviderClass) {
-      super(getMtu);
+    public JdkWithJettyNpnPlatform(Method putMethod, Method getMethod, Class<?> clientProviderClass,
+        Class<?> serverProviderClass) {
       this.putMethod = putMethod;
       this.getMethod = getMethod;
       this.clientProviderClass = clientProviderClass;
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 9d5ffb1..c9b08f2 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -70,11 +70,6 @@
  * replays them upon request in sequence.
  */
 public final class MockWebServer {
-  private static final byte[] NPN_PROTOCOLS = {
-      17, 'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '6', '/', '2', '.', '0',
-      6, 's', 'p', 'd', 'y', '/', '3',
-      8, 'h', 't', 't', 'p', '/', '1', '.', '1'
-  };
   private static final byte[] HTTP_20_DRAFT_09 = new byte[] {
       'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '9', '/', '2', '.', '0'
   };
@@ -84,6 +79,20 @@
   private static final byte[] HTTP_11 = new byte[] {
       'h', 't', 't', 'p', '/', '1', '.', '1'
   };
+  private static final byte[] NPN_PROTOCOLS = joinNpnProtocols(HTTP_20_DRAFT_09, SPDY3, HTTP_11);
+
+  private static byte[] joinNpnProtocols(byte[]... protocols) {
+    try {
+      ByteArrayOutputStream baos = new ByteArrayOutputStream();
+      for (byte[] protocol : protocols) {
+        baos.write(protocol.length);
+        baos.write(protocol);
+      }
+      return baos.toByteArray();
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+  }
 
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
     @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index ef98fe9..1c8d439 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -19,21 +19,23 @@
     final ByteString name;
     final ByteString value;
     final int size;
-    // read when in headerTable
+    // Static entries can be shared safely, as long as {@code referenced} is not mutated.
+    final boolean isStatic;
+    // Only read when in headerTable.
+    // Mutable to avoid needing another BitSet for referenced header indexes.  Using a BitSet for
+    // reference entries sounds good, except that entries are added at index zero.  This implies
+    // shifting the BitSet, which would be expensive to implement.
     boolean referenced = true;
 
-    HeaderEntry(ByteString name, ByteString value) {
-      this(name, value, 32 + name.size() + value.size());
+    HeaderEntry(ByteString name, ByteString value, boolean isStatic) {
+      this(name, value, 32 + name.size() + value.size(), isStatic);
     }
 
-    HeaderEntry(String name, String value) {
-      this(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value));
-    }
-
-    private HeaderEntry(ByteString name, ByteString value, int size) {
+    private HeaderEntry(ByteString name, ByteString value, int size, boolean isStatic) {
       this.name = name;
       this.value = value;
       this.size = size;
+      this.isStatic = isStatic;
     }
 
     /** Adds name and value, if this entry is referenced. */
@@ -43,8 +45,9 @@
       out.add(value);
     }
 
+    /** Copies this header entry and designates it as not a static entry. */
     @Override public HeaderEntry clone() {
-      return new HeaderEntry(name, value, size);
+      return new HeaderEntry(name, value, size, false);
     }
   }
 
@@ -53,66 +56,66 @@
   private static final int PREFIX_8_BITS = 0xff;
 
   private static final HeaderEntry[] STATIC_HEADER_TABLE = new HeaderEntry[] {
-      new HeaderEntry(":authority", ""),
-      new HeaderEntry(":method", "GET"),
-      new HeaderEntry(":method", "POST"),
-      new HeaderEntry(":path", "/"),
-      new HeaderEntry(":path", "/index.html"),
-      new HeaderEntry(":scheme", "http"),
-      new HeaderEntry(":scheme", "https"),
-      new HeaderEntry(":status", "200"),
-      new HeaderEntry(":status", "500"),
-      new HeaderEntry(":status", "404"),
-      new HeaderEntry(":status", "403"),
-      new HeaderEntry(":status", "400"),
-      new HeaderEntry(":status", "401"),
-      new HeaderEntry("accept-charset", ""),
-      new HeaderEntry("accept-encoding", ""),
-      new HeaderEntry("accept-language", ""),
-      new HeaderEntry("accept-ranges", ""),
-      new HeaderEntry("accept", ""),
-      new HeaderEntry("access-control-allow-origin", ""),
-      new HeaderEntry("age", ""),
-      new HeaderEntry("allow", ""),
-      new HeaderEntry("authorization", ""),
-      new HeaderEntry("cache-control", ""),
-      new HeaderEntry("content-disposition", ""),
-      new HeaderEntry("content-encoding", ""),
-      new HeaderEntry("content-language", ""),
-      new HeaderEntry("content-length", ""),
-      new HeaderEntry("content-location", ""),
-      new HeaderEntry("content-range", ""),
-      new HeaderEntry("content-type", ""),
-      new HeaderEntry("cookie", ""),
-      new HeaderEntry("date", ""),
-      new HeaderEntry("etag", ""),
-      new HeaderEntry("expect", ""),
-      new HeaderEntry("expires", ""),
-      new HeaderEntry("from", ""),
-      new HeaderEntry("host", ""),
-      new HeaderEntry("if-match", ""),
-      new HeaderEntry("if-modified-since", ""),
-      new HeaderEntry("if-none-match", ""),
-      new HeaderEntry("if-range", ""),
-      new HeaderEntry("if-unmodified-since", ""),
-      new HeaderEntry("last-modified", ""),
-      new HeaderEntry("link", ""),
-      new HeaderEntry("location", ""),
-      new HeaderEntry("max-forwards", ""),
-      new HeaderEntry("proxy-authenticate", ""),
-      new HeaderEntry("proxy-authorization", ""),
-      new HeaderEntry("range", ""),
-      new HeaderEntry("referer", ""),
-      new HeaderEntry("refresh", ""),
-      new HeaderEntry("retry-after", ""),
-      new HeaderEntry("server", ""),
-      new HeaderEntry("set-cookie", ""),
-      new HeaderEntry("strict-transport-security", ""),
-      new HeaderEntry("transfer-encoding", ""),
-      new HeaderEntry("user-agent", ""),
-      new HeaderEntry("vary", ""),
-      new HeaderEntry("via", ""),
-      new HeaderEntry("www-authenticate", "")
+      staticEntry(":authority", ""),
+      staticEntry(":method", "GET"),
+      staticEntry(":method", "POST"),
+      staticEntry(":path", "/"),
+      staticEntry(":path", "/index.html"),
+      staticEntry(":scheme", "http"),
+      staticEntry(":scheme", "https"),
+      staticEntry(":status", "200"),
+      staticEntry(":status", "500"),
+      staticEntry(":status", "404"),
+      staticEntry(":status", "403"),
+      staticEntry(":status", "400"),
+      staticEntry(":status", "401"),
+      staticEntry("accept-charset", ""),
+      staticEntry("accept-encoding", ""),
+      staticEntry("accept-language", ""),
+      staticEntry("accept-ranges", ""),
+      staticEntry("accept", ""),
+      staticEntry("access-control-allow-origin", ""),
+      staticEntry("age", ""),
+      staticEntry("allow", ""),
+      staticEntry("authorization", ""),
+      staticEntry("cache-control", ""),
+      staticEntry("content-disposition", ""),
+      staticEntry("content-encoding", ""),
+      staticEntry("content-language", ""),
+      staticEntry("content-length", ""),
+      staticEntry("content-location", ""),
+      staticEntry("content-range", ""),
+      staticEntry("content-type", ""),
+      staticEntry("cookie", ""),
+      staticEntry("date", ""),
+      staticEntry("etag", ""),
+      staticEntry("expect", ""),
+      staticEntry("expires", ""),
+      staticEntry("from", ""),
+      staticEntry("host", ""),
+      staticEntry("if-match", ""),
+      staticEntry("if-modified-since", ""),
+      staticEntry("if-none-match", ""),
+      staticEntry("if-range", ""),
+      staticEntry("if-unmodified-since", ""),
+      staticEntry("last-modified", ""),
+      staticEntry("link", ""),
+      staticEntry("location", ""),
+      staticEntry("max-forwards", ""),
+      staticEntry("proxy-authenticate", ""),
+      staticEntry("proxy-authorization", ""),
+      staticEntry("range", ""),
+      staticEntry("referer", ""),
+      staticEntry("refresh", ""),
+      staticEntry("retry-after", ""),
+      staticEntry("server", ""),
+      staticEntry("set-cookie", ""),
+      staticEntry("strict-transport-security", ""),
+      staticEntry("transfer-encoding", ""),
+      staticEntry("user-agent", ""),
+      staticEntry("vary", ""),
+      staticEntry("via", ""),
+      staticEntry("www-authenticate", "")
   };
 
   private HpackDraft05() {
@@ -173,7 +176,14 @@
     private void clearReferenceSet() {
       staticReferenceSet.clear();
       for (int i = 0, size = headerTable.size(); i < size; i++) {
-        headerTable.get(i).referenced = false;
+        HeaderEntry entry = headerTable.get(i);
+        if (entry.isStatic) { // lazy clone static entries on mutation.
+          entry = entry.clone();
+          entry.referenced = false;
+          headerTable.set(i, entry);
+        } else {
+          entry.referenced = false;
+        }
       }
     }
 
@@ -203,8 +213,8 @@
           staticReferenceSet.set(index - headerTable.size());
         } else {
           HeaderEntry staticEntry = STATIC_HEADER_TABLE[index - headerTable.size()];
-          insertIntoHeaderTable(-1, staticEntry.clone());
-        }
+          insertIntoHeaderTable(-1, staticEntry);
+       }
       } else if (!headerTable.get(index).referenced) {
         HeaderEntry existing = headerTable.get(index);
         existing.referenced = true;
@@ -235,13 +245,13 @@
         throws IOException {
       ByteString name = getName(nameIndex);
       ByteString value = readString();
-      insertIntoHeaderTable(-1, new HeaderEntry(name, value));
+      insertIntoHeaderTable(-1, new HeaderEntry(name, value, false));
     }
 
     private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
       ByteString name = readString();
       ByteString value = readString();
-      insertIntoHeaderTable(-1, new HeaderEntry(name, value));
+      insertIntoHeaderTable(-1, new HeaderEntry(name, value, false));
     }
 
     private ByteString getName(int index) {
@@ -373,4 +383,8 @@
       data.write(out);
     }
   }
+
+  private static HeaderEntry staticEntry(String name, String value) {
+    return new HeaderEntry(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value), true);
+  }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Job.java b/okhttp/src/main/java/com/squareup/okhttp/Job.java
index 72abbcc..a9286ad 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Job.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Job.java
@@ -44,6 +44,7 @@
 
   /** The request; possibly a consequence of redirects or auth headers. */
   private Request request;
+  private HttpEngine engine;
 
   public Job(Dispatcher dispatcher, OkHttpClient client, Request request,
       Response.Receiver responseReceiver) {
@@ -66,6 +67,8 @@
   }
 
   @Override public void run() {
+    String oldName = Thread.currentThread().getName();
+    Thread.currentThread().setName("OkHttp " + request.urlString());
     try {
       Response response = execute();
       if (response != null && !canceled) {
@@ -77,8 +80,8 @@
           .exception(e)
           .build());
     } finally {
-      // TODO: close the response body
-      // TODO: release the HTTP engine
+      engine.release(true); // Release the connection if it isn't already released.
+      Thread.currentThread().setName(oldName);
       dispatcher.finished(this);
     }
   }
@@ -114,7 +117,7 @@
         request = requestBuilder.build();
       }
 
-      HttpEngine engine = new HttpEngine(client, request, false, connection, null);
+      engine = new HttpEngine(client, request, false, connection, null);
       engine.sendRequest();
 
       if (body != null) {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Headers.java b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
index 19b349f..7753d9f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Headers.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
@@ -17,8 +17,8 @@
 
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Util;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
@@ -43,10 +43,10 @@
  * instances.
  */
 public final class Headers {
-  private final List<String> namesAndValues;
+  private final String[] namesAndValues;
 
   private Headers(Builder builder) {
-    this.namesAndValues = Util.immutableList(builder.namesAndValues);
+    this.namesAndValues = builder.namesAndValues.toArray(new String[builder.namesAndValues.size()]);
   }
 
   /** Returns the last value corresponding to the specified field, or null. */
@@ -56,25 +56,25 @@
 
   /** Returns the number of field values. */
   public int size() {
-    return namesAndValues.size() / 2;
+    return namesAndValues.length / 2;
   }
 
   /** Returns the field at {@code position} or null if that is out of range. */
   public String name(int index) {
     int fieldNameIndex = index * 2;
-    if (fieldNameIndex < 0 || fieldNameIndex >= namesAndValues.size()) {
+    if (fieldNameIndex < 0 || fieldNameIndex >= namesAndValues.length) {
       return null;
     }
-    return namesAndValues.get(fieldNameIndex);
+    return namesAndValues[fieldNameIndex];
   }
 
   /** Returns the value at {@code index} or null if that is out of range. */
   public String value(int index) {
     int valueIndex = index * 2 + 1;
-    if (valueIndex < 0 || valueIndex >= namesAndValues.size()) {
+    if (valueIndex < 0 || valueIndex >= namesAndValues.length) {
       return null;
     }
-    return namesAndValues.get(valueIndex);
+    return namesAndValues[valueIndex];
   }
 
   /** Returns an immutable case-insensitive set of header names. */
@@ -104,10 +104,10 @@
   // TODO: it is very weird to request a case-insensitive set as a parameter.
   public Headers getAll(Set<String> fieldNames) {
     Builder result = new Builder();
-    for (int i = 0; i < namesAndValues.size(); i += 2) {
-      String fieldName = namesAndValues.get(i);
+    for (int i = 0; i < namesAndValues.length; i += 2) {
+      String fieldName = namesAndValues[i];
       if (fieldNames.contains(fieldName)) {
-        result.add(fieldName, namesAndValues.get(i + 1));
+        result.add(fieldName, namesAndValues[i + 1]);
       }
     }
     return result.build();
@@ -115,14 +115,14 @@
 
   public Builder newBuilder() {
     Builder result = new Builder();
-    result.namesAndValues.addAll(namesAndValues);
+    result.namesAndValues.addAll(Arrays.asList(namesAndValues));
     return result;
   }
 
-  private static String get(List<String> namesAndValues, String fieldName) {
-    for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
-      if (fieldName.equalsIgnoreCase(namesAndValues.get(i))) {
-        return namesAndValues.get(i + 1);
+  private static String get(String[] namesAndValues, String fieldName) {
+    for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {
+      if (fieldName.equalsIgnoreCase(namesAndValues[i])) {
+        return namesAndValues[i + 1];
       }
     }
     return null;
@@ -187,7 +187,12 @@
 
     /** Equivalent to {@code build().get(fieldName)}, but potentially faster. */
     public String get(String fieldName) {
-      return Headers.get(namesAndValues, fieldName);
+      for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
+        if (fieldName.equalsIgnoreCase(namesAndValues.get(i))) {
+          return namesAndValues.get(i + 1);
+        }
+      }
+      return null;
     }
 
     public Headers build() {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index 1c8d439..80065e4 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -5,12 +5,19 @@
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.ArrayList;
-import java.util.BitSet;
+import java.util.Arrays;
 import java.util.List;
 
 /**
  * Read and write HPACK v05.
+ *
  * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05
+ *
+ * This implementation uses an array for the header table with a bitset for
+ * references.  Dynamic entries are added to the array, starting in the last
+ * position moving forward.  When the array fills, it is doubled, up to the
+ * supported maximum of 64 headers.  HTTP requests or responses that require
+ * more than 64 headers are hence not currently supported.
  */
 final class HpackDraft05 {
 
@@ -19,35 +26,19 @@
     final ByteString name;
     final ByteString value;
     final int size;
-    // Static entries can be shared safely, as long as {@code referenced} is not mutated.
-    final boolean isStatic;
-    // Only read when in headerTable.
-    // Mutable to avoid needing another BitSet for referenced header indexes.  Using a BitSet for
-    // reference entries sounds good, except that entries are added at index zero.  This implies
-    // shifting the BitSet, which would be expensive to implement.
-    boolean referenced = true;
 
-    HeaderEntry(ByteString name, ByteString value, boolean isStatic) {
-      this(name, value, 32 + name.size() + value.size(), isStatic);
+    HeaderEntry(String name, String value) {
+      this(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value));
     }
 
-    private HeaderEntry(ByteString name, ByteString value, int size, boolean isStatic) {
+    HeaderEntry(ByteString name, ByteString value) {
+      this(name, value, 32 + name.size() + value.size());
+    }
+
+    private HeaderEntry(ByteString name, ByteString value, int size) {
       this.name = name;
       this.value = value;
       this.size = size;
-      this.isStatic = isStatic;
-    }
-
-    /** Adds name and value, if this entry is referenced. */
-    void addTo(List<ByteString> out) {
-      if (!referenced) return;
-      out.add(name);
-      out.add(value);
-    }
-
-    /** Copies this header entry and designates it as not a static entry. */
-    @Override public HeaderEntry clone() {
-      return new HeaderEntry(name, value, size, false);
     }
   }
 
@@ -56,66 +47,66 @@
   private static final int PREFIX_8_BITS = 0xff;
 
   private static final HeaderEntry[] STATIC_HEADER_TABLE = new HeaderEntry[] {
-      staticEntry(":authority", ""),
-      staticEntry(":method", "GET"),
-      staticEntry(":method", "POST"),
-      staticEntry(":path", "/"),
-      staticEntry(":path", "/index.html"),
-      staticEntry(":scheme", "http"),
-      staticEntry(":scheme", "https"),
-      staticEntry(":status", "200"),
-      staticEntry(":status", "500"),
-      staticEntry(":status", "404"),
-      staticEntry(":status", "403"),
-      staticEntry(":status", "400"),
-      staticEntry(":status", "401"),
-      staticEntry("accept-charset", ""),
-      staticEntry("accept-encoding", ""),
-      staticEntry("accept-language", ""),
-      staticEntry("accept-ranges", ""),
-      staticEntry("accept", ""),
-      staticEntry("access-control-allow-origin", ""),
-      staticEntry("age", ""),
-      staticEntry("allow", ""),
-      staticEntry("authorization", ""),
-      staticEntry("cache-control", ""),
-      staticEntry("content-disposition", ""),
-      staticEntry("content-encoding", ""),
-      staticEntry("content-language", ""),
-      staticEntry("content-length", ""),
-      staticEntry("content-location", ""),
-      staticEntry("content-range", ""),
-      staticEntry("content-type", ""),
-      staticEntry("cookie", ""),
-      staticEntry("date", ""),
-      staticEntry("etag", ""),
-      staticEntry("expect", ""),
-      staticEntry("expires", ""),
-      staticEntry("from", ""),
-      staticEntry("host", ""),
-      staticEntry("if-match", ""),
-      staticEntry("if-modified-since", ""),
-      staticEntry("if-none-match", ""),
-      staticEntry("if-range", ""),
-      staticEntry("if-unmodified-since", ""),
-      staticEntry("last-modified", ""),
-      staticEntry("link", ""),
-      staticEntry("location", ""),
-      staticEntry("max-forwards", ""),
-      staticEntry("proxy-authenticate", ""),
-      staticEntry("proxy-authorization", ""),
-      staticEntry("range", ""),
-      staticEntry("referer", ""),
-      staticEntry("refresh", ""),
-      staticEntry("retry-after", ""),
-      staticEntry("server", ""),
-      staticEntry("set-cookie", ""),
-      staticEntry("strict-transport-security", ""),
-      staticEntry("transfer-encoding", ""),
-      staticEntry("user-agent", ""),
-      staticEntry("vary", ""),
-      staticEntry("via", ""),
-      staticEntry("www-authenticate", "")
+      new HeaderEntry(":authority", ""),
+      new HeaderEntry(":method", "GET"),
+      new HeaderEntry(":method", "POST"),
+      new HeaderEntry(":path", "/"),
+      new HeaderEntry(":path", "/index.html"),
+      new HeaderEntry(":scheme", "http"),
+      new HeaderEntry(":scheme", "https"),
+      new HeaderEntry(":status", "200"),
+      new HeaderEntry(":status", "500"),
+      new HeaderEntry(":status", "404"),
+      new HeaderEntry(":status", "403"),
+      new HeaderEntry(":status", "400"),
+      new HeaderEntry(":status", "401"),
+      new HeaderEntry("accept-charset", ""),
+      new HeaderEntry("accept-encoding", ""),
+      new HeaderEntry("accept-language", ""),
+      new HeaderEntry("accept-ranges", ""),
+      new HeaderEntry("accept", ""),
+      new HeaderEntry("access-control-allow-origin", ""),
+      new HeaderEntry("age", ""),
+      new HeaderEntry("allow", ""),
+      new HeaderEntry("authorization", ""),
+      new HeaderEntry("cache-control", ""),
+      new HeaderEntry("content-disposition", ""),
+      new HeaderEntry("content-encoding", ""),
+      new HeaderEntry("content-language", ""),
+      new HeaderEntry("content-length", ""),
+      new HeaderEntry("content-location", ""),
+      new HeaderEntry("content-range", ""),
+      new HeaderEntry("content-type", ""),
+      new HeaderEntry("cookie", ""),
+      new HeaderEntry("date", ""),
+      new HeaderEntry("etag", ""),
+      new HeaderEntry("expect", ""),
+      new HeaderEntry("expires", ""),
+      new HeaderEntry("from", ""),
+      new HeaderEntry("host", ""),
+      new HeaderEntry("if-match", ""),
+      new HeaderEntry("if-modified-since", ""),
+      new HeaderEntry("if-none-match", ""),
+      new HeaderEntry("if-range", ""),
+      new HeaderEntry("if-unmodified-since", ""),
+      new HeaderEntry("last-modified", ""),
+      new HeaderEntry("link", ""),
+      new HeaderEntry("location", ""),
+      new HeaderEntry("max-forwards", ""),
+      new HeaderEntry("proxy-authenticate", ""),
+      new HeaderEntry("proxy-authorization", ""),
+      new HeaderEntry("range", ""),
+      new HeaderEntry("referer", ""),
+      new HeaderEntry("refresh", ""),
+      new HeaderEntry("retry-after", ""),
+      new HeaderEntry("server", ""),
+      new HeaderEntry("set-cookie", ""),
+      new HeaderEntry("strict-transport-security", ""),
+      new HeaderEntry("transfer-encoding", ""),
+      new HeaderEntry("user-agent", ""),
+      new HeaderEntry("vary", ""),
+      new HeaderEntry("via", ""),
+      new HeaderEntry("www-authenticate", "")
   };
 
   private HpackDraft05() {
@@ -129,10 +120,25 @@
     private long bytesLeft = 0;
 
     // Visible for testing.
-    final List<HeaderEntry> headerTable = new ArrayList<HeaderEntry>(5); // average of 5 headers
-    final BitSet staticReferenceSet = new BitSet();
-    long headerTableSize = 0;
-    long maxHeaderTableSize = 4096; // TODO: needs to come from SETTINGS_HEADER_TABLE_SIZE.
+    HeaderEntry[] headerTable = new HeaderEntry[8]; // must be less than 64
+    // Array is populated back to front, so new entries always have lowest index.
+    int nextHeaderIndex = headerTable.length - 1;
+    int headerCount = 0;
+
+    /**
+     * Set bit positions indicate {@code headerTable[pos]} should be emitted.
+     */
+    // Using a long since the reference table < 64 entries.
+    long referencedHeaders = 0x0000000000000000L;
+
+    /**
+     * Set bit positions indicate {@code STATIC_HEADER_TABLE[pos]} should be
+     * emitted.
+     */
+    // Using a long since the static table < 64 entries.
+    long referencedStaticHeaders = 0x0000000000000000L;
+    int headerTableByteCount = 0;
+    int maxHeaderTableByteCount = 4096; // TODO: needs to come from SETTINGS_HEADER_TABLE_SIZE.
 
     Reader(DataInputStream in) {
       this.in = in;
@@ -149,51 +155,47 @@
       while (bytesLeft > 0) {
         int b = readByte();
 
-        if ((b & 0x80) != 0) {
+        if (b == 0x80) { // 10000000
+          clearReferenceSet();
+        } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
           int index = readInt(b, PREFIX_7_BITS);
-          if (index == 0) {
-            clearReferenceSet();
+          readIndexedHeader(index - 1);
+        } else { // 0NNNNNNN
+          if (b == 0x40) { // 01000000
+            readLiteralHeaderWithoutIndexingNewName();
+          } else if ((b & 0xe0) == 0x40) {  // 01NNNNNN
+            int index = readInt(b, PREFIX_6_BITS);
+            readLiteralHeaderWithoutIndexingIndexedName(index - 1);
+          } else if (b == 0) { // 00000000
+            readLiteralHeaderWithIncrementalIndexingNewName();
+          } else if ((b & 0xc0) == 0) { // 00NNNNNN
+            int index = readInt(b, PREFIX_6_BITS);
+            readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
           } else {
-            readIndexedHeader(index - 1);
+            // TODO: we should throw something that we can coerce to a PROTOCOL_ERROR
+            throw new AssertionError("unhandled byte: " + Integer.toBinaryString(b));
           }
-        } else if (b == 0x40) {
-          readLiteralHeaderWithoutIndexingNewName();
-        } else if ((b & 0xe0) == 0x40) {
-          int index = readInt(b, PREFIX_6_BITS);
-          readLiteralHeaderWithoutIndexingIndexedName(index - 1);
-        } else if (b == 0) {
-          readLiteralHeaderWithIncrementalIndexingNewName();
-        } else if ((b & 0xc0) == 0) {
-          int index = readInt(b, PREFIX_6_BITS);
-          readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
-        } else {
-          // TODO: we should throw something that we can coerce to a PROTOCOL_ERROR
-          throw new AssertionError("unhandled byte: " + Integer.toBinaryString(b));
         }
       }
     }
 
     private void clearReferenceSet() {
-      staticReferenceSet.clear();
-      for (int i = 0, size = headerTable.size(); i < size; i++) {
-        HeaderEntry entry = headerTable.get(i);
-        if (entry.isStatic) { // lazy clone static entries on mutation.
-          entry = entry.clone();
-          entry.referenced = false;
-          headerTable.set(i, entry);
-        } else {
-          entry.referenced = false;
-        }
-      }
+      referencedStaticHeaders = 0x0000000000000000L;
+      referencedHeaders = 0x0000000000000000L;
     }
 
     public void emitReferenceSet() {
-      for (int i = staticReferenceSet.nextSetBit(0); i != -1;
-          i = staticReferenceSet.nextSetBit(i + 1)) {
-        STATIC_HEADER_TABLE[i].addTo(emittedHeaders);
+      for (int i = 0; i < STATIC_HEADER_TABLE.length; ++i) {
+        if (bitPositionSet(referencedStaticHeaders, i)) {
+          emittedHeaders.add(STATIC_HEADER_TABLE[i].name);
+          emittedHeaders.add(STATIC_HEADER_TABLE[i].value);
+        }
       }
-      for (int i = headerTable.size() - 1; i != -1; i--) {
-        headerTable.get(i).addTo(emittedHeaders);
+      for (int i = headerTable.length - 1; i != nextHeaderIndex; --i) {
+        if (bitPositionSet(referencedHeaders, i)) {
+          emittedHeaders.add(headerTable[i].name);
+          emittedHeaders.add(headerTable[i].value);
+        }
       }
     }
 
@@ -208,33 +210,36 @@
     }
 
     private void readIndexedHeader(int index) {
+
       if (isStaticHeader(index)) {
-        if (maxHeaderTableSize == 0) {
-          staticReferenceSet.set(index - headerTable.size());
+        if (maxHeaderTableByteCount == 0) {
+          // Set bit designating this static entry is referenced.
+          referencedStaticHeaders |= (1L << (index - headerCount));
         } else {
-          HeaderEntry staticEntry = STATIC_HEADER_TABLE[index - headerTable.size()];
+          HeaderEntry staticEntry = STATIC_HEADER_TABLE[index - headerCount];
           insertIntoHeaderTable(-1, staticEntry);
-       }
-      } else if (!headerTable.get(index).referenced) {
-        HeaderEntry existing = headerTable.get(index);
-        existing.referenced = true;
-        insertIntoHeaderTable(index, existing);
+        }
+      } else if (!bitPositionSet(referencedHeaders, headerTableIndex(index))) {
+        referencedHeaders |= (1L << headerTableIndex(index));
       } else {
         // TODO: we should throw something that we can coerce to a PROTOCOL_ERROR
         throw new AssertionError("invalid index " + index);
       }
     }
 
-    private void readLiteralHeaderWithoutIndexingIndexedName(int index)
-        throws IOException {
+    // referencedHeaders is relative to nextHeaderIndex + 1.
+    private int headerTableIndex(int index) {
+      return nextHeaderIndex + 1 + index;
+    }
+
+    private void readLiteralHeaderWithoutIndexingIndexedName(int index) throws IOException {
       ByteString name = getName(index);
       ByteString value = readString();
       emittedHeaders.add(name);
       emittedHeaders.add(value);
     }
 
-    private void readLiteralHeaderWithoutIndexingNewName()
-        throws IOException {
+    private void readLiteralHeaderWithoutIndexingNewName() throws IOException {
       ByteString name = readString();
       ByteString value = readString();
       emittedHeaders.add(name);
@@ -245,60 +250,89 @@
         throws IOException {
       ByteString name = getName(nameIndex);
       ByteString value = readString();
-      insertIntoHeaderTable(-1, new HeaderEntry(name, value, false));
+      insertIntoHeaderTable(-1, new HeaderEntry(name, value));
     }
 
     private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
       ByteString name = readString();
       ByteString value = readString();
-      insertIntoHeaderTable(-1, new HeaderEntry(name, value, false));
+      insertIntoHeaderTable(-1, new HeaderEntry(name, value));
     }
 
     private ByteString getName(int index) {
       if (isStaticHeader(index)) {
-        return STATIC_HEADER_TABLE[index - headerTable.size()].name;
+        return STATIC_HEADER_TABLE[index - headerCount].name;
       } else {
-        return headerTable.get(index).name;
+        return headerTable[headerTableIndex(index)].name;
       }
     }
 
     private boolean isStaticHeader(int index) {
-      return index >= headerTable.size();
+      return index >= headerCount;
     }
 
     /** index == -1 when new. */
     private void insertIntoHeaderTable(int index, HeaderEntry entry) {
       int delta = entry.size;
       if (index != -1) { // Index -1 == new header.
-        delta -= headerTable.get(index).size;
+        delta -= headerTable[headerTableIndex(index)].size;
       }
 
       // if the new or replacement header is too big, drop all entries.
-      if (delta > maxHeaderTableSize) {
-        staticReferenceSet.clear();
-        headerTable.clear();
-        headerTableSize = 0;
+      if (delta > maxHeaderTableByteCount) {
+        referencedStaticHeaders = 0x0000000000000000L;
+        referencedHeaders = 0x0000000000000000L;
+        Arrays.fill(headerTable, null);
+        nextHeaderIndex = headerTable.length - 1;
+        headerCount = 0;
+        headerTableByteCount = 0;
         // emit the large header to the callback.
-        entry.addTo(emittedHeaders);
+        emittedHeaders.add(entry.name);
+        emittedHeaders.add(entry.value);
         return;
       }
 
       // Evict headers to the required length.
-      while (headerTableSize + delta > maxHeaderTableSize) {
-        remove(headerTable.size() - 1);
+      int bytesToRecover = (headerTableByteCount + delta) - maxHeaderTableByteCount;
+      int entriesToEvict = 0;
+      if (bytesToRecover > 0) {
+        // determine how many headers need to be evicted.
+        for (int j = headerTable.length - 1; j >= nextHeaderIndex && bytesToRecover > 0; j--) {
+          bytesToRecover -= headerTable[j].size;
+          headerTableByteCount -= headerTable[j].size;
+          headerCount--;
+          entriesToEvict++;
+        }
+        // shift elements over
+        referencedHeaders = referencedHeaders << entriesToEvict;
+        System.arraycopy(headerTable, nextHeaderIndex + 1, headerTable,
+            nextHeaderIndex + 1 + entriesToEvict, headerCount);
+        nextHeaderIndex += entriesToEvict;
       }
 
       if (index == -1) {
-        headerTable.add(0, entry);
+        if (headerCount + 1 > headerTable.length) {
+          if (headerTable.length == 64) {
+            // We would need to switch off long to bitset to support > 64 headers.
+            throw new UnsupportedOperationException(
+                "Header tables with count > 64 not yet supported!");
+          }
+          HeaderEntry[] doubled = new HeaderEntry[headerTable.length * 2];
+          System.arraycopy(headerTable, 0, doubled, headerTable.length, headerTable.length);
+          referencedHeaders = referencedHeaders << headerTable.length;
+          nextHeaderIndex = headerTable.length - 1;
+          headerTable = doubled;
+        }
+        index = nextHeaderIndex--;
+        referencedHeaders |= (1L << index);
+        headerTable[index] = entry;
+        headerCount++;
       } else { // Replace value at same position.
-        headerTable.set(index, entry);
+        index += headerTableIndex(index) + entriesToEvict;
+        referencedHeaders |= (1L << index);
+        headerTable[index] = entry;
       }
-
-      headerTableSize += delta;
-    }
-
-    private void remove(int index) {
-      headerTableSize -= headerTable.remove(index).size;
+      headerTableByteCount += delta;
     }
 
     private int readByte() throws IOException {
@@ -335,13 +369,19 @@
     public ByteString readString() throws IOException {
       int firstByte = readByte();
       int length = readInt(firstByte, PREFIX_8_BITS);
-      byte[] encoded = new byte[length];
+      if ((length & 0x80) == 0x80) { // 1NNNNNNN
+        length &= ~0x80;
+        // TODO: actually decode huffman!
+      }
       bytesLeft -= length;
-      in.readFully(encoded);
-      return ByteString.of(encoded);
+      return ByteString.read(in, length);
     }
   }
 
+  static boolean bitPositionSet(long referenceBitSet, int i) {
+    return ((referenceBitSet >> i) & 1L) == 1;
+  }
+
   static class Writer {
     private final OutputStream out;
 
@@ -383,8 +423,4 @@
       data.write(out);
     }
   }
-
-  private static HeaderEntry staticEntry(String name, String value) {
-    return new HeaderEntry(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value), true);
-  }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index 8ec7e81..1cfb93f 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -150,7 +150,7 @@
           return true;
       }
 
-      throw new UnsupportedOperationException("TODO");
+      throw new UnsupportedOperationException(Integer.toBinaryString(type));
     }
 
     private void readHeaders(Handler handler, int flags, int length, int streamId)
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index 4b8fef9..7397042 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -27,7 +27,11 @@
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.Util.byteStringList;
+import static com.squareup.okhttp.internal.spdy.HpackDraft05.bitPositionSet;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 public class HpackDraft05Test {
 
@@ -43,18 +47,137 @@
    * Ensure the larger header content is not lost.
    */
   @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
-    char[] tooLarge = new char[4096];
-    Arrays.fill(tooLarge, 'a');
-    final List<ByteString> sentHeaders = byteStringList("foo", new String(tooLarge));
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
 
-    ByteArrayOutputStream out = literalHeaders(sentHeaders);
+    out.write(0x00); // Literal indexed
+    out.write(0x0a); // Literal name (len = 10)
+    out.write("custom-key".getBytes(), 0, 10);
+
+    out.write(0x0d); // Literal value (len = 13)
+    out.write("custom-header".getBytes(), 0, 13);
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.maxHeaderTableByteCount = 1;
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(byteStringList("custom-key", "custom-header"), hpackReader.getAndReset());
+  }
+
+  /** Oldest entries are evicted to support newer ones. */
+  @Test public void testEviction() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x00); // Literal indexed
+    out.write(0x0a); // Literal name (len = 10)
+    out.write("custom-foo".getBytes(), 0, 10);
+
+    out.write(0x0d); // Literal value (len = 13)
+    out.write("custom-header".getBytes(), 0, 13);
+
+    out.write(0x00); // Literal indexed
+    out.write(0x0a); // Literal name (len = 10)
+    out.write("custom-bar".getBytes(), 0, 10);
+
+    out.write(0x0d); // Literal value (len = 13)
+    out.write("custom-header".getBytes(), 0, 13);
+
+    out.write(0x00); // Literal indexed
+    out.write(0x0a); // Literal name (len = 10)
+    out.write("custom-baz".getBytes(), 0, 10);
+
+    out.write(0x0d); // Literal value (len = 13)
+    out.write("custom-header".getBytes(), 0, 13);
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.maxHeaderTableByteCount = 110;
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+
+    assertEquals(2, hpackReader.headerCount);
+
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, "custom-bar", "custom-header", 55);
+    assertHeaderReferenced(headerTableLength() - 1);
+
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, "custom-baz", "custom-header", 55);
+    assertHeaderReferenced(headerTableLength() - 2);
+
+    // foo isn't here as it is no longer in the table.
+    // TODO: emit before eviction?
+    assertEquals(byteStringList("custom-bar", "custom-header", "custom-baz", "custom-header"),
+        hpackReader.getAndReset());
+  }
+
+  /** Header table backing array is initially 8 long, let's ensure it grows. */
+  @Test public void dynamicallyGrowsUpTo64Entries() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    for (int i = 0; i < 64; i++) {
+      out.write(0x00); // Literal indexed
+      out.write(0x0a); // Literal name (len = 10)
+      out.write("custom-foo".getBytes(), 0, 10);
+
+      out.write(0x0d); // Literal value (len = 13)
+      out.write("custom-header".getBytes(), 0, 13);
+    }
+
     bytesIn.set(out.toByteArray());
     hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
-    assertEquals(0, hpackReader.headerTable.size());
+    assertEquals(64, hpackReader.headerCount);
+  }
 
-    assertEquals(sentHeaders, hpackReader.getAndReset());
+  @Test public void greaterThan64HeadersNotYetSupported() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    for (int i = 0; i < 65; i++) {
+      out.write(0x00); // Literal indexed
+      out.write(0x0a); // Literal name (len = 10)
+      out.write("custom-foo".getBytes(), 0, 10);
+
+      out.write(0x0d); // Literal value (len = 13)
+      out.write("custom-header".getBytes(), 0, 13);
+    }
+
+    bytesIn.set(out.toByteArray());
+    try {
+      hpackReader.readHeaders(out.size());
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  /** Huffman headers are accepted, but come out as garbage for now. */
+  @Test public void huffmanDecodingNotYetSupported() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x04); // == Literal indexed ==
+                     // Indexed name (idx = 4) -> :path
+    out.write(0x8b); // Literal value Huffman encoded 11 bytes
+                     // decodes to www.example.com which is length 15
+    byte[] huffmanBytes = new byte[] {
+        (byte) 0xdb, (byte) 0x6d, (byte) 0x88, (byte) 0x3e,
+        (byte) 0x68, (byte) 0xd1, (byte) 0xcb, (byte) 0x12,
+        (byte) 0x25, (byte) 0xba, (byte) 0x7f};
+    out.write(huffmanBytes, 0, huffmanBytes.length);
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+
+    assertEquals(1, hpackReader.headerCount);
+    // this will change when we decode huffman
+    assertEquals(48, hpackReader.headerTableByteCount);
+
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
+    // TODO: huffman bytes are not what we want!
+    checkEntry(entry, ":path", new String(huffmanBytes, "UTF-8"), 48);
+    assertHeaderReferenced(headerTableLength() - 1);
   }
 
   /**
@@ -74,11 +197,12 @@
     hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
-    assertEquals(1, hpackReader.headerTable.size());
-    assertEquals(55, hpackReader.headerTableSize);
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(55, hpackReader.headerTableByteCount);
 
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
-    checkEntry(entry, "custom-key", "custom-header", 55, true);
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, "custom-key", "custom-header", 55);
+    assertHeaderReferenced(headerTableLength() - 1);
 
     assertEquals(byteStringList("custom-key", "custom-header"), hpackReader.getAndReset());
   }
@@ -98,7 +222,7 @@
     hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
-    assertEquals(0, hpackReader.headerTable.size());
+    assertEquals(0, hpackReader.headerCount);
 
     assertEquals(byteStringList(":path", "/sample/path"), hpackReader.getAndReset());
   }
@@ -116,11 +240,12 @@
     hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
-    assertEquals(1, hpackReader.headerTable.size());
-    assertEquals(42, hpackReader.headerTableSize);
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(42, hpackReader.headerTableByteCount);
 
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
-    checkEntry(entry, ":method", "GET", 42, true);
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
 
     assertEquals(byteStringList(":method", "GET"), hpackReader.getAndReset());
   }
@@ -135,12 +260,12 @@
                      // idx = 2 -> :method: GET
 
     bytesIn.set(out.toByteArray());
-    hpackReader.maxHeaderTableSize = 0; // SETTINGS_HEADER_TABLE_SIZE == 0
+    hpackReader.maxHeaderTableByteCount = 0; // SETTINGS_HEADER_TABLE_SIZE == 0
     hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
     // Not buffered in header table.
-    assertEquals(0, hpackReader.headerTable.size());
+    assertEquals(0, hpackReader.headerCount);
 
     assertEquals(byteStringList(":method", "GET"), hpackReader.getAndReset());
   }
@@ -186,26 +311,30 @@
   }
 
   private void checkFirstRequestWithoutHuffman() {
-    assertEquals(4, hpackReader.headerTable.size());
+    assertEquals(4, hpackReader.headerCount);
 
     // [  1] (s =  57) :authority: www.example.com
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
-    checkEntry(entry, ":authority", "www.example.com", 57, true);
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 4];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+    assertHeaderReferenced(headerTableLength() - 4);
 
     // [  2] (s =  38) :path: /
-    entry = hpackReader.headerTable.get(1);
-    checkEntry(entry, ":path", "/", 38, true);
+    entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, ":path", "/", 38);
+    assertHeaderReferenced(headerTableLength() - 3);
 
     // [  3] (s =  43) :scheme: http
-    entry = hpackReader.headerTable.get(2);
-    checkEntry(entry, ":scheme", "http", 43, true);
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, ":scheme", "http", 43);
+    assertHeaderReferenced(headerTableLength() - 2);
 
     // [  4] (s =  42) :method: GET
-    entry = hpackReader.headerTable.get(3);
-    checkEntry(entry, ":method", "GET", 42, true);
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
 
     // Table size: 180
-    assertEquals(180, hpackReader.headerTableSize);
+    assertEquals(180, hpackReader.headerTableByteCount);
 
     // Decoded header set:
     assertEquals(byteStringList(
@@ -227,30 +356,35 @@
   }
 
   private void checkSecondRequestWithoutHuffman() {
-    assertEquals(5, hpackReader.headerTable.size());
+    assertEquals(5, hpackReader.headerCount);
 
     // [  1] (s =  53) cache-control: no-cache
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
-    checkEntry(entry, "cache-control", "no-cache", 53, true);
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 5];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+    assertHeaderReferenced(headerTableLength() - 5);
 
     // [  2] (s =  57) :authority: www.example.com
-    entry = hpackReader.headerTable.get(1);
-    checkEntry(entry, ":authority", "www.example.com", 57, true);
+    entry = hpackReader.headerTable[headerTableLength() - 4];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+    assertHeaderReferenced(headerTableLength() - 4);
 
     // [  3] (s =  38) :path: /
-    entry = hpackReader.headerTable.get(2);
-    checkEntry(entry, ":path", "/", 38, true);
+    entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, ":path", "/", 38);
+    assertHeaderReferenced(headerTableLength() - 3);
 
     // [  4] (s =  43) :scheme: http
-    entry = hpackReader.headerTable.get(3);
-    checkEntry(entry, ":scheme", "http", 43, true);
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, ":scheme", "http", 43);
+    assertHeaderReferenced(headerTableLength() - 2);
 
     // [  5] (s =  42) :method: GET
-    entry = hpackReader.headerTable.get(4);
-    checkEntry(entry, ":method", "GET", 42, true);
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
 
     // Table size: 233
-    assertEquals(233, hpackReader.headerTableSize);
+    assertEquals(233, hpackReader.headerTableByteCount);
 
     // Decoded header set:
     assertEquals(byteStringList(
@@ -283,42 +417,50 @@
   }
 
   private void checkThirdRequestWithoutHuffman() {
-    assertEquals(8, hpackReader.headerTable.size());
+    assertEquals(8, hpackReader.headerCount);
 
     // [  1] (s =  54) custom-key: custom-value
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
-    checkEntry(entry, "custom-key", "custom-value", 54, true);
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 8];
+    checkEntry(entry, "custom-key", "custom-value", 54);
+    assertHeaderReferenced(headerTableLength() - 8);
 
     // [  2] (s =  48) :path: /index.html
-    entry = hpackReader.headerTable.get(1);
-    checkEntry(entry, ":path", "/index.html", 48, true);
+    entry = hpackReader.headerTable[headerTableLength() - 7];
+    checkEntry(entry, ":path", "/index.html", 48);
+    assertHeaderReferenced(headerTableLength() - 7);
 
     // [  3] (s =  44) :scheme: https
-    entry = hpackReader.headerTable.get(2);
-    checkEntry(entry, ":scheme", "https", 44, true);
+    entry = hpackReader.headerTable[headerTableLength() - 6];
+    checkEntry(entry, ":scheme", "https", 44);
+    assertHeaderReferenced(headerTableLength() - 6);
 
     // [  4] (s =  53) cache-control: no-cache
-    entry = hpackReader.headerTable.get(3);
-    checkEntry(entry, "cache-control", "no-cache", 53, false);
+    entry = hpackReader.headerTable[headerTableLength() - 5];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+    assertHeaderNotReferenced(headerTableLength() - 5);
 
     // [  5] (s =  57) :authority: www.example.com
-    entry = hpackReader.headerTable.get(4);
-    checkEntry(entry, ":authority", "www.example.com", 57, true);
+    entry = hpackReader.headerTable[headerTableLength() - 4];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+    assertHeaderReferenced(headerTableLength() - 4);
 
     // [  6] (s =  38) :path: /
-    entry = hpackReader.headerTable.get(5);
-    checkEntry(entry, ":path", "/", 38, false);
+    entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, ":path", "/", 38);
+    assertHeaderNotReferenced(headerTableLength() - 3);
 
     // [  7] (s =  43) :scheme: http
-    entry = hpackReader.headerTable.get(6);
-    checkEntry(entry, ":scheme", "http", 43, false);
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, ":scheme", "http", 43);
+    assertHeaderNotReferenced(headerTableLength() - 2);
 
     // [  8] (s =  42) :method: GET
-    entry = hpackReader.headerTable.get(7);
-    checkEntry(entry, ":method", "GET", 42, true);
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
 
     // Table size: 379
-    assertEquals(379, hpackReader.headerTableSize);
+    assertEquals(379, hpackReader.headerTableByteCount);
 
     // Decoded header set:
     // TODO: order is not correct per docs, but then again, the spec doesn't require ordering.
@@ -331,7 +473,8 @@
   }
 
   private ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-  private final HpackDraft05.Writer hpackWriter = new HpackDraft05.Writer(new DataOutputStream(bytesOut));
+  private final HpackDraft05.Writer hpackWriter =
+      new HpackDraft05.Writer(new DataOutputStream(bytesOut));
 
   @Test public void readSingleByteInt() throws IOException {
     assertEquals(10, new HpackDraft05.Reader(byteStream()).readInt(10, 31));
@@ -415,12 +558,10 @@
     return headerBytes;
   }
 
-  private void checkEntry(HpackDraft05.HeaderEntry entry, String name, String value, int size,
-      boolean referenced) {
+  private void checkEntry(HpackDraft05.HeaderEntry entry, String name, String value, int size) {
     assertEquals(name, entry.name.utf8());
     assertEquals(value, entry.value.utf8());
     assertEquals(size, entry.size);
-    assertEquals(referenced, entry.referenced);
   }
 
   private void assertBytes(int... bytes) {
@@ -438,6 +579,18 @@
     return data;
   }
 
+  private void assertHeaderReferenced(int index) {
+    assertTrue(bitPositionSet(hpackReader.referencedHeaders, index));
+  }
+
+  private void assertHeaderNotReferenced(int index) {
+    assertFalse(bitPositionSet(hpackReader.referencedHeaders, index));
+  }
+
+  private int headerTableLength() {
+    return hpackReader.headerTable.length;
+  }
+
   private static class MutableByteArrayInputStream extends ByteArrayInputStream {
 
     private MutableByteArrayInputStream() {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index 1c8d439..80065e4 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -5,12 +5,19 @@
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.ArrayList;
-import java.util.BitSet;
+import java.util.Arrays;
 import java.util.List;
 
 /**
  * Read and write HPACK v05.
+ *
  * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05
+ *
+ * This implementation uses an array for the header table with a bitset for
+ * references.  Dynamic entries are added to the array, starting in the last
+ * position moving forward.  When the array fills, it is doubled, up to the
+ * supported maximum of 64 headers.  HTTP requests or responses that require
+ * more than 64 headers are hence not currently supported.
  */
 final class HpackDraft05 {
 
@@ -19,35 +26,19 @@
     final ByteString name;
     final ByteString value;
     final int size;
-    // Static entries can be shared safely, as long as {@code referenced} is not mutated.
-    final boolean isStatic;
-    // Only read when in headerTable.
-    // Mutable to avoid needing another BitSet for referenced header indexes.  Using a BitSet for
-    // reference entries sounds good, except that entries are added at index zero.  This implies
-    // shifting the BitSet, which would be expensive to implement.
-    boolean referenced = true;
 
-    HeaderEntry(ByteString name, ByteString value, boolean isStatic) {
-      this(name, value, 32 + name.size() + value.size(), isStatic);
+    HeaderEntry(String name, String value) {
+      this(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value));
     }
 
-    private HeaderEntry(ByteString name, ByteString value, int size, boolean isStatic) {
+    HeaderEntry(ByteString name, ByteString value) {
+      this(name, value, 32 + name.size() + value.size());
+    }
+
+    private HeaderEntry(ByteString name, ByteString value, int size) {
       this.name = name;
       this.value = value;
       this.size = size;
-      this.isStatic = isStatic;
-    }
-
-    /** Adds name and value, if this entry is referenced. */
-    void addTo(List<ByteString> out) {
-      if (!referenced) return;
-      out.add(name);
-      out.add(value);
-    }
-
-    /** Copies this header entry and designates it as not a static entry. */
-    @Override public HeaderEntry clone() {
-      return new HeaderEntry(name, value, size, false);
     }
   }
 
@@ -56,66 +47,66 @@
   private static final int PREFIX_8_BITS = 0xff;
 
   private static final HeaderEntry[] STATIC_HEADER_TABLE = new HeaderEntry[] {
-      staticEntry(":authority", ""),
-      staticEntry(":method", "GET"),
-      staticEntry(":method", "POST"),
-      staticEntry(":path", "/"),
-      staticEntry(":path", "/index.html"),
-      staticEntry(":scheme", "http"),
-      staticEntry(":scheme", "https"),
-      staticEntry(":status", "200"),
-      staticEntry(":status", "500"),
-      staticEntry(":status", "404"),
-      staticEntry(":status", "403"),
-      staticEntry(":status", "400"),
-      staticEntry(":status", "401"),
-      staticEntry("accept-charset", ""),
-      staticEntry("accept-encoding", ""),
-      staticEntry("accept-language", ""),
-      staticEntry("accept-ranges", ""),
-      staticEntry("accept", ""),
-      staticEntry("access-control-allow-origin", ""),
-      staticEntry("age", ""),
-      staticEntry("allow", ""),
-      staticEntry("authorization", ""),
-      staticEntry("cache-control", ""),
-      staticEntry("content-disposition", ""),
-      staticEntry("content-encoding", ""),
-      staticEntry("content-language", ""),
-      staticEntry("content-length", ""),
-      staticEntry("content-location", ""),
-      staticEntry("content-range", ""),
-      staticEntry("content-type", ""),
-      staticEntry("cookie", ""),
-      staticEntry("date", ""),
-      staticEntry("etag", ""),
-      staticEntry("expect", ""),
-      staticEntry("expires", ""),
-      staticEntry("from", ""),
-      staticEntry("host", ""),
-      staticEntry("if-match", ""),
-      staticEntry("if-modified-since", ""),
-      staticEntry("if-none-match", ""),
-      staticEntry("if-range", ""),
-      staticEntry("if-unmodified-since", ""),
-      staticEntry("last-modified", ""),
-      staticEntry("link", ""),
-      staticEntry("location", ""),
-      staticEntry("max-forwards", ""),
-      staticEntry("proxy-authenticate", ""),
-      staticEntry("proxy-authorization", ""),
-      staticEntry("range", ""),
-      staticEntry("referer", ""),
-      staticEntry("refresh", ""),
-      staticEntry("retry-after", ""),
-      staticEntry("server", ""),
-      staticEntry("set-cookie", ""),
-      staticEntry("strict-transport-security", ""),
-      staticEntry("transfer-encoding", ""),
-      staticEntry("user-agent", ""),
-      staticEntry("vary", ""),
-      staticEntry("via", ""),
-      staticEntry("www-authenticate", "")
+      new HeaderEntry(":authority", ""),
+      new HeaderEntry(":method", "GET"),
+      new HeaderEntry(":method", "POST"),
+      new HeaderEntry(":path", "/"),
+      new HeaderEntry(":path", "/index.html"),
+      new HeaderEntry(":scheme", "http"),
+      new HeaderEntry(":scheme", "https"),
+      new HeaderEntry(":status", "200"),
+      new HeaderEntry(":status", "500"),
+      new HeaderEntry(":status", "404"),
+      new HeaderEntry(":status", "403"),
+      new HeaderEntry(":status", "400"),
+      new HeaderEntry(":status", "401"),
+      new HeaderEntry("accept-charset", ""),
+      new HeaderEntry("accept-encoding", ""),
+      new HeaderEntry("accept-language", ""),
+      new HeaderEntry("accept-ranges", ""),
+      new HeaderEntry("accept", ""),
+      new HeaderEntry("access-control-allow-origin", ""),
+      new HeaderEntry("age", ""),
+      new HeaderEntry("allow", ""),
+      new HeaderEntry("authorization", ""),
+      new HeaderEntry("cache-control", ""),
+      new HeaderEntry("content-disposition", ""),
+      new HeaderEntry("content-encoding", ""),
+      new HeaderEntry("content-language", ""),
+      new HeaderEntry("content-length", ""),
+      new HeaderEntry("content-location", ""),
+      new HeaderEntry("content-range", ""),
+      new HeaderEntry("content-type", ""),
+      new HeaderEntry("cookie", ""),
+      new HeaderEntry("date", ""),
+      new HeaderEntry("etag", ""),
+      new HeaderEntry("expect", ""),
+      new HeaderEntry("expires", ""),
+      new HeaderEntry("from", ""),
+      new HeaderEntry("host", ""),
+      new HeaderEntry("if-match", ""),
+      new HeaderEntry("if-modified-since", ""),
+      new HeaderEntry("if-none-match", ""),
+      new HeaderEntry("if-range", ""),
+      new HeaderEntry("if-unmodified-since", ""),
+      new HeaderEntry("last-modified", ""),
+      new HeaderEntry("link", ""),
+      new HeaderEntry("location", ""),
+      new HeaderEntry("max-forwards", ""),
+      new HeaderEntry("proxy-authenticate", ""),
+      new HeaderEntry("proxy-authorization", ""),
+      new HeaderEntry("range", ""),
+      new HeaderEntry("referer", ""),
+      new HeaderEntry("refresh", ""),
+      new HeaderEntry("retry-after", ""),
+      new HeaderEntry("server", ""),
+      new HeaderEntry("set-cookie", ""),
+      new HeaderEntry("strict-transport-security", ""),
+      new HeaderEntry("transfer-encoding", ""),
+      new HeaderEntry("user-agent", ""),
+      new HeaderEntry("vary", ""),
+      new HeaderEntry("via", ""),
+      new HeaderEntry("www-authenticate", "")
   };
 
   private HpackDraft05() {
@@ -129,10 +120,25 @@
     private long bytesLeft = 0;
 
     // Visible for testing.
-    final List<HeaderEntry> headerTable = new ArrayList<HeaderEntry>(5); // average of 5 headers
-    final BitSet staticReferenceSet = new BitSet();
-    long headerTableSize = 0;
-    long maxHeaderTableSize = 4096; // TODO: needs to come from SETTINGS_HEADER_TABLE_SIZE.
+    HeaderEntry[] headerTable = new HeaderEntry[8]; // must be less than 64
+    // Array is populated back to front, so new entries always have lowest index.
+    int nextHeaderIndex = headerTable.length - 1;
+    int headerCount = 0;
+
+    /**
+     * Set bit positions indicate {@code headerTable[pos]} should be emitted.
+     */
+    // Using a long since the reference table < 64 entries.
+    long referencedHeaders = 0x0000000000000000L;
+
+    /**
+     * Set bit positions indicate {@code STATIC_HEADER_TABLE[pos]} should be
+     * emitted.
+     */
+    // Using a long since the static table < 64 entries.
+    long referencedStaticHeaders = 0x0000000000000000L;
+    int headerTableByteCount = 0;
+    int maxHeaderTableByteCount = 4096; // TODO: needs to come from SETTINGS_HEADER_TABLE_SIZE.
 
     Reader(DataInputStream in) {
       this.in = in;
@@ -149,51 +155,47 @@
       while (bytesLeft > 0) {
         int b = readByte();
 
-        if ((b & 0x80) != 0) {
+        if (b == 0x80) { // 10000000
+          clearReferenceSet();
+        } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
           int index = readInt(b, PREFIX_7_BITS);
-          if (index == 0) {
-            clearReferenceSet();
+          readIndexedHeader(index - 1);
+        } else { // 0NNNNNNN
+          if (b == 0x40) { // 01000000
+            readLiteralHeaderWithoutIndexingNewName();
+          } else if ((b & 0xe0) == 0x40) {  // 01NNNNNN
+            int index = readInt(b, PREFIX_6_BITS);
+            readLiteralHeaderWithoutIndexingIndexedName(index - 1);
+          } else if (b == 0) { // 00000000
+            readLiteralHeaderWithIncrementalIndexingNewName();
+          } else if ((b & 0xc0) == 0) { // 00NNNNNN
+            int index = readInt(b, PREFIX_6_BITS);
+            readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
           } else {
-            readIndexedHeader(index - 1);
+            // TODO: we should throw something that we can coerce to a PROTOCOL_ERROR
+            throw new AssertionError("unhandled byte: " + Integer.toBinaryString(b));
           }
-        } else if (b == 0x40) {
-          readLiteralHeaderWithoutIndexingNewName();
-        } else if ((b & 0xe0) == 0x40) {
-          int index = readInt(b, PREFIX_6_BITS);
-          readLiteralHeaderWithoutIndexingIndexedName(index - 1);
-        } else if (b == 0) {
-          readLiteralHeaderWithIncrementalIndexingNewName();
-        } else if ((b & 0xc0) == 0) {
-          int index = readInt(b, PREFIX_6_BITS);
-          readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
-        } else {
-          // TODO: we should throw something that we can coerce to a PROTOCOL_ERROR
-          throw new AssertionError("unhandled byte: " + Integer.toBinaryString(b));
         }
       }
     }
 
     private void clearReferenceSet() {
-      staticReferenceSet.clear();
-      for (int i = 0, size = headerTable.size(); i < size; i++) {
-        HeaderEntry entry = headerTable.get(i);
-        if (entry.isStatic) { // lazy clone static entries on mutation.
-          entry = entry.clone();
-          entry.referenced = false;
-          headerTable.set(i, entry);
-        } else {
-          entry.referenced = false;
-        }
-      }
+      referencedStaticHeaders = 0x0000000000000000L;
+      referencedHeaders = 0x0000000000000000L;
     }
 
     public void emitReferenceSet() {
-      for (int i = staticReferenceSet.nextSetBit(0); i != -1;
-          i = staticReferenceSet.nextSetBit(i + 1)) {
-        STATIC_HEADER_TABLE[i].addTo(emittedHeaders);
+      for (int i = 0; i < STATIC_HEADER_TABLE.length; ++i) {
+        if (bitPositionSet(referencedStaticHeaders, i)) {
+          emittedHeaders.add(STATIC_HEADER_TABLE[i].name);
+          emittedHeaders.add(STATIC_HEADER_TABLE[i].value);
+        }
       }
-      for (int i = headerTable.size() - 1; i != -1; i--) {
-        headerTable.get(i).addTo(emittedHeaders);
+      for (int i = headerTable.length - 1; i != nextHeaderIndex; --i) {
+        if (bitPositionSet(referencedHeaders, i)) {
+          emittedHeaders.add(headerTable[i].name);
+          emittedHeaders.add(headerTable[i].value);
+        }
       }
     }
 
@@ -208,33 +210,36 @@
     }
 
     private void readIndexedHeader(int index) {
+
       if (isStaticHeader(index)) {
-        if (maxHeaderTableSize == 0) {
-          staticReferenceSet.set(index - headerTable.size());
+        if (maxHeaderTableByteCount == 0) {
+          // Set bit designating this static entry is referenced.
+          referencedStaticHeaders |= (1L << (index - headerCount));
         } else {
-          HeaderEntry staticEntry = STATIC_HEADER_TABLE[index - headerTable.size()];
+          HeaderEntry staticEntry = STATIC_HEADER_TABLE[index - headerCount];
           insertIntoHeaderTable(-1, staticEntry);
-       }
-      } else if (!headerTable.get(index).referenced) {
-        HeaderEntry existing = headerTable.get(index);
-        existing.referenced = true;
-        insertIntoHeaderTable(index, existing);
+        }
+      } else if (!bitPositionSet(referencedHeaders, headerTableIndex(index))) {
+        referencedHeaders |= (1L << headerTableIndex(index));
       } else {
         // TODO: we should throw something that we can coerce to a PROTOCOL_ERROR
         throw new AssertionError("invalid index " + index);
       }
     }
 
-    private void readLiteralHeaderWithoutIndexingIndexedName(int index)
-        throws IOException {
+    // referencedHeaders is relative to nextHeaderIndex + 1.
+    private int headerTableIndex(int index) {
+      return nextHeaderIndex + 1 + index;
+    }
+
+    private void readLiteralHeaderWithoutIndexingIndexedName(int index) throws IOException {
       ByteString name = getName(index);
       ByteString value = readString();
       emittedHeaders.add(name);
       emittedHeaders.add(value);
     }
 
-    private void readLiteralHeaderWithoutIndexingNewName()
-        throws IOException {
+    private void readLiteralHeaderWithoutIndexingNewName() throws IOException {
       ByteString name = readString();
       ByteString value = readString();
       emittedHeaders.add(name);
@@ -245,60 +250,89 @@
         throws IOException {
       ByteString name = getName(nameIndex);
       ByteString value = readString();
-      insertIntoHeaderTable(-1, new HeaderEntry(name, value, false));
+      insertIntoHeaderTable(-1, new HeaderEntry(name, value));
     }
 
     private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
       ByteString name = readString();
       ByteString value = readString();
-      insertIntoHeaderTable(-1, new HeaderEntry(name, value, false));
+      insertIntoHeaderTable(-1, new HeaderEntry(name, value));
     }
 
     private ByteString getName(int index) {
       if (isStaticHeader(index)) {
-        return STATIC_HEADER_TABLE[index - headerTable.size()].name;
+        return STATIC_HEADER_TABLE[index - headerCount].name;
       } else {
-        return headerTable.get(index).name;
+        return headerTable[headerTableIndex(index)].name;
       }
     }
 
     private boolean isStaticHeader(int index) {
-      return index >= headerTable.size();
+      return index >= headerCount;
     }
 
     /** index == -1 when new. */
     private void insertIntoHeaderTable(int index, HeaderEntry entry) {
       int delta = entry.size;
       if (index != -1) { // Index -1 == new header.
-        delta -= headerTable.get(index).size;
+        delta -= headerTable[headerTableIndex(index)].size;
       }
 
       // if the new or replacement header is too big, drop all entries.
-      if (delta > maxHeaderTableSize) {
-        staticReferenceSet.clear();
-        headerTable.clear();
-        headerTableSize = 0;
+      if (delta > maxHeaderTableByteCount) {
+        referencedStaticHeaders = 0x0000000000000000L;
+        referencedHeaders = 0x0000000000000000L;
+        Arrays.fill(headerTable, null);
+        nextHeaderIndex = headerTable.length - 1;
+        headerCount = 0;
+        headerTableByteCount = 0;
         // emit the large header to the callback.
-        entry.addTo(emittedHeaders);
+        emittedHeaders.add(entry.name);
+        emittedHeaders.add(entry.value);
         return;
       }
 
       // Evict headers to the required length.
-      while (headerTableSize + delta > maxHeaderTableSize) {
-        remove(headerTable.size() - 1);
+      int bytesToRecover = (headerTableByteCount + delta) - maxHeaderTableByteCount;
+      int entriesToEvict = 0;
+      if (bytesToRecover > 0) {
+        // determine how many headers need to be evicted.
+        for (int j = headerTable.length - 1; j >= nextHeaderIndex && bytesToRecover > 0; j--) {
+          bytesToRecover -= headerTable[j].size;
+          headerTableByteCount -= headerTable[j].size;
+          headerCount--;
+          entriesToEvict++;
+        }
+        // shift elements over
+        referencedHeaders = referencedHeaders << entriesToEvict;
+        System.arraycopy(headerTable, nextHeaderIndex + 1, headerTable,
+            nextHeaderIndex + 1 + entriesToEvict, headerCount);
+        nextHeaderIndex += entriesToEvict;
       }
 
       if (index == -1) {
-        headerTable.add(0, entry);
+        if (headerCount + 1 > headerTable.length) {
+          if (headerTable.length == 64) {
+            // We would need to switch off long to bitset to support > 64 headers.
+            throw new UnsupportedOperationException(
+                "Header tables with count > 64 not yet supported!");
+          }
+          HeaderEntry[] doubled = new HeaderEntry[headerTable.length * 2];
+          System.arraycopy(headerTable, 0, doubled, headerTable.length, headerTable.length);
+          referencedHeaders = referencedHeaders << headerTable.length;
+          nextHeaderIndex = headerTable.length - 1;
+          headerTable = doubled;
+        }
+        index = nextHeaderIndex--;
+        referencedHeaders |= (1L << index);
+        headerTable[index] = entry;
+        headerCount++;
       } else { // Replace value at same position.
-        headerTable.set(index, entry);
+        index += headerTableIndex(index) + entriesToEvict;
+        referencedHeaders |= (1L << index);
+        headerTable[index] = entry;
       }
-
-      headerTableSize += delta;
-    }
-
-    private void remove(int index) {
-      headerTableSize -= headerTable.remove(index).size;
+      headerTableByteCount += delta;
     }
 
     private int readByte() throws IOException {
@@ -335,13 +369,19 @@
     public ByteString readString() throws IOException {
       int firstByte = readByte();
       int length = readInt(firstByte, PREFIX_8_BITS);
-      byte[] encoded = new byte[length];
+      if ((length & 0x80) == 0x80) { // 1NNNNNNN
+        length &= ~0x80;
+        // TODO: actually decode huffman!
+      }
       bytesLeft -= length;
-      in.readFully(encoded);
-      return ByteString.of(encoded);
+      return ByteString.read(in, length);
     }
   }
 
+  static boolean bitPositionSet(long referenceBitSet, int i) {
+    return ((referenceBitSet >> i) & 1L) == 1;
+  }
+
   static class Writer {
     private final OutputStream out;
 
@@ -383,8 +423,4 @@
       data.write(out);
     }
   }
-
-  private static HeaderEntry staticEntry(String name, String value) {
-    return new HeaderEntry(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value), true);
-  }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index 8ec7e81..1cfb93f 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -150,7 +150,7 @@
           return true;
       }
 
-      throw new UnsupportedOperationException("TODO");
+      throw new UnsupportedOperationException(Integer.toBinaryString(type));
     }
 
     private void readHeaders(Handler handler, int flags, int length, int streamId)
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index 4b8fef9..7397042 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -27,7 +27,11 @@
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.Util.byteStringList;
+import static com.squareup.okhttp.internal.spdy.HpackDraft05.bitPositionSet;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 public class HpackDraft05Test {
 
@@ -43,18 +47,137 @@
    * Ensure the larger header content is not lost.
    */
   @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
-    char[] tooLarge = new char[4096];
-    Arrays.fill(tooLarge, 'a');
-    final List<ByteString> sentHeaders = byteStringList("foo", new String(tooLarge));
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
 
-    ByteArrayOutputStream out = literalHeaders(sentHeaders);
+    out.write(0x00); // Literal indexed
+    out.write(0x0a); // Literal name (len = 10)
+    out.write("custom-key".getBytes(), 0, 10);
+
+    out.write(0x0d); // Literal value (len = 13)
+    out.write("custom-header".getBytes(), 0, 13);
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.maxHeaderTableByteCount = 1;
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(byteStringList("custom-key", "custom-header"), hpackReader.getAndReset());
+  }
+
+  /** Oldest entries are evicted to support newer ones. */
+  @Test public void testEviction() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x00); // Literal indexed
+    out.write(0x0a); // Literal name (len = 10)
+    out.write("custom-foo".getBytes(), 0, 10);
+
+    out.write(0x0d); // Literal value (len = 13)
+    out.write("custom-header".getBytes(), 0, 13);
+
+    out.write(0x00); // Literal indexed
+    out.write(0x0a); // Literal name (len = 10)
+    out.write("custom-bar".getBytes(), 0, 10);
+
+    out.write(0x0d); // Literal value (len = 13)
+    out.write("custom-header".getBytes(), 0, 13);
+
+    out.write(0x00); // Literal indexed
+    out.write(0x0a); // Literal name (len = 10)
+    out.write("custom-baz".getBytes(), 0, 10);
+
+    out.write(0x0d); // Literal value (len = 13)
+    out.write("custom-header".getBytes(), 0, 13);
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.maxHeaderTableByteCount = 110;
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+
+    assertEquals(2, hpackReader.headerCount);
+
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, "custom-bar", "custom-header", 55);
+    assertHeaderReferenced(headerTableLength() - 1);
+
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, "custom-baz", "custom-header", 55);
+    assertHeaderReferenced(headerTableLength() - 2);
+
+    // foo isn't here as it is no longer in the table.
+    // TODO: emit before eviction?
+    assertEquals(byteStringList("custom-bar", "custom-header", "custom-baz", "custom-header"),
+        hpackReader.getAndReset());
+  }
+
+  /** Header table backing array is initially 8 long, let's ensure it grows. */
+  @Test public void dynamicallyGrowsUpTo64Entries() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    for (int i = 0; i < 64; i++) {
+      out.write(0x00); // Literal indexed
+      out.write(0x0a); // Literal name (len = 10)
+      out.write("custom-foo".getBytes(), 0, 10);
+
+      out.write(0x0d); // Literal value (len = 13)
+      out.write("custom-header".getBytes(), 0, 13);
+    }
+
     bytesIn.set(out.toByteArray());
     hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
-    assertEquals(0, hpackReader.headerTable.size());
+    assertEquals(64, hpackReader.headerCount);
+  }
 
-    assertEquals(sentHeaders, hpackReader.getAndReset());
+  @Test public void greaterThan64HeadersNotYetSupported() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    for (int i = 0; i < 65; i++) {
+      out.write(0x00); // Literal indexed
+      out.write(0x0a); // Literal name (len = 10)
+      out.write("custom-foo".getBytes(), 0, 10);
+
+      out.write(0x0d); // Literal value (len = 13)
+      out.write("custom-header".getBytes(), 0, 13);
+    }
+
+    bytesIn.set(out.toByteArray());
+    try {
+      hpackReader.readHeaders(out.size());
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  /** Huffman headers are accepted, but come out as garbage for now. */
+  @Test public void huffmanDecodingNotYetSupported() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x04); // == Literal indexed ==
+                     // Indexed name (idx = 4) -> :path
+    out.write(0x8b); // Literal value Huffman encoded 11 bytes
+                     // decodes to www.example.com which is length 15
+    byte[] huffmanBytes = new byte[] {
+        (byte) 0xdb, (byte) 0x6d, (byte) 0x88, (byte) 0x3e,
+        (byte) 0x68, (byte) 0xd1, (byte) 0xcb, (byte) 0x12,
+        (byte) 0x25, (byte) 0xba, (byte) 0x7f};
+    out.write(huffmanBytes, 0, huffmanBytes.length);
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+
+    assertEquals(1, hpackReader.headerCount);
+    // this will change when we decode huffman
+    assertEquals(48, hpackReader.headerTableByteCount);
+
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
+    // TODO: huffman bytes are not what we want!
+    checkEntry(entry, ":path", new String(huffmanBytes, "UTF-8"), 48);
+    assertHeaderReferenced(headerTableLength() - 1);
   }
 
   /**
@@ -74,11 +197,12 @@
     hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
-    assertEquals(1, hpackReader.headerTable.size());
-    assertEquals(55, hpackReader.headerTableSize);
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(55, hpackReader.headerTableByteCount);
 
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
-    checkEntry(entry, "custom-key", "custom-header", 55, true);
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, "custom-key", "custom-header", 55);
+    assertHeaderReferenced(headerTableLength() - 1);
 
     assertEquals(byteStringList("custom-key", "custom-header"), hpackReader.getAndReset());
   }
@@ -98,7 +222,7 @@
     hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
-    assertEquals(0, hpackReader.headerTable.size());
+    assertEquals(0, hpackReader.headerCount);
 
     assertEquals(byteStringList(":path", "/sample/path"), hpackReader.getAndReset());
   }
@@ -116,11 +240,12 @@
     hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
-    assertEquals(1, hpackReader.headerTable.size());
-    assertEquals(42, hpackReader.headerTableSize);
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(42, hpackReader.headerTableByteCount);
 
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
-    checkEntry(entry, ":method", "GET", 42, true);
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
 
     assertEquals(byteStringList(":method", "GET"), hpackReader.getAndReset());
   }
@@ -135,12 +260,12 @@
                      // idx = 2 -> :method: GET
 
     bytesIn.set(out.toByteArray());
-    hpackReader.maxHeaderTableSize = 0; // SETTINGS_HEADER_TABLE_SIZE == 0
+    hpackReader.maxHeaderTableByteCount = 0; // SETTINGS_HEADER_TABLE_SIZE == 0
     hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
     // Not buffered in header table.
-    assertEquals(0, hpackReader.headerTable.size());
+    assertEquals(0, hpackReader.headerCount);
 
     assertEquals(byteStringList(":method", "GET"), hpackReader.getAndReset());
   }
@@ -186,26 +311,30 @@
   }
 
   private void checkFirstRequestWithoutHuffman() {
-    assertEquals(4, hpackReader.headerTable.size());
+    assertEquals(4, hpackReader.headerCount);
 
     // [  1] (s =  57) :authority: www.example.com
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
-    checkEntry(entry, ":authority", "www.example.com", 57, true);
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 4];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+    assertHeaderReferenced(headerTableLength() - 4);
 
     // [  2] (s =  38) :path: /
-    entry = hpackReader.headerTable.get(1);
-    checkEntry(entry, ":path", "/", 38, true);
+    entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, ":path", "/", 38);
+    assertHeaderReferenced(headerTableLength() - 3);
 
     // [  3] (s =  43) :scheme: http
-    entry = hpackReader.headerTable.get(2);
-    checkEntry(entry, ":scheme", "http", 43, true);
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, ":scheme", "http", 43);
+    assertHeaderReferenced(headerTableLength() - 2);
 
     // [  4] (s =  42) :method: GET
-    entry = hpackReader.headerTable.get(3);
-    checkEntry(entry, ":method", "GET", 42, true);
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
 
     // Table size: 180
-    assertEquals(180, hpackReader.headerTableSize);
+    assertEquals(180, hpackReader.headerTableByteCount);
 
     // Decoded header set:
     assertEquals(byteStringList(
@@ -227,30 +356,35 @@
   }
 
   private void checkSecondRequestWithoutHuffman() {
-    assertEquals(5, hpackReader.headerTable.size());
+    assertEquals(5, hpackReader.headerCount);
 
     // [  1] (s =  53) cache-control: no-cache
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
-    checkEntry(entry, "cache-control", "no-cache", 53, true);
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 5];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+    assertHeaderReferenced(headerTableLength() - 5);
 
     // [  2] (s =  57) :authority: www.example.com
-    entry = hpackReader.headerTable.get(1);
-    checkEntry(entry, ":authority", "www.example.com", 57, true);
+    entry = hpackReader.headerTable[headerTableLength() - 4];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+    assertHeaderReferenced(headerTableLength() - 4);
 
     // [  3] (s =  38) :path: /
-    entry = hpackReader.headerTable.get(2);
-    checkEntry(entry, ":path", "/", 38, true);
+    entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, ":path", "/", 38);
+    assertHeaderReferenced(headerTableLength() - 3);
 
     // [  4] (s =  43) :scheme: http
-    entry = hpackReader.headerTable.get(3);
-    checkEntry(entry, ":scheme", "http", 43, true);
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, ":scheme", "http", 43);
+    assertHeaderReferenced(headerTableLength() - 2);
 
     // [  5] (s =  42) :method: GET
-    entry = hpackReader.headerTable.get(4);
-    checkEntry(entry, ":method", "GET", 42, true);
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
 
     // Table size: 233
-    assertEquals(233, hpackReader.headerTableSize);
+    assertEquals(233, hpackReader.headerTableByteCount);
 
     // Decoded header set:
     assertEquals(byteStringList(
@@ -283,42 +417,50 @@
   }
 
   private void checkThirdRequestWithoutHuffman() {
-    assertEquals(8, hpackReader.headerTable.size());
+    assertEquals(8, hpackReader.headerCount);
 
     // [  1] (s =  54) custom-key: custom-value
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
-    checkEntry(entry, "custom-key", "custom-value", 54, true);
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 8];
+    checkEntry(entry, "custom-key", "custom-value", 54);
+    assertHeaderReferenced(headerTableLength() - 8);
 
     // [  2] (s =  48) :path: /index.html
-    entry = hpackReader.headerTable.get(1);
-    checkEntry(entry, ":path", "/index.html", 48, true);
+    entry = hpackReader.headerTable[headerTableLength() - 7];
+    checkEntry(entry, ":path", "/index.html", 48);
+    assertHeaderReferenced(headerTableLength() - 7);
 
     // [  3] (s =  44) :scheme: https
-    entry = hpackReader.headerTable.get(2);
-    checkEntry(entry, ":scheme", "https", 44, true);
+    entry = hpackReader.headerTable[headerTableLength() - 6];
+    checkEntry(entry, ":scheme", "https", 44);
+    assertHeaderReferenced(headerTableLength() - 6);
 
     // [  4] (s =  53) cache-control: no-cache
-    entry = hpackReader.headerTable.get(3);
-    checkEntry(entry, "cache-control", "no-cache", 53, false);
+    entry = hpackReader.headerTable[headerTableLength() - 5];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+    assertHeaderNotReferenced(headerTableLength() - 5);
 
     // [  5] (s =  57) :authority: www.example.com
-    entry = hpackReader.headerTable.get(4);
-    checkEntry(entry, ":authority", "www.example.com", 57, true);
+    entry = hpackReader.headerTable[headerTableLength() - 4];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+    assertHeaderReferenced(headerTableLength() - 4);
 
     // [  6] (s =  38) :path: /
-    entry = hpackReader.headerTable.get(5);
-    checkEntry(entry, ":path", "/", 38, false);
+    entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, ":path", "/", 38);
+    assertHeaderNotReferenced(headerTableLength() - 3);
 
     // [  7] (s =  43) :scheme: http
-    entry = hpackReader.headerTable.get(6);
-    checkEntry(entry, ":scheme", "http", 43, false);
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, ":scheme", "http", 43);
+    assertHeaderNotReferenced(headerTableLength() - 2);
 
     // [  8] (s =  42) :method: GET
-    entry = hpackReader.headerTable.get(7);
-    checkEntry(entry, ":method", "GET", 42, true);
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
 
     // Table size: 379
-    assertEquals(379, hpackReader.headerTableSize);
+    assertEquals(379, hpackReader.headerTableByteCount);
 
     // Decoded header set:
     // TODO: order is not correct per docs, but then again, the spec doesn't require ordering.
@@ -331,7 +473,8 @@
   }
 
   private ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-  private final HpackDraft05.Writer hpackWriter = new HpackDraft05.Writer(new DataOutputStream(bytesOut));
+  private final HpackDraft05.Writer hpackWriter =
+      new HpackDraft05.Writer(new DataOutputStream(bytesOut));
 
   @Test public void readSingleByteInt() throws IOException {
     assertEquals(10, new HpackDraft05.Reader(byteStream()).readInt(10, 31));
@@ -415,12 +558,10 @@
     return headerBytes;
   }
 
-  private void checkEntry(HpackDraft05.HeaderEntry entry, String name, String value, int size,
-      boolean referenced) {
+  private void checkEntry(HpackDraft05.HeaderEntry entry, String name, String value, int size) {
     assertEquals(name, entry.name.utf8());
     assertEquals(value, entry.value.utf8());
     assertEquals(size, entry.size);
-    assertEquals(referenced, entry.referenced);
   }
 
   private void assertBytes(int... bytes) {
@@ -438,6 +579,18 @@
     return data;
   }
 
+  private void assertHeaderReferenced(int index) {
+    assertTrue(bitPositionSet(hpackReader.referencedHeaders, index));
+  }
+
+  private void assertHeaderNotReferenced(int index) {
+    assertFalse(bitPositionSet(hpackReader.referencedHeaders, index));
+  }
+
+  private int headerTableLength() {
+    return hpackReader.headerTable.length;
+  }
+
   private static class MutableByteArrayInputStream extends ByteArrayInputStream {
 
     private MutableByteArrayInputStream() {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 6004f23..0eea677 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -154,7 +154,7 @@
       throw new IllegalArgumentException("Unexpected name value block: " + nameValueBlock);
     }
     String status = null;
-    String version = null;
+    String version = "HTTP/1.1"; // TODO: why are we expecting :version?
 
     Headers.Builder headersBuilder = new Headers.Builder();
     headersBuilder.set(OkHeaders.SELECTED_TRANSPORT, protocol);
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
new file mode 100644
index 0000000..483f3cd
--- /dev/null
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.OkHttpClient;
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.net.URL;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLSession;
+
+public final class ExternalHttp2Example {
+  public static void main(String[] args) throws Exception {
+    URL url = new URL("https://twitter.com/");
+    HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient().open(url);
+
+    connection.setHostnameVerifier(new HostnameVerifier() {
+      @Override public boolean verify(String s, SSLSession sslSession) {
+        System.out.println("VERIFYING " + s);
+        return true;
+      }
+    });
+
+    int responseCode = connection.getResponseCode();
+    System.out.println(responseCode);
+
+    BufferedReader reader =
+        new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
+    String line;
+    while ((line = reader.readLine()) != null) {
+      System.out.println(line);
+    }
+  }
+}
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java b/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
index bf4ee23..37f1c48 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
@@ -318,4 +318,36 @@
     assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
     assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reuse!
   }
+
+  @Test public void postBodyRetransmittedOnRedirect() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b")
+        .setBody("Moved to /b !"));
+    server.enqueue(new MockResponse()
+        .setBody("This is b."));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .post(Request.Body.create(MediaType.parse("text/plain"), "body!"))
+        .build();
+    client.enqueue(request, receiver);
+
+    receiver.await(server.getUrl("/b"))
+        .assertCode(200)
+        .assertBody("This is b.");
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("body!", request1.getUtf8Body());
+    assertEquals("5", request1.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", request1.getHeader("Content-Type"));
+    assertEquals(0, request1.getSequenceNumber());
+
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("body!", request2.getUtf8Body());
+    assertEquals("5", request2.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", request2.getHeader("Content-Type"));
+    assertEquals(1, request2.getSequenceNumber());
+  }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index 9868b16..2f9c027 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -53,7 +53,6 @@
 
   public synchronized Executor getExecutor() {
     if (executor == null) {
-      // TODO: name these threads, either here or in the job.
       executor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
           new LinkedBlockingQueue<Runnable>());
     }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Failure.java b/okhttp/src/main/java/com/squareup/okhttp/Failure.java
index b5c69c6..51ee2ea 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Failure.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Failure.java
@@ -17,9 +17,6 @@
 
 /**
  * A failure attempting to retrieve an HTTP response.
- *
- * <h3>Warning: Experimental OkHttp 2.0 API</h3>
- * This class is in beta. APIs are subject to change!
  */
 public final class Failure {
   private final Request request;
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index c388c18..ef93432 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -342,10 +342,14 @@
   }
 
   /**
-   * Schedules {@code request} to be executed.
+   * Schedules {@code request} to be executed at some point in the future. The
+   * {@link #getDispatcher dispatcher} defines when the request will run:
+   * usually immediately unless there are several other requests currently being
+   * executed.
    *
-   * <h3>Warning: Experimental OkHttp 2.0 API</h3>
-   * This method is in beta. APIs are subject to change!
+   * <p>This client will later call back {@code responseReceiver} with either an
+   * HTTP response or a failure exception. If you {@link #cancel} a request
+   * before it completes the receiver will not be called back.
    */
   public void enqueue(Request request, Response.Receiver responseReceiver) {
     dispatcher.enqueue(this, request, responseReceiver);
@@ -353,10 +357,7 @@
 
   /**
    * Cancels all scheduled tasks tagged with {@code tag}. Requests that are already
-   * in flight might not be canceled.
-   *
-   * <h3>Warning: Experimental OkHttp 2.0 API</h3>
-   * This method is in beta. APIs are subject to change!
+   * complete cannot be canceled.
    */
   public void cancel(Object tag) {
     dispatcher.cancel(tag);
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java b/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java
index 1ddeb9a..05460f5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java
@@ -21,9 +21,6 @@
 /**
  * An extended response cache API. Unlike {@link java.net.ResponseCache}, this
  * interface supports conditional caching and statistics.
- *
- * <h3>Warning: Experimental OkHttp 2.0 API</h3>
- * This class is in beta. APIs are subject to change!
  */
 public interface OkResponseCache {
   Response get(Request request) throws IOException;
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index 5866af0..83c6fbb 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -35,9 +35,6 @@
 /**
  * An HTTP request. Instances of this class are immutable if their {@link #body}
  * is null or itself immutable.
- *
- * <h3>Warning: Experimental OkHttp 2.0 API</h3>
- * This class is in beta. APIs are subject to change!
  */
 public final class Request {
   private final URL url;
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index 8026a78..cb3ecb8 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -41,9 +41,6 @@
  * An HTTP response. Instances of this class are not immutable: the response
  * body is a one-shot value that may be consumed only once. All other properties
  * are immutable.
- *
- * <h3>Warning: Experimental OkHttp 2.0 API</h3>
- * This class is in beta. APIs are subject to change!
  */
 public final class Response {
   private final Request request;
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index 80065e4..63a5046 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -1,6 +1,7 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.Util;
 import java.io.DataInputStream;
 import java.io.IOException;
 import java.io.OutputStream;
@@ -115,6 +116,8 @@
   // TODO: huffman encoding!
   // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-4.1.2
   static class Reader {
+    private final Huffman.Codec huffmanCodec;
+
     private final DataInputStream in;
     private final List<ByteString> emittedHeaders = new ArrayList<ByteString>();
     private long bytesLeft = 0;
@@ -140,7 +143,8 @@
     int headerTableByteCount = 0;
     int maxHeaderTableByteCount = 4096; // TODO: needs to come from SETTINGS_HEADER_TABLE_SIZE.
 
-    Reader(DataInputStream in) {
+    Reader(boolean client, DataInputStream in) {
+      this.huffmanCodec = client ? Huffman.Codec.RESPONSE : Huffman.Codec.REQUEST;
       this.in = in;
     }
 
@@ -371,7 +375,10 @@
       int length = readInt(firstByte, PREFIX_8_BITS);
       if ((length & 0x80) == 0x80) { // 1NNNNNNN
         length &= ~0x80;
-        // TODO: actually decode huffman!
+        byte[] buff = new byte[length];
+        Util.readFully(in, buff);
+        bytesLeft -= length;
+        return ByteString.of(huffmanCodec.decode(buff));
       }
       bytesLeft -= length;
       return ByteString.read(in, length);
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index 1cfb93f..b124338 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -83,7 +83,7 @@
     Reader(InputStream in, boolean client) {
       this.in = new DataInputStream(in);
       this.client = client;
-      this.hpackReader = new HpackDraft05.Reader(this.in);
+      this.hpackReader = new HpackDraft05.Reader(client, this.in);
     }
 
     @Override public void readConnectionHeader() throws IOException {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
new file mode 100644
index 0000000..a7768d0
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
@@ -0,0 +1,279 @@
+/*
+ * Copyright 2013 Twitter, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * This class was originally composed from the following classes in
+ * <a href="https://github.com/twitter/hpack">Twitter Hpack</a>.
+ * <ul>
+ * <li>{@code com.twitter.hpack.HuffmanEncoder}</li>
+ * <li>{@code com.twitter.hpack.HuffmanDecoder}</li>
+ * <li>{@code com.twitter.hpack.HpackUtil}</li>
+ * </ul>
+ */
+class Huffman {
+  enum Codec {
+    REQUEST(REQUEST_CODES, REQUEST_CODE_LENGTHS),
+    RESPONSE(RESPONSE_CODES, RESPONSE_CODE_LENGTHS);
+
+    private final Node root = new Node();
+    private final int[] codes;
+    private final byte[] lengths;
+
+    /**
+     * @param codes Index designates the symbol this code represents.
+     * @param lengths Index designates the symbol this code represents.
+     */
+    Codec(int[] codes, byte[] lengths) {
+      buildTree(codes, lengths);
+      this.codes = codes;
+      this.lengths = lengths;
+    }
+
+    void encode(byte[] data, OutputStream out) throws IOException {
+      long current = 0;
+      int n = 0;
+
+      for (int i = 0; i < data.length; i++) {
+        int b = data[i] & 0xFF;
+        int code = codes[b];
+        int nbits = lengths[b];
+
+        current <<= nbits;
+        current |= code;
+        n += nbits;
+
+        while (n >= 8) {
+          n -= 8;
+          out.write(((int) (current >> n)));
+        }
+      }
+
+      if (n > 0) {
+        current <<= (8 - n);
+        current |= (0xFF >>> n);
+        out.write((int) current);
+      }
+    }
+
+    int encodedLength(byte[] bytes) {
+      long len = 0;
+
+      for (int i = 0; i < bytes.length; i++) {
+        int b = bytes[i] & 0xFF;
+        len += lengths[b];
+      }
+
+      return (int) ((len + 7) >> 3);
+    }
+
+    byte[] decode(byte[] buf) throws IOException {
+      // FIXME
+      ByteArrayOutputStream baos = new ByteArrayOutputStream();
+      Node node = root;
+      int current = 0;
+      int nbits = 0;
+      for (int i = 0; i < buf.length; i++) {
+        int b = buf[i] & 0xFF;
+        current = (current << 8) | b;
+        nbits += 8;
+        while (nbits >= 8) {
+          int c = (current >>> (nbits - 8)) & 0xFF;
+          node = node.children[c];
+          if (node.children == null) {
+            // terminal node
+            baos.write(node.symbol);
+            nbits -= node.terminalBits;
+            node = root;
+          } else {
+            // non-terminal node
+            nbits -= 8;
+          }
+        }
+      }
+
+      while (nbits > 0) {
+        int c = (current << (8 - nbits)) & 0xFF;
+        node = node.children[c];
+        if (node.children != null || node.terminalBits > nbits) {
+          break;
+        }
+        baos.write(node.symbol);
+        nbits -= node.terminalBits;
+        node = root;
+      }
+
+      return baos.toByteArray();
+    }
+
+    private void buildTree(int[] codes, byte[] lengths) {
+      for (int i = 0; i < lengths.length; i++) {
+        addCode(i, codes[i], lengths[i]);
+      }
+    }
+
+    private void addCode(int sym, int code, byte len) {
+      Node terminal = new Node(sym, len);
+
+      Node current = root;
+      while (len > 8) {
+        len -= 8;
+        int i = ((code >>> len) & 0xFF);
+        if (current.children == null) {
+          throw new IllegalStateException("invalid dictionary: prefix not unique");
+        }
+        if (current.children[i] == null) {
+          current.children[i] = new Node();
+        }
+        current = current.children[i];
+      }
+
+      int shift = 8 - len;
+      int start = (code << shift) & 0xFF;
+      int end = 1 << shift;
+      for (int i = start; i < start + end; i++) {
+        current.children[i] = terminal;
+      }
+    }
+  }
+
+  private static final class Node {
+
+    // Null if terminal.
+    private final Node[] children;
+
+    // Terminal nodes have a symbol.
+    private final int symbol;
+
+    // Number of bits represented in the terminal node.
+    private final int terminalBits;
+
+    /** Construct an internal node. */
+    Node() {
+      this.children = new Node[256];
+      this.symbol = 0; // Not read.
+      this.terminalBits = 0; // Not read.
+    }
+
+    /**
+     * Construct a terminal node.
+     *
+     * @param symbol symbol the node represents
+     * @param bits length of Huffman code in bits
+     */
+    Node(int symbol, int bits) {
+      this.children = null;
+      this.symbol = symbol;
+      int b = bits & 0x07;
+      this.terminalBits = b == 0 ? 8 : b;
+    }
+  }
+
+  // Appendix C: Huffman Codes For Requests
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-C
+  private static final int[] REQUEST_CODES = {
+      0x7ffffba, 0x7ffffbb, 0x7ffffbc, 0x7ffffbd, 0x7ffffbe, 0x7ffffbf, 0x7ffffc0, 0x7ffffc1,
+      0x7ffffc2, 0x7ffffc3, 0x7ffffc4, 0x7ffffc5, 0x7ffffc6, 0x7ffffc7, 0x7ffffc8, 0x7ffffc9,
+      0x7ffffca, 0x7ffffcb, 0x7ffffcc, 0x7ffffcd, 0x7ffffce, 0x7ffffcf, 0x7ffffd0, 0x7ffffd1,
+      0x7ffffd2, 0x7ffffd3, 0x7ffffd4, 0x7ffffd5, 0x7ffffd6, 0x7ffffd7, 0x7ffffd8, 0x7ffffd9, 0xe8,
+      0xffc, 0x3ffa, 0x7ffc, 0x7ffd, 0x24, 0x6e, 0x7ffe, 0x7fa, 0x7fb, 0x3fa, 0x7fc, 0xe9, 0x25,
+      0x4, 0x0, 0x5, 0x6, 0x7, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x1ec, 0xea, 0x3fffe, 0x2d,
+      0x1fffc, 0x1ed, 0x3ffb, 0x6f, 0xeb, 0xec, 0xed, 0xee, 0x70, 0x1ee, 0x1ef, 0x1f0, 0x1f1, 0x3fb,
+      0x1f2, 0xef, 0x1f3, 0x1f4, 0x1f5, 0x1f6, 0x1f7, 0xf0, 0xf1, 0x1f8, 0x1f9, 0x1fa, 0x1fb, 0x1fc,
+      0x3fc, 0x3ffc, 0x7ffffda, 0x1ffc, 0x3ffd, 0x2e, 0x7fffe, 0x8, 0x2f, 0x9, 0x30, 0x1, 0x31,
+      0x32, 0x33, 0xa, 0x71, 0x72, 0xb, 0x34, 0xc, 0xd, 0xe, 0xf2, 0xf, 0x10, 0x11, 0x35, 0x73,
+      0x36, 0xf3, 0xf4, 0xf5, 0x1fffd, 0x7fd, 0x1fffe, 0xffd, 0x7ffffdb, 0x7ffffdc, 0x7ffffdd,
+      0x7ffffde, 0x7ffffdf, 0x7ffffe0, 0x7ffffe1, 0x7ffffe2, 0x7ffffe3, 0x7ffffe4, 0x7ffffe5,
+      0x7ffffe6, 0x7ffffe7, 0x7ffffe8, 0x7ffffe9, 0x7ffffea, 0x7ffffeb, 0x7ffffec, 0x7ffffed,
+      0x7ffffee, 0x7ffffef, 0x7fffff0, 0x7fffff1, 0x7fffff2, 0x7fffff3, 0x7fffff4, 0x7fffff5,
+      0x7fffff6, 0x7fffff7, 0x7fffff8, 0x7fffff9, 0x7fffffa, 0x7fffffb, 0x7fffffc, 0x7fffffd,
+      0x7fffffe, 0x7ffffff, 0x3ffff80, 0x3ffff81, 0x3ffff82, 0x3ffff83, 0x3ffff84, 0x3ffff85,
+      0x3ffff86, 0x3ffff87, 0x3ffff88, 0x3ffff89, 0x3ffff8a, 0x3ffff8b, 0x3ffff8c, 0x3ffff8d,
+      0x3ffff8e, 0x3ffff8f, 0x3ffff90, 0x3ffff91, 0x3ffff92, 0x3ffff93, 0x3ffff94, 0x3ffff95,
+      0x3ffff96, 0x3ffff97, 0x3ffff98, 0x3ffff99, 0x3ffff9a, 0x3ffff9b, 0x3ffff9c, 0x3ffff9d,
+      0x3ffff9e, 0x3ffff9f, 0x3ffffa0, 0x3ffffa1, 0x3ffffa2, 0x3ffffa3, 0x3ffffa4, 0x3ffffa5,
+      0x3ffffa6, 0x3ffffa7, 0x3ffffa8, 0x3ffffa9, 0x3ffffaa, 0x3ffffab, 0x3ffffac, 0x3ffffad,
+      0x3ffffae, 0x3ffffaf, 0x3ffffb0, 0x3ffffb1, 0x3ffffb2, 0x3ffffb3, 0x3ffffb4, 0x3ffffb5,
+      0x3ffffb6, 0x3ffffb7, 0x3ffffb8, 0x3ffffb9, 0x3ffffba, 0x3ffffbb, 0x3ffffbc, 0x3ffffbd,
+      0x3ffffbe, 0x3ffffbf, 0x3ffffc0, 0x3ffffc1, 0x3ffffc2, 0x3ffffc3, 0x3ffffc4, 0x3ffffc5,
+      0x3ffffc6, 0x3ffffc7, 0x3ffffc8, 0x3ffffc9, 0x3ffffca, 0x3ffffcb, 0x3ffffcc, 0x3ffffcd,
+      0x3ffffce, 0x3ffffcf, 0x3ffffd0, 0x3ffffd1, 0x3ffffd2, 0x3ffffd3, 0x3ffffd4, 0x3ffffd5,
+      0x3ffffd6, 0x3ffffd7, 0x3ffffd8, 0x3ffffd9, 0x3ffffda, 0x3ffffdb
+  };
+
+  private static final byte[] REQUEST_CODE_LENGTHS = {
+      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
+      27, 27, 27, 27, 27, 27, 27, 27, 27, 8, 12, 14, 15, 15, 6, 7, 15, 11, 11, 10, 11, 8, 6, 5, 4,
+      5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 9, 8, 18, 6, 17, 9, 14, 7, 8, 8, 8, 8, 7, 9, 9, 9, 9, 10, 9, 8,
+      9, 9, 9, 9, 9, 8, 8, 9, 9, 9, 9, 9, 10, 14, 27, 13, 14, 6, 19, 5, 6, 5, 6, 4, 6, 6, 6, 5, 7,
+      7, 5, 6, 5, 5, 5, 8, 5, 5, 5, 6, 7, 6, 8, 8, 8, 17, 11, 17, 12, 27, 27, 27, 27, 27, 27, 27,
+      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
+      27, 27, 27, 27, 27, 27, 27, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+      26, 26, 26, 26, 26, 26, 26
+  };
+
+  // Appendix D: Huffman Codes For Responses
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-D
+  private static final int[] RESPONSE_CODES = {
+      0x1ffffbc, 0x1ffffbd, 0x1ffffbe, 0x1ffffbf, 0x1ffffc0, 0x1ffffc1, 0x1ffffc2, 0x1ffffc3,
+      0x1ffffc4, 0x1ffffc5, 0x1ffffc6, 0x1ffffc7, 0x1ffffc8, 0x1ffffc9, 0x1ffffca, 0x1ffffcb,
+      0x1ffffcc, 0x1ffffcd, 0x1ffffce, 0x1ffffcf, 0x1ffffd0, 0x1ffffd1, 0x1ffffd2, 0x1ffffd3,
+      0x1ffffd4, 0x1ffffd5, 0x1ffffd6, 0x1ffffd7, 0x1ffffd8, 0x1ffffd9, 0x1ffffda, 0x1ffffdb, 0x0,
+      0xffa, 0x6a, 0x1ffa, 0x3ffc, 0x1ec, 0x3f8, 0x1ffb, 0x1ed, 0x1ee, 0xffb, 0x7fa, 0x22, 0x23,
+      0x24, 0x6b, 0x1, 0x2, 0x3, 0x8, 0x9, 0xa, 0x25, 0x26, 0xb, 0xc, 0xd, 0x1ef, 0xfffa, 0x6c,
+      0x1ffc, 0xffc, 0xfffb, 0x6d, 0xea, 0xeb, 0xec, 0xed, 0xee, 0x27, 0x1f0, 0xef, 0xf0, 0x3f9,
+      0x1f1, 0x28, 0xf1, 0xf2, 0x1f2, 0x3fa, 0x1f3, 0x29, 0xe, 0x1f4, 0x1f5, 0xf3, 0x3fb, 0x1f6,
+      0x3fc, 0x7fb, 0x1ffd, 0x7fc, 0x7ffc, 0x1f7, 0x1fffe, 0xf, 0x6e, 0x2a, 0x2b, 0x10, 0x6f, 0x70,
+      0x71, 0x2c, 0x1f8, 0x1f9, 0x72, 0x2d, 0x2e, 0x2f, 0x30, 0x1fa, 0x31, 0x32, 0x33, 0x34, 0x73,
+      0xf4, 0x74, 0xf5, 0x1fb, 0xfffc, 0x3ffd, 0xfffd, 0xfffe, 0x1ffffdc, 0x1ffffdd, 0x1ffffde,
+      0x1ffffdf, 0x1ffffe0, 0x1ffffe1, 0x1ffffe2, 0x1ffffe3, 0x1ffffe4, 0x1ffffe5, 0x1ffffe6,
+      0x1ffffe7, 0x1ffffe8, 0x1ffffe9, 0x1ffffea, 0x1ffffeb, 0x1ffffec, 0x1ffffed, 0x1ffffee,
+      0x1ffffef, 0x1fffff0, 0x1fffff1, 0x1fffff2, 0x1fffff3, 0x1fffff4, 0x1fffff5, 0x1fffff6,
+      0x1fffff7, 0x1fffff8, 0x1fffff9, 0x1fffffa, 0x1fffffb, 0x1fffffc, 0x1fffffd, 0x1fffffe,
+      0x1ffffff, 0xffff80, 0xffff81, 0xffff82, 0xffff83, 0xffff84, 0xffff85, 0xffff86, 0xffff87,
+      0xffff88, 0xffff89, 0xffff8a, 0xffff8b, 0xffff8c, 0xffff8d, 0xffff8e, 0xffff8f, 0xffff90,
+      0xffff91, 0xffff92, 0xffff93, 0xffff94, 0xffff95, 0xffff96, 0xffff97, 0xffff98, 0xffff99,
+      0xffff9a, 0xffff9b, 0xffff9c, 0xffff9d, 0xffff9e, 0xffff9f, 0xffffa0, 0xffffa1, 0xffffa2,
+      0xffffa3, 0xffffa4, 0xffffa5, 0xffffa6, 0xffffa7, 0xffffa8, 0xffffa9, 0xffffaa, 0xffffab,
+      0xffffac, 0xffffad, 0xffffae, 0xffffaf, 0xffffb0, 0xffffb1, 0xffffb2, 0xffffb3, 0xffffb4,
+      0xffffb5, 0xffffb6, 0xffffb7, 0xffffb8, 0xffffb9, 0xffffba, 0xffffbb, 0xffffbc, 0xffffbd,
+      0xffffbe, 0xffffbf, 0xffffc0, 0xffffc1, 0xffffc2, 0xffffc3, 0xffffc4, 0xffffc5, 0xffffc6,
+      0xffffc7, 0xffffc8, 0xffffc9, 0xffffca, 0xffffcb, 0xffffcc, 0xffffcd, 0xffffce, 0xffffcf,
+      0xffffd0, 0xffffd1, 0xffffd2, 0xffffd3, 0xffffd4, 0xffffd5, 0xffffd6, 0xffffd7, 0xffffd8,
+      0xffffd9, 0xffffda, 0xffffdb, 0xffffdc
+  };
+
+  private static final byte[] RESPONSE_CODE_LENGTHS = {
+      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+      25, 25, 25, 25, 25, 25, 25, 25, 25, 4, 12, 7, 13, 14, 9, 10, 13, 9, 9, 12, 11, 6, 6, 6, 7, 4,
+      4, 4, 5, 5, 5, 6, 6, 5, 5, 5, 9, 16, 7, 13, 12, 16, 7, 8, 8, 8, 8, 8, 6, 9, 8, 8, 10, 9, 6, 8,
+      8, 9, 10, 9, 6, 5, 9, 9, 8, 10, 9, 10, 11, 13, 11, 15, 9, 17, 5, 7, 6, 6, 5, 7, 7, 7, 6, 9, 9,
+      7, 6, 6, 6, 6, 9, 6, 6, 6, 6, 7, 8, 7, 8, 9, 16, 14, 16, 16, 25, 25, 25, 25, 25, 25, 25, 25,
+      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+      25, 25, 25, 25, 25, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+      24, 24, 24, 24, 24, 24
+  };
+}
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index 7397042..2ddb843 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -39,7 +39,7 @@
   private HpackDraft05.Reader hpackReader;
 
   @Before public void resetReader() {
-    hpackReader = new HpackDraft05.Reader(new DataInputStream(bytesIn));
+    hpackReader = new HpackDraft05.Reader(false, new DataInputStream(bytesIn));
   }
 
   /**
@@ -171,12 +171,10 @@
     hpackReader.emitReferenceSet();
 
     assertEquals(1, hpackReader.headerCount);
-    // this will change when we decode huffman
-    assertEquals(48, hpackReader.headerTableByteCount);
+    assertEquals(52, hpackReader.headerTableByteCount);
 
     HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
-    // TODO: huffman bytes are not what we want!
-    checkEntry(entry, ":path", new String(huffmanBytes, "UTF-8"), 48);
+    checkEntry(entry, ":path", "www.example.com", 52);
     assertHeaderReferenced(headerTableLength() - 1);
   }
 
@@ -472,17 +470,237 @@
         "custom-key", "custom-value"), hpackReader.getAndReset());
   }
 
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.3
+   */
+  @Test public void decodeRequestExamplesWithHuffman() throws IOException {
+    ByteArrayOutputStream out = firstRequestWithHuffman();
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+    checkFirstRequestWithHuffman();
+
+    out = secondRequestWithHuffman();
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+    checkSecondRequestWithHuffman();
+
+    out = thirdRequestWithHuffman();
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+    checkThirdRequestWithHuffman();
+  }
+
+  private ByteArrayOutputStream firstRequestWithHuffman() {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x82); // == Indexed - Add ==
+                     // idx = 2 -> :method: GET
+    out.write(0x87); // == Indexed - Add ==
+                     // idx = 7 -> :scheme: http
+    out.write(0x86); // == Indexed - Add ==
+                     // idx = 6 -> :path: /
+    out.write(0x04); // == Literal indexed ==
+                     // Indexed name (idx = 4) -> :authority
+    out.write(0x8b); // Literal value Huffman encoded 11 bytes
+                     // decodes to www.example.com which is length 15
+    byte[] huffmanBytes = new byte[] {
+        (byte) 0xdb, (byte) 0x6d, (byte) 0x88, (byte) 0x3e,
+        (byte) 0x68, (byte) 0xd1, (byte) 0xcb, (byte) 0x12,
+        (byte) 0x25, (byte) 0xba, (byte) 0x7f};
+    out.write(huffmanBytes, 0, huffmanBytes.length);
+
+    return out;
+  }
+
+  private void checkFirstRequestWithHuffman() {
+    assertEquals(4, hpackReader.headerCount);
+
+    // [  1] (s =  57) :authority: www.example.com
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 4];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+    assertHeaderReferenced(headerTableLength() - 4);
+
+    // [  2] (s =  38) :path: /
+    entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, ":path", "/", 38);
+    assertHeaderReferenced(headerTableLength() - 3);
+
+    // [  3] (s =  43) :scheme: http
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, ":scheme", "http", 43);
+    assertHeaderReferenced(headerTableLength() - 2);
+
+    // [  4] (s =  42) :method: GET
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
+
+    // Table size: 180
+    assertEquals(180, hpackReader.headerTableByteCount);
+
+    // Decoded header set:
+    assertEquals(byteStringList(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com"), hpackReader.getAndReset());
+  }
+
+  private ByteArrayOutputStream secondRequestWithHuffman() {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x1b); // == Literal indexed ==
+                     // Indexed name (idx = 27) -> cache-control
+    out.write(0x86); // Literal value Huffman encoded 6 bytes
+                     // decodes to no-cache which is length 8
+    byte[] huffmanBytes = new byte[] {
+        (byte) 0x63, (byte) 0x65, (byte) 0x4a, (byte) 0x13,
+        (byte) 0x98, (byte) 0xff};
+    out.write(huffmanBytes, 0, huffmanBytes.length);
+
+    return out;
+  }
+
+  private void checkSecondRequestWithHuffman() {
+    assertEquals(5, hpackReader.headerCount);
+
+    // [  1] (s =  53) cache-control: no-cache
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 5];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+    assertHeaderReferenced(headerTableLength() - 5);
+
+    // [  2] (s =  57) :authority: www.example.com
+    entry = hpackReader.headerTable[headerTableLength() - 4];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+    assertHeaderReferenced(headerTableLength() - 4);
+
+    // [  3] (s =  38) :path: /
+    entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, ":path", "/", 38);
+    assertHeaderReferenced(headerTableLength() - 3);
+
+    // [  4] (s =  43) :scheme: http
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, ":scheme", "http", 43);
+    assertHeaderReferenced(headerTableLength() - 2);
+
+    // [  5] (s =  42) :method: GET
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
+
+    // Table size: 233
+    assertEquals(233, hpackReader.headerTableByteCount);
+
+    // Decoded header set:
+    assertEquals(byteStringList(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com",
+        "cache-control", "no-cache"), hpackReader.getAndReset());
+  }
+
+  private ByteArrayOutputStream thirdRequestWithHuffman() {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x80); // == Empty reference set ==
+    out.write(0x85); // == Indexed - Add ==
+                     // idx = 5 -> :method: GET
+    out.write(0x8c); // == Indexed - Add ==
+                     // idx = 12 -> :scheme: https
+    out.write(0x8b); // == Indexed - Add ==
+                     // idx = 11 -> :path: /index.html
+    out.write(0x84); // == Indexed - Add ==
+                     // idx = 4 -> :authority: www.example.com
+    out.write(0x00); // Literal indexed
+    out.write(0x88); // Literal name Huffman encoded 8 bytes
+                     // decodes to custom-key which is length 10
+    byte[] huffmanBytes = new byte[] {
+        (byte) 0x4e, (byte) 0xb0, (byte) 0x8b, (byte) 0x74,
+        (byte) 0x97, (byte) 0x90, (byte) 0xfa, (byte) 0x7f};
+    out.write(huffmanBytes, 0, huffmanBytes.length);
+    out.write(0x89); // Literal value Huffman encoded 6 bytes
+                     // decodes to custom-value which is length 12
+    huffmanBytes = new byte[] {
+        (byte) 0x4e, (byte) 0xb0, (byte) 0x8b, (byte) 0x74,
+        (byte) 0x97, (byte) 0x9a, (byte) 0x17, (byte) 0xa8,
+        (byte) 0xff};
+    out.write(huffmanBytes, 0, huffmanBytes.length);
+
+    return out;
+  }
+
+  private void checkThirdRequestWithHuffman() {
+    assertEquals(8, hpackReader.headerCount);
+
+    // [  1] (s =  54) custom-key: custom-value
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 8];
+    checkEntry(entry, "custom-key", "custom-value", 54);
+    assertHeaderReferenced(headerTableLength() - 8);
+
+    // [  2] (s =  48) :path: /index.html
+    entry = hpackReader.headerTable[headerTableLength() - 7];
+    checkEntry(entry, ":path", "/index.html", 48);
+    assertHeaderReferenced(headerTableLength() - 7);
+
+    // [  3] (s =  44) :scheme: https
+    entry = hpackReader.headerTable[headerTableLength() - 6];
+    checkEntry(entry, ":scheme", "https", 44);
+    assertHeaderReferenced(headerTableLength() - 6);
+
+    // [  4] (s =  53) cache-control: no-cache
+    entry = hpackReader.headerTable[headerTableLength() - 5];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+    assertHeaderNotReferenced(headerTableLength() - 5);
+
+    // [  5] (s =  57) :authority: www.example.com
+    entry = hpackReader.headerTable[headerTableLength() - 4];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+    assertHeaderReferenced(headerTableLength() - 4);
+
+    // [  6] (s =  38) :path: /
+    entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, ":path", "/", 38);
+    assertHeaderNotReferenced(headerTableLength() - 3);
+
+    // [  7] (s =  43) :scheme: http
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, ":scheme", "http", 43);
+    assertHeaderNotReferenced(headerTableLength() - 2);
+
+    // [  8] (s =  42) :method: GET
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
+
+    // Table size: 379
+    assertEquals(379, hpackReader.headerTableByteCount);
+
+    // Decoded header set:
+    // TODO: order is not correct per docs, but then again, the spec doesn't require ordering.
+    assertEquals(byteStringList(
+        ":method", "GET",
+        ":authority", "www.example.com",
+        ":scheme", "https",
+        ":path", "/index.html",
+        "custom-key", "custom-value"), hpackReader.getAndReset());
+  }
+
   private ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
   private final HpackDraft05.Writer hpackWriter =
       new HpackDraft05.Writer(new DataOutputStream(bytesOut));
 
   @Test public void readSingleByteInt() throws IOException {
-    assertEquals(10, new HpackDraft05.Reader(byteStream()).readInt(10, 31));
-    assertEquals(10, new HpackDraft05.Reader(byteStream()).readInt(0xe0 | 10, 31));
+    assertEquals(10, new HpackDraft05.Reader(false, byteStream()).readInt(10, 31));
+    assertEquals(10, new HpackDraft05.Reader(false, byteStream()).readInt(0xe0 | 10, 31));
   }
 
   @Test public void readMultibyteInt() throws IOException {
-    assertEquals(1337, new HpackDraft05.Reader(byteStream(154, 10)).readInt(31, 31));
+    assertEquals(1337, new HpackDraft05.Reader(false, byteStream(154, 10)).readInt(31, 31));
   }
 
   @Test public void writeSingleByteInt() throws IOException {
@@ -503,44 +721,44 @@
     hpackWriter.writeInt(0x7fffffff, 31, 0);
     assertBytes(31, 224, 255, 255, 255, 7);
     assertEquals(0x7fffffff,
-        new HpackDraft05.Reader(byteStream(224, 255, 255, 255, 7)).readInt(31, 31));
+        new HpackDraft05.Reader(false, byteStream(224, 255, 255, 255, 7)).readInt(31, 31));
   }
 
   @Test public void prefixMask() throws IOException {
     hpackWriter.writeInt(31, 31, 0);
     assertBytes(31, 0);
-    assertEquals(31, new HpackDraft05.Reader(byteStream(0)).readInt(31, 31));
+    assertEquals(31, new HpackDraft05.Reader(false, byteStream(0)).readInt(31, 31));
   }
 
   @Test public void prefixMaskMinusOne() throws IOException {
     hpackWriter.writeInt(30, 31, 0);
     assertBytes(30);
-    assertEquals(31, new HpackDraft05.Reader(byteStream(0)).readInt(31, 31));
+    assertEquals(31, new HpackDraft05.Reader(false, byteStream(0)).readInt(31, 31));
   }
 
   @Test public void zero() throws IOException {
     hpackWriter.writeInt(0, 31, 0);
     assertBytes(0);
-    assertEquals(0, new HpackDraft05.Reader(byteStream()).readInt(0, 31));
+    assertEquals(0, new HpackDraft05.Reader(false, byteStream()).readInt(0, 31));
   }
 
   @Test public void headerName() throws IOException {
     hpackWriter.writeByteString(ByteString.encodeUtf8("foo"));
     assertBytes(3, 'f', 'o', 'o');
-    assertEquals("foo", new HpackDraft05.Reader(byteStream(3, 'f', 'o', 'o')).readString().utf8());
+    assertEquals("foo", new HpackDraft05.Reader(false, byteStream(3, 'f', 'o', 'o')).readString().utf8());
   }
 
   @Test public void emptyHeaderName() throws IOException {
     hpackWriter.writeByteString(ByteString.encodeUtf8(""));
     assertBytes(0);
-    assertEquals("", new HpackDraft05.Reader(byteStream(0)).readString().utf8());
+    assertEquals("", new HpackDraft05.Reader(false, byteStream(0)).readString().utf8());
   }
 
   @Test public void headersRoundTrip() throws IOException {
     List<ByteString> sentHeaders = byteStringList("name", "value");
     hpackWriter.writeHeaders(sentHeaders);
     ByteArrayInputStream bytesIn = new ByteArrayInputStream(bytesOut.toByteArray());
-    HpackDraft05.Reader reader = new HpackDraft05.Reader(new DataInputStream(bytesIn));
+    HpackDraft05.Reader reader = new HpackDraft05.Reader(false, new DataInputStream(bytesIn));
     reader.readHeaders(bytesOut.size());
     reader.emitReferenceSet();
     List<ByteString> receivedHeaders = reader.getAndReset();
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
new file mode 100644
index 0000000..6206b7e
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2013 Twitter, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Random;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Original version of this class was lifted from {@code com.twitter.hpack.HuffmanTest}.
+ */
+public class HuffmanTest {
+
+  @Test public void roundTripForRequestAndResponse() throws IOException {
+    String s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
+    for (int i = 0; i < s.length(); i++) {
+      assertRoundTrip(s.substring(0, i).getBytes());
+    }
+
+    Random random = new Random(123456789L);
+    byte[] buf = new byte[4096];
+    random.nextBytes(buf);
+    assertRoundTrip(buf);
+  }
+
+  private void assertRoundTrip(byte[] buf) throws IOException {
+    assertRoundTrip(Huffman.Codec.REQUEST, buf);
+    assertRoundTrip(Huffman.Codec.RESPONSE, buf);
+  }
+
+  private static void assertRoundTrip(Huffman.Codec codec, byte[] buf) throws IOException {
+    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    DataOutputStream dos = new DataOutputStream(baos);
+
+    codec.encode(buf, dos);
+    assertEquals(baos.size(), codec.encodedLength(buf));
+
+    byte[] decodedBytes = codec.decode(baos.toByteArray());
+    assertTrue(Arrays.equals(buf, decodedBytes));
+  }
+}
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
index 483f3cd..36d5466 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
@@ -38,6 +38,7 @@
 
     int responseCode = connection.getResponseCode();
     System.out.println(responseCode);
+    System.out.println(connection.getHeaderFields());
 
     BufferedReader reader =
         new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
index d5884b1..5aa4606 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -153,14 +153,16 @@
       setHostname = openSslSocketClass.getMethod("setHostname", String.class);
 
       // Attempt to find Android 4.1+ APIs.
+      Method setNpnProtocols = null;
+      Method getNpnSelectedProtocol = null;
       try {
-        Method setNpnProtocols = openSslSocketClass.getMethod("setNpnProtocols", byte[].class);
-        Method getNpnSelectedProtocol = openSslSocketClass.getMethod("getNpnSelectedProtocol");
-        return new Android41(openSslSocketClass, setUseSessionTickets, setHostname,
-            setNpnProtocols, getNpnSelectedProtocol);
+        setNpnProtocols = openSslSocketClass.getMethod("setNpnProtocols", byte[].class);
+        getNpnSelectedProtocol = openSslSocketClass.getMethod("getNpnSelectedProtocol");
       } catch (NoSuchMethodException ignored) {
-        return new Android23(openSslSocketClass, setUseSessionTickets, setHostname);
       }
+
+      return new Android(openSslSocketClass, setUseSessionTickets, setHostname, setNpnProtocols,
+          getNpnSelectedProtocol);
     } catch (ClassNotFoundException ignored) {
       // This isn't an Android runtime.
     } catch (NoSuchMethodException ignored) {
@@ -187,17 +189,28 @@
     return new Platform();
   }
 
-  /** Android version 2.3 and newer support TLS session tickets and server name indication (SNI). */
-  private static class Android23 extends Platform {
+  /**
+   * Android 2.3 or better. Version 2.3 supports TLS session tickets and server
+   * name indication (SNI). Versions 4.1 supports NPN.
+   */
+  private static class Android extends Platform {
+    // Non-null.
     protected final Class<?> openSslSocketClass;
     private final Method setUseSessionTickets;
     private final Method setHostname;
 
-    private Android23(
-        Class<?> openSslSocketClass, Method setUseSessionTickets, Method setHostname) {
+    // Non-null on Android 4.1+
+    private final Method setNpnProtocols;
+    private final Method getNpnSelectedProtocol;
+
+    private Android(
+        Class<?> openSslSocketClass, Method setUseSessionTickets, Method setHostname,
+        Method setNpnProtocols, Method getNpnSelectedProtocol) {
       this.openSslSocketClass = openSslSocketClass;
       this.setUseSessionTickets = setUseSessionTickets;
       this.setHostname = setHostname;
+      this.setNpnProtocols = setNpnProtocols;
+      this.getNpnSelectedProtocol = getNpnSelectedProtocol;
     }
 
     @Override public void connectSocket(Socket socket, InetSocketAddress address,
@@ -215,36 +228,20 @@
 
     @Override public void enableTlsExtensions(SSLSocket socket, String uriHost) {
       super.enableTlsExtensions(socket, uriHost);
-      if (openSslSocketClass.isInstance(socket)) {
-        // This is Android: use reflection on OpenSslSocketImpl.
-        try {
-          setUseSessionTickets.invoke(socket, true);
-          setHostname.invoke(socket, uriHost);
-        } catch (InvocationTargetException e) {
-          throw new RuntimeException(e);
-        } catch (IllegalAccessException e) {
-          throw new AssertionError(e);
-        }
+      if (!openSslSocketClass.isInstance(socket)) return;
+      try {
+        setUseSessionTickets.invoke(socket, true);
+        setHostname.invoke(socket, uriHost);
+      } catch (InvocationTargetException e) {
+        throw new RuntimeException(e);
+      } catch (IllegalAccessException e) {
+        throw new AssertionError(e);
       }
     }
-  }
-
-  /** Android version 4.1 and newer support NPN. */
-  private static class Android41 extends Android23 {
-    private final Method setNpnProtocols;
-    private final Method getNpnSelectedProtocol;
-
-    private Android41(Class<?> openSslSocketClass, Method setUseSessionTickets, Method setHostname,
-        Method setNpnProtocols, Method getNpnSelectedProtocol) {
-      super(openSslSocketClass, setUseSessionTickets, setHostname);
-      this.setNpnProtocols = setNpnProtocols;
-      this.getNpnSelectedProtocol = getNpnSelectedProtocol;
-    }
 
     @Override public void setNpnProtocols(SSLSocket socket, byte[] npnProtocols) {
-      if (!openSslSocketClass.isInstance(socket)) {
-        return;
-      }
+      if (setNpnProtocols == null) return;
+      if (!openSslSocketClass.isInstance(socket)) return;
       try {
         setNpnProtocols.invoke(socket, new Object[] {npnProtocols});
       } catch (IllegalAccessException e) {
@@ -255,9 +252,8 @@
     }
 
     @Override public byte[] getNpnSelectedProtocol(SSLSocket socket) {
-      if (!openSslSocketClass.isInstance(socket)) {
-        return null;
-      }
+      if (getNpnSelectedProtocol == null) return null;
+      if (!openSslSocketClass.isInstance(socket)) return null;
       try {
         return (byte[]) getNpnSelectedProtocol.invoke(socket);
       } catch (InvocationTargetException e) {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/BitArray.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/BitArray.java
new file mode 100644
index 0000000..b453afe
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/BitArray.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2014 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/** A simple bitset which supports left shifting. */
+public final class BitArray {
+  /** Create a bit array from a bit-packed long. */
+  public static BitArray fromValue(long bitLong) {
+    return new BitArray(bitLong);
+  }
+
+  long[] data;
+
+  // Start offset which allows for cheap shifting. Data is always kept on 64-bit bounds but we
+  // offset the outward facing index to support shifts without having to move the underlying bits.
+  private int start; // Valid values are [0..63]
+
+  BitArray() {
+    data = new long[1];
+  }
+
+  private BitArray(long bitLong) {
+    data = new long[] { bitLong, 0 };
+  }
+
+  private void growToSize(int size) {
+    long[] newData = new long[size];
+    if (data != null) {
+      System.arraycopy(data, 0, newData, 0, data.length);
+    }
+    data = newData;
+  }
+
+  private int offsetOf(int index) {
+    index += start;
+    int offset = index / 64;
+    if (offset > data.length - 1) {
+      growToSize(offset + 1);
+    }
+    return offset;
+  }
+
+  private int shiftOf(int index) {
+    return (index + start) % 64;
+  }
+
+  public void clear() {
+    Arrays.fill(data, 0);
+  }
+
+  public void set(int index) {
+    if (index < 0) {
+      throw new IllegalArgumentException("index < 0: " + index);
+    }
+    int offset = offsetOf(index);
+    data[offset] |= 1L << shiftOf(index);
+  }
+
+  public void unset(int index) {
+    if (index < 0) {
+      throw new IllegalArgumentException("index < 0: " + index);
+    }
+    int offset = offsetOf(index);
+    data[offset] &= ~(1L << shiftOf(index));
+  }
+
+  public boolean get(int index) {
+    if (index < 0) {
+      throw new IllegalArgumentException("index < 0: " + index);
+    }
+    int offset = offsetOf(index);
+    return (data[offset] & (1L << shiftOf(index))) != 0;
+  }
+
+  public void shiftLeft(int count) {
+    if (count < 0) {
+      throw new IllegalArgumentException("count < 0: " + count);
+    }
+    start -= count;
+    if (start < 0) {
+      int arrayShift = (start / -64) + 1;
+      long[] newData = new long[data.length + arrayShift];
+      System.arraycopy(data, 0, newData, arrayShift, data.length);
+      data = newData;
+      start = 64 + (start % 64);
+    }
+  }
+
+  @Override public String toString() {
+    StringBuilder builder = new StringBuilder("{");
+    List<Integer> ints = toIntegerList();
+    for (int i = 0, count = ints.size(); i < count; i++) {
+      if (i > 0) {
+        builder.append(',');
+      }
+      builder.append(ints.get(i));
+    }
+    return builder.append('}').toString();
+  }
+
+  List<Integer> toIntegerList() {
+    List<Integer> ints = new ArrayList<Integer>();
+    for (int i = 0, count = data.length * 64 - start; i < count; i++) {
+      if (get(i)) {
+        ints.add(i);
+      }
+    }
+    return ints;
+  }
+}
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java
new file mode 100644
index 0000000..85ba915
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright 2014 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import java.math.BigInteger;
+import org.junit.Test;
+
+import static java.util.Arrays.asList;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class BitArrayTest {
+  @Test public void initializeFromLong() {
+    long bits = 1L | (1L << 3) | (1L << 7);
+    BitArray b = BitArray.fromValue(bits);
+    assertTrue(b.get(0));
+    assertTrue(b.get(3));
+    assertTrue(b.get(7));
+  }
+
+  @Test public void initializedFullFromLong() {
+    long bits = -1;
+    BitArray b = BitArray.fromValue(bits);
+    for (int i = 0; i < 64; i++) {
+      assertTrue(b.get(i));
+    }
+  }
+
+  @Test public void hpackUseCase() {
+    long bits = 1L | (1L << 63);
+    BitArray b = BitArray.fromValue(bits);
+    assertTrue(b.get(0));
+    assertFalse(b.get(1));
+    assertTrue(b.get(63));
+    assertFalse(b.get(64));
+    b.set(64);
+    assertTrue(b.get(64));
+  }
+
+  @Test public void setExpandsData() {
+    BitArray b = new BitArray();
+    b.set(64);
+    assertEquals(asList(64), b.toIntegerList());
+  }
+
+  @Test public void clearBit() {
+    BitArray b = new BitArray();
+    b.set(100);
+    b.unset(100);
+    assertTrue(b.toIntegerList().isEmpty());
+  }
+
+  @Test public void shiftLeftExpandsData() {
+    BitArray b = new BitArray();
+    b.set(0);
+    b.shiftLeft(64);
+    assertEquals(asList(64), b.toIntegerList());
+  }
+
+  @Test public void shiftLeftFromZero() {
+    BitArray b = new BitArray();
+    b.set(0);
+    b.shiftLeft(1);
+    assertEquals(asList(1), b.toIntegerList());
+  }
+
+  @Test public void shiftLeftAcrossOffset() {
+    BitArray b = new BitArray();
+    b.set(63);
+    assertEquals(1, b.data.length);
+    b.shiftLeft(1);
+    assertEquals(asList(64), b.toIntegerList());
+    assertEquals(2, b.data.length);
+  }
+
+  @Test public void multipleShiftsLeftAcrossOffset() {
+    BitArray b = new BitArray();
+    b.set(1000);
+    b.shiftLeft(67);
+    assertEquals(asList(1067), b.toIntegerList());
+    b.shiftLeft(69);
+    assertEquals(asList(1136), b.toIntegerList());
+  }
+
+  @Test public void clearBits() {
+    BitArray b = new BitArray();
+    b.set(10);
+    b.set(100);
+    b.set(1000);
+    b.clear();
+    assertTrue(b.toIntegerList().isEmpty());
+  }
+
+  @Test public void bigIntegerSanityCheck() {
+    BitArray a = new BitArray();
+    BigInteger b = BigInteger.ZERO;
+
+    a.set(64);
+    b = b.setBit(64);
+    assertEquals(bigIntegerToString(b), a.toString());
+
+    a.set(1000000);
+    b = b.setBit(1000000);
+    assertEquals(bigIntegerToString(b), a.toString());
+
+    a.shiftLeft(100);
+    b = b.shiftLeft(100);
+    assertEquals(bigIntegerToString(b), a.toString());
+
+    a.set(0xF00D);
+    b = b.setBit(0xF00D);
+    a.set(0xBEEF);
+    b = b.setBit(0xBEEF);
+    a.set(0xDEAD);
+    b = b.setBit(0xDEAD);
+    assertEquals(bigIntegerToString(b), a.toString());
+
+    a.shiftLeft(0xB0B);
+    b = b.shiftLeft(0xB0B);
+    assertEquals(bigIntegerToString(b), a.toString());
+
+    a.unset(64280);
+    b = b.clearBit(64280);
+    assertEquals(bigIntegerToString(b), a.toString());
+  }
+
+  private static String bigIntegerToString(BigInteger b) {
+    StringBuilder builder = new StringBuilder("{");
+    for (int i = 0, count = b.bitLength(); i < count; i++) {
+      if (b.testBit(i)) {
+        builder.append(i).append(',');
+      }
+    }
+    builder.setCharAt(builder.length() - 1, '}');
+    return builder.toString();
+  }
+}
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
index 9356cdf..6bdc540 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -356,8 +356,11 @@
    * without a compile-time dependency on those interfaces.
    */
   private static class JettyNpnProvider implements InvocationHandler {
+    /** This peer's supported protocols. */
     private final List<String> protocols;
+    /** Set when remote peer notifies NPN is unsupported. */
     private boolean unsupported;
+    /** When server, this is the protocol the client selected. */
     private String selected;
 
     public JettyNpnProvider(List<String> protocols) {
@@ -371,22 +374,27 @@
         args = Util.EMPTY_STRING_ARRAY;
       }
       if (methodName.equals("supports") && boolean.class == returnType) {
-        return true;
+        return true; // Client supports NPN.
       } else if (methodName.equals("unsupported") && void.class == returnType) {
-        this.unsupported = true;
+        this.unsupported = true; // Remote peer doesn't support NPN.
         return null;
       } else if (methodName.equals("protocols") && args.length == 0) {
-        return protocols;
-      } else if (methodName.equals("selectProtocol")
+        return protocols; // Server advertises these protocols.
+      } else if (methodName.equals("selectProtocol") // Called when client.
           && String.class == returnType
           && args.length == 1
           && (args[0] == null || args[0] instanceof List)) {
-        // TODO: use OpenSSL's algorithm which uses both lists
-        List<?> serverProtocols = (List) args[0];
-        this.selected = protocols.get(0);
-        return selected;
+        List<String> serverProtocols = (List) args[0];
+        // Pick the first protocol the server advertises and client knows.
+        for (int i = 0, size = serverProtocols.size(); i < size; i++) {
+          if (protocols.contains(serverProtocols.get(i))) {
+            return serverProtocols.get(i);
+          }
+        }
+        // On no intersection, try client's first protocol.
+        return protocols.get(0);
       } else if (methodName.equals("protocolSelected") && args.length == 1) {
-        this.selected = (String) args[0];
+        this.selected = (String) args[0]; // Client selected this protocol.
         return null;
       } else {
         return method.invoke(this, args);
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/BitArray.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/BitArray.java
index 3e700ad..253900d 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/BitArray.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/BitArray.java
@@ -65,12 +65,12 @@
     data[offset] |= 1L << shiftOf(index);
   }
 
-  public void unset(int index) {
+  public void toggle(int index) {
     if (index < 0) {
       throw new IllegalArgumentException("index < 0: " + index);
     }
     int offset = offsetOf(index);
-    data[offset] &= ~(1L << shiftOf(index));
+    data[offset] ^= 1L << shiftOf(index);
   }
 
   public boolean get(int index) {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index 07d2c1e..229ae67 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -251,11 +251,8 @@
           HeaderEntry staticEntry = STATIC_HEADER_TABLE[index - headerCount];
           insertIntoHeaderTable(-1, staticEntry);
         }
-      } else if (!referencedHeaders.get(headerTableIndex(index))) {
-        referencedHeaders.set(headerTableIndex(index));
       } else {
-        // TODO: we should throw something that we can coerce to a PROTOCOL_ERROR
-        throw new AssertionError("invalid index " + index);
+        referencedHeaders.toggle(headerTableIndex(index));
       }
     }
 
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java
index 5ecc9d7..afbba1c 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java
@@ -20,6 +20,7 @@
 
 import static java.util.Arrays.asList;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 public class BitArrayTest {
@@ -30,11 +31,13 @@
     assertEquals(asList(64), b.toIntegerList());
   }
 
-  @Test public void clearBit() {
+  @Test public void toggleBit() {
     BitArray b = new BitArray();
     b.set(100);
-    b.unset(100);
+    b.toggle(100);
     assertTrue(b.toIntegerList().isEmpty());
+    b.toggle(1);
+    assertEquals(asList(1), b.toIntegerList());
   }
 
   @Test public void shiftLeftExpandsData() {
@@ -106,7 +109,7 @@
     b = b.shiftLeft(0xB0B);
     assertEquals(bigIntegerToString(b), a.toString());
 
-    a.unset(64280);
+    a.toggle(64280);
     b = b.clearBit(64280);
     assertEquals(bigIntegerToString(b), a.toString());
   }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index fdcbc75..4e3cf29 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -234,6 +234,33 @@
   }
 
   /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-3.2.1
+   */
+  @Test public void toggleIndex() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    // Static table entries are copied to the top of the reference set.
+    out.write(0x82); // == Indexed - Add ==
+                     // idx = 2 -> :method: GET
+    // Specifying an index to an entry in the reference set removes it.
+    out.write(0x81); // == Indexed - Remove ==
+                     // idx = 1 -> :method: GET
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(42, hpackReader.headerTableByteCount);
+
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderNotReferenced(headerTableLength() - 1);
+
+    assertTrue(hpackReader.getAndReset().isEmpty());
+  }
+
+  /**
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.4
    */
   @Test public void decodeIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
index e62f218..d295891 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
@@ -18,26 +18,48 @@
     // H T T P / 1 . 1   2 0 0   T e m p o r a r y   R e d i r e c t
     // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
 
-    // We allow empty message without leading white space since some servers
-    // do not send the white space when the message is empty.
-    boolean hasMessage = statusLine.length() > 13;
-    if (!statusLine.startsWith("HTTP/1.")
-        || statusLine.length() < 12
-        || statusLine.charAt(8) != ' '
-        || (hasMessage && statusLine.charAt(12) != ' ')) {
+    // Parse protocol like "HTTP/1.1" followed by a space.
+    int codeStart;
+    int httpMinorVersion;
+    if (statusLine.startsWith("HTTP/1.")) {
+      if (statusLine.length() < 9 || statusLine.charAt(8) != ' ') {
+        throw new ProtocolException("Unexpected status line: " + statusLine);
+      }
+      httpMinorVersion = statusLine.charAt(7) - '0';
+      codeStart = 9;
+      if (httpMinorVersion < 0 || httpMinorVersion > 9) {
+        throw new ProtocolException("Unexpected status line: " + statusLine);
+      }
+    } else if (statusLine.startsWith("ICY ")) {
+      // Shoutcast uses ICY instead of "HTTP/1.0".
+      httpMinorVersion = 0;
+      codeStart = 4;
+    } else {
       throw new ProtocolException("Unexpected status line: " + statusLine);
     }
-    int httpMinorVersion = statusLine.charAt(7) - '0';
-    if (httpMinorVersion < 0 || httpMinorVersion > 9) {
+
+    // Parse response code like "200". Always 3 digits.
+    if (statusLine.length() < codeStart + 3) {
       throw new ProtocolException("Unexpected status line: " + statusLine);
     }
     int responseCode;
     try {
-      responseCode = Integer.parseInt(statusLine.substring(9, 12));
+      responseCode = Integer.parseInt(statusLine.substring(codeStart, codeStart + 3));
     } catch (NumberFormatException e) {
       throw new ProtocolException("Unexpected status line: " + statusLine);
     }
-    this.responseMessage = hasMessage ? statusLine.substring(13) : "";
+
+    // Parse an optional response message like "OK" or "Not Modified". If it
+    // exists, it is separated from the response code by a space.
+    String responseMessage = "";
+    if (statusLine.length() > codeStart + 3) {
+      if (statusLine.charAt(codeStart + 3) != ' ') {
+        throw new ProtocolException("Unexpected status line: " + statusLine);
+      }
+      responseMessage = statusLine.substring(codeStart + 4);
+    }
+
+    this.responseMessage = responseMessage;
     this.responseCode = responseCode;
     this.statusLine = statusLine;
     this.httpMinorVersion = httpMinorVersion;
@@ -64,5 +86,4 @@
   public String message() {
     return responseMessage;
   }
-
 }
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
index bc92397..c3ea3a9 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
@@ -16,8 +16,10 @@
 package com.squareup.okhttp.internal.http;
 
 import java.io.IOException;
+import java.net.ProtocolException;
 import org.junit.Test;
 
+import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertEquals;
 
 public final class StatusLineTest {
@@ -53,4 +55,63 @@
     assertEquals(version, statusLine.httpMinorVersion());
     assertEquals(code, statusLine.code());
   }
+
+  // https://github.com/square/okhttp/issues/386
+  @Test public void shoutcast() throws IOException {
+    StatusLine statusLine = new StatusLine("ICY 200 OK");
+    assertEquals("OK", statusLine.message());
+    assertEquals(0, statusLine.httpMinorVersion());
+    assertEquals(200, statusLine.code());
+  }
+
+  @Test public void missingProtocol() throws IOException {
+    assertInvalid("");
+    assertInvalid(" ");
+    assertInvalid("200 OK");
+    assertInvalid(" 200 OK");
+  }
+
+  @Test public void protocolVersions() throws IOException {
+    assertInvalid("HTTP/2.0 200 OK");
+    assertInvalid("HTTP/2.1 200 OK");
+    assertInvalid("HTTP/-.1 200 OK");
+    assertInvalid("HTTP/1.- 200 OK");
+    assertInvalid("HTTP/0.1 200 OK");
+    assertInvalid("HTTP/101 200 OK");
+    assertInvalid("HTTP/1.1_200 OK");
+  }
+
+  @Test public void nonThreeDigitCode() throws IOException {
+    assertInvalid("HTTP/1.1  OK");
+    assertInvalid("HTTP/1.1 2 OK");
+    assertInvalid("HTTP/1.1 20 OK");
+    assertInvalid("HTTP/1.1 2000 OK");
+    assertInvalid("HTTP/1.1 two OK");
+    assertInvalid("HTTP/1.1 2");
+    assertInvalid("HTTP/1.1 2000");
+    assertInvalid("HTTP/1.1 two");
+  }
+
+  @Test public void truncated() throws IOException {
+    assertInvalid("");
+    assertInvalid("H");
+    assertInvalid("HTTP/1");
+    assertInvalid("HTTP/1.");
+    assertInvalid("HTTP/1.1");
+    assertInvalid("HTTP/1.1 ");
+    assertInvalid("HTTP/1.1 2");
+    assertInvalid("HTTP/1.1 20");
+  }
+
+  @Test public void wrongMessageDelimiter() throws IOException {
+    assertInvalid("HTTP/1.1 200_");
+  }
+
+  private void assertInvalid(String statusLine) throws IOException {
+    try {
+      new StatusLine(statusLine);
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
 }
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index 04734cc..5704b6b 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -1324,6 +1324,32 @@
     }
   }
 
+  @Test public void shoutcast() throws Exception {
+    server.enqueue(new MockResponse().setStatus("ICY 200 OK")
+        // .addHeader("HTTP/1.0 200 OK")
+        .addHeader("Accept-Ranges: none")
+        .addHeader("Content-Type: audio/mpeg")
+        .addHeader("icy-br:128")
+        .addHeader("ice-audio-info: bitrate=128;samplerate=44100;channels=2")
+        .addHeader("icy-br:128")
+        .addHeader("icy-description:Rock")
+        .addHeader("icy-genre:riders")
+        .addHeader("icy-name:A2RRock")
+        .addHeader("icy-pub:1")
+        .addHeader("icy-url:http://www.A2Rradio.com")
+        .addHeader("Server: Icecast 2.3.3-kh8")
+        .addHeader("Cache-Control: no-cache")
+        .addHeader("Pragma: no-cache")
+        .addHeader("Expires: Mon, 26 Jul 1997 05:00:00 GMT")
+        .addHeader("icy-metaint:16000")
+        .setBody("mp3 data"));
+    server.play();
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("OK", connection.getResponseMessage());
+    assertContent("mp3 data", connection);
+  }
+
   @Test public void cannotSetNegativeFixedLengthStreamingMode() throws Exception {
     server.play();
     HttpURLConnection connection = client.open(server.getUrl("/"));
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
index 57ab491..e135ef7 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
@@ -16,7 +16,6 @@
 
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.File;
@@ -34,7 +33,7 @@
 import javax.net.ssl.SSLSocketFactory;
 import org.eclipse.jetty.npn.NextProtoNego;
 
-import static com.squareup.okhttp.internal.Util.byteStringList;
+import static com.squareup.okhttp.internal.Util.headerEntries;
 
 /** A basic SPDY server that serves the contents of a local directory. */
 public final class SpdyServer implements IncomingStreamHandler {
@@ -82,12 +81,11 @@
   }
 
   @Override public void receive(final SpdyStream stream) throws IOException {
-    List<ByteString> requestHeaders = stream.getRequestHeaders();
+    List<Header> requestHeaders = stream.getRequestHeaders();
     String path = null;
-    for (int i = 0; i < requestHeaders.size(); i += 2) {
-      ByteString s = requestHeaders.get(i);
-      if (s.utf8Equals(":path")) {
-        path = requestHeaders.get(i + 1).utf8();
+    for (int i = 0; i < requestHeaders.size(); i++) {
+      if (requestHeaders.get(i).name.equals(Header.TARGET_PATH)) {
+        path = requestHeaders.get(i).value.utf8();
         break;
       }
     }
@@ -109,8 +107,8 @@
   }
 
   private void send404(SpdyStream stream, String path) throws IOException {
-    List<ByteString> responseHeaders =
-        byteStringList(":status", "404", ":version", "HTTP/1.1", "content-type", "text/plain");
+    List<Header> responseHeaders =
+        headerEntries(":status", "404", ":version", "HTTP/1.1", "content-type", "text/plain");
     stream.reply(responseHeaders, true);
     OutputStream out = stream.getOutputStream();
     String text = "Not found: " + path;
@@ -119,8 +117,8 @@
   }
 
   private void serveDirectory(SpdyStream stream, String[] files) throws IOException {
-    List<ByteString> responseHeaders =
-        byteStringList(":status", "200", ":version", "HTTP/1.1", "content-type",
+    List<Header> responseHeaders =
+        headerEntries(":status", "200", ":version", "HTTP/1.1", "content-type",
             "text/html; charset=UTF-8");
     stream.reply(responseHeaders, true);
     OutputStream out = stream.getOutputStream();
@@ -135,7 +133,7 @@
     InputStream in = new FileInputStream(file);
     byte[] buffer = new byte[8192];
     stream.reply(
-        byteStringList(":status", "200", ":version", "HTTP/1.1", "content-type", contentType(file)),
+        headerEntries(":status", "200", ":version", "HTTP/1.1", "content-type", contentType(file)),
         true);
     OutputStream out = stream.getOutputStream();
     int count;
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 95cd2a1..124fb2e 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -22,6 +22,7 @@
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.spdy.Header;
 import com.squareup.okhttp.internal.spdy.IncomingStreamHandler;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.spdy.SpdyStream;
@@ -615,14 +616,14 @@
     }
 
     private RecordedRequest readRequest(SpdyStream stream) throws IOException {
-      List<ByteString> spdyHeaders = stream.getRequestHeaders();
+      List<Header> spdyHeaders = stream.getRequestHeaders();
       List<String> httpHeaders = new ArrayList<String>();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
-      String version = "<:version omitted>";
-      for (int i = 0, size = spdyHeaders.size(); i < size; i += 2) {
-        String name = spdyHeaders.get(i).utf8();
-        String value = spdyHeaders.get(i + 1).utf8();
+      String version = protocol == Protocol.SPDY_3 ? "<:version omitted>" : "HTTP/1.1";
+      for (int i = 0, size = spdyHeaders.size(); i < size; i++) {
+        String name = spdyHeaders.get(i).name.utf8();
+        String value = spdyHeaders.get(i).value.utf8();
         if (":method".equals(name)) {
           method = value;
         } else if (":path".equals(name)) {
@@ -652,17 +653,16 @@
       if (response.getSocketPolicy() == SocketPolicy.NO_RESPONSE) {
         return;
       }
-      List<ByteString> spdyHeaders = new ArrayList<ByteString>();
+      List<Header> spdyHeaders = new ArrayList<Header>();
       String[] statusParts = response.getStatus().split(" ", 2);
       if (statusParts.length != 2) {
         throw new AssertionError("Unexpected status: " + response.getStatus());
       }
       // TODO: constants for well-known header names.
-      spdyHeaders.add(ByteString.encodeUtf8(":status"));
-      spdyHeaders.add(ByteString.encodeUtf8(statusParts[1]));
-      // TODO: no ":version" header for HTTP/2.0, only SPDY.
-      spdyHeaders.add(ByteString.encodeUtf8(":version"));
-      spdyHeaders.add(ByteString.encodeUtf8(statusParts[0]));
+      spdyHeaders.add(new Header(Header.RESPONSE_STATUS, statusParts[1]));
+      if (protocol == Protocol.SPDY_3) {
+        spdyHeaders.add(new Header(Header.VERSION, statusParts[0]));
+      }
       List<String> headers = response.getHeaders();
       for (int i = 0, size = headers.size(); i < size; i++) {
         String header = headers.get(i);
@@ -670,8 +670,8 @@
         if (headerParts.length != 2) {
           throw new AssertionError("Unexpected header: " + header);
         }
-        spdyHeaders.add(ByteString.encodeUtf8(headerParts[0].toLowerCase(Locale.US).trim()));
-        spdyHeaders.add(ByteString.encodeUtf8(headerParts[1].trim()));
+        spdyHeaders.add(new Header(headerParts[0].toLowerCase(Locale.US).trim(),
+            headerParts[1].trim()));
       }
       byte[] body = response.getBody();
       stream.reply(spdyHeaders, body.length > 0);
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/ByteString.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/ByteString.java
index 51abec5..2fdf65d 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/ByteString.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/ByteString.java
@@ -61,17 +61,14 @@
     return new ByteString(bytes);
   }
 
-  /**
-   * Returns a new byte string containing the {@code UTF-8} bytes of {@code s},
-   * or {@link #EMPTY} if {@code s} is zero length.
-   */
+  /** Returns a new byte string containing the {@code UTF-8} bytes of {@code s}. */
   public static ByteString encodeUtf8(String s) {
     ByteString byteString = new ByteString(s.getBytes(Util.UTF_8));
     byteString.utf8 = s;
     return byteString;
   }
 
-  /** Constructs a new {@code String} by decoding the bytes as UTF-8. */
+  /** Constructs a new {@code String} by decoding the bytes as {@code UTF-8}. */
   public String utf8() {
     String result = utf8;
     // We don't care if we double-allocate in racy code.
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
index ed325ba..e1f3169 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -16,6 +16,7 @@
 
 package com.squareup.okhttp.internal;
 
+import com.squareup.okhttp.internal.spdy.Header;
 import java.io.ByteArrayInputStream;
 import java.io.Closeable;
 import java.io.EOFException;
@@ -400,18 +401,10 @@
     };
   }
 
-  public static List<ByteString> byteStringList(String... elements) {
-    List<ByteString> result = new ArrayList<ByteString>(elements.length);
-    for (String string : elements) {
-      result.add(ByteString.encodeUtf8(string));
-    }
-    return result;
-  }
-
-  public static List<ByteString> byteStringList(List<String> elements) {
-    List<ByteString> result = new ArrayList<ByteString>(elements.size());
-    for (int i = 0, size = elements.size(); i < size; i++) {
-      result.add(ByteString.encodeUtf8(elements.get(i)));
+  public static List<Header> headerEntries(String... elements) {
+    List<Header> result = new ArrayList<Header>(elements.length / 2);
+    for (int i = 0; i < elements.length; i += 2) {
+      result.add(new Header(elements[i], elements[i + 1]));
     }
     return result;
   }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
index a222860..5c0888c 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -16,7 +16,6 @@
 
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
@@ -44,7 +43,7 @@
      * (highest) thru 7 (lowest). For HTTP/2.0, priorities range from 0
      */
     void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-        int priority, List<ByteString> nameValueBlock, HeadersMode headersMode);
+        int priority, List<Header> nameValueBlock, HeadersMode headersMode);
     void rstStream(int streamId, ErrorCode errorCode);
     void settings(boolean clearPrevious, Settings settings);
     void noop();
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
index 94abc1c..63d2007 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -16,7 +16,6 @@
 
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
 import java.io.Closeable;
 import java.io.IOException;
 import java.util.List;
@@ -30,10 +29,10 @@
   /** SPDY/3 only. */
   void flush() throws IOException;
   void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      int priority, int slot, List<ByteString> nameValueBlock) throws IOException;
-  void synReply(boolean outFinished, int streamId, List<ByteString> nameValueBlock)
+      int priority, int slot, List<Header> nameValueBlock) throws IOException;
+  void synReply(boolean outFinished, int streamId, List<Header> nameValueBlock)
       throws IOException;
-  void headers(int streamId, List<ByteString> nameValueBlock) throws IOException;
+  void headers(int streamId, List<Header> nameValueBlock) throws IOException;
   void rstStream(int streamId, ErrorCode errorCode) throws IOException;
   void data(boolean outFinished, int streamId, byte[] data) throws IOException;
   void data(boolean outFinished, int streamId, byte[] data, int offset, int byteCount)
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Header.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
new file mode 100644
index 0000000..7b1f44b
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
@@ -0,0 +1,56 @@
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.ByteString;
+
+/** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
+public final class Header {
+  // Special header names defined in the SPDY and HTTP/2 specs.
+  public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(":status");
+  public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(":method");
+  public static final ByteString TARGET_PATH = ByteString.encodeUtf8(":path");
+  public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(":scheme");
+  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority"); // http/2
+  public static final ByteString TARGET_HOST = ByteString.encodeUtf8(":host"); // spdy/3
+  public static final ByteString VERSION = ByteString.encodeUtf8(":version"); // spdy/3
+
+  /** Name in case-insensitive ASCII encoding. */
+  public final ByteString name;
+  /** Value in UTF-8 encoding. */
+  public final ByteString value;
+  final int hpackSize;
+
+  // TODO: search for toLowerCase and consider moving logic here.
+  public Header(String name, String value) {
+    this(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value));
+  }
+
+  public Header(ByteString name, String value) {
+    this(name, ByteString.encodeUtf8(value));
+  }
+
+  public Header(ByteString name, ByteString value) {
+    this.name = name;
+    this.value = value;
+    this.hpackSize = 32 + name.size() + value.size();
+  }
+
+  @Override public boolean equals(Object other) {
+    if (other instanceof Header) {
+      Header that = (Header) other;
+      return this.name.equals(that.name)
+          && this.value.equals(that.value);
+    }
+    return false;
+  }
+
+  @Override public int hashCode() {
+    int result = 17;
+    result = 31 * result + name.hashCode();
+    result = 31 * result + value.hashCode();
+    return result;
+  }
+
+  @Override public String toString() {
+    return String.format("%s: %s", name.utf8(), value.utf8());
+  }
+}
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index d351d0b..a9e8b25 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -20,93 +20,71 @@
  * position moving forward.  When the array fills, it is doubled.
  */
 final class HpackDraft05 {
-
-  // Visible for testing.
-  static class HeaderEntry {
-    final ByteString name;
-    final ByteString value;
-    final int size;
-
-    HeaderEntry(String name, String value) {
-      this(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value));
-    }
-
-    HeaderEntry(ByteString name, ByteString value) {
-      this(name, value, 32 + name.size() + value.size());
-    }
-
-    private HeaderEntry(ByteString name, ByteString value, int size) {
-      this.name = name;
-      this.value = value;
-      this.size = size;
-    }
-  }
-
   private static final int PREFIX_6_BITS = 0x3f;
   private static final int PREFIX_7_BITS = 0x7f;
   private static final int PREFIX_8_BITS = 0xff;
 
-  private static final HeaderEntry[] STATIC_HEADER_TABLE = new HeaderEntry[] {
-      new HeaderEntry(":authority", ""),
-      new HeaderEntry(":method", "GET"),
-      new HeaderEntry(":method", "POST"),
-      new HeaderEntry(":path", "/"),
-      new HeaderEntry(":path", "/index.html"),
-      new HeaderEntry(":scheme", "http"),
-      new HeaderEntry(":scheme", "https"),
-      new HeaderEntry(":status", "200"),
-      new HeaderEntry(":status", "500"),
-      new HeaderEntry(":status", "404"),
-      new HeaderEntry(":status", "403"),
-      new HeaderEntry(":status", "400"),
-      new HeaderEntry(":status", "401"),
-      new HeaderEntry("accept-charset", ""),
-      new HeaderEntry("accept-encoding", ""),
-      new HeaderEntry("accept-language", ""),
-      new HeaderEntry("accept-ranges", ""),
-      new HeaderEntry("accept", ""),
-      new HeaderEntry("access-control-allow-origin", ""),
-      new HeaderEntry("age", ""),
-      new HeaderEntry("allow", ""),
-      new HeaderEntry("authorization", ""),
-      new HeaderEntry("cache-control", ""),
-      new HeaderEntry("content-disposition", ""),
-      new HeaderEntry("content-encoding", ""),
-      new HeaderEntry("content-language", ""),
-      new HeaderEntry("content-length", ""),
-      new HeaderEntry("content-location", ""),
-      new HeaderEntry("content-range", ""),
-      new HeaderEntry("content-type", ""),
-      new HeaderEntry("cookie", ""),
-      new HeaderEntry("date", ""),
-      new HeaderEntry("etag", ""),
-      new HeaderEntry("expect", ""),
-      new HeaderEntry("expires", ""),
-      new HeaderEntry("from", ""),
-      new HeaderEntry("host", ""),
-      new HeaderEntry("if-match", ""),
-      new HeaderEntry("if-modified-since", ""),
-      new HeaderEntry("if-none-match", ""),
-      new HeaderEntry("if-range", ""),
-      new HeaderEntry("if-unmodified-since", ""),
-      new HeaderEntry("last-modified", ""),
-      new HeaderEntry("link", ""),
-      new HeaderEntry("location", ""),
-      new HeaderEntry("max-forwards", ""),
-      new HeaderEntry("proxy-authenticate", ""),
-      new HeaderEntry("proxy-authorization", ""),
-      new HeaderEntry("range", ""),
-      new HeaderEntry("referer", ""),
-      new HeaderEntry("refresh", ""),
-      new HeaderEntry("retry-after", ""),
-      new HeaderEntry("server", ""),
-      new HeaderEntry("set-cookie", ""),
-      new HeaderEntry("strict-transport-security", ""),
-      new HeaderEntry("transfer-encoding", ""),
-      new HeaderEntry("user-agent", ""),
-      new HeaderEntry("vary", ""),
-      new HeaderEntry("via", ""),
-      new HeaderEntry("www-authenticate", "")
+  private static final Header[] STATIC_HEADER_TABLE = new Header[] {
+      new Header(Header.TARGET_AUTHORITY, ""),
+      new Header(Header.TARGET_METHOD, "GET"),
+      new Header(Header.TARGET_METHOD, "POST"),
+      new Header(Header.TARGET_PATH, "/"),
+      new Header(Header.TARGET_PATH, "/index.html"),
+      new Header(Header.TARGET_SCHEME, "http"),
+      new Header(Header.TARGET_SCHEME, "https"),
+      new Header(Header.RESPONSE_STATUS, "200"),
+      new Header(Header.RESPONSE_STATUS, "500"),
+      new Header(Header.RESPONSE_STATUS, "404"),
+      new Header(Header.RESPONSE_STATUS, "403"),
+      new Header(Header.RESPONSE_STATUS, "400"),
+      new Header(Header.RESPONSE_STATUS, "401"),
+      new Header("accept-charset", ""),
+      new Header("accept-encoding", ""),
+      new Header("accept-language", ""),
+      new Header("accept-ranges", ""),
+      new Header("accept", ""),
+      new Header("access-control-allow-origin", ""),
+      new Header("age", ""),
+      new Header("allow", ""),
+      new Header("authorization", ""),
+      new Header("cache-control", ""),
+      new Header("content-disposition", ""),
+      new Header("content-encoding", ""),
+      new Header("content-language", ""),
+      new Header("content-length", ""),
+      new Header("content-location", ""),
+      new Header("content-range", ""),
+      new Header("content-type", ""),
+      new Header("cookie", ""),
+      new Header("date", ""),
+      new Header("etag", ""),
+      new Header("expect", ""),
+      new Header("expires", ""),
+      new Header("from", ""),
+      new Header("host", ""),
+      new Header("if-match", ""),
+      new Header("if-modified-since", ""),
+      new Header("if-none-match", ""),
+      new Header("if-range", ""),
+      new Header("if-unmodified-since", ""),
+      new Header("last-modified", ""),
+      new Header("link", ""),
+      new Header("location", ""),
+      new Header("max-forwards", ""),
+      new Header("proxy-authenticate", ""),
+      new Header("proxy-authorization", ""),
+      new Header("range", ""),
+      new Header("referer", ""),
+      new Header("refresh", ""),
+      new Header("retry-after", ""),
+      new Header("server", ""),
+      new Header("set-cookie", ""),
+      new Header("strict-transport-security", ""),
+      new Header("transfer-encoding", ""),
+      new Header("user-agent", ""),
+      new Header("vary", ""),
+      new Header("via", ""),
+      new Header("www-authenticate", "")
   };
 
   private HpackDraft05() {
@@ -118,12 +96,12 @@
     private final Huffman.Codec huffmanCodec;
 
     private final DataInputStream in;
-    private final List<ByteString> emittedHeaders = new ArrayList<ByteString>();
+    private final List<Header> emittedHeaders = new ArrayList<Header>();
     private int maxHeaderTableByteCount;
     private long bytesLeft = 0;
 
     // Visible for testing.
-    HeaderEntry[] headerTable = new HeaderEntry[8];
+    Header[] headerTable = new Header[8];
     // Array is populated back to front, so new entries always have lowest index.
     int nextHeaderIndex = headerTable.length - 1;
     int headerCount = 0;
@@ -139,7 +117,7 @@
      * emitted.
      */
     // Using a long since the static table < 64 entries.
-    long referencedStaticHeaders = 0L;;
+    long referencedStaticHeaders = 0L;
     int headerTableByteCount = 0;
 
     Reader(boolean client, int maxHeaderTableByteCount, DataInputStream in) {
@@ -166,8 +144,8 @@
       if (bytesToRecover > 0) {
         // determine how many headers need to be evicted.
         for (int j = headerTable.length - 1; j >= nextHeaderIndex && bytesToRecover > 0; j--) {
-          bytesToRecover -= headerTable[j].size;
-          headerTableByteCount -= headerTable[j].size;
+          bytesToRecover -= headerTable[j].hpackSize;
+          headerTableByteCount -= headerTable[j].hpackSize;
           headerCount--;
           entriesToEvict++;
         }
@@ -222,14 +200,12 @@
     public void emitReferenceSet() {
       for (int i = 0; i < STATIC_HEADER_TABLE.length; ++i) {
         if (((referencedStaticHeaders >> i) & 1L) == 1) {
-          emittedHeaders.add(STATIC_HEADER_TABLE[i].name);
-          emittedHeaders.add(STATIC_HEADER_TABLE[i].value);
+          emittedHeaders.add(STATIC_HEADER_TABLE[i]);
         }
       }
       for (int i = headerTable.length - 1; i != nextHeaderIndex; --i) {
         if (referencedHeaders.get(i)) {
-          emittedHeaders.add(headerTable[i].name);
-          emittedHeaders.add(headerTable[i].value);
+          emittedHeaders.add(headerTable[i]);
         }
       }
     }
@@ -238,8 +214,8 @@
      * Returns all headers emitted since they were last cleared, then clears the
      * emitted headers.
      */
-    public List<ByteString> getAndReset() {
-      List<ByteString> result = new ArrayList<ByteString>(emittedHeaders);
+    public List<Header> getAndReset() {
+      List<Header> result = new ArrayList<Header>(emittedHeaders);
       emittedHeaders.clear();
       return result;
     }
@@ -249,7 +225,7 @@
         if (maxHeaderTableByteCount == 0) {
           referencedStaticHeaders |= (1L << (index - headerCount));
         } else {
-          HeaderEntry staticEntry = STATIC_HEADER_TABLE[index - headerCount];
+          Header staticEntry = STATIC_HEADER_TABLE[index - headerCount];
           insertIntoHeaderTable(-1, staticEntry);
         }
       } else {
@@ -265,28 +241,26 @@
     private void readLiteralHeaderWithoutIndexingIndexedName(int index) throws IOException {
       ByteString name = getName(index);
       ByteString value = readString();
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
+      emittedHeaders.add(new Header(name, value));
     }
 
     private void readLiteralHeaderWithoutIndexingNewName() throws IOException {
       ByteString name = readString();
       ByteString value = readString();
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
+      emittedHeaders.add(new Header(name, value));
     }
 
     private void readLiteralHeaderWithIncrementalIndexingIndexedName(int nameIndex)
         throws IOException {
       ByteString name = getName(nameIndex);
       ByteString value = readString();
-      insertIntoHeaderTable(-1, new HeaderEntry(name, value));
+      insertIntoHeaderTable(-1, new Header(name, value));
     }
 
     private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
       ByteString name = readString();
       ByteString value = readString();
-      insertIntoHeaderTable(-1, new HeaderEntry(name, value));
+      insertIntoHeaderTable(-1, new Header(name, value));
     }
 
     private ByteString getName(int index) {
@@ -302,10 +276,10 @@
     }
 
     /** index == -1 when new. */
-    private void insertIntoHeaderTable(int index, HeaderEntry entry) {
-      int delta = entry.size;
+    private void insertIntoHeaderTable(int index, Header entry) {
+      int delta = entry.hpackSize;
       if (index != -1) { // Index -1 == new header.
-        delta -= headerTable[headerTableIndex(index)].size;
+        delta -= headerTable[headerTableIndex(index)].hpackSize;
       }
 
       // if the new or replacement header is too big, drop all entries.
@@ -316,8 +290,7 @@
         headerCount = 0;
         headerTableByteCount = 0;
         // emit the large header to the callback.
-        emittedHeaders.add(entry.name);
-        emittedHeaders.add(entry.value);
+        emittedHeaders.add(entry);
         return;
       }
 
@@ -327,7 +300,7 @@
 
       if (index == -1) {
         if (headerCount + 1 > headerTable.length) {
-          HeaderEntry[] doubled = new HeaderEntry[headerTable.length * 2];
+          Header[] doubled = new Header[headerTable.length * 2];
           System.arraycopy(headerTable, 0, doubled, headerTable.length, headerTable.length);
           if (doubled.length == 64) {
             referencedHeaders = ((BitArray.FixedCapacity) referencedHeaders).toVariableCapacity();
@@ -390,7 +363,7 @@
         return ByteString.of(huffmanCodec.decode(buff));
       }
       bytesLeft -= length;
-      return ByteString.read(in, length);
+      return length == 0 ? ByteString.EMPTY : ByteString.read(in, length);
     }
   }
 
@@ -401,12 +374,12 @@
       this.out = out;
     }
 
-    public void writeHeaders(List<ByteString> nameValueBlock) throws IOException {
+    public void writeHeaders(List<Header> nameValueBlock) throws IOException {
       // TODO: implement a compression strategy.
-      for (int i = 0, size = nameValueBlock.size(); i < size; i += 2) {
+      for (int i = 0, size = nameValueBlock.size(); i < size; i++) {
         out.write(0x40); // Literal Header without Indexing - New Name.
-        writeByteString(nameValueBlock.get(i));
-        writeByteString(nameValueBlock.get(i + 1));
+        writeByteString(nameValueBlock.get(i).name);
+        writeByteString(nameValueBlock.get(i).value);
       }
     }
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index 94108d2..1aa4870 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -15,7 +15,6 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.Util;
 import java.io.ByteArrayOutputStream;
@@ -186,7 +185,7 @@
 
         if ((flags & FLAG_END_HEADERS) != 0) {
           hpackReader.emitReferenceSet();
-          List<ByteString> nameValueBlock = hpackReader.getAndReset();
+          List<Header> nameValueBlock = hpackReader.getAndReset();
           // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
           // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3
           int priority = -1; // TODO: priority
@@ -337,24 +336,24 @@
 
     @Override
     public synchronized void synStream(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, int slot, List<ByteString> nameValueBlock)
+        int associatedStreamId, int priority, int slot, List<Header> nameValueBlock)
         throws IOException {
       if (inFinished) throw new UnsupportedOperationException();
       headers(outFinished, streamId, priority, nameValueBlock);
     }
 
     @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<ByteString> nameValueBlock) throws IOException {
+        List<Header> nameValueBlock) throws IOException {
       headers(outFinished, streamId, -1, nameValueBlock);
     }
 
-    @Override public synchronized void headers(int streamId, List<ByteString> nameValueBlock)
+    @Override public synchronized void headers(int streamId, List<Header> nameValueBlock)
         throws IOException {
       headers(false, streamId, -1, nameValueBlock);
     }
 
     private void headers(boolean outFinished, int streamId, int priority,
-        List<ByteString> nameValueBlock) throws IOException {
+        List<Header> nameValueBlock) throws IOException {
       hpackBuffer.reset();
       hpackWriter.writeHeaders(nameValueBlock);
       int type = TYPE_HEADERS;
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
index 85af6ed..5a45bcd 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
@@ -72,7 +72,7 @@
     }
   }
 
-  public List<ByteString> readNameValueBlock(int length) throws IOException {
+  public List<Header> readNameValueBlock(int length) throws IOException {
     this.compressedLimit += length;
     try {
       int numberOfPairs = nameValueBlockIn.readInt();
@@ -82,13 +82,12 @@
       if (numberOfPairs > 1024) {
         throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
       }
-      List<ByteString> entries = new ArrayList<ByteString>(numberOfPairs * 2);
+      List<Header> entries = new ArrayList<Header>(numberOfPairs);
       for (int i = 0; i < numberOfPairs; i++) {
         ByteString name = readString();
         ByteString values = readString();
         if (name.size() == 0) throw new IOException("name.size == 0");
-        entries.add(name);
-        entries.add(values);
+        entries.add(new Header(name, values));
       }
 
       doneReading();
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index 3fc0b59..2859eff 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -213,7 +213,7 @@
       int associatedStreamId = w2 & 0x7fffffff;
       int priority = (s3 & 0xe000) >>> 13;
       int slot = s3 & 0xff;
-      List<ByteString> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 10);
+      List<Header> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 10);
 
       boolean inFinished = (flags & FLAG_FIN) != 0;
       boolean outFinished = (flags & FLAG_UNIDIRECTIONAL) != 0;
@@ -224,7 +224,7 @@
     private void readSynReply(Handler handler, int flags, int length) throws IOException {
       int w1 = in.readInt();
       int streamId = w1 & 0x7fffffff;
-      List<ByteString> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 4);
+      List<Header> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 4);
       boolean inFinished = (flags & FLAG_FIN) != 0;
       handler.headers(false, inFinished, streamId, -1, -1, nameValueBlock, HeadersMode.SPDY_REPLY);
     }
@@ -243,7 +243,7 @@
     private void readHeaders(Handler handler, int flags, int length) throws IOException {
       int w1 = in.readInt();
       int streamId = w1 & 0x7fffffff;
-      List<ByteString> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 4);
+      List<Header> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 4);
       handler.headers(false, false, streamId, -1, -1, nameValueBlock, HeadersMode.SPDY_HEADERS);
     }
 
@@ -332,7 +332,7 @@
 
     @Override
     public synchronized void synStream(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, int slot, List<ByteString> nameValueBlock)
+        int associatedStreamId, int priority, int slot, List<Header> nameValueBlock)
         throws IOException {
       writeNameValueBlockToBuffer(nameValueBlock);
       int length = 10 + nameValueBlockBuffer.size();
@@ -350,7 +350,7 @@
     }
 
     @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<ByteString> nameValueBlock) throws IOException {
+        List<Header> nameValueBlock) throws IOException {
       writeNameValueBlockToBuffer(nameValueBlock);
       int type = TYPE_SYN_REPLY;
       int flags = (outFinished ? FLAG_FIN : 0);
@@ -363,7 +363,7 @@
       out.flush();
     }
 
-    @Override public synchronized void headers(int streamId, List<ByteString> nameValueBlock)
+    @Override public synchronized void headers(int streamId, List<Header> nameValueBlock)
         throws IOException {
       writeNameValueBlockToBuffer(nameValueBlock);
       int flags = 0;
@@ -403,14 +403,16 @@
       out.write(data, offset, byteCount);
     }
 
-    private void writeNameValueBlockToBuffer(List<ByteString> nameValueBlock) throws IOException {
+    private void writeNameValueBlockToBuffer(List<Header> nameValueBlock) throws IOException {
       nameValueBlockBuffer.reset();
-      int numberOfPairs = nameValueBlock.size() / 2;
-      nameValueBlockOut.writeInt(numberOfPairs);
+      nameValueBlockOut.writeInt(nameValueBlock.size());
       for (int i = 0, size = nameValueBlock.size(); i < size; i++) {
-        ByteString s = nameValueBlock.get(i);
-        nameValueBlockOut.writeInt(s.size());
-        s.write(nameValueBlockOut);
+        ByteString name = nameValueBlock.get(i).name;
+        nameValueBlockOut.writeInt(name.size());
+        name.write(nameValueBlockOut);
+        ByteString value = nameValueBlock.get(i).value;
+        nameValueBlockOut.writeInt(value.size());
+        value.write(nameValueBlockOut);
       }
       nameValueBlockOut.flush();
     }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index e854e12..606b2ab 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -16,7 +16,6 @@
 
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.Util;
@@ -159,7 +158,7 @@
    * @param in true to create an input stream that the remote peer can use to
    *     send data to us. Corresponds to {@code FLAG_UNIDIRECTIONAL}.
    */
-  public SpdyStream newStream(List<ByteString> requestHeaders, boolean out, boolean in)
+  public SpdyStream newStream(List<Header> requestHeaders, boolean out, boolean in)
       throws IOException {
     boolean outFinished = !out;
     boolean inFinished = !in;
@@ -191,7 +190,7 @@
     return stream;
   }
 
-  void writeSynReply(int streamId, boolean outFinished, List<ByteString> alternating)
+  void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
       throws IOException {
     frameWriter.synReply(outFinished, streamId, alternating);
   }
@@ -480,7 +479,7 @@
     }
 
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<ByteString> nameValueBlock,
+        int associatedStreamId, int priority, List<Header> nameValueBlock,
         HeadersMode headersMode) {
       SpdyStream stream;
       synchronized (SpdyConnection.this) {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index 5bb79c9..dbfb2dc 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -16,7 +16,6 @@
 
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.io.InputStream;
@@ -49,10 +48,10 @@
   private long readTimeoutMillis = 0;
 
   /** Headers sent by the stream initiator. Immutable and non null. */
-  private final List<ByteString> requestHeaders;
+  private final List<Header> requestHeaders;
 
   /** Headers sent in the stream reply. Null if reply is either not sent or not sent yet. */
-  private List<ByteString> responseHeaders;
+  private List<Header> responseHeaders;
 
   private final SpdyDataInputStream in;
   private final SpdyDataOutputStream out;
@@ -65,7 +64,7 @@
   private ErrorCode errorCode = null;
 
   SpdyStream(int id, SpdyConnection connection, boolean outFinished, boolean inFinished,
-      int priority, List<ByteString> requestHeaders, Settings peerSettings) {
+      int priority, List<Header> requestHeaders, Settings peerSettings) {
     if (connection == null) throw new NullPointerException("connection == null");
     if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
     this.id = id;
@@ -109,7 +108,7 @@
     return connection;
   }
 
-  public List<ByteString> getRequestHeaders() {
+  public List<Header> getRequestHeaders() {
     return requestHeaders;
   }
 
@@ -117,7 +116,7 @@
    * Returns the stream's response headers, blocking if necessary if they
    * have not been received yet.
    */
-  public synchronized List<ByteString> getResponseHeaders() throws IOException {
+  public synchronized List<Header> getResponseHeaders() throws IOException {
     long remaining = 0;
     long start = 0;
     if (readTimeoutMillis != 0) {
@@ -161,7 +160,7 @@
    * @param out true to create an output stream that we can use to send data
    * to the remote peer. Corresponds to {@code FLAG_FIN}.
    */
-  public void reply(List<ByteString> responseHeaders, boolean out) throws IOException {
+  public void reply(List<Header> responseHeaders, boolean out) throws IOException {
     assert (!Thread.holdsLock(SpdyStream.this));
     boolean outFinished = false;
     synchronized (this) {
@@ -254,7 +253,7 @@
     return true;
   }
 
-  void receiveHeaders(List<ByteString> headers, HeadersMode headersMode) {
+  void receiveHeaders(List<Header> headers, HeadersMode headersMode) {
     assert (!Thread.holdsLock(SpdyStream.this));
     ErrorCode errorCode = null;
     boolean open = true;
@@ -271,7 +270,7 @@
         if (headersMode.failIfHeadersPresent()) {
           errorCode = ErrorCode.STREAM_IN_USE;
         } else {
-          List<ByteString> newHeaders = new ArrayList<ByteString>();
+          List<Header> newHeaders = new ArrayList<Header>();
           newHeaders.addAll(responseHeaders);
           newHeaders.addAll(headers);
           this.responseHeaders = newHeaders;
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
index 9933b09..eefb461 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
@@ -15,7 +15,6 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.List;
@@ -30,7 +29,7 @@
 
   @Override
   public void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      int priority, List<ByteString> nameValueBlock, HeadersMode headersMode) {
+      int priority, List<Header> nameValueBlock, HeadersMode headersMode) {
     fail();
   }
 
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index 4e3cf29..8c04cbc 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -26,7 +26,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.Util.byteStringList;
+import static com.squareup.okhttp.internal.Util.headerEntries;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -61,7 +61,7 @@
 
     assertEquals(0, hpackReader.headerCount);
 
-    assertEquals(byteStringList("custom-key", "custom-header"), hpackReader.getAndReset());
+    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndReset());
   }
 
   /** Oldest entries are evicted to support newer ones. */
@@ -97,7 +97,7 @@
 
     assertEquals(2, hpackReader.headerCount);
 
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
     checkEntry(entry, "custom-bar", "custom-header", 55);
     assertHeaderReferenced(headerTableLength() - 1);
 
@@ -107,7 +107,7 @@
 
     // foo isn't here as it is no longer in the table.
     // TODO: emit before eviction?
-    assertEquals(byteStringList("custom-bar", "custom-header", "custom-baz", "custom-header"),
+    assertEquals(headerEntries("custom-bar", "custom-header", "custom-baz", "custom-header"),
         hpackReader.getAndReset());
 
     // Simulate receiving a small settings frame, that implies eviction.
@@ -158,7 +158,7 @@
     assertEquals(1, hpackReader.headerCount);
     assertEquals(52, hpackReader.headerTableByteCount);
 
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
     checkEntry(entry, ":path", "www.example.com", 52);
     assertHeaderReferenced(headerTableLength() - 1);
   }
@@ -183,11 +183,11 @@
     assertEquals(1, hpackReader.headerCount);
     assertEquals(55, hpackReader.headerTableByteCount);
 
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
     checkEntry(entry, "custom-key", "custom-header", 55);
     assertHeaderReferenced(headerTableLength() - 1);
 
-    assertEquals(byteStringList("custom-key", "custom-header"), hpackReader.getAndReset());
+    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndReset());
   }
 
   /**
@@ -207,7 +207,7 @@
 
     assertEquals(0, hpackReader.headerCount);
 
-    assertEquals(byteStringList(":path", "/sample/path"), hpackReader.getAndReset());
+    assertEquals(headerEntries(":path", "/sample/path"), hpackReader.getAndReset());
   }
 
   /**
@@ -226,11 +226,11 @@
     assertEquals(1, hpackReader.headerCount);
     assertEquals(42, hpackReader.headerTableByteCount);
 
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
     checkEntry(entry, ":method", "GET", 42);
     assertHeaderReferenced(headerTableLength() - 1);
 
-    assertEquals(byteStringList(":method", "GET"), hpackReader.getAndReset());
+    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());
   }
 
   /**
@@ -253,7 +253,7 @@
     assertEquals(1, hpackReader.headerCount);
     assertEquals(42, hpackReader.headerTableByteCount);
 
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
     checkEntry(entry, ":method", "GET", 42);
     assertHeaderNotReferenced(headerTableLength() - 1);
 
@@ -277,7 +277,7 @@
     // Not buffered in header table.
     assertEquals(0, hpackReader.headerCount);
 
-    assertEquals(byteStringList(":method", "GET"), hpackReader.getAndReset());
+    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());
   }
 
   /**
@@ -324,7 +324,7 @@
     assertEquals(4, hpackReader.headerCount);
 
     // [  1] (s =  57) :authority: www.example.com
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 4];
+    Header entry = hpackReader.headerTable[headerTableLength() - 4];
     checkEntry(entry, ":authority", "www.example.com", 57);
     assertHeaderReferenced(headerTableLength() - 4);
 
@@ -347,7 +347,7 @@
     assertEquals(180, hpackReader.headerTableByteCount);
 
     // Decoded header set:
-    assertEquals(byteStringList(
+    assertEquals(headerEntries(
         ":method", "GET",
         ":scheme", "http",
         ":path", "/",
@@ -369,7 +369,7 @@
     assertEquals(5, hpackReader.headerCount);
 
     // [  1] (s =  53) cache-control: no-cache
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 5];
+    Header entry = hpackReader.headerTable[headerTableLength() - 5];
     checkEntry(entry, "cache-control", "no-cache", 53);
     assertHeaderReferenced(headerTableLength() - 5);
 
@@ -397,7 +397,7 @@
     assertEquals(233, hpackReader.headerTableByteCount);
 
     // Decoded header set:
-    assertEquals(byteStringList(
+    assertEquals(headerEntries(
         ":method", "GET",
         ":scheme", "http",
         ":path", "/",
@@ -430,7 +430,7 @@
     assertEquals(8, hpackReader.headerCount);
 
     // [  1] (s =  54) custom-key: custom-value
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 8];
+    Header entry = hpackReader.headerTable[headerTableLength() - 8];
     checkEntry(entry, "custom-key", "custom-value", 54);
     assertHeaderReferenced(headerTableLength() - 8);
 
@@ -474,7 +474,7 @@
 
     // Decoded header set:
     // TODO: order is not correct per docs, but then again, the spec doesn't require ordering.
-    assertEquals(byteStringList(
+    assertEquals(headerEntries(
         ":method", "GET",
         ":authority", "www.example.com",
         ":scheme", "https",
@@ -531,7 +531,7 @@
     assertEquals(4, hpackReader.headerCount);
 
     // [  1] (s =  57) :authority: www.example.com
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 4];
+    Header entry = hpackReader.headerTable[headerTableLength() - 4];
     checkEntry(entry, ":authority", "www.example.com", 57);
     assertHeaderReferenced(headerTableLength() - 4);
 
@@ -554,7 +554,7 @@
     assertEquals(180, hpackReader.headerTableByteCount);
 
     // Decoded header set:
-    assertEquals(byteStringList(
+    assertEquals(headerEntries(
         ":method", "GET",
         ":scheme", "http",
         ":path", "/",
@@ -580,7 +580,7 @@
     assertEquals(5, hpackReader.headerCount);
 
     // [  1] (s =  53) cache-control: no-cache
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 5];
+    Header entry = hpackReader.headerTable[headerTableLength() - 5];
     checkEntry(entry, "cache-control", "no-cache", 53);
     assertHeaderReferenced(headerTableLength() - 5);
 
@@ -608,7 +608,7 @@
     assertEquals(233, hpackReader.headerTableByteCount);
 
     // Decoded header set:
-    assertEquals(byteStringList(
+    assertEquals(headerEntries(
         ":method", "GET",
         ":scheme", "http",
         ":path", "/",
@@ -650,7 +650,7 @@
     assertEquals(8, hpackReader.headerCount);
 
     // [  1] (s =  54) custom-key: custom-value
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 8];
+    Header entry = hpackReader.headerTable[headerTableLength() - 8];
     checkEntry(entry, "custom-key", "custom-value", 54);
     assertHeaderReferenced(headerTableLength() - 8);
 
@@ -694,7 +694,7 @@
 
     // Decoded header set:
     // TODO: order is not correct per docs, but then again, the spec doesn't require ordering.
-    assertEquals(byteStringList(
+    assertEquals(headerEntries(
         ":method", "GET",
         ":authority", "www.example.com",
         ":scheme", "https",
@@ -767,13 +767,13 @@
   }
 
   @Test public void headersRoundTrip() throws IOException {
-    List<ByteString> sentHeaders = byteStringList("name", "value");
+    List<Header> sentHeaders = headerEntries("name", "value");
     hpackWriter.writeHeaders(sentHeaders);
     ByteArrayInputStream bytesIn = new ByteArrayInputStream(bytesOut.toByteArray());
     HpackDraft05.Reader reader = newReader(new DataInputStream(bytesIn));
     reader.readHeaders(bytesOut.size());
     reader.emitReferenceSet();
-    List<ByteString> receivedHeaders = reader.getAndReset();
+    List<Header> receivedHeaders = reader.getAndReset();
     assertEquals(sentHeaders, receivedHeaders);
   }
 
@@ -786,10 +786,10 @@
     return new DataInputStream(new ByteArrayInputStream(data));
   }
 
-  private void checkEntry(HpackDraft05.HeaderEntry entry, String name, String value, int size) {
+  private void checkEntry(Header entry, String name, String value, int size) {
     assertEquals(name, entry.name.utf8());
     assertEquals(value, entry.value.utf8());
-    assertEquals(size, entry.size);
+    assertEquals(size, entry.hpackSize);
   }
 
   private void assertBytes(int... bytes) {
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index 0e9f7be..3dc4c08 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -15,7 +15,6 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
@@ -23,7 +22,7 @@
 import java.util.List;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.Util.byteStringList;
+import static com.squareup.okhttp.internal.Util.headerEntries;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -32,7 +31,7 @@
   static final int expectedStreamId = 15;
 
   @Test public void onlyOneLiteralHeadersFrame() throws IOException {
-    final List<ByteString> sentHeaders = byteStringList("name", "value");
+    final List<Header> sentHeaders = headerEntries("name", "value");
 
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     DataOutputStream dataOut = new DataOutputStream(out);
@@ -54,7 +53,7 @@
 
       @Override
       public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<ByteString> nameValueBlock,
+          int associatedStreamId, int priority, List<Header> nameValueBlock,
           HeadersMode headersMode) {
         assertFalse(outFinished);
         assertTrue(inFinished);
@@ -74,7 +73,7 @@
 
     // Write the first headers frame.
     {
-      byte[] headerBytes = literalHeaders(byteStringList("foo", "bar"));
+      byte[] headerBytes = literalHeaders(headerEntries("foo", "bar"));
       dataOut.writeShort(headerBytes.length);
       dataOut.write(Http20Draft09.TYPE_HEADERS);
       dataOut.write(0); // no flags
@@ -84,7 +83,7 @@
 
     // Write the continuation frame, specifying no more frames are expected.
     {
-      byte[] headerBytes = literalHeaders(byteStringList("baz", "qux"));
+      byte[] headerBytes = literalHeaders(headerEntries("baz", "qux"));
       dataOut.writeShort(headerBytes.length);
       dataOut.write(Http20Draft09.TYPE_CONTINUATION);
       dataOut.write(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_END_STREAM);
@@ -99,14 +98,14 @@
 
       @Override
       public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<ByteString> nameValueBlock,
+          int associatedStreamId, int priority, List<Header> nameValueBlock,
           HeadersMode headersMode) {
         assertFalse(outFinished);
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
         assertEquals(-1, priority);
-        assertEquals(byteStringList("foo", "bar", "baz", "qux"), nameValueBlock);
+        assertEquals(headerEntries("foo", "bar", "baz", "qux"), nameValueBlock);
         assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     });
@@ -162,7 +161,7 @@
         Variant.HTTP_20_DRAFT_09.initialPeerSettings(false).getHeaderTableSize(), false);
   }
 
-  private byte[] literalHeaders(List<ByteString> sentHeaders) throws IOException {
+  private byte[] literalHeaders(List<Header> sentHeaders) throws IOException {
     ByteArrayOutputStream headerBytes = new ByteArrayOutputStream();
     new HpackDraft05.Writer(new DataOutputStream(headerBytes)).writeHeaders(sentHeaders);
     return headerBytes.toByteArray();
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index af3ef48..fe1789f 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -16,7 +16,6 @@
 
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Util;
 import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
@@ -187,7 +186,7 @@
     public int priority;
     public ErrorCode errorCode;
     public int deltaWindowSize;
-    public List<ByteString> nameValueBlock;
+    public List<Header> nameValueBlock;
     public byte[] data;
     public Settings settings;
     public HeadersMode headersMode;
@@ -205,7 +204,7 @@
     }
 
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<ByteString> nameValueBlock,
+        int associatedStreamId, int priority, List<Header> nameValueBlock,
         HeadersMode headersMode) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_HEADERS;
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index 287c9be..928ff23 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -31,7 +31,7 @@
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.Util.UTF_8;
-import static com.squareup.okhttp.internal.Util.byteStringList;
+import static com.squareup.okhttp.internal.Util.headerEntries;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.CANCEL;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.FLOW_CONTROL_ERROR;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.INTERNAL_ERROR;
@@ -69,15 +69,15 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame()
-        .synReply(false, 1, byteStringList("a", "android"));
+        .synReply(false, 1, headerEntries("a", "android"));
     peer.sendFrame().data(true, 1, "robot".getBytes("UTF-8"));
     peer.acceptFrame(); // DATA
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
-    assertEquals(byteStringList("a", "android"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     assertStreamData("robot", stream.getInputStream());
     writeAndClose(stream, "c3po");
     assertEquals(0, connection.openStreamCount());
@@ -90,20 +90,20 @@
     assertFalse(synStream.outFinished);
     assertEquals(1, synStream.streamId);
     assertEquals(0, synStream.associatedStreamId);
-    assertEquals(byteStringList("b", "banana"), synStream.nameValueBlock);
+    assertEquals(headerEntries("b", "banana"), synStream.nameValueBlock);
     MockSpdyPeer.InFrame requestData = peer.takeFrame();
     assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
   }
 
   @Test public void headersOnlyStreamIsClosedAfterReplyHeaders() throws Exception {
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, byteStringList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.play();
 
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("a", "android"), false, false);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, false);
     assertEquals(1, connection.openStreamCount());
-    assertEquals(byteStringList("b", "banana"), stream.getResponseHeaders());
+    assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
     assertEquals(0, connection.openStreamCount());
   }
 
@@ -111,13 +111,13 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(true, 1, byteStringList("a", "android"));
+    peer.sendFrame().synReply(true, 1, headerEntries("a", "android"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    connection.newStream(byteStringList("b", "banana"), false, true);
+    connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(1, connection.openStreamCount());
     connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
     assertEquals(0, connection.openStreamCount());
@@ -132,7 +132,7 @@
 
   @Test public void serverCreatesStreamAndClientReplies() throws Exception {
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 5, 129, byteStringList("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, 5, 129, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
     peer.play();
 
@@ -141,10 +141,10 @@
     IncomingStreamHandler handler = new IncomingStreamHandler() {
       @Override public void receive(SpdyStream stream) throws IOException {
         receiveCount.incrementAndGet();
-        assertEquals(byteStringList("a", "android"), stream.getRequestHeaders());
+        assertEquals(headerEntries("a", "android"), stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
         assertEquals(5, stream.getPriority());
-        stream.reply(byteStringList("b", "banana"), true);
+        stream.reply(headerEntries("b", "banana"), true);
       }
     };
     new SpdyConnection.Builder(true, peer.openSocket()).handler(handler).build();
@@ -155,13 +155,13 @@
     assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
     assertFalse(reply.inFinished);
     assertEquals(2, reply.streamId);
-    assertEquals(byteStringList("b", "banana"), reply.nameValueBlock);
+    assertEquals(headerEntries("b", "banana"), reply.nameValueBlock);
     assertEquals(1, receiveCount.get());
   }
 
   @Test public void replyWithNoData() throws Exception {
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, byteStringList("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
     peer.play();
 
@@ -169,7 +169,7 @@
     final AtomicInteger receiveCount = new AtomicInteger();
     IncomingStreamHandler handler = new IncomingStreamHandler() {
       @Override public void receive(SpdyStream stream) throws IOException {
-        stream.reply(byteStringList("b", "banana"), false);
+        stream.reply(headerEntries("b", "banana"), false);
         receiveCount.incrementAndGet();
       }
     };
@@ -180,7 +180,7 @@
     assertEquals(TYPE_HEADERS, reply.type);
     assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
     assertTrue(reply.inFinished);
-    assertEquals(byteStringList("b", "banana"), reply.nameValueBlock);
+    assertEquals(headerEntries("b", "banana"), reply.nameValueBlock);
     assertEquals(1, receiveCount.get());
   }
 
@@ -361,7 +361,7 @@
 
   @Test public void bogusReplyFrameDoesNotDisruptConnection() throws Exception {
     // write the mocking script
-    peer.sendFrame().synReply(false, 42, byteStringList("a", "android"));
+    peer.sendFrame().synReply(false, 42, headerEntries("a", "android"));
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
@@ -382,7 +382,7 @@
   @Test public void clientClosesClientOutputStream() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, byteStringList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.acceptFrame(); // TYPE_DATA
     peer.acceptFrame(); // TYPE_DATA with FLAG_FIN
     peer.acceptFrame(); // PING
@@ -393,7 +393,7 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
         .handler(REJECT_INCOMING_STREAMS)
         .build();
-    SpdyStream stream = connection.newStream(byteStringList("a", "android"), true, false);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, false);
     OutputStream out = stream.getOutputStream();
     out.write("square".getBytes(UTF_8));
     out.flush();
@@ -439,7 +439,7 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
         .handler(REJECT_INCOMING_STREAMS)
         .build();
-    SpdyStream stream = connection.newStream(byteStringList("a", "android"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     OutputStream out = stream.getOutputStream();
     connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
     try {
@@ -481,7 +481,7 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
         .handler(REJECT_INCOMING_STREAMS)
         .build();
-    SpdyStream stream = connection.newStream(byteStringList("a", "android"), false, true);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
     InputStream in = stream.getInputStream();
     OutputStream out = stream.getOutputStream();
     in.close();
@@ -526,7 +526,7 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
         .handler(REJECT_INCOMING_STREAMS)
         .build();
-    SpdyStream stream = connection.newStream(byteStringList("a", "android"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     InputStream in = stream.getInputStream();
     OutputStream out = stream.getOutputStream();
     in.close();
@@ -562,7 +562,7 @@
   @Test public void serverClosesClientInputStream() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, byteStringList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.sendFrame().data(true, 1, "square".getBytes(UTF_8));
     peer.play();
 
@@ -570,7 +570,7 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
         .handler(REJECT_INCOMING_STREAMS)
         .build();
-    SpdyStream stream = connection.newStream(byteStringList("a", "android"), false, true);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
     InputStream in = stream.getInputStream();
     assertStreamData("square", in);
     assertEquals(0, connection.openStreamCount());
@@ -586,17 +586,17 @@
   @Test public void remoteDoubleSynReply() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, byteStringList("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 1, byteStringList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("c", "cola"), true, true);
-    assertEquals(byteStringList("a", "android"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(headerEntries("c", "cola"), true, true);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
     try {
       stream.getInputStream().read();
@@ -619,9 +619,9 @@
 
   @Test public void remoteDoubleSynStream() throws Exception {
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, byteStringList("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, byteStringList("b", "banana"));
+    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("b", "banana"));
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
@@ -630,9 +630,9 @@
     IncomingStreamHandler handler = new IncomingStreamHandler() {
       @Override public void receive(SpdyStream stream) throws IOException {
         receiveCount.incrementAndGet();
-        assertEquals(byteStringList("a", "android"), stream.getRequestHeaders());
+        assertEquals(headerEntries("a", "android"), stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
-        stream.reply(byteStringList("c", "cola"), true);
+        stream.reply(headerEntries("c", "cola"), true);
       }
     };
     new SpdyConnection.Builder(true, peer.openSocket()).handler(handler).build();
@@ -651,7 +651,7 @@
   @Test public void remoteSendsDataAfterInFinished() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, byteStringList("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     peer.sendFrame().data(true, 1, "robot".getBytes("UTF-8"));
     peer.sendFrame().data(true, 1, "c3po".getBytes("UTF-8")); // Ignored.
     peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
@@ -660,8 +660,8 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
-    assertEquals(byteStringList("a", "android"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     assertStreamData("robot", stream.getInputStream());
 
     // verify the peer received what was expected
@@ -676,7 +676,7 @@
   @Test public void remoteSendsTooMuchData() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, byteStringList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.sendFrame().data(false, 1, new byte[64 * 1024 + 1]);
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
@@ -685,8 +685,8 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("a", "android"), true, true);
-    assertEquals(byteStringList("b", "banana"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+    assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
@@ -711,7 +711,7 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("a", "android"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     try {
       stream.getResponseHeaders();
       fail();
@@ -741,8 +741,8 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream1 = connection.newStream(byteStringList("a", "android"), true, true);
-    SpdyStream stream2 = connection.newStream(byteStringList("b", "banana"), true, true);
+    SpdyStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
+    SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the GO_AWAY has been received.
     stream1.getOutputStream().write("abc".getBytes(UTF_8));
     try {
@@ -754,7 +754,7 @@
     stream1.getOutputStream().write("def".getBytes(UTF_8));
     stream1.getOutputStream().close();
     try {
-      connection.newStream(byteStringList("c", "cola"), true, true);
+      connection.newStream(headerEntries("c", "cola"), true, true);
       fail();
     } catch (IOException expected) {
       assertEquals("shutdown", expected.getMessage());
@@ -779,13 +779,13 @@
     peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // GOAWAY
     peer.acceptFrame(); // PING
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, byteStringList("b", "b")); // Should be ignored!
+    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("b", "b")); // Should be ignored!
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    connection.newStream(byteStringList("a", "android"), true, true);
+    connection.newStream(headerEntries("a", "android"), true, true);
     Ping ping = connection.ping();
     connection.shutdown(PROTOCOL_ERROR);
     assertEquals(1, connection.openStreamCount());
@@ -832,12 +832,12 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("a", "android"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     assertEquals(1, connection.openStreamCount());
     connection.close();
     assertEquals(0, connection.openStreamCount());
     try {
-      connection.newStream(byteStringList("b", "banana"), true, true);
+      connection.newStream(headerEntries("b", "banana"), true, true);
       fail();
     } catch (IOException expected) {
       assertEquals("shutdown", expected.getMessage());
@@ -882,14 +882,14 @@
   @Test public void readTimeoutExpires() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, byteStringList("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     stream.setReadTimeout(1000);
     InputStream in = stream.getInputStream();
     long startNanos = System.nanoTime();
@@ -912,16 +912,16 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 1, byteStringList("a", "android"));
-    peer.sendFrame().headers(1, byteStringList("c", "c3po"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.sendFrame().headers(1, headerEntries("c", "c3po"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
-    assertEquals(byteStringList("a", "android", "c", "c3po"), stream.getResponseHeaders());
+    assertEquals(headerEntries("a", "android", "c", "c3po"), stream.getResponseHeaders());
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
@@ -935,14 +935,14 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().headers(1, byteStringList("c", "c3po"));
+    peer.sendFrame().headers(1, headerEntries("c", "c3po"));
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
     try {
       stream.getResponseHeaders();
@@ -966,7 +966,7 @@
     int windowUpdateThreshold = Variant.SPDY3.initialPeerSettings(true).getInitialWindowSize() / 2;
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, byteStringList("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     for (int i = 0; i < 3; i++) {
       peer.sendFrame().data(false, 1, new byte[windowUpdateThreshold]);
       peer.acceptFrame(); // WINDOW UPDATE
@@ -976,9 +976,9 @@
 
     // Play it back.
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals(windowUpdateThreshold, stream.windowUpdateThreshold);
-    assertEquals(byteStringList("a", "android"), stream.getResponseHeaders());
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     InputStream in = stream.getInputStream();
     int total = 0;
     byte[] buffer = new byte[1024];
@@ -1012,7 +1012,7 @@
 
     // Play it back.
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     OutputStream out = stream.getOutputStream();
     out.write(new byte[windowSize]);
     interruptAfterDelay(500);
@@ -1033,14 +1033,14 @@
   @Test public void testTruncatedDataFrame() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, byteStringList("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     peer.sendTruncatedFrame(8 + 100).data(false, 1, new byte[1024]);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
-    assertEquals(byteStringList("a", "android"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     InputStream in = stream.getInputStream();
     try {
       Util.readFully(in, new byte[101]);
@@ -1071,9 +1071,9 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
-    assertEquals("a", stream.getResponseHeaders().get(0).utf8());
-    assertEquals(60, stream.getResponseHeaders().get(1).size());
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals("a", stream.getResponseHeaders().get(0).name.utf8());
+    assertEquals(60, stream.getResponseHeaders().get(0).value.size());
     assertStreamData("robot", stream.getInputStream());
   }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
index ae01d75..3f03245 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
@@ -557,9 +557,9 @@
     if (append) {
       protocolsList.addAll(client.getProtocols());
     }
-    for (ByteString protocol : Util.byteStringList(protocolsString.split(",", -1))) {
+    for (String protocol : protocolsString.split(",", -1)) {
       try {
-        protocolsList.add(Protocol.find(protocol));
+        protocolsList.add(Protocol.find(ByteString.encodeUtf8(protocol)));
       } catch (IOException e) {
         throw new IllegalStateException(e);
       }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 042bbf9..6636189 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -20,9 +20,9 @@
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.spdy.ErrorCode;
+import com.squareup.okhttp.internal.spdy.Header;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.spdy.SpdyStream;
 import java.io.IOException;
@@ -37,15 +37,15 @@
 import java.util.Set;
 
 import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
+import static com.squareup.okhttp.internal.spdy.Header.RESPONSE_STATUS;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_AUTHORITY;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_HOST;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_METHOD;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_PATH;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_SCHEME;
+import static com.squareup.okhttp.internal.spdy.Header.VERSION;
 
 public final class SpdyTransport implements Transport {
-  private static final ByteString HEADER_METHOD = ByteString.encodeUtf8(":method");
-  private static final ByteString HEADER_PATH = ByteString.encodeUtf8(":path");
-  private static final ByteString HEADER_VERSION = ByteString.encodeUtf8(":version");
-  private static final ByteString HEADER_HOST = ByteString.encodeUtf8(":host");
-  private static final ByteString HEADER_AUTHORITY = ByteString.encodeUtf8(":authority");
-  private static final ByteString HEADER_SCHEME = ByteString.encodeUtf8(":scheme");
-
   private final HttpEngine httpEngine;
   private final SpdyConnection spdyConnection;
   private SpdyStream stream;
@@ -91,29 +91,26 @@
    * Names are all lower case. No names are repeated. If any name has multiple
    * values, they are concatenated using "\0" as a delimiter.
    */
-  public static List<ByteString> writeNameValueBlock(Request request, Protocol protocol,
+  public static List<Header> writeNameValueBlock(Request request, Protocol protocol,
       String version) {
     Headers headers = request.headers();
     // TODO: make the known header names constants.
-    List<ByteString> result = new ArrayList<ByteString>(headers.size() + 10);
-    result.add(HEADER_METHOD);
-    result.add(ByteString.encodeUtf8(request.method()));
-    result.add(HEADER_PATH);
-    result.add(ByteString.encodeUtf8(RequestLine.requestPath(request.url())));
-    result.add(HEADER_VERSION);
-    result.add(ByteString.encodeUtf8(version));
+    List<Header> result = new ArrayList<Header>(headers.size() + 10);
+    result.add(new Header(TARGET_METHOD, request.method()));
+    result.add(
+        new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
+    String host = HttpEngine.hostHeader(request.url());
     if (Protocol.SPDY_3 == protocol) {
-      result.add(HEADER_HOST);
+      result.add(new Header(VERSION, version));
+      result.add(new Header(TARGET_HOST, host));
     } else if (Protocol.HTTP_2 == protocol) {
-      result.add(HEADER_AUTHORITY);
+      result.add(new Header(TARGET_AUTHORITY, host));
     } else {
       throw new AssertionError();
     }
-    result.add(ByteString.encodeUtf8(HttpEngine.hostHeader(request.url())));
-    result.add(HEADER_SCHEME);
-    result.add(ByteString.encodeUtf8(request.url().getProtocol()));
+    result.add(new Header(TARGET_SCHEME, request.url().getProtocol()));
 
-    Set<ByteString> names = new LinkedHashSet<ByteString>();
+    Set<String> names = new LinkedHashSet<String>();
     for (int i = 0; i < headers.size(); i++) {
       String name = headers.name(i).toLowerCase(Locale.US);
       String value = headers.value(i);
@@ -122,27 +119,26 @@
       if (isProhibitedHeader(protocol, name)) continue;
 
       // They shouldn't be set, but if they are, drop them. We've already written them!
-      if (name.equals(":method")
-          || name.equals(":path")
-          || name.equals(":version")
-          || name.equals(":host")
-          || name.equals(":authority")
-          || name.equals(":scheme")) {
+      if (TARGET_METHOD.utf8Equals(name)
+          || TARGET_PATH.utf8Equals(name)
+          || TARGET_SCHEME.utf8Equals(name)
+          || TARGET_AUTHORITY.utf8Equals(name)
+          || TARGET_HOST.utf8Equals(name)
+          || VERSION.utf8Equals(name)) {
         continue;
       }
 
       // If we haven't seen this name before, add the pair to the end of the list...
-      if (names.add(ByteString.encodeUtf8(name))) {
-        result.add(ByteString.encodeUtf8(name));
-        result.add(ByteString.encodeUtf8(value));
+      if (names.add(name)) {
+        result.add(new Header(name, value));
         continue;
       }
 
       // ...otherwise concatenate the existing values and this value.
-      for (int j = 0; j < result.size(); j += 2) {
-        if (result.get(j).utf8Equals(name)) {
-          String concatenated = joinOnNull(result.get(j + 1).utf8(), value);
-          result.set(j + 1, ByteString.encodeUtf8(concatenated));
+      for (int j = 0; j < result.size(); j++) {
+        if (result.get(j).name.utf8Equals(name)) {
+          String concatenated = joinOnNull(result.get(j).value.utf8(), value);
+          result.set(j, new Header(name, concatenated));
           break;
         }
       }
@@ -155,29 +151,26 @@
   }
 
   /** Returns headers for a name value block containing a SPDY response. */
-  public static Response.Builder readNameValueBlock(List<ByteString> nameValueBlock,
+  public static Response.Builder readNameValueBlock(List<Header> nameValueBlock,
       Protocol protocol) throws IOException {
-    if (nameValueBlock.size() % 2 != 0) {
-      throw new IllegalArgumentException("Unexpected name value block: " + nameValueBlock);
-    }
     String status = null;
-    String version = "HTTP/1.1"; // TODO: why are we expecting :version?
+    String version = "HTTP/1.1"; // :version present only in spdy/3.
 
     Headers.Builder headersBuilder = new Headers.Builder();
     headersBuilder.set(OkHeaders.SELECTED_TRANSPORT, protocol.name.utf8());
     headersBuilder.set(OkHeaders.SELECTED_PROTOCOL, protocol.name.utf8());
-    for (int i = 0; i < nameValueBlock.size(); i += 2) {
-      String name = nameValueBlock.get(i).utf8();
-      String values = nameValueBlock.get(i + 1).utf8();
+    for (int i = 0; i < nameValueBlock.size(); i++) {
+      String name = nameValueBlock.get(i).name.utf8();
+      String values = nameValueBlock.get(i).value.utf8();
       for (int start = 0; start < values.length(); ) {
         int end = values.indexOf('\0', start);
         if (end == -1) {
           end = values.length();
         }
         String value = values.substring(start, end);
-        if (":status".equals(name)) {
+        if (RESPONSE_STATUS.utf8Equals(name)) {
           status = value;
-        } else if (":version".equals(name)) {
+        } else if (VERSION.utf8Equals(name)) {
           version = value;
         } else if (!isProhibitedHeader(protocol, name)) { // Don't write forbidden headers!
           headersBuilder.add(name, value);
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
index 91b3d1c..de7d8c2 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
@@ -18,19 +18,19 @@
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.spdy.Header;
 import java.io.IOException;
 import java.util.List;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.Util.byteStringList;
+import static com.squareup.okhttp.internal.Util.headerEntries;
 import static junit.framework.Assert.assertNull;
 import static org.junit.Assert.assertEquals;
 
 public final class HeadersTest {
   @Test public void parseNameValueBlock() throws IOException {
-    List<ByteString> nameValueBlock = byteStringList(
+    List<Header> nameValueBlock = headerEntries(
         "cache-control", "no-cache, no-store",
         "set-cookie", "Cookie1\u0000Cookie2",
         ":status", "200 OK",
@@ -59,7 +59,7 @@
   }
 
   @Test public void readNameValueBlockDropsForbiddenHeadersSpdy3() throws IOException {
-    List<ByteString> nameValueBlock = byteStringList(
+    List<Header> nameValueBlock = headerEntries(
         ":status", "200 OK",
         ":version", "HTTP/1.1",
         "connection", "close");
@@ -75,7 +75,7 @@
   }
 
   @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
-    List<ByteString> nameValueBlock = byteStringList(
+    List<Header> nameValueBlock = headerEntries(
         ":status", "200 OK",
         ":version", "HTTP/1.1",
         "connection", "close");
@@ -98,9 +98,9 @@
         .addHeader("set-cookie", "Cookie2")
         .header(":status", "200 OK")
         .build();
-    List<ByteString> nameValueBlock =
+    List<Header> nameValueBlock =
         SpdyTransport.writeNameValueBlock(request, Protocol.SPDY_3, "HTTP/1.1");
-    List<ByteString> expected = byteStringList(
+    List<Header> expected = headerEntries(
         ":method", "GET",
         ":path", "/",
         ":version", "HTTP/1.1",
@@ -118,7 +118,7 @@
         .header("Connection", "close")
         .header("Transfer-Encoding", "chunked")
         .build();
-    List<ByteString> expected = byteStringList(
+    List<Header> expected = headerEntries(
         ":method", "GET",
         ":path", "/",
         ":version", "HTTP/1.1",
@@ -133,10 +133,9 @@
         .header("Connection", "upgrade")
         .header("Upgrade", "websocket")
         .build();
-    List<ByteString> expected = byteStringList(
+    List<Header> expected = headerEntries(
         ":method", "GET",
         ":path", "/",
-        ":version", "HTTP/1.1",
         ":authority", "square.com",
         ":scheme", "http");
     assertEquals(expected,
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index 1aa4870..7875656 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -323,7 +323,7 @@
       out.flush();
     }
 
-    @Override public void ackSettings() throws IOException {
+    @Override public synchronized void ackSettings() throws IOException {
       // ACK the settings frame.
       out.writeInt(0 | (TYPE_SETTINGS & 0xff) << 8 | (FLAG_ACK & 0xff));
       out.writeInt(0);
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 124fb2e..038f3e2 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -622,16 +622,16 @@
       String path = "<:path omitted>";
       String version = protocol == Protocol.SPDY_3 ? "<:version omitted>" : "HTTP/1.1";
       for (int i = 0, size = spdyHeaders.size(); i < size; i++) {
-        String name = spdyHeaders.get(i).name.utf8();
+        ByteString name = spdyHeaders.get(i).name;
         String value = spdyHeaders.get(i).value.utf8();
-        if (":method".equals(name)) {
+        if (name.equals(Header.TARGET_METHOD)) {
           method = value;
-        } else if (":path".equals(name)) {
+        } else if (name.equals(Header.TARGET_PATH)) {
           path = value;
-        } else if (":version".equals(name)) {
+        } else if (name.equals(Header.VERSION)) {
           version = value;
         } else {
-          httpHeaders.add(name + ": " + value);
+          httpHeaders.add(name.utf8() + ": " + value);
         }
       }
 
@@ -670,8 +670,7 @@
         if (headerParts.length != 2) {
           throw new AssertionError("Unexpected header: " + header);
         }
-        spdyHeaders.add(new Header(headerParts[0].toLowerCase(Locale.US).trim(),
-            headerParts[1].trim()));
+        spdyHeaders.add(new Header(headerParts[0], headerParts[1]));
       }
       byte[] body = response.getBody();
       stream.reply(spdyHeaders, body.length > 0);
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/ByteString.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/ByteString.java
index 2fdf65d..f0a62c2 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/ByteString.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/ByteString.java
@@ -15,12 +15,13 @@
  */
 package com.squareup.okhttp.internal;
 
-import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.Arrays;
 
+import static com.squareup.okhttp.internal.Util.asciiLowerCase;
+
 /**
  * An immutable sequence of bytes.
  *
@@ -37,30 +38,16 @@
   private transient int hashCode; // Lazily computed; 0 if unknown.
   private transient String utf8; // Lazily computed.
 
-  /**
-   * A singleton empty {@code ByteString}.
-   */
+  /** A singleton empty {@code ByteString}. */
   public static final ByteString EMPTY = new ByteString(Util.EMPTY_BYTE_ARRAY);
 
   /**
-   * Returns a new byte string containing the bytes of {@code data}, or
-   * {@link #EMPTY} if {@code data} is an empty array.
+   * Returns a new byte string containing a clone of the bytes of {@code data}.
    */
   public static ByteString of(byte... data) {
     return new ByteString(data.clone());
   }
 
-  /**
-   * Returns a new byte string containing the bytes of {@code data}
-   * from {@code offset} to {@code offset + count - 1}, inclusive, or
-   * {@link #EMPTY} if {@code count} is zero.
-   */
-  public static ByteString of(byte[] data, int offset, int count) {
-    byte[] bytes = new byte[count];
-    System.arraycopy(data, offset, bytes, 0, count);
-    return new ByteString(bytes);
-  }
-
   /** Returns a new byte string containing the {@code UTF-8} bytes of {@code s}. */
   public static ByteString encodeUtf8(String s) {
     ByteString byteString = new ByteString(s.getBytes(Util.UTF_8));
@@ -76,28 +63,45 @@
   }
 
   /**
-   * Returns true when {@code s} is not null and its {@code UTF-8} encoded
-   * bytes are equivalent to the bytes wrapped by this byte string.
+   * Returns true when {@code ascii} is not null and equals the bytes wrapped
+   * by this byte string.
    */
-  public boolean utf8Equals(String s) {
-    if (s == null) return false;
-    // TODO: avoid allocation
-    return utf8().equals(s);
+  public boolean equalsAscii(String ascii) {
+    if (ascii == this.utf8) {
+      return true;
+    }
+    if (ascii == null || data.length != ascii.length()) {
+      return false;
+    }
+    for (int i = 0; i < data.length; i++) {
+      if (data[i] != ascii.charAt(i)) return false;
+    }
+    return true;
   }
 
   /**
    * Reads {@code count} bytes from {@code in} and returns the result.
    *
-   * @throws EOFException if {@code in} has fewer than {@code count} bytes to
-   * read.
+   * @throws java.io.EOFException if {@code in} has fewer than {@code count}
+   * bytes to read.
    */
   public static ByteString read(InputStream in, int count) throws IOException {
     byte[] result = new byte[count];
-    for (int c = 0; c < count; ) {
-      int read = in.read(result, c, count - c);
-      if (read == -1) throw new EOFException("Expected " + count + "; received " + c);
-      c += read;
-    }
+    Util.readFully(in, result);
+    return new ByteString(result);
+  }
+
+  /**
+   * Reads {@code count} bytes from {@code in} and returns the result converted
+   * to ASCII lowercase.
+   *
+   * @throws java.io.EOFException if {@code in} has fewer than {@code count}
+   * bytes to read.
+   */
+  public static ByteString readLowerCase(InputStream in, int count) throws IOException {
+    byte[] result = new byte[count];
+    Util.readFully(in, result);
+    asciiLowerCase(result);
     return new ByteString(result);
   }
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
index e1f3169..0cd85e1 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -408,4 +408,15 @@
     }
     return result;
   }
+
+  /** Mutates the byte array to ensure all characters are lowercase. */
+  public static void asciiLowerCase(byte[] bytes) {
+    for (int i = 0; i < bytes.length; i++) {
+      bytes[i] = asciiLowerCase(bytes[i]);
+    }
+  }
+
+  public static byte asciiLowerCase(byte c) {
+    return 'A' <= c && c <= 'Z' ? (byte) (c + 'a' - 'A') : c;
+  }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index a9e8b25..4139d3f 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -10,6 +10,8 @@
 import java.util.Arrays;
 import java.util.List;
 
+import static com.squareup.okhttp.internal.Util.asciiLowerCase;
+
 /**
  * Read and write HPACK v05.
  *
@@ -240,26 +242,26 @@
 
     private void readLiteralHeaderWithoutIndexingIndexedName(int index) throws IOException {
       ByteString name = getName(index);
-      ByteString value = readString();
+      ByteString value = readByteString(false);
       emittedHeaders.add(new Header(name, value));
     }
 
     private void readLiteralHeaderWithoutIndexingNewName() throws IOException {
-      ByteString name = readString();
-      ByteString value = readString();
+      ByteString name = readByteString(true);
+      ByteString value = readByteString(false);
       emittedHeaders.add(new Header(name, value));
     }
 
     private void readLiteralHeaderWithIncrementalIndexingIndexedName(int nameIndex)
         throws IOException {
       ByteString name = getName(nameIndex);
-      ByteString value = readString();
+      ByteString value = readByteString(false);
       insertIntoHeaderTable(-1, new Header(name, value));
     }
 
     private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
-      ByteString name = readString();
-      ByteString value = readString();
+      ByteString name = readByteString(true);
+      ByteString value = readByteString(false);
       insertIntoHeaderTable(-1, new Header(name, value));
     }
 
@@ -349,10 +351,10 @@
     }
 
     /**
-     * Reads a UTF-8 encoded string. Since ASCII is a subset of UTF-8, this method
-     * may be used to read strings that are known to be ASCII-only.
+     * Reads a potentially Huffman encoded string byte string. When
+     * {@code asciiLowercase} is true, bytes will be converted to lowercase.
      */
-    public ByteString readString() throws IOException {
+    public ByteString readByteString(boolean asciiLowercase) throws IOException {
       int firstByte = readByte();
       int length = readInt(firstByte, PREFIX_8_BITS);
       if ((length & 0x80) == 0x80) { // 1NNNNNNN
@@ -360,10 +362,13 @@
         byte[] buff = new byte[length];
         Util.readFully(in, buff);
         bytesLeft -= length;
-        return ByteString.of(huffmanCodec.decode(buff));
+        buff = huffmanCodec.decode(buff); // TODO: streaming Huffman!
+        if (asciiLowercase) asciiLowerCase(buff);
+        return ByteString.of(buff);
       }
       bytesLeft -= length;
-      return length == 0 ? ByteString.EMPTY : ByteString.read(in, length);
+      return length == 0 ? ByteString.EMPTY
+          : asciiLowercase ? ByteString.readLowerCase(in, length) : ByteString.read(in, length);
     }
   }
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
index 5a45bcd..34ce455 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
@@ -74,28 +74,24 @@
 
   public List<Header> readNameValueBlock(int length) throws IOException {
     this.compressedLimit += length;
-    try {
-      int numberOfPairs = nameValueBlockIn.readInt();
-      if (numberOfPairs < 0) {
-        throw new IOException("numberOfPairs < 0: " + numberOfPairs);
-      }
-      if (numberOfPairs > 1024) {
-        throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
-      }
-      List<Header> entries = new ArrayList<Header>(numberOfPairs);
-      for (int i = 0; i < numberOfPairs; i++) {
-        ByteString name = readString();
-        ByteString values = readString();
-        if (name.size() == 0) throw new IOException("name.size == 0");
-        entries.add(new Header(name, values));
-      }
-
-      doneReading();
-
-      return entries;
-    } catch (DataFormatException e) {
-      throw new IOException(e.getMessage());
+    int numberOfPairs = nameValueBlockIn.readInt();
+    if (numberOfPairs < 0) {
+      throw new IOException("numberOfPairs < 0: " + numberOfPairs);
     }
+    if (numberOfPairs > 1024) {
+      throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
+    }
+    List<Header> entries = new ArrayList<Header>(numberOfPairs);
+    for (int i = 0; i < numberOfPairs; i++) {
+      ByteString name = ByteString.readLowerCase(nameValueBlockIn, nameValueBlockIn.readInt());
+      ByteString values = ByteString.read(nameValueBlockIn, nameValueBlockIn.readInt());
+      if (name.size() == 0) throw new IOException("name.size == 0");
+      entries.add(new Header(name, values));
+    }
+
+    doneReading();
+
+    return entries;
   }
 
   private void doneReading() throws IOException {
@@ -110,13 +106,6 @@
     }
   }
 
-  private ByteString readString() throws DataFormatException, IOException {
-    int length = nameValueBlockIn.readInt();
-    byte[] bytes = new byte[length];
-    Util.readFully(nameValueBlockIn, bytes);
-    return ByteString.of(bytes);
-  }
-
   @Override public void close() throws IOException {
     nameValueBlockIn.close();
   }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
index e546889..95484a2 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
@@ -41,12 +41,19 @@
 
   @Test public void utf8() throws Exception {
     ByteString byteString = ByteString.encodeUtf8(bronzeHorseman);
-    assertByteArraysEquals(byteString.toByteArray(), bronzeHorseman.getBytes("UTF-8"));
-    assertTrue(byteString.equals(ByteString.of(bronzeHorseman.getBytes("UTF-8"))));
-    assertTrue(byteString.utf8Equals(bronzeHorseman));
+    assertByteArraysEquals(byteString.toByteArray(), bronzeHorseman.getBytes(Util.UTF_8));
+    assertTrue(byteString.equals(ByteString.of(bronzeHorseman.getBytes(Util.UTF_8))));
     assertEquals(byteString.utf8(), bronzeHorseman);
   }
 
+  @Test public void equalsAscii() throws Exception {
+    ByteString byteString = ByteString.encodeUtf8("Content-Length");
+    assertTrue(byteString.equalsAscii("Content-Length"));
+    assertFalse(byteString.equalsAscii("content-length"));
+    assertFalse(byteString.equalsAscii(bronzeHorseman));
+    assertFalse(ByteString.encodeUtf8("Content-Length").equalsAscii("content-length"));
+  }
+
   @Test public void testHashCode() throws Exception {
     ByteString byteString = ByteString.of((byte) 0x1, (byte) 0x2);
     assertEquals(byteString.hashCode(), byteString.hashCode());
@@ -54,12 +61,19 @@
   }
 
   @Test public void read() throws Exception {
-    InputStream in = new ByteArrayInputStream("abc".getBytes("UTF-8"));
+    InputStream in = new ByteArrayInputStream("abc".getBytes(Util.UTF_8));
     assertEquals(ByteString.of((byte) 0x61, (byte) 0x62), ByteString.read(in, 2));
     assertEquals(ByteString.of((byte) 0x63), ByteString.read(in, 1));
     assertEquals(ByteString.of(), ByteString.read(in, 0));
   }
 
+  @Test public void readLowerCase() throws Exception {
+    InputStream in = new ByteArrayInputStream("ABC".getBytes(Util.UTF_8));
+    assertEquals(ByteString.of((byte) 0x61, (byte) 0x62), ByteString.readLowerCase(in, 2));
+    assertEquals(ByteString.of((byte) 0x63), ByteString.readLowerCase(in, 1));
+    assertEquals(ByteString.of(), ByteString.readLowerCase(in, 0));
+  }
+
   @Test public void write() throws Exception {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     ByteString.of((byte) 0x61, (byte) 0x62, (byte) 0x63).write(out);
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index 8c04cbc..7bd99b2 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -29,6 +29,7 @@
 import static com.squareup.okhttp.internal.Util.headerEntries;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 public class HpackDraft05Test {
@@ -757,13 +758,14 @@
   @Test public void headerName() throws IOException {
     hpackWriter.writeByteString(ByteString.encodeUtf8("foo"));
     assertBytes(3, 'f', 'o', 'o');
-    assertEquals("foo", newReader(byteStream(3, 'f', 'o', 'o')).readString().utf8());
+    assertEquals("foo", newReader(byteStream(3, 'F', 'o', 'o')).readByteString(true).utf8());
   }
 
   @Test public void emptyHeaderName() throws IOException {
     hpackWriter.writeByteString(ByteString.encodeUtf8(""));
     assertBytes(0);
-    assertEquals("", newReader(byteStream(0)).readString().utf8());
+    assertSame(ByteString.EMPTY, newReader(byteStream(0)).readByteString(true));
+    assertSame(ByteString.EMPTY, newReader(byteStream(0)).readByteString(false));
   }
 
   @Test public void headersRoundTrip() throws IOException {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 6636189..03578e2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -20,6 +20,7 @@
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.spdy.ErrorCode;
 import com.squareup.okhttp.internal.spdy.Header;
@@ -88,7 +89,7 @@
 
   /**
    * Returns a list of alternating names and values containing a SPDY request.
-   * Names are all lower case. No names are repeated. If any name has multiple
+   * Names are all lowercase. No names are repeated. If any name has multiple
    * values, they are concatenated using "\0" as a delimiter.
    */
   public static List<Header> writeNameValueBlock(Request request, Protocol protocol,
@@ -110,21 +111,22 @@
     }
     result.add(new Header(TARGET_SCHEME, request.url().getProtocol()));
 
-    Set<String> names = new LinkedHashSet<String>();
+    Set<ByteString> names = new LinkedHashSet<ByteString>();
     for (int i = 0; i < headers.size(); i++) {
-      String name = headers.name(i).toLowerCase(Locale.US);
+      // header names must be lowercase.
+      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
       String value = headers.value(i);
 
       // Drop headers that are forbidden when layering HTTP over SPDY.
       if (isProhibitedHeader(protocol, name)) continue;
 
       // They shouldn't be set, but if they are, drop them. We've already written them!
-      if (TARGET_METHOD.utf8Equals(name)
-          || TARGET_PATH.utf8Equals(name)
-          || TARGET_SCHEME.utf8Equals(name)
-          || TARGET_AUTHORITY.utf8Equals(name)
-          || TARGET_HOST.utf8Equals(name)
-          || VERSION.utf8Equals(name)) {
+      if (name.equals(TARGET_METHOD)
+          || name.equals(TARGET_PATH)
+          || name.equals(TARGET_SCHEME)
+          || name.equals(TARGET_AUTHORITY)
+          || name.equals(TARGET_HOST)
+          || name.equals(VERSION)) {
         continue;
       }
 
@@ -136,7 +138,7 @@
 
       // ...otherwise concatenate the existing values and this value.
       for (int j = 0; j < result.size(); j++) {
-        if (result.get(j).name.utf8Equals(name)) {
+        if (result.get(j).name.equals(name)) {
           String concatenated = joinOnNull(result.get(j).value.utf8(), value);
           result.set(j, new Header(name, concatenated));
           break;
@@ -160,7 +162,7 @@
     headersBuilder.set(OkHeaders.SELECTED_TRANSPORT, protocol.name.utf8());
     headersBuilder.set(OkHeaders.SELECTED_PROTOCOL, protocol.name.utf8());
     for (int i = 0; i < nameValueBlock.size(); i++) {
-      String name = nameValueBlock.get(i).name.utf8();
+      ByteString name = nameValueBlock.get(i).name;
       String values = nameValueBlock.get(i).value.utf8();
       for (int start = 0; start < values.length(); ) {
         int end = values.indexOf('\0', start);
@@ -168,12 +170,12 @@
           end = values.length();
         }
         String value = values.substring(start, end);
-        if (RESPONSE_STATUS.utf8Equals(name)) {
+        if (name.equals(RESPONSE_STATUS)) {
           status = value;
-        } else if (VERSION.utf8Equals(name)) {
+        } else if (name.equals(VERSION)) {
           version = value;
         } else if (!isProhibitedHeader(protocol, name)) { // Don't write forbidden headers!
-          headersBuilder.add(name, value);
+          headersBuilder.add(name.utf8(), value);
         }
         start = end + 1;
       }
@@ -196,27 +198,27 @@
   }
 
   /** When true, this header should not be emitted or consumed. */
-  private static boolean isProhibitedHeader(Protocol protocol, String name) {
+  private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
     boolean prohibited = false;
     if (protocol == Protocol.SPDY_3) {
       // http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3#TOC-3.2.1-Request
-      if (name.equals("connection")
-          || name.equals("host")
-          || name.equals("keep-alive")
-          || name.equals("proxy-connection")
-          || name.equals("transfer-encoding")) {
+      if (name.equalsAscii("connection")
+          || name.equalsAscii("host")
+          || name.equalsAscii("keep-alive")
+          || name.equalsAscii("proxy-connection")
+          || name.equalsAscii("transfer-encoding")) {
         prohibited = true;
       }
     } else if (protocol == Protocol.HTTP_2) {
       // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3
-      if (name.equals("connection")
-          || name.equals("host")
-          || name.equals("keep-alive")
-          || name.equals("proxy-connection")
-          || name.equals("te")
-          || name.equals("transfer-encoding")
-          || name.equals("encoding")
-          || name.equals("upgrade")) {
+      if (name.equalsAscii("connection")
+          || name.equalsAscii("host")
+          || name.equalsAscii("keep-alive")
+          || name.equalsAscii("proxy-connection")
+          || name.equalsAscii("te")
+          || name.equalsAscii("transfer-encoding")
+          || name.equalsAscii("encoding")
+          || name.equalsAscii("upgrade")) {
         prohibited = true;
       }
     } else {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index 4139d3f..75c7724 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -92,7 +92,6 @@
   private HpackDraft05() {
   }
 
-  // TODO: huffman encoding!
   // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-4.1.2
   static class Reader {
     private final Huffman.Codec huffmanCodec;
@@ -132,12 +131,28 @@
       return maxHeaderTableByteCount;
     }
 
-    /** Evicts entries as needed. */
+    /**
+     * Called by the reader when the peer sent a new header table size setting.
+     *
+     * Evicts entries or clears the table as needed.
+     */
     void maxHeaderTableByteCount(int newMaxHeaderTableByteCount) {
-      if (newMaxHeaderTableByteCount < headerTableByteCount) {
-        evictToRecoverBytes(headerTableByteCount - newMaxHeaderTableByteCount);
-      }
       this.maxHeaderTableByteCount = newMaxHeaderTableByteCount;
+      if (maxHeaderTableByteCount < headerTableByteCount) {
+        if (maxHeaderTableByteCount == 0) {
+          clearHeaderTable();
+        } else {
+          evictToRecoverBytes(headerTableByteCount - maxHeaderTableByteCount);
+        }
+      }
+    }
+
+    private void clearHeaderTable() {
+      clearReferenceSet();
+      Arrays.fill(headerTable, null);
+      nextHeaderIndex = headerTable.length - 1;
+      headerCount = 0;
+      headerTableByteCount = 0;
     }
 
     /** Returns the count of entries evicted. */
@@ -286,11 +301,7 @@
 
       // if the new or replacement header is too big, drop all entries.
       if (delta > maxHeaderTableByteCount) {
-        clearReferenceSet();
-        Arrays.fill(headerTable, null);
-        nextHeaderIndex = headerTable.length - 1;
-        headerCount = 0;
-        headerTableByteCount = 0;
+        clearHeaderTable();
         // emit the large header to the callback.
         emittedHeaders.add(entry);
         return;
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
index 5c0888c..ed7c462 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -41,6 +41,7 @@
      * this stream.
      * @param priority or -1 for no priority. For SPDY, priorities range from 0
      * (highest) thru 7 (lowest). For HTTP/2.0, priorities range from 0
+     * (highest) thru 2^31-1 (lowest), defaulting to 2^30.
      */
     void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
         int priority, List<Header> nameValueBlock, HeadersMode headersMode);
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index cb108ad..0d95f4e 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -176,7 +176,8 @@
         throws IOException {
       if (streamId == 0) throw ioException("TYPE_HEADERS streamId == 0");
 
-      boolean inFinished = (flags & FLAG_END_STREAM) != 0;
+      boolean endStream = (flags & FLAG_END_STREAM) != 0;
+      int priority = ((flags & FLAG_PRIORITY) != 0) ? in.readInt() & 0x7fffffff : -1;
 
       while (true) {
         hpackReader.readHeaders(length);
@@ -186,8 +187,7 @@
           List<Header> nameValueBlock = hpackReader.getAndReset();
           // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
           // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3
-          int priority = -1; // TODO: priority
-          handler.headers(false, inFinished, streamId, -1, priority, nameValueBlock,
+          handler.headers(false, endStream, streamId, -1, priority, nameValueBlock,
               HeadersMode.HTTP_20_HEADERS);
           return;
         }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index 1bc912b..218b040 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -66,6 +66,42 @@
     });
   }
 
+  @Test public void headersWithPriority() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final List<Header> sentHeaders = headerEntries("name", "value");
+
+    { // Write the headers frame, specifying priority flag and value.
+      byte[] headerBytes = literalHeaders(sentHeaders);
+      dataOut.writeShort(headerBytes.length);
+      dataOut.write(Http20Draft09.TYPE_HEADERS);
+      dataOut.write(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_PRIORITY);
+      dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
+      dataOut.writeInt(0); // Highest priority is 0.
+      dataOut.write(headerBytes);
+    }
+
+    FrameReader fr = newReader(out);
+
+    // Consume the headers frame.
+    fr.nextFrame(new BaseTestHandler() {
+
+      @Override
+      public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, int priority, List<Header> nameValueBlock,
+          HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(0, priority);
+        assertEquals(sentHeaders, nameValueBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
   @Test public void headersFrameThenContinuation() throws IOException {
 
     ByteArrayOutputStream out = new ByteArrayOutputStream();
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
index 5c0888c..8db3438 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -41,9 +41,10 @@
      * this stream.
      * @param priority or -1 for no priority. For SPDY, priorities range from 0
      * (highest) thru 7 (lowest). For HTTP/2.0, priorities range from 0
+     * (highest) thru 2^31-1 (lowest), defaulting to 2^30.
      */
     void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-        int priority, List<Header> nameValueBlock, HeadersMode headersMode);
+        int priority, List<Header> headerBlock, HeadersMode headersMode);
     void rstStream(int streamId, ErrorCode errorCode);
     void settings(boolean clearPrevious, Settings settings);
     void noop();
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
index 63d2007..79469c4 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -29,10 +29,10 @@
   /** SPDY/3 only. */
   void flush() throws IOException;
   void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      int priority, int slot, List<Header> nameValueBlock) throws IOException;
-  void synReply(boolean outFinished, int streamId, List<Header> nameValueBlock)
+      int priority, int slot, List<Header> headerBlock) throws IOException;
+  void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
       throws IOException;
-  void headers(int streamId, List<Header> nameValueBlock) throws IOException;
+  void headers(int streamId, List<Header> headerBlock) throws IOException;
   void rstStream(int streamId, ErrorCode errorCode) throws IOException;
   void data(boolean outFinished, int streamId, byte[] data) throws IOException;
   void data(boolean outFinished, int streamId, byte[] data, int offset, int byteCount)
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index feeb8ef..8a3941e 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -3,8 +3,8 @@
 import com.squareup.okhttp.internal.BitArray;
 import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Util;
-import java.io.DataInputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -93,13 +93,12 @@
   }
 
   // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-4.1.2
-  static class Reader {
+  static final class Reader {
     private final Huffman.Codec huffmanCodec;
 
-    private final DataInputStream in;
+    private final InputStream in;
     private final List<Header> emittedHeaders = new ArrayList<Header>();
     private int maxHeaderTableByteCount;
-    private long bytesLeft = 0;
 
     // Visible for testing.
     Header[] headerTable = new Header[8];
@@ -121,7 +120,7 @@
     long referencedStaticHeaders = 0L;
     int headerTableByteCount = 0;
 
-    Reader(boolean client, int maxHeaderTableByteCount, DataInputStream in) {
+    Reader(boolean client, int maxHeaderTableByteCount, InputStream in) {
       this.huffmanCodec = client ? Huffman.Codec.RESPONSE : Huffman.Codec.REQUEST;
       this.maxHeaderTableByteCount = maxHeaderTableByteCount;
       this.in = in;
@@ -178,13 +177,10 @@
      * Read {@code byteCount} bytes of headers from the source stream into the
      * set of emitted headers.
      */
-    public void readHeaders(int byteCount) throws IOException {
-      bytesLeft += byteCount;
-      // TODO: limit to 'byteCount' bytes?
-
-      while (bytesLeft > 0) {
-        int b = readByte();
-
+    void readHeaders() throws IOException {
+      int b;
+      while ((b = in.read()) != -1) {
+        b &= 0xff;
         if (b == 0x80) { // 10000000
           clearReferenceSet();
         } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
@@ -214,7 +210,7 @@
       referencedHeaders.clear();
     }
 
-    public void emitReferenceSet() {
+    void emitReferenceSet() {
       for (int i = 0; i < STATIC_HEADER_TABLE.length; ++i) {
         if (((referencedStaticHeaders >> i) & 1L) == 1) {
           emittedHeaders.add(STATIC_HEADER_TABLE[i]);
@@ -231,7 +227,7 @@
      * Returns all headers emitted since they were last cleared, then clears the
      * emitted headers.
      */
-    public List<Header> getAndReset() {
+    List<Header> getAndReset() {
       List<Header> result = new ArrayList<Header>(emittedHeaders);
       emittedHeaders.clear();
       return result;
@@ -335,8 +331,7 @@
     }
 
     private int readByte() throws IOException {
-      bytesLeft--;
-      return in.readByte() & 0xff;
+      return in.read() & 0xff;
     }
 
     int readInt(int firstByte, int prefixMask) throws IOException {
@@ -365,42 +360,40 @@
      * Reads a potentially Huffman encoded string byte string. When
      * {@code asciiLowercase} is true, bytes will be converted to lowercase.
      */
-    public ByteString readByteString(boolean asciiLowercase) throws IOException {
+    ByteString readByteString(boolean asciiLowercase) throws IOException {
       int firstByte = readByte();
       int length = readInt(firstByte, PREFIX_8_BITS);
       if ((length & 0x80) == 0x80) { // 1NNNNNNN
         length &= ~0x80;
         byte[] buff = new byte[length];
         Util.readFully(in, buff);
-        bytesLeft -= length;
         buff = huffmanCodec.decode(buff); // TODO: streaming Huffman!
         if (asciiLowercase) asciiLowerCase(buff);
         return ByteString.of(buff);
       }
-      bytesLeft -= length;
       return length == 0 ? ByteString.EMPTY
           : asciiLowercase ? ByteString.readLowerCase(in, length) : ByteString.read(in, length);
     }
   }
 
-  static class Writer {
+  static final class Writer {
     private final OutputStream out;
 
     Writer(OutputStream out) {
       this.out = out;
     }
 
-    public void writeHeaders(List<Header> nameValueBlock) throws IOException {
+    void writeHeaders(List<Header> headerBlock) throws IOException {
       // TODO: implement a compression strategy.
-      for (int i = 0, size = nameValueBlock.size(); i < size; i++) {
+      for (int i = 0, size = headerBlock.size(); i < size; i++) {
         out.write(0x40); // Literal Header without Indexing - New Name.
-        writeByteString(nameValueBlock.get(i).name);
-        writeByteString(nameValueBlock.get(i).value);
+        writeByteString(headerBlock.get(i).name);
+        writeByteString(headerBlock.get(i).value);
       }
     }
 
     // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-4.1.1
-    public void writeInt(int value, int prefixMask, int bits) throws IOException {
+    void writeInt(int value, int prefixMask, int bits) throws IOException {
       // Write the raw value for a single byte value.
       if (value < prefixMask) {
         out.write(bits | value);
@@ -420,7 +413,7 @@
       out.write(value);
     }
 
-    public void writeByteString(ByteString data) throws IOException {
+    void writeByteString(ByteString data) throws IOException {
       writeInt(data.size(), PREFIX_8_BITS, 0);
       data.write(out);
     }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index cb108ad..f386d17 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -20,6 +20,7 @@
 import java.io.ByteArrayOutputStream;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
+import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -94,6 +95,7 @@
 
   static final class Reader implements FrameReader {
     private final DataInputStream in;
+    private final ContinuationInputStream continuation;
     private final boolean client;
 
     // Visible for testing.
@@ -101,8 +103,9 @@
 
     Reader(InputStream in, int headerTableSize, boolean client) {
       this.in = new DataInputStream(in);
+      this.continuation = new ContinuationInputStream(this.in);
       this.client = client;
-      this.hpackReader = new HpackDraft05.Reader(client, headerTableSize, this.in);
+      this.hpackReader = new HpackDraft05.Reader(client, headerTableSize, continuation);
     }
 
     @Override public void readConnectionHeader() throws IOException {
@@ -174,41 +177,29 @@
 
     private void readHeaders(Handler handler, int flags, int length, int streamId)
         throws IOException {
-      if (streamId == 0) throw ioException("TYPE_HEADERS streamId == 0");
+      if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
 
-      boolean inFinished = (flags & FLAG_END_STREAM) != 0;
+      boolean endHeaders = (flags & FLAG_END_HEADERS) != 0;
+      boolean endStream = (flags & FLAG_END_STREAM) != 0;
+      int priority = ((flags & FLAG_PRIORITY) != 0) ? in.readInt() & 0x7fffffff : -1;
 
-      while (true) {
-        hpackReader.readHeaders(length);
+      List<Header> headerBlock = readHeaderBlock(length, endHeaders, streamId);
 
-        if ((flags & FLAG_END_HEADERS) != 0) {
-          hpackReader.emitReferenceSet();
-          List<Header> nameValueBlock = hpackReader.getAndReset();
-          // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
-          // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3
-          int priority = -1; // TODO: priority
-          handler.headers(false, inFinished, streamId, -1, priority, nameValueBlock,
-              HeadersMode.HTTP_20_HEADERS);
-          return;
-        }
+      handler.headers(false, endStream, streamId, -1, priority, headerBlock,
+          HeadersMode.HTTP_20_HEADERS);
+    }
 
-        // Read another continuation frame.
-        int w1 = in.readInt();
-        int w2 = in.readInt();
+    private List<Header> readHeaderBlock(int length, boolean endHeaders, int streamId)
+        throws IOException {
+      continuation.bytesLeft = length;
+      continuation.endHeaders = endHeaders;
+      continuation.streamId = streamId;
 
-        // boolean r = (w1 & 0xc0000000) != 0; // Reserved.
-        length = (w1 & 0x3fff0000) >> 16; // 14-bit unsigned.
-        int newType = (w1 & 0xff00) >> 8;
-        flags = w1 & 0xff;
-
-        // boolean u = (w2 & 0x80000000) != 0; // Unused.
-        int newStreamId = (w2 & 0x7fffffff);
-
-        if (newType != TYPE_CONTINUATION) {
-          throw ioException("TYPE_CONTINUATION didn't have FLAG_END_HEADERS");
-        }
-        if (newStreamId != streamId) throw ioException("TYPE_CONTINUATION streamId changed");
-      }
+      hpackReader.readHeaders();
+      hpackReader.emitReferenceSet();
+      // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
+      // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3
+      return hpackReader.getAndReset();
     }
 
     private void readData(Handler handler, int flags, int length, int streamId) throws IOException {
@@ -334,26 +325,26 @@
 
     @Override
     public synchronized void synStream(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, int slot, List<Header> nameValueBlock)
+        int associatedStreamId, int priority, int slot, List<Header> headerBlock)
         throws IOException {
       if (inFinished) throw new UnsupportedOperationException();
-      headers(outFinished, streamId, priority, nameValueBlock);
+      headers(outFinished, streamId, priority, headerBlock);
     }
 
     @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<Header> nameValueBlock) throws IOException {
-      headers(outFinished, streamId, -1, nameValueBlock);
+        List<Header> headerBlock) throws IOException {
+      headers(outFinished, streamId, -1, headerBlock);
     }
 
-    @Override public synchronized void headers(int streamId, List<Header> nameValueBlock)
+    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
         throws IOException {
-      headers(false, streamId, -1, nameValueBlock);
+      headers(false, streamId, -1, headerBlock);
     }
 
     private void headers(boolean outFinished, int streamId, int priority,
-        List<Header> nameValueBlock) throws IOException {
+        List<Header> headerBlock) throws IOException {
       hpackBuffer.reset();
-      hpackWriter.writeHeaders(nameValueBlock);
+      hpackWriter.writeHeaders(headerBlock);
       int type = TYPE_HEADERS;
       // TODO: implement CONTINUATION
       int length = hpackBuffer.size();
@@ -440,4 +431,75 @@
   private static IOException ioException(String message, Object... args) throws IOException {
     throw new IOException(String.format(message, args));
   }
+
+  /**
+   * Decompression of the header block occurs above the framing layer.  This
+   * class lazily reads continuation frames as they are needed by
+   * {@link HpackDraft05.Reader#readHeaders()}.
+   */
+  static final class ContinuationInputStream extends InputStream {
+    private final DataInputStream in;
+
+    int bytesLeft;
+    boolean endHeaders;
+    int streamId;
+
+    ContinuationInputStream(DataInputStream in) {
+      this.in = in;
+    }
+
+    @Override public int read() throws IOException {
+      if (bytesLeft == 0) {
+        if (endHeaders) {
+          return -1;
+        } else {
+          readContinuationHeader();
+        }
+      }
+      bytesLeft--;
+      int result = in.read();
+      if (result == -1) throw new EOFException();
+      return result;
+    }
+
+    @Override public int read(byte[] dst, int offset, int byteCount) throws IOException {
+      if (byteCount > bytesLeft) {
+        if (endHeaders) {
+          throw new EOFException(
+              String.format("Attempted to read %s bytes, when only %s left", byteCount, bytesLeft));
+        } else {
+          int beforeContinuation = bytesLeft;
+          Util.readFully(in, dst, offset, bytesLeft);
+          readContinuationHeader();
+          int afterContinuation = byteCount - beforeContinuation;
+          offset += beforeContinuation;
+          bytesLeft -= afterContinuation;
+          Util.readFully(in, dst, offset, afterContinuation);
+          return byteCount;
+        }
+      } else {
+        bytesLeft -= byteCount;
+        Util.readFully(in, dst, offset, byteCount);
+        return byteCount;
+      }
+    }
+
+    private void readContinuationHeader() throws IOException {
+      int w1 = in.readInt();
+      int w2 = in.readInt();
+
+      // boolean r = (w1 & 0xc0000000) != 0; // Reserved.
+      bytesLeft = (w1 & 0x3fff0000) >> 16; // 14-bit unsigned.
+      int newType = (w1 & 0xff00) >> 8;
+      endHeaders = (w1 & 0xff & FLAG_END_HEADERS) != 0;
+
+      // boolean u = (w2 & 0x80000000) != 0; // Unused.
+      int newStreamId = (w2 & 0x7fffffff);
+
+      if (newType != TYPE_CONTINUATION) {
+        throw ioException("TYPE_CONTINUATION didn't have FLAG_END_HEADERS");
+      }
+      if (newStreamId != streamId) throw ioException("TYPE_CONTINUATION streamId changed");
+    }
+  }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
index 34ce455..9c72eb5 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
@@ -19,7 +19,7 @@
  * bytes.
  */
 class NameValueBlockReader implements Closeable {
-  private final DataInputStream nameValueBlockIn;
+  private final DataInputStream headerBlockIn;
   private final FillableInflaterInputStream fillableInflaterInputStream;
   private int compressedLimit;
 
@@ -58,7 +58,7 @@
     };
 
     fillableInflaterInputStream = new FillableInflaterInputStream(throttleStream, inflater);
-    nameValueBlockIn = new DataInputStream(fillableInflaterInputStream);
+    headerBlockIn = new DataInputStream(fillableInflaterInputStream);
   }
 
   /** Extend the inflater stream so we can eagerly fill the compressed bytes buffer if necessary. */
@@ -74,7 +74,7 @@
 
   public List<Header> readNameValueBlock(int length) throws IOException {
     this.compressedLimit += length;
-    int numberOfPairs = nameValueBlockIn.readInt();
+    int numberOfPairs = headerBlockIn.readInt();
     if (numberOfPairs < 0) {
       throw new IOException("numberOfPairs < 0: " + numberOfPairs);
     }
@@ -83,8 +83,8 @@
     }
     List<Header> entries = new ArrayList<Header>(numberOfPairs);
     for (int i = 0; i < numberOfPairs; i++) {
-      ByteString name = ByteString.readLowerCase(nameValueBlockIn, nameValueBlockIn.readInt());
-      ByteString values = ByteString.read(nameValueBlockIn, nameValueBlockIn.readInt());
+      ByteString name = ByteString.readLowerCase(headerBlockIn, headerBlockIn.readInt());
+      ByteString values = ByteString.read(headerBlockIn, headerBlockIn.readInt());
       if (name.size() == 0) throw new IOException("name.size == 0");
       entries.add(new Header(name, values));
     }
@@ -107,6 +107,6 @@
   }
 
   @Override public void close() throws IOException {
-    nameValueBlockIn.close();
+    headerBlockIn.close();
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index ad5081d..30541e5 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -116,11 +116,11 @@
   static final class Reader implements FrameReader {
     private final DataInputStream in;
     private final boolean client;
-    private final NameValueBlockReader nameValueBlockReader;
+    private final NameValueBlockReader headerBlockReader;
 
     Reader(InputStream in, boolean client) {
       this.in = new DataInputStream(in);
-      this.nameValueBlockReader = new NameValueBlockReader(in);
+      this.headerBlockReader = new NameValueBlockReader(in);
       this.client = client;
     }
 
@@ -213,20 +213,20 @@
       int associatedStreamId = w2 & 0x7fffffff;
       int priority = (s3 & 0xe000) >>> 13;
       int slot = s3 & 0xff;
-      List<Header> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 10);
+      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 10);
 
       boolean inFinished = (flags & FLAG_FIN) != 0;
       boolean outFinished = (flags & FLAG_UNIDIRECTIONAL) != 0;
       handler.headers(outFinished, inFinished, streamId, associatedStreamId, priority,
-          nameValueBlock, HeadersMode.SPDY_SYN_STREAM);
+          headerBlock, HeadersMode.SPDY_SYN_STREAM);
     }
 
     private void readSynReply(Handler handler, int flags, int length) throws IOException {
       int w1 = in.readInt();
       int streamId = w1 & 0x7fffffff;
-      List<Header> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 4);
+      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
       boolean inFinished = (flags & FLAG_FIN) != 0;
-      handler.headers(false, inFinished, streamId, -1, -1, nameValueBlock, HeadersMode.SPDY_REPLY);
+      handler.headers(false, inFinished, streamId, -1, -1, headerBlock, HeadersMode.SPDY_REPLY);
     }
 
     private void readRstStream(Handler handler, int flags, int length) throws IOException {
@@ -243,8 +243,8 @@
     private void readHeaders(Handler handler, int flags, int length) throws IOException {
       int w1 = in.readInt();
       int streamId = w1 & 0x7fffffff;
-      List<Header> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 4);
-      handler.headers(false, false, streamId, -1, -1, nameValueBlock, HeadersMode.SPDY_HEADERS);
+      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
+      handler.headers(false, false, streamId, -1, -1, headerBlock, HeadersMode.SPDY_HEADERS);
     }
 
     private void readWindowUpdate(Handler handler, int flags, int length) throws IOException {
@@ -296,15 +296,15 @@
     }
 
     @Override public void close() throws IOException {
-      Util.closeAll(in, nameValueBlockReader);
+      Util.closeAll(in, headerBlockReader);
     }
   }
 
   /** Write spdy/3 frames. */
   static final class Writer implements FrameWriter {
     private final DataOutputStream out;
-    private final ByteArrayOutputStream nameValueBlockBuffer;
-    private final DataOutputStream nameValueBlockOut;
+    private final ByteArrayOutputStream headerBlockBuffer;
+    private final DataOutputStream headerBlockOut;
     private final boolean client;
 
     Writer(OutputStream out, boolean client) {
@@ -313,9 +313,9 @@
 
       Deflater deflater = new Deflater();
       deflater.setDictionary(DICTIONARY);
-      nameValueBlockBuffer = new ByteArrayOutputStream();
-      nameValueBlockOut = new DataOutputStream(
-          Platform.get().newDeflaterOutputStream(nameValueBlockBuffer, deflater, true));
+      headerBlockBuffer = new ByteArrayOutputStream();
+      headerBlockOut = new DataOutputStream(
+          Platform.get().newDeflaterOutputStream(headerBlockBuffer, deflater, true));
     }
 
     @Override public void ackSettings() {
@@ -332,10 +332,10 @@
 
     @Override
     public synchronized void synStream(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, int slot, List<Header> nameValueBlock)
+        int associatedStreamId, int priority, int slot, List<Header> headerBlock)
         throws IOException {
-      writeNameValueBlockToBuffer(nameValueBlock);
-      int length = 10 + nameValueBlockBuffer.size();
+      writeNameValueBlockToBuffer(headerBlock);
+      int length = 10 + headerBlockBuffer.size();
       int type = TYPE_SYN_STREAM;
       int flags = (outFinished ? FLAG_FIN : 0) | (inFinished ? FLAG_UNIDIRECTIONAL : 0);
 
@@ -345,35 +345,35 @@
       out.writeInt(streamId & 0x7fffffff);
       out.writeInt(associatedStreamId & 0x7fffffff);
       out.writeShort((priority & 0x7) << 13 | (unused & 0x1f) << 8 | (slot & 0xff));
-      nameValueBlockBuffer.writeTo(out);
+      headerBlockBuffer.writeTo(out);
       out.flush();
     }
 
     @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<Header> nameValueBlock) throws IOException {
-      writeNameValueBlockToBuffer(nameValueBlock);
+        List<Header> headerBlock) throws IOException {
+      writeNameValueBlockToBuffer(headerBlock);
       int type = TYPE_SYN_REPLY;
       int flags = (outFinished ? FLAG_FIN : 0);
-      int length = nameValueBlockBuffer.size() + 4;
+      int length = headerBlockBuffer.size() + 4;
 
       out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
       out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
       out.writeInt(streamId & 0x7fffffff);
-      nameValueBlockBuffer.writeTo(out);
+      headerBlockBuffer.writeTo(out);
       out.flush();
     }
 
-    @Override public synchronized void headers(int streamId, List<Header> nameValueBlock)
+    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
         throws IOException {
-      writeNameValueBlockToBuffer(nameValueBlock);
+      writeNameValueBlockToBuffer(headerBlock);
       int flags = 0;
       int type = TYPE_HEADERS;
-      int length = nameValueBlockBuffer.size() + 4;
+      int length = headerBlockBuffer.size() + 4;
 
       out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
       out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
       out.writeInt(streamId & 0x7fffffff);
-      nameValueBlockBuffer.writeTo(out);
+      headerBlockBuffer.writeTo(out);
       out.flush();
     }
 
@@ -403,18 +403,18 @@
       out.write(data, offset, byteCount);
     }
 
-    private void writeNameValueBlockToBuffer(List<Header> nameValueBlock) throws IOException {
-      nameValueBlockBuffer.reset();
-      nameValueBlockOut.writeInt(nameValueBlock.size());
-      for (int i = 0, size = nameValueBlock.size(); i < size; i++) {
-        ByteString name = nameValueBlock.get(i).name;
-        nameValueBlockOut.writeInt(name.size());
-        name.write(nameValueBlockOut);
-        ByteString value = nameValueBlock.get(i).value;
-        nameValueBlockOut.writeInt(value.size());
-        value.write(nameValueBlockOut);
+    private void writeNameValueBlockToBuffer(List<Header> headerBlock) throws IOException {
+      headerBlockBuffer.reset();
+      headerBlockOut.writeInt(headerBlock.size());
+      for (int i = 0, size = headerBlock.size(); i < size; i++) {
+        ByteString name = headerBlock.get(i).name;
+        headerBlockOut.writeInt(name.size());
+        name.write(headerBlockOut);
+        ByteString value = headerBlock.get(i).value;
+        headerBlockOut.writeInt(value.size());
+        value.write(headerBlockOut);
       }
-      nameValueBlockOut.flush();
+      headerBlockOut.flush();
     }
 
     @Override public synchronized void settings(Settings settings) throws IOException {
@@ -482,7 +482,7 @@
     }
 
     @Override public void close() throws IOException {
-      Util.closeAll(out, nameValueBlockOut);
+      Util.closeAll(out, headerBlockOut);
     }
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index 5cb6435..fb860dc 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -482,7 +482,7 @@
     }
 
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<Header> nameValueBlock,
+        int associatedStreamId, int priority, List<Header> headerBlock,
         HeadersMode headersMode) {
       SpdyStream stream;
       synchronized (SpdyConnection.this) {
@@ -506,7 +506,7 @@
 
           // Create a stream.
           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,
-              inFinished, priority, nameValueBlock, peerSettings);
+              inFinished, priority, headerBlock, peerSettings);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
           executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
@@ -530,7 +530,7 @@
       }
 
       // Update an existing stream.
-      stream.receiveHeaders(nameValueBlock, headersMode);
+      stream.receiveHeaders(headerBlock, headersMode);
       if (inFinished) stream.receiveFin();
     }
 
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
index eefb461..c3fe967 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
@@ -29,7 +29,7 @@
 
   @Override
   public void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      int priority, List<Header> nameValueBlock, HeadersMode headersMode) {
+      int priority, List<Header> headerBlock, HeadersMode headersMode) {
     fail();
   }
 
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java
new file mode 100644
index 0000000..0ed247d
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.Arrays;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.spdy.HpackDraft05Test.MutableByteArrayInputStream;
+import static com.squareup.okhttp.internal.spdy.Http20Draft09.ContinuationInputStream;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class ContinuationInputStreamTest {
+  private final MutableByteArrayInputStream bytesIn = new MutableByteArrayInputStream();
+  private final ContinuationInputStream continuation =
+      new ContinuationInputStream(new DataInputStream(bytesIn));
+
+  @Test public void read() throws IOException {
+
+    // When there are bytes left this frame, read one.
+    continuation.bytesLeft = 2;
+    bytesIn.set(new byte[] {1, 2});
+    assertEquals(1, continuation.read());
+    assertEquals(1, continuation.bytesLeft);
+
+    // When there are bytes left this frame, but none on the remote stream, EOF!
+    continuation.bytesLeft = 2;
+    bytesIn.set(new byte[] {});
+    try {
+      continuation.read();
+      fail();
+    } catch (EOFException expected) {
+    }
+
+    // When there are no bytes left in the last header frame, return -1.
+    continuation.bytesLeft = 0;
+    continuation.endHeaders = true;
+    assertEquals(-1, continuation.read());
+    assertEquals(0, continuation.bytesLeft);
+
+    // When there are no bytes left in this frame, but it isn't the last, read continuation.
+    continuation.bytesLeft = 0;
+    continuation.endHeaders = false; // Read continuation.
+    bytesIn.set(lastContinuationFrame(new byte[] {1}));
+    assertEquals(1, continuation.read());
+    assertEquals(0, continuation.bytesLeft);
+  }
+
+  @Test public void readArray() throws IOException {
+    byte[] buff = new byte[3];
+
+    // When there are bytes left this frame, read them.
+    continuation.bytesLeft = 3;
+    continuation.endHeaders = true;
+    bytesIn.set(new byte[] {1, 2, 3});
+    assertEquals(3, continuation.read(buff));
+    assertEquals(0, continuation.bytesLeft);
+    assertTrue(Arrays.equals(buff, new byte[] {1, 2, 3}));
+
+    // When there are no bytes left in the last header frame, EOF.
+    Arrays.fill(buff, (byte) -1);
+    continuation.bytesLeft = 0;
+    continuation.endHeaders = true;
+    bytesIn.set(new byte[] {});
+    try {
+      continuation.read(buff);
+      fail();
+    } catch (EOFException expected) {
+    }
+
+    // When there are no bytes left in this frame, but it isn't the last, read continuation.
+    Arrays.fill(buff, (byte) -1);
+    continuation.bytesLeft = 0;
+    continuation.endHeaders = false; // Read continuation.
+    bytesIn.set(lastContinuationFrame(new byte[] {1, 2, 3}));
+    assertEquals(3, continuation.read(buff));
+    assertTrue(Arrays.equals(buff, new byte[] {1, 2, 3}));
+    assertEquals(0, continuation.bytesLeft);
+  }
+
+  static byte[] lastContinuationFrame(byte[] headerBlock) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+    dataOut.writeShort(headerBlock.length);
+    dataOut.write(Http20Draft09.TYPE_CONTINUATION);
+    dataOut.write(Http20Draft09.FLAG_END_HEADERS);
+    dataOut.writeInt(0);
+    dataOut.write(headerBlock);
+    return out.toByteArray();
+  }
+}
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index 7bd99b2..f4d4709 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -18,9 +18,9 @@
 import com.squareup.okhttp.internal.ByteString;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.util.Arrays;
 import java.util.List;
 import org.junit.Before;
@@ -38,7 +38,7 @@
   private HpackDraft05.Reader hpackReader;
 
   @Before public void resetReader() {
-    hpackReader = newReader(new DataInputStream(bytesIn));
+    hpackReader = newReader(bytesIn);
   }
 
   /**
@@ -57,7 +57,7 @@
 
     bytesIn.set(out.toByteArray());
     hpackReader.maxHeaderTableByteCount(1);
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(0, hpackReader.headerCount);
@@ -93,7 +93,7 @@
     bytesIn.set(out.toByteArray());
     // Set to only support 110 bytes (enough for 2 headers).
     hpackReader.maxHeaderTableByteCount(110);
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(2, hpackReader.headerCount);
@@ -131,7 +131,7 @@
 
     bytesIn.set(out.toByteArray());
     hpackReader.maxHeaderTableByteCount(16384); // Lots of headers need more room!
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(256, hpackReader.headerCount);
@@ -153,7 +153,7 @@
     out.write(huffmanBytes, 0, huffmanBytes.length);
 
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(1, hpackReader.headerCount);
@@ -178,7 +178,7 @@
     out.write("custom-header".getBytes(), 0, 13);
 
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(1, hpackReader.headerCount);
@@ -203,7 +203,7 @@
     out.write("/sample/path".getBytes(), 0, 12);
 
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(0, hpackReader.headerCount);
@@ -221,7 +221,7 @@
                      // idx = 2 -> :method: GET
 
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(1, hpackReader.headerCount);
@@ -248,7 +248,7 @@
                      // idx = 1 -> :method: GET
 
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(1, hpackReader.headerCount);
@@ -272,7 +272,7 @@
 
     bytesIn.set(out.toByteArray());
     hpackReader.maxHeaderTableByteCount(0); // SETTINGS_HEADER_TABLE_SIZE == 0
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     // Not buffered in header table.
@@ -287,19 +287,19 @@
   @Test public void decodeRequestExamplesWithoutHuffman() throws IOException {
     ByteArrayOutputStream out = firstRequestWithoutHuffman();
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkFirstRequestWithoutHuffman();
 
     out = secondRequestWithoutHuffman();
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkSecondRequestWithoutHuffman();
 
     out = thirdRequestWithoutHuffman();
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkThirdRequestWithoutHuffman();
   }
@@ -489,19 +489,19 @@
   @Test public void decodeRequestExamplesWithHuffman() throws IOException {
     ByteArrayOutputStream out = firstRequestWithHuffman();
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkFirstRequestWithHuffman();
 
     out = secondRequestWithHuffman();
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkSecondRequestWithHuffman();
 
     out = thirdRequestWithHuffman();
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkThirdRequestWithHuffman();
   }
@@ -772,20 +772,20 @@
     List<Header> sentHeaders = headerEntries("name", "value");
     hpackWriter.writeHeaders(sentHeaders);
     ByteArrayInputStream bytesIn = new ByteArrayInputStream(bytesOut.toByteArray());
-    HpackDraft05.Reader reader = newReader(new DataInputStream(bytesIn));
-    reader.readHeaders(bytesOut.size());
+    HpackDraft05.Reader reader = newReader(bytesIn);
+    reader.readHeaders();
     reader.emitReferenceSet();
     List<Header> receivedHeaders = reader.getAndReset();
     assertEquals(sentHeaders, receivedHeaders);
   }
 
-  private HpackDraft05.Reader newReader(DataInputStream input) {
+  private HpackDraft05.Reader newReader(InputStream input) {
     return new HpackDraft05.Reader(false, 4096, input);
   }
 
-  private DataInputStream byteStream(int... bytes) {
+  private InputStream byteStream(int... bytes) {
     byte[] data = intArrayToByteArray(bytes);
-    return new DataInputStream(new ByteArrayInputStream(data));
+    return new ByteArrayInputStream(data);
   }
 
   private void checkEntry(Header entry, String name, String value, int size) {
@@ -821,13 +821,13 @@
     return hpackReader.headerTable.length;
   }
 
-  private static class MutableByteArrayInputStream extends ByteArrayInputStream {
+  static class MutableByteArrayInputStream extends ByteArrayInputStream {
 
-    private MutableByteArrayInputStream() {
+    MutableByteArrayInputStream() {
       super(new byte[] { });
     }
 
-    private void set(byte[] replacement) {
+    void set(byte[] replacement) {
       this.buf = replacement;
       this.pos = 0;
       this.count = replacement.length;
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index 1bc912b..e66a48f 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -53,47 +53,38 @@
 
       @Override
       public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<Header> nameValueBlock,
+          int associatedStreamId, int priority, List<Header> headerBlock,
           HeadersMode headersMode) {
         assertFalse(outFinished);
         assertTrue(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
         assertEquals(-1, priority);
-        assertEquals(sentHeaders, nameValueBlock);
+        assertEquals(sentHeaders, headerBlock);
         assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     });
   }
 
-  @Test public void headersFrameThenContinuation() throws IOException {
-
+  @Test public void headersWithPriority() throws IOException {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     DataOutputStream dataOut = new DataOutputStream(out);
 
-    // Write the first headers frame.
-    {
-      byte[] headerBytes = literalHeaders(headerEntries("foo", "bar"));
+    final List<Header> sentHeaders = headerEntries("name", "value");
+
+    { // Write the headers frame, specifying priority flag and value.
+      byte[] headerBytes = literalHeaders(sentHeaders);
       dataOut.writeShort(headerBytes.length);
       dataOut.write(Http20Draft09.TYPE_HEADERS);
-      dataOut.write(0); // no flags
+      dataOut.write(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_PRIORITY);
       dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
-      dataOut.write(headerBytes);
-    }
-
-    // Write the continuation frame, specifying no more frames are expected.
-    {
-      byte[] headerBytes = literalHeaders(headerEntries("baz", "qux"));
-      dataOut.writeShort(headerBytes.length);
-      dataOut.write(Http20Draft09.TYPE_CONTINUATION);
-      dataOut.write(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_END_STREAM);
-      dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
+      dataOut.writeInt(0); // Highest priority is 0.
       dataOut.write(headerBytes);
     }
 
     FrameReader fr = newReader(out);
 
-    // Reading the above frames should result in a concatenated nameValueBlock.
+    // Consume the headers frame.
     fr.nextFrame(new BaseTestHandler() {
 
       @Override
@@ -104,8 +95,52 @@
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
+        assertEquals(0, priority);
+        assertEquals(sentHeaders, nameValueBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void headersFrameThenContinuation() throws IOException {
+
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    // Decoding the first header will cross frame boundaries.
+    byte[] headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+    { // Write the first headers frame.
+      dataOut.writeShort(headerBlock.length / 2);
+      dataOut.write(Http20Draft09.TYPE_HEADERS);
+      dataOut.write(0); // no flags
+      dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
+      dataOut.write(headerBlock, 0, headerBlock.length / 2);
+    }
+
+    { // Write the continuation frame, specifying no more frames are expected.
+      dataOut.writeShort(headerBlock.length / 2);
+      dataOut.write(Http20Draft09.TYPE_CONTINUATION);
+      dataOut.write(Http20Draft09.FLAG_END_HEADERS);
+      dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
+      dataOut.write(headerBlock, headerBlock.length / 2, headerBlock.length / 2);
+    }
+
+    FrameReader fr = newReader(out);
+
+    // Reading the above frames should result in a concatenated headerBlock.
+    fr.nextFrame(new BaseTestHandler() {
+
+      @Override
+      public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, int priority, List<Header> headerBlock,
+          HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
         assertEquals(-1, priority);
-        assertEquals(headerEntries("foo", "bar", "baz", "qux"), nameValueBlock);
+        assertEquals(headerEntries("foo", "barrr", "baz", "qux"), headerBlock);
         assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     });
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index fe1789f..fa4920e 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -186,7 +186,7 @@
     public int priority;
     public ErrorCode errorCode;
     public int deltaWindowSize;
-    public List<Header> nameValueBlock;
+    public List<Header> headerBlock;
     public byte[] data;
     public Settings settings;
     public HeadersMode headersMode;
@@ -204,7 +204,7 @@
     }
 
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<Header> nameValueBlock,
+        int associatedStreamId, int priority, List<Header> headerBlock,
         HeadersMode headersMode) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_HEADERS;
@@ -213,7 +213,7 @@
       this.streamId = streamId;
       this.associatedStreamId = associatedStreamId;
       this.priority = priority;
-      this.nameValueBlock = nameValueBlock;
+      this.headerBlock = headerBlock;
       this.headersMode = headersMode;
     }
 
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index 97ffe55..190d33e 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -90,7 +90,7 @@
     assertFalse(synStream.outFinished);
     assertEquals(1, synStream.streamId);
     assertEquals(0, synStream.associatedStreamId);
-    assertEquals(headerEntries("b", "banana"), synStream.nameValueBlock);
+    assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
     MockSpdyPeer.InFrame requestData = peer.takeFrame();
     assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
   }
@@ -155,7 +155,7 @@
     assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
     assertFalse(reply.inFinished);
     assertEquals(2, reply.streamId);
-    assertEquals(headerEntries("b", "banana"), reply.nameValueBlock);
+    assertEquals(headerEntries("b", "banana"), reply.headerBlock);
     assertEquals(1, receiveCount.get());
   }
 
@@ -180,7 +180,7 @@
     assertEquals(TYPE_HEADERS, reply.type);
     assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
     assertTrue(reply.inFinished);
-    assertEquals(headerEntries("b", "banana"), reply.nameValueBlock);
+    assertEquals(headerEntries("b", "banana"), reply.headerBlock);
     assertEquals(1, receiveCount.get());
   }
 
@@ -1049,7 +1049,7 @@
   }
 
   /** https://github.com/square/okhttp/issues/333 */
-  @Test public void nameValueBlockHasTrailingCompressedBytes() throws Exception {
+  @Test public void headerBlockHasTrailingCompressedBytes() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     // This specially-formatted frame has trailing deflated bytes after the name value block.
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 03578e2..9c1453b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -153,7 +153,7 @@
   }
 
   /** Returns headers for a name value block containing a SPDY response. */
-  public static Response.Builder readNameValueBlock(List<Header> nameValueBlock,
+  public static Response.Builder readNameValueBlock(List<Header> headerBlock,
       Protocol protocol) throws IOException {
     String status = null;
     String version = "HTTP/1.1"; // :version present only in spdy/3.
@@ -161,9 +161,9 @@
     Headers.Builder headersBuilder = new Headers.Builder();
     headersBuilder.set(OkHeaders.SELECTED_TRANSPORT, protocol.name.utf8());
     headersBuilder.set(OkHeaders.SELECTED_PROTOCOL, protocol.name.utf8());
-    for (int i = 0; i < nameValueBlock.size(); i++) {
-      ByteString name = nameValueBlock.get(i).name;
-      String values = nameValueBlock.get(i).value.utf8();
+    for (int i = 0; i < headerBlock.size(); i++) {
+      ByteString name = headerBlock.get(i).name;
+      String values = headerBlock.get(i).value.utf8();
       for (int start = 0; start < values.length(); ) {
         int end = values.indexOf('\0', start);
         if (end == -1) {
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
index 84926bc..36b63f0 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
@@ -30,14 +30,14 @@
 
 public final class HeadersTest {
   @Test public void parseNameValueBlock() throws IOException {
-    List<Header> nameValueBlock = headerEntries(
+    List<Header> headerBlock = headerEntries(
         "cache-control", "no-cache, no-store",
         "set-cookie", "Cookie1\u0000Cookie2",
         ":status", "200 OK",
         ":version", "HTTP/1.1");
     Request request = new Request.Builder().url("http://square.com/").build();
     Response response =
-        SpdyTransport.readNameValueBlock(nameValueBlock, Protocol.SPDY_3).request(request).build();
+        SpdyTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
     Headers headers = response.headers();
     assertEquals(5, headers.size());
     assertEquals("HTTP/1.1 200 OK", response.statusLine());
@@ -59,13 +59,13 @@
   }
 
   @Test public void readNameValueBlockDropsForbiddenHeadersSpdy3() throws IOException {
-    List<Header> nameValueBlock = headerEntries(
+    List<Header> headerBlock = headerEntries(
         ":status", "200 OK",
         ":version", "HTTP/1.1",
         "connection", "close");
     Request request = new Request.Builder().url("http://square.com/").build();
     Response response =
-        SpdyTransport.readNameValueBlock(nameValueBlock, Protocol.SPDY_3).request(request).build();
+        SpdyTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
     Headers headers = response.headers();
     assertEquals(2, headers.size());
     assertEquals(OkHeaders.SELECTED_TRANSPORT, headers.name(0));
@@ -75,12 +75,12 @@
   }
 
   @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
-    List<Header> nameValueBlock = headerEntries(
+    List<Header> headerBlock = headerEntries(
         ":status", "200 OK",
         ":version", "HTTP/1.1",
         "connection", "close");
     Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = SpdyTransport.readNameValueBlock(nameValueBlock, Protocol.HTTP_2)
+    Response response = SpdyTransport.readNameValueBlock(headerBlock, Protocol.HTTP_2)
         .request(request).build();
     Headers headers = response.headers();
     assertEquals(2, headers.size());
@@ -98,7 +98,7 @@
         .addHeader("set-cookie", "Cookie2")
         .header(":status", "200 OK")
         .build();
-    List<Header> nameValueBlock =
+    List<Header> headerBlock =
         SpdyTransport.writeNameValueBlock(request, Protocol.SPDY_3, "HTTP/1.1");
     List<Header> expected = headerEntries(
         ":method", "GET",
@@ -109,7 +109,7 @@
         "cache-control", "no-cache, no-store",
         "set-cookie", "Cookie1\u0000Cookie2",
         ":status", "200 OK");
-    assertEquals(expected, nameValueBlock);
+    assertEquals(expected, headerBlock);
   }
 
   @Test public void toNameValueBlockDropsForbiddenHeadersSpdy3() {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
index 8db3438..3d97841 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -52,5 +52,23 @@
     void goAway(int lastGoodStreamId, ErrorCode errorCode);
     void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl);
     void priority(int streamId, int priority);
+
+    /**
+     * HTTP/2 only. Receive a push promise header block.
+     * <p/>
+     * A push promise contains all the headers that pertain to a server-initiated
+     * request, and a {@code promisedStreamId} to which response frames will be
+     * delivered. Push promise frames are sent as a part of the response to
+     * {@code streamId}.  The {@code promisedStreamId} has a priority of one
+     * greater than {@code streamId}.
+     *
+     * @param streamId client-initiated stream ID.  Must be an odd number.
+     * @param promisedStreamId server-initiated stream ID.  Must be an even
+     * number.
+     * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
+     * {@code :authority}, and (@code :path}.
+     */
+    void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+        throws IOException;
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
index 79469c4..7c1c329 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -26,6 +26,24 @@
   void connectionHeader() throws IOException;
   void ackSettings() throws IOException;
 
+  /**
+   * HTTP/2 only. Send a push promise header block.
+   * <p/>
+   * A push promise contains all the headers that pertain to a server-initiated
+   * request, and a {@code promisedStreamId} to which response frames will be
+   * delivered. Push promise frames are sent as a part of the response to
+   * {@code streamId}.  The {@code promisedStreamId} has a priority of one
+   * greater than {@code streamId}.
+   *
+   * @param streamId client-initiated stream ID.  Must be an odd number.
+   * @param promisedStreamId server-initiated stream ID.  Must be an even
+   * number.
+   * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
+   * {@code :authority}, and (@code :path}.
+   */
+  void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+      throws IOException;
+
   /** SPDY/3 only. */
   void flush() throws IOException;
   void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index f386d17..1797cbd 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -24,7 +24,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
 import java.util.Arrays;
 import java.util.List;
 
@@ -40,11 +39,7 @@
 
   // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-6.5
   @Override public Settings defaultOkHttpSettings(boolean client) {
-    Settings settings = initialPeerSettings(client);
-    if (client) { // TODO: we don't yet support reading push.
-      settings.set(Settings.ENABLE_PUSH, 0, 0);
-    }
-    return settings;
+    return initialPeerSettings(client);
   }
 
   @Override public Settings initialPeerSettings(boolean client) {
@@ -57,14 +52,8 @@
     return settings;
   }
 
-  private static final byte[] CONNECTION_HEADER;
-  static {
-    try {
-      CONNECTION_HEADER = "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n".getBytes("UTF-8");
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
-    }
-  }
+  private static final byte[] CONNECTION_HEADER =
+      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n".getBytes(Util.UTF_8);
 
   static final int TYPE_DATA = 0x0;
   static final int TYPE_HEADERS = 0x1;
@@ -79,8 +68,9 @@
 
   static final int FLAG_END_STREAM = 0x1;
 
-  /** Used for headers, push-promise and continuation. */
+  /** Used for headers and continuation. */
   static final int FLAG_END_HEADERS = 0x4;
+  static final int FLAG_END_PUSH_PROMISE = 0x4;
   static final int FLAG_PRIORITY = 0x8;
   static final int FLAG_ACK = 0x1;
   static final int FLAG_END_FLOW_CONTROL = 0x1;
@@ -252,8 +242,17 @@
       }
     }
 
-    private void readPushPromise(Handler handler, int flags, int length, int streamId) {
-      // TODO:
+    private void readPushPromise(Handler handler, int flags, int length, int streamId)
+        throws IOException {
+      if (streamId == 0) {
+        throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
+      }
+      boolean endHeaders = (flags & FLAG_END_PUSH_PROMISE) != 0;
+
+      int promisedStreamId = in.readInt() & 0x7fffffff;
+      List<Header> headerBlock = readHeaderBlock(length, endHeaders, streamId);
+
+      handler.pushPromise(streamId, promisedStreamId, headerBlock);
     }
 
     private void readPing(Handler handler, int flags, int length, int streamId) throws IOException {
@@ -341,6 +340,22 @@
       headers(false, streamId, -1, headerBlock);
     }
 
+    @Override
+    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+        throws IOException {
+      hpackBuffer.reset();
+      hpackWriter.writeHeaders(requestHeaders);
+      int type = TYPE_PUSH_PROMISE;
+      // TODO: implement CONTINUATION
+      int length = hpackBuffer.size();
+      checkFrameSize(length);
+      int flags = FLAG_END_HEADERS;
+      out.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
+      out.writeInt(streamId & 0x7fffffff);
+      out.writeInt(promisedStreamId & 0x7fffffff);
+      hpackBuffer.writeTo(out);
+    }
+
     private void headers(boolean outFinished, int streamId, int priority,
         List<Header> headerBlock) throws IOException {
       hpackBuffer.reset();
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index 30541e5..6688625 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -322,6 +322,12 @@
       // Do nothing: no ACK for SPDY/3 settings.
     }
 
+    @Override
+    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+        throws IOException {
+      // Do nothing: no push promise for SPDY/3.
+    }
+
     @Override public synchronized void connectionHeader() {
       // Do nothing: no connection header for SPDY/3.
     }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index fb860dc..504d49f 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -630,5 +630,23 @@
     @Override public void priority(int streamId, int priority) {
       // TODO: honor priority.
     }
+
+    @Override
+    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+        throws IOException {
+      // TODO: Wire up properly and only cancel when local settings disable push.
+      cancelStreamLater(promisedStreamId);
+    }
+
+    private void cancelStreamLater(final int streamId) {
+      executor.submit(new NamedRunnable("OkHttp %s Cancelling Stream %s", hostName, streamId) {
+        @Override public void execute() {
+          try {
+            frameWriter.rstStream(streamId, ErrorCode.CANCEL);
+          } catch (IOException ignored) {
+          }
+        }
+      });
+    }
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
index c3fe967..7daa60f 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
@@ -61,4 +61,9 @@
   @Override public void priority(int streamId, int priority) {
     fail();
   }
+
+  @Override
+  public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
+    fail();
+  }
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index e66a48f..2fdf3c6 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -19,6 +19,7 @@
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
+import java.util.Arrays;
 import java.util.List;
 import org.junit.Test;
 
@@ -146,6 +147,88 @@
     });
   }
 
+  @Test public void pushPromise() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final int expectedPromisedStreamId = 11;
+
+    final List<Header> pushPromise = Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/")
+    );
+
+    { // Write the push promise frame, specifying the associated stream ID.
+      byte[] headerBytes = literalHeaders(pushPromise);
+      dataOut.writeShort(headerBytes.length);
+      dataOut.write(Http20Draft09.TYPE_PUSH_PROMISE);
+      dataOut.write(Http20Draft09.FLAG_END_PUSH_PROMISE);
+      dataOut.writeInt(expectedStreamId & 0x7fffffff);
+      dataOut.writeInt(expectedPromisedStreamId & 0x7fffffff);
+      dataOut.write(headerBytes);
+    }
+
+    FrameReader fr = newReader(out);
+
+    // Consume the headers frame.
+    fr.nextFrame(new BaseTestHandler() {
+      @Override
+      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedPromisedStreamId, promisedStreamId);
+        assertEquals(pushPromise, headerBlock);
+      }
+    });
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void pushPromiseThenContinuation() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final int expectedPromisedStreamId = 11;
+
+    final List<Header> pushPromise = Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/")
+    );
+
+    // Decoding the first header will cross frame boundaries.
+    byte[] headerBlock = literalHeaders(pushPromise);
+    { // Write the first headers frame.
+      dataOut.writeShort(headerBlock.length / 2);
+      dataOut.write(Http20Draft09.TYPE_PUSH_PROMISE);
+      dataOut.write(0); // no flags
+      dataOut.writeInt(expectedStreamId & 0x7fffffff);
+      dataOut.writeInt(expectedPromisedStreamId & 0x7fffffff);
+      dataOut.write(headerBlock, 0, headerBlock.length / 2);
+    }
+
+    { // Write the continuation frame, specifying no more frames are expected.
+      dataOut.writeShort(headerBlock.length / 2);
+      dataOut.write(Http20Draft09.TYPE_CONTINUATION);
+      dataOut.write(Http20Draft09.FLAG_END_HEADERS);
+      dataOut.writeInt(expectedStreamId & 0x7fffffff);
+      dataOut.write(headerBlock, headerBlock.length / 2, headerBlock.length / 2);
+    }
+
+    FrameReader fr = newReader(out);
+
+    // Reading the above frames should result in a concatenated headerBlock.
+    fr.nextFrame(new BaseTestHandler() {
+      @Override
+      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedPromisedStreamId, promisedStreamId);
+        assertEquals(pushPromise, headerBlock);
+      }
+    });
+  }
+
   @Test public void readRstStreamFrame() throws IOException {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     DataOutputStream dataOut = new DataOutputStream(out);
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index fa4920e..f83c18a 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -262,5 +262,13 @@
     @Override public void priority(int streamId, int priority) {
       throw new UnsupportedOperationException();
     }
+
+    @Override
+    public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
+      this.type = Http20Draft09.TYPE_PUSH_PROMISE;
+      this.streamId = streamId;
+      this.associatedStreamId = associatedStreamId;
+      this.headerBlock = headerBlock;
+    }
   }
-}
\ No newline at end of file
+}
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index 190d33e..e8f1c0c 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -13,7 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.Protocol;
@@ -25,6 +24,7 @@
 import java.io.InterruptedIOException;
 import java.io.OutputStream;
 import java.util.Arrays;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import org.junit.After;
@@ -1075,6 +1075,36 @@
     assertStreamData("robot", stream.getInputStream());
   }
 
+  // TODO: change this to only cancel when local settings disable push
+  @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
+    MockSpdyPeer peer = new MockSpdyPeer(Variant.HTTP_20_DRAFT_09, false);
+
+    // write the mocking script
+    peer.sendFrame().pushPromise(1, 2, Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/cached")
+    ));
+    peer.sendFrame().synReply(true, 1, Arrays.asList(
+        new Header(Header.RESPONSE_STATUS, "200")
+    ));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
+        .protocol(Protocol.HTTP_2)
+        .handler(REJECT_INCOMING_STREAMS)
+        .build();
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
+    assertEquals(TYPE_RST_STREAM, rstStream.type);
+    assertEquals(2, rstStream.streamId);
+    assertEquals(CANCEL, rstStream.errorCode);
+  }
+
   private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
       throws IOException, InterruptedException {
     MockSpdyPeer peer = new MockSpdyPeer(Variant.HTTP_20_DRAFT_09, client);
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 4a69878..3e7dcbd 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -333,7 +333,7 @@
 
   private boolean isRecoverable(IOException e) {
     // If the problem was a CertificateException from the X509TrustManager,
-    // do not retry, we didn't have an abrupt server initiated exception.
+    // do not retry, we didn't have an abrupt server-initiated exception.
     boolean sslFailure =
         e instanceof SSLHandshakeException && e.getCause() instanceof CertificateException;
     boolean protocolFailure = e instanceof ProtocolException;
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
index 3d97841..20b0317 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -48,7 +48,19 @@
     void rstStream(int streamId, ErrorCode errorCode);
     void settings(boolean clearPrevious, Settings settings);
     void noop();
-    void ping(boolean reply, int payload1, int payload2);
+
+    /**
+     *  Read a connection-level ping from the peer.  {@code ack} indicates this
+     *  is a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
+     *  <p/>
+     *  In SPDY/3, only the first {@code payload1} parameter is set.  If the
+     *  reader is a client, it is an unsigned even number.  Likewise, a server
+     *  will receive an odd number.
+     *  <p/>
+     *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
+     *  set. The data is opaque binary, and there are no rules on the content.
+     */
+    void ping(boolean ack, int payload1, int payload2);
     void goAway(int lastGoodStreamId, ErrorCode errorCode);
     void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl);
     void priority(int streamId, int priority);
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
index 7c1c329..8670f5b 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -58,7 +58,19 @@
   /** Write okhttp's settings to the peer. */
   void settings(Settings okHttpSettings) throws IOException;
   void noop() throws IOException;
-  void ping(boolean reply, int payload1, int payload2) throws IOException;
+
+  /**
+   *  Send a connection-level ping to the peer.  {@code ack} indicates this is
+   *  a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
+   *  <p/>
+   *  In SPDY/3, only the first {@code payload1} parameter is sent.  If the
+   *  sender is a client, it is an unsigned odd number.  Likewise, a server
+   *  will send an even number.
+   *  <p/>
+   *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
+   *  sent.  The data is opaque binary, and there are no rules on the content.
+   */
+  void ping(boolean ack, int payload1, int payload2) throws IOException;
   void goAway(int lastGoodStreamId, ErrorCode errorCode) throws IOException;
   void windowUpdate(int streamId, int deltaWindowSize) throws IOException;
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index 1797cbd..a416d10 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -260,8 +260,8 @@
       if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
       int payload1 = in.readInt();
       int payload2 = in.readInt();
-      boolean reply = (flags & FLAG_ACK) != 0;
-      handler.ping(reply, payload1, payload2);
+      boolean ack = (flags & FLAG_ACK) != 0;
+      handler.ping(ack, payload1, payload2);
     }
 
     private void readGoAway(Handler handler, int flags, int length, int streamId)
@@ -419,9 +419,12 @@
       throw new UnsupportedOperationException();
     }
 
-    @Override public synchronized void ping(boolean reply, int payload1, int payload2)
+    @Override public synchronized void ping(boolean ack, int payload1, int payload2)
         throws IOException {
-      // TODO
+      out.writeInt(8 << 16 | (TYPE_PING & 0xff) << 8 | ((ack ? FLAG_ACK : 0) & 0xff));
+      out.writeInt(0); // connection-level
+      out.writeInt(payload1);
+      out.writeInt(payload2);
     }
 
     @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode)
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index 6688625..236b30e 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -259,8 +259,8 @@
     private void readPing(Handler handler, int flags, int length) throws IOException {
       if (length != 4) throw ioException("TYPE_PING length: %d != 4", length);
       int id = in.readInt();
-      boolean reply = client == ((id % 2) == 1);
-      handler.ping(reply, id, 0);
+      boolean ack = client == ((id % 2) == 1);
+      handler.ping(ack, id, 0);
     }
 
     private void readGoAway(Handler handler, int flags, int length) throws IOException {
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
index 7daa60f..cbb6eac 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
@@ -45,7 +45,7 @@
     fail();
   }
 
-  @Override public void ping(boolean reply, int payload1, int payload2) {
+  @Override public void ping(boolean ack, int payload1, int payload2) {
     fail();
   }
 
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index 2fdf3c6..c54bd16 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -24,6 +24,7 @@
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.Util.headerEntries;
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -277,14 +278,49 @@
     });
   }
 
+  @Test public void pingRoundTrip() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final int expectedPayload1 = 7;
+    final int expectedPayload2 = 8;
+
+    // Compose the expected PING frame.
+    dataOut.writeShort(8); // length
+    dataOut.write(Http20Draft09.TYPE_PING);
+    dataOut.write(Http20Draft09.FLAG_ACK);
+    dataOut.writeInt(0); // connection-level
+    dataOut.writeInt(expectedPayload1);
+    dataOut.writeInt(expectedPayload2);
+
+    // Check writer sends the same bytes.
+    assertArrayEquals(out.toByteArray(), sendPingFrame(true, expectedPayload1, expectedPayload2));
+
+    FrameReader fr = newReader(out);
+
+    fr.nextFrame(new BaseTestHandler() { // Consume the ping frame.
+      @Override public void ping(boolean ack, int payload1, int payload2) {
+        assertTrue(ack);
+        assertEquals(expectedPayload1, payload1);
+        assertEquals(expectedPayload2, payload2);
+      }
+    });
+  }
+
   private Http20Draft09.Reader newReader(ByteArrayOutputStream out) {
     return new Http20Draft09.Reader(new ByteArrayInputStream(out.toByteArray()),
         Variant.HTTP_20_DRAFT_09.initialPeerSettings(false).getHeaderTableSize(), false);
   }
 
   private byte[] literalHeaders(List<Header> sentHeaders) throws IOException {
-    ByteArrayOutputStream headerBytes = new ByteArrayOutputStream();
-    new HpackDraft05.Writer(new DataOutputStream(headerBytes)).writeHeaders(sentHeaders);
-    return headerBytes.toByteArray();
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new HpackDraft05.Writer(new DataOutputStream(out)).writeHeaders(sentHeaders);
+    return out.toByteArray();
+  }
+
+  private byte[] sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Http20Draft09.Writer(out, true).ping(ack, payload1, payload2);
+    return out.toByteArray();
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index f83c18a..73a37e0 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -190,6 +190,9 @@
     public byte[] data;
     public Settings settings;
     public HeadersMode headersMode;
+    public boolean ack;
+    public int payload1;
+    public int payload2;
 
     public InFrame(int sequence, FrameReader reader) {
       this.sequence = sequence;
@@ -234,10 +237,12 @@
       this.errorCode = errorCode;
     }
 
-    @Override public void ping(boolean reply, int payload1, int payload2) {
+    @Override public void ping(boolean ack, int payload1, int payload2) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_PING;
-      this.streamId = payload1;
+      this.ack = ack;
+      this.payload1 = payload1;
+      this.payload2 = payload2;
     }
 
     @Override public void noop() {
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index e8f1c0c..3e140c3 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -211,14 +211,36 @@
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame ping = peer.takeFrame();
+    assertEquals(0, ping.streamId);
+    assertEquals(2, ping.payload1);
+    assertEquals(0, ping.payload2); // ignored in spdy!
+    assertTrue(ping.ack);
+  }
+
+  @Test public void serverPingsClientHttp2() throws Exception {
+    MockSpdyPeer peer = new MockSpdyPeer(Variant.HTTP_20_DRAFT_09, false);
+
+    // write the mocking script
+    peer.sendFrame().ping(false, 2, 3);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    http2Connection(peer);
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.streamId);
+    assertEquals(0, ping.streamId);
+    assertEquals(2, ping.payload1);
+    assertEquals(3, ping.payload2);
+    assertTrue(ping.ack);
   }
 
   @Test public void clientPingsServer() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
+    peer.sendFrame().ping(true, 1, 5); // payload2 ignored in spdy!
     peer.play();
 
     // play it back
@@ -232,7 +254,31 @@
     // verify the peer received what was expected
     MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
     assertEquals(TYPE_PING, pingFrame.type);
-    assertEquals(1, pingFrame.streamId);
+    assertEquals(1, pingFrame.payload1);
+    assertEquals(0, pingFrame.payload2);
+    assertFalse(pingFrame.ack);
+  }
+
+  @Test public void clientPingsServerHttp2() throws Exception {
+    MockSpdyPeer peer = new MockSpdyPeer(Variant.HTTP_20_DRAFT_09, false);
+
+    // write the mocking script
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 5);
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = http2Connection(peer);
+    Ping ping = connection.ping();
+    assertTrue(ping.roundTripTime() > 0);
+    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
+    assertEquals(0, pingFrame.streamId);
+    assertEquals(1, pingFrame.payload1);
+    assertEquals(0x4f4b6f6b, pingFrame.payload2); // connection.ping() sets this.
+    assertFalse(pingFrame.ack);
   }
 
   @Test public void unexpectedPingIsNotReturned() throws Exception {
@@ -249,9 +295,9 @@
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame ping2 = peer.takeFrame();
-    assertEquals(2, ping2.streamId);
+    assertEquals(2, ping2.payload1);
     MockSpdyPeer.InFrame ping4 = peer.takeFrame();
-    assertEquals(4, ping4.streamId);
+    assertEquals(4, ping4.payload1);
   }
 
   @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
@@ -354,7 +400,7 @@
     assertEquals(42, rstStream.streamId);
     assertEquals(INVALID_STREAM, rstStream.errorCode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
   @Test public void bogusReplyFrameDoesNotDisruptConnection() throws Exception {
@@ -374,7 +420,7 @@
     assertEquals(42, rstStream.streamId);
     assertEquals(INVALID_STREAM, rstStream.errorCode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
   @Test public void clientClosesClientOutputStream() throws Exception {
@@ -421,7 +467,7 @@
     assertTrue(fin.inFinished);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(1, ping.streamId);
+    assertEquals(1, ping.payload1);
   }
 
   @Test public void serverClosesClientOutputStream() throws Exception {
@@ -457,7 +503,7 @@
     assertFalse(synStream.outFinished);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(1, ping.streamId);
+    assertEquals(1, ping.payload1);
     MockSpdyPeer.InFrame data = peer.takeFrame();
     assertEquals(TYPE_DATA, data.type);
     assertEquals(1, data.streamId);
@@ -668,7 +714,7 @@
     assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
   @Test public void remoteSendsTooMuchData() throws Exception {
@@ -696,7 +742,7 @@
     assertEquals(FLOW_CONTROL_ERROR, rstStream.errorCode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
   @Test public void remoteSendsRefusedStreamBeforeReplyHeaders() throws Exception {
@@ -724,7 +770,7 @@
     assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
   @Test public void receiveGoAway() throws Exception {
@@ -1093,10 +1139,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .protocol(Protocol.HTTP_2)
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    http2Connection(peer);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
@@ -1113,10 +1156,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .protocol(Protocol.HTTP_2)
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = http2Connection(peer);
 
     // verify the peer received the ACK
     MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
@@ -1128,6 +1168,12 @@
     return connection;
   }
 
+  private SpdyConnection http2Connection(MockSpdyPeer peer) throws IOException {
+    return new SpdyConnection.Builder(true, peer.openSocket())
+        .protocol(Protocol.HTTP_2)
+        .handler(REJECT_INCOMING_STREAMS).build();
+  }
+
   private void writeAndClose(SpdyStream stream, String data) throws IOException {
     OutputStream out = stream.getOutputStream();
     out.write(data.getBytes("UTF-8"));
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
index 8670f5b..ab90db6 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -52,7 +52,17 @@
       throws IOException;
   void headers(int streamId, List<Header> headerBlock) throws IOException;
   void rstStream(int streamId, ErrorCode errorCode) throws IOException;
+
+  /**
+   * {@code data.length} may be longer than the max length of the variant's data frame.
+   * Implementations must send multiple frames as necessary.
+   */
   void data(boolean outFinished, int streamId, byte[] data) throws IOException;
+
+  /**
+   * {@code byteCount} may be longer than the max length of the variant's data frame.
+   * Implementations must send multiple frames as necessary.
+   */
   void data(boolean outFinished, int streamId, byte[] data, int offset, int byteCount)
       throws IOException;
   /** Write okhttp's settings to the peer. */
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index a416d10..4589788 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -391,12 +391,16 @@
 
     @Override public synchronized void data(boolean outFinished, int streamId, byte[] data,
         int offset, int byteCount) throws IOException {
-      int type = TYPE_DATA;
       int flags = 0;
       if (outFinished) flags |= FLAG_END_STREAM;
       // TODO: Implement looping strategy.
+      sendDataFrame(streamId, flags, data, offset, byteCount);
+    }
+
+    void sendDataFrame(int streamId, int flags, byte[] data, int offset, int byteCount)
+        throws IOException {
       checkFrameSize(byteCount);
-      out.writeInt((byteCount & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
+      out.writeInt((byteCount & 0x3fff) << 16 | (TYPE_DATA & 0xff) << 8 | (flags & 0xff));
       out.writeInt(streamId & 0x7fffffff);
       out.write(data, offset, byteCount);
     }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index 236b30e..4d0bf84 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -403,7 +403,16 @@
 
     @Override public synchronized void data(boolean outFinished, int streamId, byte[] data,
         int offset, int byteCount) throws IOException {
+      // TODO: Implement looping strategy.
       int flags = (outFinished ? FLAG_FIN : 0);
+      sendDataFrame(streamId, flags, data, offset, byteCount);
+    }
+
+    void sendDataFrame(int streamId, int flags, byte[] data, int offset, int byteCount)
+        throws IOException {
+      if (byteCount > 0xffffff) {
+        throw new IOException("FRAME_TOO_LARGE max size is 16Mib: " + byteCount);
+      }
       out.writeInt(streamId & 0x7fffffff);
       out.writeInt((flags & 0xff) << 24 | byteCount & 0xffffff);
       out.write(data, offset, byteCount);
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index dbfb2dc..ba14dbe 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -29,6 +29,7 @@
 
 /** A logical bidirectional stream. */
 public final class SpdyStream {
+  static final int OUTPUT_BUFFER_SIZE = 8192;
 
   // Internal state is guarded by this. No long-running or potentially
   // blocking operations are performed while the lock is held.
@@ -576,7 +577,7 @@
    * is not thread safe.
    */
   private final class SpdyDataOutputStream extends OutputStream {
-    private final byte[] buffer = SpdyStream.this.connection.bufferPool.getBuf(8192);
+    private final byte[] buffer = SpdyStream.this.connection.bufferPool.getBuf(OUTPUT_BUFFER_SIZE);
     private int pos = 0;
 
     /** True if the caller has closed this stream. */
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index c54bd16..31d0842 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -15,10 +15,12 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.Util;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.util.Arrays;
 import java.util.List;
 import org.junit.Test;
@@ -28,6 +30,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 public class Http20Draft09Test {
   static final int expectedStreamId = 15;
@@ -307,6 +310,49 @@
     });
   }
 
+  @Test public void maxLengthDataFrame() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final byte[] expectedData = new byte[16383];
+    Arrays.fill(expectedData, (byte) 2);
+
+    // Write the data frame.
+    dataOut.writeShort(expectedData.length);
+    dataOut.write(Http20Draft09.TYPE_DATA);
+    dataOut.write(0); // no flags
+    dataOut.writeInt(expectedStreamId & 0x7fffffff);
+    dataOut.write(expectedData);
+
+    // Check writer sends the same bytes.
+    assertArrayEquals(out.toByteArray(), sendDataFrame(expectedData));
+
+    FrameReader fr = newReader(out);
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void data(boolean inFinished, int streamId, InputStream in, int length)
+          throws IOException {
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(16383, length);
+        byte[] data = new byte[length];
+        Util.readFully(in, data);
+        for (byte b : data){
+          assertEquals(2, b);
+        }
+      }
+    });
+  }
+
+  @Test public void tooLargeDataFrame() throws IOException {
+    try {
+      sendDataFrame(new byte[0x1000000]);
+      fail();
+    } catch (IOException e) {
+      assertEquals("FRAME_SIZE_ERROR max size is 16383: 16777216", e.getMessage());
+    }
+  }
+
   private Http20Draft09.Reader newReader(ByteArrayOutputStream out) {
     return new Http20Draft09.Reader(new ByteArrayInputStream(out.toByteArray()),
         Variant.HTTP_20_DRAFT_09.initialPeerSettings(false).getHeaderTableSize(), false);
@@ -323,4 +369,14 @@
     new Http20Draft09.Writer(out, true).ping(ack, payload1, payload2);
     return out.toByteArray();
   }
+
+  private byte[] sendDataFrame(byte[] data) throws IOException {
+    return sendDataFrame(data, 0, data.length);
+  }
+
+  private byte[] sendDataFrame(byte[] data, int offset, int byteCount) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Http20Draft09.Writer(out, true).sendDataFrame(expectedStreamId, 0, data, offset, byteCount);
+    return out.toByteArray();
+  }
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
new file mode 100644
index 0000000..83d3fd2
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class Spdy3Test {
+  static final int expectedStreamId = 15;
+
+  @Test public void tooLargeDataFrame() throws IOException {
+    try {
+      sendDataFrame(new byte[0x1000000]);
+      fail();
+    } catch (IOException e) {
+      assertEquals("FRAME_TOO_LARGE max size is 16Mib: 16777216", e.getMessage());
+    }
+  }
+
+  private byte[] sendDataFrame(byte[] data) throws IOException {
+    return sendDataFrame(data, 0, data.length);
+  }
+
+  private byte[] sendDataFrame(byte[] data, int offset, int byteCount) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Spdy3.Writer(out, true).sendDataFrame(expectedStreamId, 0, data, offset, byteCount);
+    return out.toByteArray();
+  }
+}
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index 3e140c3..313bcbc 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -24,7 +24,6 @@
 import java.io.InterruptedIOException;
 import java.io.OutputStream;
 import java.util.Arrays;
-import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import org.junit.After;
@@ -1094,6 +1093,40 @@
     }
   }
 
+  /**
+   * This tests that data frames are written in chunks limited by the
+   * SpdyDataOutputStream buffer size.  A side-effect is that this size
+   * prevents us from overrunning the max frame size of SPDY/3 or HTTP/2.
+   */
+  @Test public void spdyStreamOutputBufferSizeLimitsDataFrameLength() throws Exception {
+    MockSpdyPeer peer = new MockSpdyPeer(Variant.HTTP_20_DRAFT_09, false);
+
+    byte[] buff = new byte[SpdyStream.OUTPUT_BUFFER_SIZE * 2];
+    Arrays.fill(buff, (byte) '*');
+
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA 1
+    peer.acceptFrame(); // DATA 2
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = http2Connection(peer);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    OutputStream out = stream.getOutputStream();
+    out.write(buff);
+    out.flush();
+    out.close();
+
+    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    MockSpdyPeer.InFrame data = peer.takeFrame();
+    assertEquals(SpdyStream.OUTPUT_BUFFER_SIZE, data.data.length);
+    data = peer.takeFrame();
+    assertEquals(SpdyStream.OUTPUT_BUFFER_SIZE, data.data.length);
+  }
+
   /** https://github.com/square/okhttp/issues/333 */
   @Test public void headerBlockHasTrailingCompressedBytes() throws Exception {
     // write the mocking script
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
index 20b0317..dc03bf2 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -62,7 +62,12 @@
      */
     void ping(boolean ack, int payload1, int payload2);
     void goAway(int lastGoodStreamId, ErrorCode errorCode);
-    void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl);
+
+    /**
+     * Notifies that an additional {@code windowSizeIncrement} bytes can be
+     * sent on {@code streamId} or the connection, if {@code streamId} is zero.
+     */
+    void windowUpdate(int streamId, int windowSizeIncrement);
     void priority(int streamId, int priority);
 
     /**
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
index ab90db6..01aff52 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -82,5 +82,9 @@
    */
   void ping(boolean ack, int payload1, int payload2) throws IOException;
   void goAway(int lastGoodStreamId, ErrorCode errorCode) throws IOException;
-  void windowUpdate(int streamId, int deltaWindowSize) throws IOException;
+  /**
+   * Inform peer that an additional {@code windowSizeIncrement} bytes can be
+   * sent on {@code streamId} or the connection, if {@code streamId} is zero.
+   */
+  void windowUpdate(int streamId, int windowSizeIncrement) throws IOException;
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index 4589788..cae2fd3 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -73,7 +73,6 @@
   static final int FLAG_END_PUSH_PROMISE = 0x4;
   static final int FLAG_PRIORITY = 0x8;
   static final int FLAG_ACK = 0x1;
-  static final int FLAG_END_FLOW_CONTROL = 0x1;
 
   @Override public FrameReader newReader(InputStream in, Settings peerSettings, boolean client) {
     return new Reader(in, peerSettings.getHeaderTableSize(), client);
@@ -119,6 +118,9 @@
 
       // boolean r = (w1 & 0xc0000000) != 0; // Reserved.
       int length = (w1 & 0x3fff0000) >> 16; // 14-bit unsigned.
+      if ((length & 0xffffffffL) > 16383) {
+        throw new IOException("FRAME_SIZE_ERROR max size is 16383: " + length);
+      }
       int type = (w1 & 0xff00) >> 8;
       int flags = w1 & 0xff;
       // boolean r = (w2 & 0x80000000) != 0; // Reserved.
@@ -282,11 +284,10 @@
 
     private void readWindowUpdate(Handler handler, int flags, int length, int streamId)
         throws IOException {
-      int w1 = in.readInt();
-      // boolean r = (w1 & 0x80000000) != 0; // Reserved.
-      int windowSizeIncrement = (w1 & 0x7fffffff);
-      boolean endFlowControl = (flags & FLAG_END_FLOW_CONTROL) != 0;
-      handler.windowUpdate(streamId, windowSizeIncrement, endFlowControl);
+      if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
+      int increment = (in.readInt() & 0x7fffffff);
+      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
+      handler.windowUpdate(streamId, increment);
     }
 
     @Override public void close() throws IOException {
@@ -436,9 +437,15 @@
       // TODO
     }
 
-    @Override public synchronized void windowUpdate(int streamId, int deltaWindowSize)
+    @Override public synchronized void windowUpdate(int streamId, int increment)
         throws IOException {
-      // TODO
+      if (increment == 0 || (increment & 0xffffffffL) > 0x7fffffffL) {
+        throw new IllegalArgumentException(
+            "windowSizeIncrement must be between 1 and 0x7fffffff: " + (increment & 0xffffffffL));
+      }
+      out.writeInt(4 << 16 | (TYPE_WINDOW_UPDATE & 0xff) << 8); // No flags.
+      out.writeInt(streamId);
+      out.writeInt(increment);
     }
 
     @Override public void close() throws IOException {
@@ -447,7 +454,9 @@
   }
 
   private static void checkFrameSize(int bytes) throws IOException {
-    if (bytes > 16383) throw ioException("FRAME_SIZE_ERROR max size is 16383: %s", bytes);
+    if ((bytes & 0xffffffffL) > 16383) {
+      throw new IllegalArgumentException("FRAME_SIZE_ERROR max size is 16383: " + bytes);
+    }
   }
 
   private static IOException ioException(String message, Object... args) throws IOException {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index 4d0bf84..f837d76 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -252,8 +252,9 @@
       int w1 = in.readInt();
       int w2 = in.readInt();
       int streamId = w1 & 0x7fffffff;
-      int deltaWindowSize = w2 & 0x7fffffff;
-      handler.windowUpdate(streamId, deltaWindowSize, false);
+      int increment = w2 & 0x7fffffff;
+      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
+      handler.windowUpdate(streamId, increment);
     }
 
     private void readPing(Handler handler, int flags, int length) throws IOException {
@@ -410,8 +411,9 @@
 
     void sendDataFrame(int streamId, int flags, byte[] data, int offset, int byteCount)
         throws IOException {
-      if (byteCount > 0xffffff) {
-        throw new IOException("FRAME_TOO_LARGE max size is 16Mib: " + byteCount);
+      if ((byteCount & 0xffffffffL) > 0xffffffL) {
+        throw new IllegalArgumentException(
+            "FRAME_TOO_LARGE max size is 16Mib: " + (byteCount & 0xffffffffL));
       }
       out.writeInt(streamId & 0x7fffffff);
       out.writeInt((flags & 0xff) << 24 | byteCount & 0xffffff);
@@ -484,15 +486,19 @@
       out.flush();
     }
 
-    @Override public synchronized void windowUpdate(int streamId, int deltaWindowSize)
+    @Override public synchronized void windowUpdate(int streamId, int increment)
         throws IOException {
+      if (increment == 0 || (increment & 0xffffffffL) > 0x7fffffffL) {
+        throw new IllegalArgumentException(
+            "windowSizeIncrement must be between 1 and 0x7fffffff: " + (increment & 0xffffffffL));
+      }
       int type = TYPE_WINDOW_UPDATE;
       int flags = 0;
       int length = 8;
       out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
       out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
       out.writeInt(streamId);
-      out.writeInt(deltaWindowSize);
+      out.writeInt(increment);
       out.flush();
     }
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index 504d49f..3056eac 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -218,19 +218,19 @@
     frameWriter.rstStream(streamId, statusCode);
   }
 
-  void writeWindowUpdateLater(final int streamId, final int deltaWindowSize) {
+  void writeWindowUpdateLater(final int streamId, final int windowSizeIncrement) {
     executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
       @Override public void execute() {
         try {
-          writeWindowUpdate(streamId, deltaWindowSize);
+          writeWindowUpdate(streamId, windowSizeIncrement);
         } catch (IOException ignored) {
         }
       }
     });
   }
 
-  void writeWindowUpdate(int streamId, int deltaWindowSize) throws IOException {
-    frameWriter.windowUpdate(streamId, deltaWindowSize);
+  void writeWindowUpdate(int streamId, int windowSizeIncrement) throws IOException {
+    frameWriter.windowUpdate(streamId, windowSizeIncrement);
   }
 
   /**
@@ -614,16 +614,16 @@
       }
     }
 
-    @Override public void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl) {
+    @Override public void windowUpdate(int streamId, int windowSizeIncrement) {
       if (streamId == 0) {
-        // TODO: honor whole-stream flow control
+        // TODO: honor connection-level flow control
         return;
       }
 
       // TODO: honor endFlowControl
       SpdyStream stream = getStream(streamId);
       if (stream != null) {
-        stream.receiveWindowUpdate(deltaWindowSize);
+        stream.receiveWindowUpdate(windowSizeIncrement);
       }
     }
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index ba14dbe..4d00e15 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -325,8 +325,8 @@
     notifyAll();
   }
 
-  synchronized void receiveWindowUpdate(int deltaWindowSize) {
-    out.unacknowledgedBytes -= deltaWindowSize;
+  synchronized void receiveWindowUpdate(int windowSizeIncrement) {
+    out.unacknowledgedBytes -= windowSizeIncrement;
     notifyAll();
   }
 
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
index cbb6eac..5eb81f4 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
@@ -54,7 +54,7 @@
   }
 
   @Override
-  public void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl) {
+  public void windowUpdate(int streamId, int windowSizeIncrement) {
     fail();
   }
 
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index 31d0842..4926d99 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -348,11 +348,53 @@
     try {
       sendDataFrame(new byte[0x1000000]);
       fail();
-    } catch (IOException e) {
+    } catch (IllegalArgumentException e) {
       assertEquals("FRAME_SIZE_ERROR max size is 16383: 16777216", e.getMessage());
     }
   }
 
+  @Test public void windowUpdateRoundTrip() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final int expectedWindowSizeIncrement = 0x7fffffff;
+
+    // Compose the expected window update frame.
+    dataOut.writeShort(4); // length
+    dataOut.write(Http20Draft09.TYPE_WINDOW_UPDATE);
+    dataOut.write(0); // No flags.
+    dataOut.writeInt(expectedStreamId);
+    dataOut.writeInt(expectedWindowSizeIncrement);
+
+    // Check writer sends the same bytes.
+    assertArrayEquals(out.toByteArray(), windowUpdate(expectedWindowSizeIncrement));
+
+    FrameReader fr = newReader(out);
+
+    fr.nextFrame(new BaseTestHandler() { // Consume the window update frame.
+      public void windowUpdate(int streamId, int windowSizeIncrement) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedWindowSizeIncrement, windowSizeIncrement);
+      }
+    });
+  }
+
+  @Test public void badWindowSizeIncrement() throws IOException {
+    try {
+      windowUpdate(0);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 0", e.getMessage());
+    }
+    try {
+      windowUpdate(0x80000000);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 2147483648",
+          e.getMessage());
+    }
+  }
+
   private Http20Draft09.Reader newReader(ByteArrayOutputStream out) {
     return new Http20Draft09.Reader(new ByteArrayInputStream(out.toByteArray()),
         Variant.HTTP_20_DRAFT_09.initialPeerSettings(false).getHeaderTableSize(), false);
@@ -379,4 +421,10 @@
     new Http20Draft09.Writer(out, true).sendDataFrame(expectedStreamId, 0, data, offset, byteCount);
     return out.toByteArray();
   }
+
+  private byte[] windowUpdate(int windowSizeIncrement) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Http20Draft09.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
+    return out.toByteArray();
+  }
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index 73a37e0..3e36b1c 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -185,7 +185,7 @@
     public int associatedStreamId;
     public int priority;
     public ErrorCode errorCode;
-    public int deltaWindowSize;
+    public int windowSizeIncrement;
     public List<Header> headerBlock;
     public byte[] data;
     public Settings settings;
@@ -257,11 +257,11 @@
       this.errorCode = errorCode;
     }
 
-    @Override public void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl) {
+    @Override public void windowUpdate(int streamId, int windowSizeIncrement) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_WINDOW_UPDATE;
       this.streamId = streamId;
-      this.deltaWindowSize = deltaWindowSize;
+      this.windowSizeIncrement = windowSizeIncrement;
     }
 
     @Override public void priority(int streamId, int priority) {
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
index 83d3fd2..a7520b3 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
@@ -29,11 +29,27 @@
     try {
       sendDataFrame(new byte[0x1000000]);
       fail();
-    } catch (IOException e) {
+    } catch (IllegalArgumentException e) {
       assertEquals("FRAME_TOO_LARGE max size is 16Mib: 16777216", e.getMessage());
     }
   }
 
+  @Test public void badWindowSizeIncrement() throws IOException {
+    try {
+      windowUpdate(0);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 0", e.getMessage());
+    }
+    try {
+      windowUpdate(0x80000000);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 2147483648",
+          e.getMessage());
+    }
+  }
+
   private byte[] sendDataFrame(byte[] data) throws IOException {
     return sendDataFrame(data, 0, data.length);
   }
@@ -43,4 +59,10 @@
     new Spdy3.Writer(out, true).sendDataFrame(expectedStreamId, 0, data, offset, byteCount);
     return out.toByteArray();
   }
+
+  private byte[] windowUpdate(int increment) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Spdy3.Writer(out, true).windowUpdate(expectedStreamId, increment);
+    return out.toByteArray();
+  }
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index 313bcbc..31c9450 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -15,7 +15,6 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.Base64;
 import com.squareup.okhttp.internal.Util;
 import java.io.ByteArrayOutputStream;
@@ -27,6 +26,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import org.junit.After;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.Util.UTF_8;
@@ -189,9 +189,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection =
-        new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS)
-            .build();
+    SpdyConnection connection = connection(peer, Variant.SPDY3);
     connection.noop();
 
     // verify the peer received what was expected
@@ -206,7 +204,7 @@
     peer.play();
 
     // play it back
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS).build();
+    connection(peer, Variant.SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame ping = peer.takeFrame();
@@ -225,7 +223,7 @@
     peer.play();
 
     // play it back
-    http2Connection(peer);
+    connection(peer, Variant.HTTP_20_DRAFT_09);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame ping = peer.takeFrame();
@@ -243,9 +241,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, Variant.SPDY3);
     Ping ping = connection.ping();
     assertTrue(ping.roundTripTime() > 0);
     assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
@@ -267,7 +263,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = http2Connection(peer);
+    SpdyConnection connection = connection(peer, Variant.HTTP_20_DRAFT_09);
     Ping ping = connection.ping();
     assertTrue(ping.roundTripTime() > 0);
     assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
@@ -290,7 +286,7 @@
     peer.play();
 
     // play it back
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS).build();
+    connection(peer, Variant.SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame ping2 = peer.takeFrame();
@@ -338,9 +334,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, Variant.SPDY3);
 
     peer.takeFrame(); // Guarantees that the peer Settings frame has been processed.
     synchronized (connection) {
@@ -365,9 +359,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, Variant.SPDY3);
 
     peer.takeFrame(); // Guarantees that the Settings frame has been processed.
     synchronized (connection) {
@@ -391,7 +383,7 @@
     peer.play();
 
     // play it back
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS).build();
+    connection(peer, Variant.SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
@@ -411,7 +403,7 @@
     peer.play();
 
     // play it back
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS).build();
+    connection(peer, Variant.SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
@@ -433,9 +425,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, Variant.SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, false);
     OutputStream out = stream.getOutputStream();
     out.write("square".getBytes(UTF_8));
@@ -479,9 +469,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, Variant.SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     OutputStream out = stream.getOutputStream();
     connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
@@ -521,9 +509,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, Variant.SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
     InputStream in = stream.getInputStream();
     OutputStream out = stream.getOutputStream();
@@ -566,9 +552,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, Variant.SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     InputStream in = stream.getInputStream();
     OutputStream out = stream.getOutputStream();
@@ -610,9 +594,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, Variant.SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
     InputStream in = stream.getInputStream();
     assertStreamData("square", in);
@@ -1006,7 +988,24 @@
   }
 
   @Test public void readSendsWindowUpdate() throws Exception {
-    int windowUpdateThreshold = Variant.SPDY3.initialPeerSettings(true).getInitialWindowSize() / 2;
+    readSendsWindowUpdate(Variant.SPDY3);
+  }
+
+  /**
+   * This test fails on http/2 as it tries to send too large data frame.  In
+   * practice, {@link SpdyStream#OUTPUT_BUFFER_SIZE} prevents us from sending
+   * too large frames.  The test should probably be rewritten to take into
+   * account max frame size per variant.
+   */
+  @Test @Ignore public void readSendsWindowUpdateHttp2() throws Exception {
+    readSendsWindowUpdate(Variant.HTTP_20_DRAFT_09);
+  }
+
+  private void readSendsWindowUpdate(Variant variant)
+      throws IOException, InterruptedException {
+    MockSpdyPeer peer = new MockSpdyPeer(variant, false);
+    int windowUpdateThreshold = variant.initialPeerSettings(true).getInitialWindowSize() / 2;
+
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
@@ -1018,7 +1017,7 @@
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, variant);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals(windowUpdateThreshold, stream.windowUpdateThreshold);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
@@ -1039,7 +1038,7 @@
       MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
       assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
       assertEquals(1, windowUpdate.streamId);
-      assertEquals(windowUpdateThreshold, windowUpdate.deltaWindowSize);
+      assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
     }
   }
 
@@ -1112,7 +1111,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = http2Connection(peer);
+    SpdyConnection connection = connection(peer, Variant.HTTP_20_DRAFT_09);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     OutputStream out = stream.getOutputStream();
     out.write(buff);
@@ -1172,7 +1171,7 @@
     peer.play();
 
     // play it back
-    http2Connection(peer);
+    connection(peer, Variant.HTTP_20_DRAFT_09);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
@@ -1189,7 +1188,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = http2Connection(peer);
+    SpdyConnection connection = connection(peer, Variant.HTTP_20_DRAFT_09);
 
     // verify the peer received the ACK
     MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
@@ -1201,9 +1200,9 @@
     return connection;
   }
 
-  private SpdyConnection http2Connection(MockSpdyPeer peer) throws IOException {
+  private SpdyConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
     return new SpdyConnection.Builder(true, peer.openSocket())
-        .protocol(Protocol.HTTP_2)
+        .protocol(variant.getProtocol())
         .handler(REJECT_INCOMING_STREAMS).build();
   }
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
index 20b0317..36e2e15 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -61,8 +61,25 @@
      *  set. The data is opaque binary, and there are no rules on the content.
      */
     void ping(boolean ack, int payload1, int payload2);
-    void goAway(int lastGoodStreamId, ErrorCode errorCode);
-    void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl);
+
+    /**
+     * The peer tells us to stop creating streams.  It is safe to replay
+     * streams with {@code ID > lastGoodStreamId} on a new connection.  In-
+     * flight streams with {@code ID <= lastGoodStreamId} can only be replayed
+     * on a new connection if they are idempotent.
+     *
+     * @param lastGoodStreamId the last stream ID the peer processed before
+     * sending this message. If {@lastGoodStreamId} is zero, the peer processed no frames.
+     * @param errorCode reason for closing the connection.
+     * @param debugData only valid for http/2; opaque debug data to send.
+     */
+    void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData);
+
+    /**
+     * Notifies that an additional {@code windowSizeIncrement} bytes can be
+     * sent on {@code streamId}, or the connection if {@code streamId} is zero.
+     */
+    void windowUpdate(int streamId, long windowSizeIncrement);
     void priority(int streamId, int priority);
 
     /**
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
index ab90db6..e508c96 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -65,6 +65,7 @@
    */
   void data(boolean outFinished, int streamId, byte[] data, int offset, int byteCount)
       throws IOException;
+
   /** Write okhttp's settings to the peer. */
   void settings(Settings okHttpSettings) throws IOException;
   void noop() throws IOException;
@@ -81,6 +82,21 @@
    *  sent.  The data is opaque binary, and there are no rules on the content.
    */
   void ping(boolean ack, int payload1, int payload2) throws IOException;
-  void goAway(int lastGoodStreamId, ErrorCode errorCode) throws IOException;
-  void windowUpdate(int streamId, int deltaWindowSize) throws IOException;
+
+  /**
+   * Tell the peer to stop creating streams and that we last processed
+   * {@code lastGoodStreamId}, or zero if no streams were processed.
+   *
+   * @param lastGoodStreamId the last stream ID processed, or zero if no
+   * streams were processed.
+   * @param errorCode reason for closing the connection.
+   * @param debugData only valid for http/2; opaque debug data to send.
+   */
+  void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) throws IOException;
+
+  /**
+   * Inform peer that an additional {@code windowSizeIncrement} bytes can be
+   * sent on {@code streamId}, or the connection if {@code streamId} is zero.
+   */
+  void windowUpdate(int streamId, long windowSizeIncrement) throws IOException;
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index 4589788..f3c5484 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -73,7 +73,6 @@
   static final int FLAG_END_PUSH_PROMISE = 0x4;
   static final int FLAG_PRIORITY = 0x8;
   static final int FLAG_ACK = 0x1;
-  static final int FLAG_END_FLOW_CONTROL = 0x1;
 
   @Override public FrameReader newReader(InputStream in, Settings peerSettings, boolean client) {
     return new Reader(in, peerSettings.getHeaderTableSize(), client);
@@ -119,6 +118,9 @@
 
       // boolean r = (w1 & 0xc0000000) != 0; // Reserved.
       int length = (w1 & 0x3fff0000) >> 16; // 14-bit unsigned.
+      if (length > 16383) {
+        throw new IOException("FRAME_SIZE_ERROR max size is 16383: " + length);
+      }
       int type = (w1 & 0xff00) >> 8;
       int flags = w1 & 0xff;
       // boolean r = (w2 & 0x80000000) != 0; // Reserved.
@@ -267,26 +269,28 @@
     private void readGoAway(Handler handler, int flags, int length, int streamId)
         throws IOException {
       if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
+      if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
       int lastStreamId = in.readInt();
       int errorCodeInt = in.readInt();
       int opaqueDataLength = length - 8;
       ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
       if (errorCode == null) {
-        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
+        throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
       }
-      if (Util.skipByReading(in, opaqueDataLength) != opaqueDataLength) {
-        throw new IOException("TYPE_GOAWAY opaque data was truncated");
+      byte[] debugData = Util.EMPTY_BYTE_ARRAY;
+      if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
+        debugData = new byte[opaqueDataLength];
+        Util.readFully(in, debugData);
       }
-      handler.goAway(lastStreamId, errorCode);
+      handler.goAway(lastStreamId, errorCode, debugData);
     }
 
     private void readWindowUpdate(Handler handler, int flags, int length, int streamId)
         throws IOException {
-      int w1 = in.readInt();
-      // boolean r = (w1 & 0x80000000) != 0; // Reserved.
-      int windowSizeIncrement = (w1 & 0x7fffffff);
-      boolean endFlowControl = (flags & FLAG_END_FLOW_CONTROL) != 0;
-      handler.windowUpdate(streamId, windowSizeIncrement, endFlowControl);
+      if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
+      long increment = (in.readInt() & 0x7fffffff);
+      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
+      handler.windowUpdate(streamId, increment);
     }
 
     @Override public void close() throws IOException {
@@ -431,14 +435,33 @@
       out.writeInt(payload2);
     }
 
-    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode)
+    @Override
+    public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
         throws IOException {
-      // TODO
+      if (errorCode.httpCode == -1) {
+        throw new IllegalArgumentException("errorCode.httpCode == -1");
+      }
+      int length = 8 + debugData.length;
+      checkFrameSize(length);
+      out.writeInt((length & 0x3fff) << 16 | (TYPE_GOAWAY & 0xff) << 8);
+      out.writeInt(0); // connection-level
+      out.writeInt(lastGoodStreamId);
+      out.writeInt(errorCode.httpCode);
+      if (debugData.length > 0) {
+        out.write(debugData);
+      }
+      out.flush();
     }
 
-    @Override public synchronized void windowUpdate(int streamId, int deltaWindowSize)
+    @Override public synchronized void windowUpdate(int streamId, long increment)
         throws IOException {
-      // TODO
+      if (increment == 0 || increment > 0x7fffffffL) {
+        throw new IllegalArgumentException(
+            "windowSizeIncrement must be between 1 and 0x7fffffff: " + increment);
+      }
+      out.writeInt(4 << 16 | (TYPE_WINDOW_UPDATE & 0xff) << 8); // No flags.
+      out.writeInt(streamId);
+      out.writeInt((int) increment);
     }
 
     @Override public void close() throws IOException {
@@ -447,7 +470,9 @@
   }
 
   private static void checkFrameSize(int bytes) throws IOException {
-    if (bytes > 16383) throw ioException("FRAME_SIZE_ERROR max size is 16383: %s", bytes);
+    if (bytes > 16383) {
+      throw new IllegalArgumentException("FRAME_SIZE_ERROR max size is 16383: " + bytes);
+    }
   }
 
   private static IOException ioException(String message, Object... args) throws IOException {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index 4d0bf84..184b901 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -252,8 +252,9 @@
       int w1 = in.readInt();
       int w2 = in.readInt();
       int streamId = w1 & 0x7fffffff;
-      int deltaWindowSize = w2 & 0x7fffffff;
-      handler.windowUpdate(streamId, deltaWindowSize, false);
+      long increment = w2 & 0x7fffffff;
+      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
+      handler.windowUpdate(streamId, increment);
     }
 
     private void readPing(Handler handler, int flags, int length) throws IOException {
@@ -271,7 +272,7 @@
       if (errorCode == null) {
         throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
       }
-      handler.goAway(lastGoodStreamId, errorCode);
+      handler.goAway(lastGoodStreamId, errorCode, Util.EMPTY_BYTE_ARRAY);
     }
 
     private void readSettings(Handler handler, int flags, int length) throws IOException {
@@ -410,8 +411,8 @@
 
     void sendDataFrame(int streamId, int flags, byte[] data, int offset, int byteCount)
         throws IOException {
-      if (byteCount > 0xffffff) {
-        throw new IOException("FRAME_TOO_LARGE max size is 16Mib: " + byteCount);
+      if (byteCount > 0xffffffL) {
+        throw new IllegalArgumentException("FRAME_TOO_LARGE max size is 16Mib: " + byteCount);
       }
       out.writeInt(streamId & 0x7fffffff);
       out.writeInt((flags & 0xff) << 24 | byteCount & 0xffffff);
@@ -471,9 +472,12 @@
       out.flush();
     }
 
-    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode)
+    @Override
+    public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] ignored)
         throws IOException {
-      if (errorCode.spdyGoAwayCode == -1) throw new IllegalArgumentException();
+      if (errorCode.spdyGoAwayCode == -1) {
+        throw new IllegalArgumentException("errorCode.spdyGoAwayCode == -1");
+      }
       int type = TYPE_GOAWAY;
       int flags = 0;
       int length = 8;
@@ -484,15 +488,19 @@
       out.flush();
     }
 
-    @Override public synchronized void windowUpdate(int streamId, int deltaWindowSize)
+    @Override public synchronized void windowUpdate(int streamId, long increment)
         throws IOException {
+      if (increment == 0 || increment > 0x7fffffffL) {
+        throw new IllegalArgumentException(
+            "windowSizeIncrement must be between 1 and 0x7fffffff: " + increment);
+      }
       int type = TYPE_WINDOW_UPDATE;
       int flags = 0;
       int length = 8;
       out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
       out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
       out.writeInt(streamId);
-      out.writeInt(deltaWindowSize);
+      out.writeInt((int) increment);
       out.flush();
     }
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index 504d49f..c8cb750 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -218,19 +218,19 @@
     frameWriter.rstStream(streamId, statusCode);
   }
 
-  void writeWindowUpdateLater(final int streamId, final int deltaWindowSize) {
+  void writeWindowUpdateLater(final int streamId, final int windowSizeIncrement) {
     executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
       @Override public void execute() {
         try {
-          writeWindowUpdate(streamId, deltaWindowSize);
+          writeWindowUpdate(streamId, windowSizeIncrement);
         } catch (IOException ignored) {
         }
       }
     });
   }
 
-  void writeWindowUpdate(int streamId, int deltaWindowSize) throws IOException {
-    frameWriter.windowUpdate(streamId, deltaWindowSize);
+  void writeWindowUpdate(int streamId, int windowSizeIncrement) throws IOException {
+    frameWriter.windowUpdate(streamId, windowSizeIncrement);
   }
 
   /**
@@ -303,7 +303,8 @@
         shutdown = true;
         lastGoodStreamId = this.lastGoodStreamId;
       }
-      frameWriter.goAway(lastGoodStreamId, statusCode);
+      // TODO: propagate exception message into debugData
+      frameWriter.goAway(lastGoodStreamId, statusCode, Util.EMPTY_BYTE_ARRAY);
     }
   }
 
@@ -597,7 +598,10 @@
       }
     }
 
-    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode) {
+    @Override
+    public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+      if (debugData.length > 0) { // TODO: log the debugData
+      }
       synchronized (SpdyConnection.this) {
         shutdown = true;
 
@@ -614,16 +618,16 @@
       }
     }
 
-    @Override public void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl) {
+    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
       if (streamId == 0) {
-        // TODO: honor whole-stream flow control
+        // TODO: honor connection-level flow control
         return;
       }
 
       // TODO: honor endFlowControl
       SpdyStream stream = getStream(streamId);
       if (stream != null) {
-        stream.receiveWindowUpdate(deltaWindowSize);
+        stream.receiveWindowUpdate(windowSizeIncrement);
       }
     }
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index ba14dbe..68ab921 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -325,8 +325,8 @@
     notifyAll();
   }
 
-  synchronized void receiveWindowUpdate(int deltaWindowSize) {
-    out.unacknowledgedBytes -= deltaWindowSize;
+  synchronized void receiveWindowUpdate(long windowSizeIncrement) {
+    out.unacknowledgedBytes -= windowSizeIncrement;
     notifyAll();
   }
 
@@ -594,7 +594,7 @@
      * acknowledged with an incoming {@code WINDOW_UPDATE} frame. Writes
      * block if they cause this to exceed the {@code WINDOW_SIZE}.
      */
-    private int unacknowledgedBytes = 0;
+    private long unacknowledgedBytes = 0;
 
     @Override public void write(int b) throws IOException {
       Util.writeSingleByte(this, b);
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
index cbb6eac..dc08d2f 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
@@ -49,12 +49,13 @@
     fail();
   }
 
-  @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode) {
+  @Override
+  public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
     fail();
   }
 
   @Override
-  public void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl) {
+  public void windowUpdate(int streamId, long windowSizeIncrement) {
     fail();
   }
 
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index 31d0842..8f7c917 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -348,11 +348,113 @@
     try {
       sendDataFrame(new byte[0x1000000]);
       fail();
-    } catch (IOException e) {
+    } catch (IllegalArgumentException e) {
       assertEquals("FRAME_SIZE_ERROR max size is 16383: 16777216", e.getMessage());
     }
   }
 
+  @Test public void windowUpdateRoundTrip() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final long expectedWindowSizeIncrement = 0x7fffffff;
+
+    // Compose the expected window update frame.
+    dataOut.writeShort(4); // length
+    dataOut.write(Http20Draft09.TYPE_WINDOW_UPDATE);
+    dataOut.write(0); // No flags.
+    dataOut.writeInt(expectedStreamId);
+    dataOut.writeInt((int) expectedWindowSizeIncrement);
+
+    // Check writer sends the same bytes.
+    assertArrayEquals(out.toByteArray(), windowUpdate(expectedWindowSizeIncrement));
+
+    FrameReader fr = newReader(out);
+
+    fr.nextFrame(new BaseTestHandler() { // Consume the window update frame.
+      @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedWindowSizeIncrement, windowSizeIncrement);
+      }
+    });
+  }
+
+  @Test public void badWindowSizeIncrement() throws IOException {
+    try {
+      windowUpdate(0);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 0", e.getMessage());
+    }
+    try {
+      windowUpdate(0x80000000L);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 2147483648",
+          e.getMessage());
+    }
+  }
+
+  @Test public void goAwayWithoutDebugDataRoundTrip() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
+
+    // Compose the expected GOAWAY frame without debug data.
+    dataOut.writeShort(8); // Without debug data there's only 2 32-bit fields.
+    dataOut.write(Http20Draft09.TYPE_GOAWAY);
+    dataOut.write(0); // no flags.
+    dataOut.writeInt(0); // connection-scope
+    dataOut.writeInt(expectedStreamId); // last good stream.
+    dataOut.writeInt(expectedError.httpCode);
+
+    // Check writer sends the same bytes.
+    assertArrayEquals(out.toByteArray(),
+        sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
+
+    FrameReader fr = newReader(out);
+
+    fr.nextFrame(new BaseTestHandler() { // Consume the go away frame.
+      @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+        assertEquals(expectedStreamId, lastGoodStreamId);
+        assertEquals(expectedError, errorCode);
+        assertEquals(0, debugData.length);
+      }
+    });
+  }
+
+  @Test public void goAwayWithDebugDataRoundTrip() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
+    final byte[] expectedData = new byte[8];
+    Arrays.fill(expectedData, (byte) '*');
+
+    // Compose the expected GOAWAY frame without debug data.
+    dataOut.writeShort(8 + expectedData.length);
+    dataOut.write(Http20Draft09.TYPE_GOAWAY);
+    dataOut.write(0); // no flags.
+    dataOut.writeInt(0); // connection-scope
+    dataOut.writeInt(0); // never read any stream!
+    dataOut.writeInt(expectedError.httpCode);
+    dataOut.write(expectedData);
+
+    // Check writer sends the same bytes.
+    assertArrayEquals(out.toByteArray(), sendGoAway(0, expectedError, expectedData));
+
+    FrameReader fr = newReader(out);
+
+    fr.nextFrame(new BaseTestHandler() { // Consume the go away frame.
+      @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+        assertEquals(0, lastGoodStreamId);
+        assertEquals(expectedError, errorCode);
+        assertArrayEquals(expectedData, debugData);
+      }
+    });
+  }
+
   private Http20Draft09.Reader newReader(ByteArrayOutputStream out) {
     return new Http20Draft09.Reader(new ByteArrayInputStream(out.toByteArray()),
         Variant.HTTP_20_DRAFT_09.initialPeerSettings(false).getHeaderTableSize(), false);
@@ -370,6 +472,13 @@
     return out.toByteArray();
   }
 
+  private byte[] sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+      throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Http20Draft09.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
+    return out.toByteArray();
+  }
+
   private byte[] sendDataFrame(byte[] data) throws IOException {
     return sendDataFrame(data, 0, data.length);
   }
@@ -379,4 +488,10 @@
     new Http20Draft09.Writer(out, true).sendDataFrame(expectedStreamId, 0, data, offset, byteCount);
     return out.toByteArray();
   }
+
+  private byte[] windowUpdate(long windowSizeIncrement) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Http20Draft09.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
+    return out.toByteArray();
+  }
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index 73a37e0..7ce058e 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -185,7 +185,7 @@
     public int associatedStreamId;
     public int priority;
     public ErrorCode errorCode;
-    public int deltaWindowSize;
+    public long windowSizeIncrement;
     public List<Header> headerBlock;
     public byte[] data;
     public Settings settings;
@@ -250,18 +250,20 @@
       this.type = Spdy3.TYPE_NOOP;
     }
 
-    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode) {
+    @Override
+    public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_GOAWAY;
       this.streamId = lastGoodStreamId;
       this.errorCode = errorCode;
+      this.data = debugData;
     }
 
-    @Override public void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl) {
+    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_WINDOW_UPDATE;
       this.streamId = streamId;
-      this.deltaWindowSize = deltaWindowSize;
+      this.windowSizeIncrement = windowSizeIncrement;
     }
 
     @Override public void priority(int streamId, int priority) {
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
index 83d3fd2..c6adebb 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
@@ -15,10 +15,14 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.Util;
+import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
 import java.io.IOException;
 import org.junit.Test;
 
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
@@ -29,11 +33,63 @@
     try {
       sendDataFrame(new byte[0x1000000]);
       fail();
-    } catch (IOException e) {
-      assertEquals("FRAME_TOO_LARGE max size is 16Mib: 16777216", e.getMessage());
+    } catch (IllegalArgumentException e) {
+      assertEquals("FRAME_TOO_LARGE max size is 16Mib: " + 0x1000000L, e.getMessage());
     }
   }
 
+  @Test public void badWindowSizeIncrement() throws IOException {
+    try {
+      windowUpdate(0);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 0", e.getMessage());
+    }
+    try {
+      windowUpdate(0x80000000L);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 2147483648",
+          e.getMessage());
+    }
+  }
+
+  @Test public void goAwayRoundTrip() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
+
+    // Compose the expected GOAWAY frame without debug data
+    // |C| Version(15bits) | Type(16bits) |
+    dataOut.writeInt(0x80000000 | (Spdy3.VERSION & 0x7fff) << 16 | Spdy3.TYPE_GOAWAY & 0xffff);
+    // | Flags (8)  |  Length (24 bits)   |
+    dataOut.writeInt(8); // no flags and length is 8.
+    dataOut.writeInt(expectedStreamId); // last good stream.
+    dataOut.writeInt(expectedError.spdyGoAwayCode);
+
+    // Check writer sends the same bytes.
+    assertArrayEquals(out.toByteArray(),
+        sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
+
+    // SPDY/3 does not send debug data, so bytes should be same!
+    assertArrayEquals(out.toByteArray(), sendGoAway(expectedStreamId, expectedError, new byte[8]));
+
+    FrameReader fr = newReader(out);
+
+    fr.nextFrame(new BaseTestHandler() { // Consume the goAway frame.
+      @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+        assertEquals(expectedStreamId, lastGoodStreamId);
+        assertEquals(expectedError, errorCode);
+        assertEquals(0, debugData.length);
+      }
+    });
+  }
+
+  private Spdy3.Reader newReader(ByteArrayOutputStream out) {
+    return new Spdy3.Reader(new ByteArrayInputStream(out.toByteArray()), false);
+  }
+
   private byte[] sendDataFrame(byte[] data) throws IOException {
     return sendDataFrame(data, 0, data.length);
   }
@@ -43,4 +99,17 @@
     new Spdy3.Writer(out, true).sendDataFrame(expectedStreamId, 0, data, offset, byteCount);
     return out.toByteArray();
   }
+
+  private byte[] windowUpdate(long increment) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Spdy3.Writer(out, true).windowUpdate(expectedStreamId, increment);
+    return out.toByteArray();
+  }
+
+  private byte[] sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+      throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Spdy3.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
+    return out.toByteArray();
+  }
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index 313bcbc..d89d664 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -15,7 +15,6 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.Base64;
 import com.squareup.okhttp.internal.Util;
 import java.io.ByteArrayOutputStream;
@@ -27,6 +26,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import org.junit.After;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.Util.UTF_8;
@@ -189,9 +189,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection =
-        new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS)
-            .build();
+    SpdyConnection connection = connection(peer, Variant.SPDY3);
     connection.noop();
 
     // verify the peer received what was expected
@@ -206,7 +204,7 @@
     peer.play();
 
     // play it back
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS).build();
+    connection(peer, Variant.SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame ping = peer.takeFrame();
@@ -225,7 +223,7 @@
     peer.play();
 
     // play it back
-    http2Connection(peer);
+    connection(peer, Variant.HTTP_20_DRAFT_09);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame ping = peer.takeFrame();
@@ -243,9 +241,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, Variant.SPDY3);
     Ping ping = connection.ping();
     assertTrue(ping.roundTripTime() > 0);
     assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
@@ -267,7 +263,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = http2Connection(peer);
+    SpdyConnection connection = connection(peer, Variant.HTTP_20_DRAFT_09);
     Ping ping = connection.ping();
     assertTrue(ping.roundTripTime() > 0);
     assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
@@ -290,7 +286,7 @@
     peer.play();
 
     // play it back
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS).build();
+    connection(peer, Variant.SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame ping2 = peer.takeFrame();
@@ -338,9 +334,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, Variant.SPDY3);
 
     peer.takeFrame(); // Guarantees that the peer Settings frame has been processed.
     synchronized (connection) {
@@ -365,9 +359,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, Variant.SPDY3);
 
     peer.takeFrame(); // Guarantees that the Settings frame has been processed.
     synchronized (connection) {
@@ -391,7 +383,7 @@
     peer.play();
 
     // play it back
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS).build();
+    connection(peer, Variant.SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
@@ -411,7 +403,7 @@
     peer.play();
 
     // play it back
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS).build();
+    connection(peer, Variant.SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
@@ -433,9 +425,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, Variant.SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, false);
     OutputStream out = stream.getOutputStream();
     out.write("square".getBytes(UTF_8));
@@ -479,9 +469,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, Variant.SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     OutputStream out = stream.getOutputStream();
     connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
@@ -521,9 +509,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, Variant.SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
     InputStream in = stream.getInputStream();
     OutputStream out = stream.getOutputStream();
@@ -566,9 +552,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, Variant.SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     InputStream in = stream.getInputStream();
     OutputStream out = stream.getOutputStream();
@@ -610,9 +594,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, Variant.SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
     InputStream in = stream.getInputStream();
     assertStreamData("square", in);
@@ -772,18 +754,29 @@
     assertEquals(2, ping.payload1);
   }
 
+
   @Test public void receiveGoAway() throws Exception {
+    receiveGoAway(Variant.SPDY3);
+  }
+
+  @Test public void receiveGoAwayHttp2() throws Exception {
+    receiveGoAway(Variant.HTTP_20_DRAFT_09);
+  }
+
+  private void receiveGoAway(Variant variant) throws Exception {
+    MockSpdyPeer peer = new MockSpdyPeer(variant, false);
+
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // SYN_STREAM 3
-    peer.sendFrame().goAway(1, PROTOCOL_ERROR);
+    peer.sendFrame().goAway(1, PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // DATA STREAM 1
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, variant);
     SpdyStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
     SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the GO_AWAY has been received.
@@ -1006,7 +999,24 @@
   }
 
   @Test public void readSendsWindowUpdate() throws Exception {
-    int windowUpdateThreshold = Variant.SPDY3.initialPeerSettings(true).getInitialWindowSize() / 2;
+    readSendsWindowUpdate(Variant.SPDY3);
+  }
+
+  /**
+   * This test fails on http/2 as it tries to send too large data frame.  In
+   * practice, {@link SpdyStream#OUTPUT_BUFFER_SIZE} prevents us from sending
+   * too large frames.  The test should probably be rewritten to take into
+   * account max frame size per variant.
+   */
+  @Test @Ignore public void readSendsWindowUpdateHttp2() throws Exception {
+    readSendsWindowUpdate(Variant.HTTP_20_DRAFT_09);
+  }
+
+  private void readSendsWindowUpdate(Variant variant)
+      throws IOException, InterruptedException {
+    MockSpdyPeer peer = new MockSpdyPeer(variant, false);
+    int windowUpdateThreshold = variant.initialPeerSettings(true).getInitialWindowSize() / 2;
+
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
@@ -1018,7 +1028,7 @@
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, variant);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals(windowUpdateThreshold, stream.windowUpdateThreshold);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
@@ -1039,7 +1049,7 @@
       MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
       assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
       assertEquals(1, windowUpdate.streamId);
-      assertEquals(windowUpdateThreshold, windowUpdate.deltaWindowSize);
+      assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
     }
   }
 
@@ -1112,7 +1122,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = http2Connection(peer);
+    SpdyConnection connection = connection(peer, Variant.HTTP_20_DRAFT_09);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     OutputStream out = stream.getOutputStream();
     out.write(buff);
@@ -1172,7 +1182,7 @@
     peer.play();
 
     // play it back
-    http2Connection(peer);
+    connection(peer, Variant.HTTP_20_DRAFT_09);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
@@ -1189,7 +1199,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = http2Connection(peer);
+    SpdyConnection connection = connection(peer, Variant.HTTP_20_DRAFT_09);
 
     // verify the peer received the ACK
     MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
@@ -1201,9 +1211,9 @@
     return connection;
   }
 
-  private SpdyConnection http2Connection(MockSpdyPeer peer) throws IOException {
+  private SpdyConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
     return new SpdyConnection.Builder(true, peer.openSocket())
-        .protocol(Protocol.HTTP_2)
+        .protocol(variant.getProtocol())
         .handler(REJECT_INCOMING_STREAMS).build();
   }
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index faa83b2..defe6f5 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -38,11 +38,7 @@
   }
 
   // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-6.5
-  @Override public Settings defaultOkHttpSettings(boolean client) {
-    return initialPeerSettings(client);
-  }
-
-  @Override public Settings initialPeerSettings(boolean client) {
+  static Settings defaultSettings(boolean client) {
     Settings settings = new Settings();
     settings.set(Settings.HEADER_TABLE_SIZE, 0, 4096);
     if (client) { // client specifies whether or not it accepts push.
@@ -74,11 +70,11 @@
   static final int FLAG_PRIORITY = 0x8;
   static final int FLAG_ACK = 0x1;
 
-  @Override public FrameReader newReader(InputStream in, Settings peerSettings, boolean client) {
-    return new Reader(in, peerSettings.getHeaderTableSize(), client);
+  @Override public FrameReader newReader(InputStream in, boolean client) {
+    return new Reader(in, 4096, client);
   }
 
-  @Override public FrameWriter newWriter(OutputStream out, Settings ignored, boolean client) {
+  @Override public FrameWriter newWriter(OutputStream out, boolean client) {
     return new Writer(out, client);
   }
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index 184b901..e20c9d7 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -36,11 +36,7 @@
     return Protocol.SPDY_3;
   }
 
-  @Override public Settings defaultOkHttpSettings(boolean client) {
-    return initialPeerSettings(client); // no difference in defaults.
-  }
-
-  @Override public Settings initialPeerSettings(boolean client) {
+  static Settings defaultSettings(boolean client) {
     Settings settings = new Settings();
     settings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
     return settings;
@@ -104,11 +100,11 @@
     }
   }
 
-  @Override public FrameReader newReader(InputStream in, Settings ignored, boolean client) {
+  @Override public FrameReader newReader(InputStream in, boolean client) {
     return new Reader(in, client);
   }
 
-  @Override public FrameWriter newWriter(OutputStream out, Settings ignored, boolean client) {
+  @Override public FrameWriter newWriter(OutputStream out, boolean client) {
     return new Writer(out, client);
   }
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index c8cb750..b5e143a 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -13,7 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.Protocol;
@@ -61,7 +60,7 @@
       Util.threadFactory("OkHttp SpdyConnection", true));
 
   /** The protocol variant, like {@link com.squareup.okhttp.internal.spdy.Spdy3}. */
-  final Variant variant;
+  final Protocol protocol;
 
   /** True if this peer initiated the connection. */
   final boolean client;
@@ -93,27 +92,37 @@
   final ByteArrayPool bufferPool;
 
   private SpdyConnection(Builder builder) {
-    variant = builder.variant;
+    protocol = builder.protocol;
     client = builder.client;
-    okHttpSettings = variant.defaultOkHttpSettings(client);
-    // TODO: implement stream limit
-    // okHttpSettings.set(Settings.MAX_CONCURRENT_STREAMS, 0, max);
-    peerSettings = variant.initialPeerSettings(client);
-    bufferPool = new ByteArrayPool(peerSettings.getInitialWindowSize() * 8);
     handler = builder.handler;
-    frameReader = variant.newReader(builder.in, peerSettings, client);
-    frameWriter = variant.newWriter(builder.out, okHttpSettings, client);
     nextStreamId = builder.client ? 1 : 2;
     nextPingId = builder.client ? 1 : 2;
-
     hostName = builder.hostName;
 
+    Variant variant;
+    if (protocol == Protocol.HTTP_2) {
+      okHttpSettings = Http20Draft09.defaultSettings(client);
+      variant = new Http20Draft09(); // connection-specific settings here!
+    } else if (protocol == Protocol.SPDY_3) {
+      okHttpSettings = Spdy3.defaultSettings(client);
+      variant = new Spdy3(); // connection-specific settings here!
+    } else {
+      throw new AssertionError(protocol);
+    }
+
+    // TODO: implement stream limit
+    // okHttpSettings.set(Settings.MAX_CONCURRENT_STREAMS, 0, max);
+    peerSettings = okHttpSettings;
+    bufferPool = new ByteArrayPool(peerSettings.getInitialWindowSize() * 8);
+    frameReader = variant.newReader(builder.in, client);
+    frameWriter = variant.newWriter(builder.out, client);
+
     new Thread(new Reader()).start(); // Not a daemon thread.
   }
 
   /** The protocol as selected using NPN or ALPN. */
   public Protocol getProtocol() {
-     return variant.getProtocol();
+     return protocol;
   }
 
   /**
@@ -392,7 +401,7 @@
     private InputStream in;
     private OutputStream out;
     private IncomingStreamHandler handler = IncomingStreamHandler.REFUSE_INCOMING_STREAMS;
-    private Variant variant = Variant.SPDY3;
+    private Protocol protocol = Protocol.SPDY_3;
     private boolean client;
 
     public Builder(boolean client, Socket socket) throws IOException {
@@ -428,14 +437,7 @@
     }
 
     public Builder protocol(Protocol protocol) {
-      // TODO: protocol == variant.getProtocol, so we could map this.
-      if (protocol == Protocol.HTTP_2) {
-        this.variant = Variant.HTTP_20_DRAFT_09;
-      } else if (protocol == Protocol.SPDY_3) {
-        this.variant = Variant.SPDY3;
-      } else {
-        throw new AssertionError(protocol);
-      }
+      this.protocol = protocol;
       return this;
     }
 
@@ -550,7 +552,7 @@
         } else {
           peerSettings.merge(newSettings);
         }
-        if (SpdyConnection.this.variant.getProtocol() == Protocol.HTTP_2) {
+        if (getProtocol() == Protocol.HTTP_2) {
           ackSettingsLater();
         }
         if (!streams.isEmpty()) {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
index f736730..784d02e 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
@@ -21,34 +21,17 @@
 
 /** A version and dialect of the framed socket protocol. */
 interface Variant {
-  Variant SPDY3 = new Spdy3();
-  Variant HTTP_20_DRAFT_09 = new Http20Draft09();
 
   /** The protocol as selected using NPN or ALPN. */
   Protocol getProtocol();
 
   /**
-   * Default settings used for reading or writing frames to the peer.
-   * @param client true if these settings apply to writing requests, false if responses.
-   */
-  Settings defaultOkHttpSettings(boolean client);
-
-  /**
-   * Initial settings used for reading frames from the peer until we are sent
-   * a Settings frame.
-   * @param client true if these settings apply to reading responses, false if requests.
-   */
-  Settings initialPeerSettings(boolean client);
-
-  /**
-   * @param peerSettings potentially stale settings that reflect the remote peer.
    * @param client true if this is the HTTP client's reader, reading frames from a server.
    */
-  FrameReader newReader(InputStream in, Settings peerSettings, boolean client);
+  FrameReader newReader(InputStream in, boolean client);
 
   /**
-   * @param okHttpSettings settings sent to the peer, such compression header table size.
    * @param client true if this is the HTTP client's writer, writing frames to a server.
    */
-  FrameWriter newWriter(OutputStream out, Settings okHttpSettings, boolean client);
+  FrameWriter newWriter(OutputStream out, boolean client);
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index 8f7c917..a7f4cca 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -456,8 +456,7 @@
   }
 
   private Http20Draft09.Reader newReader(ByteArrayOutputStream out) {
-    return new Http20Draft09.Reader(new ByteArrayInputStream(out.toByteArray()),
-        Variant.HTTP_20_DRAFT_09.initialPeerSettings(false).getHeaderTableSize(), false);
+    return new Http20Draft09.Reader(new ByteArrayInputStream(out.toByteArray()), 4096, false);
   }
 
   private byte[] literalHeaders(List<Header> sentHeaders) throws IOException {
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index 7ce058e..e5335fa 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -50,7 +50,7 @@
   public MockSpdyPeer(Variant variant, boolean client) {
     this.client = client;
     this.variant = variant;
-    this.frameWriter = variant.newWriter(bytesOut, variant.defaultOkHttpSettings(client), client);
+    this.frameWriter = variant.newWriter(bytesOut, client);
   }
 
   public void acceptFrame() {
@@ -110,7 +110,7 @@
     socket = serverSocket.accept();
     OutputStream out = socket.getOutputStream();
     InputStream in = socket.getInputStream();
-    FrameReader reader = variant.newReader(in, variant.initialPeerSettings(client), client);
+    FrameReader reader = variant.newReader(in, client);
 
     Iterator<OutFrame> outFramesIterator = outFrames.iterator();
     byte[] outBytes = bytesOut.toByteArray();
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index d89d664..fbf6560 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -53,12 +53,15 @@
 import static org.junit.Assert.fail;
 
 public final class SpdyConnectionTest {
+  private static final Variant SPDY3 = new Spdy3();
+  private static final Variant HTTP_20_DRAFT_09 = new Http20Draft09();
+
   private static final IncomingStreamHandler REJECT_INCOMING_STREAMS = new IncomingStreamHandler() {
     @Override public void receive(SpdyStream stream) throws IOException {
       throw new AssertionError();
     }
   };
-  private final MockSpdyPeer peer = new MockSpdyPeer(Variant.SPDY3, false);
+  private final MockSpdyPeer peer = new MockSpdyPeer(SPDY3, false);
 
   @After public void tearDown() throws Exception {
     peer.close();
@@ -189,7 +192,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, Variant.SPDY3);
+    SpdyConnection connection = connection(peer, SPDY3);
     connection.noop();
 
     // verify the peer received what was expected
@@ -204,7 +207,7 @@
     peer.play();
 
     // play it back
-    connection(peer, Variant.SPDY3);
+    connection(peer, SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame ping = peer.takeFrame();
@@ -215,7 +218,7 @@
   }
 
   @Test public void serverPingsClientHttp2() throws Exception {
-    MockSpdyPeer peer = new MockSpdyPeer(Variant.HTTP_20_DRAFT_09, false);
+    MockSpdyPeer peer = new MockSpdyPeer(HTTP_20_DRAFT_09, false);
 
     // write the mocking script
     peer.sendFrame().ping(false, 2, 3);
@@ -223,7 +226,7 @@
     peer.play();
 
     // play it back
-    connection(peer, Variant.HTTP_20_DRAFT_09);
+    connection(peer, HTTP_20_DRAFT_09);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame ping = peer.takeFrame();
@@ -241,7 +244,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, Variant.SPDY3);
+    SpdyConnection connection = connection(peer, SPDY3);
     Ping ping = connection.ping();
     assertTrue(ping.roundTripTime() > 0);
     assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
@@ -255,7 +258,7 @@
   }
 
   @Test public void clientPingsServerHttp2() throws Exception {
-    MockSpdyPeer peer = new MockSpdyPeer(Variant.HTTP_20_DRAFT_09, false);
+    MockSpdyPeer peer = new MockSpdyPeer(HTTP_20_DRAFT_09, false);
 
     // write the mocking script
     peer.acceptFrame(); // PING
@@ -263,7 +266,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, Variant.HTTP_20_DRAFT_09);
+    SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
     Ping ping = connection.ping();
     assertTrue(ping.roundTripTime() > 0);
     assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
@@ -286,7 +289,7 @@
     peer.play();
 
     // play it back
-    connection(peer, Variant.SPDY3);
+    connection(peer, SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame ping2 = peer.takeFrame();
@@ -297,7 +300,7 @@
 
   @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
     boolean client = false; // Peer is server, so we are client.
-    Settings settings = Variant.HTTP_20_DRAFT_09.initialPeerSettings(client);
+    Settings settings = new Settings();
     settings.set(Settings.HEADER_TABLE_SIZE, PERSIST_VALUE, 0);
 
     SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
@@ -313,7 +316,7 @@
 
   @Test public void peerHttp2ClientDisablesPush() throws Exception {
     boolean client = false; // Peer is client, so we are server.
-    Settings settings = Variant.HTTP_20_DRAFT_09.initialPeerSettings(client);
+    Settings settings = Http20Draft09.defaultSettings(client);
     settings.set(Settings.ENABLE_PUSH, 0, 0); // The peer client disables push.
 
     SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
@@ -334,7 +337,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, Variant.SPDY3);
+    SpdyConnection connection = connection(peer, SPDY3);
 
     peer.takeFrame(); // Guarantees that the peer Settings frame has been processed.
     synchronized (connection) {
@@ -359,7 +362,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, Variant.SPDY3);
+    SpdyConnection connection = connection(peer, SPDY3);
 
     peer.takeFrame(); // Guarantees that the Settings frame has been processed.
     synchronized (connection) {
@@ -383,7 +386,7 @@
     peer.play();
 
     // play it back
-    connection(peer, Variant.SPDY3);
+    connection(peer, SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
@@ -403,7 +406,7 @@
     peer.play();
 
     // play it back
-    connection(peer, Variant.SPDY3);
+    connection(peer, SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
@@ -425,7 +428,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, Variant.SPDY3);
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, false);
     OutputStream out = stream.getOutputStream();
     out.write("square".getBytes(UTF_8));
@@ -469,7 +472,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, Variant.SPDY3);
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     OutputStream out = stream.getOutputStream();
     connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
@@ -509,7 +512,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, Variant.SPDY3);
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
     InputStream in = stream.getInputStream();
     OutputStream out = stream.getOutputStream();
@@ -552,7 +555,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, Variant.SPDY3);
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     InputStream in = stream.getInputStream();
     OutputStream out = stream.getOutputStream();
@@ -594,7 +597,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, Variant.SPDY3);
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
     InputStream in = stream.getInputStream();
     assertStreamData("square", in);
@@ -756,11 +759,11 @@
 
 
   @Test public void receiveGoAway() throws Exception {
-    receiveGoAway(Variant.SPDY3);
+    receiveGoAway(SPDY3);
   }
 
   @Test public void receiveGoAwayHttp2() throws Exception {
-    receiveGoAway(Variant.HTTP_20_DRAFT_09);
+    receiveGoAway(HTTP_20_DRAFT_09);
   }
 
   private void receiveGoAway(Variant variant) throws Exception {
@@ -999,7 +1002,7 @@
   }
 
   @Test public void readSendsWindowUpdate() throws Exception {
-    readSendsWindowUpdate(Variant.SPDY3);
+    readSendsWindowUpdate(SPDY3);
   }
 
   /**
@@ -1009,13 +1012,13 @@
    * account max frame size per variant.
    */
   @Test @Ignore public void readSendsWindowUpdateHttp2() throws Exception {
-    readSendsWindowUpdate(Variant.HTTP_20_DRAFT_09);
+    readSendsWindowUpdate(HTTP_20_DRAFT_09);
   }
 
   private void readSendsWindowUpdate(Variant variant)
       throws IOException, InterruptedException {
     MockSpdyPeer peer = new MockSpdyPeer(variant, false);
-    int windowUpdateThreshold = variant.initialPeerSettings(true).getInitialWindowSize() / 2;
+    int windowUpdateThreshold = 65535 / 2;
 
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
@@ -1054,7 +1057,7 @@
   }
 
   @Test public void writeAwaitsWindowUpdate() throws Exception {
-    int windowSize = Variant.SPDY3.initialPeerSettings(true).getInitialWindowSize();
+    int windowSize = 65535;
 
     // Write the mocking script. This accepts more data frames than necessary!
     peer.acceptFrame(); // SYN_STREAM
@@ -1109,7 +1112,7 @@
    * prevents us from overrunning the max frame size of SPDY/3 or HTTP/2.
    */
   @Test public void spdyStreamOutputBufferSizeLimitsDataFrameLength() throws Exception {
-    MockSpdyPeer peer = new MockSpdyPeer(Variant.HTTP_20_DRAFT_09, false);
+    MockSpdyPeer peer = new MockSpdyPeer(HTTP_20_DRAFT_09, false);
 
     byte[] buff = new byte[SpdyStream.OUTPUT_BUFFER_SIZE * 2];
     Arrays.fill(buff, (byte) '*');
@@ -1122,7 +1125,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, Variant.HTTP_20_DRAFT_09);
+    SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     OutputStream out = stream.getOutputStream();
     out.write(buff);
@@ -1166,7 +1169,7 @@
 
   // TODO: change this to only cancel when local settings disable push
   @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
-    MockSpdyPeer peer = new MockSpdyPeer(Variant.HTTP_20_DRAFT_09, false);
+    MockSpdyPeer peer = new MockSpdyPeer(HTTP_20_DRAFT_09, false);
 
     // write the mocking script
     peer.sendFrame().pushPromise(1, 2, Arrays.asList(
@@ -1182,7 +1185,7 @@
     peer.play();
 
     // play it back
-    connection(peer, Variant.HTTP_20_DRAFT_09);
+    connection(peer, HTTP_20_DRAFT_09);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
@@ -1193,13 +1196,13 @@
 
   private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
       throws IOException, InterruptedException {
-    MockSpdyPeer peer = new MockSpdyPeer(Variant.HTTP_20_DRAFT_09, client);
+    MockSpdyPeer peer = new MockSpdyPeer(HTTP_20_DRAFT_09, client);
     peer.sendFrame().settings(settings);
     peer.acceptFrame(); // ACK
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, Variant.HTTP_20_DRAFT_09);
+    SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
 
     // verify the peer received the ACK
     MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index 8a3941e..87ba091 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -178,9 +178,8 @@
      * set of emitted headers.
      */
     void readHeaders() throws IOException {
-      int b;
-      while ((b = in.read()) != -1) {
-        b &= 0xff;
+      while (in.available() > 0) {
+        int b = in.read() & 0xff;
         if (b == 0x80) { // 10000000
           clearReferenceSet();
         } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index defe6f5..ada0d6b 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -51,24 +51,23 @@
   private static final byte[] CONNECTION_HEADER =
       "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n".getBytes(Util.UTF_8);
 
-  static final int TYPE_DATA = 0x0;
-  static final int TYPE_HEADERS = 0x1;
-  static final int TYPE_PRIORITY = 0x2;
-  static final int TYPE_RST_STREAM = 0x3;
-  static final int TYPE_SETTINGS = 0x4;
-  static final int TYPE_PUSH_PROMISE = 0x5;
-  static final int TYPE_PING = 0x6;
-  static final int TYPE_GOAWAY = 0x7;
-  static final int TYPE_WINDOW_UPDATE = 0x9;
-  static final int TYPE_CONTINUATION = 0xa;
+  static final byte TYPE_DATA = 0x0;
+  static final byte TYPE_HEADERS = 0x1;
+  static final byte TYPE_PRIORITY = 0x2;
+  static final byte TYPE_RST_STREAM = 0x3;
+  static final byte TYPE_SETTINGS = 0x4;
+  static final byte TYPE_PUSH_PROMISE = 0x5;
+  static final byte TYPE_PING = 0x6;
+  static final byte TYPE_GOAWAY = 0x7;
+  static final byte TYPE_WINDOW_UPDATE = 0x9;
+  static final byte TYPE_CONTINUATION = 0xa;
 
-  static final int FLAG_END_STREAM = 0x1;
-
-  /** Used for headers and continuation. */
-  static final int FLAG_END_HEADERS = 0x4;
-  static final int FLAG_END_PUSH_PROMISE = 0x4;
-  static final int FLAG_PRIORITY = 0x8;
-  static final int FLAG_ACK = 0x1;
+  static final byte FLAG_NONE = 0x0;
+  static final byte FLAG_ACK = 0x1;
+  static final byte FLAG_END_STREAM = 0x1;
+  static final byte FLAG_END_HEADERS = 0x4; // Used for headers and continuation.
+  static final byte FLAG_END_PUSH_PROMISE = 0x4;
+  static final byte FLAG_PRIORITY = 0x8;
 
   @Override public FrameReader newReader(InputStream in, boolean client) {
     return new Reader(in, 4096, client);
@@ -88,18 +87,18 @@
 
     Reader(InputStream in, int headerTableSize, boolean client) {
       this.in = new DataInputStream(in);
-      this.continuation = new ContinuationInputStream(this.in);
       this.client = client;
+      this.continuation = new ContinuationInputStream(this.in);
       this.hpackReader = new HpackDraft05.Reader(client, headerTableSize, continuation);
     }
 
     @Override public void readConnectionHeader() throws IOException {
       if (client) return; // Nothing to read; servers don't send connection headers!
       byte[] connectionHeader = new byte[CONNECTION_HEADER.length];
-      in.readFully(connectionHeader);
+      Util.readFully(in, connectionHeader);
       if (!Arrays.equals(connectionHeader, CONNECTION_HEADER)) {
-        throw ioException("Expected a connection header but was "
-            + Arrays.toString(connectionHeader));
+        throw ioException("Expected a connection header but was %s",
+            Arrays.toString(connectionHeader));
       }
     }
 
@@ -110,77 +109,82 @@
       } catch (IOException e) {
         return false; // This might be a normal socket close.
       }
+
       int w2 = in.readInt();
 
-      // boolean r = (w1 & 0xc0000000) != 0; // Reserved.
-      short length = (short) ((w1 & 0x3fff0000) >> 16); // 14-bit unsigned.
-      if (length < 0 || length > 16383) {
-        throw new IOException("FRAME_SIZE_ERROR max size is 16383: " + length);
-      }
+      // boolean r = (w1 & 0xc0000000) != 0; // Reserved: Ignore first 2 bits.
+      short length = (short) ((w1 & 0x3fff0000) >> 16); // 14-bit unsigned == max 16383
       byte type = (byte) ((w1 & 0xff00) >> 8);
       byte flags = (byte) (w1 & 0xff);
-      // boolean r = (w2 & 0x80000000) != 0; // Reserved.
-      int streamId = (w2 & 0x7fffffff);
+      // boolean r = (w2 & 0x80000000) != 0; // Reserved: Ignore first bit.
+      int streamId = (w2 & 0x7fffffff); // 31-bit opaque identifier.
 
       switch (type) {
         case TYPE_DATA:
           readData(handler, length, flags, streamId);
-          return true;
+          break;
 
         case TYPE_HEADERS:
           readHeaders(handler, length, flags, streamId);
-          return true;
+          break;
 
         case TYPE_PRIORITY:
           readPriority(handler, length, flags, streamId);
-          return true;
+          break;
 
         case TYPE_RST_STREAM:
           readRstStream(handler, length, flags, streamId);
-          return true;
+          break;
 
         case TYPE_SETTINGS:
           readSettings(handler, length, flags, streamId);
-          return true;
+          break;
 
         case TYPE_PUSH_PROMISE:
           readPushPromise(handler, length, flags, streamId);
-          return true;
+          break;
 
         case TYPE_PING:
           readPing(handler, length, flags, streamId);
-          return true;
+          break;
 
         case TYPE_GOAWAY:
           readGoAway(handler, length, flags, streamId);
-          return true;
+          break;
 
         case TYPE_WINDOW_UPDATE:
           readWindowUpdate(handler, length, flags, streamId);
-          return true;
-      }
+          break;
 
-      throw new UnsupportedOperationException(Integer.toBinaryString(type));
+        default:
+          // Implementations MUST ignore frames of unsupported or unrecognized types.
+          Util.skipByReading(in, length);
+      }
+      return true;
     }
 
     private void readHeaders(Handler handler, short length, byte flags, int streamId)
         throws IOException {
       if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
 
-      boolean endHeaders = (flags & FLAG_END_HEADERS) != 0;
       boolean endStream = (flags & FLAG_END_STREAM) != 0;
-      int priority = ((flags & FLAG_PRIORITY) != 0) ? in.readInt() & 0x7fffffff : -1;
 
-      List<Header> headerBlock = readHeaderBlock(length, endHeaders, streamId);
+      int priority = -1;
+      if ((flags & FLAG_PRIORITY) != 0) {
+        priority = in.readInt() & 0x7fffffff;
+        length -= 4; // account for above read.
+      }
+
+      List<Header> headerBlock = readHeaderBlock(length, flags, streamId);
 
       handler.headers(false, endStream, streamId, -1, priority, headerBlock,
           HeadersMode.HTTP_20_HEADERS);
     }
 
-    private List<Header> readHeaderBlock(short length, boolean endHeaders, int streamId)
+    private List<Header> readHeaderBlock(short length, byte flags, int streamId)
         throws IOException {
-      continuation.bytesLeft = length;
-      continuation.endHeaders = endHeaders;
+      continuation.length = continuation.left = length;
+      continuation.flags = flags;
       continuation.streamId = streamId;
 
       hpackReader.readHeaders();
@@ -246,11 +250,9 @@
       if (streamId == 0) {
         throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
       }
-      boolean endHeaders = (flags & FLAG_END_PUSH_PROMISE) != 0;
-
       int promisedStreamId = in.readInt() & 0x7fffffff;
-      List<Header> headerBlock = readHeaderBlock(length, endHeaders, streamId);
-
+      length -= 4; // account for above read.
+      List<Header> headerBlock = readHeaderBlock(length, flags, streamId);
       handler.pushPromise(streamId, promisedStreamId, headerBlock);
     }
 
@@ -314,9 +316,11 @@
     }
 
     @Override public synchronized void ackSettings() throws IOException {
-      // ACK the settings frame.
-      out.writeInt(0 | (TYPE_SETTINGS & 0xff) << 8 | (FLAG_ACK & 0xff));
-      out.writeInt(0);
+      int length = 0;
+      byte type = TYPE_SETTINGS;
+      byte flags = FLAG_ACK;
+      int streamId = 0;
+      frameHeader(length, type, flags, streamId);
     }
 
     @Override public synchronized void connectionHeader() throws IOException {
@@ -343,17 +347,16 @@
     }
 
     @Override
-    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+    public synchronized void pushPromise(int streamId, int promisedStreamId,
+        List<Header> requestHeaders)
         throws IOException {
       hpackBuffer.reset();
       hpackWriter.writeHeaders(requestHeaders);
-      int type = TYPE_PUSH_PROMISE;
-      // TODO: implement CONTINUATION
-      int length = hpackBuffer.size();
-      checkFrameSize(length);
-      int flags = FLAG_END_HEADERS;
-      out.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
-      out.writeInt(streamId & 0x7fffffff);
+
+      int length = 4 + hpackBuffer.size();
+      byte type = TYPE_PUSH_PROMISE;
+      byte flags = FLAG_END_HEADERS;
+      frameHeader(length, type, flags, streamId); // TODO: CONTINUATION
       out.writeInt(promisedStreamId & 0x7fffffff);
       hpackBuffer.writeTo(out);
     }
@@ -362,15 +365,14 @@
         List<Header> headerBlock) throws IOException {
       hpackBuffer.reset();
       hpackWriter.writeHeaders(headerBlock);
-      int type = TYPE_HEADERS;
-      // TODO: implement CONTINUATION
+
       int length = hpackBuffer.size();
-      checkFrameSize(length);
-      int flags = FLAG_END_HEADERS;
+      byte type = TYPE_HEADERS;
+      byte flags = FLAG_END_HEADERS;
       if (outFinished) flags |= FLAG_END_STREAM;
       if (priority != -1) flags |= FLAG_PRIORITY;
-      out.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
-      out.writeInt(streamId & 0x7fffffff);
+      if (priority != -1) length += 4;
+      frameHeader(length, type, flags, streamId); // TODO: CONTINUATION
       if (priority != -1) out.writeInt(priority & 0x7fffffff);
       hpackBuffer.writeTo(out);
     }
@@ -378,42 +380,40 @@
     @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
         throws IOException {
       if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
-      int flags = 0;
-      int type = TYPE_RST_STREAM;
+
       int length = 4;
-      out.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
-      out.writeInt(streamId & 0x7fffffff);
+      byte type = TYPE_RST_STREAM;
+      byte flags = FLAG_NONE;
+      frameHeader(length, type, flags, streamId);
       out.writeInt(errorCode.httpCode);
       out.flush();
     }
 
-    @Override public void data(boolean outFinished, int streamId, byte[] data) throws IOException {
+    @Override public synchronized void data(boolean outFinished, int streamId, byte[] data)
+        throws IOException {
       data(outFinished, streamId, data, 0, data.length);
     }
 
     @Override public synchronized void data(boolean outFinished, int streamId, byte[] data,
         int offset, int byteCount) throws IOException {
-      int flags = 0;
+      byte flags = FLAG_NONE;
       if (outFinished) flags |= FLAG_END_STREAM;
-      // TODO: Implement looping strategy.
-      sendDataFrame(streamId, flags, data, offset, byteCount);
+      dataFrame(streamId, flags, data, offset, byteCount); // TODO: Implement looping strategy
     }
 
-    void sendDataFrame(int streamId, int flags, byte[] data, int offset, int byteCount)
+    void dataFrame(int streamId, byte flags, byte[] data, int offset, int length)
         throws IOException {
-      checkFrameSize(byteCount);
-      out.writeInt((byteCount & 0x3fff) << 16 | (TYPE_DATA & 0xff) << 8 | (flags & 0xff));
-      out.writeInt(streamId & 0x7fffffff);
-      out.write(data, offset, byteCount);
+      byte type = TYPE_DATA;
+      frameHeader(length, type, flags, streamId);
+      out.write(data, offset, length);
     }
 
     @Override public synchronized void settings(Settings settings) throws IOException {
-      int type = TYPE_SETTINGS;
       int length = settings.size() * 8;
-      int flags = 0;
+      byte type = TYPE_SETTINGS;
+      byte flags = FLAG_NONE;
       int streamId = 0;
-      out.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
-      out.writeInt(streamId & 0x7fffffff);
+      frameHeader(length, type, flags, streamId);
       for (int i = 0; i < Settings.COUNT; i++) {
         if (!settings.isSet(i)) continue;
         out.writeInt(i & 0xffffff);
@@ -427,8 +427,11 @@
 
     @Override public synchronized void ping(boolean ack, int payload1, int payload2)
         throws IOException {
-      out.writeInt(8 << 16 | (TYPE_PING & 0xff) << 8 | ((ack ? FLAG_ACK : 0) & 0xff));
-      out.writeInt(0); // connection-level
+      int length = 8;
+      byte type = TYPE_PING;
+      byte flags = ack ? FLAG_ACK : FLAG_NONE;
+      int streamId = 0;
+      frameHeader(length, type, flags, streamId);
       out.writeInt(payload1);
       out.writeInt(payload2);
     }
@@ -436,41 +439,48 @@
     @Override
     public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
         throws IOException {
-      if (errorCode.httpCode == -1) {
-        throw new IllegalArgumentException("errorCode.httpCode == -1");
-      }
+      if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
       int length = 8 + debugData.length;
-      checkFrameSize(length);
-      out.writeInt((length & 0x3fff) << 16 | (TYPE_GOAWAY & 0xff) << 8);
-      out.writeInt(0); // connection-level
+      byte type = TYPE_GOAWAY;
+      byte flags = FLAG_NONE;
+      int streamId = 0;
+      frameHeader(length, type, flags, streamId);
       out.writeInt(lastGoodStreamId);
       out.writeInt(errorCode.httpCode);
       if (debugData.length > 0) {
         out.write(debugData);
       }
-      out.flush();
     }
 
-    @Override public synchronized void windowUpdate(int streamId, long increment)
+    @Override public synchronized void windowUpdate(int streamId, long windowSizeIncrement)
         throws IOException {
-      if (increment == 0 || increment > 0x7fffffffL) {
-        throw new IllegalArgumentException(
-            "windowSizeIncrement must be between 1 and 0x7fffffff: " + increment);
+      if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {
+        throw illegalArgument("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s",
+            windowSizeIncrement);
       }
-      out.writeInt(4 << 16 | (TYPE_WINDOW_UPDATE & 0xff) << 8); // No flags.
-      out.writeInt(streamId);
-      out.writeInt((int) increment);
+      int length = 4;
+      byte type = TYPE_WINDOW_UPDATE;
+      byte flags = FLAG_NONE;
+      frameHeader(length, type, flags, streamId);
+      out.writeInt((int) windowSizeIncrement);
     }
 
     @Override public void close() throws IOException {
       out.close();
     }
+
+    private void frameHeader(int length, byte type, byte flags, int streamId)
+        throws IOException {
+      if (length > 16383) throw illegalArgument("FRAME_SIZE_ERROR length > 16383: %s", length);
+      if ((streamId & 0x80000000) == 1) throw illegalArgument("(streamId & 0x80000000) == 1: %s",
+          streamId);
+      out.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
+      out.writeInt(streamId & 0x7fffffff);
+    }
   }
 
-  private static void checkFrameSize(int bytes) throws IOException {
-    if (bytes > 16383) {
-      throw new IllegalArgumentException("FRAME_SIZE_ERROR max size is 16383: " + bytes);
-    }
+  private static IllegalArgumentException illegalArgument(String message, Object... args) {
+    throw new IllegalArgumentException(String.format(message, args));
   }
 
   private static IOException ioException(String message, Object... args) throws IOException {
@@ -478,76 +488,87 @@
   }
 
   /**
-   * Decompression of the header block occurs above the framing layer.  This
-   * class lazily reads continuation frames as they are needed by
-   * {@link HpackDraft05.Reader#readHeaders()}.
+   * Decompression of the header block occurs above the framing layer.  This class lazily reads
+   * continuation frames as they are needed by {@link HpackDraft05.Reader#readHeaders()}.
    */
   static final class ContinuationInputStream extends InputStream {
     private final DataInputStream in;
 
-    short bytesLeft;
-    boolean endHeaders;
+    int length;
+    byte flags;
     int streamId;
 
+    int left;
+
     ContinuationInputStream(DataInputStream in) {
       this.in = in;
     }
 
     @Override public int read() throws IOException {
-      if (bytesLeft == 0) {
-        if (endHeaders) {
-          return -1;
+      if (left == 0) {
+        if (endHeaders()) {
+          throw eofReading(1);
         } else {
           readContinuationHeader();
         }
       }
-      bytesLeft--;
-      int result = in.read();
-      if (result == -1) throw new EOFException();
-      return result;
+      left--;
+      return in.read();
+    }
+
+    @Override public int available() throws IOException {
+      if (left == 0) {
+        if (endHeaders()) {
+          return 0;
+        } else {
+          readContinuationHeader();
+        }
+      }
+      return left;
     }
 
     @Override public int read(byte[] dst, int offset, int byteCount) throws IOException {
-      if (byteCount > bytesLeft) {
-        if (endHeaders) {
-          throw new EOFException(
-              String.format("Attempted to read %s bytes, when only %s left", byteCount, bytesLeft));
+      if (byteCount > left) {
+        if (endHeaders()) {
+          throw eofReading(byteCount);
         } else {
-          int beforeContinuation = bytesLeft;
-          Util.readFully(in, dst, offset, bytesLeft);
+          int beforeContinuation = left;
+          Util.readFully(in, dst, offset, beforeContinuation);
           readContinuationHeader();
           int afterContinuation = byteCount - beforeContinuation;
           offset += beforeContinuation;
-          bytesLeft -= afterContinuation;
           Util.readFully(in, dst, offset, afterContinuation);
+          left -= afterContinuation;
           return byteCount;
         }
       } else {
-        bytesLeft -= byteCount;
         Util.readFully(in, dst, offset, byteCount);
+        left -= byteCount;
         return byteCount;
       }
     }
 
+    private EOFException eofReading(int byteCount) throws EOFException {
+      int read = length - left;
+      throw new EOFException(
+          String.format("EOF reading %s more bytes; read %s/%s of frame.", byteCount, read,
+              length));
+    }
+
     private void readContinuationHeader() throws IOException {
+      int previousStreamId = streamId;
       int w1 = in.readInt();
       int w2 = in.readInt();
+      length = left = (short) ((w1 & 0x3fff0000) >> 16);
+      byte type = (byte) ((w1 & 0xff00) >> 8);
+      flags = (byte) (w1 & 0xff);
+      streamId = (w2 & 0x7fffffff);
+      if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
+      if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
+    }
 
-      // boolean r = (w1 & 0xc0000000) != 0; // Reserved.
-      bytesLeft = (short) ((w1 & 0x3fff0000) >> 16); // 14-bit unsigned.
-      if (bytesLeft < 0 || bytesLeft > 16383) {
-        throw new IOException("FRAME_SIZE_ERROR max size is 16383: " + bytesLeft);
-      }
-      int newType = (w1 & 0xff00) >> 8;
-      endHeaders = (w1 & 0xff & FLAG_END_HEADERS) != 0;
-
-      // boolean u = (w2 & 0x80000000) != 0; // Unused.
-      int newStreamId = (w2 & 0x7fffffff);
-
-      if (newType != TYPE_CONTINUATION) {
-        throw ioException("TYPE_CONTINUATION didn't have FLAG_END_HEADERS");
-      }
-      if (newStreamId != streamId) throw ioException("TYPE_CONTINUATION streamId changed");
+    private boolean endHeaders() {
+      return (flags & FLAG_END_HEADERS) != 0;
     }
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java
index 0ed247d..67b5322 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java
@@ -25,6 +25,8 @@
 
 import static com.squareup.okhttp.internal.spdy.HpackDraft05Test.MutableByteArrayInputStream;
 import static com.squareup.okhttp.internal.spdy.Http20Draft09.ContinuationInputStream;
+import static com.squareup.okhttp.internal.spdy.Http20Draft09.FLAG_END_STREAM;
+import static com.squareup.okhttp.internal.spdy.Http20Draft09.TYPE_DATA;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -34,77 +36,130 @@
   private final ContinuationInputStream continuation =
       new ContinuationInputStream(new DataInputStream(bytesIn));
 
-  @Test public void read() throws IOException {
+  @Test public void readCantOverrunHeaderPayload() throws IOException {
+    bytesIn.set(onlyHeadersPayloadFollowedByData());
 
-    // When there are bytes left this frame, read one.
-    continuation.bytesLeft = 2;
-    bytesIn.set(new byte[] {1, 2});
+    continuation.length = continuation.left = 3;
+    continuation.flags = Http20Draft09.FLAG_END_HEADERS;
+    continuation.streamId = 12345;
+
     assertEquals(1, continuation.read());
-    assertEquals(1, continuation.bytesLeft);
+    assertEquals(2, continuation.read());
+    assertEquals(3, continuation.read());
 
-    // When there are bytes left this frame, but none on the remote stream, EOF!
-    continuation.bytesLeft = 2;
-    bytesIn.set(new byte[] {});
     try {
       continuation.read();
       fail();
     } catch (EOFException expected) {
     }
-
-    // When there are no bytes left in the last header frame, return -1.
-    continuation.bytesLeft = 0;
-    continuation.endHeaders = true;
-    assertEquals(-1, continuation.read());
-    assertEquals(0, continuation.bytesLeft);
-
-    // When there are no bytes left in this frame, but it isn't the last, read continuation.
-    continuation.bytesLeft = 0;
-    continuation.endHeaders = false; // Read continuation.
-    bytesIn.set(lastContinuationFrame(new byte[] {1}));
-    assertEquals(1, continuation.read());
-    assertEquals(0, continuation.bytesLeft);
   }
 
-  @Test public void readArray() throws IOException {
-    byte[] buff = new byte[3];
+  @Test public void readCantOverrunHeaderContinuationPayload() throws IOException {
+    bytesIn.set(headersPayloadWithContinuationFollowedByData());
 
-    // When there are bytes left this frame, read them.
-    continuation.bytesLeft = 3;
-    continuation.endHeaders = true;
-    bytesIn.set(new byte[] {1, 2, 3});
+    continuation.length = continuation.left = 2;
+    continuation.flags = Http20Draft09.FLAG_NONE;
+    continuation.streamId = 12345;
+
+    assertEquals(1, continuation.read());
+    assertEquals(2, continuation.read());
+    assertEquals(3, continuation.read());
+    assertEquals(0, continuation.available());
+
+    try {
+      continuation.read();
+      fail();
+    } catch (EOFException expected) {
+    }
+  }
+
+  @Test public void availableWithContinuation() throws IOException {
+    bytesIn.set(headersPayloadWithContinuationFollowedByData());
+
+    continuation.length = continuation.left = 2;
+    continuation.flags = Http20Draft09.FLAG_NONE;
+    continuation.streamId = 12345;
+
+    assertEquals(1, continuation.read());
+    assertEquals(2, continuation.read()); // exhaust frame one
+
+    assertEquals(0, continuation.left);
+    assertEquals(1, continuation.available()); // lazy reads next
+
+    assertEquals(1, continuation.length);
+    assertEquals(1, continuation.left);
+    assertEquals(3, continuation.read());
+
+    assertEquals(0, continuation.available());
+    assertEquals(0, continuation.left);
+
+    try {
+      continuation.read();
+      fail();
+    } catch (EOFException expected) {
+    }
+  }
+
+  @Test public void readArrayCantOverrunHeaderPayload() throws IOException {
+    bytesIn.set(onlyHeadersPayloadFollowedByData());
+
+    continuation.length = continuation.left = 3;
+    continuation.flags = Http20Draft09.FLAG_END_HEADERS;
+    continuation.streamId = 12345;
+
+    byte[] buff = new byte[3];
     assertEquals(3, continuation.read(buff));
-    assertEquals(0, continuation.bytesLeft);
     assertTrue(Arrays.equals(buff, new byte[] {1, 2, 3}));
 
-    // When there are no bytes left in the last header frame, EOF.
-    Arrays.fill(buff, (byte) -1);
-    continuation.bytesLeft = 0;
-    continuation.endHeaders = true;
-    bytesIn.set(new byte[] {});
     try {
       continuation.read(buff);
       fail();
     } catch (EOFException expected) {
     }
-
-    // When there are no bytes left in this frame, but it isn't the last, read continuation.
-    Arrays.fill(buff, (byte) -1);
-    continuation.bytesLeft = 0;
-    continuation.endHeaders = false; // Read continuation.
-    bytesIn.set(lastContinuationFrame(new byte[] {1, 2, 3}));
-    assertEquals(3, continuation.read(buff));
-    assertTrue(Arrays.equals(buff, new byte[] {1, 2, 3}));
-    assertEquals(0, continuation.bytesLeft);
   }
 
-  static byte[] lastContinuationFrame(byte[] headerBlock) throws IOException {
+  @Test public void readArrayCantOverrunHeaderContinuationPayload() throws IOException {
+    bytesIn.set(headersPayloadWithContinuationFollowedByData());
+
+    continuation.length = continuation.left = 2;
+    continuation.flags = Http20Draft09.FLAG_NONE;
+    continuation.streamId = 12345;
+
+    byte[] buff = new byte[3];
+    assertEquals(3, continuation.read(buff));
+    assertTrue(Arrays.equals(buff, new byte[] {1, 2, 3}));
+
+    try {
+      continuation.read(buff);
+      fail();
+    } catch (EOFException expected) {
+    }
+  }
+
+  static byte[] onlyHeadersPayloadFollowedByData() throws IOException {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     DataOutputStream dataOut = new DataOutputStream(out);
-    dataOut.writeShort(headerBlock.length);
+    dataOut.write(new byte[] {1, 2, 3});
+    dataOut.writeShort(0);
+    dataOut.write(TYPE_DATA);
+    dataOut.write(FLAG_END_STREAM);
+    dataOut.writeInt(0xFFFFFFFF);
+    return out.toByteArray();
+  }
+
+  static byte[] headersPayloadWithContinuationFollowedByData() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+    dataOut.write(new byte[] {1, 2});
+    dataOut.writeShort(1);
     dataOut.write(Http20Draft09.TYPE_CONTINUATION);
     dataOut.write(Http20Draft09.FLAG_END_HEADERS);
-    dataOut.writeInt(0);
-    dataOut.write(headerBlock);
+    dataOut.writeInt(12345);
+    dataOut.write(3);
+    dataOut.writeShort(0);
+    dataOut.write(TYPE_DATA);
+    dataOut.write(FLAG_END_STREAM);
+    dataOut.writeInt(0xFFFFFFFF);
     return out.toByteArray();
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index a7f4cca..8a8aaed 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -35,6 +35,22 @@
 public class Http20Draft09Test {
   static final int expectedStreamId = 15;
 
+  @Test public void unknownFrameTypeIgnored() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    dataOut.writeShort(4); // has a 4-byte field
+    dataOut.write(99); // type 99
+    dataOut.write(0); // no flags
+    dataOut.writeInt(expectedStreamId);
+    dataOut.writeInt(111111111); // custom data
+
+    FrameReader fr = newReader(out);
+
+    // Consume the unknown frame.
+    fr.nextFrame(new BaseTestHandler());
+  }
+
   @Test public void onlyOneLiteralHeadersFrame() throws IOException {
     final List<Header> sentHeaders = headerEntries("name", "value");
 
@@ -47,7 +63,7 @@
       dataOut.writeShort(headerBytes.length);
       dataOut.write(Http20Draft09.TYPE_HEADERS);
       dataOut.write(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_END_STREAM);
-      dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
+      dataOut.writeInt(expectedStreamId & 0x7fffffff);
       dataOut.write(headerBytes);
     }
 
@@ -79,10 +95,10 @@
 
     { // Write the headers frame, specifying priority flag and value.
       byte[] headerBytes = literalHeaders(sentHeaders);
-      dataOut.writeShort(headerBytes.length);
+      dataOut.writeShort(headerBytes.length + 4);
       dataOut.write(Http20Draft09.TYPE_HEADERS);
       dataOut.write(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_PRIORITY);
-      dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
+      dataOut.writeInt(expectedStreamId & 0x7fffffff);
       dataOut.writeInt(0); // Highest priority is 0.
       dataOut.write(headerBytes);
     }
@@ -119,7 +135,7 @@
       dataOut.writeShort(headerBlock.length / 2);
       dataOut.write(Http20Draft09.TYPE_HEADERS);
       dataOut.write(0); // no flags
-      dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
+      dataOut.writeInt(expectedStreamId & 0x7fffffff);
       dataOut.write(headerBlock, 0, headerBlock.length / 2);
     }
 
@@ -127,7 +143,7 @@
       dataOut.writeShort(headerBlock.length / 2);
       dataOut.write(Http20Draft09.TYPE_CONTINUATION);
       dataOut.write(Http20Draft09.FLAG_END_HEADERS);
-      dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
+      dataOut.writeInt(expectedStreamId & 0x7fffffff);
       dataOut.write(headerBlock, headerBlock.length / 2, headerBlock.length / 2);
     }
 
@@ -166,7 +182,7 @@
 
     { // Write the push promise frame, specifying the associated stream ID.
       byte[] headerBytes = literalHeaders(pushPromise);
-      dataOut.writeShort(headerBytes.length);
+      dataOut.writeShort(headerBytes.length + 4);
       dataOut.write(Http20Draft09.TYPE_PUSH_PROMISE);
       dataOut.write(Http20Draft09.FLAG_END_PUSH_PROMISE);
       dataOut.writeInt(expectedStreamId & 0x7fffffff);
@@ -204,7 +220,7 @@
     // Decoding the first header will cross frame boundaries.
     byte[] headerBlock = literalHeaders(pushPromise);
     { // Write the first headers frame.
-      dataOut.writeShort(headerBlock.length / 2);
+      dataOut.writeShort((headerBlock.length / 2) + 4);
       dataOut.write(Http20Draft09.TYPE_PUSH_PROMISE);
       dataOut.write(0); // no flags
       dataOut.writeInt(expectedStreamId & 0x7fffffff);
@@ -240,7 +256,7 @@
     dataOut.writeShort(4);
     dataOut.write(Http20Draft09.TYPE_RST_STREAM);
     dataOut.write(0); // No flags
-    dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
+    dataOut.writeInt(expectedStreamId & 0x7fffffff);
     dataOut.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
 
     FrameReader fr = newReader(out);
@@ -349,7 +365,7 @@
       sendDataFrame(new byte[0x1000000]);
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("FRAME_SIZE_ERROR max size is 16383: 16777216", e.getMessage());
+      assertEquals("FRAME_SIZE_ERROR length > 16383: 16777216", e.getMessage());
     }
   }
 
@@ -384,13 +400,14 @@
       windowUpdate(0);
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 0", e.getMessage());
+      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 0",
+          e.getMessage());
     }
     try {
       windowUpdate(0x80000000L);
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 2147483648",
+      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 2147483648",
           e.getMessage());
     }
   }
@@ -484,7 +501,8 @@
 
   private byte[] sendDataFrame(byte[] data, int offset, int byteCount) throws IOException {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
-    new Http20Draft09.Writer(out, true).sendDataFrame(expectedStreamId, 0, data, offset, byteCount);
+    new Http20Draft09.Writer(out, true).dataFrame(expectedStreamId, Http20Draft09.FLAG_NONE, data,
+        offset, byteCount);
     return out.toByteArray();
   }
 
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index e5335fa..3675bb0 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -57,6 +57,10 @@
     frameCount++;
   }
 
+  public int frameCount() {
+    return frameCount;
+  }
+
   public FrameWriter sendFrame() {
     outFrames.add(new OutFrame(frameCount++, bytesOut.size(), Integer.MAX_VALUE));
     return frameWriter;
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index fbf6560..ceb68dd 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -162,6 +162,17 @@
   }
 
   @Test public void replyWithNoData() throws Exception {
+    MockSpdyPeer.InFrame reply = replyWithNoData(SPDY3);
+    assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
+  }
+
+  @Test public void replyWithNoDataHttp2() throws Exception {
+    MockSpdyPeer.InFrame reply = replyWithNoData(HTTP_20_DRAFT_09);
+    assertEquals(HeadersMode.HTTP_20_HEADERS, reply.headersMode);
+  }
+
+  private MockSpdyPeer.InFrame replyWithNoData(Variant variant) throws Exception {
+    MockSpdyPeer peer = new MockSpdyPeer(variant, false);
     // write the mocking script
     peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
@@ -175,15 +186,15 @@
         receiveCount.incrementAndGet();
       }
     };
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(handler).build();
+    connectionBuilder(peer, variant).handler(handler).build();
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame reply = peer.takeFrame();
     assertEquals(TYPE_HEADERS, reply.type);
-    assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
     assertTrue(reply.inFinished);
     assertEquals(headerEntries("b", "banana"), reply.headerBlock);
     assertEquals(1, receiveCount.get());
+    return reply;
   }
 
   @Test public void noop() throws Exception {
@@ -1056,6 +1067,66 @@
     }
   }
 
+  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdate() throws Exception {
+    serverSendsEmptyDataClientDoesntSendWindowUpdate(SPDY3);
+  }
+
+  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdateHttp2() throws Exception {
+    serverSendsEmptyDataClientDoesntSendWindowUpdate(HTTP_20_DRAFT_09);
+  }
+
+  private void serverSendsEmptyDataClientDoesntSendWindowUpdate(Variant variant)
+      throws IOException, InterruptedException {
+    MockSpdyPeer peer = new MockSpdyPeer(variant, false);
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 1, new byte[0]);
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, variant);
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    assertEquals(-1, client.getInputStream().read());
+
+    // Verify the peer received what was expected.
+    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    assertEquals(3, peer.frameCount());
+  }
+
+  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
+    clientSendsEmptyDataServerDoesntSendWindowUpdate(SPDY3);
+  }
+
+  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
+    clientSendsEmptyDataServerDoesntSendWindowUpdate(HTTP_20_DRAFT_09);
+  }
+
+  private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
+      throws IOException, InterruptedException {
+    MockSpdyPeer peer = new MockSpdyPeer(variant, false);
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, variant);
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals(0, client.getInputStream().available());
+    client.getOutputStream().write(Util.EMPTY_BYTE_ARRAY);
+    client.getOutputStream().flush();
+    client.getOutputStream().close();
+
+    // Verify the peer received what was expected.
+    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    assertEquals(2, peer.frameCount());
+  }
+
   @Test public void writeAwaitsWindowUpdate() throws Exception {
     int windowSize = 65535;
 
@@ -1215,9 +1286,12 @@
   }
 
   private SpdyConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
-    return new SpdyConnection.Builder(true, peer.openSocket())
-        .protocol(variant.getProtocol())
-        .handler(REJECT_INCOMING_STREAMS).build();
+    return connectionBuilder(peer, variant).handler(REJECT_INCOMING_STREAMS).build();
+  }
+
+  private SpdyConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
+      throws IOException {
+    return new SpdyConnection.Builder(true, peer.openSocket()).protocol(variant.getProtocol());
   }
 
   private void writeAndClose(SpdyStream stream, String data) throws IOException {
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index 7b9eb8d..1179702 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -76,6 +76,7 @@
 import org.junit.Ignore;
 import org.junit.Test;
 
+import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
@@ -2527,6 +2528,71 @@
     assertTrue(call, call.contains("challenges=[Basic realm=\"protected area\"]"));
   }
 
+  @Test public void npnSetsProtocolHeader_SPDY_3() throws Exception {
+    npnSetsProtocolHeader(Protocol.SPDY_3);
+  }
+
+  @Test public void npnSetsProtocolHeader_HTTP_2() throws Exception {
+    npnSetsProtocolHeader(Protocol.HTTP_2);
+  }
+
+  private void npnSetsProtocolHeader(Protocol protocol) throws IOException {
+    enableNpn(protocol);
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+    client.setProtocols(Arrays.asList(Protocol.HTTP_11, protocol));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+    assertEquals(Arrays.asList(protocol.name.utf8()), protocolValues);
+    assertContent("A", connection);
+  }
+
+  /** For example, empty Protobuf RPC messages end up as a zero-length POST. */
+  @Test public void zeroLengthPost() throws IOException, InterruptedException {
+    zeroLengthPayload("POST");
+  }
+
+  @Test public void zeroLengthPost_SPDY_3() throws Exception {
+    enableNpn(Protocol.SPDY_3);
+    zeroLengthPost();
+  }
+
+  @Test public void zeroLengthPost_HTTP_2() throws Exception {
+    enableNpn(Protocol.HTTP_2);
+    zeroLengthPost();
+  }
+
+  /** For example, creating an Amazon S3 bucket ends up as a zero-length POST. */
+  @Test public void zeroLengthPut() throws IOException, InterruptedException {
+    zeroLengthPayload("PUT");
+  }
+
+  @Test public void zeroLengthPut_SPDY_3() throws Exception {
+    enableNpn(Protocol.SPDY_3);
+    zeroLengthPut();
+  }
+
+  @Test public void zeroLengthPut_HTTP_2() throws Exception {
+    enableNpn(Protocol.HTTP_2);
+    zeroLengthPut();
+  }
+
+  private void zeroLengthPayload(String method)
+      throws IOException, InterruptedException {
+    server.enqueue(new MockResponse());
+    server.play();
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection.setRequestProperty("Content-Length", "0");
+    connection.setRequestMethod(method);
+    connection.setFixedLengthStreamingMode(0);
+    connection.setDoOutput(true);
+    assertContent("", connection);
+    RecordedRequest zeroLengthPayload = server.takeRequest();
+    assertEquals(method, zeroLengthPayload.getMethod());
+    assertEquals("0", zeroLengthPayload.getHeader("content-length"));
+    assertEquals(0L, zeroLengthPayload.getBodySize());
+  }
+
   @Test public void setProtocols() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
@@ -2772,4 +2838,16 @@
     @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
     }
   }
+
+  /**
+   * Tests that use this will fail unless boot classpath is set. Ex. {@code
+   * -Xbootclasspath/p:/tmp/npn-boot-8.1.2.v20120308.jar}
+   */
+  private void enableNpn(Protocol protocol) {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.setNpnEnabled(true);
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_11));
+  }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index b5e143a..29342ad 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -21,6 +21,7 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.InterruptedIOException;
 import java.io.OutputStream;
 import java.net.Socket;
 import java.util.HashMap;
@@ -81,6 +82,12 @@
   private Map<Integer, Ping> pings;
   private int nextPingId;
 
+  /**
+   * Count of bytes that can be written on the connection before receiving a
+   * window update.
+   */
+  private long bytesLeftInWriteWindow = 65535; // TODO: initialize this with settings.
+
   // TODO: Do we want to dynamically adjust settings, or KISS and only set once?
   // Settings we might send include toggling push, adjusting compression table size.
   final Settings okHttpSettings;
@@ -209,9 +216,24 @@
 
   public void writeData(int streamId, boolean outFinished, byte[] buffer, int offset, int byteCount)
       throws IOException {
+    synchronized (SpdyConnection.this) {
+      waitUntilWritable(byteCount);
+      bytesLeftInWriteWindow -= byteCount;
+    }
     frameWriter.data(outFinished, streamId, buffer, offset, byteCount);
   }
 
+  /** Returns once the peer is ready to receive {@code byteCount} bytes. */
+  private void waitUntilWritable(int byteCount) throws IOException {
+    try {
+      while (byteCount > bytesLeftInWriteWindow) {
+        SpdyConnection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
+      }
+    } catch (InterruptedException e) {
+      throw new InterruptedIOException();
+    }
+  }
+
   void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
     executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
       @Override public void execute() {
@@ -622,14 +644,16 @@
 
     @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
       if (streamId == 0) {
-        // TODO: honor connection-level flow control
-        return;
-      }
-
-      // TODO: honor endFlowControl
-      SpdyStream stream = getStream(streamId);
-      if (stream != null) {
-        stream.receiveWindowUpdate(windowSizeIncrement);
+        synchronized (SpdyConnection.this) {
+          bytesLeftInWriteWindow += windowSizeIncrement;
+          notifyAll();
+        }
+      } else {
+        // TODO: honor endFlowControl
+        SpdyStream stream = getStream(streamId);
+        if (stream != null) {
+          stream.receiveWindowUpdate(windowSizeIncrement);
+        }
       }
     }
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java
index f57361e..dbd4499 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java
@@ -26,7 +26,7 @@
  * <a href="http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04">NPN</a> or
  * <a href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> selection.
  *
- * <p/>
+ * <p>
  * <h3>Protocol vs Scheme</h3>
  * Despite its name, {@link java.net.URL#getProtocol()} returns the
  * {@link java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
index f02a2ca..7b54b29 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -44,7 +44,7 @@
  * <h3>ALPN and NPN</h3>
  * This class uses TLS extensions ALPN and NPN to negotiate the upgrade from
  * HTTP/1.1 (the default protocol to use with TLS on port 443) to either SPDY
- * or HTTP/2.0.
+ * or HTTP/2.
  *
  * <p>NPN (Next Protocol Negotiation) was developed for SPDY. It is widely
  * available and we support it on both Android (4.1+) and OpenJDK 7 (via the
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
index 36e2e15..50568bb 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -21,7 +21,7 @@
 import java.io.InputStream;
 import java.util.List;
 
-/** Reads transport frames for SPDY/3 or HTTP/2.0. */
+/** Reads transport frames for SPDY/3 or HTTP/2. */
 public interface FrameReader extends Closeable {
   void readConnectionHeader() throws IOException;
   boolean nextFrame(Handler handler) throws IOException;
@@ -32,7 +32,7 @@
     /**
      * Create or update incoming headers, creating the corresponding streams
      * if necessary. Frames that trigger this are SPDY SYN_STREAM, HEADERS, and
-     * SYN_REPLY, and HTTP/2.0 HEADERS and PUSH_PROMISE.
+     * SYN_REPLY, and HTTP/2 HEADERS and PUSH_PROMISE.
      *
      * @param outFinished true if the receiver should not send further frames.
      * @param inFinished true if the sender will not send further frames.
@@ -40,23 +40,28 @@
      * @param associatedStreamId the stream that triggered the sender to create
      * this stream.
      * @param priority or -1 for no priority. For SPDY, priorities range from 0
-     * (highest) thru 7 (lowest). For HTTP/2.0, priorities range from 0
+     * (highest) thru 7 (lowest). For HTTP/2, priorities range from 0
      * (highest) thru 2^31-1 (lowest), defaulting to 2^30.
      */
     void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
         int priority, List<Header> headerBlock, HeadersMode headersMode);
     void rstStream(int streamId, ErrorCode errorCode);
     void settings(boolean clearPrevious, Settings settings);
+
+    /** HTTP/2 only. */
+    void ackSettings();
+
+    /** SPDY/3 only. */
     void noop();
 
     /**
      *  Read a connection-level ping from the peer.  {@code ack} indicates this
      *  is a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
-     *  <p/>
+     *  <p>
      *  In SPDY/3, only the first {@code payload1} parameter is set.  If the
      *  reader is a client, it is an unsigned even number.  Likewise, a server
      *  will receive an odd number.
-     *  <p/>
+     *  <p>
      *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
      *  set. The data is opaque binary, and there are no rules on the content.
      */
@@ -84,7 +89,7 @@
 
     /**
      * HTTP/2 only. Receive a push promise header block.
-     * <p/>
+     * <p>
      * A push promise contains all the headers that pertain to a server-initiated
      * request, and a {@code promisedStreamId} to which response frames will be
      * delivered. Push promise frames are sent as a part of the response to
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
index e508c96..b7182a6 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -20,15 +20,15 @@
 import java.io.IOException;
 import java.util.List;
 
-/** Writes transport frames for SPDY/3 or HTTP/2.0. */
+/** Writes transport frames for SPDY/3 or HTTP/2. */
 public interface FrameWriter extends Closeable {
-  /** HTTP/2.0 only. */
+  /** HTTP/2 only. */
   void connectionHeader() throws IOException;
   void ackSettings() throws IOException;
 
   /**
    * HTTP/2 only. Send a push promise header block.
-   * <p/>
+   * <p>
    * A push promise contains all the headers that pertain to a server-initiated
    * request, and a {@code promisedStreamId} to which response frames will be
    * delivered. Push promise frames are sent as a part of the response to
@@ -68,16 +68,18 @@
 
   /** Write okhttp's settings to the peer. */
   void settings(Settings okHttpSettings) throws IOException;
+
+  /** SPDY/3 only. */
   void noop() throws IOException;
 
   /**
    *  Send a connection-level ping to the peer.  {@code ack} indicates this is
    *  a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
-   *  <p/>
+   *  <p>
    *  In SPDY/3, only the first {@code payload1} parameter is sent.  If the
    *  sender is a client, it is an unsigned odd number.  Likewise, a server
    *  will send an even number.
-   *  <p/>
+   *  <p>
    *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
    *  sent.  The data is opaque binary, and there are no rules on the content.
    */
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index 87ba091..c134932 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -132,7 +132,7 @@
 
     /**
      * Called by the reader when the peer sent a new header table size setting.
-     * <p/>
+     * <p>
      * Evicts entries or clears the table as needed.
      */
     void maxHeaderTableByteCount(int newMaxHeaderTableByteCount) {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index ada0d6b..eb0f3f6 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -37,17 +37,6 @@
     return Protocol.HTTP_2;
   }
 
-  // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-6.5
-  static Settings defaultSettings(boolean client) {
-    Settings settings = new Settings();
-    settings.set(Settings.HEADER_TABLE_SIZE, 0, 4096);
-    if (client) { // client specifies whether or not it accepts push.
-      settings.set(Settings.ENABLE_PUSH, 0, 1);
-    }
-    settings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
-    return settings;
-  }
-
   private static final byte[] CONNECTION_HEADER =
       "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n".getBytes(Util.UTF_8);
 
@@ -225,12 +214,14 @@
 
     private void readSettings(Handler handler, short length, byte flags, int streamId)
         throws IOException {
+      if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
       if ((flags & FLAG_ACK) != 0) {
         if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
+        handler.ackSettings();
+        return;
       }
 
       if (length % 8 != 0) throw ioException("TYPE_SETTINGS length %% 8 != 0: %s", length);
-      if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
       Settings settings = new Settings();
       for (int i = 0; i < length; i += 8) {
         int w1 = in.readInt();
@@ -348,8 +339,7 @@
 
     @Override
     public synchronized void pushPromise(int streamId, int promisedStreamId,
-        List<Header> requestHeaders)
-        throws IOException {
+        List<Header> requestHeaders) throws IOException {
       hpackBuffer.reset();
       hpackWriter.writeHeaders(requestHeaders);
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index e20c9d7..99411b0 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -36,12 +36,6 @@
     return Protocol.SPDY_3;
   }
 
-  static Settings defaultSettings(boolean client) {
-    Settings settings = new Settings();
-    settings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
-    return settings;
-  }
-
   static final int TYPE_DATA = 0x0;
   static final int TYPE_SYN_STREAM = 0x1;
   static final int TYPE_SYN_REPLY = 0x2;
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index 29342ad..f9226e3 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -83,19 +83,29 @@
   private int nextPingId;
 
   /**
+   * Initial window size to use for the connection and new streams.  Until the
+   * peer sends an update, this will is initialized to {@code 65535}.
+   */
+  int initialWindowSize = 65535;
+
+  /**
    * Count of bytes that can be written on the connection before receiving a
    * window update.
    */
-  private long bytesLeftInWriteWindow = 65535; // TODO: initialize this with settings.
+  // Visible for testing
+  long bytesLeftInWriteWindow = initialWindowSize;
 
   // TODO: Do we want to dynamically adjust settings, or KISS and only set once?
   // Settings we might send include toggling push, adjusting compression table size.
   final Settings okHttpSettings;
   // TODO: MWS will need to guard on this setting before attempting to push.
   final Settings peerSettings;
+  private boolean receivedInitialPeerSettings = false;
   final FrameReader frameReader;
   final FrameWriter frameWriter;
 
+  // Visible for testing
+  final Reader readerRunnable;
   final ByteArrayPool bufferPool;
 
   private SpdyConnection(Builder builder) {
@@ -108,23 +118,22 @@
 
     Variant variant;
     if (protocol == Protocol.HTTP_2) {
-      okHttpSettings = Http20Draft09.defaultSettings(client);
-      variant = new Http20Draft09(); // connection-specific settings here!
+      variant = new Http20Draft09();
     } else if (protocol == Protocol.SPDY_3) {
-      okHttpSettings = Spdy3.defaultSettings(client);
-      variant = new Spdy3(); // connection-specific settings here!
+      variant = new Spdy3();
     } else {
       throw new AssertionError(protocol);
     }
-
+    okHttpSettings = new Settings();
+    peerSettings = new Settings();
     // TODO: implement stream limit
     // okHttpSettings.set(Settings.MAX_CONCURRENT_STREAMS, 0, max);
-    peerSettings = okHttpSettings;
     bufferPool = new ByteArrayPool(peerSettings.getInitialWindowSize() * 8);
     frameReader = variant.newReader(builder.in, client);
     frameWriter = variant.newWriter(builder.out, client);
 
-    new Thread(new Reader()).start(); // Not a daemon thread.
+    readerRunnable = new Reader();
+    new Thread(readerRunnable).start(); // Not a daemon thread.
   }
 
   /** The protocol as selected using NPN or ALPN. */
@@ -195,7 +204,7 @@
         streamId = nextStreamId;
         nextStreamId += 2;
         stream = new SpdyStream(
-            streamId, this, outFinished, inFinished, priority, requestHeaders, peerSettings);
+            streamId, this, outFinished, inFinished, priority, requestHeaders, initialWindowSize);
         if (stream.isOpen()) {
           streams.put(streamId, stream);
           setIdle(false);
@@ -234,6 +243,15 @@
     }
   }
 
+  /**
+   * {@code delta} will be negative if a settings frame initial window is
+   * smaller than the last.
+   */
+  void addBytesToWriteWindow(long delta) {
+    bytesLeftInWriteWindow += delta;
+    if (delta > 0) SpdyConnection.this.notifyAll();
+  }
+
   void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
     executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
       @Override public void execute() {
@@ -468,7 +486,7 @@
     }
   }
 
-  private class Reader extends NamedRunnable implements FrameReader.Handler {
+  class Reader extends NamedRunnable implements FrameReader.Handler {
     private Reader() {
       super("OkHttp %s", hostName);
     }
@@ -531,7 +549,7 @@
 
           // Create a stream.
           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,
-              inFinished, priority, headerBlock, peerSettings);
+              inFinished, priority, headerBlock, initialWindowSize);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
           executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
@@ -577,6 +595,15 @@
         if (getProtocol() == Protocol.HTTP_2) {
           ackSettingsLater();
         }
+        int peerInitialWindowSize = peerSettings.getInitialWindowSize();
+        if (peerInitialWindowSize != -1 && peerInitialWindowSize != initialWindowSize) {
+          long delta = peerInitialWindowSize - initialWindowSize;
+          SpdyConnection.this.initialWindowSize = peerInitialWindowSize;
+          if (!receivedInitialPeerSettings) {
+            addBytesToWriteWindow(delta);
+            receivedInitialPeerSettings = true;
+          }
+        }
         if (!streams.isEmpty()) {
           streamsToNotify = streams.values().toArray(new SpdyStream[streams.size()]);
         }
@@ -607,6 +634,10 @@
       });
     }
 
+    @Override public void ackSettings() {
+      // TODO: If we don't get this callback after sending settings to the peer, SETTINGS_TIMEOUT.
+    }
+
     @Override public void noop() {
     }
 
@@ -646,7 +677,7 @@
       if (streamId == 0) {
         synchronized (SpdyConnection.this) {
           bytesLeftInWriteWindow += windowSizeIncrement;
-          notifyAll();
+          SpdyConnection.this.notifyAll();
         }
       } else {
         // TODO: honor endFlowControl
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index 68ab921..7336f1d 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -55,7 +55,7 @@
   private List<Header> responseHeaders;
 
   private final SpdyDataInputStream in;
-  private final SpdyDataOutputStream out;
+  final SpdyDataOutputStream out;
 
   /**
    * The reason why this stream was abnormally closed. If there are multiple
@@ -65,18 +65,19 @@
   private ErrorCode errorCode = null;
 
   SpdyStream(int id, SpdyConnection connection, boolean outFinished, boolean inFinished,
-      int priority, List<Header> requestHeaders, Settings peerSettings) {
+      int priority, List<Header> requestHeaders, int initialWriteWindow) {
     if (connection == null) throw new NullPointerException("connection == null");
     if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
     this.id = id;
     this.connection = connection;
-    this.in = new SpdyDataInputStream(peerSettings.getInitialWindowSize());
+    this.writeWindowSize = initialWriteWindow;
+    this.windowUpdateThreshold = initialWriteWindow / 2;
+    this.in = new SpdyDataInputStream(initialWriteWindow);
     this.out = new SpdyDataOutputStream();
     this.in.finished = inFinished;
     this.out.finished = outFinished;
     this.priority = priority;
     this.requestHeaders = requestHeaders;
-    setPeerSettings(peerSettings);
   }
 
   /**
@@ -311,11 +312,13 @@
   }
 
   private void setPeerSettings(Settings peerSettings) {
-    // TODO: For HTTP/2.0, also adjust the stream flow control window size
+    // TODO: For HTTP/2, also adjust the stream flow control window size
     // by the difference between the new value and the old value.
     assert (Thread.holdsLock(connection)); // Because 'settings' is guarded by 'connection'.
+    long delta = peerSettings.getInitialWindowSize() - writeWindowSize;
     this.writeWindowSize = peerSettings.getInitialWindowSize();
     this.windowUpdateThreshold = peerSettings.getInitialWindowSize() / 2;
+    receiveWindowUpdate(delta);
   }
 
   /** Notification received when peer settings change. */
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
index dc08d2f..3b6a1be 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
@@ -41,6 +41,10 @@
     fail();
   }
 
+  @Override public void ackSettings() {
+    fail();
+  }
+
   @Override public void noop() {
     fail();
   }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index 3675bb0..401020b 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -210,6 +210,12 @@
       this.settings = settings;
     }
 
+    @Override public void ackSettings() {
+      if (this.type != -1) throw new IllegalStateException();
+      this.type = Spdy3.TYPE_SETTINGS;
+      this.ack = true;
+    }
+
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
         int associatedStreamId, int priority, List<Header> headerBlock,
         HeadersMode headersMode) {
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index ceb68dd..1d1e5e2 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -290,6 +290,41 @@
     assertFalse(pingFrame.ack);
   }
 
+  @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
+    boolean client = false; // Peer is server, so we are client.
+    Settings initial = new Settings();
+    initial.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 1684);
+    Settings shouldntImpactConnection = new Settings();
+    shouldntImpactConnection.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 3368);
+
+    MockSpdyPeer peer = new MockSpdyPeer(HTTP_20_DRAFT_09, client);
+    peer.sendFrame().settings(initial);
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().settings(shouldntImpactConnection);
+    peer.acceptFrame(); // ACK 2
+    peer.acceptFrame(); // HEADERS
+    peer.play();
+
+    SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
+
+    // verify the peer received the ACK
+    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+    ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+
+    // This stream was created *after* the connection settings were adjusted.
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+
+    assertEquals(3368, connection.initialWindowSize);
+    assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
+    assertEquals(1684, stream.windowUpdateThreshold);
+  }
+
   @Test public void unexpectedPingIsNotReturned() throws Exception {
     // write the mocking script
     peer.sendFrame().ping(false, 2, 0);
@@ -327,7 +362,7 @@
 
   @Test public void peerHttp2ClientDisablesPush() throws Exception {
     boolean client = false; // Peer is client, so we are server.
-    Settings settings = Http20Draft09.defaultSettings(client);
+    Settings settings = new Settings();
     settings.set(Settings.ENABLE_PUSH, 0, 0); // The peer client disables push.
 
     SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
@@ -1276,11 +1311,10 @@
     SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
 
     // verify the peer received the ACK
-    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
-    assertEquals(TYPE_SETTINGS, pingFrame.type);
-    assertEquals(0, pingFrame.streamId);
-    // TODO: check for ACK flag.
-    assertEquals(0, pingFrame.settings.size());
+    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
     peer.close();
     return connection;
   }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index 0a95a0d..cb9e353 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -191,7 +191,7 @@
 
     /**
      * Returns true if further data from this response body should be read at
-     * this time. For asynchronous protocols like SPDY and HTTP/2.0, this will
+     * this time. For asynchronous protocols like SPDY and HTTP/2, this will
      * return false once all locally-available body bytes have been read.
      *
      * <p>Clients with many concurrent downloads can use this method to reduce
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index f9226e3..b784392 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -128,7 +128,7 @@
     peerSettings = new Settings();
     // TODO: implement stream limit
     // okHttpSettings.set(Settings.MAX_CONCURRENT_STREAMS, 0, max);
-    bufferPool = new ByteArrayPool(peerSettings.getInitialWindowSize() * 8);
+    bufferPool = new ByteArrayPool(initialWindowSize * 8); // TODO: revisit size limit!
     frameReader = variant.newReader(builder.in, client);
     frameWriter = variant.newWriter(builder.out, client);
 
@@ -149,7 +149,7 @@
     return streams.size();
   }
 
-  private synchronized SpdyStream getStream(int id) {
+  synchronized SpdyStream getStream(int id) {
     return streams.get(id);
   }
 
@@ -223,8 +223,27 @@
     frameWriter.synReply(outFinished, streamId, alternating);
   }
 
+  /**
+   * Callers of this method are not thread safe, and sometimes on application
+   * threads.  Most often, this method will be called to send a buffer worth of
+   * data to the peer.
+   * <p>
+   * Writes are subject to the write window of the stream and the connection.
+   * Until there is a window sufficient to send {@code byteCount}, the caller
+   * will block.  For example, a user of {@code HttpURLConnection} who flushes
+   * more bytes to the output stream than the connection's write window will
+   * block.
+   * <p>
+   * Zero {@code byteCount} writes are not subject to flow control and
+   * will not block.  The only use case for zero {@code byteCount} is closing
+   * a flushed output stream.
+   */
   public void writeData(int streamId, boolean outFinished, byte[] buffer, int offset, int byteCount)
       throws IOException {
+    if (byteCount == 0) { // Empty data frames are not flow-controlled.
+      frameWriter.data(outFinished, streamId, buffer, offset, byteCount);
+      return;
+    }
     synchronized (SpdyConnection.this) {
       waitUntilWritable(byteCount);
       bytesLeftInWriteWindow -= byteCount;
@@ -267,21 +286,17 @@
     frameWriter.rstStream(streamId, statusCode);
   }
 
-  void writeWindowUpdateLater(final int streamId, final int windowSizeIncrement) {
+  void writeWindowUpdateLater(final int streamId, final long windowSizeIncrement) {
     executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
       @Override public void execute() {
         try {
-          writeWindowUpdate(streamId, windowSizeIncrement);
+          frameWriter.windowUpdate(streamId, windowSizeIncrement);
         } catch (IOException ignored) {
         }
       }
     });
   }
 
-  void writeWindowUpdate(int streamId, int windowSizeIncrement) throws IOException {
-    frameWriter.windowUpdate(streamId, windowSizeIncrement);
-  }
-
   /**
    * Sends a ping frame to the peer. Use the returned object to await the
    * ping's response and observe its round trip time.
@@ -486,6 +501,10 @@
     }
   }
 
+  /**
+   * Methods in this class must not lock FrameWriter.  If a method needs to
+   * write a frame, create an async task to do so.
+   */
   class Reader extends NamedRunnable implements FrameReader.Handler {
     private Reader() {
       super("OkHttp %s", hostName);
@@ -585,6 +604,7 @@
     }
 
     @Override public void settings(boolean clearPrevious, Settings newSettings) {
+      long delta = 0;
       SpdyStream[] streamsToNotify = null;
       synchronized (SpdyConnection.this) {
         if (clearPrevious) {
@@ -597,27 +617,21 @@
         }
         int peerInitialWindowSize = peerSettings.getInitialWindowSize();
         if (peerInitialWindowSize != -1 && peerInitialWindowSize != initialWindowSize) {
-          long delta = peerInitialWindowSize - initialWindowSize;
+          delta = peerInitialWindowSize - initialWindowSize;
           SpdyConnection.this.initialWindowSize = peerInitialWindowSize;
           if (!receivedInitialPeerSettings) {
             addBytesToWriteWindow(delta);
             receivedInitialPeerSettings = true;
           }
-        }
-        if (!streams.isEmpty()) {
-          streamsToNotify = streams.values().toArray(new SpdyStream[streams.size()]);
+          if (!streams.isEmpty()) {
+            streamsToNotify = streams.values().toArray(new SpdyStream[streams.size()]);
+          }
         }
       }
-      if (streamsToNotify != null) {
-        for (SpdyStream stream : streamsToNotify) {
-          // The synchronization here is ugly. We need to synchronize on 'this' to guard
-          // reads to 'peerSettings'. We synchronize on 'stream' to guard the state change.
-          // And we need to acquire the 'stream' lock first, since that may block.
-          // TODO: this can block the reader thread until a write completes. That's bad!
+      if (streamsToNotify != null && delta != 0) {
+        for (SpdyStream stream : streams.values()) {
           synchronized (stream) {
-            synchronized (SpdyConnection.this) {
-              stream.receiveSettings(peerSettings);
-            }
+            stream.addBytesToWriteWindow(delta);
           }
         }
       }
@@ -653,8 +667,7 @@
       }
     }
 
-    @Override
-    public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
       if (debugData.length > 0) { // TODO: log the debugData
       }
       synchronized (SpdyConnection.this) {
@@ -680,10 +693,11 @@
           SpdyConnection.this.notifyAll();
         }
       } else {
-        // TODO: honor endFlowControl
         SpdyStream stream = getStream(streamId);
         if (stream != null) {
-          stream.receiveWindowUpdate(windowSizeIncrement);
+          synchronized (stream) {
+            stream.addBytesToWriteWindow(windowSizeIncrement);
+          }
         }
       }
     }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index 7336f1d..c8ac6d9 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -41,7 +41,14 @@
    * stream. (Chrome 25 uses 5 MiB.)
    */
   int windowUpdateThreshold;
-  private int writeWindowSize;
+
+  /**
+   * Count of bytes that can be written on the stream before receiving a
+   * window update. Even if this is positive, writes will block until there
+   * available bytes in {@code connection.bytesLeftInWriteWindow}.
+   */
+  // guarded by this
+  long bytesLeftInWriteWindow = 0;
 
   private final int id;
   private final SpdyConnection connection;
@@ -70,7 +77,7 @@
     if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
     this.id = id;
     this.connection = connection;
-    this.writeWindowSize = initialWriteWindow;
+    this.bytesLeftInWriteWindow = initialWriteWindow;
     this.windowUpdateThreshold = initialWriteWindow / 2;
     this.in = new SpdyDataInputStream(initialWriteWindow);
     this.out = new SpdyDataOutputStream();
@@ -311,28 +318,6 @@
     }
   }
 
-  private void setPeerSettings(Settings peerSettings) {
-    // TODO: For HTTP/2, also adjust the stream flow control window size
-    // by the difference between the new value and the old value.
-    assert (Thread.holdsLock(connection)); // Because 'settings' is guarded by 'connection'.
-    long delta = peerSettings.getInitialWindowSize() - writeWindowSize;
-    this.writeWindowSize = peerSettings.getInitialWindowSize();
-    this.windowUpdateThreshold = peerSettings.getInitialWindowSize() / 2;
-    receiveWindowUpdate(delta);
-  }
-
-  /** Notification received when peer settings change. */
-  void receiveSettings(Settings peerSettings) {
-    assert (Thread.holdsLock(this));
-    setPeerSettings(peerSettings);
-    notifyAll();
-  }
-
-  synchronized void receiveWindowUpdate(long windowSizeIncrement) {
-    out.unacknowledgedBytes -= windowSizeIncrement;
-    notifyAll();
-  }
-
   int getPriority() {
     return priority;
   }
@@ -579,7 +564,7 @@
    * An output stream that writes outgoing data frames of a stream. This class
    * is not thread safe.
    */
-  private final class SpdyDataOutputStream extends OutputStream {
+  final class SpdyDataOutputStream extends OutputStream {
     private final byte[] buffer = SpdyStream.this.connection.bufferPool.getBuf(OUTPUT_BUFFER_SIZE);
     private int pos = 0;
 
@@ -592,13 +577,6 @@
      */
     private boolean finished;
 
-    /**
-     * The total number of bytes written out to the peer, but not yet
-     * acknowledged with an incoming {@code WINDOW_UPDATE} frame. Writes
-     * block if they cause this to exceed the {@code WINDOW_SIZE}.
-     */
-    private long unacknowledgedBytes = 0;
-
     @Override public void write(int b) throws IOException {
       Util.writeSingleByte(this, b);
     }
@@ -606,11 +584,13 @@
     @Override public void write(byte[] bytes, int offset, int count) throws IOException {
       assert (!Thread.holdsLock(SpdyStream.this));
       checkOffsetAndCount(bytes.length, offset, count);
-      checkNotClosed();
+      synchronized (SpdyStream.this) {
+        checkOutNotClosed();
+      }
 
       while (count > 0) {
         if (pos == buffer.length) {
-          writeFrame(false);
+          writeFrame();
         }
         int bytesToCopy = Math.min(count, buffer.length - pos);
         System.arraycopy(bytes, offset, buffer, pos, bytesToCopy);
@@ -622,9 +602,11 @@
 
     @Override public void flush() throws IOException {
       assert (!Thread.holdsLock(SpdyStream.this));
-      checkNotClosed();
+      synchronized (SpdyStream.this) {
+        checkOutNotClosed();
+      }
       if (pos > 0) {
-        writeFrame(false);
+        writeFrame();
         connection.flush();
       }
     }
@@ -639,59 +621,53 @@
         SpdyStream.this.connection.bufferPool.returnBuf(buffer);
       }
       if (!out.finished) {
-        writeFrame(true);
+        connection.writeData(id, true, buffer, 0, pos);
       }
       connection.flush();
       cancelStreamIfNecessary();
     }
 
-    private void writeFrame(boolean outFinished) throws IOException {
+    private void writeFrame() throws IOException {
       assert (!Thread.holdsLock(SpdyStream.this));
 
       int length = pos;
       synchronized (SpdyStream.this) {
-        waitUntilWritable(length, outFinished);
-        unacknowledgedBytes += length;
+        waitUntilWritable(length);
+        checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
+        bytesLeftInWriteWindow -= length;
       }
-      connection.writeData(id, outFinished, buffer, 0, pos);
+      connection.writeData(id, false, buffer, 0, pos);
       pos = 0;
     }
+  }
 
-    /**
-     * Returns once the peer is ready to receive {@code count} bytes.
-     *
-     * @throws IOException if the stream was finished or closed, or the
-     * thread was interrupted.
-     */
-    private void waitUntilWritable(int count, boolean last) throws IOException {
-      try {
-        while (unacknowledgedBytes + count >= writeWindowSize) {
-          SpdyStream.this.wait(); // Wait until we receive a WINDOW_UPDATE.
-
-          // The stream may have been closed or reset while we were waiting!
-          if (!last && closed) {
-            throw new IOException("stream closed");
-          } else if (finished) {
-            throw new IOException("stream finished");
-          } else if (errorCode != null) {
-            throw new IOException("stream was reset: " + errorCode);
-          }
-        }
-      } catch (InterruptedException e) {
-        throw new InterruptedIOException();
+  /** Returns once the peer is ready to receive {@code byteCount} bytes. */
+  private void waitUntilWritable(int byteCount) throws IOException {
+    try {
+      while (byteCount > bytesLeftInWriteWindow) {
+        SpdyStream.this.wait(); // Wait until we receive a WINDOW_UPDATE.
       }
+    } catch (InterruptedException e) {
+      throw new InterruptedIOException();
     }
+  }
 
-    private void checkNotClosed() throws IOException {
-      synchronized (SpdyStream.this) {
-        if (closed) {
-          throw new IOException("stream closed");
-        } else if (finished) {
-          throw new IOException("stream finished");
-        } else if (errorCode != null) {
-          throw new IOException("stream was reset: " + errorCode);
-        }
-      }
+  /**
+   * {@code delta} will be negative if a settings frame initial window is
+   * smaller than the last.
+   */
+  void addBytesToWriteWindow(long delta) {
+    bytesLeftInWriteWindow += delta;
+    if (delta > 0) SpdyStream.this.notifyAll();
+  }
+
+  private void checkOutNotClosed() throws IOException {
+    if (out.closed) {
+      throw new IOException("stream closed");
+    } else if (out.finished) {
+      throw new IOException("stream finished");
+    } else if (errorCode != null) {
+      throw new IOException("stream was reset: " + errorCode);
     }
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index 1d1e5e2..52169a5 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -322,7 +322,8 @@
 
     assertEquals(3368, connection.initialWindowSize);
     assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
-    assertEquals(1684, stream.windowUpdateThreshold);
+    // New Stream is has the most recent initial window size.
+    assertEquals(3368, stream.bytesLeftInWriteWindow);
   }
 
   @Test public void unexpectedPingIsNotReturned() throws Exception {
@@ -1177,13 +1178,8 @@
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     OutputStream out = stream.getOutputStream();
     out.write(new byte[windowSize]);
-    interruptAfterDelay(500);
-    try {
-      out.write('a');
-      out.flush();
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
+    out.write('a');
+    assertFlushBlocks(out);
 
     // Verify the peer received what was expected.
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
@@ -1192,6 +1188,56 @@
     assertEquals(TYPE_DATA, data.type);
   }
 
+  @Test public void initialSettingsWithWindowSizeAdjustsConnection() throws Exception {
+    int initialWindowSize = 65535;
+    int framesThatFillWindow = roundUp(initialWindowSize, SpdyStream.OUTPUT_BUFFER_SIZE);
+
+    // Write the mocking script. This accepts more data frames than necessary!
+    peer.acceptFrame(); // SYN_STREAM
+    for (int i = 0; i < framesThatFillWindow; i++) {
+      peer.acceptFrame(); // DATA on stream 1
+    }
+    peer.acceptFrame(); // DATA on stream 2
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyStream stream = connection.newStream(headerEntries("a", "apple"), true, true);
+    OutputStream out = stream.getOutputStream();
+    out.write(new byte[initialWindowSize]);
+    out.flush();
+
+    // write 1 more than the window size
+    out.write('a');
+    assertFlushBlocks(out);
+
+    // Check that we've filled the window for both the stream and also the connection.
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+
+    // Receiving a Settings with a larger window size will unblock the streams.
+    Settings initial = new Settings();
+    initial.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, initialWindowSize + 1);
+    connection.readerRunnable.settings(false, initial);
+
+    assertEquals(1, connection.bytesLeftInWriteWindow);
+    assertEquals(1, connection.getStream(1).bytesLeftInWriteWindow);
+
+    // The stream should no longer be blocked.
+    out.flush();
+
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+
+    // Settings after the initial do not affect the connection window size.
+    Settings next = new Settings();
+    next.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, initialWindowSize + 2);
+    connection.readerRunnable.settings(false, next);
+
+    assertEquals(0, connection.bytesLeftInWriteWindow); // connection wasn't affected.
+    assertEquals(1, connection.getStream(1).bytesLeftInWriteWindow);
+  }
+
   @Test public void testTruncatedDataFrame() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
@@ -1212,6 +1258,46 @@
     }
   }
 
+  @Test public void blockedStreamDoesntStarveNewStream() throws Exception {
+    int initialWindowSize = 65535;
+    int framesThatFillWindow = roundUp(initialWindowSize, SpdyStream.OUTPUT_BUFFER_SIZE);
+
+    // Write the mocking script. This accepts more data frames than necessary!
+    peer.acceptFrame(); // SYN_STREAM
+    for (int i = 0; i < framesThatFillWindow; i++) {
+      peer.acceptFrame(); // DATA on stream 1
+    }
+    peer.acceptFrame(); // DATA on stream 2
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyStream stream1 = connection.newStream(headerEntries("a", "apple"), true, true);
+    OutputStream out1 = stream1.getOutputStream();
+    out1.write(new byte[initialWindowSize]);
+    out1.flush();
+
+    // Check that we've filled the window for both the stream and also the connection.
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+
+    // receiving a window update on the the connection will unblock new streams.
+    connection.readerRunnable.windowUpdate(0, 3);
+
+    assertEquals(3, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+
+    // Another stream should be able to send data even though 1 is blocked.
+    SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
+    OutputStream out2 = stream2.getOutputStream();
+    out2.write("foo".getBytes(UTF_8));
+    out2.flush();
+
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+    assertEquals(initialWindowSize - 3, connection.getStream(3).bytesLeftInWriteWindow);
+  }
+
   /**
    * This tests that data frames are written in chunks limited by the
    * SpdyDataOutputStream buffer size.  A side-effect is that this size
@@ -1344,6 +1430,15 @@
     assertEquals(expected, actual);
   }
 
+  private void assertFlushBlocks(OutputStream out) throws IOException {
+    interruptAfterDelay(500);
+    try {
+      out.flush();
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+  }
+
   /** Interrupts the current thread after {@code delayMillis}. */
   private void interruptAfterDelay(final long delayMillis) {
     final Thread toInterrupt = Thread.currentThread();
@@ -1358,4 +1453,8 @@
       }
     }.start();
   }
+
+  static int roundUp(int num, int divisor) {
+    return (num + divisor - 1) / divisor;
+  }
 }
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index 8cc7bfd..b22520a 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -157,6 +157,25 @@
     assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
   }
 
+  @Test public void closeAfterFlush() throws Exception {
+    MockResponse response = new MockResponse().setBody("ABCDE");
+    server.enqueue(response);
+    server.play();
+
+    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection.setRequestProperty("Content-Length", String.valueOf(postBytes.length));
+    connection.setDoOutput(true);
+    connection.getOutputStream().write(postBytes); // push bytes into SpdyDataOutputStream.buffer
+    connection.getOutputStream().flush(); // SpdyConnection.writeData subject to write window
+    connection.getOutputStream().close(); // SpdyConnection.writeData empty frame
+    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody());
+    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+  }
+
   @Test public void setFixedLengthStreamingModeSetsContentLength() throws Exception {
     MockResponse response = new MockResponse().setBody("ABCDE");
     server.enqueue(response);
/Fim/
diff --git a/.travis.yml b/.travis.yml
index 7769867..bc088e9 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -3,5 +3,8 @@
 notifications:
   email: false
 
+before_install:
+ - mvn -version
+
 jdk:
   - oraclejdk7
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index 401020b..7fd0e2d 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -28,26 +28,29 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
 
 /** Replays prerecorded outgoing frames and records incoming frames. */
 public final class MockSpdyPeer implements Closeable {
   private int frameCount = 0;
-  private final boolean client;
-  private final Variant variant;
+  private boolean client = false;
+  private Variant variant = new Spdy3();
   private final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-  private final FrameWriter frameWriter;
+  private FrameWriter frameWriter = variant.newWriter(bytesOut, client);;
   private final List<OutFrame> outFrames = new ArrayList<OutFrame>();
   private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<InFrame>();
   private int port;
-  private final Executor executor = Executors.newCachedThreadPool(
+  private final ExecutorService executor = Executors.newCachedThreadPool(
       Util.threadFactory("MockSpdyPeer", false));
   private ServerSocket serverSocket;
   private Socket socket;
 
-  public MockSpdyPeer(Variant variant, boolean client) {
+  public void setVariantAndClient(Variant variant, boolean client) {
+    if (this.variant.getProtocol() == variant.getProtocol() && this.client == client) {
+      return;
+    }
     this.client = client;
     this.variant = variant;
     this.frameWriter = variant.newWriter(bytesOut, client);
@@ -85,10 +88,6 @@
     return frameWriter;
   }
 
-  public int getPort() {
-    return port;
-  }
-
   public InFrame takeFrame() throws InterruptedException {
     return inFrames.take();
   }
@@ -97,12 +96,13 @@
     if (serverSocket != null) throw new IllegalStateException();
     serverSocket = new ServerSocket(0);
     serverSocket.setReuseAddress(true);
-    this.port = serverSocket.getLocalPort();
+    port = serverSocket.getLocalPort();
     executor.execute(new Runnable() {
       @Override public void run() {
         try {
           readAndWriteFrames();
         } catch (IOException e) {
+          Util.closeQuietly(MockSpdyPeer.this);
           throw new RuntimeException(e);
         }
       }
@@ -153,15 +153,16 @@
     return new Socket("localhost", port);
   }
 
-  @Override public void close() throws IOException {
+  @Override public synchronized void close() throws IOException {
+    executor.shutdown();
     Socket socket = this.socket;
     if (socket != null) {
-      socket.close();
+      Util.closeQuietly(socket);
       this.socket = null;
     }
     ServerSocket serverSocket = this.serverSocket;
     if (serverSocket != null) {
-      serverSocket.close();
+      Util.closeQuietly(serverSocket);
       this.serverSocket = null;
     }
   }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index 8f29368..c7f3936 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -62,7 +62,7 @@
       throw new AssertionError();
     }
   };
-  private final MockSpdyPeer peer = new MockSpdyPeer(SPDY3, false);
+  private final MockSpdyPeer peer = new MockSpdyPeer();
 
   @After public void tearDown() throws Exception {
     peer.close();
@@ -173,7 +173,7 @@
   }
 
   private MockSpdyPeer.InFrame replyWithNoData(Variant variant) throws Exception {
-    MockSpdyPeer peer = new MockSpdyPeer(variant, false);
+    peer.setVariantAndClient(variant, false);
     // write the mocking script
     peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
@@ -230,7 +230,7 @@
   }
 
   @Test public void serverPingsClientHttp2() throws Exception {
-    MockSpdyPeer peer = new MockSpdyPeer(HTTP_20_DRAFT_09, false);
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
 
     // write the mocking script
     peer.sendFrame().ping(false, 2, 3);
@@ -270,7 +270,7 @@
   }
 
   @Test public void clientPingsServerHttp2() throws Exception {
-    MockSpdyPeer peer = new MockSpdyPeer(HTTP_20_DRAFT_09, false);
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
 
     // write the mocking script
     peer.acceptFrame(); // PING
@@ -292,13 +292,13 @@
   }
 
   @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
-    boolean client = false; // Peer is server, so we are client.
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
+
     Settings initial = new Settings();
     initial.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 1684);
     Settings shouldntImpactConnection = new Settings();
     shouldntImpactConnection.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 3368);
 
-    MockSpdyPeer peer = new MockSpdyPeer(HTTP_20_DRAFT_09, client);
     peer.sendFrame().settings(initial);
     peer.acceptFrame(); // ACK
     peer.sendFrame().settings(shouldntImpactConnection);
@@ -815,7 +815,7 @@
   }
 
   private void receiveGoAway(Variant variant) throws Exception {
-    MockSpdyPeer peer = new MockSpdyPeer(variant, false);
+    peer.setVariantAndClient(variant, false);
 
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM 1
@@ -1059,7 +1059,8 @@
 
   private void readSendsWindowUpdate(Variant variant)
       throws IOException, InterruptedException {
-    MockSpdyPeer peer = new MockSpdyPeer(variant, false);
+    peer.setVariantAndClient(variant, false);
+
     int windowUpdateThreshold = INITIAL_WINDOW_SIZE / 2;
 
     // Write the mocking script.
@@ -1118,7 +1119,7 @@
 
   private void serverSendsEmptyDataClientDoesntSendWindowUpdate(Variant variant)
       throws IOException, InterruptedException {
-    MockSpdyPeer peer = new MockSpdyPeer(variant, false);
+    peer.setVariantAndClient(variant, false);
 
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
@@ -1147,7 +1148,7 @@
 
   private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
       throws IOException, InterruptedException {
-    MockSpdyPeer peer = new MockSpdyPeer(variant, false);
+    peer.setVariantAndClient(variant, false);
 
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
@@ -1324,7 +1325,7 @@
    * prevents us from overrunning the max frame size of SPDY/3 or HTTP/2.
    */
   @Test public void spdyStreamOutputBufferSizeLimitsDataFrameLength() throws Exception {
-    MockSpdyPeer peer = new MockSpdyPeer(HTTP_20_DRAFT_09, false);
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
 
     byte[] buff = new byte[SpdyStream.OUTPUT_BUFFER_SIZE * 2];
     Arrays.fill(buff, (byte) '*');
@@ -1381,7 +1382,7 @@
 
   // TODO: change this to only cancel when local settings disable push
   @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
-    MockSpdyPeer peer = new MockSpdyPeer(HTTP_20_DRAFT_09, false);
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
 
     // write the mocking script
     peer.sendFrame().pushPromise(1, 2, Arrays.asList(
@@ -1408,7 +1409,7 @@
 
   private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
       throws IOException, InterruptedException {
-    MockSpdyPeer peer = new MockSpdyPeer(HTTP_20_DRAFT_09, client);
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, client);
     peer.sendFrame().settings(settings);
     peer.acceptFrame(); // ACK
     peer.play();
@@ -1421,7 +1422,6 @@
     assertEquals(TYPE_SETTINGS, ackFrame.type);
     assertEquals(0, ackFrame.streamId);
     assertTrue(ackFrame.ack);
-    peer.close();
     return connection;
   }
 
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
index c02be45..99e7aa3 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
@@ -75,19 +75,19 @@
     Route httpRoute = new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true);
     Route spdyRoute = new Route(spdyAddress, Proxy.NO_PROXY, spdySocketAddress, true);
     httpA = new Connection(httpRoute);
-    httpA.connect(100, 100, null);
+    httpA.connect(200, 200, null);
     httpB = new Connection(httpRoute);
-    httpB.connect(100, 100, null);
+    httpB.connect(200, 200, null);
     httpC = new Connection(httpRoute);
-    httpC.connect(100, 100, null);
+    httpC.connect(200, 200, null);
     httpD = new Connection(httpRoute);
-    httpD.connect(100, 100, null);
+    httpD.connect(200, 200, null);
     httpE = new Connection(httpRoute);
-    httpE.connect(100, 100, null);
+    httpE.connect(200, 200, null);
     spdyA = new Connection(spdyRoute);
-    spdyA.connect(100, 100, null);
+    spdyA.connect(200, 200, null);
     spdyB = new Connection(spdyRoute);
-    spdyB.connect(100, 100, null);
+    spdyB.connect(200, 200, null);
   }
 
   @After public void tearDown() throws Exception {
@@ -109,7 +109,7 @@
     assertNull(connection);
 
     connection = new Connection(new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true));
-    connection.connect(100, 100, null);
+    connection.connect(200, 200, null);
     assertEquals(0, pool.getConnectionCount());
     pool.recycle(connection);
     assertEquals(1, pool.getConnectionCount());
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index b22520a..83cabde 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -34,7 +34,6 @@
 import java.net.CookieManager;
 import java.net.HttpURLConnection;
 import java.net.URL;
-import java.net.URLConnection;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
@@ -80,6 +79,7 @@
   private final MockWebServer server = new MockWebServer();
   private final String hostName = server.getHostName();
   private final OkHttpClient client = new OkHttpClient();
+  private HttpURLConnection connection;
   private HttpResponseCache cache;
 
   @Before public void setUp() throws Exception {
@@ -102,7 +102,7 @@
     server.enqueue(response);
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     assertContent("ABCDE", connection, Integer.MAX_VALUE);
     assertEquals(200, connection.getResponseCode());
     assertEquals("Sweet", connection.getResponseMessage());
@@ -117,7 +117,7 @@
     server.enqueue(new MockResponse());
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     assertEquals(-1, connection.getInputStream().read());
   }
 
@@ -129,7 +129,7 @@
     server.enqueue(response);
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     connection.setDoOutput(true);
     connection.getOutputStream().write(postBytes);
     assertContent("ABCDE", connection, Integer.MAX_VALUE);
@@ -145,7 +145,7 @@
     server.enqueue(response);
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     connection.setRequestProperty("Content-Length", String.valueOf(postBytes.length));
     connection.setDoOutput(true);
     connection.getOutputStream().write(postBytes);
@@ -162,7 +162,7 @@
     server.enqueue(response);
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     connection.setRequestProperty("Content-Length", String.valueOf(postBytes.length));
     connection.setDoOutput(true);
     connection.getOutputStream().write(postBytes); // push bytes into SpdyDataOutputStream.buffer
@@ -181,7 +181,7 @@
     server.enqueue(response);
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     connection.setFixedLengthStreamingMode(postBytes.length);
     connection.setDoOutput(true);
     connection.getOutputStream().write(postBytes);
@@ -237,7 +237,7 @@
     server.play();
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
     RecordedRequest denied = server.takeRequest();
@@ -255,7 +255,7 @@
     server.enqueue(new MockResponse().setBody("This is the new location!"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertContent("This is the new location!", connection, Integer.MAX_VALUE);
 
     RecordedRequest request1 = server.takeRequest();
@@ -268,7 +268,7 @@
     server.enqueue(new MockResponse().setBody("ABC"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     assertEquals("ABC", readAscii(in, 3));
     assertEquals(-1, in.read());
@@ -280,7 +280,7 @@
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setReadTimeout(1000);
     assertContent("A", connection, Integer.MAX_VALUE);
   }
@@ -341,12 +341,12 @@
     server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("EFGH"));
     server.play();
 
-    URLConnection connection1 = client.open(server.getUrl("/"));
+    HttpURLConnection connection1 = client.open(server.getUrl("/"));
     InputStream in1 = connection1.getInputStream();
     assertEquals("AB", readAscii(in1, 2));
     in1.close();
 
-    URLConnection connection2 = client.open(server.getUrl("/"));
+    HttpURLConnection connection2 = client.open(server.getUrl("/"));
     InputStream in2 = connection2.getInputStream();
     assertEquals("ABCD", readAscii(in2, Integer.MAX_VALUE));
     in2.close();
@@ -378,11 +378,10 @@
     assertTrue(collection.toString(), collection.contains(value));
   }
 
-  private void assertContent(String expected, URLConnection connection, int limit)
+  private void assertContent(String expected, HttpURLConnection connection, int limit)
       throws IOException {
     connection.connect();
     assertEquals(expected, readAscii(connection.getInputStream(), limit));
-    ((HttpURLConnection) connection).disconnect();
   }
 
   private void assertContainsNoneMatching(List<String> headers, String pattern) {
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index 1179702..d9d3d3d 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -98,6 +98,7 @@
   private MockWebServer server2 = new MockWebServer();
 
   private final OkHttpClient client = new OkHttpClient();
+  private HttpURLConnection connection;
   private HttpResponseCache cache;
   private String hostName;
 
@@ -125,12 +126,12 @@
     server.enqueue(new MockResponse());
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.addRequestProperty("D", "e");
-    urlConnection.addRequestProperty("D", "f");
-    assertEquals("f", urlConnection.getRequestProperty("D"));
-    assertEquals("f", urlConnection.getRequestProperty("d"));
-    Map<String, List<String>> requestHeaders = urlConnection.getRequestProperties();
+    connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("D", "e");
+    connection.addRequestProperty("D", "f");
+    assertEquals("f", connection.getRequestProperty("D"));
+    assertEquals("f", connection.getRequestProperty("d"));
+    Map<String, List<String>> requestHeaders = connection.getRequestProperties();
     assertEquals(newSet("e", "f"), new HashSet<String>(requestHeaders.get("D")));
     assertEquals(newSet("e", "f"), new HashSet<String>(requestHeaders.get("d")));
     try {
@@ -144,21 +145,21 @@
     } catch (UnsupportedOperationException expected) {
     }
     try {
-      urlConnection.setRequestProperty(null, "j");
+      connection.setRequestProperty(null, "j");
       fail();
     } catch (NullPointerException expected) {
     }
     try {
-      urlConnection.addRequestProperty(null, "k");
+      connection.addRequestProperty(null, "k");
       fail();
     } catch (NullPointerException expected) {
     }
-    urlConnection.setRequestProperty("NullValue", null);
-    assertNull(urlConnection.getRequestProperty("NullValue"));
-    urlConnection.addRequestProperty("AnotherNullValue", null);
-    assertNull(urlConnection.getRequestProperty("AnotherNullValue"));
+    connection.setRequestProperty("NullValue", null);
+    assertNull(connection.getRequestProperty("NullValue"));
+    connection.addRequestProperty("AnotherNullValue", null);
+    assertNull(connection.getRequestProperty("AnotherNullValue"));
 
-    urlConnection.getResponseCode();
+    connection.getResponseCode();
     RecordedRequest request = server.takeRequest();
     assertContains(request.getHeaders(), "D: e");
     assertContains(request.getHeaders(), "D: f");
@@ -168,17 +169,17 @@
     assertContainsNoneMatching(request.getHeaders(), "null:.*");
 
     try {
-      urlConnection.addRequestProperty("N", "o");
+      connection.addRequestProperty("N", "o");
       fail("Set header after connect");
     } catch (IllegalStateException expected) {
     }
     try {
-      urlConnection.setRequestProperty("P", "q");
+      connection.setRequestProperty("P", "q");
       fail("Set header after connect");
     } catch (IllegalStateException expected) {
     }
     try {
-      urlConnection.getRequestProperties();
+      connection.getRequestProperties();
       fail();
     } catch (IllegalStateException expected) {
     }
@@ -186,10 +187,10 @@
 
   @Test public void getRequestPropertyReturnsLastValue() throws Exception {
     server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.addRequestProperty("A", "value1");
-    urlConnection.addRequestProperty("A", "value2");
-    assertEquals("value2", urlConnection.getRequestProperty("A"));
+    connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("A", "value1");
+    connection.addRequestProperty("A", "value2");
+    assertEquals("value2", connection.getRequestProperty("A"));
   }
 
   @Test public void responseHeaders() throws IOException, InterruptedException {
@@ -200,11 +201,11 @@
         .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8));
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-    assertEquals("HTTP/1.0 200 Fantastic", urlConnection.getHeaderField(null));
-    Map<String, List<String>> responseHeaders = urlConnection.getHeaderFields();
+    connection = client.open(server.getUrl("/"));
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("Fantastic", connection.getResponseMessage());
+    assertEquals("HTTP/1.0 200 Fantastic", connection.getHeaderField(null));
+    Map<String, List<String>> responseHeaders = connection.getHeaderFields();
     assertEquals(Arrays.asList("HTTP/1.0 200 Fantastic"), responseHeaders.get(null));
     assertEquals(newSet("c", "e"), new HashSet<String>(responseHeaders.get("A")));
     assertEquals(newSet("c", "e"), new HashSet<String>(responseHeaders.get("a")));
@@ -218,21 +219,21 @@
       fail("Modified an unmodifiable view.");
     } catch (UnsupportedOperationException expected) {
     }
-    assertEquals("A", urlConnection.getHeaderFieldKey(0));
-    assertEquals("c", urlConnection.getHeaderField(0));
-    assertEquals("B", urlConnection.getHeaderFieldKey(1));
-    assertEquals("d", urlConnection.getHeaderField(1));
-    assertEquals("A", urlConnection.getHeaderFieldKey(2));
-    assertEquals("e", urlConnection.getHeaderField(2));
+    assertEquals("A", connection.getHeaderFieldKey(0));
+    assertEquals("c", connection.getHeaderField(0));
+    assertEquals("B", connection.getHeaderFieldKey(1));
+    assertEquals("d", connection.getHeaderField(1));
+    assertEquals("A", connection.getHeaderFieldKey(2));
+    assertEquals("e", connection.getHeaderField(2));
   }
 
   @Test public void serverSendsInvalidResponseHeaders() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.getResponseCode();
+      connection.getResponseCode();
       fail();
     } catch (IOException expected) {
     }
@@ -242,9 +243,9 @@
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.getResponseCode();
+      connection.getResponseCode();
       fail();
     } catch (IOException expected) {
     }
@@ -254,9 +255,9 @@
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.getResponseCode();
+      connection.getResponseCode();
       fail();
     } catch (IOException expected) {
     }
@@ -266,9 +267,9 @@
     server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.getResponseCode();
+      connection.getResponseCode();
       fail();
     } catch (IOException expected) {
     }
@@ -279,7 +280,7 @@
     URL url = server.getUrl("/foo");
     server.shutdown();
 
-    HttpURLConnection connection = client.open(url);
+    connection = client.open(url);
     try {
       connection.connect();
       fail();
@@ -310,7 +311,7 @@
     client.setProxySelector(proxySelector);
     server2.shutdown();
 
-    HttpURLConnection connection = client.open(server.getUrl("/def"));
+    connection = client.open(server.getUrl("/def"));
     connection.setDoOutput(true);
     transferKind.setForRequest(connection, 4);
     connection.getOutputStream().write("body".getBytes("UTF-8"));
@@ -322,14 +323,14 @@
   @Test public void getErrorStreamOnSuccessfulRequest() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertNull(connection.getErrorStream());
   }
 
   @Test public void getErrorStreamOnUnsuccessfulRequest() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(404).setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection.getErrorStream(), Integer.MAX_VALUE));
   }
 
@@ -509,7 +510,7 @@
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
 
     assertContent("this response comes via HTTPS", connection);
 
@@ -529,7 +530,7 @@
 
     client.setSslSocketFactory(clientSocketFactory);
     client.setHostnameVerifier(hostnameVerifier);
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertContent("this response comes via HTTPS", connection);
 
     connection = client.open(server.getUrl("/"));
@@ -569,7 +570,7 @@
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
 
     assertContent("this response comes via SSL", connection);
 
@@ -587,7 +588,7 @@
     server.enqueue(new MockResponse()); // unused
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     try {
       connection.getInputStream();
       fail();
@@ -615,7 +616,7 @@
     server.play();
 
     URL url = new URL("http://android.com/foo");
-    HttpURLConnection connection = proxyConfig.connect(server, client, url);
+    connection = proxyConfig.connect(server, client, url);
     assertContent("this response comes via a proxy", connection);
     assertTrue(connection.usingProxy());
 
@@ -666,7 +667,7 @@
     URL url = server.getUrl("/foo");
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = proxyConfig.connect(server, client, url);
+    connection = proxyConfig.connect(server, client, url);
 
     assertContent("this response comes via HTTPS", connection);
 
@@ -706,7 +707,7 @@
     URL url = new URL("https://android.com/foo");
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(hostnameVerifier);
-    HttpURLConnection connection = proxyConfig.connect(server, client, url);
+    connection = proxyConfig.connect(server, client, url);
 
     assertContent("this response comes via a secure proxy", connection);
 
@@ -742,7 +743,7 @@
 
     URL url = new URL("https://android.com/foo");
     client.setSslSocketFactory(sslContext.getSocketFactory());
-    HttpURLConnection connection = client.open(url);
+    connection = client.open(url);
 
     try {
       connection.getResponseCode();
@@ -781,7 +782,7 @@
     URL url = new URL("https://android.com/foo");
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(hostnameVerifier);
-    HttpURLConnection connection = client.open(url);
+    connection = client.open(url);
     connection.addRequestProperty("Private", "Secret");
     connection.addRequestProperty("Proxy-Authorization", "bar");
     connection.addRequestProperty("User-Agent", "baz");
@@ -813,7 +814,7 @@
     URL url = new URL("https://android.com/foo");
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(url);
+    connection = client.open(url);
     assertContent("A", connection);
 
     RecordedRequest connect1 = server.takeRequest();
@@ -843,7 +844,7 @@
     URL url = new URL("https://android.com/foo");
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(url);
+    connection = client.open(url);
     connection.setRequestProperty("Connection", "close");
 
     assertContent("this response comes via a proxy", connection);
@@ -872,7 +873,7 @@
     server.enqueue(new MockResponse().setBody("ABCDEFGHIJKLMNOPQR"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     assertEquals('A', (char) in.read());
     connection.disconnect();
@@ -887,9 +888,8 @@
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.disconnect();
-
     assertContent("A", connection);
     assertEquals(200, connection.getResponseCode());
   }
@@ -1120,15 +1120,15 @@
 
     server.play();
 
-    URLConnection connection1 = client.open(server.getUrl("/"));
+    HttpURLConnection connection1 = client.open(server.getUrl("/"));
     InputStream in1 = connection1.getInputStream();
     assertEquals("ABCDE", readAscii(in1, 5));
-    in1.close();
+    connection1.disconnect();
 
     HttpURLConnection connection2 = client.open(server.getUrl("/"));
     InputStream in2 = connection2.getInputStream();
     assertEquals("LMNOP", readAscii(in2, 5));
-    in2.close();
+    connection2.disconnect();
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection is pooled!
@@ -1166,12 +1166,12 @@
     server.play();
 
     String body = "ABCDEFGHIJKLMNOPQ";
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.setChunkedStreamingMode(0); // OkHttp does not honor specific chunk sizes.
-    urlConnection.setDoOutput(true);
-    OutputStream outputStream = urlConnection.getOutputStream();
+    connection = client.open(server.getUrl("/"));
+    connection.setChunkedStreamingMode(0); // OkHttp does not honor specific chunk sizes.
+    connection.setDoOutput(true);
+    OutputStream outputStream = connection.getOutputStream();
     outputStream.write(body.getBytes("US-ASCII"));
-    assertEquals(200, urlConnection.getResponseCode());
+    assertEquals(200, connection.getResponseCode());
 
     RecordedRequest request = server.takeRequest();
     assertEquals(body, new String(request.getBody(), "US-ASCII"));
@@ -1194,7 +1194,7 @@
     server.play();
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     if (streamingMode == StreamingMode.FIXED_LENGTH) {
@@ -1278,7 +1278,6 @@
     server.enqueue(pleaseAuthenticate);
     server.play();
 
-    HttpURLConnection connection;
     if (proxy) {
       client.setProxy(server.toProxyAddress());
       connection = client.open(new URL("http://android.com"));
@@ -1301,7 +1300,7 @@
   }
 
   private void assertValidRequestMethod(String requestMethod) throws Exception {
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setRequestMethod(requestMethod);
     assertEquals(requestMethod, connection.getRequestMethod());
   }
@@ -1317,7 +1316,7 @@
   }
 
   private void assertInvalidRequestMethod(String requestMethod) throws Exception {
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.setRequestMethod(requestMethod);
       fail();
@@ -1345,7 +1344,7 @@
         .addHeader("icy-metaint:16000")
         .setBody("mp3 data"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals(200, connection.getResponseCode());
     assertEquals("OK", connection.getResponseMessage());
     assertContent("mp3 data", connection);
@@ -1353,7 +1352,7 @@
 
   @Test public void cannotSetNegativeFixedLengthStreamingMode() throws Exception {
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.setFixedLengthStreamingMode(-2);
       fail();
@@ -1363,14 +1362,14 @@
 
   @Test public void canSetNegativeChunkedStreamingMode() throws Exception {
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setChunkedStreamingMode(-2);
   }
 
   @Test public void cannotSetFixedLengthStreamingModeAfterConnect() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     try {
       connection.setFixedLengthStreamingMode(1);
@@ -1382,7 +1381,7 @@
   @Test public void cannotSetChunkedStreamingModeAfterConnect() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     try {
       connection.setChunkedStreamingMode(1);
@@ -1393,7 +1392,7 @@
 
   @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() throws Exception {
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setChunkedStreamingMode(1);
     try {
       connection.setFixedLengthStreamingMode(1);
@@ -1404,7 +1403,7 @@
 
   @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() throws Exception {
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setFixedLengthStreamingMode(1);
     try {
       connection.setChunkedStreamingMode(1);
@@ -1432,7 +1431,7 @@
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     if (streamingMode == StreamingMode.FIXED_LENGTH) {
@@ -1472,7 +1471,7 @@
     server.play();
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     OutputStream outputStream = connection.getOutputStream();
@@ -1507,7 +1506,7 @@
     server.play();
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
     // no authorization header for the first request...
@@ -1532,7 +1531,7 @@
     server.play();
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
@@ -1579,7 +1578,7 @@
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("This is the new location!",
         readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -1600,7 +1599,7 @@
     client.setFollowProtocolRedirects(false);
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
@@ -1611,7 +1610,7 @@
     server.play();
 
     client.setFollowProtocolRedirects(false);
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
@@ -1652,7 +1651,7 @@
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
     client.setFollowProtocolRedirects(true);
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertContent("This is secure HTTPS!", connection);
     assertFalse(connection instanceof HttpsURLConnection);
   }
@@ -1685,7 +1684,7 @@
     server.enqueue(new MockResponse().setBody("This is the first server again!"));
     server.play();
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertContent("This is the 2nd server!", connection);
     assertEquals(server2.getUrl("/"), connection.getURL());
 
@@ -1755,7 +1754,7 @@
     server.enqueue(new MockResponse().setBody("Page 2"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/page1"));
+    connection = client.open(server.getUrl("/page1"));
     connection.setDoOutput(true);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     OutputStream outputStream = connection.getOutputStream();
@@ -1779,7 +1778,7 @@
     server.enqueue(new MockResponse().setBody("Page 2"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/page1"));
+    connection = client.open(server.getUrl("/page1"));
     connection.setDoOutput(true);
     connection.addRequestProperty("Content-Length", "4");
     connection.addRequestProperty("Content-Type", "text/plain; charset=utf-8");
@@ -1805,7 +1804,7 @@
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("Proxy Response"));
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     // Fails on the RI, which gets "Proxy Response"
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -1841,7 +1840,7 @@
     server.enqueue(new MockResponse().setBody("Page 2"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/page1"));
+    connection = client.open(server.getUrl("/page1"));
     connection.setRequestMethod(method);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     if (method.equals("POST")) {
@@ -1887,7 +1886,7 @@
     server.enqueue(new MockResponse().setBody("Success!"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/0"));
+    connection = client.open(server.getUrl("/0"));
     assertContent("Success!", connection);
     assertEquals(server.getUrl("/20"), connection.getURL());
   }
@@ -1900,7 +1899,7 @@
     }
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/0"));
+    connection = client.open(server.getUrl("/0"));
     try {
       connection.getInputStream();
       fail();
@@ -1945,9 +1944,9 @@
     server.enqueue(new MockResponse().setBody("unused")); // to keep the server alive
     server.play();
 
-    URLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.setReadTimeout(1000);
-    InputStream in = urlConnection.getInputStream();
+    URLConnection connection = client.open(server.getUrl("/"));
+    connection.setReadTimeout(1000);
+    InputStream in = connection.getInputStream();
     assertEquals('A', in.read());
     assertEquals('B', in.read());
     assertEquals('C', in.read());
@@ -1962,11 +1961,11 @@
     server.enqueue(new MockResponse());
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.setRequestProperty("Transfer-encoding", "chunked");
-    urlConnection.setDoOutput(true);
-    urlConnection.getOutputStream().write("ABC".getBytes("UTF-8"));
-    assertEquals(200, urlConnection.getResponseCode());
+    connection = client.open(server.getUrl("/"));
+    connection.setRequestProperty("Transfer-encoding", "chunked");
+    connection.setDoOutput(true);
+    connection.getOutputStream().write("ABC".getBytes("UTF-8"));
+    assertEquals(200, connection.getResponseCode());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("ABC", new String(request.getBody(), "UTF-8"));
@@ -2053,7 +2052,7 @@
     server.enqueue(new MockResponse().setBody(new byte[] { -2, -1 }));
     server.play();
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     assertEquals(254, in.read());
     assertEquals(255, in.read());
@@ -2081,7 +2080,7 @@
     server.enqueue(new MockResponse().setBody("abc"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     byte[] upload = "def".getBytes("UTF-8");
 
@@ -2112,7 +2111,7 @@
     }
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.getInputStream();
       fail();
@@ -2127,7 +2126,7 @@
   }
 
   @Test public void dnsFailureThrowsIOException() throws IOException {
-    HttpURLConnection connection = client.open(new URL("http://host.unlikelytld"));
+    connection = client.open(new URL("http://host.unlikelytld"));
     try {
       connection.connect();
       fail();
@@ -2136,7 +2135,7 @@
   }
 
   @Test public void malformedUrlThrowsUnknownHostException() throws IOException {
-    HttpURLConnection connection = client.open(new URL("http:///foo.html"));
+    connection = client.open(new URL("http:///foo.html"));
     try {
       connection.connect();
       fail();
@@ -2150,11 +2149,10 @@
     server.play();
 
     // The request should work once and then fail
-    URLConnection connection1 = client.open(server.getUrl(""));
+    HttpURLConnection connection1 = client.open(server.getUrl(""));
     connection1.setReadTimeout(100);
     InputStream input = connection1.getInputStream();
     assertEquals("ABC", readAscii(input, Integer.MAX_VALUE));
-    input.close();
     server.shutdown();
     try {
       HttpURLConnection connection2 = client.open(server.getUrl(""));
@@ -2192,7 +2190,7 @@
         .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     assertEquals("ABC", readAscii(in, 3));
     assertEquals(-1, in.read());
@@ -2202,7 +2200,7 @@
   @Test public void getContent() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = (InputStream) connection.getContent();
     assertEquals("A", readAscii(in, Integer.MAX_VALUE));
   }
@@ -2210,7 +2208,7 @@
   @Test public void getContentOfType() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.getContent(null);
       fail();
@@ -2222,13 +2220,12 @@
     } catch (NullPointerException expected) {
     }
     assertNull(connection.getContent(new Class[] { getClass() }));
-    connection.disconnect();
   }
 
   @Test public void getOutputStreamOnGetFails() throws Exception {
     server.enqueue(new MockResponse());
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.getOutputStream();
       fail();
@@ -2239,7 +2236,7 @@
   @Test public void getOutputAfterGetInputStreamFails() throws Exception {
     server.enqueue(new MockResponse());
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     try {
       connection.getInputStream();
@@ -2252,7 +2249,7 @@
   @Test public void setDoOutputOrDoInputAfterConnectFails() throws Exception {
     server.enqueue(new MockResponse());
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.connect();
     try {
       connection.setDoOutput(true);
@@ -2264,13 +2261,12 @@
       fail();
     } catch (IllegalStateException expected) {
     }
-    connection.disconnect();
   }
 
   @Test public void clientSendsContentLength() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     OutputStream out = connection.getOutputStream();
     out.write(new byte[] { 'A', 'B', 'C' });
@@ -2283,25 +2279,22 @@
   @Test public void getContentLengthConnects() throws Exception {
     server.enqueue(new MockResponse().setBody("ABC"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals(3, connection.getContentLength());
-    connection.disconnect();
   }
 
   @Test public void getContentTypeConnects() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("ABC"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("text/plain", connection.getContentType());
-    connection.disconnect();
   }
 
   @Test public void getContentEncodingConnects() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Encoding: identity").setBody("ABC"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("identity", connection.getContentEncoding());
-    connection.disconnect();
   }
 
   // http://b/4361656
@@ -2333,7 +2326,7 @@
     transferKind.setBody(response, body, 4);
     server.enqueue(response);
     server.play();
-    URLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     for (int i = 0; i < body.length(); i++) {
       assertTrue(in.available() >= 0);
@@ -2380,7 +2373,7 @@
     byte[] requestBody = new byte[requestSize];
     new Random(0).nextBytes(requestBody);
 
-    HttpURLConnection connection = client.open(server.getUrl("/b"));
+    connection = client.open(server.getUrl("/b"));
     connection.setRequestMethod("POST");
     transferKind.setForRequest(connection, requestBody.length);
     for (int i = 0; i < requestBody.length; i += 1024) {
@@ -2400,7 +2393,7 @@
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/b"));
+    connection = client.open(server.getUrl("/b"));
     connection.setRequestProperty("Content-Length", "4");
     connection.setRequestMethod("POST");
     OutputStream out = connection.getOutputStream();
@@ -2418,7 +2411,7 @@
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/b"));
+    connection = client.open(server.getUrl("/b"));
     connection.setRequestProperty("Content-Length", "3");
     connection.setRequestMethod("POST");
     OutputStream out = connection.getOutputStream();
@@ -2459,26 +2452,26 @@
   @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
     server.enqueue(new MockResponse().setBody("body"));
     server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.addRequestProperty("B", "");
-    assertContent("body", urlConnection);
-    assertEquals("", urlConnection.getRequestProperty("B"));
+    connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("B", "");
+    assertContent("body", connection);
+    assertEquals("", connection.getRequestProperty("B"));
   }
 
   @Test public void emptyResponseHeaderValueIsAllowed() throws Exception {
     server.enqueue(new MockResponse().addHeader("A:").setBody("body"));
     server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    assertContent("body", urlConnection);
-    assertEquals("", urlConnection.getHeaderField("A"));
+    connection = client.open(server.getUrl("/"));
+    assertContent("body", connection);
+    assertEquals("", connection.getHeaderField("A"));
   }
 
   @Test public void emptyRequestHeaderNameIsStrict() throws Exception {
     server.enqueue(new MockResponse().setBody("body"));
     server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.setRequestProperty("", "A");
+      connection.setRequestProperty("", "A");
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -2487,9 +2480,9 @@
   @Test public void emptyResponseHeaderNameIsLenient() throws Exception {
     server.enqueue(new MockResponse().addHeader(":A").setBody("body"));
     server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.getResponseCode();
-    assertEquals("A", urlConnection.getHeaderField(""));
+    connection = client.open(server.getUrl("/"));
+    connection.getResponseCode();
+    assertEquals("A", connection.getHeaderField(""));
   }
 
   @Test @Ignore public void deflateCompression() {
@@ -2541,7 +2534,7 @@
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
     client.setProtocols(Arrays.asList(Protocol.HTTP_11, protocol));
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
     assertEquals(Arrays.asList(protocol.name.utf8()), protocolValues);
     assertContent("A", connection);
@@ -2581,7 +2574,7 @@
       throws IOException, InterruptedException {
     server.enqueue(new MockResponse());
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setRequestProperty("Content-Length", "0");
     connection.setRequestMethod(method);
     connection.setFixedLengthStreamingMode(0);
@@ -2621,7 +2614,7 @@
     server.enqueue(new MockResponse());
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     long contentLength = Integer.MAX_VALUE + 1L;
     connection.setFixedLengthStreamingMode(contentLength);
@@ -2656,12 +2649,10 @@
     HttpURLConnection connection1 = client.open(server.getUrl("/"));
     assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection1.getResponseCode());
     assertContent("", connection1);
-    connection1.getInputStream().close();
 
     HttpURLConnection connection2 = client.open(server.getUrl("/"));
     assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
     assertContent("b", connection2);
-    connection2.getInputStream().close();
 
     RecordedRequest requestA = server.takeRequest();
     assertEquals(0, requestA.getSequenceNumber());
@@ -2683,14 +2674,13 @@
    * Reads at most {@code limit} characters from {@code in} and asserts that
    * content equals {@code expected}.
    */
-  private void assertContent(String expected, URLConnection connection, int limit)
+  private void assertContent(String expected, HttpURLConnection connection, int limit)
       throws IOException {
     connection.connect();
     assertEquals(expected, readAscii(connection.getInputStream(), limit));
-    ((HttpURLConnection) connection).disconnect();
   }
 
-  private void assertContent(String expected, URLConnection connection) throws IOException {
+  private void assertContent(String expected, HttpURLConnection connection) throws IOException {
     assertContent(expected, connection, Integer.MAX_VALUE);
   }
 
/Fim/
diff --git a/pom.xml b/pom.xml
index bc32950..a4ab7ea 100644
--- a/pom.xml
+++ b/pom.xml
@@ -37,7 +37,7 @@
     <apache.http.version>4.2.2</apache.http.version>
 
     <!-- Test Dependencies -->
-    <junit.version>4.10</junit.version>
+    <junit.version>4.11</junit.version>
   </properties>
 
   <scm>
@@ -105,10 +105,17 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-surefire-plugin</artifactId>
-          <version>2.9</version>
+          <version>2.16</version>
           <configuration>
             <argLine>-Xbootclasspath/p:${settings.localRepository}/org/mortbay/jetty/npn/npn-boot/${npn.version}/npn-boot-${npn.version}.jar</argLine>
           </configuration>
+          <dependencies>
+            <dependency>
+              <groupId>org.apache.maven.surefire</groupId>
+              <artifactId>surefire-junit47</artifactId>
+              <version>2.16</version>
+            </dependency>
+          </dependencies>
         </plugin>
 
         <plugin>
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java
index 9bfa304..1cdf23c 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java
@@ -30,12 +30,12 @@
  * <h3>Protocol vs Scheme</h3>
  * Despite its name, {@link java.net.URL#getProtocol()} returns the
  * {@link java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not
- * the protocol (http/1.1, spdy/3, etc.).  OkHttp uses the word protocol to
+ * the protocol (http/1.1, spdy/3.1, etc.).  OkHttp uses the word protocol to
  * indicate how HTTP messages are framed.
  */
 public enum Protocol {
   HTTP_2("HTTP-draft-09/2.0", true),
-  SPDY_3("spdy/3", true),
+  SPDY_3("spdy/3.1", true),
   HTTP_11("http/1.1", false);
 
   public static final List<Protocol> HTTP2_SPDY3_AND_HTTP =
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
index 1fcbb0d..eee2295 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -340,7 +340,7 @@
         if (!provider.unsupported && provider.selected == null) {
           Logger logger = Logger.getLogger("com.squareup.okhttp.OkHttpClient");
           logger.log(Level.INFO,
-              "NPN callback dropped so SPDY is disabled. " + "Is npn-boot on the boot class path?");
+              "NPN callback dropped so SPDY is disabled. Is npn-boot on the boot class path?");
           return null;
         }
         return provider.unsupported ? null : ByteString.encodeUtf8(provider.selected);
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
index 50568bb..9d4c233 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -51,9 +51,6 @@
     /** HTTP/2 only. */
     void ackSettings();
 
-    /** SPDY/3 only. */
-    void noop();
-
     /**
      *  Read a connection-level ping from the peer.  {@code ack} indicates this
      *  is a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
index b7182a6..db1134e 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -69,9 +69,6 @@
   /** Write okhttp's settings to the peer. */
   void settings(Settings okHttpSettings) throws IOException;
 
-  /** SPDY/3 only. */
-  void noop() throws IOException;
-
   /**
    *  Send a connection-level ping to the peer.  {@code ack} indicates this is
    *  a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index eb0f3f6..fd465f9 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -411,10 +411,6 @@
       }
     }
 
-    @Override public synchronized void noop() throws IOException {
-      throw new UnsupportedOperationException();
-    }
-
     @Override public synchronized void ping(boolean ack, int payload1, int payload2)
         throws IOException {
       int length = 8;
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index ee33d11..393b6ee 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -28,8 +28,14 @@
 import java.io.UnsupportedEncodingException;
 import java.net.ProtocolException;
 import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import java.util.zip.Deflater;
 
+/**
+ * Read and write spdy/3.1 frames.
+ * http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1
+ */
 final class Spdy3 implements Variant {
 
   @Override public Protocol getProtocol() {
@@ -41,12 +47,10 @@
   static final int TYPE_SYN_REPLY = 0x2;
   static final int TYPE_RST_STREAM = 0x3;
   static final int TYPE_SETTINGS = 0x4;
-  static final int TYPE_NOOP = 0x5;
   static final int TYPE_PING = 0x6;
   static final int TYPE_GOAWAY = 0x7;
   static final int TYPE_HEADERS = 0x8;
   static final int TYPE_WINDOW_UPDATE = 0x9;
-  static final int TYPE_CREDENTIAL = 0x10;
 
   static final int FLAG_FIN = 0x1;
   static final int FLAG_UNIDIRECTIONAL = 0x2;
@@ -159,11 +163,6 @@
             readSettings(handler, flags, length);
             return true;
 
-          case TYPE_NOOP:
-            if (length != 0) throw ioException("TYPE_NOOP length: %d != 0", length);
-            handler.noop();
-            return true;
-
           case TYPE_PING:
             readPing(handler, flags, length);
             return true;
@@ -180,12 +179,11 @@
             readWindowUpdate(handler, flags, length);
             return true;
 
-          case TYPE_CREDENTIAL:
-            Util.skipByReading(in, length);
-            throw new UnsupportedOperationException("TODO"); // TODO: implement
-
           default:
-            throw new IOException("Unexpected frame");
+            Logger logger = Logger.getLogger("com.squareup.okhttp.internal.spdy.Spdy3");
+            logger.log(Level.INFO, "Ignoring unknown frame type " + type);
+            Util.skipByReading(in, length);
+            return true;
         }
       } else {
         int streamId = w1 & 0x7fffffff;
@@ -440,15 +438,6 @@
       out.flush();
     }
 
-    @Override public synchronized void noop() throws IOException {
-      int type = TYPE_NOOP;
-      int length = 0;
-      int flags = 0;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.flush();
-    }
-
     @Override public synchronized void ping(boolean reply, int payload1, int payload2)
         throws IOException {
       boolean payloadIsReply = client != ((payload1 % 2) == 1);
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index 0f9e265..daec4ce 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -348,11 +348,6 @@
     return pings != null ? pings.remove(id) : null;
   }
 
-  /** Sends a noop frame to the peer. */
-  public void noop() throws IOException {
-    frameWriter.noop();
-  }
-
   public void flush() throws IOException {
     frameWriter.flush();
   }
@@ -658,9 +653,6 @@
       // TODO: If we don't get this callback after sending settings to the peer, SETTINGS_TIMEOUT.
     }
 
-    @Override public void noop() {
-    }
-
     @Override public void ping(boolean reply, int payload1, int payload2) {
       if (reply) {
         Ping ping = removePing(payload1);
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
index 3b6a1be..6dfc1e9 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
@@ -45,10 +45,6 @@
     fail();
   }
 
-  @Override public void noop() {
-    fail();
-  }
-
   @Override public void ping(boolean ack, int payload1, int payload2) {
     fail();
   }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index 7fd0e2d..f890c00 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -256,11 +256,6 @@
       this.payload2 = payload2;
     }
 
-    @Override public void noop() {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_NOOP;
-    }
-
     @Override
     public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
       if (this.type != -1) throw new IllegalStateException();
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index c7f3936..c563491 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -42,7 +42,6 @@
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_DATA;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_GOAWAY;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_NOOP;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_PING;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_RST_STREAM;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_SETTINGS;
@@ -198,20 +197,6 @@
     return reply;
   }
 
-  @Test public void noop() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // NOOP
-    peer.play();
-
-    // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    connection.noop();
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_NOOP, ping.type);
-  }
-
   @Test public void serverPingsClient() throws Exception {
     // write the mocking script
     peer.sendFrame().ping(false, 2, 0);
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index 9df5971..951f59a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -323,12 +323,12 @@
    * <p>The following protocols are currently supported:
    * <ul>
    *   <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-   *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3">spdy/3</a>
+   *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
    *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-09">HTTP-draft-09/2.0</a>
    * </ul>
    *
    * <p><strong>This is an evolving set.</strong> Future releases may drop
-   * support for transitional protocols (like spdy/3), in favor of their
+   * support for transitional protocols (like spdy/3.1), in favor of their
    * successors (spdy/4 or http/2.0). The http/1.1 transport will never be
    * dropped.
    *
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
index bc18ea6..dd18638 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
@@ -58,7 +58,7 @@
 
   /**
    * Synthetic response header: the selected
-   * {@link com.squareup.okhttp.Protocol protocol} ("spdy/3", "http/1.1", etc).
+   * {@link com.squareup.okhttp.Protocol protocol} ("spdy/3.1", "http/1.1", etc).
    */
   public static final String SELECTED_PROTOCOL = PREFIX + "-Selected-Protocol";
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 743e64b..3390588 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -98,8 +98,7 @@
     // TODO: make the known header names constants.
     List<Header> result = new ArrayList<Header>(headers.size() + 10);
     result.add(new Header(TARGET_METHOD, request.method()));
-    result.add(
-        new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
+    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
     String host = HttpEngine.hostHeader(request.url());
     if (Protocol.SPDY_3 == protocol) {
       result.add(new Header(VERSION, version));
@@ -201,7 +200,7 @@
   private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
     boolean prohibited = false;
     if (protocol == Protocol.SPDY_3) {
-      // http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3#TOC-3.2.1-Request
+      // http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1#TOC-3.2.1-Request
       if (name.equalsAscii("connection")
           || name.equalsAscii("host")
           || name.equalsAscii("keep-alive")
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
index a7b85e3..c8d9f22 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
@@ -17,6 +17,7 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.net.URL;
@@ -30,7 +31,8 @@
 public final class ExternalHttp2Example {
   public static void main(String[] args) throws Exception {
     URL url = new URL("https://twitter.com/");
-    HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient().open(url);
+    HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient()
+        .setProtocols(Protocol.HTTP2_AND_HTTP_11).open(url);
 
     connection.setHostnameVerifier(new HostnameVerifier() {
       @Override public boolean verify(String s, SSLSession sslSession) {
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
index e43fbb0..dab90c1 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
@@ -17,6 +17,7 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.net.URL;
@@ -30,7 +31,8 @@
 public final class ExternalSpdyExample {
   public static void main(String[] args) throws Exception {
     URL url = new URL("https://www.google.ca/");
-    HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient().open(url);
+    HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient()
+        .setProtocols(Protocol.SPDY3_AND_HTTP11).open(url);
 
     connection.setHostnameVerifier(new HostnameVerifier() {
       @Override public boolean verify(String s, SSLSession sslSession) {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index 3662068..0bd8b06 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -1,14 +1,17 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.BitArray;
-import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 
 import static com.squareup.okhttp.internal.Util.asciiLowerCase;
 
@@ -188,7 +191,7 @@
         } else { // 0NNNNNNN
           if (b == 0x40) { // 01000000
             readLiteralHeaderWithoutIndexingNewName();
-          } else if ((b & 0xe0) == 0x40) {  // 01NNNNNN
+          } else if ((b & 0x40) == 0x40) {  // 01NNNNNN
             int index = readInt(b, PREFIX_6_BITS);
             readLiteralHeaderWithoutIndexingIndexedName(index - 1);
           } else if (b == 0) { // 00000000
@@ -375,6 +378,19 @@
     }
   }
 
+  private static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
+
+  private static Map<ByteString, Integer> nameToFirstIndex() {
+    Map<ByteString, Integer> result =
+        new LinkedHashMap<ByteString, Integer>(STATIC_HEADER_TABLE.length);
+    for (int i = 0; i < STATIC_HEADER_TABLE.length; i++) {
+      if (!result.containsKey(STATIC_HEADER_TABLE[i].name)) {
+        result.put(STATIC_HEADER_TABLE[i].name, i);
+      }
+    }
+    return Collections.unmodifiableMap(result);
+  }
+
   static final class Writer {
     private final OutputStream out;
 
@@ -383,11 +399,19 @@
     }
 
     void writeHeaders(List<Header> headerBlock) throws IOException {
-      // TODO: implement a compression strategy.
+      // TODO: implement index tracking
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
-        out.write(0x40); // Literal Header without Indexing - New Name.
-        writeByteString(headerBlock.get(i).name);
-        writeByteString(headerBlock.get(i).value);
+        ByteString name = headerBlock.get(i).name;
+        Integer staticIndex = NAME_TO_FIRST_INDEX.get(name);
+        if (staticIndex != null) {
+          // Literal Header Field without Indexing - Indexed Name.
+          writeInt(staticIndex + 1, PREFIX_6_BITS, 0x40);
+          writeByteString(headerBlock.get(i).value);
+        } else {
+          out.write(0x40); // Literal Header without Indexing - New Name.
+          writeByteString(name);
+          writeByteString(headerBlock.get(i).value);
+        }
       }
     }
 
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index 9e3bb1e..5f01183 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -27,6 +27,7 @@
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.Util.headerEntries;
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertSame;
@@ -36,9 +37,12 @@
 
   private final MutableByteArrayInputStream bytesIn = new MutableByteArrayInputStream();
   private HpackDraft05.Reader hpackReader;
+  private ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
+  private HpackDraft05.Writer hpackWriter;
 
-  @Before public void resetReader() {
+  @Before public void reset() {
     hpackReader = newReader(bytesIn);
+    hpackWriter = new HpackDraft05.Writer(new DataOutputStream(bytesOut));
   }
 
   /**
@@ -167,7 +171,7 @@
   /**
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.1
    */
-  @Test public void decodeLiteralHeaderFieldWithIndexing() throws IOException {
+  @Test public void readLiteralHeaderFieldWithIndexing() throws IOException {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
 
     out.write(0x00); // Literal indexed
@@ -192,29 +196,60 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.2
+   * Literal Header Field without Indexing - New Name
    */
-  @Test public void decodeLiteralHeaderFieldWithoutIndexingIndexedName() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+  @Test public void literalHeaderFieldWithoutIndexingNewName() throws IOException {
+    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
 
-    out.write(0x44); // == Literal not indexed ==
-                     // Indexed name (idx = 4) -> :path
-    out.write(0x0c); // Literal value (len = 12)
-    out.write("/sample/path".getBytes(), 0, 12);
+    ByteArrayOutputStream expectedBytes = new ByteArrayOutputStream();
 
-    bytesIn.set(out.toByteArray());
+    expectedBytes.write(0x40); // Not indexed
+    expectedBytes.write(0x0a); // Literal name (len = 10)
+    expectedBytes.write("custom-key".getBytes(), 0, 10);
+
+    expectedBytes.write(0x0d); // Literal value (len = 13)
+    expectedBytes.write("custom-header".getBytes(), 0, 13);
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertArrayEquals(expectedBytes.toByteArray(), bytesOut.toByteArray());
+
+    bytesIn.set(bytesOut.toByteArray());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(0, hpackReader.headerCount);
 
-    assertEquals(headerEntries(":path", "/sample/path"), hpackReader.getAndReset());
+    assertEquals(headerBlock, hpackReader.getAndReset());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.2
+   */
+  @Test public void literalHeaderFieldWithoutIndexingIndexedName() throws IOException {
+    List<Header> headerBlock = headerEntries(":path", "/sample/path");
+
+    ByteArrayOutputStream expectedBytes = new ByteArrayOutputStream();
+    expectedBytes.write(0x44); // == Literal not indexed ==
+                               // Indexed name (idx = 4) -> :path
+    expectedBytes.write(0x0c); // Literal value (len = 12)
+    expectedBytes.write("/sample/path".getBytes(), 0, 12);
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertArrayEquals(expectedBytes.toByteArray(), bytesOut.toByteArray());
+
+    bytesIn.set(bytesOut.toByteArray());
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndReset());
   }
 
   /**
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.3
    */
-  @Test public void decodeIndexedHeaderField() throws IOException {
+  @Test public void readIndexedHeaderField() throws IOException {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
 
     out.write(0x82); // == Indexed - Add ==
@@ -264,7 +299,7 @@
   /**
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.4
    */
-  @Test public void decodeIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
+  @Test public void readIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
 
     out.write(0x82); // == Indexed - Add ==
@@ -284,24 +319,24 @@
   /**
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.2
    */
-  @Test public void decodeRequestExamplesWithoutHuffman() throws IOException {
+  @Test public void readRequestExamplesWithoutHuffman() throws IOException {
     ByteArrayOutputStream out = firstRequestWithoutHuffman();
     bytesIn.set(out.toByteArray());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
-    checkFirstRequestWithoutHuffman();
+    checkReadFirstRequestWithoutHuffman();
 
     out = secondRequestWithoutHuffman();
     bytesIn.set(out.toByteArray());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
-    checkSecondRequestWithoutHuffman();
+    checkReadSecondRequestWithoutHuffman();
 
     out = thirdRequestWithoutHuffman();
     bytesIn.set(out.toByteArray());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
-    checkThirdRequestWithoutHuffman();
+    checkReadThirdRequestWithoutHuffman();
   }
 
   private ByteArrayOutputStream firstRequestWithoutHuffman() {
@@ -321,7 +356,7 @@
     return out;
   }
 
-  private void checkFirstRequestWithoutHuffman() {
+  private void checkReadFirstRequestWithoutHuffman() {
     assertEquals(4, hpackReader.headerCount);
 
     // [  1] (s =  57) :authority: www.example.com
@@ -366,7 +401,7 @@
     return out;
   }
 
-  private void checkSecondRequestWithoutHuffman() {
+  private void checkReadSecondRequestWithoutHuffman() {
     assertEquals(5, hpackReader.headerCount);
 
     // [  1] (s =  53) cache-control: no-cache
@@ -427,7 +462,7 @@
     return out;
   }
 
-  private void checkThirdRequestWithoutHuffman() {
+  private void checkReadThirdRequestWithoutHuffman() {
     assertEquals(8, hpackReader.headerCount);
 
     // [  1] (s =  54) custom-key: custom-value
@@ -486,24 +521,24 @@
   /**
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.3
    */
-  @Test public void decodeRequestExamplesWithHuffman() throws IOException {
+  @Test public void readRequestExamplesWithHuffman() throws IOException {
     ByteArrayOutputStream out = firstRequestWithHuffman();
     bytesIn.set(out.toByteArray());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
-    checkFirstRequestWithHuffman();
+    checkReadFirstRequestWithHuffman();
 
     out = secondRequestWithHuffman();
     bytesIn.set(out.toByteArray());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
-    checkSecondRequestWithHuffman();
+    checkReadSecondRequestWithHuffman();
 
     out = thirdRequestWithHuffman();
     bytesIn.set(out.toByteArray());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
-    checkThirdRequestWithHuffman();
+    checkReadThirdRequestWithHuffman();
   }
 
   private ByteArrayOutputStream firstRequestWithHuffman() {
@@ -528,7 +563,7 @@
     return out;
   }
 
-  private void checkFirstRequestWithHuffman() {
+  private void checkReadFirstRequestWithHuffman() {
     assertEquals(4, hpackReader.headerCount);
 
     // [  1] (s =  57) :authority: www.example.com
@@ -577,7 +612,7 @@
     return out;
   }
 
-  private void checkSecondRequestWithHuffman() {
+  private void checkReadSecondRequestWithHuffman() {
     assertEquals(5, hpackReader.headerCount);
 
     // [  1] (s =  53) cache-control: no-cache
@@ -647,7 +682,7 @@
     return out;
   }
 
-  private void checkThirdRequestWithHuffman() {
+  private void checkReadThirdRequestWithHuffman() {
     assertEquals(8, hpackReader.headerCount);
 
     // [  1] (s =  54) custom-key: custom-value
@@ -703,10 +738,6 @@
         "custom-key", "custom-value"), hpackReader.getAndReset());
   }
 
-  private ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-  private final HpackDraft05.Writer hpackWriter =
-      new HpackDraft05.Writer(new DataOutputStream(bytesOut));
-
   @Test public void readSingleByteInt() throws IOException {
     assertEquals(10, newReader(byteStream()).readInt(10, 31));
     assertEquals(10, newReader(byteStream()).readInt(0xe0 | 10, 31));
@@ -768,17 +799,6 @@
     assertSame(ByteString.EMPTY, newReader(byteStream(0)).readByteString(false));
   }
 
-  @Test public void headersRoundTrip() throws IOException {
-    List<Header> sentHeaders = headerEntries("name", "value");
-    hpackWriter.writeHeaders(sentHeaders);
-    ByteArrayInputStream bytesIn = new ByteArrayInputStream(bytesOut.toByteArray());
-    HpackDraft05.Reader reader = newReader(bytesIn);
-    reader.readHeaders();
-    reader.emitReferenceSet();
-    List<Header> receivedHeaders = reader.getAndReset();
-    assertEquals(sentHeaders, receivedHeaders);
-  }
-
   private HpackDraft05.Reader newReader(InputStream input) {
     return new HpackDraft05.Reader(false, 4096, input);
   }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index 8a8aaed..4f94d27 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -219,21 +219,22 @@
 
     // Decoding the first header will cross frame boundaries.
     byte[] headerBlock = literalHeaders(pushPromise);
+    int firstFrameLength = headerBlock.length - 1;
     { // Write the first headers frame.
-      dataOut.writeShort((headerBlock.length / 2) + 4);
+      dataOut.writeShort(firstFrameLength + 4);
       dataOut.write(Http20Draft09.TYPE_PUSH_PROMISE);
       dataOut.write(0); // no flags
       dataOut.writeInt(expectedStreamId & 0x7fffffff);
       dataOut.writeInt(expectedPromisedStreamId & 0x7fffffff);
-      dataOut.write(headerBlock, 0, headerBlock.length / 2);
+      dataOut.write(headerBlock, 0, firstFrameLength);
     }
 
     { // Write the continuation frame, specifying no more frames are expected.
-      dataOut.writeShort(headerBlock.length / 2);
+      dataOut.writeShort(1);
       dataOut.write(Http20Draft09.TYPE_CONTINUATION);
       dataOut.write(Http20Draft09.FLAG_END_HEADERS);
       dataOut.writeInt(expectedStreamId & 0x7fffffff);
-      dataOut.write(headerBlock, headerBlock.length / 2, headerBlock.length / 2);
+      dataOut.write(headerBlock, firstFrameLength, 1);
     }
 
     FrameReader fr = newReader(out);
/Fim/
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
new file mode 100644
index 0000000..e606d7f
--- /dev/null
+++ b/benchmarks/pom.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>benchmarks</artifactId>
+  <name>Benchmarks</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.bouncycastle</groupId>
+      <artifactId>bcprov-jdk15on</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.mortbay.jetty.npn</groupId>
+      <artifactId>npn-boot</artifactId>
+      <scope>provided</scope>
+    </dependency>
+  </dependencies>
+</project>
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
new file mode 100644
index 0000000..7637a3b
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.mockwebserver.Dispatcher;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import java.util.zip.GZIPOutputStream;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+
+/**
+ * This benchmark is fake, but may be useful for certain relative comparisons.
+ * It uses a local connection to a MockWebServer to measure how many identical
+ * requests per second can be carried over a fixed number of threads.
+ */
+public class Benchmark {
+  private static final int NUM_REPORTS = 10;
+  private final Random random = new Random(0);
+
+  /** Which client to run.*/
+  // TODO: implement additional candidates for other HTTP client libraries.
+  Candidate candidate = new OkHttp();
+
+  /** How many concurrent threads to execute. */
+  int threadCount = 10;
+
+  /** True to use TLS. */
+  // TODO: compare different ciphers?
+  boolean tls = false;
+
+  /** True to use gzip content-encoding for the response body. */
+  boolean gzip = true;
+
+  /** Don't combine chunked with SPDY_3 or HTTP_2; that's not allowed. */
+  boolean chunked = true;
+
+  /** The size of the HTTP response body, in uncompressed bytes. */
+  int bodyByteCount = 1024 * 1024;
+
+  /** How many additional headers were included, beyond the built-in ones. */
+  int headerCount = 20;
+
+  /** Which ALPN/NPN protocols are in use. Only useful with TLS. */
+  List<Protocol> protocols = Arrays.asList(Protocol.HTTP_11);
+
+  public static void main(String[] args) throws IOException {
+    new Benchmark().run();
+  }
+
+  public void run() throws IOException {
+    ThreadPoolExecutor executor = new ThreadPoolExecutor(threadCount, threadCount,
+        1, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
+
+    System.out.println(toString());
+
+    // Prepare the client & server
+    candidate.prepare();
+    MockWebServer server = startServer();
+    String url = server.getUrl("/").toString();
+
+    int targetBacklog = 10;
+    int requestCount = 0;
+    long reportStart = System.nanoTime();
+    long reportPeriod = TimeUnit.SECONDS.toNanos(1);
+    int reports = 0;
+
+    // Run until we've printed enough reports.
+    while (reports < NUM_REPORTS) {
+      // Print a report if we haven't recently.
+      long now = System.nanoTime();
+      double reportDuration = now - reportStart;
+      if (reportDuration > reportPeriod) {
+        double requestsPerSecond = requestCount / reportDuration * TimeUnit.SECONDS.toNanos(1);
+        System.out.println(String.format("Requests per second: %.1f", requestsPerSecond));
+        requestCount = 0;
+        reportStart = now;
+        reports++;
+      }
+
+      // Fill the job queue with work.
+      while (executor.getQueue().size() < targetBacklog) {
+        executor.execute(candidate.request(url));
+        requestCount++;
+      }
+
+      // The job queue is full. Take a break.
+      sleep(10);
+    }
+  }
+
+  @Override public String toString() {
+    List<Object> modifiers = new ArrayList<Object>();
+    if (tls) modifiers.add("tls");
+    if (gzip) modifiers.add("gzip");
+    if (chunked) modifiers.add("chunked");
+    modifiers.addAll(protocols);
+
+    return String.format("%s %s\n"
+        + "bodyByteCount=%s headerCount=%s threadCount=%s",
+        candidate.getClass().getSimpleName(), modifiers,
+        bodyByteCount, headerCount, threadCount);
+  }
+
+  private void sleep(int millis) {
+    try {
+      Thread.sleep(millis);
+    } catch (InterruptedException ignored) {
+    }
+  }
+
+  private MockWebServer startServer() throws IOException {
+    Logger.getLogger(MockWebServer.class.getName()).setLevel(Level.WARNING);
+    MockWebServer server = new MockWebServer();
+
+    if (tls) {
+      SSLContext sslContext = SslContextBuilder.localhost();
+      server.useHttps(sslContext.getSocketFactory(), false);
+      server.setNpnEnabled(true);
+    }
+
+    final MockResponse response = newResponse();
+    server.setDispatcher(new Dispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        return response;
+      }
+    });
+
+    server.play();
+    return server;
+  }
+
+  private MockResponse newResponse() throws IOException {
+    byte[] body = new byte[bodyByteCount];
+    random.nextBytes(body);
+
+    MockResponse result = new MockResponse();
+
+    if (gzip) {
+      body = gzip(body);
+      result.addHeader("Content-Encoding: gzip");
+    }
+
+    if (chunked) {
+      result.setChunkedBody(body, 1024);
+    } else {
+      result.setBody(body);
+    }
+
+    for (int i = 0; i < headerCount; i++) {
+      result.addHeader(randomString(12), randomString(20));
+    }
+
+    return result;
+  }
+
+  private String randomString(int length) {
+    String alphabet = "-abcdefghijklmnopqrstuvwxyz";
+    char[] result = new char[length];
+    for (int i = 0; i < length; i++) {
+      result[i] = alphabet.charAt(random.nextInt(alphabet.length()));
+    }
+    return new String(result);
+  }
+
+  /** Returns a gzipped copy of {@code bytes}. */
+  private byte[] gzip(byte[] bytes) throws IOException {
+    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
+    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
+    gzippedOut.write(bytes);
+    gzippedOut.close();
+    return bytesOut.toByteArray();
+  }
+
+  interface Candidate {
+    void prepare();
+    Runnable request(String url);
+  }
+
+  class OkHttp implements Candidate {
+    private OkHttpClient client;
+
+    @Override public void prepare() {
+      client = new OkHttpClient();
+      client.setProtocols(protocols);
+
+      URL.setURLStreamHandlerFactory(client);
+
+      if (tls) {
+        SSLContext sslContext = SslContextBuilder.localhost();
+        SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+        HostnameVerifier hostnameVerifier = new HostnameVerifier() {
+          @Override public boolean verify(String s, SSLSession session) {
+            return true;
+          }
+        };
+        client.setSslSocketFactory(socketFactory);
+        client.setHostnameVerifier(hostnameVerifier);
+      }
+    }
+
+    @Override public Runnable request(String url) {
+      return new HttpURLConnectionRequest(url);
+    }
+  }
+}
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpURLConnectionRequest.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpURLConnectionRequest.java
new file mode 100644
index 0000000..b1eb99e
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpURLConnectionRequest.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.concurrent.TimeUnit;
+
+public class HttpURLConnectionRequest implements Runnable {
+  private static final boolean VERBOSE = false;
+  private final URL url;
+
+  public HttpURLConnectionRequest(String url) {
+    try {
+      this.url = new URL(url);
+    } catch (MalformedURLException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public void run() {
+    byte[] buffer = new byte[1024];
+    long start = System.nanoTime();
+    try {
+      HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
+      InputStream in = urlConnection.getInputStream();
+
+      // Discard the response body.
+      int total = 0;
+      for (int count; (count = in.read(buffer)) != -1; ) {
+        total += count;
+      }
+      in.close();
+      long finish = System.nanoTime();
+
+      if (VERBOSE) {
+        System.out.println(String.format("Transferred % 8d bytes in %4d ms",
+            total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
+      }
+    } catch (IOException e) {
+      System.out.println("Failed: " + e);
+    }
+  }
+}
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 4ca28ba..90e2925 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -18,10 +18,10 @@
 package com.squareup.okhttp.mockwebserver;
 
 import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.spdy.Header;
 import com.squareup.okhttp.internal.spdy.IncomingStreamHandler;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
@@ -72,7 +72,6 @@
  * replays them upon request in sequence.
  */
 public final class MockWebServer {
-
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
     @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
         throws CertificateException {
@@ -381,7 +380,9 @@
         } else if (response.getSocketPolicy() == SocketPolicy.SHUTDOWN_OUTPUT_AT_END) {
           socket.shutdownOutput();
         }
-        logger.info("Received request: " + request + " and responded: " + response);
+        if (logger.isLoggable(Level.INFO)) {
+          logger.info("Received request: " + request + " and responded: " + response);
+        }
         sequenceNumber++;
         return true;
       }
@@ -611,8 +612,10 @@
         throw new AssertionError(e);
       }
       writeResponse(stream, response);
-      logger.info("Received request: " + request + " and responded: " + response
-          + " protocol is " + protocol.name.utf8());
+      if (logger.isLoggable(Level.INFO)) {
+        logger.info("Received request: " + request + " and responded: " + response
+            + " protocol is " + protocol.name.utf8());
+      }
     }
 
     private RecordedRequest readRequest(SpdyStream stream) throws IOException {
/Fim/
diff --git a/pom.xml b/pom.xml
index a4ab7ea..aea71da 100644
--- a/pom.xml
+++ b/pom.xml
@@ -24,6 +24,7 @@
     <module>okhttp-protocols</module>
     <module>mockwebserver</module>
     <module>samples</module>
+    <module>benchmarks</module>
   </modules>
 
   <properties>
/Fim/
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index e606d7f..7b8ce52 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -32,5 +32,9 @@
       <artifactId>npn-boot</artifactId>
       <scope>provided</scope>
     </dependency>
+    <dependency>
+      <groupId>org.apache.httpcomponents</groupId>
+      <artifactId>httpclient</artifactId>
+    </dependency>
   </dependencies>
 </project>
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpURLConnectionRequest.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClientRequest.java
similarity index 62%
copy from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpURLConnectionRequest.java
copy to benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClientRequest.java
index b1eb99e..a507738 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpURLConnectionRequest.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClientRequest.java
@@ -17,31 +17,35 @@
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.MalformedURLException;
-import java.net.URL;
 import java.util.concurrent.TimeUnit;
+import java.util.zip.GZIPInputStream;
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
 
-public class HttpURLConnectionRequest implements Runnable {
+class ApacheHttpClientRequest implements Runnable {
   private static final boolean VERBOSE = false;
-  private final URL url;
+  private final HttpClient client;
+  private final String url;
 
-  public HttpURLConnectionRequest(String url) {
-    try {
-      this.url = new URL(url);
-    } catch (MalformedURLException e) {
-      throw new AssertionError();
-    }
+  public ApacheHttpClientRequest(String url, HttpClient client) {
+    this.client = client;
+    this.url = url;
   }
 
   public void run() {
     byte[] buffer = new byte[1024];
     long start = System.nanoTime();
     try {
-      HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
-      InputStream in = urlConnection.getInputStream();
+      HttpResponse response = client.execute(new HttpGet(url));
+      InputStream in = response.getEntity().getContent();
+      Header contentEncoding = response.getFirstHeader("Content-Encoding");
+      if (contentEncoding != null && contentEncoding.getValue().equals("gzip")) {
+        in = new GZIPInputStream(in);
+      }
 
-      // Discard the response body.
+      // Consume the response body.
       int total = 0;
       for (int count; (count = in.read(buffer)) != -1; ) {
         total += count;
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
index 7637a3b..3b0887a 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
@@ -18,6 +18,7 @@
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
 import com.squareup.okhttp.mockwebserver.Dispatcher;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
@@ -25,7 +26,6 @@
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
-import java.net.URL;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -40,6 +40,11 @@
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
+import org.apache.http.client.HttpClient;
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.conn.scheme.Scheme;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.impl.conn.PoolingClientConnectionManager;
 
 /**
  * This benchmark is fake, but may be useful for certain relative comparisons.
@@ -51,8 +56,7 @@
   private final Random random = new Random(0);
 
   /** Which client to run.*/
-  // TODO: implement additional candidates for other HTTP client libraries.
-  Candidate candidate = new OkHttp();
+  Candidate candidate = new UrlConnection(); // new OkHttp(); // new ApacheHttpClient();
 
   /** How many concurrent threads to execute. */
   int threadCount = 10;
@@ -62,10 +66,10 @@
   boolean tls = false;
 
   /** True to use gzip content-encoding for the response body. */
-  boolean gzip = true;
+  boolean gzip = false;
 
   /** Don't combine chunked with SPDY_3 or HTTP_2; that's not allowed. */
-  boolean chunked = true;
+  boolean chunked = false;
 
   /** The size of the HTTP response body, in uncompressed bytes. */
   int bodyByteCount = 1024 * 1024;
@@ -216,8 +220,6 @@
       client = new OkHttpClient();
       client.setProtocols(protocols);
 
-      URL.setURLStreamHandlerFactory(client);
-
       if (tls) {
         SSLContext sslContext = SslContextBuilder.localhost();
         SSLSocketFactory socketFactory = sslContext.getSocketFactory();
@@ -232,7 +234,45 @@
     }
 
     @Override public Runnable request(String url) {
-      return new HttpURLConnectionRequest(url);
+      return new OkHttpRequest(client, url);
+    }
+  }
+
+  class UrlConnection implements Candidate {
+    @Override public void prepare() {
+      if (tls) {
+        SSLContext sslContext = SslContextBuilder.localhost();
+        SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+        HostnameVerifier hostnameVerifier = new HostnameVerifier() {
+          @Override public boolean verify(String s, SSLSession session) {
+            return true;
+          }
+        };
+        HttpsURLConnectionImpl.setDefaultHostnameVerifier(hostnameVerifier);
+        HttpsURLConnectionImpl.setDefaultSSLSocketFactory(socketFactory);
+      }
+    }
+
+    @Override public Runnable request(String url) {
+      return new UrlConnectionRequest(url);
+    }
+  }
+
+  class ApacheHttpClient implements Candidate {
+    private HttpClient client;
+
+    @Override public void prepare() {
+      ClientConnectionManager connectionManager = new PoolingClientConnectionManager();
+      if (tls) {
+        SSLContext sslContext = SslContextBuilder.localhost();
+        connectionManager.getSchemeRegistry().register(
+            new Scheme("https", 443, new org.apache.http.conn.ssl.SSLSocketFactory(sslContext)));
+      }
+      client = new DefaultHttpClient(connectionManager);
+    }
+
+    @Override public Runnable request(String url) {
+      return new ApacheHttpClientRequest(url, client);
     }
   }
 }
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpURLConnectionRequest.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpRequest.java
similarity index 84%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpURLConnectionRequest.java
rename to benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpRequest.java
index b1eb99e..e4ab485 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpURLConnectionRequest.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpRequest.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp.benchmarks;
 
+import com.squareup.okhttp.OkHttpClient;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
@@ -22,12 +23,15 @@
 import java.net.URL;
 import java.util.concurrent.TimeUnit;
 
-public class HttpURLConnectionRequest implements Runnable {
+class OkHttpRequest implements Runnable {
   private static final boolean VERBOSE = false;
+
+  private final OkHttpClient client;
   private final URL url;
 
-  public HttpURLConnectionRequest(String url) {
+  public OkHttpRequest(OkHttpClient client, String url) {
     try {
+      this.client = client;
       this.url = new URL(url);
     } catch (MalformedURLException e) {
       throw new AssertionError();
@@ -38,10 +42,10 @@
     byte[] buffer = new byte[1024];
     long start = System.nanoTime();
     try {
-      HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
+      HttpURLConnection urlConnection = client.open(url);
       InputStream in = urlConnection.getInputStream();
 
-      // Discard the response body.
+      // Consume the response body.
       int total = 0;
       for (int count; (count = in.read(buffer)) != -1; ) {
         total += count;
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpURLConnectionRequest.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnectionRequest.java
similarity index 82%
copy from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpURLConnectionRequest.java
copy to benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnectionRequest.java
index b1eb99e..ab5c9b4 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpURLConnectionRequest.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnectionRequest.java
@@ -21,12 +21,15 @@
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.concurrent.TimeUnit;
+import java.util.zip.GZIPInputStream;
 
-public class HttpURLConnectionRequest implements Runnable {
+/** Uses the default java.net.HttpURLConnection implementation. */
+class UrlConnectionRequest implements Runnable {
   private static final boolean VERBOSE = false;
+
   private final URL url;
 
-  public HttpURLConnectionRequest(String url) {
+  public UrlConnectionRequest(String url) {
     try {
       this.url = new URL(url);
     } catch (MalformedURLException e) {
@@ -40,8 +43,11 @@
     try {
       HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
       InputStream in = urlConnection.getInputStream();
+      if ("gzip".equals(urlConnection.getHeaderField("Content-Encoding"))) {
+        in = new GZIPInputStream(in);
+      }
 
-      // Discard the response body.
+      // Consume the response body.
       int total = 0;
       for (int count; (count = in.read(buffer)) != -1; ) {
         total += count;
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
index 16bd063..fe23182 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
@@ -138,6 +138,7 @@
       SSLContext sslContext = SslContextBuilder.localhost();
       server.useHttps(sslContext.getSocketFactory(), false);
       server.setNpnEnabled(true);
+      server.setNpnProtocols(protocols);
     }
 
     final MockResponse response = newResponse();
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 90e2925..71c7c86 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -106,6 +106,7 @@
 
   private int port = -1;
   private boolean npnEnabled = true;
+  private List<Protocol> npnProtocols = Protocol.HTTP2_SPDY3_AND_HTTP;
 
   public int getPort() {
     if (port == -1) throw new IllegalStateException("Cannot retrieve port before calling play()");
@@ -166,6 +167,27 @@
   }
 
   /**
+   * Indicates the protocols supported by NPN on incoming HTTPS connections.
+   * This list is ignored when npn is disabled.
+   *
+   * @param protocols the protocols to use, in order of preference. The list
+   *     must contain "http/1.1". It must not contain null.
+   */
+  public void setNpnProtocols(List<Protocol> protocols) {
+    protocols = Util.immutableList(protocols);
+    if (!protocols.contains(Protocol.HTTP_11)) {
+      throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
+    }
+    if (protocols.contains(null)) {
+      throw new IllegalArgumentException("protocols must not contain null");
+    }
+    if (protocols.contains(ByteString.EMPTY)) {
+      throw new IllegalArgumentException("protocols contains an empty string");
+    }
+    this.npnProtocols = Util.immutableList(protocols);
+  }
+
+  /**
    * Serve requests with HTTPS rather than otherwise.
    * @param tunnelProxy true to expect the HTTP CONNECT method before
    *     negotiating TLS.
@@ -304,8 +326,7 @@
           openClientSockets.put(socket, true);
 
           if (npnEnabled) {
-            // TODO: expose means to select which protocols to advertise.
-            Platform.get().setNpnProtocols(sslSocket, Protocol.HTTP2_SPDY3_AND_HTTP);
+            Platform.get().setNpnProtocols(sslSocket, npnProtocols);
           }
 
           sslSocket.startHandshake();
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index d9d3d3d..6ed031d 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -2834,10 +2834,11 @@
    * -Xbootclasspath/p:/tmp/npn-boot-8.1.2.v20120308.jar}
    */
   private void enableNpn(Protocol protocol) {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.setNpnEnabled(true);
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
     client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_11));
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.setNpnEnabled(true);
+    server.setNpnProtocols(client.getProtocols());
   }
 }
/Fim/
diff --git a/benchmarks/README.md b/benchmarks/README.md
new file mode 100644
index 0000000..59f571f
--- /dev/null
+++ b/benchmarks/README.md
@@ -0,0 +1,8 @@
+OkHttp Benchmarks
+=======================================
+
+This module allows you to test the performance of HTTP clients.
+
+### Running
+  1. If you made modifications to `com.squareup.okhttp.benchmarks.Benchmark` run `mvn compile`.
+  2. Run `mvn exec:exec` to launch a new JVM, which will execute the benchmark.
/Fim/
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index 14d93ee..cecf864 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -52,4 +52,30 @@
       <version>4.0.15.Final</version>
     </dependency>
   </dependencies>
+  <build>
+    <plugins>
+    <plugin>
+      <groupId>org.codehaus.mojo</groupId>
+      <artifactId>exec-maven-plugin</artifactId>
+      <executions>
+        <execution>
+          <goals>
+            <goal>java</goal>
+          </goals>
+        </execution>
+      </executions>
+      <configuration>
+        <executable>java</executable>
+        <arguments>
+          <argument>-Xms512m</argument>
+          <argument>-Xmx512m</argument>
+          <commandlineArgs>-Xbootclasspath/p:${settings.localRepository}/org/mortbay/jetty/npn/npn-boot/${npn.version}/npn-boot-${npn.version}.jar</commandlineArgs>
+          <argument>-classpath</argument>
+          <classpath/>
+          <argument>com.squareup.okhttp.benchmarks.Benchmark</argument>
+        </arguments>
+      </configuration>
+    </plugin>
+    </plugins>
+  </build>
 </project>
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
index 16bd063..fe23182 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
@@ -138,6 +138,7 @@
       SSLContext sslContext = SslContextBuilder.localhost();
       server.useHttps(sslContext.getSocketFactory(), false);
       server.setNpnEnabled(true);
+      server.setNpnProtocols(protocols);
     }
 
     final MockResponse response = newResponse();
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 90e2925..71c7c86 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -106,6 +106,7 @@
 
   private int port = -1;
   private boolean npnEnabled = true;
+  private List<Protocol> npnProtocols = Protocol.HTTP2_SPDY3_AND_HTTP;
 
   public int getPort() {
     if (port == -1) throw new IllegalStateException("Cannot retrieve port before calling play()");
@@ -166,6 +167,27 @@
   }
 
   /**
+   * Indicates the protocols supported by NPN on incoming HTTPS connections.
+   * This list is ignored when npn is disabled.
+   *
+   * @param protocols the protocols to use, in order of preference. The list
+   *     must contain "http/1.1". It must not contain null.
+   */
+  public void setNpnProtocols(List<Protocol> protocols) {
+    protocols = Util.immutableList(protocols);
+    if (!protocols.contains(Protocol.HTTP_11)) {
+      throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
+    }
+    if (protocols.contains(null)) {
+      throw new IllegalArgumentException("protocols must not contain null");
+    }
+    if (protocols.contains(ByteString.EMPTY)) {
+      throw new IllegalArgumentException("protocols contains an empty string");
+    }
+    this.npnProtocols = Util.immutableList(protocols);
+  }
+
+  /**
    * Serve requests with HTTPS rather than otherwise.
    * @param tunnelProxy true to expect the HTTP CONNECT method before
    *     negotiating TLS.
@@ -304,8 +326,7 @@
           openClientSockets.put(socket, true);
 
           if (npnEnabled) {
-            // TODO: expose means to select which protocols to advertise.
-            Platform.get().setNpnProtocols(sslSocket, Protocol.HTTP2_SPDY3_AND_HTTP);
+            Platform.get().setNpnProtocols(sslSocket, npnProtocols);
           }
 
           sslSocket.startHandshake();
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index d9d3d3d..6ed031d 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -2834,10 +2834,11 @@
    * -Xbootclasspath/p:/tmp/npn-boot-8.1.2.v20120308.jar}
    */
   private void enableNpn(Protocol protocol) {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.setNpnEnabled(true);
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
     client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_11));
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.setNpnEnabled(true);
+    server.setNpnProtocols(client.getProtocols());
   }
 }
/Fim/
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index cecf864..fb67f50 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -14,6 +14,11 @@
 
   <dependencies>
     <dependency>
+      <groupId>com.google.caliper</groupId>
+      <artifactId>caliper</artifactId>
+      <version>1.0-beta-1</version>
+    </dependency>
+    <dependency>
       <groupId>com.squareup.okhttp</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
@@ -51,6 +56,12 @@
       <artifactId>netty-codec-http</artifactId>
       <version>4.0.15.Final</version>
     </dependency>
+    <!-- Netty needs this if gzip is enabled. -->
+    <dependency>
+      <groupId>com.jcraft</groupId>
+      <artifactId>jzlib</artifactId>
+      <version>1.1.2</version>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java
index cd2cba3..cb8e719 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java
@@ -61,7 +61,6 @@
     }
 
     public void run() {
-      byte[] buffer = new byte[1024];
       long start = System.nanoTime();
       try {
         HttpResponse response = client.execute(new HttpGet(url.toString()));
@@ -71,12 +70,7 @@
           in = new GZIPInputStream(in);
         }
 
-        // Consume the response body.
-        int total = 0;
-        for (int count; (count = in.read(buffer)) != -1; ) {
-          total += count;
-        }
-        in.close();
+        long total = readAllAndClose(in);
         long finish = System.nanoTime();
 
         if (VERBOSE) {
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
index fe23182..fb4ecf1 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
@@ -15,6 +15,9 @@
  */
 package com.squareup.okhttp.benchmarks;
 
+import com.google.caliper.Param;
+import com.google.caliper.model.ArbitraryMeasurement;
+import com.google.caliper.runner.CaliperMain;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.mockwebserver.Dispatcher;
@@ -40,41 +43,57 @@
  * It uses a local connection to a MockWebServer to measure how many identical
  * requests per second can be carried over a fixed number of threads.
  */
-public class Benchmark {
+public class Benchmark extends com.google.caliper.Benchmark {
   private static final int NUM_REPORTS = 10;
+  private static final boolean VERBOSE = false;
+
   private final Random random = new Random(0);
 
   /** Which client to run.*/
-  HttpClient httpClient = new NettyHttpClient();
+  @Param
+  Client client;
 
   /** How many concurrent requests to execute. */
-  int concurrencyLevel = 10;
+  @Param({ "1", "10" })
+  int concurrencyLevel;
 
   /** True to use TLS. */
   // TODO: compare different ciphers?
-  boolean tls = false;
+  @Param
+  boolean tls;
 
   /** True to use gzip content-encoding for the response body. */
-  boolean gzip = false;
+  @Param
+  boolean gzip;
 
   /** Don't combine chunked with SPDY_3 or HTTP_2; that's not allowed. */
-  boolean chunked = false;
+  @Param
+  boolean chunked;
 
   /** The size of the HTTP response body, in uncompressed bytes. */
-  int bodyByteCount = 1024 * 1024;
+  @Param({ "128", "1048576" })
+  int bodyByteCount;
 
   /** How many additional headers were included, beyond the built-in ones. */
-  int headerCount = 20;
+  @Param({ "0", "20" })
+  int headerCount;
 
   /** Which ALPN/NPN protocols are in use. Only useful with TLS. */
   List<Protocol> protocols = Arrays.asList(Protocol.HTTP_11);
 
-  public static void main(String[] args) throws Exception {
-    new Benchmark().run();
+  public static void main(String[] args) {
+    List<String> allArgs = new ArrayList<String>();
+    allArgs.add("--instrument");
+    allArgs.add("arbitrary");
+    allArgs.addAll(Arrays.asList(args));
+
+    CaliperMain.main(Benchmark.class, allArgs.toArray(new String[allArgs.size()]));
   }
 
-  public void run() throws Exception {
-    System.out.println(toString());
+  @ArbitraryMeasurement(description = "requests per second")
+  public double run() throws Exception {
+    if (VERBOSE) System.out.println(toString());
+    HttpClient httpClient = client.create();
 
     // Prepare the client & server
     httpClient.prepare(this);
@@ -85,6 +104,7 @@
     long reportStart = System.nanoTime();
     long reportPeriod = TimeUnit.SECONDS.toNanos(1);
     int reports = 0;
+    double best = 0.0;
 
     // Run until we've printed enough reports.
     while (reports < NUM_REPORTS) {
@@ -93,7 +113,10 @@
       double reportDuration = now - reportStart;
       if (reportDuration > reportPeriod) {
         double requestsPerSecond = requestCount / reportDuration * TimeUnit.SECONDS.toNanos(1);
-        System.out.println(String.format("Requests per second: %.1f", requestsPerSecond));
+        if (VERBOSE) {
+          System.out.println(String.format("Requests per second: %.1f", requestsPerSecond));
+        }
+        best = Math.max(best, requestsPerSecond);
         requestCount = 0;
         reportStart = now;
         reports++;
@@ -108,6 +131,8 @@
       // The job queue is full. Take a break.
       sleep(10);
     }
+
+    return best;
   }
 
   @Override public String toString() {
@@ -117,10 +142,8 @@
     if (chunked) modifiers.add("chunked");
     modifiers.addAll(protocols);
 
-    return String.format("%s %s\n"
-        + "bodyByteCount=%s headerCount=%s concurrencyLevel=%s",
-        httpClient.getClass().getSimpleName(), modifiers,
-        bodyByteCount, headerCount, concurrencyLevel);
+    return String.format("%s %s\nbodyByteCount=%s headerCount=%s concurrencyLevel=%s",
+        client, modifiers, bodyByteCount, headerCount, concurrencyLevel);
   }
 
   private void sleep(int millis) {
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java
new file mode 100644
index 0000000..0f076a6
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+enum Client {
+  OkHttp {
+    @Override HttpClient create() {
+      return new OkHttp();
+    }
+  },
+
+  Apache {
+    @Override HttpClient create() {
+      return new ApacheHttpClient();
+    }
+  },
+
+  UrlConnection {
+    @Override HttpClient create() {
+      return new UrlConnection();
+    }
+  },
+
+  Netty {
+    @Override HttpClient create() {
+      return new NettyHttpClient();
+    }
+  };
+
+  abstract HttpClient create();
+}
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
index d5adec5..c3b0651 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
@@ -48,7 +48,7 @@
 import javax.net.ssl.SSLEngine;
 
 /** Netty isn't an HTTP client, but it's almost one. */
-public class NettyHttpClient implements HttpClient {
+class NettyHttpClient implements HttpClient {
   private static final boolean VERBOSE = false;
 
   // Guarded by this. Real apps need more capable connection management.
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
index 6fdb40e..03b9e3c 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
@@ -18,7 +18,6 @@
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.IOException;
-import java.io.InputStream;
 import java.net.HttpURLConnection;
 import java.net.URL;
 import java.util.concurrent.TimeUnit;
@@ -62,18 +61,10 @@
     }
 
     public void run() {
-      byte[] buffer = new byte[1024];
       long start = System.nanoTime();
       try {
         HttpURLConnection urlConnection = client.open(url);
-        InputStream in = urlConnection.getInputStream();
-
-        // Consume the response body.
-        int total = 0;
-        for (int count; (count = in.read(buffer)) != -1; ) {
-          total += count;
-        }
-        in.close();
+        long total = readAllAndClose(urlConnection.getInputStream());
         long finish = System.nanoTime();
 
         if (VERBOSE) {
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
index 9a0851c..f4bb02c 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
@@ -15,6 +15,8 @@
  */
 package com.squareup.okhttp.benchmarks;
 
+import java.io.IOException;
+import java.io.InputStream;
 import java.net.URL;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
@@ -38,5 +40,15 @@
     return executor.getQueue().size() < targetBacklog;
   }
 
+  protected long readAllAndClose(InputStream in) throws IOException {
+    byte[] buffer = new byte[1024];
+    long total = 0;
+    for (int count; (count = in.read(buffer)) != -1; ) {
+      total += count;
+    }
+    in.close();
+    return total;
+  }
+
   abstract Runnable request(URL url);
 }
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
index a2c3f3a..53d2a4b 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
@@ -58,7 +58,6 @@
     }
 
     public void run() {
-      byte[] buffer = new byte[1024];
       long start = System.nanoTime();
       try {
         HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
@@ -67,12 +66,7 @@
           in = new GZIPInputStream(in);
         }
 
-        // Consume the response body.
-        int total = 0;
-        for (int count; (count = in.read(buffer)) != -1; ) {
-          total += count;
-        }
-        in.close();
+        long total = readAllAndClose(in);
         long finish = System.nanoTime();
 
         if (VERBOSE) {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index fd465f9..307a4a5 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -317,6 +317,7 @@
     @Override public synchronized void connectionHeader() throws IOException {
       if (!client) return; // Nothing to write; servers don't send connection headers!
       out.write(CONNECTION_HEADER);
+      out.flush();
     }
 
     @Override
@@ -409,6 +410,7 @@
         out.writeInt(i & 0xffffff);
         out.writeInt(settings.get(i));
       }
+      out.flush();
     }
 
     @Override public synchronized void ping(boolean ack, int payload1, int payload2)
@@ -420,6 +422,7 @@
       frameHeader(length, type, flags, streamId);
       out.writeInt(payload1);
       out.writeInt(payload2);
+      out.flush();
     }
 
     @Override
@@ -436,6 +439,7 @@
       if (debugData.length > 0) {
         out.write(debugData);
       }
+      out.flush();
     }
 
     @Override public synchronized void windowUpdate(int streamId, long windowSizeIncrement)
@@ -449,6 +453,7 @@
       byte flags = FLAG_NONE;
       frameHeader(length, type, flags, streamId);
       out.writeInt((int) windowSizeIncrement);
+      out.flush();
     }
 
     @Override public void close() throws IOException {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index 393b6ee..7506044 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -369,7 +369,6 @@
       out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
       out.writeInt(streamId & 0x7fffffff);
       headerBlockBuffer.writeTo(out);
-      out.flush();
     }
 
     @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
index c3b0651..980367c 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
@@ -19,9 +19,11 @@
 import com.squareup.okhttp.internal.Util;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.PooledByteBufAllocator;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.SimpleChannelInboundHandler;
@@ -81,6 +83,7 @@
     EventLoopGroup group = new NioEventLoopGroup();
     bootstrap = new Bootstrap();
     bootstrap.group(group)
+        .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
         .channel(NioSocketChannel.class)
         .handler(channelInitializer);
   }
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
index fb4ecf1..151128d 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
@@ -57,6 +57,10 @@
   @Param({ "1", "10" })
   int concurrencyLevel;
 
+  /** How many requests to enqueue to await threads to execute them. */
+  @Param({ "10" })
+  int targetBacklog;
+
   /** True to use TLS. */
   // TODO: compare different ciphers?
   @Param
@@ -129,7 +133,7 @@
       }
 
       // The job queue is full. Take a break.
-      sleep(10);
+      sleep(1);
     }
 
     return best;
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java
index 0f076a6..bd777aa 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java
@@ -22,6 +22,12 @@
     }
   },
 
+  OkHttpAsync {
+    @Override HttpClient create() {
+      return new OkHttpAsync();
+    }
+  },
+
   Apache {
     @Override HttpClient create() {
       return new ApacheHttpClient();
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
index 980367c..9044d0a 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
@@ -25,7 +25,6 @@
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.ChannelPipeline;
-import io.netty.channel.EventLoopGroup;
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.SocketChannel;
@@ -43,8 +42,8 @@
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.ssl.SslHandler;
 import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
+import java.util.ArrayDeque;
+import java.util.Deque;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLEngine;
@@ -54,14 +53,17 @@
   private static final boolean VERBOSE = false;
 
   // Guarded by this. Real apps need more capable connection management.
-  private final List<HttpChannel> freeChannels = new ArrayList<HttpChannel>();
-  private int totalChannels = 0;
+  private final Deque<HttpChannel> freeChannels = new ArrayDeque<HttpChannel>();
+  private final Deque<URL> backlog = new ArrayDeque<URL>();
 
+  private int totalChannels = 0;
   private int concurrencyLevel;
+  private int targetBacklog;
   private Bootstrap bootstrap;
 
   @Override public void prepare(final Benchmark benchmark) {
     this.concurrencyLevel = benchmark.concurrencyLevel;
+    this.targetBacklog = benchmark.targetBacklog;
 
     ChannelInitializer<SocketChannel> channelInitializer = new ChannelInitializer<SocketChannel>() {
       @Override public void initChannel(SocketChannel channel) throws Exception {
@@ -80,38 +82,55 @@
       }
     };
 
-    EventLoopGroup group = new NioEventLoopGroup();
     bootstrap = new Bootstrap();
-    bootstrap.group(group)
+    bootstrap.group(new NioEventLoopGroup(concurrencyLevel))
         .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
         .channel(NioSocketChannel.class)
         .handler(channelInitializer);
   }
 
   @Override public void enqueue(URL url) throws Exception {
-    acquireChannel(url).sendRequest(url);
+    HttpChannel httpChannel = null;
+    synchronized (this) {
+      if (!freeChannels.isEmpty()) {
+        httpChannel = freeChannels.pop();
+      } else if (totalChannels < concurrencyLevel) {
+        totalChannels++; // Create a new channel. (outside of the synchronized block).
+      } else {
+        backlog.add(url); // Enqueue this for later, to be picked up when another request completes.
+        return;
+      }
+    }
+    if (httpChannel == null) {
+      Channel channel = bootstrap.connect(url.getHost(), Util.getEffectivePort(url))
+          .sync().channel();
+      httpChannel = (HttpChannel) channel.pipeline().last();
+    }
+    httpChannel.sendRequest(url);
   }
 
   @Override public synchronized boolean acceptingJobs() {
+    return backlog.size() < targetBacklog || hasFreeChannels();
+  }
+
+  private boolean hasFreeChannels() {
     int activeChannels = totalChannels - freeChannels.size();
     return activeChannels < concurrencyLevel;
   }
 
-  private HttpChannel acquireChannel(URL url) throws InterruptedException {
+  private void release(HttpChannel httpChannel) {
+    URL url;
     synchronized (this) {
-      if (!freeChannels.isEmpty()) {
-        return freeChannels.remove(freeChannels.size() - 1);
-      } else {
-        totalChannels++;
+      url = backlog.pop();
+      if (url == null) {
+        // There were no URLs in the backlog. Pool this channel for later.
+        freeChannels.push(httpChannel);
+        return;
       }
     }
 
-    Channel channel = bootstrap.connect(url.getHost(), Util.getEffectivePort(url)).sync().channel();
-    return (HttpChannel) channel.pipeline().last();
-  }
-
-  private synchronized void release(HttpChannel httpChannel) {
-    freeChannels.add(httpChannel);
+    // We removed a URL from the backlog. Schedule it right away.
+    httpChannel.sendRequest(url);
   }
 
   class HttpChannel extends SimpleChannelInboundHandler<HttpObject> {
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
new file mode 100644
index 0000000..b7633b7
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.squareup.okhttp.Dispatcher;
+import com.squareup.okhttp.Failure;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import java.io.IOException;
+import java.net.URL;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+
+class OkHttpAsync implements HttpClient {
+  private static final boolean VERBOSE = false;
+
+  private final AtomicInteger requestsInFlight = new AtomicInteger();
+
+  private OkHttpClient client;
+  private Response.Receiver receiver;
+  private int concurrencyLevel;
+  private int targetBacklog;
+
+  @Override public void prepare(final Benchmark benchmark) {
+    concurrencyLevel = benchmark.concurrencyLevel;
+    targetBacklog = benchmark.targetBacklog;
+
+    client = new OkHttpClient();
+    client.setProtocols(benchmark.protocols);
+    client.setDispatcher(new Dispatcher(new ThreadPoolExecutor(benchmark.concurrencyLevel,
+        benchmark.concurrencyLevel, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>())));
+
+    if (benchmark.tls) {
+      SSLContext sslContext = SslContextBuilder.localhost();
+      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
+        @Override public boolean verify(String s, SSLSession session) {
+          return true;
+        }
+      };
+      client.setSslSocketFactory(socketFactory);
+      client.setHostnameVerifier(hostnameVerifier);
+    }
+
+    receiver = new Response.Receiver() {
+      @Override public void onFailure(Failure failure) {
+        System.out.println("Failed: " + failure.exception());
+      }
+
+      @Override public boolean onResponse(Response response) throws IOException {
+        Response.Body body = response.body();
+        long total = SynchronousHttpClient.readAllAndClose(body.byteStream());
+        long finish = System.nanoTime();
+        if (VERBOSE) {
+          long start = (Long) response.request().tag();
+          System.out.printf("Transferred % 8d bytes in %4d ms%n",
+              total, TimeUnit.NANOSECONDS.toMillis(finish - start));
+        }
+        requestsInFlight.decrementAndGet();
+        return true;
+      }
+    };
+  }
+
+  @Override public void enqueue(URL url) throws Exception {
+    requestsInFlight.incrementAndGet();
+    client.enqueue(new Request.Builder().tag(System.nanoTime()).url(url).build(), receiver);
+  }
+
+  @Override public synchronized boolean acceptingJobs() {
+    return requestsInFlight.get() < (concurrencyLevel + targetBacklog);
+  }
+}
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
index f4bb02c..b15eedc 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
@@ -24,10 +24,11 @@
 
 /** Any HTTP client with a blocking API. */
 abstract class SynchronousHttpClient implements HttpClient {
-  int targetBacklog = 10;
   ThreadPoolExecutor executor;
+  int targetBacklog;
 
   @Override public void prepare(Benchmark benchmark) {
+    this.targetBacklog = benchmark.targetBacklog;
     executor = new ThreadPoolExecutor(benchmark.concurrencyLevel, benchmark.concurrencyLevel,
         1, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
   }
@@ -40,7 +41,7 @@
     return executor.getQueue().size() < targetBacklog;
   }
 
-  protected long readAllAndClose(InputStream in) throws IOException {
+  static long readAllAndClose(InputStream in) throws IOException {
     byte[] buffer = new byte[1024];
     long total = 0;
     for (int count; (count = in.read(buffer)) != -1; ) {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
index eee2295..ed4ba10 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -293,7 +293,9 @@
           byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invoke(socket);
           if (alpnResult != null) return ByteString.of(alpnResult);
         }
-        return ByteString.of((byte[]) getNpnSelectedProtocol.invoke(socket));
+        byte[] npnResult = (byte[]) getNpnSelectedProtocol.invoke(socket);
+        if (npnResult == null) return null;
+        return ByteString.of(npnResult);
       } catch (InvocationTargetException e) {
         throw new RuntimeException(e);
       } catch (IllegalAccessException e) {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
index 75d305c..14fa221 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
@@ -109,7 +109,7 @@
     // |ID1|ID2|CM |FLG|     MTIME     |XFL|OS | (more-->)
     // +---+---+---+---+---+---+---+---+---+---+
     require(10, deadline);
-    byte flags = buffer.byteAt(3);
+    byte flags = buffer.getByte(3);
     boolean fhcrc = ((flags >> FHCRC) & 1) == 1;
     if (fhcrc) updateCrc(buffer, 0, 10);
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
index d4cb511..cf6ddbd 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
@@ -76,7 +76,7 @@
   }
 
   /** Returns the byte at {@code i}. */
-  public byte byteAt(long i) {
+  public byte getByte(long i) {
     checkOffsetAndCount(byteCount, i, 1);
     for (Segment s = head; true; s = s.next) {
       int segmentByteCount = s.limit - s.pos;
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
index 909d9f7..595ae4a 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
@@ -516,17 +516,17 @@
     buffer.writeUtf8("a");
     buffer.writeUtf8(repeat('b', Segment.SIZE));
     buffer.writeUtf8("c");
-    assertEquals('a', buffer.byteAt(0));
-    assertEquals('a', buffer.byteAt(0)); // Peek doesn't mutate!
-    assertEquals('c', buffer.byteAt(buffer.byteCount - 1));
-    assertEquals('b', buffer.byteAt(buffer.byteCount - 2));
-    assertEquals('b', buffer.byteAt(buffer.byteCount - 3));
+    assertEquals('a', buffer.getByte(0));
+    assertEquals('a', buffer.getByte(0)); // getByte doesn't mutate!
+    assertEquals('c', buffer.getByte(buffer.byteCount - 1));
+    assertEquals('b', buffer.getByte(buffer.byteCount - 2));
+    assertEquals('b', buffer.getByte(buffer.byteCount - 3));
   }
 
-  @Test public void byteAtOfEmptyBuffer() throws Exception {
+  @Test public void getByteOfEmptyBuffer() throws Exception {
     OkBuffer buffer = new OkBuffer();
     try {
-      buffer.byteAt(0);
+      buffer.getByte(0);
       fail();
     } catch (IndexOutOfBoundsException expected) {
     }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
index 14fa221..c6cf1c4 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
@@ -135,7 +135,7 @@
     // |...original file name, zero-terminated...| (more-->)
     // +=========================================+
     if (((flags >> FNAME) & 1) == 1) {
-      long index = seek((byte) 0, deadline);
+      long index = OkBuffers.seek(buffer, (byte) 0, source, deadline);
       if (fhcrc) updateCrc(buffer, 0, index + 1);
       buffer.skip(index + 1);
     }
@@ -145,7 +145,7 @@
     // |...file comment, zero-terminated...| (more-->)
     // +===================================+
     if (((flags >> FCOMMENT) & 1) == 1) {
-      long index = seek((byte) 0, deadline);
+      long index = OkBuffers.seek(buffer, (byte) 0, source, deadline);
       if (fhcrc) updateCrc(buffer, 0, index + 1);
       buffer.skip(index + 1);
     }
@@ -194,21 +194,10 @@
     }
   }
 
-  /** Returns the next index of {@code b}, reading data into the buffer as necessary. */
-  private long seek(byte b, Deadline deadline) throws IOException {
-    long start = 0;
-    long index;
-    while ((index = buffer.indexOf(b, start)) == -1) {
-      start = buffer.byteCount;
-      if (source.read(buffer, Segment.SIZE, deadline) == -1) throw new EOFException();
-    }
-    return index;
-  }
-
   private void checkEqual(String name, int expected, int actual) throws IOException {
     if (actual != expected) {
       throw new IOException(String.format(
-          "%s: actual %#08x != expected %#08x", name, actual, expected));
+          "%s: actual 0x%08x != expected 0x%08x", name, actual, expected));
     }
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
index cf6ddbd..ecea127 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
@@ -21,6 +21,7 @@
 import java.util.Collections;
 import java.util.List;
 
+import static com.squareup.okhttp.internal.Util.UTF_8;
 import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
 
 /**
@@ -165,7 +166,25 @@
 
   /** Removes {@code byteCount} bytes from this, decodes them as UTF-8 and returns the string. */
   public String readUtf8(int byteCount) {
-    return new String(readBytes(byteCount), Util.UTF_8);
+    checkOffsetAndCount(this.byteCount, 0, byteCount);
+    if (byteCount == 0) return "";
+
+    Segment head = this.head;
+    if (head.pos + byteCount > head.limit) {
+      // If the string spans multiple segments, delegate to readBytes().
+      return new String(readBytes(byteCount), Util.UTF_8);
+    }
+
+    String result = new String(head.data, head.pos, byteCount, UTF_8);
+    head.pos += byteCount;
+    this.byteCount -= byteCount;
+
+    if (head.pos == head.limit) {
+      this.head = head.pop();
+      SegmentPool.INSTANCE.recycle(head);
+    }
+
+    return result;
   }
 
   private byte[] readBytes(int byteCount) {
@@ -354,8 +373,8 @@
     while (byteCount > 0) {
       // Is a prefix of the source's head segment all that we need to move?
       if (byteCount < (source.head.limit - source.head.pos)) {
-        Segment tail = head.prev;
-        if (byteCount + (tail.limit - tail.pos) > Segment.SIZE) {
+        Segment tail = head != null ? head.prev : null;
+        if (tail == null || byteCount + (tail.limit - tail.pos) > Segment.SIZE) {
           // We're going to need another segment. Split the source's head
           // segment in two, then move the first of those two to this buffer.
           source.head = source.head.split((int) byteCount);
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java
index 230ab4c..d5d88cd 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp.internal.bytes;
 
+import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -25,6 +26,22 @@
   private OkBuffers() {
   }
 
+  /**
+   * Returns the index of {@code b} in {@code buffer}, refilling it if necessary
+   * until it is found. This reads an unbounded number of bytes into {@code
+   * buffer}.
+   */
+  public static long seek(OkBuffer buffer, byte b, Source source, Deadline deadline)
+      throws IOException {
+    long start = 0;
+    long index;
+    while ((index = buffer.indexOf(b, start)) == -1) {
+      start = buffer.byteCount;
+      if (source.read(buffer, Segment.SIZE, deadline) == -1) throw new EOFException();
+    }
+    return index;
+  }
+
   /** Returns a sink that writes to {@code out}. */
   public static Sink sink(final OutputStream out) {
     return new Sink() {
@@ -148,7 +165,7 @@
           long count = source.read(buffer, Segment.SIZE, Deadline.NONE);
           if (count == -1) return -1;
         }
-        return buffer.readByte();
+        return buffer.readByte() & 0xff;
       }
 
       @Override public int read(byte[] data, int offset, int byteCount) throws IOException {
@@ -179,7 +196,7 @@
       }
 
       @Override public void close() throws IOException {
-        super.close();
+        source.close(Deadline.NONE);
       }
 
       @Override public String toString() {
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java
index cafe6c4..d4b59b6 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java
@@ -115,7 +115,7 @@
       gunzip(gzipped);
       fail();
     } catch (IOException e) {
-      assertEquals("FHCRC: actual 0x00261d != expected 0x000000", e.getMessage());
+      assertEquals("FHCRC: actual 0x0000261d != expected 0x00000000", e.getMessage());
     }
   }
 
@@ -130,7 +130,7 @@
       gunzip(gzipped);
       fail();
     } catch (IOException e) {
-      assertEquals("CRC: actual 0x37ad8f8d != expected 0x1234567", e.getMessage());
+      assertEquals("CRC: actual 0x37ad8f8d != expected 0x01234567", e.getMessage());
     }
   }
 
@@ -145,7 +145,7 @@
       gunzip(gzipped);
       fail();
     } catch (IOException e) {
-      assertEquals("ISIZE: actual 0x000020 != expected 0x123456", e.getMessage());
+      assertEquals("ISIZE: actual 0x00000020 != expected 0x00123456", e.getMessage());
     }
   }
 
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
index 595ae4a..443e24b 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
@@ -47,6 +47,19 @@
     }
   }
 
+  @Test public void readUtf8SpansSegments() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(repeat('a', Segment.SIZE * 2));
+    buffer.readUtf8(Segment.SIZE - 1);
+    assertEquals("aa", buffer.readUtf8(2));
+  }
+
+  @Test public void readUtf8EntireBuffer() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(repeat('a', Segment.SIZE));
+    assertEquals(repeat('a', Segment.SIZE), buffer.readUtf8(Segment.SIZE));
+  }
+
   @Test public void bufferToString() throws Exception {
     OkBuffer buffer = new OkBuffer();
     buffer.writeUtf8("\u0000\u0001\u0002\u007f");
@@ -465,8 +478,8 @@
   @Test public void readByte() throws Exception {
     OkBuffer data = new OkBuffer();
     data.write(new ByteString(new byte[] { (byte) 0xab, (byte) 0xcd }));
-    assertEquals((byte) 0xab, data.readByte());
-    assertEquals((byte) 0xcd, data.readByte());
+    assertEquals(0xab, data.readByte() & 0xff);
+    assertEquals(0xcd, data.readByte() & 0xff);
     assertEquals(0, data.byteCount());
   }
 
@@ -538,13 +551,21 @@
     buffer.writeUtf8(repeat('b', Segment.SIZE));
     buffer.writeUtf8("c");
     buffer.skip(1);
-    assertEquals('b', buffer.readByte());
+    assertEquals('b', buffer.readByte() & 0xff);
     buffer.skip(Segment.SIZE - 2);
-    assertEquals('b', buffer.readByte());
+    assertEquals('b', buffer.readByte() & 0xff);
     buffer.skip(1);
     assertEquals(0, buffer.byteCount());
   }
 
+  @Test public void testWritePrefixToEmptyBuffer() {
+    OkBuffer sink = new OkBuffer();
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8("abcd");
+    sink.write(source, 2, Deadline.NONE);
+    assertEquals("ab", sink.readUtf8(2));
+  }
+
   private String repeat(char c, int count) {
     char[] array = new char[count];
     Arrays.fill(array, c);
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSource.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSource.java
new file mode 100644
index 0000000..96063d5
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSource.java
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+
+import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
+
+/**
+ * A source that keeps a buffer internally so that callers can do small reads
+ * without a performance penalty.
+ */
+public final class BufferedSource implements Source {
+  public final OkBuffer buffer;
+  public final Source source;
+  private boolean closed;
+
+  public BufferedSource(Source source, OkBuffer buffer) {
+    this.buffer = buffer;
+    this.source = source;
+  }
+
+  @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
+      throws IOException {
+    if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+    if (closed) throw new IllegalStateException("closed");
+
+    if (buffer.byteCount == 0) {
+      long read = source.read(buffer, Segment.SIZE, deadline);
+      if (read == -1) return -1;
+    }
+
+    long toRead = Math.min(byteCount, buffer.byteCount);
+    return buffer.read(sink, toRead, deadline);
+  }
+
+  /**
+   * Returns true if there are no more bytes in the buffer or the source. This
+   * will block until there are bytes to read or the source is definitely
+   * exhausted.
+   */
+  public boolean exhausted() throws IOException {
+    return buffer.byteCount() == 0 && source.read(buffer, Segment.SIZE, Deadline.NONE) == -1;
+  }
+
+  /**
+   * Returns when the buffer contains at least {@code byteCount} bytes. Throws
+   * an {@link EOFException} if the source is exhausted before the required
+   * bytes can be read.
+   */
+  void require(long byteCount, Deadline deadline) throws IOException {
+    while (buffer.byteCount < byteCount) {
+      if (source.read(buffer, Segment.SIZE, deadline) == -1) throw new EOFException();
+    }
+  }
+
+  public byte readByte() throws IOException {
+    require(1, Deadline.NONE);
+    return buffer.readByte();
+  }
+
+  public ByteString readByteString(int byteCount) throws IOException {
+    require(byteCount, Deadline.NONE);
+    return buffer.readByteString(byteCount);
+  }
+
+  public short readShort() throws IOException {
+    require(2, Deadline.NONE);
+    return buffer.readShort();
+  }
+
+  public int readInt() throws IOException {
+    require(4, Deadline.NONE);
+    return buffer.readInt();
+  }
+
+  /**
+   * Reads and discards {@code byteCount} bytes from {@code source} using {@code
+   * buffer} as a buffer. Throws an {@link EOFException} if the source is
+   * exhausted before the requested bytes can be skipped.
+   */
+  public void skip(long byteCount, Deadline deadline) throws IOException {
+    while (byteCount > 0) {
+      if (buffer.byteCount == 0 && source.read(buffer, Segment.SIZE, deadline) == -1) {
+        throw new EOFException();
+      }
+      long toSkip = Math.min(byteCount, buffer.byteCount());
+      buffer.skip(toSkip);
+      byteCount -= toSkip;
+    }
+  }
+
+  /** Returns an input stream that reads from this source. */
+  public InputStream inputStream() {
+    return new InputStream() {
+      @Override public int read() throws IOException {
+        if (buffer.byteCount == 0) {
+          long count = source.read(buffer, Segment.SIZE, Deadline.NONE);
+          if (count == -1) return -1;
+        }
+        return buffer.readByte() & 0xff;
+      }
+
+      @Override public int read(byte[] data, int offset, int byteCount) throws IOException {
+        checkOffsetAndCount(data.length, offset, byteCount);
+
+        if (buffer.byteCount == 0) {
+          long count = source.read(buffer, Segment.SIZE, Deadline.NONE);
+          if (count == -1) return -1;
+        }
+
+        Segment head = buffer.head;
+        int toCopy = Math.min(byteCount, head.limit - head.pos);
+        System.arraycopy(head.data, head.pos, data, offset, toCopy);
+
+        head.pos += toCopy;
+        buffer.byteCount -= toCopy;
+
+        if (head.pos == head.limit) {
+          buffer.head = head.pop();
+          SegmentPool.INSTANCE.recycle(head);
+        }
+
+        return toCopy;
+      }
+
+      @Override public int available() throws IOException {
+        return (int) Math.min(buffer.byteCount, Integer.MAX_VALUE);
+      }
+
+      @Override public void close() throws IOException {
+        BufferedSource.this.close(Deadline.NONE);
+      }
+
+      @Override public String toString() {
+        return BufferedSource.this.toString() + ".inputStream()";
+      }
+    };
+  }
+
+  @Override public void close(Deadline deadline) throws IOException {
+    if (closed) return;
+    closed = true;
+    source.close(deadline);
+    buffer.clear();
+  }
+
+  @Override public String toString() {
+    return "BufferedSource(" + source + ")";
+  }
+}
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
index ecea127..8352908 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
@@ -367,7 +367,9 @@
     // an equivalent buffer [30%, 62%, 82%] and then move the head segment,
     // yielding sink [51%, 91%, 30%] and source [62%, 82%].
 
-    if (source == this) throw new IllegalArgumentException("source == this");
+    if (source == this) {
+      throw new IllegalArgumentException("source == this");
+    }
     checkOffsetAndCount(source.byteCount, 0, byteCount);
 
     while (byteCount > 0) {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java
index c6f4af8..ff4775c 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java
@@ -42,35 +42,6 @@
     return index;
   }
 
-  /**
-   * Returns when {@code sink} contains at least {@code byteCount} bytes. Throws
-   * an {@link EOFException} if the source is exhausted before the requested
-   * bytes can be read.
-   */
-  public static void require(Source source, OkBuffer sink, long byteCount, Deadline deadline)
-      throws IOException {
-    while (sink.byteCount < byteCount) {
-      if (source.read(sink, Segment.SIZE, deadline) == -1) throw new EOFException();
-    }
-  }
-
-  /**
-   * Reads and discards {@code byteCount} bytes from {@code source} using {@code
-   * buffer} as a buffer. Throws an {@link EOFException} if the source is
-   * exhausted before the requested bytes can be skipped.
-   */
-  public static void skip(Source source, OkBuffer buffer, long byteCount, Deadline deadline)
-      throws IOException {
-    while (byteCount > 0) {
-      if (buffer.byteCount == 0 && source.read(buffer, Segment.SIZE, deadline) == -1) {
-        throw new EOFException();
-      }
-      long toSkip = Math.min(byteCount, buffer.byteCount());
-      buffer.skip(toSkip);
-      byteCount -= toSkip;
-    }
-  }
-
   /** Returns a sink that writes to {@code out}. */
   public static Sink sink(final OutputStream out) {
     return new Sink() {
@@ -180,65 +151,4 @@
       }
     };
   }
-
-  /**
-   * Returns an input stream that reads from {@code source}. This may buffer
-   * data by reading extra data eagerly.
-   */
-  public static InputStream inputStream(final Source source) {
-    return inputStream(source, new OkBuffer());
-  }
-
-  /**
-   * Returns a buffered input stream that reads from {@code source}, with {@code
-   * buffer} as a buffer. Bytes are drawn from {@code buffer}, which is refilled
-   * from {@code source} when it is empty. This may read extra data eagerly into
-   * {@code buffer}.
-   */
-  public static InputStream inputStream(final Source source, final OkBuffer buffer) {
-    return new InputStream() {
-      @Override public int read() throws IOException {
-        if (buffer.byteCount == 0) {
-          long count = source.read(buffer, Segment.SIZE, Deadline.NONE);
-          if (count == -1) return -1;
-        }
-        return buffer.readByte() & 0xff;
-      }
-
-      @Override public int read(byte[] data, int offset, int byteCount) throws IOException {
-        checkOffsetAndCount(data.length, offset, byteCount);
-
-        if (buffer.byteCount == 0) {
-          long count = source.read(buffer, Segment.SIZE, Deadline.NONE);
-          if (count == -1) return -1;
-        }
-
-        Segment head = buffer.head;
-        int toCopy = Math.min(byteCount, head.limit - head.pos);
-        System.arraycopy(head.data, head.pos, data, offset, toCopy);
-
-        head.pos += toCopy;
-        buffer.byteCount -= toCopy;
-
-        if (head.pos == head.limit) {
-          buffer.head = head.pop();
-          SegmentPool.INSTANCE.recycle(head);
-        }
-
-        return toCopy;
-      }
-
-      @Override public int available() throws IOException {
-        return (int) Math.min(buffer.byteCount, Integer.MAX_VALUE);
-      }
-
-      @Override public void close() throws IOException {
-        source.close(Deadline.NONE);
-      }
-
-      @Override public String toString() {
-        return "inputStream(" + source + ")";
-      }
-    };
-  }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index 1f0ea21..9aaf3c6 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -1,10 +1,9 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.BitArray;
+import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
-import com.squareup.okhttp.internal.bytes.Deadline;
 import com.squareup.okhttp.internal.bytes.OkBuffer;
-import com.squareup.okhttp.internal.bytes.OkBuffers;
 import com.squareup.okhttp.internal.bytes.Source;
 import java.io.IOException;
 import java.io.OutputStream;
@@ -100,8 +99,7 @@
     private final Huffman.Codec huffmanCodec;
 
     private final List<Header> emittedHeaders = new ArrayList<Header>();
-    private final Source source;
-    private final OkBuffer buffer = new OkBuffer();
+    private final BufferedSource source;
     private int maxHeaderTableByteCount;
 
     // Visible for testing.
@@ -127,7 +125,7 @@
     Reader(boolean client, int maxHeaderTableByteCount, Source source) {
       this.huffmanCodec = client ? Huffman.Codec.RESPONSE : Huffman.Codec.REQUEST;
       this.maxHeaderTableByteCount = maxHeaderTableByteCount;
-      this.source = source;
+      this.source = new BufferedSource(source, new OkBuffer());
     }
 
     int maxHeaderTableByteCount() {
@@ -182,9 +180,8 @@
      * set of emitted headers.
      */
     void readHeaders() throws IOException {
-      while (buffer.byteCount() > 0
-          || source.read(buffer, 2048, Deadline.NONE) != -1) {
-        int b = buffer.readByte() & 0xff;
+      while (!source.exhausted()) {
+        int b = source.readByte() & 0xff;
         if (b == 0x80) { // 10000000
           clearReferenceSet();
         } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
@@ -335,8 +332,7 @@
     }
 
     private int readByte() throws IOException {
-      OkBuffers.require(source, buffer, 1, Deadline.NONE);
-      return buffer.readByte() & 0xff;
+      return source.readByte() & 0xff;
     }
 
     int readInt(int firstByte, int prefixMask) throws IOException {
@@ -375,8 +371,7 @@
         huffmanDecode = true;
       }
 
-      OkBuffers.require(source, buffer, length, Deadline.NONE);
-      ByteString byteString = buffer.readByteString(length);
+      ByteString byteString = source.readByteString(length);
 
       if (huffmanDecode) {
         byteString = huffmanCodec.decode(byteString); // TODO: streaming Huffman!
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index 365f4a7..98b8c7f 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -16,6 +16,7 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.bytes.Deadline;
 import com.squareup.okhttp.internal.bytes.OkBuffer;
@@ -68,8 +69,7 @@
   }
 
   static final class Reader implements FrameReader {
-    private final OkBuffer buffer = new OkBuffer();
-    private final Source source;
+    private final BufferedSource source;
     private final ContinuationSource continuation;
     private final boolean client;
 
@@ -77,29 +77,29 @@
     final HpackDraft05.Reader hpackReader;
 
     Reader(Source source, int headerTableSize, boolean client) {
-      this.source = source;
+      this.source = new BufferedSource(source, new OkBuffer());
       this.client = client;
-      this.continuation = new ContinuationSource(source, buffer);
+      this.continuation = new ContinuationSource(this.source);
       this.hpackReader = new HpackDraft05.Reader(client, headerTableSize, continuation);
     }
 
     @Override public void readConnectionHeader() throws IOException {
       if (client) return; // Nothing to read; servers don't send connection headers!
-      OkBuffers.require(source, buffer, CONNECTION_HEADER.size(), Deadline.NONE);
-      ByteString connectionHeader = buffer.readByteString(CONNECTION_HEADER.size());
+      ByteString connectionHeader = source.readByteString(CONNECTION_HEADER.size());
       if (!CONNECTION_HEADER.equals(connectionHeader)) {
         throw ioException("Expected a connection header but was %s", connectionHeader.utf8());
       }
     }
 
     @Override public boolean nextFrame(Handler handler) throws IOException {
+      int w1;
+      int w2;
       try {
-        OkBuffers.require(source, buffer, 8, Deadline.NONE);
+        w1 = source.readInt();
+        w2 = source.readInt();
       } catch (IOException e) {
         return false; // This might be a normal socket close.
       }
-      int w1 = buffer.readInt();
-      int w2 = buffer.readInt();
 
       // boolean r = (w1 & 0xc0000000) != 0; // Reserved: Ignore first 2 bits.
       short length = (short) ((w1 & 0x3fff0000) >> 16); // 14-bit unsigned == max 16383
@@ -147,7 +147,7 @@
 
         default:
           // Implementations MUST ignore frames of unsupported or unrecognized types.
-          OkBuffers.skip(source, buffer, length, Deadline.NONE);
+          source.skip(length, Deadline.NONE);
       }
       return true;
     }
@@ -160,8 +160,7 @@
 
       int priority = -1;
       if ((flags & FLAG_PRIORITY) != 0) {
-        OkBuffers.require(source, buffer, 4, Deadline.NONE);
-        priority = buffer.readInt() & 0x7fffffff;
+        priority = source.readInt() & 0x7fffffff;
         length -= 4; // account for above read.
       }
 
@@ -188,15 +187,14 @@
         throws IOException {
       boolean inFinished = (flags & FLAG_END_STREAM) != 0;
       // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
-      handler.data(inFinished, streamId, OkBuffers.inputStream(source, buffer), length);
+      handler.data(inFinished, streamId, source.inputStream(), length);
     }
 
     private void readPriority(Handler handler, short length, byte flags, int streamId)
         throws IOException {
       if (length != 4) throw ioException("TYPE_PRIORITY length: %d != 4", length);
       if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
-      OkBuffers.require(source, buffer, 4, Deadline.NONE);
-      int w1 = buffer.readInt();
+      int w1 = source.readInt();
       // boolean r = (w1 & 0x80000000) != 0; // Reserved.
       int priority = (w1 & 0x7fffffff);
       handler.priority(streamId, priority);
@@ -206,8 +204,7 @@
         throws IOException {
       if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
       if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
-      OkBuffers.require(source, buffer, 4, Deadline.NONE);
-      int errorCodeInt = buffer.readInt();
+      int errorCodeInt = source.readInt();
       ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
       if (errorCode == null) {
         throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
@@ -226,10 +223,9 @@
 
       if (length % 8 != 0) throw ioException("TYPE_SETTINGS length %% 8 != 0: %s", length);
       Settings settings = new Settings();
-      OkBuffers.require(source, buffer, length, Deadline.NONE);
       for (int i = 0; i < length; i += 8) {
-        int w1 = buffer.readInt();
-        int value = buffer.readInt();
+        int w1 = source.readInt();
+        int value = source.readInt();
         // int r = (w1 & 0xff000000) >>> 24; // Reserved.
         int id = w1 & 0xffffff;
         settings.set(id, 0, value);
@@ -245,8 +241,7 @@
       if (streamId == 0) {
         throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
       }
-      OkBuffers.require(source, buffer, 4, Deadline.NONE);
-      int promisedStreamId = buffer.readInt() & 0x7fffffff;
+      int promisedStreamId = source.readInt() & 0x7fffffff;
       length -= 4; // account for above read.
       List<Header> headerBlock = readHeaderBlock(length, flags, streamId);
       handler.pushPromise(streamId, promisedStreamId, headerBlock);
@@ -256,9 +251,8 @@
         throws IOException {
       if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
       if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
-      OkBuffers.require(source, buffer, 8, Deadline.NONE);
-      int payload1 = buffer.readInt();
-      int payload2 = buffer.readInt();
+      int payload1 = source.readInt();
+      int payload2 = source.readInt();
       boolean ack = (flags & FLAG_ACK) != 0;
       handler.ping(ack, payload1, payload2);
     }
@@ -267,9 +261,8 @@
         throws IOException {
       if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
       if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
-      OkBuffers.require(source, buffer, 8, Deadline.NONE);
-      int lastStreamId = buffer.readInt();
-      int errorCodeInt = buffer.readInt();
+      int lastStreamId = source.readInt();
+      int errorCodeInt = source.readInt();
       int opaqueDataLength = length - 8;
       ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
       if (errorCode == null) {
@@ -277,8 +270,7 @@
       }
       ByteString debugData = ByteString.EMPTY;
       if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
-        OkBuffers.require(source, buffer, opaqueDataLength, Deadline.NONE);
-        debugData = buffer.readByteString(opaqueDataLength);
+        debugData = source.readByteString(opaqueDataLength);
       }
       handler.goAway(lastStreamId, errorCode, debugData);
     }
@@ -286,8 +278,7 @@
     private void readWindowUpdate(Handler handler, short length, byte flags, int streamId)
         throws IOException {
       if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
-      OkBuffers.require(source, buffer, 4, Deadline.NONE);
-      long increment = (buffer.readInt() & 0x7fffffff);
+      long increment = (source.readInt() & 0x7fffffff);
       if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
       handler.windowUpdate(streamId, increment);
     }
@@ -490,8 +481,7 @@
    * HpackDraft05.Reader#readHeaders()}.
    */
   static final class ContinuationSource implements Source {
-    private final Source source;
-    private final OkBuffer buffer;
+    private final BufferedSource source;
 
     int length;
     byte flags;
@@ -499,23 +489,19 @@
 
     int left;
 
-    public ContinuationSource(Source source, OkBuffer buffer) {
+    public ContinuationSource(BufferedSource source) {
       this.source = source;
-      this.buffer = buffer;
     }
 
     @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
         throws IOException {
       while (left == 0) {
         if ((flags & FLAG_END_HEADERS) != 0) return -1;
-        readContinuationHeader(deadline);
+        readContinuationHeader();
         // TODO: test case for empty continuation header?
       }
 
-      long toRead = Math.min(byteCount, left);
-      long read = buffer.byteCount() > 0
-          ? buffer.read(sink, toRead, deadline)
-          : source.read(sink, toRead, deadline);
+      long read = source.read(sink, Math.min(byteCount, left), deadline);
       if (read == -1) return -1;
       left -= read;
       return read;
@@ -524,11 +510,10 @@
     @Override public void close(Deadline deadline) throws IOException {
     }
 
-    private void readContinuationHeader(Deadline deadline) throws IOException {
-      OkBuffers.require(source, buffer, 8, deadline);
+    private void readContinuationHeader() throws IOException {
       int previousStreamId = streamId;
-      int w1 = buffer.readInt();
-      int w2 = buffer.readInt();
+      int w1 = source.readInt();
+      int w2 = source.readInt();
       length = left = (short) ((w1 & 0x3fff0000) >> 16);
       byte type = (byte) ((w1 & 0xff00) >> 8);
       flags = (byte) (w1 & 0xff);
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
index 9efdbdf..b78ac60 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
@@ -1,10 +1,10 @@
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.bytes.Deadline;
 import com.squareup.okhttp.internal.bytes.InflaterSource;
 import com.squareup.okhttp.internal.bytes.OkBuffer;
-import com.squareup.okhttp.internal.bytes.OkBuffers;
 import com.squareup.okhttp.internal.bytes.Source;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -28,10 +28,10 @@
    */
   private int compressedLimit;
 
-  /** This buffer holds inflated bytes read from inflaterSource. */
-  private final OkBuffer inflatedBuffer = new OkBuffer();
+  /** This source holds inflated bytes. */
+  private final BufferedSource source;
 
-  public NameValueBlockReader(final OkBuffer sourceBuffer, final Source source) {
+  public NameValueBlockReader(final BufferedSource source) {
     // Limit the inflater input stream to only those bytes in the Name/Value
     // block. We cut the inflater off at its source because we can't predict the
     // ratio of compressed bytes to uncompressed bytes.
@@ -39,10 +39,7 @@
       @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
           throws IOException {
         if (compressedLimit == 0) return -1; // Out of data for the current block.
-        byteCount = Math.min(byteCount, compressedLimit);
-        long read = sourceBuffer.byteCount() > 0
-            ? sourceBuffer.read(sink, byteCount, deadline)
-            : source.read(sink, byteCount, deadline);
+        long read = source.read(sink, Math.min(byteCount, compressedLimit), deadline);
         if (read == -1) return -1;
         compressedLimit -= read;
         return read;
@@ -66,14 +63,14 @@
       }
     };
 
-    inflaterSource = new InflaterSource(throttleSource, inflater);
+    this.inflaterSource = new InflaterSource(throttleSource, inflater);
+    this.source = new BufferedSource(inflaterSource, new OkBuffer());
   }
 
   public List<Header> readNameValueBlock(int length) throws IOException {
     this.compressedLimit += length;
 
-    OkBuffers.require(inflaterSource, inflatedBuffer, 4, Deadline.NONE);
-    int numberOfPairs = inflatedBuffer.readInt();
+    int numberOfPairs = source.readInt();
     if (numberOfPairs < 0) throw new IOException("numberOfPairs < 0: " + numberOfPairs);
     if (numberOfPairs > 1024) throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
 
@@ -90,10 +87,8 @@
   }
 
   private ByteString readByteString() throws IOException {
-    OkBuffers.require(inflaterSource, inflatedBuffer, 4, Deadline.NONE);
-    int length = inflatedBuffer.readInt();
-    OkBuffers.require(inflaterSource, inflatedBuffer, length, Deadline.NONE);
-    return inflatedBuffer.readByteString(length);
+    int length = source.readInt();
+    return source.readByteString(length);
   }
 
   private void doneReading() throws IOException {
@@ -107,6 +102,6 @@
   }
 
   public void close(Deadline deadline) throws IOException {
-    inflaterSource.close(deadline);
+    source.close(deadline);
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index d9c6ee1..0a4e629 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -18,6 +18,7 @@
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.bytes.Deadline;
 import com.squareup.okhttp.internal.bytes.OkBuffer;
@@ -109,14 +110,13 @@
 
   /** Read spdy/3 frames. */
   static final class Reader implements FrameReader {
-    private final OkBuffer buffer = new OkBuffer();
-    private final Source source;
+    private final BufferedSource source;
     private final boolean client;
     private final NameValueBlockReader headerBlockReader;
 
     Reader(Source source, boolean client) {
-      this.source = source;
-      this.headerBlockReader = new NameValueBlockReader(buffer, source);
+      this.source = new BufferedSource(source, new OkBuffer());
+      this.headerBlockReader = new NameValueBlockReader(this.source);
       this.client = client;
     }
 
@@ -128,13 +128,14 @@
      * more frames on the stream.
      */
     @Override public boolean nextFrame(Handler handler) throws IOException {
+      int w1;
+      int w2;
       try {
-        OkBuffers.require(source, buffer, 8, Deadline.NONE);
+        w1 = source.readInt();
+        w2 = source.readInt();
       } catch (IOException e) {
         return false; // This might be a normal socket close.
       }
-      int w1 = buffer.readInt();
-      int w2 = buffer.readInt();
 
       boolean control = (w1 & 0x80000000) != 0;
       int flags = (w2 & 0xff000000) >>> 24;
@@ -182,22 +183,21 @@
             return true;
 
           default:
-            OkBuffers.skip(source, buffer, length, Deadline.NONE);
+            source.skip(length, Deadline.NONE);
             return true;
         }
       } else {
         int streamId = w1 & 0x7fffffff;
         boolean inFinished = (flags & FLAG_FIN) != 0;
-        handler.data(inFinished, streamId, OkBuffers.inputStream(source, buffer), length);
+        handler.data(inFinished, streamId, source.inputStream(), length);
         return true;
       }
     }
 
     private void readSynStream(Handler handler, int flags, int length) throws IOException {
-      OkBuffers.require(source, buffer, 12, Deadline.NONE);
-      int w1 = buffer.readInt();
-      int w2 = buffer.readInt();
-      int s3 = buffer.readShort();
+      int w1 = source.readInt();
+      int w2 = source.readInt();
+      int s3 = source.readShort();
       int streamId = w1 & 0x7fffffff;
       int associatedStreamId = w2 & 0x7fffffff;
       int priority = (s3 & 0xe000) >>> 13;
@@ -211,8 +211,7 @@
     }
 
     private void readSynReply(Handler handler, int flags, int length) throws IOException {
-      OkBuffers.require(source, buffer, 4, Deadline.NONE);
-      int w1 = buffer.readInt();
+      int w1 = source.readInt();
       int streamId = w1 & 0x7fffffff;
       List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
       boolean inFinished = (flags & FLAG_FIN) != 0;
@@ -221,9 +220,8 @@
 
     private void readRstStream(Handler handler, int flags, int length) throws IOException {
       if (length != 8) throw ioException("TYPE_RST_STREAM length: %d != 8", length);
-      OkBuffers.require(source, buffer, 8, Deadline.NONE);
-      int streamId = buffer.readInt() & 0x7fffffff;
-      int errorCodeInt = buffer.readInt();
+      int streamId = source.readInt() & 0x7fffffff;
+      int errorCodeInt = source.readInt();
       ErrorCode errorCode = ErrorCode.fromSpdy3Rst(errorCodeInt);
       if (errorCode == null) {
         throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
@@ -232,8 +230,7 @@
     }
 
     private void readHeaders(Handler handler, int flags, int length) throws IOException {
-      OkBuffers.require(source, buffer, 4, Deadline.NONE);
-      int w1 = buffer.readInt();
+      int w1 = source.readInt();
       int streamId = w1 & 0x7fffffff;
       List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
       handler.headers(false, false, streamId, -1, -1, headerBlock, HeadersMode.SPDY_HEADERS);
@@ -241,9 +238,8 @@
 
     private void readWindowUpdate(Handler handler, int flags, int length) throws IOException {
       if (length != 8) throw ioException("TYPE_WINDOW_UPDATE length: %d != 8", length);
-      OkBuffers.require(source, buffer, 8, Deadline.NONE);
-      int w1 = buffer.readInt();
-      int w2 = buffer.readInt();
+      int w1 = source.readInt();
+      int w2 = source.readInt();
       int streamId = w1 & 0x7fffffff;
       long increment = w2 & 0x7fffffff;
       if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
@@ -252,17 +248,15 @@
 
     private void readPing(Handler handler, int flags, int length) throws IOException {
       if (length != 4) throw ioException("TYPE_PING length: %d != 4", length);
-      OkBuffers.require(source, buffer, 4, Deadline.NONE);
-      int id = buffer.readInt();
+      int id = source.readInt();
       boolean ack = client == ((id & 1) == 1);
       handler.ping(ack, id, 0);
     }
 
     private void readGoAway(Handler handler, int flags, int length) throws IOException {
       if (length != 8) throw ioException("TYPE_GOAWAY length: %d != 8", length);
-      OkBuffers.require(source, buffer, 8, Deadline.NONE);
-      int lastGoodStreamId = buffer.readInt() & 0x7fffffff;
-      int errorCodeInt = buffer.readInt();
+      int lastGoodStreamId = source.readInt() & 0x7fffffff;
+      int errorCodeInt = source.readInt();
       ErrorCode errorCode = ErrorCode.fromSpdyGoAway(errorCodeInt);
       if (errorCode == null) {
         throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
@@ -271,16 +265,14 @@
     }
 
     private void readSettings(Handler handler, int flags, int length) throws IOException {
-      OkBuffers.require(source, buffer, 4, Deadline.NONE);
-      int numberOfEntries = buffer.readInt();
+      int numberOfEntries = source.readInt();
       if (length != 4 + 8 * numberOfEntries) {
         throw ioException("TYPE_SETTINGS length: %d != 4 + 8 * %d", length, numberOfEntries);
       }
-      OkBuffers.require(source, buffer, 8 * numberOfEntries, Deadline.NONE);
       Settings settings = new Settings();
       for (int i = 0; i < numberOfEntries; i++) {
-        int w1 = buffer.readInt();
-        int value = buffer.readInt();
+        int w1 = source.readInt();
+        int value = source.readInt();
         int idFlags = (w1 & 0xff000000) >>> 24;
         int id = w1 & 0xffffff;
         settings.set(id, idFlags, value);
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
index caa7bcf..1b96890 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
@@ -384,7 +384,7 @@
     source.writeUtf8(repeat('b', Segment.SIZE));
     source.writeUtf8("c");
 
-    InputStream in = OkBuffers.inputStream(source);
+    InputStream in = new BufferedSource(source, new OkBuffer()).inputStream();
     assertEquals(0, in.available());
     assertEquals(Segment.SIZE + 2, source.byteCount());
 
@@ -417,7 +417,7 @@
   @Test public void inputStreamFromSourceBounds() throws IOException {
     OkBuffer source = new OkBuffer();
     source.writeUtf8(repeat('a', 100));
-    InputStream in = OkBuffers.inputStream(source);
+    InputStream in = new BufferedSource(source, new OkBuffer()).inputStream();
     try {
       in.read(new byte[100], 50, 51);
       fail();
@@ -568,60 +568,60 @@
   }
 
   @Test public void requireTracksBufferFirst() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-    buffer.writeUtf8("aa");
-
     OkBuffer source = new OkBuffer();
     source.writeUtf8("bb");
 
-    OkBuffers.require(source, buffer, 2, Deadline.NONE);
-    assertEquals(2, buffer.byteCount());
+    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+    bufferedSource.buffer.writeUtf8("aa");
+
+    bufferedSource.require(2, Deadline.NONE);
+    assertEquals(2, bufferedSource.buffer.byteCount());
     assertEquals(2, source.byteCount());
   }
 
   @Test public void requireIncludesBufferBytes() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-    buffer.writeUtf8("a");
-
     OkBuffer source = new OkBuffer();
     source.writeUtf8("b");
 
-    OkBuffers.require(source, buffer, 2, Deadline.NONE);
-    assertEquals("ab", buffer.readUtf8(2));
+    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+    bufferedSource.buffer.writeUtf8("a");
+
+    bufferedSource.require(2, Deadline.NONE);
+    assertEquals("ab", bufferedSource.buffer.readUtf8(2));
   }
 
   @Test public void requireInsufficientData() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-
     OkBuffer source = new OkBuffer();
     source.writeUtf8("a");
 
+    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+
     try {
-      OkBuffers.require(source, buffer, 2, Deadline.NONE);
+      bufferedSource.require(2, Deadline.NONE);
       fail();
     } catch (EOFException expected) {
     }
   }
 
   @Test public void requireReadsOneSegmentAtATime() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-
     OkBuffer source = new OkBuffer();
     source.writeUtf8(repeat('a', Segment.SIZE));
     source.writeUtf8(repeat('b', Segment.SIZE));
 
-    OkBuffers.require(source, buffer, 2, Deadline.NONE);
+    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+
+    bufferedSource.require(2, Deadline.NONE);
     assertEquals(Segment.SIZE, source.byteCount());
-    assertEquals(Segment.SIZE, buffer.byteCount());
+    assertEquals(Segment.SIZE, bufferedSource.buffer.byteCount());
   }
 
   @Test public void skipInsufficientData() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-
     OkBuffer source = new OkBuffer();
     source.writeUtf8("a");
+
+    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
     try {
-      OkBuffers.require(source, buffer, 2, Deadline.NONE);
+      bufferedSource.skip(2, Deadline.NONE);
       fail();
     } catch (EOFException expected) {
     }
@@ -631,21 +631,21 @@
     OkBuffer source = new OkBuffer();
     source.writeUtf8(repeat('a', Segment.SIZE));
     source.writeUtf8(repeat('b', Segment.SIZE));
-    OkBuffer buffer = new OkBuffer();
-    OkBuffers.skip(source, buffer, 2, Deadline.NONE);
+    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+    bufferedSource.skip(2, Deadline.NONE);
     assertEquals(Segment.SIZE, source.byteCount());
-    assertEquals(Segment.SIZE - 2, buffer.byteCount());
+    assertEquals(Segment.SIZE - 2, bufferedSource.buffer.byteCount());
   }
 
   @Test public void skipTracksBufferFirst() throws Exception {
-    OkBuffer buffer = new OkBuffer();
-    buffer.writeUtf8("aa");
-
     OkBuffer source = new OkBuffer();
     source.writeUtf8("bb");
 
-    OkBuffers.skip(source, buffer, 2, Deadline.NONE);
-    assertEquals(0, buffer.byteCount());
+    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+    bufferedSource.buffer.writeUtf8("aa");
+
+    bufferedSource.skip(2, Deadline.NONE);
+    assertEquals(0, bufferedSource.buffer.byteCount());
     assertEquals(2, source.byteCount());
   }
 
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index aed4b10..b55768b 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -21,6 +21,7 @@
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.spdy.Header;
 import com.squareup.okhttp.internal.spdy.IncomingStreamHandler;
@@ -655,7 +656,7 @@
         }
       }
 
-      InputStream bodyIn = stream.getInputStream();
+      InputStream bodyIn = new BufferedSource(stream.getSource()).inputStream();
       ByteArrayOutputStream bodyOut = new ByteArrayOutputStream();
       byte[] buffer = new byte[8192];
       int count;
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java
index 1cdf23c..ab1acdc 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java
@@ -15,8 +15,8 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.List;
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
index f5823a4..2b4638f 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -16,6 +16,9 @@
 
 package com.squareup.okhttp.internal;
 
+import com.squareup.okhttp.internal.bytes.Deadline;
+import com.squareup.okhttp.internal.bytes.OkBuffer;
+import com.squareup.okhttp.internal.bytes.Source;
 import com.squareup.okhttp.internal.spdy.Header;
 import java.io.ByteArrayInputStream;
 import java.io.Closeable;
@@ -29,7 +32,6 @@
 import java.io.UnsupportedEncodingException;
 import java.net.ServerSocket;
 import java.net.Socket;
-import java.net.SocketTimeoutException;
 import java.net.URI;
 import java.net.URL;
 import java.nio.charset.Charset;
@@ -40,7 +42,6 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.atomic.AtomicReference;
 
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
@@ -55,7 +56,6 @@
 
   /** A cheap and type-safe constant for the UTF-8 Charset. */
   public static final Charset UTF_8 = Charset.forName("UTF-8");
-  private static AtomicReference<byte[]> skipBuffer = new AtomicReference<byte[]>();
 
   private static final char[] DIGITS =
       { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
@@ -108,6 +108,21 @@
   }
 
   /**
+   * Closes {@code source}, ignoring any checked exceptions. Does nothing if
+   * {@code source} is null.
+   */
+  public static void closeQuietly(Source source) {
+    if (source != null) {
+      try {
+        source.close(Deadline.NONE);
+      } catch (RuntimeException rethrown) {
+        throw rethrown;
+      } catch (Exception ignored) {
+      }
+    }
+  }
+
+  /**
    * Closes {@code socket}, ignoring any checked exceptions. Does nothing if
    * {@code socket} is null.
    */
@@ -180,17 +195,6 @@
   }
 
   /**
-   * Implements InputStream.read(int) in terms of InputStream.read(byte[], int, int).
-   * InputStream assumes that you implement InputStream.read(int) and provides default
-   * implementations of the others, but often the opposite is more efficient.
-   */
-  public static int readSingleByte(InputStream in) throws IOException {
-    byte[] buffer = new byte[1];
-    int result = in.read(buffer, 0, 1);
-    return (result != -1) ? buffer[0] & 0xff : -1;
-  }
-
-  /**
    * Implements OutputStream.write(int) in terms of OutputStream.write(byte[], int, int).
    * OutputStream assumes that you implement OutputStream.write(int) and provides default
    * implementations of the others, but often the opposite is more efficient.
@@ -251,53 +255,17 @@
     }
   }
 
-  /**
-   * Call {@code in.read()} repeatedly until either the stream is exhausted or
-   * {@code byteCount} bytes have been read.
-   *
-   * <p>This method reuses the skip buffer but is careful to never use it at
-   * the same time that another stream is using it. Otherwise streams that use
-   * the caller's buffer for consistency checks like CRC could be clobbered by
-   * other threads. A thread-local buffer is also insufficient because some
-   * streams may call other streams in their skip() method, also clobbering the
-   * buffer.
-   *
-   * <p>This method throws a SocketTimeoutException if {@code timeoutMillis}
-   * elapses before the bytes can be skipped.
-   *
-   * @param timeoutMillis the maximum time to wait, or 0 to wait indefinitely.
-   */
-  public static long skipByReading(InputStream in, long byteCount, long timeoutMillis)
-      throws IOException {
-    if (byteCount == 0) return 0L;
-    long startNanos = timeoutMillis != 0 ? System.nanoTime() : 0;
-
-    // acquire the shared skip buffer.
-    byte[] buffer = skipBuffer.getAndSet(null);
-    if (buffer == null) {
-      buffer = new byte[4096];
+  /** Reads until {@code in} is exhausted or the timeout has elapsed. */
+  public static boolean skipAll(Source in, int timeoutMillis) throws IOException {
+    // TODO: Implement deadlines everywhere so they can do this work.
+    long startNanos = System.nanoTime();
+    OkBuffer skipBuffer = new OkBuffer();
+    while (NANOSECONDS.toMillis(System.nanoTime() - startNanos) < timeoutMillis) {
+      long read = in.read(skipBuffer, 2048, Deadline.NONE);
+      if (read == -1) return true; // Successfully exhausted the stream.
+      skipBuffer.clear();
     }
-
-    long skipped = 0;
-    while (skipped < byteCount) {
-      int toRead = (int) Math.min(byteCount - skipped, buffer.length);
-      int read = in.read(buffer, 0, toRead);
-      if (read == -1) break;
-      skipped += read;
-      if (timeoutMillis != 0
-          && NANOSECONDS.toMillis(System.nanoTime() - startNanos) > timeoutMillis) {
-        throw new SocketTimeoutException("Timed out after reading " + skipped + " of " + byteCount);
-      }
-    }
-
-    // release the shared skip buffer.
-    skipBuffer.set(buffer);
-
-    return skipped;
-  }
-
-  public static long skipByReading(InputStream in, long byteCount) throws IOException {
-    return skipByReading(in, byteCount, 0);
+    return false; // Ran out of time.
   }
 
   /**
@@ -315,33 +283,6 @@
     return total;
   }
 
-  /**
-   * Returns the ASCII characters up to but not including the next "\r\n", or
-   * "\n".
-   *
-   * @throws java.io.EOFException if the stream is exhausted before the next newline
-   * character.
-   */
-  public static String readAsciiLine(InputStream in) throws IOException {
-    // TODO: support UTF-8 here instead
-    StringBuilder result = new StringBuilder(80);
-    while (true) {
-      int c = in.read();
-      if (c == -1) {
-        throw new EOFException();
-      } else if (c == '\n') {
-        break;
-      }
-
-      result.append((char) c);
-    }
-    int length = result.length();
-    if (length > 0 && result.charAt(length - 1) == '\r') {
-      result.setLength(length - 1);
-    }
-    return result.toString();
-  }
-
   /** Returns a 32 character string containing a hash of {@code s}. */
   public static String hash(String s) {
     try {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSource.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSource.java
index db62b6c..35e3333 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSource.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSource.java
@@ -35,6 +35,10 @@
     this.source = source;
   }
 
+  public BufferedSource(Source source) {
+    this(source, new OkBuffer());
+  }
+
   @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
       throws IOException {
     if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
index 11e460d..7ece475 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
@@ -54,7 +54,7 @@
 
   public GzipSource(Source source) throws IOException {
     this.inflater = new Inflater(true);
-    this.source = new BufferedSource(source, new OkBuffer());
+    this.source = new BufferedSource(source);
     this.inflaterSource = new InflaterSource(this.source, inflater);
   }
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/InflaterSource.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/InflaterSource.java
index ce67f12..6681487 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/InflaterSource.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/InflaterSource.java
@@ -34,7 +34,7 @@
   private boolean closed;
 
   public InflaterSource(Source source, Inflater inflater) {
-    this(new BufferedSource(source, new OkBuffer()), inflater);
+    this(new BufferedSource(source), inflater);
   }
 
   /**
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java
index da0e827..b18692a 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java
@@ -25,6 +25,28 @@
   private OkBuffers() {
   }
 
+  /** Copies bytes from {@code source} to {@code sink}. */
+  public static void copy(OkBuffer source, long offset, long byteCount, OutputStream sink)
+      throws IOException {
+    checkOffsetAndCount(source.byteCount, offset, byteCount);
+
+    // Skip segments that we aren't copying from.
+    Segment s = source.head;
+    while (offset >= (s.limit - s.pos)) {
+      offset -= (s.limit - s.pos);
+      s = s.next;
+    }
+
+    // Copy from one segment at a time.
+    while (byteCount > 0) {
+      int pos = (int) (s.pos + offset);
+      int toWrite = (int) Math.min(s.limit - pos, byteCount);
+      sink.write(s.data, pos, toWrite);
+      byteCount -= toWrite;
+      offset = 0;
+    }
+  }
+
   /** Returns a sink that writes to {@code out}. */
   public static Sink sink(final OutputStream out) {
     return new Sink() {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index 418c431..6b15ffe 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -4,7 +4,6 @@
 import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.bytes.Deadline;
-import com.squareup.okhttp.internal.bytes.OkBuffer;
 import com.squareup.okhttp.internal.bytes.Source;
 import java.io.IOException;
 import java.io.OutputStream;
@@ -126,7 +125,7 @@
     Reader(boolean client, int maxHeaderTableByteCount, Source source) {
       this.huffmanCodec = client ? Huffman.Codec.RESPONSE : Huffman.Codec.REQUEST;
       this.maxHeaderTableByteCount = maxHeaderTableByteCount;
-      this.source = new BufferedSource(source, new OkBuffer());
+      this.source = new BufferedSource(source);
     }
 
     int maxHeaderTableByteCount() {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index 9f2228a..6086423 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -20,12 +20,10 @@
 import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.bytes.Deadline;
 import com.squareup.okhttp.internal.bytes.OkBuffer;
-import com.squareup.okhttp.internal.bytes.OkBuffers;
 import com.squareup.okhttp.internal.bytes.Source;
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.List;
 
@@ -60,8 +58,8 @@
   static final byte FLAG_END_PUSH_PROMISE = 0x4;
   static final byte FLAG_PRIORITY = 0x8;
 
-  @Override public FrameReader newReader(InputStream in, boolean client) {
-    return new Reader(OkBuffers.source(in), 4096, client);
+  @Override public FrameReader newReader(BufferedSource source, boolean client) {
+    return new Reader(source, 4096, client);
   }
 
   @Override public FrameWriter newWriter(OutputStream out, boolean client) {
@@ -76,8 +74,8 @@
     // Visible for testing.
     final HpackDraft05.Reader hpackReader;
 
-    Reader(Source source, int headerTableSize, boolean client) {
-      this.source = new BufferedSource(source, new OkBuffer());
+    Reader(BufferedSource source, int headerTableSize, boolean client) {
+      this.source = source;
       this.client = client;
       this.continuation = new ContinuationSource(this.source);
       this.hpackReader = new HpackDraft05.Reader(client, headerTableSize, continuation);
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
index b78ac60..405f6fc 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
@@ -64,7 +64,7 @@
     };
 
     this.inflaterSource = new InflaterSource(throttleSource, inflater);
-    this.source = new BufferedSource(inflaterSource, new OkBuffer());
+    this.source = new BufferedSource(inflaterSource);
   }
 
   public List<Header> readNameValueBlock(int length) throws IOException {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index e97aeac..27ce042 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -21,13 +21,9 @@
 import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.bytes.Deadline;
-import com.squareup.okhttp.internal.bytes.OkBuffer;
-import com.squareup.okhttp.internal.bytes.OkBuffers;
-import com.squareup.okhttp.internal.bytes.Source;
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.ProtocolException;
@@ -100,8 +96,8 @@
     }
   }
 
-  @Override public FrameReader newReader(InputStream in, boolean client) {
-    return new Reader(OkBuffers.source(in), client);
+  @Override public FrameReader newReader(BufferedSource source, boolean client) {
+    return new Reader(source, client);
   }
 
   @Override public FrameWriter newWriter(OutputStream out, boolean client) {
@@ -114,8 +110,8 @@
     private final boolean client;
     private final NameValueBlockReader headerBlockReader;
 
-    Reader(Source source, boolean client) {
-      this.source = new BufferedSource(source, new OkBuffer());
+    Reader(BufferedSource source, boolean client) {
+      this.source = source;
       this.headerBlockReader = new NameValueBlockReader(this.source);
       this.client = client;
     }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index c4bc9ff..466171e 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -21,9 +21,9 @@
 import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.bytes.Deadline;
+import com.squareup.okhttp.internal.bytes.OkBuffers;
 import java.io.Closeable;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.InterruptedIOException;
 import java.io.OutputStream;
 import java.net.Socket;
@@ -139,7 +139,7 @@
     }
     bytesLeftInWriteWindow = peerSettings.getInitialWindowSize();
     bufferPool = new ByteArrayPool(INITIAL_WINDOW_SIZE * 8); // TODO: revisit size limit!
-    frameReader = variant.newReader(builder.in, client);
+    frameReader = variant.newReader(builder.source, client);
     frameWriter = variant.newWriter(builder.out, client);
 
     readerRunnable = new Reader();
@@ -449,36 +449,25 @@
 
   public static class Builder {
     private String hostName;
-    private InputStream in;
+    private BufferedSource source;
     private OutputStream out;
     private IncomingStreamHandler handler = IncomingStreamHandler.REFUSE_INCOMING_STREAMS;
     private Protocol protocol = Protocol.SPDY_3;
     private boolean client;
 
     public Builder(boolean client, Socket socket) throws IOException {
-      this("", client, socket.getInputStream(), socket.getOutputStream());
-    }
-
-    public Builder(boolean client, InputStream in, OutputStream out) {
-      this("", client, in, out);
-    }
-
-    /**
-     * @param client true if this peer initiated the connection; false if
-     * this peer accepted the connection.
-     */
-    public Builder(String hostName, boolean client, Socket socket) throws IOException {
-      this(hostName, client, socket.getInputStream(), socket.getOutputStream());
+      this("", client, new BufferedSource(OkBuffers.source(socket.getInputStream())),
+          socket.getOutputStream());
     }
 
     /**
      * @param client true if this peer initiated the connection; false if this
-     * peer accepted the connection.
+     *     peer accepted the connection.
      */
-    public Builder(String hostName, boolean client, InputStream in, OutputStream out) {
+    public Builder(String hostName, boolean client, BufferedSource source, OutputStream out) {
       this.hostName = hostName;
       this.client = client;
-      this.in = in;
+      this.source = source;
       this.out = out;
     }
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index 8166cb9..b23bfb6 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -23,7 +23,6 @@
 import com.squareup.okhttp.internal.bytes.Source;
 import java.io.EOFException;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.InterruptedIOException;
 import java.io.OutputStream;
 import java.net.SocketTimeoutException;
@@ -67,7 +66,6 @@
   private List<Header> responseHeaders;
 
   private final SpdyDataSource source;
-  private final InputStream in;
   final SpdyDataOutputStream out;
 
   /**
@@ -85,7 +83,6 @@
     this.connection = connection;
     this.bytesLeftInWriteWindow = connection.peerSettings.getInitialWindowSize();
     this.source = new SpdyDataSource(connection.okHttpSettings.getInitialWindowSize());
-    this.in = new BufferedSource(source, new OkBuffer()).inputStream();
     this.out = new SpdyDataOutputStream();
     this.source.finished = inFinished;
     this.out.finished = outFinished;
@@ -211,9 +208,9 @@
     return readTimeoutMillis;
   }
 
-  /** Returns an input stream that can be used to read data from the peer. */
-  public InputStream getInputStream() {
-    return in;
+  /** Returns a source that reads data from the peer. */
+  public Source getSource() {
+    return source;
   }
 
   /**
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
index 784d02e..af4c5e9 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
@@ -16,7 +16,7 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.Protocol;
-import java.io.InputStream;
+import com.squareup.okhttp.internal.bytes.BufferedSource;
 import java.io.OutputStream;
 
 /** A version and dialect of the framed socket protocol. */
@@ -28,7 +28,7 @@
   /**
    * @param client true if this is the HTTP client's reader, reading frames from a server.
    */
-  FrameReader newReader(InputStream in, boolean client);
+  FrameReader newReader(BufferedSource source, boolean client);
 
   /**
    * @param client true if this is the HTTP client's writer, writing frames to a server.
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
index 61d6fd0..d05943e 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
@@ -419,7 +419,7 @@
     source.writeUtf8(repeat('b', Segment.SIZE));
     source.writeUtf8("c");
 
-    InputStream in = new BufferedSource(source, new OkBuffer()).inputStream();
+    InputStream in = new BufferedSource(source).inputStream();
     assertEquals(0, in.available());
     assertEquals(Segment.SIZE + 2, source.byteCount());
 
@@ -452,7 +452,7 @@
   @Test public void inputStreamFromSourceBounds() throws IOException {
     OkBuffer source = new OkBuffer();
     source.writeUtf8(repeat('a', 100));
-    InputStream in = new BufferedSource(source, new OkBuffer()).inputStream();
+    InputStream in = new BufferedSource(source).inputStream();
     try {
       in.read(new byte[100], 50, 51);
       fail();
@@ -606,7 +606,7 @@
     OkBuffer source = new OkBuffer();
     source.writeUtf8("bb");
 
-    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+    BufferedSource bufferedSource = new BufferedSource(source);
     bufferedSource.buffer.writeUtf8("aa");
 
     bufferedSource.require(2, Deadline.NONE);
@@ -618,7 +618,7 @@
     OkBuffer source = new OkBuffer();
     source.writeUtf8("b");
 
-    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+    BufferedSource bufferedSource = new BufferedSource(source);
     bufferedSource.buffer.writeUtf8("a");
 
     bufferedSource.require(2, Deadline.NONE);
@@ -629,7 +629,7 @@
     OkBuffer source = new OkBuffer();
     source.writeUtf8("a");
 
-    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+    BufferedSource bufferedSource = new BufferedSource(source);
 
     try {
       bufferedSource.require(2, Deadline.NONE);
@@ -643,7 +643,7 @@
     source.writeUtf8(repeat('a', Segment.SIZE));
     source.writeUtf8(repeat('b', Segment.SIZE));
 
-    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+    BufferedSource bufferedSource = new BufferedSource(source);
 
     bufferedSource.require(2, Deadline.NONE);
     assertEquals(Segment.SIZE, source.byteCount());
@@ -654,7 +654,7 @@
     OkBuffer source = new OkBuffer();
     source.writeUtf8("a");
 
-    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+    BufferedSource bufferedSource = new BufferedSource(source);
     try {
       bufferedSource.skip(2, Deadline.NONE);
       fail();
@@ -666,7 +666,7 @@
     OkBuffer source = new OkBuffer();
     source.writeUtf8(repeat('a', Segment.SIZE));
     source.writeUtf8(repeat('b', Segment.SIZE));
-    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+    BufferedSource bufferedSource = new BufferedSource(source);
     bufferedSource.skip(2, Deadline.NONE);
     assertEquals(Segment.SIZE, source.byteCount());
     assertEquals(Segment.SIZE - 2, bufferedSource.buffer.byteCount());
@@ -676,7 +676,7 @@
     OkBuffer source = new OkBuffer();
     source.writeUtf8("bb");
 
-    BufferedSource bufferedSource = new BufferedSource(source, new OkBuffer());
+    BufferedSource bufferedSource = new BufferedSource(source);
     bufferedSource.buffer.writeUtf8("aa");
 
     bufferedSource.skip(2, Deadline.NONE);
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index be9e4e8..0ca781f 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -477,7 +477,7 @@
   private Http20Draft09.Reader newReader(ByteArrayOutputStream out) {
     OkBuffer buffer = new OkBuffer();
     buffer.write(ByteString.of(out.toByteArray()));
-    return new Http20Draft09.Reader(buffer, 4096, false);
+    return new Http20Draft09.Reader(new BufferedSource(buffer), 4096, false);
   }
 
   @Test public void frameSizeError() throws IOException {
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index e4a6b07..15b8f7c 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -19,6 +19,7 @@
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
+import com.squareup.okhttp.internal.bytes.OkBuffers;
 import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
 import java.io.IOException;
@@ -116,7 +117,7 @@
     socket = serverSocket.accept();
     OutputStream out = socket.getOutputStream();
     InputStream in = socket.getInputStream();
-    FrameReader reader = variant.newReader(in, client);
+    FrameReader reader = variant.newReader(new BufferedSource(OkBuffers.source(in)), client);
 
     Iterator<OutFrame> outFramesIterator = outFrames.iterator();
     byte[] outBytes = bytesOut.toByteArray();
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
index e488617..6b31759 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
@@ -16,6 +16,7 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.bytes.OkBuffer;
 import java.io.ByteArrayOutputStream;
@@ -91,7 +92,7 @@
   private Spdy3.Reader newReader(ByteArrayOutputStream out) {
     OkBuffer data = new OkBuffer();
     data.write(ByteString.of(out.toByteArray()));
-    return new Spdy3.Reader(data, false);
+    return new Spdy3.Reader(new BufferedSource(data), false);
   }
 
   private byte[] sendDataFrame(byte[] data) throws IOException {
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index 64decfd..1968130 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -16,10 +16,12 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.internal.bytes.Deadline;
+import com.squareup.okhttp.internal.bytes.OkBuffer;
+import com.squareup.okhttp.internal.bytes.Source;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.InterruptedIOException;
 import java.io.OutputStream;
 import java.util.Arrays;
@@ -80,7 +82,7 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    assertStreamData("robot", stream.getInputStream());
+    assertStreamData("robot", stream.getSource());
     writeAndClose(stream, "c3po");
     assertEquals(0, connection.openStreamCount());
 
@@ -547,11 +549,11 @@
     // play it back
     SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
-    InputStream in = stream.getInputStream();
+    Source in = stream.getSource();
     OutputStream out = stream.getOutputStream();
-    in.close();
+    in.close(Deadline.NONE);
     try {
-      in.read();
+      in.read(new OkBuffer(), 1, Deadline.NONE);
       fail();
     } catch (IOException expected) {
       assertEquals("stream closed", expected.getMessage());
@@ -590,11 +592,11 @@
     // play it back
     SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    InputStream in = stream.getInputStream();
+    Source source = stream.getSource();
     OutputStream out = stream.getOutputStream();
-    in.close();
+    source.close(Deadline.NONE);
     try {
-      in.read();
+      source.read(new OkBuffer(), 1, Deadline.NONE);
       fail();
     } catch (IOException expected) {
       assertEquals("stream closed", expected.getMessage());
@@ -632,8 +634,8 @@
     // play it back
     SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
-    InputStream in = stream.getInputStream();
-    assertStreamData("square", in);
+    Source source = stream.getSource();
+    assertStreamData("square", source);
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -660,7 +662,7 @@
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
     try {
-      stream.getInputStream().read();
+      stream.getSource().read(new OkBuffer(), 1, Deadline.NONE);
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: STREAM_IN_USE", expected.getMessage());
@@ -723,7 +725,7 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    assertStreamData("robot", stream.getInputStream());
+    assertStreamData("robot", stream.getSource());
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
@@ -921,7 +923,7 @@
       assertEquals("stream was reset: CANCEL", expected.getMessage());
     }
     try {
-      stream.getInputStream().read();
+      stream.getSource().read(new OkBuffer(), 1, Deadline.NONE);
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: CANCEL", expected.getMessage());
@@ -963,10 +965,10 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     stream.setReadTimeout(1000);
-    InputStream in = stream.getInputStream();
+    Source source = stream.getSource();
     long startNanos = System.nanoTime();
     try {
-      in.read();
+      source.read(new OkBuffer(), 1, Deadline.NONE);
       fail();
     } catch (IOException expected) {
     }
@@ -1067,15 +1069,12 @@
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals(0, stream.unacknowledgedBytesRead);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    InputStream in = stream.getInputStream();
-    int total = 0;
-    byte[] buffer = new byte[1024];
-    int count;
-    while ((count = in.read(buffer)) != -1) {
-      total += count;
-      if (total == 3 * windowUpdateThreshold) break;
+    Source in = stream.getSource();
+    OkBuffer buffer = new OkBuffer();
+    while (in.read(buffer, 1024, Deadline.NONE) != -1) {
+      if (buffer.byteCount() == 3 * windowUpdateThreshold) break;
     }
-    assertEquals(-1, in.read());
+    assertEquals(-1, in.read(buffer, 1, Deadline.NONE));
 
     // Verify the peer received what was expected.
     assertEquals(21, peer.frameCount());
@@ -1115,7 +1114,7 @@
     // Play it back.
     SpdyConnection connection = connection(peer, variant);
     SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(-1, client.getInputStream().read());
+    assertEquals(-1, client.getSource().read(new OkBuffer(), 1, Deadline.NONE));
 
     // Verify the peer received what was expected.
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
@@ -1143,7 +1142,6 @@
     // Play it back.
     SpdyConnection connection = connection(peer, variant);
     SpdyStream client = connection.newStream(headerEntries("b", "banana"), true, true);
-    assertEquals(0, client.getInputStream().available());
     client.getOutputStream().write(Util.EMPTY_BYTE_ARRAY);
     client.getOutputStream().flush();
     client.getOutputStream().close();
@@ -1256,9 +1254,9 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    InputStream in = stream.getInputStream();
+    Source in = stream.getSource();
     try {
-      Util.readFully(in, new byte[101]);
+      new BufferedSource(in).readByteString(101);
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
@@ -1403,7 +1401,7 @@
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals("a", stream.getResponseHeaders().get(0).name.utf8());
     assertEquals(length, stream.getResponseHeaders().get(0).value.size());
-    assertStreamData("robot", stream.getInputStream());
+    assertStreamData("robot", stream.getSource());
   }
 
   // TODO: change this to only cancel when local settings disable push
@@ -1466,13 +1464,11 @@
     out.close();
   }
 
-  private void assertStreamData(String expected, InputStream inputStream) throws IOException {
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    byte[] buffer = new byte[1024];
-    for (int count; (count = inputStream.read(buffer)) != -1; ) {
-      bytesOut.write(buffer, 0, count);
+  private void assertStreamData(String expected, Source source) throws IOException {
+    OkBuffer buffer = new OkBuffer();
+    while (source.read(buffer, Long.MAX_VALUE, Deadline.NONE) != -1) {
     }
-    String actual = bytesOut.toString("UTF-8");
+    String actual = buffer.readUtf8((int) buffer.byteCount());
     assertEquals(expected, actual);
   }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index 11fe7e5..b8d2f26 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -17,14 +17,16 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
+import com.squareup.okhttp.internal.bytes.Deadline;
+import com.squareup.okhttp.internal.bytes.OkBuffers;
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpConnection;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpTransport;
 import com.squareup.okhttp.internal.http.SpdyTransport;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
-import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.Closeable;
 import java.io.IOException;
@@ -71,6 +73,7 @@
   private Socket socket;
   private InputStream in;
   private OutputStream out;
+  private BufferedSource source;
   private boolean connected = false;
   private HttpConnection httpConnection;
   private SpdyConnection spdyConnection;
@@ -97,7 +100,7 @@
       upgradeToTls(tunnelRequest);
     } else {
       streamWrapper();
-      httpConnection = new HttpConnection(pool, this, in, out);
+      httpConnection = new HttpConnection(pool, this, source, out);
     }
     connected = true;
   }
@@ -161,11 +164,11 @@
 
     if (selectedProtocol.spdyVariant) {
       sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
-      spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, in, out)
+      spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, source, out)
           .protocol(selectedProtocol).build();
       spdyConnection.sendConnectionHeader();
     } else {
-      httpConnection = new HttpConnection(pool, this, in, out);
+      httpConnection = new HttpConnection(pool, this, source, out);
     }
   }
 
@@ -202,22 +205,19 @@
    * #isAlive()}; callers should check {@link #isAlive()} first.
    */
   public boolean isReadable() {
-    if (!(in instanceof BufferedInputStream)) {
+    if (source == null) {
       return true; // Optimistic.
     }
     if (isSpdy()) {
       return true; // Optimistic. We can't test SPDY because its streams are in use.
     }
-    BufferedInputStream bufferedInputStream = (BufferedInputStream) in;
     try {
       int readTimeout = socket.getSoTimeout();
       try {
         socket.setSoTimeout(1);
-        bufferedInputStream.mark(1);
-        if (bufferedInputStream.read() == -1) {
+        if (source.source.read(source.buffer, 1, Deadline.NONE) == -1) {
           return false; // Stream is exhausted; socket is closed.
         }
-        bufferedInputStream.reset();
         return true;
       } finally {
         socket.setSoTimeout(readTimeout);
@@ -307,7 +307,8 @@
    * retried if the proxy requires authorization.
    */
   private void makeTunnel(TunnelRequest tunnelRequest) throws IOException {
-    HttpConnection tunnelConnection = new HttpConnection(pool, this, in, out);
+    BufferedSource tunnelSource = new BufferedSource(OkBuffers.source(in));
+    HttpConnection tunnelConnection = new HttpConnection(pool, this, tunnelSource, out);
     Request request = tunnelRequest.getRequest();
     String requestLine = tunnelRequest.requestLine();
     while (true) {
@@ -317,12 +318,19 @@
 
       switch (response.code()) {
         case HTTP_OK:
+          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If that
+          // happens, then we will have buffered bytes that are needed by the SSLSocket!
+          if (tunnelSource.buffer.byteCount() > 0) {
+            throw new IOException("TLS tunnel buffered too many bytes!");
+          }
           return;
+
         case HTTP_PROXY_AUTH:
           request = HttpAuthenticator.processAuthHeader(
               route.address.authenticator, response, route.proxy);
           if (request != null) continue;
           throw new IOException("Failed to authenticate with proxy");
+
         default:
           throw new IOException(
               "Unexpected response code for CONNECT: " + response.code());
@@ -331,7 +339,7 @@
   }
 
   private void streamWrapper() throws IOException {
-    in = new BufferedInputStream(in, 4096);
+    source = new BufferedSource(OkBuffers.source(in));
     out = new BufferedOutputStream(out, 256);
   }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Job.java b/okhttp/src/main/java/com/squareup/okhttp/Job.java
index bd87e6e..045caa0 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Job.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Job.java
@@ -16,6 +16,8 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.NamedRunnable;
+import com.squareup.okhttp.internal.bytes.BufferedSource;
+import com.squareup.okhttp.internal.bytes.Source;
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
@@ -228,11 +230,14 @@
 
   static class RealResponseBody extends Response.Body {
     private final Response response;
-    private final InputStream in;
+    private final Source source;
 
-    RealResponseBody(Response response, InputStream in) {
+    /** Multiple calls to {@link #byteStream} must return the same instance. */
+    private InputStream in;
+
+    RealResponseBody(Response response, Source source) {
       this.response = response;
-      this.in = in;
+      this.source = source;
     }
 
     @Override public boolean ready() throws IOException {
@@ -248,8 +253,15 @@
       return OkHeaders.contentLength(response);
     }
 
+    @Override public Source source() {
+      return source;
+    }
+
     @Override public InputStream byteStream() {
-      return in;
+      InputStream result = in;
+      return result != null
+          ? result
+          : (in = new BufferedSource(source).inputStream());
     }
   }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index cb9e353..fc37786 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -16,6 +16,8 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.OkBuffers;
+import com.squareup.okhttp.internal.bytes.Source;
 import com.squareup.okhttp.internal.http.HttpDate;
 import com.squareup.okhttp.internal.http.OkHeaders;
 import com.squareup.okhttp.internal.http.StatusLine;
@@ -189,6 +191,9 @@
     /** Multiple calls to {@link #charStream()} must return the same instance. */
     private Reader reader;
 
+    /** Multiple calls to {@link #source()} must return the same instance. */
+    private Source source;
+
     /**
      * Returns true if further data from this response body should be read at
      * this time. For asynchronous protocols like SPDY and HTTP/2, this will
@@ -213,6 +218,12 @@
 
     public abstract InputStream byteStream();
 
+    // TODO: Source needs to be an API type for this to be public
+    public Source source() {
+      Source s = source;
+      return s != null ? s : (source = OkBuffers.source(byteStream()));
+    }
+
     public final byte[] bytes() throws IOException {
       long contentLength = contentLength();
       if (contentLength > Integer.MAX_VALUE) {
@@ -239,10 +250,8 @@
      * charset, this will attempt to decode the response body as UTF-8.
      */
     public final Reader charStream() {
-      if (reader == null) {
-        reader = new InputStreamReader(byteStream(), charset());
-      }
-      return reader;
+      Reader r = reader;
+      return r != null ? r : (reader = new InputStreamReader(byteStream(), charset()));
     }
 
     /**
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
index cce881b..5408650 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
@@ -23,9 +23,13 @@
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.AbstractOutputStream;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.BufferedSource;
+import com.squareup.okhttp.internal.bytes.Deadline;
+import com.squareup.okhttp.internal.bytes.OkBuffer;
+import com.squareup.okhttp.internal.bytes.OkBuffers;
+import com.squareup.okhttp.internal.bytes.Source;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.CacheRequest;
 import java.net.ProtocolException;
@@ -33,6 +37,7 @@
 
 import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
+import static com.squareup.okhttp.internal.http.Transport.DISCARD_STREAM_TIMEOUT_MILLIS;
 
 /**
  * A socket connection that can be used to send HTTP/1.1 messages. This class
@@ -45,8 +50,8 @@
  *   <li>Write to and then close that stream.
  *   <li>{@link #readResponse Read response headers}.
  *   <li>Open the HTTP response body input stream. Either {@link
- *       #newFixedLengthInputStream fixed-length}, {@link #newChunkedInputStream
- *       chunked} or {@link #newUnknownLengthInputStream unknown length}.
+ *       #newFixedLengthSource fixed-length}, {@link #newChunkedSource chunked}
+ *       or {@link #newUnknownLengthSource unknown length}.
  *   <li>Read from and close that stream.
  * </ol>
  * <p>Exchanges that do not have a request body may skip creating and closing
@@ -68,17 +73,17 @@
 
   private final ConnectionPool pool;
   private final Connection connection;
-  private final InputStream in;
+  private final BufferedSource source;
   private final OutputStream out;
 
   private int state = STATE_IDLE;
   private int onIdle = ON_IDLE_HOLD;
 
-  public HttpConnection(ConnectionPool pool, Connection connection, InputStream in,
+  public HttpConnection(ConnectionPool pool, Connection connection, BufferedSource source,
       OutputStream out) {
     this.pool = pool;
     this.connection = connection;
-    this.in = in;
+    this.source = source;
     this.out = out;
   }
 
@@ -137,12 +142,12 @@
 
   /** Parses bytes of a response header from an HTTP transport. */
   public Response.Builder readResponse() throws IOException {
-    if (state != STATE_OPEN_REQUEST_BODY
-        && state != STATE_READ_RESPONSE_HEADERS) {
+    if (state != STATE_OPEN_REQUEST_BODY && state != STATE_READ_RESPONSE_HEADERS) {
       throw new IllegalStateException("state: " + state);
     }
+
     while (true) {
-      String statusLineString = Util.readAsciiLine(in);
+      String statusLineString = readLine();
       StatusLine statusLine = new StatusLine(statusLineString);
 
       Response.Builder responseBuilder = new Response.Builder()
@@ -151,7 +156,7 @@
           .header(OkHeaders.SELECTED_PROTOCOL, Protocol.HTTP_11.name.utf8());
 
       Headers.Builder headersBuilder = new Headers.Builder();
-      OkHeaders.readHeaders(headersBuilder, in);
+      readHeaders(headersBuilder);
       responseBuilder.headers(headersBuilder.build());
 
       if (statusLine.code() != HTTP_CONTINUE) {
@@ -161,23 +166,44 @@
     }
   }
 
+  /** Reads headers or trailers into {@code builder}. */
+  public void readHeaders(Headers.Builder builder) throws IOException {
+    // parse the result headers until the first blank line
+    for (String line; (line = readLine()).length() != 0; ) {
+      builder.addLine(line);
+    }
+  }
+
+  private String readLine() throws IOException {
+    long newline = source.seek((byte) '\n', Deadline.NONE);
+
+    if (newline > 0 && source.buffer.getByte(newline - 1) == '\r') {
+      // Read everything until '\r\n', then skip the '\r\n'.
+      String result = source.buffer.readUtf8((int) (newline - 1));
+      source.buffer.skip(2);
+      return result;
+
+    } else {
+      // Read everything until '\n', then skip the '\n'.
+      String result = source.buffer.readUtf8((int) (newline));
+      source.buffer.skip(1);
+      return result;
+    }
+  }
+
   /**
-   * Discards the response body so that the connection can be reused. This
-   * needs to be done judiciously, since it delays the current request in
-   * order to speed up a potential future request that may never occur.
-   *
-   * <p>A stream may be discarded to encourage response caching (a response
-   * cannot be cached unless it is consumed completely) or to enable connection
-   * reuse.
+   * Discards the response body so that the connection can be reused and the
+   * cache entry can be completed. This needs to be done judiciously, since it
+   * delays the current request in order to speed up a potential future request
+   * that may never occur.
    */
-  public boolean discard(InputStream responseBodyIn) {
+  public boolean discard(Source in, int timeoutMillis) {
     Socket socket = connection.getSocket();
     try {
       int socketTimeout = socket.getSoTimeout();
-      socket.setSoTimeout(Transport.DISCARD_STREAM_TIMEOUT_MILLIS);
+      socket.setSoTimeout(timeoutMillis);
       try {
-        Util.skipByReading(responseBodyIn, Long.MAX_VALUE, Transport.DISCARD_STREAM_TIMEOUT_MILLIS);
-        return true;
+        return Util.skipAll(in, timeoutMillis);
       } finally {
         socket.setSoTimeout(socketTimeout);
       }
@@ -204,11 +230,11 @@
     requestBody.writeToSocket(out);
   }
 
-  public InputStream newFixedLengthInputStream(CacheRequest cacheRequest, long length)
+  public Source newFixedLengthSource(CacheRequest cacheRequest, long length)
       throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new FixedLengthInputStream(cacheRequest, length);
+    return new FixedLengthSource(cacheRequest, length);
   }
 
   /**
@@ -216,21 +242,20 @@
    * have a response body.
    */
   public void emptyResponseBody() throws IOException {
-    newFixedLengthInputStream(null, 0L); // Transition to STATE_IDLE.
+    newFixedLengthSource(null, 0L); // Transition to STATE_IDLE.
   }
 
-  public InputStream newChunkedInputStream(
-      CacheRequest cacheRequest, HttpEngine httpEngine) throws IOException {
-    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_READING_RESPONSE_BODY;
-    return new ChunkedInputStream(cacheRequest, httpEngine);
-  }
-
-  public InputStream newUnknownLengthInputStream(CacheRequest cacheRequest, HttpEngine httpEngine)
+  public Source newChunkedSource(CacheRequest cacheRequest, HttpEngine httpEngine)
       throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_READING_RESPONSE_BODY;
-    return new UnknownLengthHttpInputStream(cacheRequest);
+    return new ChunkedSource(cacheRequest, httpEngine);
+  }
+
+  public Source newUnknownLengthSource(CacheRequest cacheRequest) throws IOException {
+    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+    state = STATE_READING_RESPONSE_BODY;
+    return new UnknownLengthSource(cacheRequest);
   }
 
   /** An HTTP body with a fixed length known in advance. */
@@ -382,15 +407,14 @@
     }
   }
 
-  private class AbstractHttpInputStream extends InputStream {
+  private class AbstractSource {
     private final CacheRequest cacheRequest;
     protected final OutputStream cacheBody;
     protected boolean closed;
 
-    AbstractHttpInputStream(CacheRequest cacheRequest) throws IOException {
-      OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
-
+    AbstractSource(CacheRequest cacheRequest) throws IOException {
       // Some apps return a null body; for compatibility we treat that like a null cache request.
+      OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
       if (cacheBody == null) {
         cacheRequest = null;
       }
@@ -399,21 +423,10 @@
       this.cacheRequest = cacheRequest;
     }
 
-    /**
-     * read() is implemented using read(byte[], int, int) so subclasses only
-     * need to override the latter.
-     */
-    @Override public final int read() throws IOException {
-      return Util.readSingleByte(this);
-    }
-
-    protected final void checkNotClosed() throws IOException {
-      if (closed) throw new IOException("stream closed");
-    }
-
-    protected final void cacheWrite(byte[] buffer, int offset, int count) throws IOException {
+    /** Copy the last {@code byteCount} bytes of {@code source} to the cache body. */
+    protected final void cacheWrite(OkBuffer source, long byteCount) throws IOException {
       if (cacheBody != null) {
-        cacheBody.write(buffer, offset, count);
+        OkBuffers.copy(source, source.byteCount() - byteCount, byteCount, cacheBody);
       }
     }
 
@@ -460,10 +473,10 @@
   }
 
   /** An HTTP body with a fixed length specified in advance. */
-  private class FixedLengthInputStream extends AbstractHttpInputStream {
+  private class FixedLengthSource extends AbstractSource implements Source {
     private long bytesRemaining;
 
-    public FixedLengthInputStream(CacheRequest cacheRequest, long length) throws IOException {
+    public FixedLengthSource(CacheRequest cacheRequest, long length) throws IOException {
       super(cacheRequest);
       bytesRemaining = length;
       if (bytesRemaining == 0) {
@@ -471,82 +484,76 @@
       }
     }
 
-    @Override public int read(byte[] buffer, int offset, int count) throws IOException {
-      checkOffsetAndCount(buffer.length, offset, count);
-      checkNotClosed();
-      if (bytesRemaining == 0) {
-        return -1;
-      }
-      int read = in.read(buffer, offset, (int) Math.min(count, bytesRemaining));
+    @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
+        throws IOException {
+      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+      if (closed) throw new IllegalStateException("closed");
+      if (bytesRemaining == 0) return -1;
+
+      long read = source.read(sink, Math.min(bytesRemaining, byteCount), deadline);
       if (read == -1) {
         unexpectedEndOfInput(); // the server didn't supply the promised content length
         throw new ProtocolException("unexpected end of stream");
       }
+
       bytesRemaining -= read;
-      cacheWrite(buffer, offset, read);
+      cacheWrite(sink, read);
       if (bytesRemaining == 0) {
         endOfInput();
       }
       return read;
     }
 
-    @Override public int available() throws IOException {
-      checkNotClosed();
-      return bytesRemaining == 0 ? 0 : (int) Math.min(in.available(), bytesRemaining);
-    }
+    @Override public void close(Deadline deadline) throws IOException {
+      if (closed) return;
 
-    @Override public void close() throws IOException {
-      if (closed) {
-        return;
-      }
-      if (bytesRemaining != 0 && !discard(this)) {
+      if (bytesRemaining != 0 && !discard(this, DISCARD_STREAM_TIMEOUT_MILLIS)) {
         unexpectedEndOfInput();
       }
+
       closed = true;
     }
   }
 
   /** An HTTP body with alternating chunk sizes and chunk bodies. */
-  private class ChunkedInputStream extends AbstractHttpInputStream {
+  private class ChunkedSource extends AbstractSource implements Source {
     private static final int NO_CHUNK_YET = -1;
     private int bytesRemainingInChunk = NO_CHUNK_YET;
     private boolean hasMoreChunks = true;
     private final HttpEngine httpEngine;
 
-    ChunkedInputStream(CacheRequest cacheRequest, HttpEngine httpEngine) throws IOException {
+    ChunkedSource(CacheRequest cacheRequest, HttpEngine httpEngine) throws IOException {
       super(cacheRequest);
       this.httpEngine = httpEngine;
     }
 
-    @Override public int read(byte[] buffer, int offset, int count) throws IOException {
-      checkOffsetAndCount(buffer.length, offset, count);
-      checkNotClosed();
+    @Override public long read(
+        OkBuffer sink, long byteCount, Deadline deadline) throws IOException {
+      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+      if (closed) throw new IllegalStateException("closed");
+      if (!hasMoreChunks) return -1;
 
-      if (!hasMoreChunks) {
-        return -1;
-      }
       if (bytesRemainingInChunk == 0 || bytesRemainingInChunk == NO_CHUNK_YET) {
         readChunkSize();
-        if (!hasMoreChunks) {
-          return -1;
-        }
+        if (!hasMoreChunks) return -1;
       }
-      int read = in.read(buffer, offset, Math.min(count, bytesRemainingInChunk));
+
+      long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk), deadline);
       if (read == -1) {
         unexpectedEndOfInput(); // the server didn't supply the promised chunk length
         throw new IOException("unexpected end of stream");
       }
       bytesRemainingInChunk -= read;
-      cacheWrite(buffer, offset, read);
+      cacheWrite(sink, read);
       return read;
     }
 
     private void readChunkSize() throws IOException {
       // read the suffix of the previous chunk
       if (bytesRemainingInChunk != NO_CHUNK_YET) {
-        Util.readAsciiLine(in);
+        readLine();
       }
-      String chunkSizeString = Util.readAsciiLine(in);
+      String chunkSizeString = readLine();
       int index = chunkSizeString.indexOf(";");
       if (index != -1) {
         chunkSizeString = chunkSizeString.substring(0, index);
@@ -559,25 +566,15 @@
       if (bytesRemainingInChunk == 0) {
         hasMoreChunks = false;
         Headers.Builder trailersBuilder = new Headers.Builder();
-        OkHeaders.readHeaders(trailersBuilder, in);
+        readHeaders(trailersBuilder);
         httpEngine.receiveHeaders(trailersBuilder.build());
         endOfInput();
       }
     }
 
-    @Override public int available() throws IOException {
-      checkNotClosed();
-      if (!hasMoreChunks || bytesRemainingInChunk == NO_CHUNK_YET) {
-        return 0;
-      }
-      return Math.min(in.available(), bytesRemainingInChunk);
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) {
-        return;
-      }
-      if (hasMoreChunks && !discard(this)) {
+    @Override public void close(Deadline deadline) throws IOException {
+      if (closed) return;
+      if (hasMoreChunks && !discard(this, DISCARD_STREAM_TIMEOUT_MILLIS)) {
         unexpectedEndOfInput();
       }
       closed = true;
@@ -585,42 +582,36 @@
   }
 
   /** An HTTP message body terminated by the end of the underlying stream. */
-  class UnknownLengthHttpInputStream extends AbstractHttpInputStream {
+  class UnknownLengthSource extends AbstractSource implements Source {
     private boolean inputExhausted;
 
-    UnknownLengthHttpInputStream(CacheRequest cacheRequest) throws IOException {
+    UnknownLengthSource(CacheRequest cacheRequest) throws IOException {
       super(cacheRequest);
     }
 
-    @Override public int read(byte[] buffer, int offset, int count) throws IOException {
-      checkOffsetAndCount(buffer.length, offset, count);
-      checkNotClosed();
-      if (in == null || inputExhausted) {
-        return -1;
-      }
-      int read = in.read(buffer, offset, count);
+    @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
+        throws IOException {
+      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+      if (closed) throw new IllegalStateException("closed");
+      if (inputExhausted) return -1;
+
+      long read = source.read(sink, byteCount, deadline);
       if (read == -1) {
         inputExhausted = true;
         endOfInput();
         return -1;
       }
-      cacheWrite(buffer, offset, read);
+      cacheWrite(sink, read);
       return read;
     }
 
-    @Override public int available() throws IOException {
-      checkNotClosed();
-      return in == null ? 0 : in.available();
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) {
-        return;
-      }
-      closed = true;
+    @Override public void close(Deadline deadline) throws IOException {
+      if (closed) return;
+      // TODO: discard unknown length streams for best caching?
       if (!inputExhausted) {
         unexpectedEndOfInput();
       }
+      closed = true;
     }
   }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 1fdcf7e..9992ada 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -28,6 +28,9 @@
 import com.squareup.okhttp.Route;
 import com.squareup.okhttp.TunnelRequest;
 import com.squareup.okhttp.internal.Dns;
+import com.squareup.okhttp.internal.bytes.BufferedSource;
+import com.squareup.okhttp.internal.bytes.GzipSource;
+import com.squareup.okhttp.internal.bytes.Source;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -39,7 +42,6 @@
 import java.security.cert.CertificateException;
 import java.util.List;
 import java.util.Map;
-import java.util.zip.GZIPInputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocketFactory;
@@ -102,8 +104,9 @@
 
   /** Null until a response is received from the network or the cache. */
   private Response response;
-  private InputStream responseTransferIn;
-  private InputStream responseBodyIn;
+  private Source responseTransferSource;
+  private Source responseBody;
+  private InputStream responseBodyBytes;
 
   /**
    * The cache response currently being validated on a conditional get. Null
@@ -194,7 +197,7 @@
       // No need for the network! Promote the cached response immediately.
       this.response = validatingResponse;
       if (validatingResponse.body() != null) {
-        initContentStream(validatingResponse.body().byteStream());
+        initContentStream(validatingResponse.body().source());
       }
     }
   }
@@ -274,9 +277,16 @@
     return response;
   }
 
-  public final InputStream getResponseBody() {
+  public final Source getResponseBody() {
     if (response == null) throw new IllegalStateException();
-    return responseBodyIn;
+    return responseBody;
+  }
+
+  public final InputStream getResponseBodyBytes() {
+    InputStream result = responseBodyBytes;
+    return result != null
+        ? result
+        : (responseBodyBytes = new BufferedSource(getResponseBody()).inputStream());
   }
 
   public final Connection getConnection() {
@@ -358,14 +368,17 @@
    */
   public final Connection close() {
     // If this engine never achieved a response body, its connection cannot be reused.
-    if (responseBodyIn == null) {
+    if (responseBody == null) {
       closeQuietly(connection);
       connection = null;
       return null;
     }
 
     // Close the response body. This will recycle the connection if it is eligible.
-    closeQuietly(responseBodyIn);
+    closeQuietly(responseBody);
+
+    // Clear the buffer held by the response body input stream adapter.
+    closeQuietly(responseBodyBytes);
 
     // Close the connection if it cannot be reused.
     if (transport != null && !transport.canReuseConnection()) {
@@ -380,9 +393,9 @@
   }
 
   /**
-   * Initialize the response content stream from the response transfer stream.
-   * These two streams are the same unless we're doing transparent gzip, in
-   * which case the content stream is decompressed.
+   * Initialize the response content stream from the response transfer source.
+   * These two sources are the same unless we're doing transparent gzip, in
+   * which case the content source is decompressed.
    *
    * <p>Whenever we do transparent gzip we also strip the corresponding headers.
    * We strip the Content-Encoding header to prevent the application from
@@ -393,18 +406,18 @@
    * <p>This method should only be used for non-empty response bodies. Response
    * codes like "304 Not Modified" can include "Content-Encoding: gzip" without
    * a response body and we will crash if we attempt to decompress the zero-byte
-   * stream.
+   * source.
    */
-  private void initContentStream(InputStream transferStream) throws IOException {
-    responseTransferIn = transferStream;
+  private void initContentStream(Source transferSource) throws IOException {
+    responseTransferSource = transferSource;
     if (transparentGzip && "gzip".equalsIgnoreCase(response.header("Content-Encoding"))) {
       response = response.newBuilder()
           .removeHeader("Content-Encoding")
           .removeHeader("Content-Length")
           .build();
-      responseBodyIn = new GZIPInputStream(transferStream);
+      responseBody = new GzipSource(transferSource);
     } else {
-      responseBodyIn = transferStream;
+      responseBody = transferSource;
     }
   }
 
@@ -541,7 +554,7 @@
         responseCache.update(validatingResponse, cacheableResponse());
 
         if (validatingResponse.body() != null) {
-          initContentStream(validatingResponse.body().byteStream());
+          initContentStream(validatingResponse.body().source());
         }
         return;
       } else {
@@ -551,8 +564,8 @@
 
     if (!hasResponseBody()) {
       // Don't call initContentStream() when the response doesn't have any content.
-      responseTransferIn = transport.getTransferStream(cacheRequest);
-      responseBodyIn = responseTransferIn;
+      responseTransferSource = transport.getTransferStream(cacheRequest);
+      responseBody = responseTransferSource;
       return;
     }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
index 5e25927..ef143f0 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
@@ -18,8 +18,8 @@
 
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.bytes.Source;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.CacheRequest;
 
@@ -133,23 +133,23 @@
     httpConnection.emptyResponseBody();
   }
 
-  @Override public InputStream getTransferStream(CacheRequest cacheRequest) throws IOException {
+  @Override public Source getTransferStream(CacheRequest cacheRequest) throws IOException {
     if (!httpEngine.hasResponseBody()) {
-      return httpConnection.newFixedLengthInputStream(cacheRequest, 0);
+      return httpConnection.newFixedLengthSource(cacheRequest, 0);
     }
 
     if ("chunked".equalsIgnoreCase(httpEngine.getResponse().header("Transfer-Encoding"))) {
-      return httpConnection.newChunkedInputStream(cacheRequest, httpEngine);
+      return httpConnection.newChunkedSource(cacheRequest, httpEngine);
     }
 
     long contentLength = OkHeaders.contentLength(httpEngine.getResponse());
     if (contentLength != -1) {
-      return httpConnection.newFixedLengthInputStream(cacheRequest, contentLength);
+      return httpConnection.newFixedLengthSource(cacheRequest, contentLength);
     }
 
     // Wrap the input stream from the connection (rather than just returning
     // "socketIn" directly here), so that we can control its use after the
     // reference escapes.
-    return httpConnection.newUnknownLengthInputStream(cacheRequest, httpEngine);
+    return httpConnection.newUnknownLengthSource(cacheRequest);
   }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
index 29a6010..d90f6f6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
@@ -113,7 +113,7 @@
     try {
       HttpEngine response = getResponse();
       if (response.hasResponseBody() && response.getResponse().code() >= HTTP_BAD_REQUEST) {
-        return response.getResponseBody();
+        return response.getResponseBodyBytes();
       }
       return null;
     } catch (IOException e) {
@@ -191,7 +191,7 @@
       throw new FileNotFoundException(url.toString());
     }
 
-    InputStream result = response.getResponseBody();
+    InputStream result = response.getResponseBodyBytes();
     if (result == null) {
       throw new ProtocolException("No response body exists; responseCode=" + getResponseCode());
     }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
index dd18638..5aa051a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
@@ -4,9 +4,6 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
-import java.io.IOException;
-import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -131,12 +128,4 @@
     }
     return sb.toString();
   }
-
-  /** Reads headers or trailers into {@code builder}. */
-  public static void readHeaders(Headers.Builder builder, InputStream in) throws IOException {
-    // parse the result headers until the first blank line
-    for (String line; (line = Util.readAsciiLine(in)).length() != 0; ) {
-      builder.addLine(line);
-    }
-  }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 1bb29d5..9c05c71 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -22,12 +22,15 @@
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.bytes.ByteString;
+import com.squareup.okhttp.internal.bytes.Deadline;
+import com.squareup.okhttp.internal.bytes.OkBuffer;
+import com.squareup.okhttp.internal.bytes.OkBuffers;
+import com.squareup.okhttp.internal.bytes.Source;
 import com.squareup.okhttp.internal.spdy.ErrorCode;
 import com.squareup.okhttp.internal.spdy.Header;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.spdy.SpdyStream;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.CacheRequest;
 import java.net.ProtocolException;
@@ -37,7 +40,6 @@
 import java.util.Locale;
 import java.util.Set;
 
-import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
 import static com.squareup.okhttp.internal.spdy.Header.RESPONSE_STATUS;
 import static com.squareup.okhttp.internal.spdy.Header.TARGET_AUTHORITY;
 import static com.squareup.okhttp.internal.spdy.Header.TARGET_HOST;
@@ -191,8 +193,8 @@
     // Do nothing.
   }
 
-  @Override public InputStream getTransferStream(CacheRequest cacheRequest) throws IOException {
-    return new SpdyInputStream(stream, cacheRequest, httpEngine);
+  @Override public Source getTransferStream(CacheRequest cacheRequest) throws IOException {
+    return new SpdySource(stream, cacheRequest);
   }
 
   @Override public void releaseConnectionOnIdle() {
@@ -232,28 +234,22 @@
     return prohibited;
   }
 
-  /**
-   * An input stream for the body of an HTTP response.
-   *
-   * <p>Since a single socket's input stream may be used to read multiple HTTP
-   * responses from the same server, subclasses shouldn't close the socket stream.
-   *
-   * <p>A side effect of reading an HTTP response is that the response cache
-   * is populated. If the stream is closed early, that cache entry will be
-   * invalidated.
-   */
-  abstract static class AbstractHttpInputStream extends InputStream {
-    protected final InputStream in;
+  /** An HTTP message body terminated by the end of the underlying stream. */
+  private static class SpdySource implements Source {
+    private final SpdyStream stream;
+    private final Source source;
     private final CacheRequest cacheRequest;
-    protected final OutputStream cacheBody;
-    protected boolean closed;
+    private final OutputStream cacheBody;
 
-    AbstractHttpInputStream(InputStream in, CacheRequest cacheRequest) throws IOException {
-      this.in = in;
+    private boolean inputExhausted;
+    private boolean closed;
 
-      OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
+    SpdySource(SpdyStream stream, CacheRequest cacheRequest) throws IOException {
+      this.stream = stream;
+      this.source = stream.getSource();
 
       // Some apps return a null body; for compatibility we treat that like a null cache request.
+      OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
       if (cacheBody == null) {
         cacheRequest = null;
       }
@@ -262,86 +258,29 @@
       this.cacheRequest = cacheRequest;
     }
 
-    /**
-     * read() is implemented using read(byte[], int, int) so subclasses only
-     * need to override the latter.
-     */
-    @Override public final int read() throws IOException {
-      return Util.readSingleByte(this);
-    }
-
-    protected final void checkNotClosed() throws IOException {
-      if (closed) throw new IOException("stream closed");
-    }
-
-    protected final void cacheWrite(byte[] buffer, int offset, int count) throws IOException {
-      if (cacheBody != null) {
-        cacheBody.write(buffer, offset, count);
-      }
-    }
-
-    /**
-     * Closes the cache entry and makes the socket available for reuse. This
-     * should be invoked when the end of the body has been reached.
-     */
-    protected final void endOfInput() throws IOException {
-      if (cacheRequest != null) {
-        cacheBody.close();
-      }
-    }
-
-    /**
-     * Calls abort on the cache entry and disconnects the socket. This
-     * should be invoked when the connection is closed unexpectedly to
-     * invalidate the cache entry and to prevent the HTTP connection from
-     * being reused. HTTP messages are sent in serial so whenever a message
-     * cannot be read to completion, subsequent messages cannot be read
-     * either and the connection must be discarded.
-     *
-     * <p>An earlier implementation skipped the remaining bytes, but this
-     * requires that the entire transfer be completed. If the intention was
-     * to cancel the transfer, closing the connection is the only solution.
-     */
-    protected final void unexpectedEndOfInput() {
-      if (cacheRequest != null) {
-        cacheRequest.abort();
-      }
-    }
-  }
-
-  /** An HTTP message body terminated by the end of the underlying stream. */
-  private static class SpdyInputStream extends AbstractHttpInputStream {
-    private final SpdyStream stream;
-    private boolean inputExhausted;
-
-    SpdyInputStream(SpdyStream stream, CacheRequest cacheRequest, HttpEngine httpEngine)
+    @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
         throws IOException {
-      super(stream.getInputStream(), cacheRequest);
-      this.stream = stream;
-    }
+      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+      if (closed) throw new IllegalStateException("closed");
+      if (inputExhausted) return -1;
 
-    @Override public int read(byte[] buffer, int offset, int count) throws IOException {
-      checkOffsetAndCount(buffer.length, offset, count);
-      checkNotClosed();
-      if (in == null || inputExhausted) {
-        return -1;
-      }
-      int read = in.read(buffer, offset, count);
+      long read = source.read(sink, byteCount, deadline);
       if (read == -1) {
         inputExhausted = true;
-        endOfInput();
+        if (cacheRequest != null) {
+          cacheBody.close();
+        }
         return -1;
       }
-      cacheWrite(buffer, offset, read);
+
+      if (cacheBody != null) {
+        OkBuffers.copy(sink, sink.byteCount() - read, read, cacheBody);
+      }
+
       return read;
     }
 
-    @Override public int available() throws IOException {
-      checkNotClosed();
-      return in == null ? 0 : in.available();
-    }
-
-    @Override public void close() throws IOException {
+    @Override public void close(Deadline deadline) throws IOException {
       if (closed) return;
 
       if (!inputExhausted && cacheBody != null) {
@@ -352,7 +291,9 @@
 
       if (!inputExhausted) {
         stream.closeLater(ErrorCode.CANCEL);
-        unexpectedEndOfInput();
+        if (cacheRequest != null) {
+          cacheRequest.abort();
+        }
       }
     }
 
@@ -362,7 +303,7 @@
         stream.setReadTimeout(socketTimeout);
         stream.setReadTimeout(DISCARD_STREAM_TIMEOUT_MILLIS);
         try {
-          Util.skipByReading(this, Long.MAX_VALUE, DISCARD_STREAM_TIMEOUT_MILLIS);
+          Util.skipAll(this, DISCARD_STREAM_TIMEOUT_MILLIS);
           return true;
         } finally {
           stream.setReadTimeout(socketTimeout);
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
index 2230cdd..990d6e7 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
@@ -18,8 +18,8 @@
 
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.bytes.Source;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.CacheRequest;
 
@@ -68,7 +68,7 @@
   void emptyTransferStream() throws IOException;
 
   // TODO: make this the content stream?
-  InputStream getTransferStream(CacheRequest cacheRequest) throws IOException;
+  Source getTransferStream(CacheRequest cacheRequest) throws IOException;
 
   /**
    * Configures the response body to pool or close the socket connection when
/Fim/
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
index 40a35e7..4cd8e7d 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
@@ -577,7 +577,7 @@
     try {
       in.read();
       fail("Expected an IOException because the stream is closed.");
-    } catch (IOException expected) {
+    } catch (IllegalStateException expected) {
     }
 
     assertEquals(1, cache.getWriteAbortCount());
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index 6ed031d..05fd469 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -880,7 +880,7 @@
     try {
       in.read();
       fail("Expected a connection closed exception");
-    } catch (IOException expected) {
+    } catch (IllegalStateException expected) {
     }
   }
 
@@ -2365,6 +2365,7 @@
       throws Exception {
     server.enqueue(new MockResponse().setBody("A").setSocketPolicy(SHUTDOWN_INPUT_AT_END));
     server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse().setBody("C"));
     server.play();
 
     assertContent("A", client.open(server.getUrl("/a")));
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
index 2b4638f..999b0fe 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -18,6 +18,7 @@
 
 import com.squareup.okhttp.internal.bytes.Deadline;
 import com.squareup.okhttp.internal.bytes.OkBuffer;
+import com.squareup.okhttp.internal.bytes.Sink;
 import com.squareup.okhttp.internal.bytes.Source;
 import com.squareup.okhttp.internal.spdy.Header;
 import java.io.ByteArrayInputStream;
@@ -123,6 +124,21 @@
   }
 
   /**
+   * Closes {@code sink}, ignoring any checked exceptions. Does nothing if
+   * {@code sink} is null.
+   */
+  public static void closeQuietly(Sink sink) {
+    if (sink != null) {
+      try {
+        sink.close(Deadline.NONE);
+      } catch (RuntimeException rethrown) {
+        throw rethrown;
+      } catch (Exception ignored) {
+      }
+    }
+  }
+
+  /**
    * Closes {@code socket}, ignoring any checked exceptions. Does nothing if
    * {@code socket} is null.
    */
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSink.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSink.java
index cbd2716..3d5f00e 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSink.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSink.java
@@ -55,6 +55,12 @@
     emitCompleteSegments(deadline);
   }
 
+  public void write(byte[] data, int offset, int byteCount, Deadline deadline) throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    buffer.write(data, offset, byteCount);
+    emitCompleteSegments(deadline);
+  }
+
   public void writeByte(int b, Deadline deadline) throws IOException {
     if (closed) throw new IllegalStateException("closed");
     buffer.writeByte(b);
@@ -74,16 +80,8 @@
   }
 
   void emitCompleteSegments(Deadline deadline) throws IOException {
-    long byteCount = buffer.byteCount;
+    long byteCount = buffer.completeSegmentByteCount();
     if (byteCount == 0) return;
-
-    // Omit the tail if it's still writable.
-    Segment tail = buffer.head.prev;
-    if (tail.limit < Segment.SIZE) {
-      byteCount -= tail.limit - tail.pos;
-      if (byteCount == 0) return;
-    }
-
     sink.write(buffer, byteCount, deadline);
   }
 
@@ -121,6 +119,7 @@
     if (buffer.byteCount > 0) {
       sink.write(buffer, buffer.byteCount, deadline);
     }
+    sink.flush(deadline);
   }
 
   @Override public void close(Deadline deadline) throws IOException {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
index 8352908..9ed0dfa 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
@@ -39,7 +39,7 @@
  * returning it to you. Even if you're going to write over that space anyway.
  * This class avoids zero-fill and GC churn by pooling byte arrays.
  */
-public final class OkBuffer implements Source, Sink {
+public final class OkBuffer implements Source, Sink, Cloneable {
   private static final char[] HEX_DIGITS =
       { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
 
@@ -54,6 +54,24 @@
     return byteCount;
   }
 
+  /**
+   * Returns the number of bytes in segments that are not writable. This is the
+   * number of bytes that can be flushed immediately to an underlying sink
+   * without harming throughput.
+   */
+  public long completeSegmentByteCount() {
+    long result = byteCount;
+    if (result == 0) return 0;
+
+    // Omit the tail if it's still writable.
+    Segment tail = head.prev;
+    if (tail.limit < Segment.SIZE) {
+      result -= tail.limit - tail.pos;
+    }
+
+    return result;
+  }
+
   /** Removes a byte from the front of this buffer and returns it. */
   public byte readByte() {
     if (byteCount < 1) throw new IllegalArgumentException("byteCount < 1: " + byteCount);
@@ -481,4 +499,17 @@
     }
     return new String(result);
   }
+
+  /** Returns a deep copy of this buffer. */
+  @Override public OkBuffer clone() {
+    OkBuffer result = new OkBuffer();
+    if (byteCount() == 0) return result;
+
+    result.write(head.data, head.pos, head.limit - head.pos);
+    for (Segment s = head.next; s != head; s = s.next) {
+      result.write(s.data, s.pos, s.limit - s.pos);
+    }
+
+    return result;
+  }
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/BufferedSinkTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/BufferedSinkTest.java
new file mode 100644
index 0000000..f5508b3
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/BufferedSinkTest.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import java.util.Arrays;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public final class BufferedSinkTest {
+  @Test public void bytesEmittedToSinkWithFlush() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    BufferedSink bufferedSink = new BufferedSink(sink);
+    bufferedSink.writeUtf8("abc", Deadline.NONE);
+    bufferedSink.flush(Deadline.NONE);
+    assertEquals(3, sink.byteCount());
+  }
+
+  @Test public void bytesNotEmittedToSinkWithoutFlush() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    BufferedSink bufferedSink = new BufferedSink(sink);
+    bufferedSink.writeUtf8("abc", Deadline.NONE);
+    assertEquals(0, sink.byteCount());
+  }
+
+  @Test public void completeSegmentsEmitted() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    BufferedSink bufferedSink = new BufferedSink(sink);
+    bufferedSink.writeUtf8(repeat('a', Segment.SIZE * 3), Deadline.NONE);
+    assertEquals(Segment.SIZE * 3, sink.byteCount());
+  }
+
+  @Test public void incompleteSegmentsNotEmitted() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    BufferedSink bufferedSink = new BufferedSink(sink);
+    bufferedSink.writeUtf8(repeat('a', Segment.SIZE * 3 - 1), Deadline.NONE);
+    assertEquals(Segment.SIZE * 2, sink.byteCount());
+  }
+
+  private String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
+  }
+}
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
index d05943e..97703b9 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
@@ -48,6 +48,23 @@
     }
   }
 
+  @Test public void completeSegmentByteCountOnEmptyBuffer() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    assertEquals(0, buffer.completeSegmentByteCount());
+  }
+
+  @Test public void completeSegmentByteCountOnBufferWithFullSegments() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(repeat('a', Segment.SIZE * 4));
+    assertEquals(Segment.SIZE * 4, buffer.completeSegmentByteCount());
+  }
+
+  @Test public void completeSegmentByteCountOnBufferWithIncompleteTailSegment() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(repeat('a', Segment.SIZE * 4 - 10));
+    assertEquals(Segment.SIZE * 3, buffer.completeSegmentByteCount());
+  }
+
   @Test public void readUtf8SpansSegments() throws Exception {
     OkBuffer buffer = new OkBuffer();
     buffer.writeUtf8(repeat('a', Segment.SIZE * 2));
@@ -684,6 +701,51 @@
     assertEquals(2, source.byteCount());
   }
 
+  @Test public void cloneDoesNotObserveWritesToOriginal() throws Exception {
+    OkBuffer original = new OkBuffer();
+    OkBuffer clone = original.clone();
+    original.writeUtf8("abc");
+    assertEquals(0, clone.byteCount());
+  }
+
+  @Test public void cloneDoesNotObserveReadsFromOriginal() throws Exception {
+    OkBuffer original = new OkBuffer();
+    original.writeUtf8("abc");
+    OkBuffer clone = original.clone();
+    assertEquals("abc", original.readUtf8(3));
+    assertEquals(3, clone.byteCount());
+    assertEquals("ab", clone.readUtf8(2));
+  }
+
+  @Test public void originalDoesNotObserveWritesToClone() throws Exception {
+    OkBuffer original = new OkBuffer();
+    OkBuffer clone = original.clone();
+    clone.writeUtf8("abc");
+    assertEquals(0, original.byteCount());
+  }
+
+  @Test public void originalDoesNotObserveReadsFromClone() throws Exception {
+    OkBuffer original = new OkBuffer();
+    original.writeUtf8("abc");
+    OkBuffer clone = original.clone();
+    assertEquals("abc", clone.readUtf8(3));
+    assertEquals(3, original.byteCount());
+    assertEquals("ab", original.readUtf8(2));
+  }
+
+  @Test public void cloneMultipleSegments() throws Exception {
+    OkBuffer original = new OkBuffer();
+    original.writeUtf8(repeat('a', Segment.SIZE * 3));
+    OkBuffer clone = original.clone();
+    original.writeUtf8(repeat('b', Segment.SIZE * 3));
+    clone.writeUtf8(repeat('c', Segment.SIZE * 3));
+
+    assertEquals(repeat('a', Segment.SIZE * 3) + repeat('b', Segment.SIZE * 3),
+        original.readUtf8(Segment.SIZE * 6));
+    assertEquals(repeat('a', Segment.SIZE * 3) + repeat('c', Segment.SIZE * 3),
+        clone.readUtf8(Segment.SIZE * 6));
+  }
+
   private String repeat(char c, int count) {
     char[] array = new char[count];
     Arrays.fill(array, c);
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
index 999b0fe..99aa917 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -16,7 +16,6 @@
 
 package com.squareup.okhttp.internal;
 
-import com.squareup.okhttp.internal.bytes.Deadline;
 import com.squareup.okhttp.internal.bytes.OkBuffer;
 import com.squareup.okhttp.internal.bytes.Sink;
 import com.squareup.okhttp.internal.bytes.Source;
@@ -115,7 +114,7 @@
   public static void closeQuietly(Source source) {
     if (source != null) {
       try {
-        source.close(Deadline.NONE);
+        source.close();
       } catch (RuntimeException rethrown) {
         throw rethrown;
       } catch (Exception ignored) {
@@ -130,7 +129,7 @@
   public static void closeQuietly(Sink sink) {
     if (sink != null) {
       try {
-        sink.close(Deadline.NONE);
+        sink.close();
       } catch (RuntimeException rethrown) {
         throw rethrown;
       } catch (Exception ignored) {
@@ -277,7 +276,7 @@
     long startNanos = System.nanoTime();
     OkBuffer skipBuffer = new OkBuffer();
     while (NANOSECONDS.toMillis(System.nanoTime() - startNanos) < timeoutMillis) {
-      long read = in.read(skipBuffer, 2048, Deadline.NONE);
+      long read = in.read(skipBuffer, 2048);
       if (read == -1) return true; // Successfully exhausted the stream.
       skipBuffer.clear();
     }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSink.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSink.java
index 3d5f00e..2b5a670 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSink.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSink.java
@@ -36,53 +36,53 @@
     this(sink, new OkBuffer());
   }
 
-  @Override public void write(OkBuffer source, long byteCount, Deadline deadline)
+  @Override public void write(OkBuffer source, long byteCount)
       throws IOException {
     if (closed) throw new IllegalStateException("closed");
-    buffer.write(source, byteCount, deadline);
-    emitCompleteSegments(deadline);
+    buffer.write(source, byteCount);
+    emitCompleteSegments();
   }
 
-  public void write(ByteString byteString, Deadline deadline) throws IOException {
+  public void write(ByteString byteString) throws IOException {
     if (closed) throw new IllegalStateException("closed");
     buffer.write(byteString);
-    emitCompleteSegments(deadline);
+    emitCompleteSegments();
   }
 
-  public void writeUtf8(String string, Deadline deadline) throws IOException {
+  public void writeUtf8(String string) throws IOException {
     if (closed) throw new IllegalStateException("closed");
     buffer.writeUtf8(string);
-    emitCompleteSegments(deadline);
+    emitCompleteSegments();
   }
 
-  public void write(byte[] data, int offset, int byteCount, Deadline deadline) throws IOException {
+  public void write(byte[] data, int offset, int byteCount) throws IOException {
     if (closed) throw new IllegalStateException("closed");
     buffer.write(data, offset, byteCount);
-    emitCompleteSegments(deadline);
+    emitCompleteSegments();
   }
 
-  public void writeByte(int b, Deadline deadline) throws IOException {
+  public void writeByte(int b) throws IOException {
     if (closed) throw new IllegalStateException("closed");
     buffer.writeByte(b);
-    emitCompleteSegments(deadline);
+    emitCompleteSegments();
   }
 
-  public void writeShort(int s, Deadline deadline) throws IOException {
+  public void writeShort(int s) throws IOException {
     if (closed) throw new IllegalStateException("closed");
     buffer.writeShort(s);
-    emitCompleteSegments(deadline);
+    emitCompleteSegments();
   }
 
-  public void writeInt(int i, Deadline deadline) throws IOException {
+  public void writeInt(int i) throws IOException {
     if (closed) throw new IllegalStateException("closed");
     buffer.writeInt(i);
-    emitCompleteSegments(deadline);
+    emitCompleteSegments();
   }
 
-  void emitCompleteSegments(Deadline deadline) throws IOException {
+  void emitCompleteSegments() throws IOException {
     long byteCount = buffer.completeSegmentByteCount();
     if (byteCount == 0) return;
-    sink.write(buffer, byteCount, deadline);
+    sink.write(buffer, byteCount);
   }
 
   /** Returns an output stream that writes to this sink. */
@@ -91,21 +91,21 @@
       @Override public void write(int b) throws IOException {
         if (closed) throw new IllegalStateException("closed");
         buffer.writeByte((byte) b);
-        emitCompleteSegments(Deadline.NONE);
+        emitCompleteSegments();
       }
 
       @Override public void write(byte[] data, int offset, int byteCount) throws IOException {
         if (closed) throw new IllegalStateException("closed");
         buffer.write(data, offset, byteCount);
-        emitCompleteSegments(Deadline.NONE);
+        emitCompleteSegments();
       }
 
       @Override public void flush() throws IOException {
-        BufferedSink.this.flush(Deadline.NONE);
+        BufferedSink.this.flush();
       }
 
       @Override public void close() throws IOException {
-        BufferedSink.this.close(Deadline.NONE);
+        BufferedSink.this.close();
       }
 
       @Override public String toString() {
@@ -114,20 +114,25 @@
     };
   }
 
-  @Override public void flush(Deadline deadline) throws IOException {
+  @Override public void flush() throws IOException {
     if (closed) throw new IllegalStateException("closed");
     if (buffer.byteCount > 0) {
-      sink.write(buffer, buffer.byteCount, deadline);
+      sink.write(buffer, buffer.byteCount);
     }
-    sink.flush(deadline);
+    sink.flush();
   }
 
-  @Override public void close(Deadline deadline) throws IOException {
-    flush(deadline);
-    sink.close(deadline);
+  @Override public void close() throws IOException {
+    flush();
+    sink.close();
     closed = true;
   }
 
+  @Override public Sink deadline(Deadline deadline) {
+    sink.deadline(deadline);
+    return this;
+  }
+
   @Override public String toString() {
     return "BufferedSink(" + sink + ")";
   }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSource.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSource.java
index 35e3333..c3bdea1 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSource.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/BufferedSource.java
@@ -39,18 +39,18 @@
     this(source, new OkBuffer());
   }
 
-  @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
+  @Override public long read(OkBuffer sink, long byteCount)
       throws IOException {
     if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
     if (closed) throw new IllegalStateException("closed");
 
     if (buffer.byteCount == 0) {
-      long read = source.read(buffer, Segment.SIZE, deadline);
+      long read = source.read(buffer, Segment.SIZE);
       if (read == -1) return -1;
     }
 
     long toRead = Math.min(byteCount, buffer.byteCount);
-    return buffer.read(sink, toRead, deadline);
+    return buffer.read(sink, toRead);
   }
 
   /**
@@ -58,8 +58,8 @@
    * will block until there are bytes to read or the source is definitely
    * exhausted.
    */
-  public boolean exhausted(Deadline deadline) throws IOException {
-    return buffer.byteCount() == 0 && source.read(buffer, Segment.SIZE, deadline) == -1;
+  public boolean exhausted() throws IOException {
+    return buffer.byteCount() == 0 && source.read(buffer, Segment.SIZE) == -1;
   }
 
   /**
@@ -67,39 +67,39 @@
    * an {@link EOFException} if the source is exhausted before the required
    * bytes can be read.
    */
-  void require(long byteCount, Deadline deadline) throws IOException {
+  void require(long byteCount) throws IOException {
     while (buffer.byteCount < byteCount) {
-      if (source.read(buffer, Segment.SIZE, deadline) == -1) throw new EOFException();
+      if (source.read(buffer, Segment.SIZE) == -1) throw new EOFException();
     }
   }
 
   public byte readByte() throws IOException {
-    require(1, Deadline.NONE);
+    require(1);
     return buffer.readByte();
   }
 
   public ByteString readByteString(int byteCount) throws IOException {
-    require(byteCount, Deadline.NONE);
+    require(byteCount);
     return buffer.readByteString(byteCount);
   }
 
   public short readShort() throws IOException {
-    require(2, Deadline.NONE);
+    require(2);
     return buffer.readShort();
   }
 
   public int readShortLe() throws IOException {
-    require(2, Deadline.NONE);
+    require(2);
     return buffer.readShortLe();
   }
 
   public int readInt() throws IOException {
-    require(4, Deadline.NONE);
+    require(4);
     return buffer.readInt();
   }
 
   public int readIntLe() throws IOException {
-    require(4, Deadline.NONE);
+    require(4);
     return buffer.readIntLe();
   }
 
@@ -108,9 +108,9 @@
    * buffer} as a buffer. Throws an {@link EOFException} if the source is
    * exhausted before the requested bytes can be skipped.
    */
-  public void skip(long byteCount, Deadline deadline) throws IOException {
+  public void skip(long byteCount) throws IOException {
     while (byteCount > 0) {
-      if (buffer.byteCount == 0 && source.read(buffer, Segment.SIZE, deadline) == -1) {
+      if (buffer.byteCount == 0 && source.read(buffer, Segment.SIZE) == -1) {
         throw new EOFException();
       }
       long toSkip = Math.min(byteCount, buffer.byteCount());
@@ -123,12 +123,12 @@
    * Returns the index of {@code b} in the buffer, refilling it if necessary
    * until it is found. This reads an unbounded number of bytes into the buffer.
    */
-  public long seek(byte b, Deadline deadline) throws IOException {
+  public long seek(byte b) throws IOException {
     long start = 0;
     long index;
     while ((index = buffer.indexOf(b, start)) == -1) {
       start = buffer.byteCount;
-      if (source.read(buffer, Segment.SIZE, deadline) == -1) throw new EOFException();
+      if (source.read(buffer, Segment.SIZE) == -1) throw new EOFException();
     }
     return index;
   }
@@ -138,7 +138,7 @@
     return new InputStream() {
       @Override public int read() throws IOException {
         if (buffer.byteCount == 0) {
-          long count = source.read(buffer, Segment.SIZE, Deadline.NONE);
+          long count = source.read(buffer, Segment.SIZE);
           if (count == -1) return -1;
         }
         return buffer.readByte() & 0xff;
@@ -148,7 +148,7 @@
         checkOffsetAndCount(data.length, offset, byteCount);
 
         if (buffer.byteCount == 0) {
-          long count = source.read(buffer, Segment.SIZE, Deadline.NONE);
+          long count = source.read(buffer, Segment.SIZE);
           if (count == -1) return -1;
         }
 
@@ -172,7 +172,7 @@
       }
 
       @Override public void close() throws IOException {
-        BufferedSource.this.close(Deadline.NONE);
+        BufferedSource.this.close();
       }
 
       @Override public String toString() {
@@ -181,10 +181,15 @@
     };
   }
 
-  @Override public void close(Deadline deadline) throws IOException {
+  @Override public Source deadline(Deadline deadline) {
+    source.deadline(deadline);
+    return this;
+  }
+
+  @Override public void close() throws IOException {
     if (closed) return;
     closed = true;
-    source.close(deadline);
+    source.close();
     buffer.clear();
   }
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/DeflaterSink.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/DeflaterSink.java
index 2413d48..cc81de9 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/DeflaterSink.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/DeflaterSink.java
@@ -44,7 +44,7 @@
     this.deflater = deflater;
   }
 
-  @Override public void write(OkBuffer source, long byteCount, Deadline deadline)
+  @Override public void write(OkBuffer source, long byteCount)
       throws IOException {
     checkOffsetAndCount(source.byteCount, 0, byteCount);
     while (byteCount > 0) {
@@ -54,7 +54,7 @@
       deflater.setInput(head.data, head.pos, toDeflate);
 
       // Deflate those bytes into sink.
-      deflate(deadline, false);
+      deflate(false);
 
       // Mark those bytes as read.
       source.byteCount -= toDeflate;
@@ -69,7 +69,7 @@
   }
 
   @IgnoreJRERequirement
-  private void deflate(Deadline deadline, boolean syncFlush) throws IOException {
+  private void deflate(boolean syncFlush) throws IOException {
     while (true) {
       Segment s = sink.buffer.writableSegment(1);
 
@@ -84,18 +84,27 @@
       if (deflated == 0) return;
       s.limit += deflated;
       sink.buffer.byteCount += deflated;
-      sink.emitCompleteSegments(deadline);
+      sink.emitCompleteSegments();
     }
   }
 
-  @Override public void flush(Deadline deadline) throws IOException {
-    deflate(deadline, true);
-    sink.flush(deadline);
+  @Override public void flush() throws IOException {
+    deflate(true);
+    sink.flush();
   }
 
-  @Override public void close(Deadline deadline) throws IOException {
+  @Override public void close() throws IOException {
     deflater.finish();
-    deflate(deadline, false);
-    sink.close(deadline);
+    deflate(false);
+    sink.close();
+  }
+
+  @Override public Sink deadline(Deadline deadline) {
+    sink.deadline(deadline);
+    return this;
+  }
+
+  @Override public String toString() {
+    return "DeflaterSink(" + sink + ")";
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
index 7ece475..bd0fc5c 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
@@ -58,20 +58,20 @@
     this.inflaterSource = new InflaterSource(this.source, inflater);
   }
 
-  @Override public long read(OkBuffer sink, long byteCount, Deadline deadline) throws IOException {
+  @Override public long read(OkBuffer sink, long byteCount) throws IOException {
     if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
     if (byteCount == 0) return 0;
 
     // If we haven't consumed the header, we must consume it before anything else.
     if (section == SECTION_HEADER) {
-      consumeHeader(deadline);
+      consumeHeader();
       section = SECTION_BODY;
     }
 
     // Attempt to read at least a byte of the body. If we do, we're done.
     if (section == SECTION_BODY) {
       long offset = sink.byteCount;
-      long result = inflaterSource.read(sink, byteCount, deadline);
+      long result = inflaterSource.read(sink, byteCount);
       if (result != -1) {
         updateCrc(sink, offset, result);
         return result;
@@ -83,40 +83,40 @@
     // trailer before returning a -1 exhausted result; that way if you read to
     // the end of a GzipSource you guarantee that the CRC has been checked.
     if (section == SECTION_TRAILER) {
-      consumeTrailer(deadline);
+      consumeTrailer();
       section = SECTION_DONE;
     }
 
     return -1;
   }
 
-  private void consumeHeader(Deadline deadline) throws IOException {
+  private void consumeHeader() throws IOException {
     // Read the 10-byte header. We peek at the flags byte first so we know if we
     // need to CRC the entire header. Then we read the magic ID1ID2 sequence.
     // We can skip everything else in the first 10 bytes.
     // +---+---+---+---+---+---+---+---+---+---+
     // |ID1|ID2|CM |FLG|     MTIME     |XFL|OS | (more-->)
     // +---+---+---+---+---+---+---+---+---+---+
-    source.require(10, deadline);
+    source.require(10);
     byte flags = source.buffer.getByte(3);
     boolean fhcrc = ((flags >> FHCRC) & 1) == 1;
     if (fhcrc) updateCrc(source.buffer, 0, 10);
 
     short id1id2 = source.readShort();
     checkEqual("ID1ID2", (short) 0x1f8b, id1id2);
-    source.skip(8, deadline);
+    source.skip(8);
 
     // Skip optional extra fields.
     // +---+---+=================================+
     // | XLEN  |...XLEN bytes of "extra field"...| (more-->)
     // +---+---+=================================+
     if (((flags >> FEXTRA) & 1) == 1) {
-      source.require(2, deadline);
+      source.require(2);
       if (fhcrc) updateCrc(source.buffer, 0, 2);
       int xlen = source.buffer.readShortLe() & 0xffff;
-      source.require(xlen, deadline);
+      source.require(xlen);
       if (fhcrc) updateCrc(source.buffer, 0, xlen);
-      source.skip(xlen, deadline);
+      source.skip(xlen);
     }
 
     // Skip an optional 0-terminated name.
@@ -124,7 +124,7 @@
     // |...original file name, zero-terminated...| (more-->)
     // +=========================================+
     if (((flags >> FNAME) & 1) == 1) {
-      long index = source.seek((byte) 0, deadline);
+      long index = source.seek((byte) 0);
       if (fhcrc) updateCrc(source.buffer, 0, index + 1);
       source.buffer.skip(index + 1);
     }
@@ -134,9 +134,9 @@
     // |...file comment, zero-terminated...| (more-->)
     // +===================================+
     if (((flags >> FCOMMENT) & 1) == 1) {
-      long index = source.seek((byte) 0, deadline);
+      long index = source.seek((byte) 0);
       if (fhcrc) updateCrc(source.buffer, 0, index + 1);
-      source.skip(index + 1, deadline);
+      source.skip(index + 1);
     }
 
     // Confirm the optional header CRC.
@@ -149,7 +149,7 @@
     }
   }
 
-  private void consumeTrailer(Deadline deadline) throws IOException {
+  private void consumeTrailer() throws IOException {
     // Read the eight-byte trailer. Confirm the body's CRC and size.
     // +---+---+---+---+---+---+---+---+
     // |     CRC32     |     ISIZE     |
@@ -158,8 +158,13 @@
     checkEqual("ISIZE", source.readIntLe(), inflater.getTotalOut());
   }
 
-  @Override public void close(Deadline deadline) throws IOException {
-    inflaterSource.close(deadline);
+  @Override public Source deadline(Deadline deadline) {
+    source.deadline(deadline);
+    return this;
+  }
+
+  @Override public void close() throws IOException {
+    inflaterSource.close();
   }
 
   /** Updates the CRC with the given bytes. */
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/InflaterSource.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/InflaterSource.java
index 790dcfd..b31cc03 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/InflaterSource.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/InflaterSource.java
@@ -53,13 +53,13 @@
   }
 
   @Override public long read(
-      OkBuffer sink, long byteCount, Deadline deadline) throws IOException {
+      OkBuffer sink, long byteCount) throws IOException {
     if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
     if (closed) throw new IllegalStateException("closed");
     if (byteCount == 0) return 0;
 
     while (true) {
-      boolean sourceExhausted = refill(deadline);
+      boolean sourceExhausted = refill();
 
       // Decompress the inflater's compressed data into the sink.
       try {
@@ -86,14 +86,14 @@
    * it needs input). Returns true if the inflater required input but the source
    * was exhausted.
    */
-  public boolean refill(Deadline deadline) throws IOException {
+  public boolean refill() throws IOException {
     if (!inflater.needsInput()) return false;
 
     releaseInflatedBytes();
     if (inflater.getRemaining() != 0) throw new IllegalStateException("?"); // TODO: possible?
 
     // If there are compressed bytes in the source, assign them to the inflater.
-    if (source.exhausted(deadline)) return true;
+    if (source.exhausted()) return true;
 
     // Assign buffer bytes to the inflater.
     Segment head = source.buffer.head;
@@ -110,10 +110,15 @@
     source.buffer.skip(toRelease);
   }
 
-  @Override public void close(Deadline deadline) throws IOException {
+  @Override public Source deadline(Deadline deadline) {
+    source.deadline(deadline);
+    return this;
+  }
+
+  @Override public void close() throws IOException {
     if (closed) return;
     inflater.end();
     closed = true;
-    source.close(deadline);
+    source.close();
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
index 9ed0dfa..a8ab472 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
@@ -334,7 +334,7 @@
     return tail;
   }
 
-  @Override public void write(OkBuffer source, long byteCount, Deadline deadline) {
+  @Override public void write(OkBuffer source, long byteCount) {
     // Move bytes from the head of the source buffer to the tail of this buffer
     // while balancing two conflicting goals: don't waste CPU and don't waste
     // memory.
@@ -425,13 +425,18 @@
     }
   }
 
-  @Override public long read(OkBuffer sink, long byteCount, Deadline deadline) throws IOException {
+  @Override public long read(OkBuffer sink, long byteCount) throws IOException {
     if (this.byteCount == 0) return -1L;
     if (byteCount > this.byteCount) byteCount = this.byteCount;
-    sink.write(this, byteCount, deadline);
+    sink.write(this, byteCount);
     return byteCount;
   }
 
+  @Override public OkBuffer deadline(Deadline deadline) {
+    // All operations are in memory so this class doesn't need to honor deadlines.
+    return this;
+  }
+
   /**
    * Returns the index of {@code b} in this, or -1 if this buffer does not
    * contain {@code b}.
@@ -465,10 +470,10 @@
     return -1L;
   }
 
-  @Override public void flush(Deadline deadline) {
+  @Override public void flush() {
   }
 
-  @Override public void close(Deadline deadline) {
+  @Override public void close() {
   }
 
   /** For testing. This returns the sizes of the segments in this buffer. */
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java
index b18692a..6e5be4c 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java
@@ -50,7 +50,9 @@
   /** Returns a sink that writes to {@code out}. */
   public static Sink sink(final OutputStream out) {
     return new Sink() {
-      @Override public void write(OkBuffer source, long byteCount, Deadline deadline)
+      private Deadline deadline = Deadline.NONE;
+
+      @Override public void write(OkBuffer source, long byteCount)
           throws IOException {
         checkOffsetAndCount(source.byteCount, 0, byteCount);
         while (byteCount > 0) {
@@ -70,14 +72,20 @@
         }
       }
 
-      @Override public void flush(Deadline deadline) throws IOException {
+      @Override public void flush() throws IOException {
         out.flush();
       }
 
-      @Override public void close(Deadline deadline) throws IOException {
+      @Override public void close() throws IOException {
         out.close();
       }
 
+      @Override public Sink deadline(Deadline deadline) {
+        if (deadline == null) throw new IllegalArgumentException("deadline == null");
+        this.deadline = deadline;
+        return this;
+      }
+
       @Override public String toString() {
         return "sink(" + out + ")";
       }
@@ -87,8 +95,9 @@
   /** Returns a source that reads from {@code in}. */
   public static Source source(final InputStream in) {
     return new Source() {
-      @Override public long read(
-          OkBuffer sink, long byteCount, Deadline deadline) throws IOException {
+      private Deadline deadline = Deadline.NONE;
+
+      @Override public long read(OkBuffer sink, long byteCount) throws IOException {
         if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
         deadline.throwIfReached();
         Segment tail = sink.writableSegment(1);
@@ -100,10 +109,16 @@
         return bytesRead;
       }
 
-      @Override public void close(Deadline deadline) throws IOException {
+      @Override public void close() throws IOException {
         in.close();
       }
 
+      @Override public Source deadline(Deadline deadline) {
+        if (deadline == null) throw new IllegalArgumentException("deadline == null");
+        this.deadline = deadline;
+        return this;
+      }
+
       @Override public String toString() {
         return "source(" + in + ")";
       }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Sink.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Sink.java
index 1531366..d559290 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Sink.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Sink.java
@@ -15,22 +15,29 @@
  */
 package com.squareup.okhttp.internal.bytes;
 
+import java.io.Closeable;
 import java.io.IOException;
 
 /**
  * An alternative to OutputStream.
  */
-public interface Sink {
+public interface Sink extends Closeable {
   /** Removes {@code byteCount} bytes from {@code source} and appends them to this. */
-  void write(OkBuffer source, long byteCount, Deadline deadline) throws IOException;
+  void write(OkBuffer source, long byteCount) throws IOException;
 
   /** Pushes all buffered bytes to their final destination. */
-  void flush(Deadline deadline) throws IOException;
+  void flush() throws IOException;
 
   /**
    * Pushes all buffered bytes to their final destination and releases the
    * resources held by this sink. It is an error to write a closed sink. It is
    * safe to close a sink more than once.
    */
-  void close(Deadline deadline) throws IOException;
+  @Override void close() throws IOException;
+
+  /**
+   * Sets the deadline for all operations on this sink.
+   * @return this sink.
+   */
+  Sink deadline(Deadline deadline);
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Source.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Source.java
index 5b9a87a..52f28a3 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Source.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Source.java
@@ -15,22 +15,29 @@
  */
 package com.squareup.okhttp.internal.bytes;
 
+import java.io.Closeable;
 import java.io.IOException;
 
 /**
  * An alternative to InputStream.
  */
-public interface Source {
+public interface Source extends Closeable {
   /**
    * Removes at least 1, and up to {@code byteCount} bytes from this and appends
    * them to {@code sink}. Returns the number of bytes read, or -1 if this
    * source is exhausted.
    */
-  long read(OkBuffer sink, long byteCount, Deadline deadline) throws IOException;
+  long read(OkBuffer sink, long byteCount) throws IOException;
+
+  /**
+   * Sets the deadline for all operations on this source.
+   * @return this source.
+   */
+  Source deadline(Deadline deadline);
 
   /**
    * Closes this source and releases the resources held by this source. It is an
    * error to read a closed source. It is safe to close a source more than once.
    */
-  void close(Deadline deadline) throws IOException;
+  @Override void close() throws IOException;
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index 6b15ffe..36e42f0 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -3,7 +3,6 @@
 import com.squareup.okhttp.internal.BitArray;
 import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
-import com.squareup.okhttp.internal.bytes.Deadline;
 import com.squareup.okhttp.internal.bytes.Source;
 import java.io.IOException;
 import java.io.OutputStream;
@@ -180,7 +179,7 @@
      * set of emitted headers.
      */
     void readHeaders() throws IOException {
-      while (!source.exhausted(Deadline.NONE)) {
+      while (!source.exhausted()) {
         int b = source.readByte() & 0xff;
         if (b == 0x80) { // 10000000
           clearReferenceSet();
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index 6086423..27f66ee 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -145,7 +145,7 @@
 
         default:
           // Implementations MUST ignore frames of unsupported or unrecognized types.
-          source.skip(length, Deadline.NONE);
+          source.skip(length);
       }
       return true;
     }
@@ -282,7 +282,7 @@
     }
 
     @Override public void close() throws IOException {
-      source.close(Deadline.NONE);
+      source.close();
     }
   }
 
@@ -491,7 +491,7 @@
       this.source = source;
     }
 
-    @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
+    @Override public long read(OkBuffer sink, long byteCount)
         throws IOException {
       while (left == 0) {
         if ((flags & FLAG_END_HEADERS) != 0) return -1;
@@ -499,13 +499,18 @@
         // TODO: test case for empty continuation header?
       }
 
-      long read = source.read(sink, Math.min(byteCount, left), deadline);
+      long read = source.read(sink, Math.min(byteCount, left));
       if (read == -1) return -1;
       left -= read;
       return read;
     }
 
-    @Override public void close(Deadline deadline) throws IOException {
+    @Override public Source deadline(Deadline deadline) {
+      source.deadline(deadline);
+      return this;
+    }
+
+    @Override public void close() throws IOException {
     }
 
     private void readContinuationHeader() throws IOException {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
index 405f6fc..60e8f9b 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
@@ -36,17 +36,22 @@
     // block. We cut the inflater off at its source because we can't predict the
     // ratio of compressed bytes to uncompressed bytes.
     Source throttleSource = new Source() {
-      @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
+      @Override public long read(OkBuffer sink, long byteCount)
           throws IOException {
         if (compressedLimit == 0) return -1; // Out of data for the current block.
-        long read = source.read(sink, Math.min(byteCount, compressedLimit), deadline);
+        long read = source.read(sink, Math.min(byteCount, compressedLimit));
         if (read == -1) return -1;
         compressedLimit -= read;
         return read;
       }
 
-      @Override public void close(Deadline deadline) throws IOException {
-        source.close(deadline);
+      @Override public void close() throws IOException {
+        source.close();
+      }
+
+      @Override public Source deadline(Deadline deadline) {
+        source.deadline(deadline);
+        return this;
       }
     };
 
@@ -96,12 +101,12 @@
     // deflate compression is that sometimes there are bytes remaining in the
     // stream after we've consumed all of the content.
     if (compressedLimit > 0) {
-      inflaterSource.refill(Deadline.NONE);
+      inflaterSource.refill();
       if (compressedLimit != 0) throw new IOException("compressedLimit > 0: " + compressedLimit);
     }
   }
 
-  public void close(Deadline deadline) throws IOException {
-    source.close(deadline);
+  public void close() throws IOException {
+    source.close();
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index 27ce042..477baa2 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -20,7 +20,6 @@
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
-import com.squareup.okhttp.internal.bytes.Deadline;
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
@@ -179,7 +178,7 @@
             return true;
 
           default:
-            source.skip(length, Deadline.NONE);
+            source.skip(length);
             return true;
         }
       } else {
@@ -282,7 +281,7 @@
     }
 
     @Override public void close() throws IOException {
-      headerBlockReader.close(Deadline.NONE);
+      headerBlockReader.close();
     }
   }
 
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index aa1a2ba..f5c1678 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -20,7 +20,6 @@
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
-import com.squareup.okhttp.internal.bytes.Deadline;
 import com.squareup.okhttp.internal.bytes.OkBuffers;
 import java.io.Closeable;
 import java.io.IOException;
@@ -531,7 +530,7 @@
       SpdyStream dataStream = getStream(streamId);
       if (dataStream == null) {
         writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
-        source.skip(length, Deadline.NONE);
+        source.skip(length);
         return;
       }
       dataStream.receiveData(source, length);
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index b23bfb6..b61db2a 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -355,7 +355,7 @@
       this.maxByteCount = maxByteCount;
     }
 
-    @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
+    @Override public long read(OkBuffer sink, long byteCount)
         throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
 
@@ -366,7 +366,7 @@
         if (readBuffer.byteCount() == 0) return -1; // This source is exhausted.
 
         // Move bytes from the read buffer into the caller's buffer.
-        read = readBuffer.read(sink, Math.min(byteCount, readBuffer.byteCount()), deadline);
+        read = readBuffer.read(sink, Math.min(byteCount, readBuffer.byteCount()));
 
         // Flow control: notify the peer that we're ready for more data!
         unacknowledgedBytesRead += read;
@@ -430,26 +430,26 @@
 
         // If the peer sends more data than we can handle, discard it and close the connection.
         if (flowControlError) {
-          in.skip(byteCount, Deadline.NONE);
+          in.skip(byteCount);
           closeLater(ErrorCode.FLOW_CONTROL_ERROR);
           return;
         }
 
         // Discard data received after the stream is finished. It's probably a benign race.
         if (finished) {
-          in.skip(byteCount, Deadline.NONE);
+          in.skip(byteCount);
           return;
         }
 
         // Fill the receive buffer without holding any locks.
-        long read = in.read(receiveBuffer, byteCount, Deadline.NONE);
+        long read = in.read(receiveBuffer, byteCount);
         if (read == -1) throw new EOFException();
         byteCount -= read;
 
         // Move the received data to the read buffer to the reader can read it.
         synchronized (SpdyStream.this) {
           boolean wasEmpty = readBuffer.byteCount() == 0;
-          readBuffer.write(receiveBuffer, receiveBuffer.byteCount(), Deadline.NONE);
+          readBuffer.write(receiveBuffer, receiveBuffer.byteCount());
           if (wasEmpty) {
             SpdyStream.this.notifyAll();
           }
@@ -457,7 +457,12 @@
       }
     }
 
-    @Override public void close(Deadline deadline) throws IOException {
+    @Override public Source deadline(Deadline deadline) {
+      // TODO: honor deadlines.
+      return this;
+    }
+
+    @Override public void close() throws IOException {
       synchronized (SpdyStream.this) {
         closed = true;
         readBuffer.clear();
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/BufferedSinkTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/BufferedSinkTest.java
index f5508b3..d45785f 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/BufferedSinkTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/BufferedSinkTest.java
@@ -24,29 +24,29 @@
   @Test public void bytesEmittedToSinkWithFlush() throws Exception {
     OkBuffer sink = new OkBuffer();
     BufferedSink bufferedSink = new BufferedSink(sink);
-    bufferedSink.writeUtf8("abc", Deadline.NONE);
-    bufferedSink.flush(Deadline.NONE);
+    bufferedSink.writeUtf8("abc");
+    bufferedSink.flush();
     assertEquals(3, sink.byteCount());
   }
 
   @Test public void bytesNotEmittedToSinkWithoutFlush() throws Exception {
     OkBuffer sink = new OkBuffer();
     BufferedSink bufferedSink = new BufferedSink(sink);
-    bufferedSink.writeUtf8("abc", Deadline.NONE);
+    bufferedSink.writeUtf8("abc");
     assertEquals(0, sink.byteCount());
   }
 
   @Test public void completeSegmentsEmitted() throws Exception {
     OkBuffer sink = new OkBuffer();
     BufferedSink bufferedSink = new BufferedSink(sink);
-    bufferedSink.writeUtf8(repeat('a', Segment.SIZE * 3), Deadline.NONE);
+    bufferedSink.writeUtf8(repeat('a', Segment.SIZE * 3));
     assertEquals(Segment.SIZE * 3, sink.byteCount());
   }
 
   @Test public void incompleteSegmentsNotEmitted() throws Exception {
     OkBuffer sink = new OkBuffer();
     BufferedSink bufferedSink = new BufferedSink(sink);
-    bufferedSink.writeUtf8(repeat('a', Segment.SIZE * 3 - 1), Deadline.NONE);
+    bufferedSink.writeUtf8(repeat('a', Segment.SIZE * 3 - 1));
     assertEquals(Segment.SIZE * 2, sink.byteCount());
   }
 
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/DeflaterSinkTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/DeflaterSinkTest.java
index e1d22b9..6c18678 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/DeflaterSinkTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/DeflaterSinkTest.java
@@ -33,8 +33,8 @@
     data.writeUtf8(original);
     OkBuffer sink = new OkBuffer();
     DeflaterSink deflaterSink = new DeflaterSink(sink, new Deflater());
-    deflaterSink.write(data, data.byteCount(), Deadline.NONE);
-    deflaterSink.close(Deadline.NONE);
+    deflaterSink.write(data, data.byteCount());
+    deflaterSink.close();
     OkBuffer inflated = inflate(sink);
     assertEquals(original, inflated.readUtf8((int) inflated.byteCount()));
   }
@@ -45,8 +45,8 @@
     data.writeUtf8(original);
     OkBuffer sink = new OkBuffer();
     DeflaterSink deflaterSink = new DeflaterSink(sink, new Deflater());
-    deflaterSink.write(data, data.byteCount(), Deadline.NONE);
-    deflaterSink.flush(Deadline.NONE);
+    deflaterSink.write(data, data.byteCount());
+    deflaterSink.flush();
     OkBuffer inflated = inflate(sink);
     assertEquals(original, inflated.readUtf8((int) inflated.byteCount()));
   }
@@ -57,8 +57,8 @@
     data.writeUtf8(original);
     OkBuffer sink = new OkBuffer();
     DeflaterSink deflaterSink = new DeflaterSink(sink, new Deflater());
-    deflaterSink.write(data, data.byteCount(), Deadline.NONE);
-    deflaterSink.close(Deadline.NONE);
+    deflaterSink.write(data, data.byteCount());
+    deflaterSink.close();
     OkBuffer inflated = inflate(sink);
     assertEquals(original, inflated.readUtf8((int) inflated.byteCount()));
   }
@@ -69,8 +69,8 @@
     data.write(original);
     OkBuffer sink = new OkBuffer();
     DeflaterSink deflaterSink = new DeflaterSink(sink, new Deflater());
-    deflaterSink.write(data, data.byteCount(), Deadline.NONE);
-    deflaterSink.close(Deadline.NONE);
+    deflaterSink.write(data, data.byteCount());
+    deflaterSink.close();
     OkBuffer inflated = inflate(sink);
     assertEquals(original, inflated.readByteString((int) inflated.byteCount()));
   }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java
index d4b59b6..1f0a6da 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java
@@ -176,7 +176,7 @@
   private OkBuffer gunzip(OkBuffer gzipped) throws IOException {
     OkBuffer result = new OkBuffer();
     GzipSource source = new GzipSource(gzipped);
-    while (source.read(result, Integer.MAX_VALUE, Deadline.NONE) != -1) {
+    while (source.read(result, Integer.MAX_VALUE) != -1) {
     }
     return result;
   }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/InflaterSourceTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/InflaterSourceTest.java
index 481f024..7a56d59 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/InflaterSourceTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/InflaterSourceTest.java
@@ -88,8 +88,8 @@
   private OkBuffer deflate(OkBuffer buffer) throws IOException {
     OkBuffer result = new OkBuffer();
     Sink sink = OkBuffers.sink(new DeflaterOutputStream(new BufferedSink(result).outputStream()));
-    sink.write(buffer, buffer.byteCount(), Deadline.NONE);
-    sink.close(Deadline.NONE);
+    sink.write(buffer, buffer.byteCount());
+    sink.close();
     return result;
   }
 
@@ -103,7 +103,7 @@
   private OkBuffer inflate(OkBuffer deflated) throws IOException {
     OkBuffer result = new OkBuffer();
     InflaterSource source = new InflaterSource(deflated, new Inflater());
-    while (source.read(result, Integer.MAX_VALUE, Deadline.NONE) != -1) {
+    while (source.read(result, Integer.MAX_VALUE) != -1) {
     }
     return result;
   }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
index 97703b9..7d9540c 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
@@ -152,7 +152,7 @@
     for (String s : contents) {
       OkBuffer source = new OkBuffer();
       source.writeUtf8(s);
-      buffer.write(source, source.byteCount(), Deadline.NONE);
+      buffer.write(source, source.byteCount());
       expected.append(s);
     }
     List<Integer> segmentSizes = buffer.segmentSizes();
@@ -169,7 +169,7 @@
 
     OkBuffer source = new OkBuffer();
     source.writeUtf8(repeat('a', Segment.SIZE * 2));
-    sink.write(source, writeSize, Deadline.NONE);
+    sink.write(source, writeSize);
 
     assertEquals(asList(Segment.SIZE - 10, writeSize), sink.segmentSizes());
     assertEquals(asList(Segment.SIZE - writeSize, Segment.SIZE), source.segmentSizes());
@@ -184,7 +184,7 @@
 
     OkBuffer source = new OkBuffer();
     source.writeUtf8(repeat('a', Segment.SIZE * 2));
-    sink.write(source, writeSize, Deadline.NONE);
+    sink.write(source, writeSize);
 
     assertEquals(asList(Segment.SIZE - 10, writeSize), sink.segmentSizes());
     assertEquals(asList(Segment.SIZE - writeSize, Segment.SIZE), source.segmentSizes());
@@ -196,7 +196,7 @@
 
     OkBuffer source = new OkBuffer();
     source.writeUtf8(repeat('a', Segment.SIZE * 2));
-    sink.write(source, 20, Deadline.NONE);
+    sink.write(source, 20);
 
     assertEquals(asList(30), sink.segmentSizes());
     assertEquals(asList(Segment.SIZE - 20, Segment.SIZE), source.segmentSizes());
@@ -211,7 +211,7 @@
 
     OkBuffer source = new OkBuffer();
     source.writeUtf8(repeat('a', Segment.SIZE * 2));
-    sink.write(source, 20, Deadline.NONE);
+    sink.write(source, 20);
 
     assertEquals(asList(30), sink.segmentSizes());
     assertEquals(asList(Segment.SIZE - 20, Segment.SIZE), source.segmentSizes());
@@ -225,7 +225,7 @@
 
     OkBuffer source = new OkBuffer();
 
-    assertEquals(-1, source.read(sink, 10, Deadline.NONE));
+    assertEquals(-1, source.read(sink, 10));
     assertEquals(10, sink.byteCount());
     assertEquals(0, source.byteCount());
   }
@@ -238,7 +238,7 @@
 
     // Either 0 or -1 is reasonable here. For consistency with Android's
     // ByteArrayInputStream we return 0.
-    assertEquals(-1, source.read(sink, 0, Deadline.NONE));
+    assertEquals(-1, source.read(sink, 0));
     assertEquals(10, sink.byteCount());
     assertEquals(0, source.byteCount());
   }
@@ -250,7 +250,7 @@
     OkBuffer source = new OkBuffer();
     source.writeUtf8(repeat('b', 15));
 
-    assertEquals(10, source.read(sink, 10, Deadline.NONE));
+    assertEquals(10, source.read(sink, 10));
     assertEquals(20, sink.byteCount());
     assertEquals(5, source.byteCount());
     assertEquals(repeat('a', 10) + repeat('b', 10), sink.readUtf8(20));
@@ -263,7 +263,7 @@
     OkBuffer source = new OkBuffer();
     source.writeUtf8(repeat('b', 20));
 
-    assertEquals(20, source.read(sink, 25, Deadline.NONE));
+    assertEquals(20, source.read(sink, 25));
     assertEquals(30, sink.byteCount());
     assertEquals(0, source.byteCount());
     assertEquals(repeat('a', 10) + repeat('b', 20), sink.readUtf8(30));
@@ -336,9 +336,9 @@
 
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     Sink sink = OkBuffers.sink(out);
-    sink.write(data, 3, Deadline.NONE);
+    sink.write(data, 3);
     assertEquals("abb", out.toString("UTF-8"));
-    sink.write(data, data.byteCount(), Deadline.NONE);
+    sink.write(data, data.byteCount());
     assertEquals("a" + repeat('b', 9998) + "c", out.toString("UTF-8"));
   }
 
@@ -365,9 +365,9 @@
   @Test public void bufferedSinkEmitsTailWhenItIsComplete() throws IOException {
     OkBuffer sink = new OkBuffer();
     BufferedSink bufferedSink = new BufferedSink(sink);
-    bufferedSink.writeUtf8(repeat('a', Segment.SIZE - 1), Deadline.NONE);
+    bufferedSink.writeUtf8(repeat('a', Segment.SIZE - 1));
     assertEquals(0, sink.byteCount());
-    bufferedSink.writeByte(0, Deadline.NONE);
+    bufferedSink.writeByte(0);
     assertEquals(Segment.SIZE, sink.byteCount());
     assertEquals(0, bufferedSink.buffer.byteCount());
   }
@@ -375,14 +375,14 @@
   @Test public void bufferedSinkEmitZero() throws IOException {
     OkBuffer sink = new OkBuffer();
     BufferedSink bufferedSink = new BufferedSink(sink);
-    bufferedSink.writeUtf8("", Deadline.NONE);
+    bufferedSink.writeUtf8("");
     assertEquals(0, sink.byteCount());
   }
 
   @Test public void bufferedSinkEmitMultipleSegments() throws IOException {
     OkBuffer sink = new OkBuffer();
     BufferedSink bufferedSink = new BufferedSink(sink);
-    bufferedSink.writeUtf8(repeat('a', Segment.SIZE * 4 - 1), Deadline.NONE);
+    bufferedSink.writeUtf8(repeat('a', Segment.SIZE * 4 - 1));
     assertEquals(Segment.SIZE * 3, sink.byteCount());
     assertEquals(Segment.SIZE - 1, bufferedSink.buffer.byteCount());
   }
@@ -390,9 +390,9 @@
   @Test public void bufferedSinkFlush() throws IOException {
     OkBuffer sink = new OkBuffer();
     BufferedSink bufferedSink = new BufferedSink(sink);
-    bufferedSink.writeByte('a', Deadline.NONE);
+    bufferedSink.writeByte('a');
     assertEquals(0, sink.byteCount());
-    bufferedSink.flush(Deadline.NONE);
+    bufferedSink.flush();
     assertEquals(0, bufferedSink.buffer.byteCount());
     assertEquals(1, sink.byteCount());
   }
@@ -406,25 +406,25 @@
     OkBuffer sink = new OkBuffer();
 
     // Source: b...bc. Sink: abb.
-    assertEquals(3, source.read(sink, 3, Deadline.NONE));
+    assertEquals(3, source.read(sink, 3));
     assertEquals("abb", sink.readUtf8(3));
 
     // Source: b...bc. Sink: b...b.
-    assertEquals(Segment.SIZE, source.read(sink, 20000, Deadline.NONE));
+    assertEquals(Segment.SIZE, source.read(sink, 20000));
     assertEquals(repeat('b', Segment.SIZE), sink.readUtf8((int) sink.byteCount()));
 
     // Source: b...bc. Sink: b...bc.
-    assertEquals(Segment.SIZE - 1, source.read(sink, 20000, Deadline.NONE));
+    assertEquals(Segment.SIZE - 1, source.read(sink, 20000));
     assertEquals(repeat('b', Segment.SIZE - 2) + "c", sink.readUtf8((int) sink.byteCount()));
 
     // Source and sink are empty.
-    assertEquals(-1, source.read(sink, 1, Deadline.NONE));
+    assertEquals(-1, source.read(sink, 1));
   }
 
   @Test public void sourceFromInputStreamBounds() throws Exception {
     Source source = OkBuffers.source(new ByteArrayInputStream(new byte[100]));
     try {
-      source.read(new OkBuffer(), -1, Deadline.NONE);
+      source.read(new OkBuffer(), -1);
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -615,7 +615,7 @@
     OkBuffer sink = new OkBuffer();
     OkBuffer source = new OkBuffer();
     source.writeUtf8("abcd");
-    sink.write(source, 2, Deadline.NONE);
+    sink.write(source, 2);
     assertEquals("ab", sink.readUtf8(2));
   }
 
@@ -626,7 +626,7 @@
     BufferedSource bufferedSource = new BufferedSource(source);
     bufferedSource.buffer.writeUtf8("aa");
 
-    bufferedSource.require(2, Deadline.NONE);
+    bufferedSource.require(2);
     assertEquals(2, bufferedSource.buffer.byteCount());
     assertEquals(2, source.byteCount());
   }
@@ -638,7 +638,7 @@
     BufferedSource bufferedSource = new BufferedSource(source);
     bufferedSource.buffer.writeUtf8("a");
 
-    bufferedSource.require(2, Deadline.NONE);
+    bufferedSource.require(2);
     assertEquals("ab", bufferedSource.buffer.readUtf8(2));
   }
 
@@ -649,7 +649,7 @@
     BufferedSource bufferedSource = new BufferedSource(source);
 
     try {
-      bufferedSource.require(2, Deadline.NONE);
+      bufferedSource.require(2);
       fail();
     } catch (EOFException expected) {
     }
@@ -662,7 +662,7 @@
 
     BufferedSource bufferedSource = new BufferedSource(source);
 
-    bufferedSource.require(2, Deadline.NONE);
+    bufferedSource.require(2);
     assertEquals(Segment.SIZE, source.byteCount());
     assertEquals(Segment.SIZE, bufferedSource.buffer.byteCount());
   }
@@ -673,7 +673,7 @@
 
     BufferedSource bufferedSource = new BufferedSource(source);
     try {
-      bufferedSource.skip(2, Deadline.NONE);
+      bufferedSource.skip(2);
       fail();
     } catch (EOFException expected) {
     }
@@ -684,7 +684,7 @@
     source.writeUtf8(repeat('a', Segment.SIZE));
     source.writeUtf8(repeat('b', Segment.SIZE));
     BufferedSource bufferedSource = new BufferedSource(source);
-    bufferedSource.skip(2, Deadline.NONE);
+    bufferedSource.skip(2);
     assertEquals(Segment.SIZE, source.byteCount());
     assertEquals(Segment.SIZE - 2, bufferedSource.buffer.byteCount());
   }
@@ -696,7 +696,7 @@
     BufferedSource bufferedSource = new BufferedSource(source);
     bufferedSource.buffer.writeUtf8("aa");
 
-    bufferedSource.skip(2, Deadline.NONE);
+    bufferedSource.skip(2);
     assertEquals(0, bufferedSource.buffer.byteCount());
     assertEquals(2, source.byteCount());
   }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index 287bfb1..ae89284 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -18,7 +18,6 @@
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
-import com.squareup.okhttp.internal.bytes.Deadline;
 import com.squareup.okhttp.internal.bytes.OkBuffer;
 import com.squareup.okhttp.internal.bytes.Source;
 import java.io.IOException;
@@ -33,7 +32,6 @@
 import static com.squareup.okhttp.internal.Util.UTF_8;
 import static com.squareup.okhttp.internal.Util.headerEntries;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.CANCEL;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.FLOW_CONTROL_ERROR;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.INTERNAL_ERROR;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.INVALID_STREAM;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.PROTOCOL_ERROR;
@@ -551,9 +549,9 @@
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
     Source in = stream.getSource();
     OutputStream out = stream.getOutputStream();
-    in.close(Deadline.NONE);
+    in.close();
     try {
-      in.read(new OkBuffer(), 1, Deadline.NONE);
+      in.read(new OkBuffer(), 1);
       fail();
     } catch (IOException expected) {
       assertEquals("stream closed", expected.getMessage());
@@ -594,9 +592,9 @@
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     Source source = stream.getSource();
     OutputStream out = stream.getOutputStream();
-    source.close(Deadline.NONE);
+    source.close();
     try {
-      source.read(new OkBuffer(), 1, Deadline.NONE);
+      source.read(new OkBuffer(), 1);
       fail();
     } catch (IOException expected) {
       assertEquals("stream closed", expected.getMessage());
@@ -662,7 +660,7 @@
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
     try {
-      stream.getSource().read(new OkBuffer(), 1, Deadline.NONE);
+      stream.getSource().read(new OkBuffer(), 1);
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: STREAM_IN_USE", expected.getMessage());
@@ -918,7 +916,7 @@
       assertEquals("stream was reset: CANCEL", expected.getMessage());
     }
     try {
-      stream.getSource().read(new OkBuffer(), 1, Deadline.NONE);
+      stream.getSource().read(new OkBuffer(), 1);
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: CANCEL", expected.getMessage());
@@ -963,7 +961,7 @@
     Source source = stream.getSource();
     long startNanos = System.nanoTime();
     try {
-      source.read(new OkBuffer(), 1, Deadline.NONE);
+      source.read(new OkBuffer(), 1);
       fail();
     } catch (IOException expected) {
     }
@@ -1067,10 +1065,10 @@
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     Source in = stream.getSource();
     OkBuffer buffer = new OkBuffer();
-    while (in.read(buffer, 1024, Deadline.NONE) != -1) {
+    while (in.read(buffer, 1024) != -1) {
       if (buffer.byteCount() == 3 * windowUpdateThreshold) break;
     }
-    assertEquals(-1, in.read(buffer, 1, Deadline.NONE));
+    assertEquals(-1, in.read(buffer, 1));
 
     // Verify the peer received what was expected.
     assertEquals(21, peer.frameCount());
@@ -1110,7 +1108,7 @@
     // Play it back.
     SpdyConnection connection = connection(peer, variant);
     SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(-1, client.getSource().read(new OkBuffer(), 1, Deadline.NONE));
+    assertEquals(-1, client.getSource().read(new OkBuffer(), 1));
 
     // Verify the peer received what was expected.
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
@@ -1462,7 +1460,7 @@
 
   private void assertStreamData(String expected, Source source) throws IOException {
     OkBuffer buffer = new OkBuffer();
-    while (source.read(buffer, Long.MAX_VALUE, Deadline.NONE) != -1) {
+    while (source.read(buffer, Long.MAX_VALUE) != -1) {
     }
     String actual = buffer.readUtf8((int) buffer.byteCount());
     assertEquals(expected, actual);
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index b8d2f26..1b81e5e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -19,7 +19,6 @@
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.bytes.BufferedSource;
 import com.squareup.okhttp.internal.bytes.ByteString;
-import com.squareup.okhttp.internal.bytes.Deadline;
 import com.squareup.okhttp.internal.bytes.OkBuffers;
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpConnection;
@@ -215,7 +214,7 @@
       int readTimeout = socket.getSoTimeout();
       try {
         socket.setSoTimeout(1);
-        if (source.source.read(source.buffer, 1, Deadline.NONE) == -1) {
+        if (source.source.read(source.buffer, 1) == -1) {
           return false; // Stream is exhausted; socket is closed.
         }
         return true;
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
index de5ae15..eadfb42 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
@@ -174,7 +174,7 @@
   }
 
   private String readLine() throws IOException {
-    long newline = source.seek((byte) '\n', Deadline.NONE);
+    long newline = source.seek((byte) '\n');
 
     if (newline > 0 && source.buffer.getByte(newline - 1) == '\r') {
       // Read everything until '\r\n', then skip the '\r\n'.
@@ -483,13 +483,13 @@
       }
     }
 
-    @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
+    @Override public long read(OkBuffer sink, long byteCount)
         throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
       if (closed) throw new IllegalStateException("closed");
       if (bytesRemaining == 0) return -1;
 
-      long read = source.read(sink, Math.min(bytesRemaining, byteCount), deadline);
+      long read = source.read(sink, Math.min(bytesRemaining, byteCount));
       if (read == -1) {
         unexpectedEndOfInput(); // the server didn't supply the promised content length
         throw new ProtocolException("unexpected end of stream");
@@ -503,7 +503,12 @@
       return read;
     }
 
-    @Override public void close(Deadline deadline) throws IOException {
+    @Override public Source deadline(Deadline deadline) {
+      source.deadline(deadline);
+      return this;
+    }
+
+    @Override public void close() throws IOException {
       if (closed) return;
 
       if (bytesRemaining != 0 && !discard(this, DISCARD_STREAM_TIMEOUT_MILLIS)) {
@@ -527,7 +532,7 @@
     }
 
     @Override public long read(
-        OkBuffer sink, long byteCount, Deadline deadline) throws IOException {
+        OkBuffer sink, long byteCount) throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
       if (closed) throw new IllegalStateException("closed");
       if (!hasMoreChunks) return -1;
@@ -537,7 +542,7 @@
         if (!hasMoreChunks) return -1;
       }
 
-      long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk), deadline);
+      long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
       if (read == -1) {
         unexpectedEndOfInput(); // the server didn't supply the promised chunk length
         throw new IOException("unexpected end of stream");
@@ -571,7 +576,12 @@
       }
     }
 
-    @Override public void close(Deadline deadline) throws IOException {
+    @Override public Source deadline(Deadline deadline) {
+      source.deadline(deadline);
+      return this;
+    }
+
+    @Override public void close() throws IOException {
       if (closed) return;
       if (hasMoreChunks && !discard(this, DISCARD_STREAM_TIMEOUT_MILLIS)) {
         unexpectedEndOfInput();
@@ -588,13 +598,13 @@
       super(cacheRequest);
     }
 
-    @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
+    @Override public long read(OkBuffer sink, long byteCount)
         throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
       if (closed) throw new IllegalStateException("closed");
       if (inputExhausted) return -1;
 
-      long read = source.read(sink, byteCount, deadline);
+      long read = source.read(sink, byteCount);
       if (read == -1) {
         inputExhausted = true;
         endOfInput();
@@ -604,7 +614,12 @@
       return read;
     }
 
-    @Override public void close(Deadline deadline) throws IOException {
+    @Override public Source deadline(Deadline deadline) {
+      source.deadline(deadline);
+      return this;
+    }
+
+    @Override public void close() throws IOException {
       if (closed) return;
       // TODO: discard unknown length streams for best caching?
       if (!inputExhausted) {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index b4c1e62..e159fb5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -257,13 +257,13 @@
       this.cacheRequest = cacheRequest;
     }
 
-    @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
+    @Override public long read(OkBuffer sink, long byteCount)
         throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
       if (closed) throw new IllegalStateException("closed");
       if (inputExhausted) return -1;
 
-      long read = source.read(sink, byteCount, deadline);
+      long read = source.read(sink, byteCount);
       if (read == -1) {
         inputExhausted = true;
         if (cacheRequest != null) {
@@ -279,7 +279,12 @@
       return read;
     }
 
-    @Override public void close(Deadline deadline) throws IOException {
+    @Override public Source deadline(Deadline deadline) {
+      source.deadline(deadline);
+      return this;
+    }
+
+    @Override public void close() throws IOException {
       if (closed) return;
 
       if (!inputExhausted && cacheBody != null) {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
index 99aa917..e522cc8 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -350,17 +350,6 @@
     return result;
   }
 
-  /** Mutates the byte array to ensure all characters are lowercase. */
-  public static void asciiLowerCase(byte[] bytes) {
-    for (int i = 0; i < bytes.length; i++) {
-      bytes[i] = asciiLowerCase(bytes[i]);
-    }
-  }
-
-  public static byte asciiLowerCase(byte c) {
-    return 'A' <= c && c <= 'Z' ? (byte) (c + 'a' - 'A') : c;
-  }
-
   public static int reverseBytesShort(short s) {
     int i = s & 0xffff;
     return (i & 0xff00) >>> 8
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/ByteString.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/ByteString.java
index a62b3fa..78674ce 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/ByteString.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/ByteString.java
@@ -21,8 +21,6 @@
 import java.io.OutputStream;
 import java.util.Arrays;
 
-import static com.squareup.okhttp.internal.Util.asciiLowerCase;
-
 /**
  * An immutable sequence of bytes.
  *
@@ -111,20 +109,6 @@
   }
 
   /**
-   * Reads {@code count} bytes from {@code in} and returns the result converted
-   * to ASCII lowercase.
-   *
-   * @throws java.io.EOFException if {@code in} has fewer than {@code count}
-   * bytes to read.
-   */
-  public static ByteString readLowerCase(InputStream in, int count) throws IOException {
-    byte[] result = new byte[count];
-    Util.readFully(in, result);
-    asciiLowerCase(result);
-    return new ByteString(result);
-  }
-
-  /**
    * Returns a byte string equal to this byte string, but with the bytes 'A'
    * through 'Z' replaced with the corresponding byte in 'a' through 'z'.
    * Returns this byte string if it contains no bytes in 'A' through 'Z'.
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
index 7a57eed..072db85 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
@@ -72,9 +72,9 @@
 
   @Test public void readLowerCase() throws Exception {
     InputStream in = new ByteArrayInputStream("ABC".getBytes(Util.UTF_8));
-    assertEquals(ByteString.of((byte) 0x61, (byte) 0x62), ByteString.readLowerCase(in, 2));
-    assertEquals(ByteString.of((byte) 0x63), ByteString.readLowerCase(in, 1));
-    assertEquals(ByteString.of(), ByteString.readLowerCase(in, 0));
+    assertEquals(ByteString.encodeUtf8("ab"), ByteString.read(in, 2).toAsciiLowercase());
+    assertEquals(ByteString.encodeUtf8("c"), ByteString.read(in, 1).toAsciiLowercase());
+    assertEquals(ByteString.EMPTY, ByteString.read(in, 0).toAsciiLowercase());
   }
 
   @Test public void toAsciiLowerCaseNoUppercase() throws Exception {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Dns.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Dns.java
index 69b2d37..a89b293 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Dns.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Dns.java
@@ -25,6 +25,7 @@
 public interface Dns {
   Dns DEFAULT = new Dns() {
     @Override public InetAddress[] getAllByName(String host) throws UnknownHostException {
+      if (host == null) throw new UnknownHostException("host == null");
       return InetAddress.getAllByName(host);
     }
   };
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index 05fd469..36312ed 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -399,6 +399,17 @@
     testServerClosesOutput(SHUTDOWN_OUTPUT_AT_END);
   }
 
+  @Test public void invalidHost() throws Exception {
+    // Note that 1234.1.1.1 is an invalid host in a URI, but URL isn't as strict.
+    URL url = new URL("http://1234.1.1.1/index.html");
+    HttpURLConnection connection = client.open(url);
+    try {
+      connection.connect();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
   private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception {
     server.enqueue(new MockResponse().setBody("This connection won't pool properly")
         .setSocketPolicy(socketPolicy));
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
index bd0fc5c..46fec49 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
@@ -85,6 +85,14 @@
     if (section == SECTION_TRAILER) {
       consumeTrailer();
       section = SECTION_DONE;
+
+      // Gzip streams self-terminate: they return -1 before their underlying
+      // source returns -1. Here we attempt to force the underlying stream to
+      // return -1 which may trigger it to release its resources. If it doesn't
+      // return -1, then our Gzip data finished prematurely!
+      if (!source.exhausted(deadline)) {
+        throw new IOException("gzip finished without exhausting source");
+      }
     }
 
     return -1;
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java
index 1f0a6da..c2fdbdc 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java
@@ -22,6 +22,8 @@
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public class GzipSourceTest {
@@ -149,6 +151,50 @@
     }
   }
 
+  @Test public void gunzipExhaustsSource() throws Exception {
+    byte[] abcGzipped = {
+        (byte) 0x1f, (byte) 0x8b, (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+        (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x4b, (byte) 0x4c, (byte) 0x4a, (byte) 0x06,
+        (byte) 0x00, (byte) 0xc2, (byte) 0x41, (byte) 0x24, (byte) 0x35, (byte) 0x03, (byte) 0x00,
+        (byte) 0x00, (byte) 0x00
+    };
+    OkBuffer gzippedSource = new OkBuffer();
+    gzippedSource.write(abcGzipped, 0, abcGzipped.length);
+
+    ExhaustableSource exhaustableSource = new ExhaustableSource(gzippedSource);
+    BufferedSource gunzippedSource = new BufferedSource(new GzipSource(exhaustableSource));
+
+    assertEquals('a', gunzippedSource.readByte());
+    assertEquals('b', gunzippedSource.readByte());
+    assertEquals('c', gunzippedSource.readByte());
+    assertFalse(exhaustableSource.exhausted);
+    assertEquals(-1, gunzippedSource.read(new OkBuffer(), 1, Deadline.NONE));
+    assertTrue(exhaustableSource.exhausted);
+  }
+
+  @Test public void gunzipThrowsIfSourceIsNotExhausted() throws Exception {
+    byte[] abcGzipped = {
+        (byte) 0x1f, (byte) 0x8b, (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+        (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x4b, (byte) 0x4c, (byte) 0x4a, (byte) 0x06,
+        (byte) 0x00, (byte) 0xc2, (byte) 0x41, (byte) 0x24, (byte) 0x35, (byte) 0x03, (byte) 0x00,
+        (byte) 0x00, (byte) 0x00
+    };
+    OkBuffer gzippedSource = new OkBuffer();
+    gzippedSource.write(abcGzipped, 0, abcGzipped.length);
+    gzippedSource.writeByte('d'); // This byte shouldn't be here!
+
+    BufferedSource gunzippedSource = new BufferedSource(new GzipSource(gzippedSource));
+
+    assertEquals('a', gunzippedSource.readByte());
+    assertEquals('b', gunzippedSource.readByte());
+    assertEquals('c', gunzippedSource.readByte());
+    try {
+      gunzippedSource.readByte();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
   private byte[] gzipHeaderWithFlags(byte flags) {
     byte[] result = Arrays.copyOf(gzipHeader, gzipHeader.length);
     result[3] = flags;
@@ -180,4 +226,25 @@
     }
     return result;
   }
+
+  /** This source keeps track of whether its read have returned -1. */
+  static class ExhaustableSource implements Source {
+    private final Source source;
+    private boolean exhausted;
+
+    ExhaustableSource(Source source) {
+      this.source = source;
+    }
+
+    @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
+        throws IOException {
+      long result = source.read(sink, byteCount, deadline);
+      if (result == -1) exhausted = true;
+      return result;
+    }
+
+    @Override public void close(Deadline deadline) throws IOException {
+      source.close(deadline);
+    }
+  }
 }
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index 83cabde..18d4f75 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -124,7 +124,7 @@
   byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
 
   /** An output stream can be written to more than once, so we can't guess content length. */
-   @Test public void noDefaultContentLengthOnPost() throws Exception {
+  @Test public void noDefaultContentLengthOnPost() throws Exception {
     MockResponse response = new MockResponse().setBody("ABCDE");
     server.enqueue(response);
     server.play();
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
index 46fec49..ffe1b55 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java
@@ -90,7 +90,7 @@
       // source returns -1. Here we attempt to force the underlying stream to
       // return -1 which may trigger it to release its resources. If it doesn't
       // return -1, then our Gzip data finished prematurely!
-      if (!source.exhausted(deadline)) {
+      if (!source.exhausted()) {
         throw new IOException("gzip finished without exhausting source");
       }
     }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java
index c2fdbdc..e640bfb 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/GzipSourceTest.java
@@ -168,7 +168,7 @@
     assertEquals('b', gunzippedSource.readByte());
     assertEquals('c', gunzippedSource.readByte());
     assertFalse(exhaustableSource.exhausted);
-    assertEquals(-1, gunzippedSource.read(new OkBuffer(), 1, Deadline.NONE));
+    assertEquals(-1, gunzippedSource.read(new OkBuffer(), 1));
     assertTrue(exhaustableSource.exhausted);
   }
 
@@ -236,15 +236,19 @@
       this.source = source;
     }
 
-    @Override public long read(OkBuffer sink, long byteCount, Deadline deadline)
-        throws IOException {
-      long result = source.read(sink, byteCount, deadline);
+    @Override public long read(OkBuffer sink, long byteCount) throws IOException {
+      long result = source.read(sink, byteCount);
       if (result == -1) exhausted = true;
       return result;
     }
 
-    @Override public void close(Deadline deadline) throws IOException {
-      source.close(deadline);
+    @Override public Source deadline(Deadline deadline) {
+      source.deadline(deadline);
+      return this;
+    }
+
+    @Override public void close() throws IOException {
+      source.close();
     }
   }
 }
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 832f790..7a0e754 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -63,7 +63,7 @@
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
 import okio.ByteString;
-import okio.OkBuffers;
+import okio.Okio;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
@@ -656,7 +656,7 @@
         }
       }
 
-      InputStream bodyIn = OkBuffers.buffer(stream.getSource()).inputStream();
+      InputStream bodyIn = Okio.buffer(stream.getSource()).inputStream();
       ByteArrayOutputStream bodyOut = new ByteArrayOutputStream();
       byte[] buffer = new byte[8192];
       int count;
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
index 6ce965f..f3f04fd 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -39,6 +39,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.ThreadFactory;
+import okio.ByteString;
 import okio.OkBuffer;
 import okio.Sink;
 import okio.Source;
@@ -57,9 +58,6 @@
   /** A cheap and type-safe constant for the UTF-8 Charset. */
   public static final Charset UTF_8 = Charset.forName("UTF-8");
 
-  private static final char[] DIGITS =
-      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
-
   private Util() {
   }
 
@@ -303,7 +301,7 @@
     try {
       MessageDigest messageDigest = MessageDigest.getInstance("MD5");
       byte[] md5bytes = messageDigest.digest(s.getBytes("UTF-8"));
-      return bytesToHexString(md5bytes);
+      return ByteString.of(md5bytes).hex();
     } catch (NoSuchAlgorithmException e) {
       throw new AssertionError(e);
     } catch (UnsupportedEncodingException e) {
@@ -311,17 +309,6 @@
     }
   }
 
-  private static String bytesToHexString(byte[] bytes) {
-    char[] digits = DIGITS;
-    char[] buf = new char[bytes.length * 2];
-    int c = 0;
-    for (byte b : bytes) {
-      buf[c++] = digits[(b >> 4) & 0xf];
-      buf[c++] = digits[b & 0xf];
-    }
-    return new String(buf);
-  }
-
   /** Returns an immutable copy of {@code list}. */
   public static <T> List<T> immutableList(List<T> list) {
     return Collections.unmodifiableList(new ArrayList<T>(list));
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index 6149094..e16f038 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -11,7 +11,7 @@
 import java.util.Map;
 import okio.BufferedSource;
 import okio.ByteString;
-import okio.OkBuffers;
+import okio.Okio;
 import okio.Source;
 
 /**
@@ -125,7 +125,7 @@
     Reader(boolean client, int maxHeaderTableByteCount, Source source) {
       this.huffmanCodec = client ? Huffman.Codec.RESPONSE : Huffman.Codec.REQUEST;
       this.maxHeaderTableByteCount = maxHeaderTableByteCount;
-      this.source = OkBuffers.buffer(source);
+      this.source = Okio.buffer(source);
     }
 
     int maxHeaderTableByteCount() {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
index 69deb22..293d817 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
@@ -10,7 +10,7 @@
 import okio.Deadline;
 import okio.InflaterSource;
 import okio.OkBuffer;
-import okio.OkBuffers;
+import okio.Okio;
 import okio.Source;
 
 /**
@@ -70,7 +70,7 @@
     };
 
     this.inflaterSource = new InflaterSource(throttleSource, inflater);
-    this.source = OkBuffers.buffer(inflaterSource);
+    this.source = Okio.buffer(inflaterSource);
   }
 
   public List<Header> readNameValueBlock(int length) throws IOException {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index f5a1620..3f2ac90 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -33,7 +33,7 @@
 import java.util.concurrent.TimeUnit;
 import okio.BufferedSource;
 import okio.ByteString;
-import okio.OkBuffers;
+import okio.Okio;
 
 /**
  * A socket connection to a remote peer. A connection hosts streams which can
@@ -464,7 +464,7 @@
     private boolean client;
 
     public Builder(boolean client, Socket socket) throws IOException {
-      this("", client, OkBuffers.buffer(OkBuffers.source(socket.getInputStream())),
+      this("", client, Okio.buffer(Okio.source(socket.getInputStream())),
           socket.getOutputStream());
     }
 
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
index 4e78b5c..db2774e 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
@@ -26,17 +26,18 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 public class ByteStringTest {
 
   @Test public void equals() throws Exception {
-    ByteString byteString = ByteString.of((byte) 0x0, (byte) 0x1, (byte) 0x2);
+    ByteString byteString = ByteString.decodeHex("000102");
     assertTrue(byteString.equals(byteString));
-    assertTrue(byteString.equals(ByteString.of((byte) 0x0, (byte) 0x1, (byte) 0x2)));
+    assertTrue(byteString.equals(ByteString.decodeHex("000102")));
     assertTrue(ByteString.of().equals(ByteString.EMPTY));
     assertTrue(ByteString.EMPTY.equals(ByteString.of()));
     assertFalse(byteString.equals(new Object()));
-    assertFalse(byteString.equals(ByteString.of((byte) 0x0, (byte) 0x2, (byte) 0x1)));
+    assertFalse(byteString.equals(ByteString.decodeHex("000201")));
   }
 
   private final String bronzeHorseman = "?? ?????? ????????? ????";
@@ -58,15 +59,15 @@
   }
 
   @Test public void testHashCode() throws Exception {
-    ByteString byteString = ByteString.of((byte) 0x1, (byte) 0x2);
+    ByteString byteString = ByteString.decodeHex("0102");
     assertEquals(byteString.hashCode(), byteString.hashCode());
-    assertEquals(byteString.hashCode(), ByteString.of((byte) 0x1, (byte) 0x2).hashCode());
+    assertEquals(byteString.hashCode(), ByteString.decodeHex("0102").hashCode());
   }
 
   @Test public void read() throws Exception {
     InputStream in = new ByteArrayInputStream("abc".getBytes(Util.UTF_8));
-    assertEquals(ByteString.of((byte) 0x61, (byte) 0x62), ByteString.read(in, 2));
-    assertEquals(ByteString.of((byte) 0x63), ByteString.read(in, 1));
+    assertEquals(ByteString.decodeHex("6162"), ByteString.read(in, 2));
+    assertEquals(ByteString.decodeHex("63"), ByteString.read(in, 1));
     assertEquals(ByteString.of(), ByteString.read(in, 0));
   }
 
@@ -92,7 +93,7 @@
 
   @Test public void write() throws Exception {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
-    ByteString.of((byte) 0x61, (byte) 0x62, (byte) 0x63).write(out);
+    ByteString.decodeHex("616263").write(out);
     assertByteArraysEquals(new byte[] { 0x61, 0x62, 0x63 }, out.toByteArray());
   }
 
@@ -123,16 +124,16 @@
   @Test public void decodeBase64() {
     assertEquals("", ByteString.decodeBase64("").utf8());
     assertEquals(null, ByteString.decodeBase64("/===")); // Can't do anything with 6 bits!
-    assertEquals(bytes(0xff), ByteString.decodeBase64("//=="));
-    assertEquals(bytes(0xff, 0xff), ByteString.decodeBase64("///="));
-    assertEquals(bytes(0xff, 0xff, 0xff), ByteString.decodeBase64("////"));
-    assertEquals(bytes(0xff, 0xff, 0xff, 0xff, 0xff, 0xff), ByteString.decodeBase64("////////"));
+    assertEquals(ByteString.decodeHex("ff"), ByteString.decodeBase64("//=="));
+    assertEquals(ByteString.decodeHex("ffff"), ByteString.decodeBase64("///="));
+    assertEquals(ByteString.decodeHex("ffffff"), ByteString.decodeBase64("////"));
+    assertEquals(ByteString.decodeHex("ffffffffffff"), ByteString.decodeBase64("////////"));
     assertEquals("What's to be scared about? It's just a little hiccup in the power...",
         ByteString.decodeBase64("V2hhdCdzIHRvIGJlIHNjYXJlZCBhYm91dD8gSXQncyBqdXN0IGEgbGl0dGxlIGhpY2"
             + "N1cCBpbiB0aGUgcG93ZXIuLi4=").utf8());
   }
 
-  @Test public void decodeWithWhitespace() {
+  @Test public void decodeBase64WithWhitespace() {
     assertEquals("\u0000\u0000\u0000", ByteString.decodeBase64(" AA AA ").utf8());
     assertEquals("\u0000\u0000\u0000", ByteString.decodeBase64(" AA A\r\nA ").utf8());
     assertEquals("\u0000\u0000\u0000", ByteString.decodeBase64("AA AA").utf8());
@@ -142,13 +143,28 @@
     assertEquals("", ByteString.decodeBase64("    ").utf8());
   }
 
-  /** Make it easy to make varargs calls. Otherwise we need a lot of (byte) casts. */
-  private ByteString bytes(int... bytes) {
-    byte[] result = new byte[bytes.length];
-    for (int i = 0; i < bytes.length; i++) {
-      result[i] = (byte) bytes[i];
+  @Test public void encodeHex() throws Exception {
+    assertEquals("000102", ByteString.of((byte) 0x0, (byte) 0x1, (byte) 0x2).hex());
+  }
+
+  @Test public void decodeHex() throws Exception {
+    assertEquals(ByteString.of((byte) 0x0, (byte) 0x1, (byte) 0x2), ByteString.decodeHex("000102"));
+  }
+
+  @Test public void decodeHexOddNumberOfChars() throws Exception {
+    try {
+      ByteString.decodeHex("aaa");
+      fail();
+    } catch (IllegalArgumentException expected) {
     }
-    return ByteString.of(result);
+  }
+
+  @Test public void decodeHexInvalidChar() throws Exception {
+    try {
+      ByteString.decodeHex("a\u0000");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
   }
 
   private static void assertByteArraysEquals(byte[] a, byte[] b) {
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index 49ef96d..e480e41 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -23,7 +23,7 @@
 import java.util.Arrays;
 import java.util.List;
 import okio.ByteString;
-import okio.OkBuffers;
+import okio.Okio;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -800,7 +800,7 @@
   }
 
   private HpackDraft05.Reader newReader(InputStream input) {
-    return new HpackDraft05.Reader(false, 4096, OkBuffers.source(input));
+    return new HpackDraft05.Reader(false, 4096, Okio.source(input));
   }
 
   private InputStream byteStream(int... bytes) {
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index 5885a5a..939bb99 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -33,7 +33,7 @@
 import java.util.concurrent.LinkedBlockingQueue;
 import okio.BufferedSource;
 import okio.ByteString;
-import okio.OkBuffers;
+import okio.Okio;
 
 /** Replays prerecorded outgoing frames and records incoming frames. */
 public final class MockSpdyPeer implements Closeable {
@@ -118,7 +118,7 @@
     socket = serverSocket.accept();
     OutputStream out = socket.getOutputStream();
     InputStream in = socket.getInputStream();
-    FrameReader reader = variant.newReader(OkBuffers.buffer(OkBuffers.source(in)), client);
+    FrameReader reader = variant.newReader(Okio.buffer(Okio.source(in)), client);
 
     Iterator<OutFrame> outFramesIterator = outFrames.iterator();
     byte[] outBytes = bytesOut.toByteArray();
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index 6152d2c..30994e3 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -24,7 +24,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import okio.ByteString;
 import okio.OkBuffer;
-import okio.OkBuffers;
+import okio.Okio;
 import okio.Source;
 import org.junit.After;
 import org.junit.Test;
@@ -1252,7 +1252,7 @@
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     Source in = stream.getSource();
     try {
-      OkBuffers.buffer(in).readByteString(101);
+      Okio.buffer(in).readByteString(101);
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index d0cb3c9..3e24376 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -34,7 +34,7 @@
 import javax.net.ssl.SSLSocket;
 import okio.BufferedSource;
 import okio.ByteString;
-import okio.OkBuffers;
+import okio.Okio;
 
 import static java.net.HttpURLConnection.HTTP_OK;
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
@@ -306,7 +306,7 @@
    * retried if the proxy requires authorization.
    */
   private void makeTunnel(TunnelRequest tunnelRequest) throws IOException {
-    BufferedSource tunnelSource = OkBuffers.buffer(OkBuffers.source(in));
+    BufferedSource tunnelSource = Okio.buffer(Okio.source(in));
     HttpConnection tunnelConnection = new HttpConnection(pool, this, tunnelSource, out);
     Request request = tunnelRequest.getRequest();
     String requestLine = tunnelRequest.requestLine();
@@ -338,7 +338,7 @@
   }
 
   private void streamWrapper() throws IOException {
-    source = OkBuffers.buffer(OkBuffers.source(in));
+    source = Okio.buffer(Okio.source(in));
     out = new BufferedOutputStream(out, 256);
   }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Job.java b/okhttp/src/main/java/com/squareup/okhttp/Job.java
index be08cb9..84cc6c5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Job.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Job.java
@@ -25,7 +25,7 @@
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.URL;
-import okio.OkBuffers;
+import okio.Okio;
 import okio.Source;
 
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
@@ -264,7 +264,7 @@
       InputStream result = in;
       return result != null
           ? result
-          : (in = OkBuffers.buffer(source).inputStream());
+          : (in = Okio.buffer(source).inputStream());
     }
   }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index 346ef76..13f9124 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -32,7 +32,7 @@
 import java.util.List;
 import java.util.Set;
 import java.util.TreeSet;
-import okio.OkBuffers;
+import okio.Okio;
 import okio.Source;
 
 import static com.squareup.okhttp.internal.Util.UTF_8;
@@ -221,7 +221,7 @@
     // TODO: Source needs to be an API type for this to be public
     public Source source() {
       Source s = source;
-      return s != null ? s : (source = OkBuffers.source(byteStream()));
+      return s != null ? s : (source = Okio.source(byteStream()));
     }
 
     public final byte[] bytes() throws IOException {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
index a20367d..3ba72c6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
@@ -32,7 +32,7 @@
 import okio.BufferedSource;
 import okio.Deadline;
 import okio.OkBuffer;
-import okio.OkBuffers;
+import okio.Okio;
 import okio.Source;
 
 import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
@@ -425,7 +425,7 @@
     /** Copy the last {@code byteCount} bytes of {@code source} to the cache body. */
     protected final void cacheWrite(OkBuffer source, long byteCount) throws IOException {
       if (cacheBody != null) {
-        OkBuffers.copy(source, source.byteCount() - byteCount, byteCount, cacheBody);
+        Okio.copy(source, source.byteCount() - byteCount, byteCount, cacheBody);
       }
     }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index e053d88..bffac3d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -43,7 +43,7 @@
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocketFactory;
 import okio.GzipSource;
-import okio.OkBuffers;
+import okio.Okio;
 import okio.Source;
 
 import static com.squareup.okhttp.internal.Util.closeQuietly;
@@ -290,7 +290,7 @@
     InputStream result = responseBodyBytes;
     return result != null
         ? result
-        : (responseBodyBytes = OkBuffers.buffer(getResponseBody()).inputStream());
+        : (responseBodyBytes = Okio.buffer(getResponseBody()).inputStream());
   }
 
   public final Connection getConnection() {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 4030272..6c287aa 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -37,7 +37,7 @@
 import okio.ByteString;
 import okio.Deadline;
 import okio.OkBuffer;
-import okio.OkBuffers;
+import okio.Okio;
 import okio.Source;
 
 import static com.squareup.okhttp.internal.spdy.Header.RESPONSE_STATUS;
@@ -273,7 +273,7 @@
       }
 
       if (cacheBody != null) {
-        OkBuffers.copy(sink, sink.byteCount() - read, read, cacheBody);
+        Okio.copy(sink, sink.byteCount() - read, read, cacheBody);
       }
 
       return read;
/Fim/
diff --git a/okio/src/main/java/okio/ByteString.java b/okio/src/main/java/okio/ByteString.java
index 4439e9a..9223a86 100644
--- a/okio/src/main/java/okio/ByteString.java
+++ b/okio/src/main/java/okio/ByteString.java
@@ -32,6 +32,9 @@
  * process.
  */
 public final class ByteString {
+  private static final char[] HEX_DIGITS =
+      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
+
   final byte[] data;
   private transient int hashCode; // Lazily computed; 0 if unknown.
   private transient String utf8; // Lazily computed.
@@ -78,6 +81,37 @@
     return decoded != null ? new ByteString(decoded) : null;
   }
 
+  /** Returns this byte string encoded in hexadecimal. */
+  public String hex() {
+    char[] result = new char[data.length * 2];
+    int c = 0;
+    for (byte b : data) {
+      result[c++] = HEX_DIGITS[(b >> 4) & 0xf];
+      result[c++] = HEX_DIGITS[b & 0xf];
+    }
+    return new String(result);
+  }
+
+  /** Decodes the hex-encoded bytes and returns their value a byte string. */
+  public static ByteString decodeHex(String hex) {
+    if (hex.length() % 2 != 0) throw new IllegalArgumentException("Unexpected hex string: " + hex);
+
+    byte[] result = new byte[hex.length() / 2];
+    for (int i = 0; i < result.length; i++) {
+      int d1 = decodeHexDigit(hex.charAt(i * 2)) << 4;
+      int d2 = decodeHexDigit(hex.charAt(i * 2 + 1));
+      result[i] = (byte) (d1 + d2);
+    }
+    return of(result);
+  }
+
+  private static int decodeHexDigit(char c) {
+    if (c >= '0' && c <= '9') return c - '0';
+    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
+    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
+    throw new IllegalArgumentException("Unexpected hex digit: " + c);
+  }
+
   /**
    * Returns true when {@code ascii} is not null and equals the bytes wrapped
    * by this byte string.
/Fim/
diff --git a/okio/src/main/java/okio/DeflaterSink.java b/okio/src/main/java/okio/DeflaterSink.java
index b934b2d..43a964c 100644
--- a/okio/src/main/java/okio/DeflaterSink.java
+++ b/okio/src/main/java/okio/DeflaterSink.java
@@ -40,7 +40,7 @@
   private final Deflater deflater;
 
   public DeflaterSink(Sink sink, Deflater deflater) {
-    this.sink = OkBuffers.buffer(sink);
+    this.sink = Okio.buffer(sink);
     this.deflater = deflater;
   }
 
/Fim/
diff --git a/okio/src/main/java/okio/GzipSource.java b/okio/src/main/java/okio/GzipSource.java
index a8cf109..26fbaac 100644
--- a/okio/src/main/java/okio/GzipSource.java
+++ b/okio/src/main/java/okio/GzipSource.java
@@ -54,7 +54,7 @@
 
   public GzipSource(Source source) throws IOException {
     this.inflater = new Inflater(true);
-    this.source = OkBuffers.buffer(source);
+    this.source = Okio.buffer(source);
     this.inflaterSource = new InflaterSource(this.source, inflater);
   }
 
/Fim/
diff --git a/okio/src/main/java/okio/InflaterSource.java b/okio/src/main/java/okio/InflaterSource.java
index eb65739..f4ee469 100644
--- a/okio/src/main/java/okio/InflaterSource.java
+++ b/okio/src/main/java/okio/InflaterSource.java
@@ -37,7 +37,7 @@
   private boolean closed;
 
   public InflaterSource(Source source, Inflater inflater) {
-    this(OkBuffers.buffer(source), inflater);
+    this(Okio.buffer(source), inflater);
   }
 
   /**
/Fim/
diff --git a/okio/src/main/java/okio/OkBuffer.java b/okio/src/main/java/okio/OkBuffer.java
index 40aca0f..10b1257 100644
--- a/okio/src/main/java/okio/OkBuffer.java
+++ b/okio/src/main/java/okio/OkBuffer.java
@@ -18,6 +18,8 @@
 import java.io.EOFException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -41,9 +43,6 @@
  * This class avoids zero-fill and GC churn by pooling byte arrays.
  */
 public final class OkBuffer implements BufferedSource, BufferedSink, Cloneable {
-  private static final char[] HEX_DIGITS =
-      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
-
   Segment head;
   long byteCount;
 
@@ -579,22 +578,27 @@
     return result;
   }
 
-  /**
-   * Returns the contents of this buffer in hex. For buffers larger than 1 MiB
-   * this method is undefined.
-   */
   @Override public String toString() {
-    if (byteCount > 0x100000) return super.toString();
-    int charCount = (int) (byteCount * 2);
-    char[] result = new char[charCount];
-    int offset = 0;
-    for (Segment s = head; offset < charCount; s = s.next) {
-      for (int i = s.pos; i < s.limit; i++) {
-        result[offset++] = HEX_DIGITS[(s.data[i] >> 4) & 0xf];
-        result[offset++] = HEX_DIGITS[s.data[i] & 0xf];
-      }
+    if (byteCount == 0) {
+      return "OkBuffer[size=0]";
     }
-    return new String(result);
+
+    if (byteCount <= 16) {
+      ByteString data = clone().readByteString((int) byteCount);
+      return String.format("OkBuffer[size=%s data=%s]", byteCount, data.hex());
+    }
+
+    try {
+      MessageDigest md5 = MessageDigest.getInstance("MD5");
+      md5.update(head.data, head.pos, head.limit - head.pos);
+      for (Segment s = head.next; s != head; s = s.next) {
+        md5.update(s.data, s.pos, s.limit - s.pos);
+      }
+      return String.format("OkBuffer[size=%s md5=%s]",
+          byteCount, ByteString.of(md5.digest()).hex());
+    } catch (NoSuchAlgorithmException e) {
+      throw new AssertionError();
+    }
   }
 
   /** Returns a deep copy of this buffer. */
/Fim/
diff --git a/okio/src/main/java/okio/OkBuffers.java b/okio/src/main/java/okio/Okio.java
similarity index 98%
rename from okio/src/main/java/okio/OkBuffers.java
rename to okio/src/main/java/okio/Okio.java
index e49fe24..afe5b53 100644
--- a/okio/src/main/java/okio/OkBuffers.java
+++ b/okio/src/main/java/okio/Okio.java
@@ -21,8 +21,8 @@
 
 import static okio.Util.checkOffsetAndCount;
 
-public final class OkBuffers {
-  private OkBuffers() {
+public final class Okio {
+  private Okio() {
   }
 
   public static BufferedSource buffer(Source source) {
/Fim/
diff --git a/okio/src/test/java/okio/GzipSourceTest.java b/okio/src/test/java/okio/GzipSourceTest.java
index 060d037..49deaa4 100644
--- a/okio/src/test/java/okio/GzipSourceTest.java
+++ b/okio/src/test/java/okio/GzipSourceTest.java
@@ -16,7 +16,6 @@
 package okio;
 
 import java.io.IOException;
-import java.util.Arrays;
 import java.util.zip.CRC32;
 import org.junit.Test;
 
@@ -30,51 +29,52 @@
 
   @Test public void gunzip() throws Exception {
     OkBuffer gzipped = new OkBuffer();
-    gzipped.write(gzipHeader, 0, gzipHeader.length);
-    gzipped.write(deflated, 0, deflated.length);
-    gzipped.write(gzipTrailer, 0, gzipTrailer.length);
+    gzipped.write(gzipHeader);
+    gzipped.write(deflated);
+    gzipped.write(gzipTrailer);
     assertGzipped(gzipped);
   }
 
   @Test public void gunzip_withHCRC() throws Exception {
     CRC32 hcrc = new CRC32();
-    hcrc.update(gzipHeaderWithFlags((byte) 0x02));
+    ByteString gzipHeader = gzipHeaderWithFlags((byte) 0x02);
+    hcrc.update(gzipHeader.toByteArray());
 
     OkBuffer gzipped = new OkBuffer();
-    gzipped.write(gzipHeaderWithFlags((byte) 0x02), 0, gzipHeader.length);
+    gzipped.write(gzipHeader);
     gzipped.writeShort(Util.reverseBytesShort((short) hcrc.getValue())); // little endian
-    gzipped.write(deflated, 0, deflated.length);
-    gzipped.write(gzipTrailer, 0, gzipTrailer.length);
+    gzipped.write(deflated);
+    gzipped.write(gzipTrailer);
     assertGzipped(gzipped);
   }
 
   @Test public void gunzip_withExtra() throws Exception {
     OkBuffer gzipped = new OkBuffer();
-    gzipped.write(gzipHeaderWithFlags((byte) 0x04), 0, gzipHeader.length);
+    gzipped.write(gzipHeaderWithFlags((byte) 0x04));
     gzipped.writeShort(Util.reverseBytesShort((short) 7)); // little endian extra length
     gzipped.write("blubber".getBytes(UTF_8), 0, 7);
-    gzipped.write(deflated, 0, deflated.length);
-    gzipped.write(gzipTrailer, 0, gzipTrailer.length);
+    gzipped.write(deflated);
+    gzipped.write(gzipTrailer);
     assertGzipped(gzipped);
   }
 
   @Test public void gunzip_withName() throws Exception {
     OkBuffer gzipped = new OkBuffer();
-    gzipped.write(gzipHeaderWithFlags((byte) 0x08), 0, gzipHeader.length);
+    gzipped.write(gzipHeaderWithFlags((byte) 0x08));
     gzipped.write("foo.txt".getBytes(UTF_8), 0, 7);
     gzipped.writeByte(0); // zero-terminated
-    gzipped.write(deflated, 0, deflated.length);
-    gzipped.write(gzipTrailer, 0, gzipTrailer.length);
+    gzipped.write(deflated);
+    gzipped.write(gzipTrailer);
     assertGzipped(gzipped);
   }
 
   @Test public void gunzip_withComment() throws Exception {
     OkBuffer gzipped = new OkBuffer();
-    gzipped.write(gzipHeaderWithFlags((byte) 0x10), 0, gzipHeader.length);
+    gzipped.write(gzipHeaderWithFlags((byte) 0x10));
     gzipped.write("rubbish".getBytes(UTF_8), 0, 7);
     gzipped.writeByte(0); // zero-terminated
-    gzipped.write(deflated, 0, deflated.length);
-    gzipped.write(gzipTrailer, 0, gzipTrailer.length);
+    gzipped.write(deflated);
+    gzipped.write(gzipTrailer);
     assertGzipped(gzipped);
   }
 
@@ -84,15 +84,15 @@
    */
   @Test public void gunzip_withAll() throws Exception {
     OkBuffer gzipped = new OkBuffer();
-    gzipped.write(gzipHeaderWithFlags((byte) 0x1c), 0, gzipHeader.length);
+    gzipped.write(gzipHeaderWithFlags((byte) 0x1c));
     gzipped.writeShort(Util.reverseBytesShort((short) 7)); // little endian extra length
     gzipped.write("blubber".getBytes(UTF_8), 0, 7);
     gzipped.write("foo.txt".getBytes(UTF_8), 0, 7);
     gzipped.writeByte(0); // zero-terminated
     gzipped.write("rubbish".getBytes(UTF_8), 0, 7);
     gzipped.writeByte(0); // zero-terminated
-    gzipped.write(deflated, 0, deflated.length);
-    gzipped.write(gzipTrailer, 0, gzipTrailer.length);
+    gzipped.write(deflated);
+    gzipped.write(gzipTrailer);
     assertGzipped(gzipped);
   }
 
@@ -108,10 +108,10 @@
    */
   @Test public void gunzipWhenHeaderCRCIncorrect() throws Exception {
     OkBuffer gzipped = new OkBuffer();
-    gzipped.write(gzipHeaderWithFlags((byte) 0x02), 0, gzipHeader.length);
+    gzipped.write(gzipHeaderWithFlags((byte) 0x02));
     gzipped.writeShort((short) 0); // wrong HCRC!
-    gzipped.write(deflated, 0, deflated.length);
-    gzipped.write(gzipTrailer, 0, gzipTrailer.length);
+    gzipped.write(deflated);
+    gzipped.write(gzipTrailer);
 
     try {
       gunzip(gzipped);
@@ -123,10 +123,10 @@
 
   @Test public void gunzipWhenCRCIncorrect() throws Exception {
     OkBuffer gzipped = new OkBuffer();
-    gzipped.write(gzipHeader, 0, gzipHeader.length);
-    gzipped.write(deflated, 0, deflated.length);
+    gzipped.write(gzipHeader);
+    gzipped.write(deflated);
     gzipped.writeInt(Util.reverseBytesInt(0x1234567)); // wrong CRC
-    gzipped.write(gzipTrailer, 3, 4);
+    gzipped.write(gzipTrailer.toByteArray(), 3, 4);
 
     try {
       gunzip(gzipped);
@@ -138,9 +138,9 @@
 
   @Test public void gunzipWhenLengthIncorrect() throws Exception {
     OkBuffer gzipped = new OkBuffer();
-    gzipped.write(gzipHeader, 0, gzipHeader.length);
-    gzipped.write(deflated, 0, deflated.length);
-    gzipped.write(gzipTrailer, 0, 4);
+    gzipped.write(gzipHeader);
+    gzipped.write(deflated);
+    gzipped.write(gzipTrailer.toByteArray(), 0, 4);
     gzipped.writeInt(Util.reverseBytesInt(0x123456)); // wrong length
 
     try {
@@ -152,17 +152,11 @@
   }
 
   @Test public void gunzipExhaustsSource() throws Exception {
-    byte[] abcGzipped = {
-        (byte) 0x1f, (byte) 0x8b, (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-        (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x4b, (byte) 0x4c, (byte) 0x4a, (byte) 0x06,
-        (byte) 0x00, (byte) 0xc2, (byte) 0x41, (byte) 0x24, (byte) 0x35, (byte) 0x03, (byte) 0x00,
-        (byte) 0x00, (byte) 0x00
-    };
-    OkBuffer gzippedSource = new OkBuffer();
-    gzippedSource.write(abcGzipped, 0, abcGzipped.length);
+    OkBuffer gzippedSource = new OkBuffer()
+        .write(ByteString.decodeHex("1f8b08000000000000004b4c4a0600c241243503000000")); // 'abc'
 
     ExhaustableSource exhaustableSource = new ExhaustableSource(gzippedSource);
-    BufferedSource gunzippedSource = OkBuffers.buffer(new GzipSource(exhaustableSource));
+    BufferedSource gunzippedSource = Okio.buffer(new GzipSource(exhaustableSource));
 
     assertEquals('a', gunzippedSource.readByte());
     assertEquals('b', gunzippedSource.readByte());
@@ -173,17 +167,11 @@
   }
 
   @Test public void gunzipThrowsIfSourceIsNotExhausted() throws Exception {
-    byte[] abcGzipped = {
-        (byte) 0x1f, (byte) 0x8b, (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-        (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x4b, (byte) 0x4c, (byte) 0x4a, (byte) 0x06,
-        (byte) 0x00, (byte) 0xc2, (byte) 0x41, (byte) 0x24, (byte) 0x35, (byte) 0x03, (byte) 0x00,
-        (byte) 0x00, (byte) 0x00
-    };
-    OkBuffer gzippedSource = new OkBuffer();
-    gzippedSource.write(abcGzipped, 0, abcGzipped.length);
+    OkBuffer gzippedSource = new OkBuffer()
+        .write(ByteString.decodeHex("1f8b08000000000000004b4c4a0600c241243503000000")); // 'abc'
     gzippedSource.writeByte('d'); // This byte shouldn't be here!
 
-    BufferedSource gunzippedSource = OkBuffers.buffer(new GzipSource(gzippedSource));
+    BufferedSource gunzippedSource = Okio.buffer(new GzipSource(gzippedSource));
 
     assertEquals('a', gunzippedSource.readByte());
     assertEquals('b', gunzippedSource.readByte());
@@ -195,29 +183,22 @@
     }
   }
 
-  private byte[] gzipHeaderWithFlags(byte flags) {
-    byte[] result = Arrays.copyOf(gzipHeader, gzipHeader.length);
+  private ByteString gzipHeaderWithFlags(byte flags) {
+    byte[] result = gzipHeader.toByteArray();
     result[3] = flags;
-    return result;
+    return ByteString.of(result);
   }
 
-  private final byte[] gzipHeader = new byte[] {
-      (byte) 0x1f, (byte) 0x8b, (byte) 0x08, 0, 0, 0, 0, 0, 0, 0
-  };
+  private final ByteString gzipHeader = ByteString.decodeHex("1f8b0800000000000000");
 
-  // deflated "It's a UNIX system! I know this!"
-  private final byte[] deflated = new byte[] {
-      (byte) 0xf3, (byte) 0x2c, (byte) 0x51, (byte) 0x2f, (byte) 0x56, (byte) 0x48, (byte) 0x54,
-      (byte) 0x08, (byte) 0xf5, (byte) 0xf3, (byte) 0x8c, (byte) 0x50, (byte) 0x28, (byte) 0xae,
-      (byte) 0x2c, (byte) 0x2e, (byte) 0x49, (byte) 0xcd, (byte) 0x55, (byte) 0x54, (byte) 0xf0,
-      (byte) 0x54, (byte) 0xc8, (byte) 0xce, (byte) 0xcb, (byte) 0x2f, (byte) 0x57, (byte) 0x28,
-      (byte) 0xc9, (byte) 0xc8, (byte) 0x2c, (byte) 0x56, (byte) 0x04, (byte) 0x00
-  };
+  // Deflated "It's a UNIX system! I know this!"
+  private final ByteString deflated = ByteString.decodeHex(
+      "f32c512f56485408f5f38c5028ae2c2e49cd5554f054c8cecb2f5728c9c82c560400");
 
-  private final byte[] gzipTrailer = new byte[] {
-      (byte) 0x8d, (byte) 0x8f, (byte) 0xad, (byte) 0x37, // checksum of deflated
-      0x20, 0, 0, 0, // 32 in little endian
-  };
+  private final ByteString gzipTrailer = ByteString.decodeHex(""
+      + "8d8fad37" // Checksum of deflated.
+      + "20000000" // 32 in little endian.
+  );
 
   private OkBuffer gunzip(OkBuffer gzipped) throws IOException {
     OkBuffer result = new OkBuffer();
/Fim/
diff --git a/okio/src/test/java/okio/InflaterSourceTest.java b/okio/src/test/java/okio/InflaterSourceTest.java
index 0795cbc..ba5c62d 100644
--- a/okio/src/test/java/okio/InflaterSourceTest.java
+++ b/okio/src/test/java/okio/InflaterSourceTest.java
@@ -85,7 +85,7 @@
   /** Use DeflaterOutputStream to deflate source. */
   private OkBuffer deflate(ByteString source) throws IOException {
     OkBuffer result = new OkBuffer();
-    Sink sink = OkBuffers.sink(new DeflaterOutputStream(result.outputStream()));
+    Sink sink = Okio.sink(new DeflaterOutputStream(result.outputStream()));
     sink.write(new OkBuffer().write(source), source.size());
     sink.close();
     return result;
/Fim/
diff --git a/okio/src/test/java/okio/OkBufferTest.java b/okio/src/test/java/okio/OkBufferTest.java
index d26f72a..2a41fc3 100644
--- a/okio/src/test/java/okio/OkBufferTest.java
+++ b/okio/src/test/java/okio/OkBufferTest.java
@@ -15,14 +15,10 @@
  */
 package okio;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.InputStream;
 import java.util.Arrays;
 import java.util.List;
 import org.junit.Test;
 
-import static okio.Util.UTF_8;
 import static java.util.Arrays.asList;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
@@ -75,10 +71,27 @@
     assertEquals(repeat('a', Segment.SIZE), buffer.readUtf8(Segment.SIZE));
   }
 
-  @Test public void bufferToString() throws Exception {
+  @Test public void toStringOnEmptyBuffer() throws Exception {
     OkBuffer buffer = new OkBuffer();
-    buffer.writeUtf8("\u0000\u0001\u0002\u007f");
-    assertEquals("0001027f", buffer.toString());
+    assertEquals("OkBuffer[size=0]", buffer.toString());
+  }
+
+  @Test public void toStringOnSmallBufferIncludesContents() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.write(ByteString.decodeHex("a1b2c3d4e5f61a2b3c4d5e6f10203040"));
+    assertEquals("OkBuffer[size=16 data=a1b2c3d4e5f61a2b3c4d5e6f10203040]", buffer.toString());
+  }
+
+  @Test public void toStringIncludesMd5() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.write(ByteString.encodeUtf8("12345678901234567"));
+    assertEquals("OkBuffer[size=17 md5=2c9728a2138b2f25e9f89f99bdccf8db]", buffer.toString());
+  }
+
+  @Test public void toStringOnMultipleSegmentBuffer() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(repeat('a', 6144));
+    assertEquals("OkBuffer[size=6144 md5=d890021f28522533c1cc1b9b1f83ce73]", buffer.toString());
   }
 
   @Test public void multipleSegmentBuffers() throws Exception {
@@ -325,58 +338,11 @@
     assertEquals(halfSegment * 4 - 1, buffer.indexOf((byte) 'd', halfSegment * 4 - 1));
   }
 
-  @Test public void sinkFromOutputStream() throws Exception {
-    OkBuffer data = new OkBuffer();
-    data.writeUtf8("a");
-    data.writeUtf8(repeat('b', 9998));
-    data.writeUtf8("c");
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    Sink sink = OkBuffers.sink(out);
-    sink.write(data, 3);
-    assertEquals("abb", out.toString("UTF-8"));
-    sink.write(data, data.byteCount());
-    assertEquals("a" + repeat('b', 9998) + "c", out.toString("UTF-8"));
-  }
-
-  @Test public void sourceFromInputStream() throws Exception {
-    InputStream in = new ByteArrayInputStream(
-        ("a" + repeat('b', Segment.SIZE * 2) + "c").getBytes(UTF_8));
-
-    // Source: ab...bc
-    Source source = OkBuffers.source(in);
-    OkBuffer sink = new OkBuffer();
-
-    // Source: b...bc. Sink: abb.
-    assertEquals(3, source.read(sink, 3));
-    assertEquals("abb", sink.readUtf8(3));
-
-    // Source: b...bc. Sink: b...b.
-    assertEquals(Segment.SIZE, source.read(sink, 20000));
-    assertEquals(repeat('b', Segment.SIZE), sink.readUtf8((int) sink.byteCount()));
-
-    // Source: b...bc. Sink: b...bc.
-    assertEquals(Segment.SIZE - 1, source.read(sink, 20000));
-    assertEquals(repeat('b', Segment.SIZE - 2) + "c", sink.readUtf8((int) sink.byteCount()));
-
-    // Source and sink are empty.
-    assertEquals(-1, source.read(sink, 1));
-  }
-
-  @Test public void sourceFromInputStreamBounds() throws Exception {
-    Source source = OkBuffers.source(new ByteArrayInputStream(new byte[100]));
-    try {
-      source.read(new OkBuffer(), -1);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
   @Test public void writeBytes() throws Exception {
     OkBuffer data = new OkBuffer();
     data.writeByte(0xab);
     data.writeByte(0xcd);
-    assertEquals("abcd", data.toString());
+    assertEquals("OkBuffer[size=2 data=abcd]", data.toString());
   }
 
   @Test public void writeLastByteInSegment() throws Exception {
@@ -386,21 +352,21 @@
     data.writeByte(0x21);
     assertEquals(asList(Segment.SIZE, 1), data.segmentSizes());
     assertEquals(repeat('a', Segment.SIZE - 1), data.readUtf8(Segment.SIZE - 1));
-    assertEquals("2021", data.toString());
+    assertEquals("OkBuffer[size=2 data=2021]", data.toString());
   }
 
   @Test public void writeShort() throws Exception {
     OkBuffer data = new OkBuffer();
     data.writeShort(0xabcd);
     data.writeShort(0x4321);
-    assertEquals("abcd4321", data.toString());
+    assertEquals("OkBuffer[size=4 data=abcd4321]", data.toString());
   }
 
   @Test public void writeInt() throws Exception {
     OkBuffer data = new OkBuffer();
     data.writeInt(0xabcdef01);
     data.writeInt(0x87654321);
-    assertEquals("abcdef0187654321", data.toString());
+    assertEquals("OkBuffer[size=8 data=abcdef0187654321]", data.toString());
   }
 
   @Test public void writeLastIntegerInSegment() throws Exception {
@@ -410,7 +376,7 @@
     data.writeInt(0x87654321);
     assertEquals(asList(Segment.SIZE, 4), data.segmentSizes());
     assertEquals(repeat('a', Segment.SIZE - 4), data.readUtf8(Segment.SIZE - 4));
-    assertEquals("abcdef0187654321", data.toString());
+    assertEquals("OkBuffer[size=8 data=abcdef0187654321]", data.toString());
   }
 
   @Test public void writeIntegerDoesntQuiteFitInSegment() throws Exception {
@@ -420,7 +386,7 @@
     data.writeInt(0x87654321);
     assertEquals(asList(Segment.SIZE - 3, 8), data.segmentSizes());
     assertEquals(repeat('a', Segment.SIZE - 3), data.readUtf8(Segment.SIZE - 3));
-    assertEquals("abcdef0187654321", data.toString());
+    assertEquals("OkBuffer[size=8 data=abcdef0187654321]", data.toString());
   }
 
   @Test public void readByte() throws Exception {
/Fim/
diff --git a/okio/src/test/java/okio/OkioTest.java b/okio/src/test/java/okio/OkioTest.java
new file mode 100644
index 0000000..7613432
--- /dev/null
+++ b/okio/src/test/java/okio/OkioTest.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.InputStream;
+import java.util.Arrays;
+import org.junit.Test;
+
+import static okio.Util.UTF_8;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class OkioTest {
+  @Test public void sinkFromOutputStream() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8("a");
+    data.writeUtf8(repeat('b', 9998));
+    data.writeUtf8("c");
+
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    Sink sink = Okio.sink(out);
+    sink.write(data, 3);
+    assertEquals("abb", out.toString("UTF-8"));
+    sink.write(data, data.byteCount());
+    assertEquals("a" + repeat('b', 9998) + "c", out.toString("UTF-8"));
+  }
+
+  @Test public void sourceFromInputStream() throws Exception {
+    InputStream in = new ByteArrayInputStream(
+        ("a" + repeat('b', Segment.SIZE * 2) + "c").getBytes(UTF_8));
+
+    // Source: ab...bc
+    Source source = Okio.source(in);
+    OkBuffer sink = new OkBuffer();
+
+    // Source: b...bc. Sink: abb.
+    assertEquals(3, source.read(sink, 3));
+    assertEquals("abb", sink.readUtf8(3));
+
+    // Source: b...bc. Sink: b...b.
+    assertEquals(Segment.SIZE, source.read(sink, 20000));
+    assertEquals(repeat('b', Segment.SIZE), sink.readUtf8((int) sink.byteCount()));
+
+    // Source: b...bc. Sink: b...bc.
+    assertEquals(Segment.SIZE - 1, source.read(sink, 20000));
+    assertEquals(repeat('b', Segment.SIZE - 2) + "c", sink.readUtf8((int) sink.byteCount()));
+
+    // Source and sink are empty.
+    assertEquals(-1, source.read(sink, 1));
+  }
+
+  @Test public void sourceFromInputStreamBounds() throws Exception {
+    Source source = Okio.source(new ByteArrayInputStream(new byte[100]));
+    try {
+      source.read(new OkBuffer(), -1);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  private String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
+  }
+}
/Fim/
diff --git a/okio/src/main/java/okio/ByteString.java b/okio/src/main/java/okio/ByteString.java
index 9223a86..608d652 100644
--- a/okio/src/main/java/okio/ByteString.java
+++ b/okio/src/main/java/okio/ByteString.java
@@ -15,9 +15,12 @@
  */
 package okio;
 
+import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.util.Arrays;
 
 /**
@@ -35,12 +38,16 @@
   private static final char[] HEX_DIGITS =
       { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
 
+  /** A singleton empty {@code ByteString}. */
+  public static final ByteString EMPTY = ByteString.of();
+
   final byte[] data;
   private transient int hashCode; // Lazily computed; 0 if unknown.
   private transient String utf8; // Lazily computed.
 
-  /** A singleton empty {@code ByteString}. */
-  public static final ByteString EMPTY = new ByteString(Util.EMPTY_BYTE_ARRAY);
+  ByteString(byte[] data) {
+    this.data = data; // Trusted internal constructor doesn't clone data.
+  }
 
   /**
    * Returns a new byte string containing a clone of the bytes of {@code data}.
@@ -133,11 +140,14 @@
    * Reads {@code count} bytes from {@code in} and returns the result.
    *
    * @throws java.io.EOFException if {@code in} has fewer than {@code count}
-   * bytes to read.
+   *     bytes to read.
    */
-  public static ByteString read(InputStream in, int count) throws IOException {
-    byte[] result = new byte[count];
-    Util.readFully(in, result);
+  public static ByteString read(InputStream in, int byteCount) throws IOException {
+    byte[] result = new byte[byteCount];
+    for (int offset = 0, read; offset < byteCount; offset += read) {
+      read = in.read(result, offset, byteCount - offset);
+      if (read == -1) throw new EOFException();
+    }
     return new ByteString(result);
   }
 
@@ -180,10 +190,6 @@
     return new ByteString(result);
   }
 
-  ByteString(byte[] data) {
-    this.data = data; // Trusted internal constructor doesn't clone data.
-  }
-
   /**
    * Returns the number of bytes in this ByteString.
    */
@@ -211,4 +217,21 @@
     int result = hashCode;
     return result != 0 ? result : (hashCode = Arrays.hashCode(data));
   }
+
+  @Override public String toString() {
+    if (data.length == 0) {
+      return "ByteString[size=0]";
+    }
+
+    if (data.length <= 16) {
+      return String.format("ByteString[size=%s data=%s]", data.length, hex());
+    }
+
+    try {
+      return String.format("ByteString[size=%s md5=%s]", data.length,
+          ByteString.of(MessageDigest.getInstance("MD5").digest(data)).hex());
+    } catch (NoSuchAlgorithmException e) {
+      throw new AssertionError();
+    }
+  }
 }
/Fim/
diff --git a/okio/src/main/java/okio/OkBuffer.java b/okio/src/main/java/okio/OkBuffer.java
index 10b1257..10f3ea8 100644
--- a/okio/src/main/java/okio/OkBuffer.java
+++ b/okio/src/main/java/okio/OkBuffer.java
@@ -578,6 +578,51 @@
     return result;
   }
 
+  @Override public boolean equals(Object o) {
+    if (!(o instanceof OkBuffer)) return false;
+    OkBuffer that = (OkBuffer) o;
+    if (byteCount != that.byteCount) return false;
+    if (byteCount == 0) return true; // Both buffers are empty.
+
+    Segment sa = this.head;
+    Segment sb = that.head;
+    int posA = sa.pos;
+    int posB = sb.pos;
+
+    for (long pos = 0, count; pos < byteCount; pos += count) {
+      count = Math.min(sa.limit - posA, sb.limit - posB);
+
+      for (int i = 0; i < count; i++) {
+        if (sa.data[posA++] != sb.data[posB++]) return false;
+      }
+
+      if (posA == sa.limit) {
+        sa = sa.next;
+        posA = sa.pos;
+      }
+
+      if (posB == sb.limit) {
+        sb = sb.next;
+        posB = sb.pos;
+      }
+    }
+
+    return true;
+  }
+
+  @Override public int hashCode() {
+    Segment s = head;
+    if (s == null) return 0;
+    int result = 1;
+    do {
+      for (int pos = s.pos, limit = s.limit; pos < limit; pos++) {
+        result = 31 * result + s.data[pos];
+      }
+      s = s.next;
+    } while (s != head);
+    return result;
+  }
+
   @Override public String toString() {
     if (byteCount == 0) {
       return "OkBuffer[size=0]";
/Fim/
diff --git a/okio/src/main/java/okio/Util.java b/okio/src/main/java/okio/Util.java
index f3df733..a2bada2 100644
--- a/okio/src/main/java/okio/Util.java
+++ b/okio/src/main/java/okio/Util.java
@@ -1,12 +1,23 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package okio;
 
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.InputStream;
 import java.nio.charset.Charset;
 
-class Util {
-  public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
+final class Util {
   /** A cheap and type-safe constant for the UTF-8 Charset. */
   public static final Charset UTF_8 = Charset.forName("UTF-8");
 
@@ -19,41 +30,6 @@
     }
   }
 
-  /**
-   * Fills 'dst' with bytes from 'in', throwing EOFException if insufficient bytes are available.
-   */
-  public static void readFully(InputStream in, byte[] dst) throws IOException {
-    readFully(in, dst, 0, dst.length);
-  }
-
-  /**
-   * Reads exactly 'byteCount' bytes from 'in' (into 'dst' at offset 'offset'), and throws
-   * EOFException if insufficient bytes are available.
-   *
-   * Used to implement {@link java.io.DataInputStream#readFully(byte[], int, int)}.
-   */
-  public static void readFully(InputStream in, byte[] dst, int offset, int byteCount)
-      throws IOException {
-    if (byteCount == 0) {
-      return;
-    }
-    if (in == null) {
-      throw new NullPointerException("in == null");
-    }
-    if (dst == null) {
-      throw new NullPointerException("dst == null");
-    }
-    checkOffsetAndCount(dst.length, offset, byteCount);
-    while (byteCount > 0) {
-      int bytesRead = in.read(dst, offset, byteCount);
-      if (bytesRead < 0) {
-        throw new EOFException();
-      }
-      offset += bytesRead;
-      byteCount -= bytesRead;
-    }
-  }
-
   public static int reverseBytesShort(short s) {
     int i = s & 0xffff;
     return (i & 0xff00) >>> 8
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java b/okio/src/test/java/okio/ByteStringTest.java
similarity index 92%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
rename to okio/src/test/java/okio/ByteStringTest.java
index db2774e..e714056 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
+++ b/okio/src/test/java/okio/ByteStringTest.java
@@ -13,13 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okio;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.InputStream;
 import java.util.Arrays;
-import okio.ByteString;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -167,6 +166,20 @@
     }
   }
 
+  @Test public void toStringOnEmptyByteString() {
+    assertEquals("ByteString[size=0]", ByteString.of().toString());
+  }
+
+  @Test public void toStringOnSmallByteStringIncludesContents() {
+    assertEquals("ByteString[size=16 data=a1b2c3d4e5f61a2b3c4d5e6f10203040]",
+        ByteString.decodeHex("a1b2c3d4e5f61a2b3c4d5e6f10203040").toString());
+  }
+
+  @Test public void toStringOnLargeByteStringIncludesMd5() {
+    assertEquals("ByteString[size=17 md5=2c9728a2138b2f25e9f89f99bdccf8db]",
+        ByteString.encodeUtf8("12345678901234567").toString());
+  }
+
   private static void assertByteArraysEquals(byte[] a, byte[] b) {
     assertEquals(Arrays.toString(a), Arrays.toString(b));
   }
/Fim/
diff --git a/okio/src/test/java/okio/OkBufferTest.java b/okio/src/test/java/okio/OkBufferTest.java
index 2a41fc3..d19f2ca 100644
--- a/okio/src/test/java/okio/OkBufferTest.java
+++ b/okio/src/test/java/okio/OkBufferTest.java
@@ -17,10 +17,13 @@
 
 import java.util.Arrays;
 import java.util.List;
+import java.util.Random;
 import org.junit.Test;
 
 import static java.util.Arrays.asList;
+import static junit.framework.Assert.assertFalse;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class OkBufferTest {
@@ -82,7 +85,7 @@
     assertEquals("OkBuffer[size=16 data=a1b2c3d4e5f61a2b3c4d5e6f10203040]", buffer.toString());
   }
 
-  @Test public void toStringIncludesMd5() throws Exception {
+  @Test public void toStringOnLargeBufferIncludesMd5() throws Exception {
     OkBuffer buffer = new OkBuffer();
     buffer.write(ByteString.encodeUtf8("12345678901234567"));
     assertEquals("OkBuffer[size=17 md5=2c9728a2138b2f25e9f89f99bdccf8db]", buffer.toString());
@@ -525,6 +528,65 @@
         clone.readUtf8(Segment.SIZE * 6));
   }
 
+  @Test public void testEqualsAndHashCodeEmpty() throws Exception {
+    OkBuffer a = new OkBuffer();
+    OkBuffer b = new OkBuffer();
+    assertTrue(a.equals(b));
+    assertTrue(a.hashCode() == b.hashCode());
+  }
+
+  @Test public void testEqualsAndHashCode() throws Exception {
+    OkBuffer a = new OkBuffer().writeUtf8("dog");
+    OkBuffer b = new OkBuffer().writeUtf8("hotdog");
+    assertFalse(a.equals(b));
+    assertFalse(a.hashCode() == b.hashCode());
+
+    b.readUtf8(3); // Leaves b containing 'dog'.
+    assertTrue(a.equals(b));
+    assertTrue(a.hashCode() == b.hashCode());
+  }
+
+  @Test public void testEqualsAndHashCodeSpanningSegments() throws Exception {
+    byte[] data = new byte[1024 * 1024];
+    Random dice = new Random(0);
+    dice.nextBytes(data);
+
+    OkBuffer a = bufferWithRandomSegmentLayout(dice, data);
+    OkBuffer b = bufferWithRandomSegmentLayout(dice, data);
+    assertTrue(a.equals(b));
+    assertTrue(a.hashCode() == b.hashCode());
+
+    data[data.length / 2]++; // Change a single byte.
+    OkBuffer c = bufferWithRandomSegmentLayout(dice, data);
+    assertFalse(a.equals(c));
+    assertFalse(a.hashCode() == c.hashCode());
+  }
+
+  /**
+   * Returns a new buffer containing the data in {@code data}, and a segment
+   * layout determined by {@code dice}.
+   */
+  private OkBuffer bufferWithRandomSegmentLayout(Random dice, byte[] data) {
+    OkBuffer result = new OkBuffer();
+
+    // Writing to result directly will yield packed segments. Instead, write to
+    // other buffers, then write those buffers to result.
+    for (int pos = 0, byteCount; pos < data.length; pos += byteCount) {
+      byteCount = (Segment.SIZE / 2) + dice.nextInt(Segment.SIZE / 2);
+      if (byteCount > data.length - pos) byteCount = data.length - pos;
+      int offset = dice.nextInt(Segment.SIZE - byteCount);
+
+      OkBuffer segment = new OkBuffer();
+      segment.write(new byte[offset]);
+      segment.write(data, pos, byteCount);
+      segment.skip(offset);
+
+      result.write(segment, byteCount);
+    }
+
+    return result;
+  }
+
   private String repeat(char c, int count) {
     char[] array = new char[count];
     Arrays.fill(array, c);
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index e16f038..0f51db6 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -2,7 +2,6 @@
 
 import com.squareup.okhttp.internal.BitArray;
 import java.io.IOException;
-import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -11,6 +10,7 @@
 import java.util.Map;
 import okio.BufferedSource;
 import okio.ByteString;
+import okio.OkBuffer;
 import okio.Okio;
 import okio.Source;
 
@@ -399,9 +399,9 @@
   }
 
   static final class Writer {
-    private final OutputStream out;
+    private final OkBuffer out;
 
-    Writer(OutputStream out) {
+    Writer(OkBuffer out) {
       this.out = out;
     }
 
@@ -415,7 +415,7 @@
           writeInt(staticIndex + 1, PREFIX_6_BITS, 0x40);
           writeByteString(headerBlock.get(i).value);
         } else {
-          out.write(0x40); // Literal Header without Indexing - New Name.
+          out.writeByte(0x40); // Literal Header without Indexing - New Name.
           writeByteString(name);
           writeByteString(headerBlock.get(i).value);
         }
@@ -426,26 +426,26 @@
     void writeInt(int value, int prefixMask, int bits) throws IOException {
       // Write the raw value for a single byte value.
       if (value < prefixMask) {
-        out.write(bits | value);
+        out.writeByte(bits | value);
         return;
       }
 
       // Write the mask to start a multibyte value.
-      out.write(bits | prefixMask);
+      out.writeByte(bits | prefixMask);
       value -= prefixMask;
 
       // Write 7 bits at a time 'til we're done.
       while (value >= 0x80) {
         int b = value & 0x7f;
-        out.write(b | 0x80);
+        out.writeByte(b | 0x80);
         value >>>= 7;
       }
-      out.write(value);
+      out.writeByte(value);
     }
 
     void writeByteString(ByteString data) throws IOException {
       writeInt(data.size(), PREFIX_8_BITS, 0);
-      data.write(out);
+      out.write(data);
     }
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index ffc8104..57feb32 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -16,11 +16,9 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.Protocol;
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
 import java.io.IOException;
-import java.io.OutputStream;
 import java.util.List;
+import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.Deadline;
@@ -62,8 +60,8 @@
     return new Reader(source, 4096, client);
   }
 
-  @Override public FrameWriter newWriter(OutputStream out, boolean client) {
-    return new Writer(out, client);
+  @Override public FrameWriter newWriter(BufferedSink sink, boolean client) {
+    return new Writer(sink, client);
   }
 
   static final class Reader implements FrameReader {
@@ -287,20 +285,20 @@
   }
 
   static final class Writer implements FrameWriter {
-    private final DataOutputStream out;
+    private final BufferedSink sink;
     private final boolean client;
-    private final ByteArrayOutputStream hpackBuffer;
+    private final OkBuffer hpackBuffer;
     private final HpackDraft05.Writer hpackWriter;
 
-    Writer(OutputStream out, boolean client) {
-      this.out = new DataOutputStream(out);
+    Writer(BufferedSink sink, boolean client) {
+      this.sink = sink;
       this.client = client;
-      this.hpackBuffer = new ByteArrayOutputStream();
+      this.hpackBuffer = new OkBuffer();
       this.hpackWriter = new HpackDraft05.Writer(hpackBuffer);
     }
 
     @Override public synchronized void flush() throws IOException {
-      out.flush();
+      sink.flush();
     }
 
     @Override public synchronized void ackSettings() throws IOException {
@@ -309,17 +307,17 @@
       byte flags = FLAG_ACK;
       int streamId = 0;
       frameHeader(length, type, flags, streamId);
+      sink.flush();
     }
 
     @Override public synchronized void connectionHeader() throws IOException {
       if (!client) return; // Nothing to write; servers don't send connection headers!
-      out.write(CONNECTION_HEADER.toByteArray());
-      out.flush();
+      sink.write(CONNECTION_HEADER.toByteArray());
+      sink.flush();
     }
 
-    @Override
-    public synchronized void synStream(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, int slot, List<Header> headerBlock)
+    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
+        int streamId, int associatedStreamId, int priority, int slot, List<Header> headerBlock)
         throws IOException {
       if (inFinished) throw new UnsupportedOperationException();
       headers(outFinished, streamId, priority, headerBlock);
@@ -335,34 +333,33 @@
       headers(false, streamId, -1, headerBlock);
     }
 
-    @Override
-    public synchronized void pushPromise(int streamId, int promisedStreamId,
+    @Override public synchronized void pushPromise(int streamId, int promisedStreamId,
         List<Header> requestHeaders) throws IOException {
-      hpackBuffer.reset();
+      if (hpackBuffer.byteCount() != 0) throw new IllegalStateException();
       hpackWriter.writeHeaders(requestHeaders);
 
-      int length = 4 + hpackBuffer.size();
+      int length = (int) (4 + hpackBuffer.byteCount());
       byte type = TYPE_PUSH_PROMISE;
       byte flags = FLAG_END_HEADERS;
       frameHeader(length, type, flags, streamId); // TODO: CONTINUATION
-      out.writeInt(promisedStreamId & 0x7fffffff);
-      hpackBuffer.writeTo(out);
+      sink.writeInt(promisedStreamId & 0x7fffffff);
+      sink.write(hpackBuffer, hpackBuffer.byteCount());
     }
 
     private void headers(boolean outFinished, int streamId, int priority,
         List<Header> headerBlock) throws IOException {
-      hpackBuffer.reset();
+      if (hpackBuffer.byteCount() != 0) throw new IllegalStateException();
       hpackWriter.writeHeaders(headerBlock);
 
-      int length = hpackBuffer.size();
+      int length = (int) hpackBuffer.byteCount();
       byte type = TYPE_HEADERS;
       byte flags = FLAG_END_HEADERS;
       if (outFinished) flags |= FLAG_END_STREAM;
       if (priority != -1) flags |= FLAG_PRIORITY;
       if (priority != -1) length += 4;
       frameHeader(length, type, flags, streamId); // TODO: CONTINUATION
-      if (priority != -1) out.writeInt(priority & 0x7fffffff);
-      hpackBuffer.writeTo(out);
+      if (priority != -1) sink.writeInt(priority & 0x7fffffff);
+      sink.write(hpackBuffer, hpackBuffer.byteCount());
     }
 
     @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
@@ -373,8 +370,8 @@
       byte type = TYPE_RST_STREAM;
       byte flags = FLAG_NONE;
       frameHeader(length, type, flags, streamId);
-      out.writeInt(errorCode.httpCode);
-      out.flush();
+      sink.writeInt(errorCode.httpCode);
+      sink.flush();
     }
 
     @Override public synchronized void data(boolean outFinished, int streamId, byte[] data)
@@ -393,7 +390,7 @@
         throws IOException {
       byte type = TYPE_DATA;
       frameHeader(length, type, flags, streamId);
-      out.write(data, offset, length);
+      sink.write(data, offset, length);
     }
 
     @Override public synchronized void settings(Settings settings) throws IOException {
@@ -404,10 +401,10 @@
       frameHeader(length, type, flags, streamId);
       for (int i = 0; i < Settings.COUNT; i++) {
         if (!settings.isSet(i)) continue;
-        out.writeInt(i & 0xffffff);
-        out.writeInt(settings.get(i));
+        sink.writeInt(i & 0xffffff);
+        sink.writeInt(settings.get(i));
       }
-      out.flush();
+      sink.flush();
     }
 
     @Override public synchronized void ping(boolean ack, int payload1, int payload2)
@@ -417,26 +414,25 @@
       byte flags = ack ? FLAG_ACK : FLAG_NONE;
       int streamId = 0;
       frameHeader(length, type, flags, streamId);
-      out.writeInt(payload1);
-      out.writeInt(payload2);
-      out.flush();
+      sink.writeInt(payload1);
+      sink.writeInt(payload2);
+      sink.flush();
     }
 
-    @Override
-    public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
-        throws IOException {
+    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
+        byte[] debugData) throws IOException {
       if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
       int length = 8 + debugData.length;
       byte type = TYPE_GOAWAY;
       byte flags = FLAG_NONE;
       int streamId = 0;
       frameHeader(length, type, flags, streamId);
-      out.writeInt(lastGoodStreamId);
-      out.writeInt(errorCode.httpCode);
+      sink.writeInt(lastGoodStreamId);
+      sink.writeInt(errorCode.httpCode);
       if (debugData.length > 0) {
-        out.write(debugData);
+        sink.write(debugData);
       }
-      out.flush();
+      sink.flush();
     }
 
     @Override public synchronized void windowUpdate(int streamId, long windowSizeIncrement)
@@ -449,19 +445,19 @@
       byte type = TYPE_WINDOW_UPDATE;
       byte flags = FLAG_NONE;
       frameHeader(length, type, flags, streamId);
-      out.writeInt((int) windowSizeIncrement);
-      out.flush();
+      sink.writeInt((int) windowSizeIncrement);
+      sink.flush();
     }
 
-    @Override public void close() throws IOException {
-      out.close();
+    @Override public synchronized void close() throws IOException {
+      sink.close();
     }
 
     void frameHeader(int length, byte type, byte flags, int streamId) throws IOException {
       if (length > 16383) throw illegalArgument("FRAME_SIZE_ERROR length > 16383: %s", length);
       if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
-      out.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
-      out.writeInt(streamId & 0x7fffffff);
+      sink.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
+      sink.writeInt(streamId & 0x7fffffff);
     }
   }
 
@@ -491,8 +487,7 @@
       this.source = source;
     }
 
-    @Override public long read(OkBuffer sink, long byteCount)
-        throws IOException {
+    @Override public long read(OkBuffer sink, long byteCount) throws IOException {
       while (left == 0) {
         if ((flags & FLAG_END_HEADERS) != 0) return -1;
         readContinuationHeader();
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index 4566fe1..1c240fd 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -16,18 +16,18 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
 import java.io.IOException;
-import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.ProtocolException;
 import java.util.List;
 import java.util.zip.Deflater;
+import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
+import okio.DeflaterSink;
+import okio.OkBuffer;
+import okio.Okio;
 
 /**
  * Read and write spdy/3.1 frames.
@@ -99,8 +99,8 @@
     return new Reader(source, client);
   }
 
-  @Override public FrameWriter newWriter(OutputStream out, boolean client) {
-    return new Writer(out, client);
+  @Override public FrameWriter newWriter(BufferedSink sink, boolean client) {
+    return new Writer(sink, client);
   }
 
   /** Read spdy/3 frames. */
@@ -287,20 +287,19 @@
 
   /** Write spdy/3 frames. */
   static final class Writer implements FrameWriter {
-    private final DataOutputStream out;
-    private final ByteArrayOutputStream headerBlockBuffer;
-    private final DataOutputStream headerBlockOut;
+    private final BufferedSink sink;
+    private final OkBuffer headerBlockBuffer;
+    private final BufferedSink headerBlockOut;
     private final boolean client;
 
-    Writer(OutputStream out, boolean client) {
-      this.out = new DataOutputStream(out);
+    Writer(BufferedSink sink, boolean client) {
+      this.sink = sink;
       this.client = client;
 
       Deflater deflater = new Deflater();
       deflater.setDictionary(DICTIONARY);
-      headerBlockBuffer = new ByteArrayOutputStream();
-      headerBlockOut = new DataOutputStream(
-          Platform.get().newDeflaterOutputStream(headerBlockBuffer, deflater, true));
+      headerBlockBuffer = new OkBuffer();
+      headerBlockOut = Okio.buffer(new DeflaterSink(headerBlockBuffer, deflater));
     }
 
     @Override public void ackSettings() {
@@ -318,26 +317,25 @@
     }
 
     @Override public synchronized void flush() throws IOException {
-      out.flush();
+      sink.flush();
     }
 
-    @Override
-    public synchronized void synStream(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, int slot, List<Header> headerBlock)
+    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
+        int streamId, int associatedStreamId, int priority, int slot, List<Header> headerBlock)
         throws IOException {
       writeNameValueBlockToBuffer(headerBlock);
-      int length = 10 + headerBlockBuffer.size();
+      int length = (int) (10 + headerBlockBuffer.byteCount());
       int type = TYPE_SYN_STREAM;
       int flags = (outFinished ? FLAG_FIN : 0) | (inFinished ? FLAG_UNIDIRECTIONAL : 0);
 
       int unused = 0;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(streamId & 0x7fffffff);
-      out.writeInt(associatedStreamId & 0x7fffffff);
-      out.writeShort((priority & 0x7) << 13 | (unused & 0x1f) << 8 | (slot & 0xff));
-      headerBlockBuffer.writeTo(out);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(streamId & 0x7fffffff);
+      sink.writeInt(associatedStreamId & 0x7fffffff);
+      sink.writeShort((priority & 0x7) << 13 | (unused & 0x1f) << 8 | (slot & 0xff));
+      sink.write(headerBlockBuffer, headerBlockBuffer.byteCount());
+      sink.flush();
     }
 
     @Override public synchronized void synReply(boolean outFinished, int streamId,
@@ -345,13 +343,13 @@
       writeNameValueBlockToBuffer(headerBlock);
       int type = TYPE_SYN_REPLY;
       int flags = (outFinished ? FLAG_FIN : 0);
-      int length = headerBlockBuffer.size() + 4;
+      int length = (int) (headerBlockBuffer.byteCount() + 4);
 
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(streamId & 0x7fffffff);
-      headerBlockBuffer.writeTo(out);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(streamId & 0x7fffffff);
+      sink.write(headerBlockBuffer, headerBlockBuffer.byteCount());
+      sink.flush();
     }
 
     @Override public synchronized void headers(int streamId, List<Header> headerBlock)
@@ -359,12 +357,12 @@
       writeNameValueBlockToBuffer(headerBlock);
       int flags = 0;
       int type = TYPE_HEADERS;
-      int length = headerBlockBuffer.size() + 4;
+      int length = (int) (headerBlockBuffer.byteCount() + 4);
 
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(streamId & 0x7fffffff);
-      headerBlockBuffer.writeTo(out);
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(streamId & 0x7fffffff);
+      sink.write(headerBlockBuffer, headerBlockBuffer.byteCount());
     }
 
     @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
@@ -373,11 +371,11 @@
       int flags = 0;
       int type = TYPE_RST_STREAM;
       int length = 8;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(streamId & 0x7fffffff);
-      out.writeInt(errorCode.spdyRstCode);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(streamId & 0x7fffffff);
+      sink.writeInt(errorCode.spdyRstCode);
+      sink.flush();
     }
 
     @Override public synchronized void data(boolean outFinished, int streamId, byte[] data)
@@ -397,21 +395,21 @@
       if (byteCount > 0xffffffL) {
         throw new IllegalArgumentException("FRAME_TOO_LARGE max size is 16Mib: " + byteCount);
       }
-      out.writeInt(streamId & 0x7fffffff);
-      out.writeInt((flags & 0xff) << 24 | byteCount & 0xffffff);
-      out.write(data, offset, byteCount);
+      sink.writeInt(streamId & 0x7fffffff);
+      sink.writeInt((flags & 0xff) << 24 | byteCount & 0xffffff);
+      sink.write(data, offset, byteCount);
     }
 
     private void writeNameValueBlockToBuffer(List<Header> headerBlock) throws IOException {
-      headerBlockBuffer.reset();
+      if (headerBlockBuffer.byteCount() != 0) throw new IllegalStateException();
       headerBlockOut.writeInt(headerBlock.size());
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
         ByteString name = headerBlock.get(i).name;
         headerBlockOut.writeInt(name.size());
-        name.write(headerBlockOut);
+        headerBlockOut.write(name);
         ByteString value = headerBlock.get(i).value;
         headerBlockOut.writeInt(value.size());
-        value.write(headerBlockOut);
+        headerBlockOut.write(value);
       }
       headerBlockOut.flush();
     }
@@ -421,16 +419,16 @@
       int flags = 0;
       int size = settings.size();
       int length = 4 + size * 8;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(size);
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(size);
       for (int i = 0; i <= Settings.COUNT; i++) {
         if (!settings.isSet(i)) continue;
         int settingsFlags = settings.flags(i);
-        out.writeInt((settingsFlags & 0xff) << 24 | (i & 0xffffff));
-        out.writeInt(settings.get(i));
+        sink.writeInt((settingsFlags & 0xff) << 24 | (i & 0xffffff));
+        sink.writeInt(settings.get(i));
       }
-      out.flush();
+      sink.flush();
     }
 
     @Override public synchronized void ping(boolean reply, int payload1, int payload2)
@@ -440,26 +438,25 @@
       int type = TYPE_PING;
       int flags = 0;
       int length = 4;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(payload1);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(payload1);
+      sink.flush();
     }
 
-    @Override
-    public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] ignored)
-        throws IOException {
+    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
+        byte[] ignored) throws IOException {
       if (errorCode.spdyGoAwayCode == -1) {
         throw new IllegalArgumentException("errorCode.spdyGoAwayCode == -1");
       }
       int type = TYPE_GOAWAY;
       int flags = 0;
       int length = 8;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(lastGoodStreamId);
-      out.writeInt(errorCode.spdyGoAwayCode);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(lastGoodStreamId);
+      sink.writeInt(errorCode.spdyGoAwayCode);
+      sink.flush();
     }
 
     @Override public synchronized void windowUpdate(int streamId, long increment)
@@ -471,15 +468,15 @@
       int type = TYPE_WINDOW_UPDATE;
       int flags = 0;
       int length = 8;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(streamId);
-      out.writeInt((int) increment);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(streamId);
+      sink.writeInt((int) increment);
+      sink.flush();
     }
 
-    @Override public void close() throws IOException {
-      Util.closeAll(out, headerBlockOut);
+    @Override public synchronized void close() throws IOException {
+      Util.closeAll(sink, headerBlockOut);
     }
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index 3f2ac90..984df71 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -21,7 +21,6 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
-import java.io.OutputStream;
 import java.net.Socket;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -31,6 +30,7 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.Okio;
@@ -148,7 +148,7 @@
     bytesLeftInWriteWindow = peerSettings.getInitialWindowSize();
     bufferPool = new ByteArrayPool(INITIAL_WINDOW_SIZE * 8); // TODO: revisit size limit!
     frameReader = variant.newReader(builder.source, client);
-    frameWriter = variant.newWriter(builder.out, client);
+    frameWriter = variant.newWriter(builder.sink, client);
 
     readerRunnable = new Reader();
     new Thread(readerRunnable).start(); // Not a daemon thread.
@@ -232,6 +232,10 @@
           requestHeaders);
     }
 
+    if (!out) {
+      frameWriter.flush();
+    }
+
     return stream;
   }
 
@@ -458,25 +462,25 @@
   public static class Builder {
     private String hostName;
     private BufferedSource source;
-    private OutputStream out;
+    private BufferedSink sink;
     private IncomingStreamHandler handler = IncomingStreamHandler.REFUSE_INCOMING_STREAMS;
     private Protocol protocol = Protocol.SPDY_3;
     private boolean client;
 
     public Builder(boolean client, Socket socket) throws IOException {
       this("", client, Okio.buffer(Okio.source(socket.getInputStream())),
-          socket.getOutputStream());
+          Okio.buffer(Okio.sink(socket.getOutputStream())));
     }
 
     /**
      * @param client true if this peer initiated the connection; false if this
      *     peer accepted the connection.
      */
-    public Builder(String hostName, boolean client, BufferedSource source, OutputStream out) {
+    public Builder(String hostName, boolean client, BufferedSource source, BufferedSink sink) {
       this.hostName = hostName;
       this.client = client;
       this.source = source;
-      this.out = out;
+      this.sink = sink;
     }
 
     public Builder handler(IncomingStreamHandler handler) {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index e1fd875..a70a566 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -194,6 +194,10 @@
       }
     }
     connection.writeSynReply(id, outFinished, responseHeaders);
+
+    if (outFinished) {
+      connection.flush();
+    }
   }
 
   /**
@@ -547,8 +551,8 @@
       }
       if (pos > 0) {
         writeFrame();
-        connection.flush();
       }
+      connection.flush();
     }
 
     @Override public void close() throws IOException {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
index b9940d6..f8b73f9 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
@@ -16,7 +16,7 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.Protocol;
-import java.io.OutputStream;
+import okio.BufferedSink;
 import okio.BufferedSource;
 
 /** A version and dialect of the framed socket protocol. */
@@ -33,5 +33,5 @@
   /**
    * @param client true if this is the HTTP client's writer, writing frames to a server.
    */
-  FrameWriter newWriter(OutputStream out, boolean client);
+  FrameWriter newWriter(BufferedSink sink, boolean client);
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index e480e41..268d855 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -15,34 +15,28 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
-import java.util.Arrays;
 import java.util.List;
 import okio.ByteString;
-import okio.Okio;
+import okio.OkBuffer;
 import org.junit.Before;
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.Util.headerEntries;
-import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 public class HpackDraft05Test {
 
-  private final MutableByteArrayInputStream bytesIn = new MutableByteArrayInputStream();
+  private final OkBuffer bytesIn = new OkBuffer();
   private HpackDraft05.Reader hpackReader;
-  private ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
+  private OkBuffer bytesOut = new OkBuffer();
   private HpackDraft05.Writer hpackWriter;
 
   @Before public void reset() {
     hpackReader = newReader(bytesIn);
-    hpackWriter = new HpackDraft05.Writer(new DataOutputStream(bytesOut));
+    hpackWriter = new HpackDraft05.Writer(bytesOut);
   }
 
   /**
@@ -50,16 +44,16 @@
    * Ensure the larger header content is not lost.
    */
   @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    OkBuffer out = new OkBuffer();
 
-    out.write(0x00); // Literal indexed
-    out.write(0x0a); // Literal name (len = 10)
-    out.write("custom-key".getBytes(), 0, 10);
+    out.writeByte(0x00); // Literal indexed
+    out.writeByte(0x0a); // Literal name (len = 10)
+    out.writeUtf8("custom-key");
 
-    out.write(0x0d); // Literal value (len = 13)
-    out.write("custom-header".getBytes(), 0, 13);
+    out.writeByte(0x0d); // Literal value (len = 13)
+    out.writeUtf8("custom-header");
 
-    bytesIn.set(out.toByteArray());
+    bytesIn.write(out, out.byteCount());
     hpackReader.maxHeaderTableByteCount(1);
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
@@ -71,30 +65,30 @@
 
   /** Oldest entries are evicted to support newer ones. */
   @Test public void testEviction() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    OkBuffer out = new OkBuffer();
 
-    out.write(0x00); // Literal indexed
-    out.write(0x0a); // Literal name (len = 10)
-    out.write("custom-foo".getBytes(), 0, 10);
+    out.writeByte(0x00); // Literal indexed
+    out.writeByte(0x0a); // Literal name (len = 10)
+    out.writeUtf8("custom-foo");
 
-    out.write(0x0d); // Literal value (len = 13)
-    out.write("custom-header".getBytes(), 0, 13);
+    out.writeByte(0x0d); // Literal value (len = 13)
+    out.writeUtf8("custom-header");
 
-    out.write(0x00); // Literal indexed
-    out.write(0x0a); // Literal name (len = 10)
-    out.write("custom-bar".getBytes(), 0, 10);
+    out.writeByte(0x00); // Literal indexed
+    out.writeByte(0x0a); // Literal name (len = 10)
+    out.writeUtf8("custom-bar");
 
-    out.write(0x0d); // Literal value (len = 13)
-    out.write("custom-header".getBytes(), 0, 13);
+    out.writeByte(0x0d); // Literal value (len = 13)
+    out.writeUtf8("custom-header");
 
-    out.write(0x00); // Literal indexed
-    out.write(0x0a); // Literal name (len = 10)
-    out.write("custom-baz".getBytes(), 0, 10);
+    out.writeByte(0x00); // Literal indexed
+    out.writeByte(0x0a); // Literal name (len = 10)
+    out.writeUtf8("custom-baz");
 
-    out.write(0x0d); // Literal value (len = 13)
-    out.write("custom-header".getBytes(), 0, 13);
+    out.writeByte(0x0d); // Literal value (len = 13)
+    out.writeUtf8("custom-header");
 
-    bytesIn.set(out.toByteArray());
+    bytesIn.write(out, out.byteCount());
     // Set to only support 110 bytes (enough for 2 headers).
     hpackReader.maxHeaderTableByteCount(110);
     hpackReader.readHeaders();
@@ -122,18 +116,18 @@
 
   /** Header table backing array is initially 8 long, let's ensure it grows. */
   @Test public void dynamicallyGrowsBeyond64Entries() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    OkBuffer out = new OkBuffer();
 
     for (int i = 0; i < 256; i++) {
-      out.write(0x00); // Literal indexed
-      out.write(0x0a); // Literal name (len = 10)
-      out.write("custom-foo".getBytes(), 0, 10);
+      out.writeByte(0x00); // Literal indexed
+      out.writeByte(0x0a); // Literal name (len = 10)
+      out.writeUtf8("custom-foo");
 
-      out.write(0x0d); // Literal value (len = 13)
-      out.write("custom-header".getBytes(), 0, 13);
+      out.writeByte(0x0d); // Literal value (len = 13)
+      out.writeUtf8("custom-header");
     }
 
-    bytesIn.set(out.toByteArray());
+    bytesIn.write(out, out.byteCount());
     hpackReader.maxHeaderTableByteCount(16384); // Lots of headers need more room!
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
@@ -144,19 +138,19 @@
   }
 
   @Test public void huffmanDecodingSupported() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    OkBuffer out = new OkBuffer();
 
-    out.write(0x04); // == Literal indexed ==
-                     // Indexed name (idx = 4) -> :path
-    out.write(0x8b); // Literal value Huffman encoded 11 bytes
-                     // decodes to www.example.com which is length 15
+    out.writeByte(0x04); // == Literal indexed ==
+                         // Indexed name (idx = 4) -> :path
+    out.writeByte(0x8b); // Literal value Huffman encoded 11 bytes
+                         // decodes to www.example.com which is length 15
     byte[] huffmanBytes = new byte[] {
         (byte) 0xdb, (byte) 0x6d, (byte) 0x88, (byte) 0x3e,
         (byte) 0x68, (byte) 0xd1, (byte) 0xcb, (byte) 0x12,
         (byte) 0x25, (byte) 0xba, (byte) 0x7f};
     out.write(huffmanBytes, 0, huffmanBytes.length);
 
-    bytesIn.set(out.toByteArray());
+    bytesIn.write(out, out.byteCount());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -172,16 +166,16 @@
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.1
    */
   @Test public void readLiteralHeaderFieldWithIndexing() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    OkBuffer out = new OkBuffer();
 
-    out.write(0x00); // Literal indexed
-    out.write(0x0a); // Literal name (len = 10)
-    out.write("custom-key".getBytes(), 0, 10);
+    out.writeByte(0x00); // Literal indexed
+    out.writeByte(0x0a); // Literal name (len = 10)
+    out.writeUtf8("custom-key");
 
-    out.write(0x0d); // Literal value (len = 13)
-    out.write("custom-header".getBytes(), 0, 13);
+    out.writeByte(0x0d); // Literal value (len = 13)
+    out.writeUtf8("custom-header");
 
-    bytesIn.set(out.toByteArray());
+    bytesIn.write(out, out.byteCount());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -201,19 +195,19 @@
   @Test public void literalHeaderFieldWithoutIndexingNewName() throws IOException {
     List<Header> headerBlock = headerEntries("custom-key", "custom-header");
 
-    ByteArrayOutputStream expectedBytes = new ByteArrayOutputStream();
+    OkBuffer expectedBytes = new OkBuffer();
 
-    expectedBytes.write(0x40); // Not indexed
-    expectedBytes.write(0x0a); // Literal name (len = 10)
+    expectedBytes.writeByte(0x40); // Not indexed
+    expectedBytes.writeByte(0x0a); // Literal name (len = 10)
     expectedBytes.write("custom-key".getBytes(), 0, 10);
 
-    expectedBytes.write(0x0d); // Literal value (len = 13)
+    expectedBytes.writeByte(0x0d); // Literal value (len = 13)
     expectedBytes.write("custom-header".getBytes(), 0, 13);
 
     hpackWriter.writeHeaders(headerBlock);
-    assertArrayEquals(expectedBytes.toByteArray(), bytesOut.toByteArray());
+    assertEquals(expectedBytes, bytesOut);
 
-    bytesIn.set(bytesOut.toByteArray());
+    bytesIn.write(bytesOut, bytesOut.byteCount());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -228,16 +222,16 @@
   @Test public void literalHeaderFieldWithoutIndexingIndexedName() throws IOException {
     List<Header> headerBlock = headerEntries(":path", "/sample/path");
 
-    ByteArrayOutputStream expectedBytes = new ByteArrayOutputStream();
-    expectedBytes.write(0x44); // == Literal not indexed ==
-                               // Indexed name (idx = 4) -> :path
-    expectedBytes.write(0x0c); // Literal value (len = 12)
+    OkBuffer expectedBytes = new OkBuffer();
+    expectedBytes.writeByte(0x44); // == Literal not indexed ==
+                                   // Indexed name (idx = 4) -> :path
+    expectedBytes.writeByte(0x0c); // Literal value (len = 12)
     expectedBytes.write("/sample/path".getBytes(), 0, 12);
 
     hpackWriter.writeHeaders(headerBlock);
-    assertArrayEquals(expectedBytes.toByteArray(), bytesOut.toByteArray());
+    assertEquals(expectedBytes, bytesOut);
 
-    bytesIn.set(bytesOut.toByteArray());
+    bytesIn.write(bytesOut, bytesOut.byteCount());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -250,12 +244,9 @@
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.3
    */
   @Test public void readIndexedHeaderField() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
 
-    out.write(0x82); // == Indexed - Add ==
-                     // idx = 2 -> :method: GET
-
-    bytesIn.set(out.toByteArray());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -273,16 +264,13 @@
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-3.2.1
    */
   @Test public void toggleIndex() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-
     // Static table entries are copied to the top of the reference set.
-    out.write(0x82); // == Indexed - Add ==
-                     // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
     // Specifying an index to an entry in the reference set removes it.
-    out.write(0x81); // == Indexed - Remove ==
-                     // idx = 1 -> :method: GET
+    bytesIn.writeByte(0x81); // == Indexed - Remove ==
+                             // idx = 1 -> :method: GET
 
-    bytesIn.set(out.toByteArray());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -300,12 +288,9 @@
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.4
    */
   @Test public void readIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
 
-    out.write(0x82); // == Indexed - Add ==
-                     // idx = 2 -> :method: GET
-
-    bytesIn.set(out.toByteArray());
     hpackReader.maxHeaderTableByteCount(0); // SETTINGS_HEADER_TABLE_SIZE == 0
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
@@ -320,38 +305,38 @@
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.2
    */
   @Test public void readRequestExamplesWithoutHuffman() throws IOException {
-    ByteArrayOutputStream out = firstRequestWithoutHuffman();
-    bytesIn.set(out.toByteArray());
+    OkBuffer out = firstRequestWithoutHuffman();
+    bytesIn.write(out, out.byteCount());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadFirstRequestWithoutHuffman();
 
     out = secondRequestWithoutHuffman();
-    bytesIn.set(out.toByteArray());
+    bytesIn.write(out, out.byteCount());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadSecondRequestWithoutHuffman();
 
     out = thirdRequestWithoutHuffman();
-    bytesIn.set(out.toByteArray());
+    bytesIn.write(out, out.byteCount());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadThirdRequestWithoutHuffman();
   }
 
-  private ByteArrayOutputStream firstRequestWithoutHuffman() {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+  private OkBuffer firstRequestWithoutHuffman() {
+    OkBuffer out = new OkBuffer();
 
-    out.write(0x82); // == Indexed - Add ==
-                     // idx = 2 -> :method: GET
-    out.write(0x87); // == Indexed - Add ==
-                     // idx = 7 -> :scheme: http
-    out.write(0x86); // == Indexed - Add ==
-                     // idx = 6 -> :path: /
-    out.write(0x04); // == Literal indexed ==
-                     // Indexed name (idx = 4) -> :authority
-    out.write(0x0f); // Literal value (len = 15)
-    out.write("www.example.com".getBytes(), 0, 15);
+    out.writeByte(0x82); // == Indexed - Add ==
+                         // idx = 2 -> :method: GET
+    out.writeByte(0x87); // == Indexed - Add ==
+                         // idx = 7 -> :scheme: http
+    out.writeByte(0x86); // == Indexed - Add ==
+                         // idx = 6 -> :path: /
+    out.writeByte(0x04); // == Literal indexed ==
+                         // Indexed name (idx = 4) -> :authority
+    out.writeByte(0x0f); // Literal value (len = 15)
+    out.writeUtf8("www.example.com");
 
     return out;
   }
@@ -390,13 +375,13 @@
         ":authority", "www.example.com"), hpackReader.getAndReset());
   }
 
-  private ByteArrayOutputStream secondRequestWithoutHuffman() {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+  private OkBuffer secondRequestWithoutHuffman() {
+    OkBuffer out = new OkBuffer();
 
-    out.write(0x1b); // == Literal indexed ==
-                     // Indexed name (idx = 27) -> cache-control
-    out.write(0x08); // Literal value (len = 8)
-    out.write("no-cache".getBytes(), 0, 8);
+    out.writeByte(0x1b); // == Literal indexed ==
+                         // Indexed name (idx = 27) -> cache-control
+    out.writeByte(0x08); // Literal value (len = 8)
+    out.writeUtf8("no-cache");
 
     return out;
   }
@@ -441,23 +426,23 @@
         "cache-control", "no-cache"), hpackReader.getAndReset());
   }
 
-  private ByteArrayOutputStream thirdRequestWithoutHuffman() {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+  private OkBuffer thirdRequestWithoutHuffman() {
+    OkBuffer out = new OkBuffer();
 
-    out.write(0x80); // == Empty reference set ==
-    out.write(0x85); // == Indexed - Add ==
-                     // idx = 5 -> :method: GET
-    out.write(0x8c); // == Indexed - Add ==
-                     // idx = 12 -> :scheme: https
-    out.write(0x8b); // == Indexed - Add ==
-                     // idx = 11 -> :path: /index.html
-    out.write(0x84); // == Indexed - Add ==
-                     // idx = 4 -> :authority: www.example.com
-    out.write(0x00); // Literal indexed
-    out.write(0x0a); // Literal name (len = 10)
-    out.write("custom-key".getBytes(), 0, 10);
-    out.write(0x0c); // Literal value (len = 12)
-    out.write("custom-value".getBytes(), 0, 12);
+    out.writeByte(0x80); // == Empty reference set ==
+    out.writeByte(0x85); // == Indexed - Add ==
+                         // idx = 5 -> :method: GET
+    out.writeByte(0x8c); // == Indexed - Add ==
+                         // idx = 12 -> :scheme: https
+    out.writeByte(0x8b); // == Indexed - Add ==
+                         // idx = 11 -> :path: /index.html
+    out.writeByte(0x84); // == Indexed - Add ==
+                         // idx = 4 -> :authority: www.example.com
+    out.writeByte(0x00); // Literal indexed
+    out.writeByte(0x0a); // Literal name (len = 10)
+    out.writeUtf8("custom-key");
+    out.writeByte(0x0c); // Literal value (len = 12)
+    out.writeUtf8("custom-value");
 
     return out;
   }
@@ -522,38 +507,38 @@
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.3
    */
   @Test public void readRequestExamplesWithHuffman() throws IOException {
-    ByteArrayOutputStream out = firstRequestWithHuffman();
-    bytesIn.set(out.toByteArray());
+    OkBuffer out = firstRequestWithHuffman();
+    bytesIn.write(out, out.byteCount());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadFirstRequestWithHuffman();
 
     out = secondRequestWithHuffman();
-    bytesIn.set(out.toByteArray());
+    bytesIn.write(out, out.byteCount());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadSecondRequestWithHuffman();
 
     out = thirdRequestWithHuffman();
-    bytesIn.set(out.toByteArray());
+    bytesIn.write(out, out.byteCount());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadThirdRequestWithHuffman();
   }
 
-  private ByteArrayOutputStream firstRequestWithHuffman() {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+  private OkBuffer firstRequestWithHuffman() {
+    OkBuffer out = new OkBuffer();
 
-    out.write(0x82); // == Indexed - Add ==
-                     // idx = 2 -> :method: GET
-    out.write(0x87); // == Indexed - Add ==
-                     // idx = 7 -> :scheme: http
-    out.write(0x86); // == Indexed - Add ==
-                     // idx = 6 -> :path: /
-    out.write(0x04); // == Literal indexed ==
-                     // Indexed name (idx = 4) -> :authority
-    out.write(0x8b); // Literal value Huffman encoded 11 bytes
-                     // decodes to www.example.com which is length 15
+    out.writeByte(0x82); // == Indexed - Add ==
+                         // idx = 2 -> :method: GET
+    out.writeByte(0x87); // == Indexed - Add ==
+                         // idx = 7 -> :scheme: http
+    out.writeByte(0x86); // == Indexed - Add ==
+                         // idx = 6 -> :path: /
+    out.writeByte(0x04); // == Literal indexed ==
+                         // Indexed name (idx = 4) -> :authority
+    out.writeByte(0x8b); // Literal value Huffman encoded 11 bytes
+                         // decodes to www.example.com which is length 15
     byte[] huffmanBytes = new byte[] {
         (byte) 0xdb, (byte) 0x6d, (byte) 0x88, (byte) 0x3e,
         (byte) 0x68, (byte) 0xd1, (byte) 0xcb, (byte) 0x12,
@@ -597,13 +582,13 @@
         ":authority", "www.example.com"), hpackReader.getAndReset());
   }
 
-  private ByteArrayOutputStream secondRequestWithHuffman() {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+  private OkBuffer secondRequestWithHuffman() {
+    OkBuffer out = new OkBuffer();
 
-    out.write(0x1b); // == Literal indexed ==
-                     // Indexed name (idx = 27) -> cache-control
-    out.write(0x86); // Literal value Huffman encoded 6 bytes
-                     // decodes to no-cache which is length 8
+    out.writeByte(0x1b); // == Literal indexed ==
+                         // Indexed name (idx = 27) -> cache-control
+    out.writeByte(0x86); // Literal value Huffman encoded 6 bytes
+                         // decodes to no-cache which is length 8
     byte[] huffmanBytes = new byte[] {
         (byte) 0x63, (byte) 0x65, (byte) 0x4a, (byte) 0x13,
         (byte) 0x98, (byte) 0xff};
@@ -652,27 +637,27 @@
         "cache-control", "no-cache"), hpackReader.getAndReset());
   }
 
-  private ByteArrayOutputStream thirdRequestWithHuffman() {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+  private OkBuffer thirdRequestWithHuffman() {
+    OkBuffer out = new OkBuffer();
 
-    out.write(0x80); // == Empty reference set ==
-    out.write(0x85); // == Indexed - Add ==
-                     // idx = 5 -> :method: GET
-    out.write(0x8c); // == Indexed - Add ==
-                     // idx = 12 -> :scheme: https
-    out.write(0x8b); // == Indexed - Add ==
-                     // idx = 11 -> :path: /index.html
-    out.write(0x84); // == Indexed - Add ==
-                     // idx = 4 -> :authority: www.example.com
-    out.write(0x00); // Literal indexed
-    out.write(0x88); // Literal name Huffman encoded 8 bytes
-                     // decodes to custom-key which is length 10
+    out.writeByte(0x80); // == Empty reference set ==
+    out.writeByte(0x85); // == Indexed - Add ==
+                         // idx = 5 -> :method: GET
+    out.writeByte(0x8c); // == Indexed - Add ==
+                         // idx = 12 -> :scheme: https
+    out.writeByte(0x8b); // == Indexed - Add ==
+                         // idx = 11 -> :path: /index.html
+    out.writeByte(0x84); // == Indexed - Add ==
+                         // idx = 4 -> :authority: www.example.com
+    out.writeByte(0x00); // Literal indexed
+    out.writeByte(0x88); // Literal name Huffman encoded 8 bytes
+                         // decodes to custom-key which is length 10
     byte[] huffmanBytes = new byte[] {
         (byte) 0x4e, (byte) 0xb0, (byte) 0x8b, (byte) 0x74,
         (byte) 0x97, (byte) 0x90, (byte) 0xfa, (byte) 0x7f};
     out.write(huffmanBytes, 0, huffmanBytes.length);
-    out.write(0x89); // Literal value Huffman encoded 6 bytes
-                     // decodes to custom-value which is length 12
+    out.writeByte(0x89); // Literal value Huffman encoded 6 bytes
+                         // decodes to custom-value which is length 12
     huffmanBytes = new byte[] {
         (byte) 0x4e, (byte) 0xb0, (byte) 0x8b, (byte) 0x74,
         (byte) 0x97, (byte) 0x9a, (byte) 0x17, (byte) 0xa8,
@@ -799,13 +784,12 @@
     assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString(false));
   }
 
-  private HpackDraft05.Reader newReader(InputStream input) {
-    return new HpackDraft05.Reader(false, 4096, Okio.source(input));
+  private HpackDraft05.Reader newReader(OkBuffer source) {
+    return new HpackDraft05.Reader(false, 4096, source);
   }
 
-  private InputStream byteStream(int... bytes) {
-    byte[] data = intArrayToByteArray(bytes);
-    return new ByteArrayInputStream(data);
+  private OkBuffer byteStream(int... bytes) {
+    return new OkBuffer().write(intArrayToByteArray(bytes));
   }
 
   private void checkEntry(Header entry, String name, String value, int size) {
@@ -815,18 +799,17 @@
   }
 
   private void assertBytes(int... bytes) {
-    byte[] expected = intArrayToByteArray(bytes);
-    byte[] actual = bytesOut.toByteArray();
-    assertEquals(Arrays.toString(expected), Arrays.toString(actual));
-    bytesOut.reset(); // So the next test starts with a clean slate.
+    ByteString expected = intArrayToByteArray(bytes);
+    ByteString actual = bytesOut.readByteString((int) bytesOut.byteCount());
+    assertEquals(expected, actual);
   }
 
-  private byte[] intArrayToByteArray(int[] bytes) {
+  private ByteString intArrayToByteArray(int[] bytes) {
     byte[] data = new byte[bytes.length];
     for (int i = 0; i < bytes.length; i++) {
       data[i] = (byte) bytes[i];
     }
-    return data;
+    return ByteString.of(data);
   }
 
   private void assertHeaderReferenced(int index) {
@@ -840,17 +823,4 @@
   private int headerTableLength() {
     return hpackReader.headerTable.length;
   }
-
-  static class MutableByteArrayInputStream extends ByteArrayInputStream {
-
-    MutableByteArrayInputStream() {
-      super(new byte[] { });
-    }
-
-    void set(byte[] replacement) {
-      this.buf = replacement;
-      this.pos = 0;
-      this.count = replacement.length;
-    }
-  }
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index b21e5d2..77eb8df 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -480,7 +480,7 @@
   }
 
   @Test public void frameSizeError() throws IOException {
-    Http20Draft09.Writer writer = new Http20Draft09.Writer(new ByteArrayOutputStream(), true);
+    Http20Draft09.Writer writer = new Http20Draft09.Writer(new OkBuffer(), true);
 
     try {
       writer.frameHeader(16384, Http20Draft09.TYPE_DATA, Http20Draft09.FLAG_NONE, 0);
@@ -491,7 +491,7 @@
   }
 
   @Test public void streamIdHasReservedBit() throws IOException {
-      Http20Draft09.Writer writer = new Http20Draft09.Writer(new ByteArrayOutputStream(), true);
+      Http20Draft09.Writer writer = new Http20Draft09.Writer(new OkBuffer(), true);
 
       try {
       int streamId = 3;
@@ -504,22 +504,22 @@
   }
 
   private byte[] literalHeaders(List<Header> sentHeaders) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    new HpackDraft05.Writer(new DataOutputStream(out)).writeHeaders(sentHeaders);
-    return out.toByteArray();
+    OkBuffer out = new OkBuffer();
+    new HpackDraft05.Writer(out).writeHeaders(sentHeaders);
+    return out.readByteString((int) out.byteCount()).toByteArray();
   }
 
   private byte[] sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    OkBuffer out = new OkBuffer();
     new Http20Draft09.Writer(out, true).ping(ack, payload1, payload2);
-    return out.toByteArray();
+    return out.readByteString((int) out.byteCount()).toByteArray();
   }
 
   private byte[] sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
       throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    OkBuffer out = new OkBuffer();
     new Http20Draft09.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
-    return out.toByteArray();
+    return out.readByteString((int) out.byteCount()).toByteArray();
   }
 
   private byte[] sendDataFrame(byte[] data) throws IOException {
@@ -527,15 +527,15 @@
   }
 
   private byte[] sendDataFrame(byte[] data, int offset, int byteCount) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    OkBuffer out = new OkBuffer();
     new Http20Draft09.Writer(out, true).dataFrame(expectedStreamId, Http20Draft09.FLAG_NONE, data,
         offset, byteCount);
-    return out.toByteArray();
+    return out.readByteString((int) out.byteCount()).toByteArray();
   }
 
   private byte[] windowUpdate(long windowSizeIncrement) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    OkBuffer out = new OkBuffer();
     new Http20Draft09.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
-    return out.toByteArray();
+    return out.readByteString((int) out.byteCount()).toByteArray();
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index 939bb99..6bef5dd 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -17,7 +17,6 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
@@ -33,6 +32,7 @@
 import java.util.concurrent.LinkedBlockingQueue;
 import okio.BufferedSource;
 import okio.ByteString;
+import okio.OkBuffer;
 import okio.Okio;
 
 /** Replays prerecorded outgoing frames and records incoming frames. */
@@ -40,7 +40,7 @@
   private int frameCount = 0;
   private boolean client = false;
   private Variant variant = new Spdy3();
-  private final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
+  private final OkBuffer bytesOut = new OkBuffer();
   private FrameWriter frameWriter = variant.newWriter(bytesOut, client);
   private final List<OutFrame> outFrames = new ArrayList<OutFrame>();
   private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<InFrame>();
@@ -69,7 +69,7 @@
   }
 
   public FrameWriter sendFrame() {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), Integer.MAX_VALUE));
+    outFrames.add(new OutFrame(frameCount++, bytesOut.byteCount(), Integer.MAX_VALUE));
     return frameWriter;
   }
 
@@ -78,7 +78,7 @@
    * won't be generated naturally.
    */
   public void sendFrame(byte[] frame) throws IOException {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), Integer.MAX_VALUE));
+    outFrames.add(new OutFrame(frameCount++, bytesOut.byteCount(), Integer.MAX_VALUE));
     bytesOut.write(frame);
   }
 
@@ -88,7 +88,7 @@
    * malformed.
    */
   public FrameWriter sendTruncatedFrame(int truncateToLength) {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), truncateToLength));
+    outFrames.add(new OutFrame(frameCount++, bytesOut.byteCount(), truncateToLength));
     return frameWriter;
   }
 
@@ -121,7 +121,7 @@
     FrameReader reader = variant.newReader(Okio.buffer(Okio.source(in)), client);
 
     Iterator<OutFrame> outFramesIterator = outFrames.iterator();
-    byte[] outBytes = bytesOut.toByteArray();
+    byte[] outBytes = bytesOut.readByteString((int) bytesOut.byteCount()).toByteArray();
     OutFrame nextOutFrame = null;
 
     for (int i = 0; i < frameCount; i++) {
@@ -130,9 +130,9 @@
       }
 
       if (nextOutFrame != null && nextOutFrame.sequence == i) {
-        int start = nextOutFrame.start;
+        long start = nextOutFrame.start;
         int truncateToLength = nextOutFrame.truncateToLength;
-        int end;
+        long end;
         if (outFramesIterator.hasNext()) {
           nextOutFrame = outFramesIterator.next();
           end = nextOutFrame.start;
@@ -141,8 +141,8 @@
         }
 
         // write a frame
-        int length = Math.min(end - start, truncateToLength);
-        out.write(outBytes, start, length);
+        int length = (int) Math.min(end - start, truncateToLength);
+        out.write(outBytes, (int) start, length);
       } else {
         // read a frame
         InFrame inFrame = new InFrame(i, reader);
@@ -173,10 +173,10 @@
 
   private static class OutFrame {
     private final int sequence;
-    private final int start;
+    private final long start;
     private final int truncateToLength;
 
-    private OutFrame(int sequence, int start, int truncateToLength) {
+    private OutFrame(int sequence, long start, int truncateToLength) {
       this.sequence = sequence;
       this.start = start;
       this.truncateToLength = truncateToLength;
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
index c56310a..fc7b977 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
@@ -98,21 +98,21 @@
   }
 
   private byte[] sendDataFrame(byte[] data, int offset, int byteCount) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    OkBuffer out = new OkBuffer();
     new Spdy3.Writer(out, true).sendDataFrame(expectedStreamId, 0, data, offset, byteCount);
-    return out.toByteArray();
+    return out.readByteString((int) out.byteCount()).toByteArray();
   }
 
   private byte[] windowUpdate(long increment) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    OkBuffer out = new OkBuffer();
     new Spdy3.Writer(out, true).windowUpdate(expectedStreamId, increment);
-    return out.toByteArray();
+    return out.readByteString((int) out.byteCount()).toByteArray();
   }
 
   private byte[] sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
       throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    OkBuffer out = new OkBuffer();
     new Spdy3.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
-    return out.toByteArray();
+    return out.readByteString((int) out.byteCount()).toByteArray();
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index 30994e3..fcf32eb 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -1060,7 +1060,7 @@
     // Play it back.
     SpdyConnection connection = connection(peer, variant);
     connection.okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, INITIAL_WINDOW_SIZE);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(0, stream.unacknowledgedBytesRead);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     Source in = stream.getSource();
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index 3e24376..8aaecd2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -32,6 +32,7 @@
 import java.net.Socket;
 import java.net.SocketTimeoutException;
 import javax.net.ssl.SSLSocket;
+import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.Okio;
@@ -73,6 +74,7 @@
   private InputStream in;
   private OutputStream out;
   private BufferedSource source;
+  private BufferedSink sink;
   private boolean connected = false;
   private HttpConnection httpConnection;
   private SpdyConnection spdyConnection;
@@ -98,7 +100,7 @@
     if (route.address.sslSocketFactory != null) {
       upgradeToTls(tunnelRequest);
     } else {
-      streamWrapper();
+      streamWrapper(true);
       httpConnection = new HttpConnection(pool, this, source, out);
     }
     connected = true;
@@ -153,7 +155,6 @@
     out = sslSocket.getOutputStream();
     in = sslSocket.getInputStream();
     handshake = Handshake.get(sslSocket.getSession());
-    streamWrapper();
 
     ByteString maybeProtocol;
     Protocol selectedProtocol = Protocol.HTTP_11;
@@ -162,11 +163,13 @@
     }
 
     if (selectedProtocol.spdyVariant) {
+      streamWrapper(false);
       sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
-      spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, source, out)
+      spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, source, sink)
           .protocol(selectedProtocol).build();
       spdyConnection.sendConnectionHeader();
     } else {
+      streamWrapper(true);
       httpConnection = new HttpConnection(pool, this, source, out);
     }
   }
@@ -337,8 +340,14 @@
     }
   }
 
-  private void streamWrapper() throws IOException {
+  // TODO: drop the outputStream option when we use Okio's sink in HttpConnection.
+  private void streamWrapper(boolean outputStream) throws IOException {
     source = Okio.buffer(Okio.source(in));
-    out = new BufferedOutputStream(out, 256);
+
+    if (outputStream) {
+      out = new BufferedOutputStream(out, 256);
+    } else {
+      sink = Okio.buffer(Okio.sink(out));
+    }
   }
 }
/Fim/
diff --git a/okio/src/main/java/okio/DeflaterSink.java b/okio/src/main/java/okio/DeflaterSink.java
index 43a964c..276c3e6 100644
--- a/okio/src/main/java/okio/DeflaterSink.java
+++ b/okio/src/main/java/okio/DeflaterSink.java
@@ -70,8 +70,9 @@
 
   @IgnoreJRERequirement
   private void deflate(boolean syncFlush) throws IOException {
+    OkBuffer buffer = sink.buffer();
     while (true) {
-      Segment s = sink.buffer().writableSegment(1);
+      Segment s = buffer.writableSegment(1);
 
       // The 4-parameter overload of deflate() doesn't exist in the RI until
       // Java 1.7, and is public (although with @hide) on Android since 2.3.
@@ -83,7 +84,7 @@
 
       if (deflated == 0) return;
       s.limit += deflated;
-      sink.buffer().byteCount += deflated;
+      buffer.byteCount += deflated;
       sink.emitCompleteSegments();
     }
   }
/Fim/
diff --git a/okio/src/main/java/okio/RealBufferedSink.java b/okio/src/main/java/okio/RealBufferedSink.java
index 2ad52c4..99ae0cc 100644
--- a/okio/src/main/java/okio/RealBufferedSink.java
+++ b/okio/src/main/java/okio/RealBufferedSink.java
@@ -126,6 +126,7 @@
   }
 
   @Override public void close() throws IOException {
+    if (closed) return;
     flush();
     sink.close();
     closed = true;
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index 8aaecd2..894a418 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -23,7 +23,6 @@
 import com.squareup.okhttp.internal.http.HttpTransport;
 import com.squareup.okhttp.internal.http.SpdyTransport;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
-import java.io.BufferedOutputStream;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
@@ -100,8 +99,8 @@
     if (route.address.sslSocketFactory != null) {
       upgradeToTls(tunnelRequest);
     } else {
-      streamWrapper(true);
-      httpConnection = new HttpConnection(pool, this, source, out);
+      initSourceAndSink();
+      httpConnection = new HttpConnection(pool, this, source, sink);
     }
     connected = true;
   }
@@ -155,6 +154,7 @@
     out = sslSocket.getOutputStream();
     in = sslSocket.getInputStream();
     handshake = Handshake.get(sslSocket.getSession());
+    initSourceAndSink();
 
     ByteString maybeProtocol;
     Protocol selectedProtocol = Protocol.HTTP_11;
@@ -163,14 +163,12 @@
     }
 
     if (selectedProtocol.spdyVariant) {
-      streamWrapper(false);
       sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
       spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, source, sink)
           .protocol(selectedProtocol).build();
       spdyConnection.sendConnectionHeader();
     } else {
-      streamWrapper(true);
-      httpConnection = new HttpConnection(pool, this, source, out);
+      httpConnection = new HttpConnection(pool, this, source, sink);
     }
   }
 
@@ -310,11 +308,13 @@
    */
   private void makeTunnel(TunnelRequest tunnelRequest) throws IOException {
     BufferedSource tunnelSource = Okio.buffer(Okio.source(in));
-    HttpConnection tunnelConnection = new HttpConnection(pool, this, tunnelSource, out);
+    BufferedSink tunnelSink = Okio.buffer(Okio.sink(out));
+    HttpConnection tunnelConnection = new HttpConnection(pool, this, tunnelSource, tunnelSink);
     Request request = tunnelRequest.getRequest();
     String requestLine = tunnelRequest.requestLine();
     while (true) {
       tunnelConnection.writeRequest(request.headers(), requestLine);
+      tunnelConnection.flush();
       Response response = tunnelConnection.readResponse().request(request).build();
       tunnelConnection.emptyResponseBody();
 
@@ -340,14 +340,8 @@
     }
   }
 
-  // TODO: drop the outputStream option when we use Okio's sink in HttpConnection.
-  private void streamWrapper(boolean outputStream) throws IOException {
+  private void initSourceAndSink() throws IOException {
     source = Okio.buffer(Okio.source(in));
-
-    if (outputStream) {
-      out = new BufferedOutputStream(out, 256);
-    } else {
-      sink = Okio.buffer(Okio.sink(out));
-    }
+    sink = Okio.buffer(Okio.sink(out));
   }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
index 3ba72c6..3d9d19a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
@@ -23,12 +23,12 @@
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.AbstractOutputStream;
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.net.CacheRequest;
 import java.net.ProtocolException;
 import java.net.Socket;
+import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.Deadline;
 import okio.OkBuffer;
@@ -74,17 +74,17 @@
   private final ConnectionPool pool;
   private final Connection connection;
   private final BufferedSource source;
-  private final OutputStream out;
+  private final BufferedSink sink;
 
   private int state = STATE_IDLE;
   private int onIdle = ON_IDLE_HOLD;
 
   public HttpConnection(ConnectionPool pool, Connection connection, BufferedSource source,
-      OutputStream out) {
+      BufferedSink sink) {
     this.pool = pool;
     this.connection = connection;
     this.source = source;
-    this.out = out;
+    this.sink = sink;
   }
 
   /**
@@ -121,22 +121,20 @@
   }
 
   public void flush() throws IOException {
-    out.flush();
+    sink.flush();
   }
 
   /** Returns bytes of a request header for sending on an HTTP transport. */
   public void writeRequest(Headers headers, String requestLine) throws IOException {
     if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
-    StringBuilder result = new StringBuilder(256);
-    result.append(requestLine).append("\r\n");
+    sink.writeUtf8(requestLine).writeUtf8("\r\n");
     for (int i = 0; i < headers.size(); i ++) {
-      result.append(headers.name(i))
-          .append(": ")
-          .append(headers.value(i))
-          .append("\r\n");
+      sink.writeUtf8(headers.name(i))
+          .writeUtf8(": ")
+          .writeUtf8(headers.value(i))
+          .writeUtf8("\r\n");
     }
-    result.append("\r\n");
-    out.write(result.toString().getBytes("ISO-8859-1"));
+    sink.writeUtf8("\r\n");
     state = STATE_OPEN_REQUEST_BODY;
   }
 
@@ -214,19 +212,19 @@
   public OutputStream newChunkedOutputStream(int defaultChunkLength) {
     if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_WRITING_REQUEST_BODY;
-    return new ChunkedOutputStream(out, defaultChunkLength);
+    return new ChunkedOutputStream(sink, defaultChunkLength);
   }
 
   public OutputStream newFixedLengthOutputStream(long contentLength) {
     if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_WRITING_REQUEST_BODY;
-    return new FixedLengthOutputStream(out, contentLength);
+    return new FixedLengthOutputStream(sink, contentLength);
   }
 
   public void writeRequestBody(RetryableOutputStream requestBody) throws IOException {
     if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_READ_RESPONSE_HEADERS;
-    requestBody.writeToSocket(out);
+    requestBody.writeToSocket(sink);
   }
 
   public Source newFixedLengthSource(CacheRequest cacheRequest, long length)
@@ -259,11 +257,11 @@
 
   /** An HTTP body with a fixed length known in advance. */
   private final class FixedLengthOutputStream extends AbstractOutputStream {
-    private final OutputStream socketOut;
+    private final BufferedSink sink;
     private long bytesRemaining;
 
-    private FixedLengthOutputStream(OutputStream socketOut, long bytesRemaining) {
-      this.socketOut = socketOut;
+    private FixedLengthOutputStream(BufferedSink sink, long bytesRemaining) {
+      this.sink = sink;
       this.bytesRemaining = bytesRemaining;
     }
 
@@ -273,7 +271,7 @@
       if (count > bytesRemaining) {
         throw new ProtocolException("expected " + bytesRemaining + " bytes but received " + count);
       }
-      socketOut.write(buffer, offset, count);
+      sink.write(buffer, offset, count);
       bytesRemaining -= count;
     }
 
@@ -281,7 +279,7 @@
       if (closed) {
         return; // don't throw; this stream might have been closed on the caller's behalf
       }
-      socketOut.flush();
+      sink.flush();
     }
 
     @Override public void close() throws IOException {
@@ -296,7 +294,7 @@
     }
   }
 
-  private static final byte[] CRLF = { '\r', '\n' };
+  private static final String CRLF = "\r\n";
   private static final byte[] HEX_DIGITS = {
       '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
   };
@@ -311,14 +309,14 @@
     /** Scratch space for up to 8 hex digits, and then a constant CRLF. */
     private final byte[] hex = { 0, 0, 0, 0, 0, 0, 0, 0, '\r', '\n' };
 
-    private final OutputStream socketOut;
+    private final BufferedSink sink;
     private final int maxChunkLength;
-    private final ByteArrayOutputStream bufferedChunk;
+    private final OkBuffer bufferedChunk;
 
-    private ChunkedOutputStream(OutputStream socketOut, int maxChunkLength) {
-      this.socketOut = socketOut;
+    private ChunkedOutputStream(BufferedSink sink, int maxChunkLength) {
+      this.sink = sink;
       this.maxChunkLength = Math.max(1, dataLength(maxChunkLength));
-      this.bufferedChunk = new ByteArrayOutputStream(maxChunkLength);
+      this.bufferedChunk = new OkBuffer();
     }
 
     /**
@@ -342,20 +340,20 @@
       while (count > 0) {
         int numBytesWritten;
 
-        if (bufferedChunk.size() > 0 || count < maxChunkLength) {
+        if (bufferedChunk.byteCount() > 0 || count < maxChunkLength) {
           // fill the buffered chunk and then maybe write that to the stream
-          numBytesWritten = Math.min(count, maxChunkLength - bufferedChunk.size());
+          numBytesWritten = (int) Math.min(count, maxChunkLength - bufferedChunk.byteCount());
           // TODO: skip unnecessary copies from buffer->bufferedChunk?
           bufferedChunk.write(buffer, offset, numBytesWritten);
-          if (bufferedChunk.size() == maxChunkLength) {
+          if (bufferedChunk.byteCount() == maxChunkLength) {
             writeBufferedChunkToSocket();
           }
         } else {
           // write a single chunk of size maxChunkLength to the stream
           numBytesWritten = maxChunkLength;
           writeHex(numBytesWritten);
-          socketOut.write(buffer, offset, numBytesWritten);
-          socketOut.write(CRLF);
+          sink.write(buffer, offset, numBytesWritten);
+          sink.writeUtf8(CRLF);
         }
 
         offset += numBytesWritten;
@@ -372,7 +370,7 @@
       do {
         hex[--cursor] = HEX_DIGITS[i & 0xf];
       } while ((i >>>= 4) != 0);
-      socketOut.write(hex, cursor, hex.length - cursor);
+      sink.write(hex, cursor, hex.length - cursor);
     }
 
     @Override public synchronized void flush() throws IOException {
@@ -380,7 +378,7 @@
         return; // don't throw; this stream might have been closed on the caller's behalf
       }
       writeBufferedChunkToSocket();
-      socketOut.flush();
+      sink.flush();
     }
 
     @Override public synchronized void close() throws IOException {
@@ -389,20 +387,17 @@
       }
       closed = true;
       writeBufferedChunkToSocket();
-      socketOut.write(FINAL_CHUNK);
+      sink.write(FINAL_CHUNK);
       state = STATE_READ_RESPONSE_HEADERS;
     }
 
     private void writeBufferedChunkToSocket() throws IOException {
-      int size = bufferedChunk.size();
-      if (size <= 0) {
-        return;
-      }
+      int size = (int) bufferedChunk.byteCount();
+      if (size == 0) return;
 
       writeHex(size);
-      bufferedChunk.writeTo(socketOut);
-      bufferedChunk.reset();
-      socketOut.write(CRLF);
+      sink.write(bufferedChunk, bufferedChunk.byteCount());
+      sink.writeUtf8(CRLF);
     }
   }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableOutputStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableOutputStream.java
index 5eb6b76..b0a8531 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableOutputStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableOutputStream.java
@@ -19,8 +19,8 @@
 import com.squareup.okhttp.internal.AbstractOutputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.io.OutputStream;
 import java.net.ProtocolException;
+import okio.BufferedSink;
 
 import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
 
@@ -69,7 +69,7 @@
     return content.size();
   }
 
-  public void writeToSocket(OutputStream socketOut) throws IOException {
-    content.writeTo(socketOut);
+  public void writeToSocket(BufferedSink socketOut) throws IOException {
+    content.writeTo(socketOut.outputStream());
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index 01aec35..9093661 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -16,8 +16,6 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.List;
@@ -27,7 +25,6 @@
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.Util.headerEntries;
-import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -37,16 +34,15 @@
   static final int expectedStreamId = 15;
 
   @Test public void unknownFrameTypeIgnored() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
-    dataOut.writeShort(4); // has a 4-byte field
-    dataOut.write(99); // type 99
-    dataOut.write(0); // no flags
-    dataOut.writeInt(expectedStreamId);
-    dataOut.writeInt(111111111); // custom data
+    frame.writeShort(4); // has a 4-byte field
+    frame.writeByte(99); // type 99
+    frame.writeByte(0); // no flags
+    frame.writeInt(expectedStreamId);
+    frame.writeInt(111111111); // custom data
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     // Consume the unknown frame.
     fr.nextFrame(new BaseTestHandler());
@@ -55,20 +51,19 @@
   @Test public void onlyOneLiteralHeadersFrame() throws IOException {
     final List<Header> sentHeaders = headerEntries("name", "value");
 
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     // Write the headers frame, specifying no more frames are expected.
     {
-      byte[] headerBytes = literalHeaders(sentHeaders);
-      dataOut.writeShort(headerBytes.length);
-      dataOut.write(Http20Draft09.TYPE_HEADERS);
-      dataOut.write(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_END_STREAM);
-      dataOut.writeInt(expectedStreamId & 0x7fffffff);
-      dataOut.write(headerBytes);
+      OkBuffer headerBytes = literalHeaders(sentHeaders);
+      frame.writeShort((int) headerBytes.byteCount());
+      frame.writeByte(Http20Draft09.TYPE_HEADERS);
+      frame.writeByte(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_END_STREAM);
+      frame.writeInt(expectedStreamId & 0x7fffffff);
+      frame.write(headerBytes, headerBytes.byteCount());
     }
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     // Consume the headers frame.
     fr.nextFrame(new BaseTestHandler() {
@@ -89,22 +84,21 @@
   }
 
   @Test public void headersWithPriority() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final List<Header> sentHeaders = headerEntries("name", "value");
 
     { // Write the headers frame, specifying priority flag and value.
-      byte[] headerBytes = literalHeaders(sentHeaders);
-      dataOut.writeShort(headerBytes.length + 4);
-      dataOut.write(Http20Draft09.TYPE_HEADERS);
-      dataOut.write(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_PRIORITY);
-      dataOut.writeInt(expectedStreamId & 0x7fffffff);
-      dataOut.writeInt(0); // Highest priority is 0.
-      dataOut.write(headerBytes);
+      OkBuffer headerBytes = literalHeaders(sentHeaders);
+      frame.writeShort((int) (headerBytes.byteCount() + 4));
+      frame.writeByte(Http20Draft09.TYPE_HEADERS);
+      frame.writeByte(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_PRIORITY);
+      frame.writeInt(expectedStreamId & 0x7fffffff);
+      frame.writeInt(0); // Highest priority is 0.
+      frame.write(headerBytes, headerBytes.byteCount());
     }
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     // Consume the headers frame.
     fr.nextFrame(new BaseTestHandler() {
@@ -127,28 +121,27 @@
   /** Headers are compressed, then framed. */
   @Test public void headersFrameThenContinuation() throws IOException {
 
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     // Decoding the first header will cross frame boundaries.
-    byte[] headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+    OkBuffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
     { // Write the first headers frame.
-      dataOut.writeShort(headerBlock.length / 2);
-      dataOut.write(Http20Draft09.TYPE_HEADERS);
-      dataOut.write(0); // no flags
-      dataOut.writeInt(expectedStreamId & 0x7fffffff);
-      dataOut.write(headerBlock, 0, headerBlock.length / 2);
+      frame.writeShort((int) (headerBlock.byteCount() / 2));
+      frame.writeByte(Http20Draft09.TYPE_HEADERS);
+      frame.writeByte(0); // no flags
+      frame.writeInt(expectedStreamId & 0x7fffffff);
+      frame.write(headerBlock, headerBlock.byteCount() / 2);
     }
 
     { // Write the continuation frame, specifying no more frames are expected.
-      dataOut.writeShort(headerBlock.length / 2);
-      dataOut.write(Http20Draft09.TYPE_CONTINUATION);
-      dataOut.write(Http20Draft09.FLAG_END_HEADERS);
-      dataOut.writeInt(expectedStreamId & 0x7fffffff);
-      dataOut.write(headerBlock, headerBlock.length / 2, headerBlock.length / 2);
+      frame.writeShort((int) headerBlock.byteCount());
+      frame.writeByte(Http20Draft09.TYPE_CONTINUATION);
+      frame.writeByte(Http20Draft09.FLAG_END_HEADERS);
+      frame.writeInt(expectedStreamId & 0x7fffffff);
+      frame.write(headerBlock, headerBlock.byteCount());
     }
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     // Reading the above frames should result in a concatenated headerBlock.
     fr.nextFrame(new BaseTestHandler() {
@@ -169,8 +162,7 @@
   }
 
   @Test public void pushPromise() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final int expectedPromisedStreamId = 11;
 
@@ -182,16 +174,16 @@
     );
 
     { // Write the push promise frame, specifying the associated stream ID.
-      byte[] headerBytes = literalHeaders(pushPromise);
-      dataOut.writeShort(headerBytes.length + 4);
-      dataOut.write(Http20Draft09.TYPE_PUSH_PROMISE);
-      dataOut.write(Http20Draft09.FLAG_END_PUSH_PROMISE);
-      dataOut.writeInt(expectedStreamId & 0x7fffffff);
-      dataOut.writeInt(expectedPromisedStreamId & 0x7fffffff);
-      dataOut.write(headerBytes);
+      OkBuffer headerBytes = literalHeaders(pushPromise);
+      frame.writeShort((int) (headerBytes.byteCount() + 4));
+      frame.writeByte(Http20Draft09.TYPE_PUSH_PROMISE);
+      frame.writeByte(Http20Draft09.FLAG_END_PUSH_PROMISE);
+      frame.writeInt(expectedStreamId & 0x7fffffff);
+      frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
+      frame.write(headerBytes, headerBytes.byteCount());
     }
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     // Consume the headers frame.
     fr.nextFrame(new BaseTestHandler() {
@@ -206,8 +198,7 @@
 
   /** Headers are compressed, then framed. */
   @Test public void pushPromiseThenContinuation() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final int expectedPromisedStreamId = 11;
 
@@ -219,26 +210,26 @@
     );
 
     // Decoding the first header will cross frame boundaries.
-    byte[] headerBlock = literalHeaders(pushPromise);
-    int firstFrameLength = headerBlock.length - 1;
+    OkBuffer headerBlock = literalHeaders(pushPromise);
+    int firstFrameLength = (int) (headerBlock.byteCount() - 1);
     { // Write the first headers frame.
-      dataOut.writeShort(firstFrameLength + 4);
-      dataOut.write(Http20Draft09.TYPE_PUSH_PROMISE);
-      dataOut.write(0); // no flags
-      dataOut.writeInt(expectedStreamId & 0x7fffffff);
-      dataOut.writeInt(expectedPromisedStreamId & 0x7fffffff);
-      dataOut.write(headerBlock, 0, firstFrameLength);
+      frame.writeShort(firstFrameLength + 4);
+      frame.writeByte(Http20Draft09.TYPE_PUSH_PROMISE);
+      frame.writeByte(0); // no flags
+      frame.writeInt(expectedStreamId & 0x7fffffff);
+      frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
+      frame.write(headerBlock, firstFrameLength);
     }
 
     { // Write the continuation frame, specifying no more frames are expected.
-      dataOut.writeShort(1);
-      dataOut.write(Http20Draft09.TYPE_CONTINUATION);
-      dataOut.write(Http20Draft09.FLAG_END_HEADERS);
-      dataOut.writeInt(expectedStreamId & 0x7fffffff);
-      dataOut.write(headerBlock, firstFrameLength, 1);
+      frame.writeShort(1);
+      frame.writeByte(Http20Draft09.TYPE_CONTINUATION);
+      frame.writeByte(Http20Draft09.FLAG_END_HEADERS);
+      frame.writeInt(expectedStreamId & 0x7fffffff);
+      frame.write(headerBlock, 1);
     }
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     // Reading the above frames should result in a concatenated headerBlock.
     fr.nextFrame(new BaseTestHandler() {
@@ -252,16 +243,15 @@
   }
 
   @Test public void readRstStreamFrame() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
-    dataOut.writeShort(4);
-    dataOut.write(Http20Draft09.TYPE_RST_STREAM);
-    dataOut.write(0); // No flags
-    dataOut.writeInt(expectedStreamId & 0x7fffffff);
-    dataOut.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
+    frame.writeShort(4);
+    frame.writeByte(Http20Draft09.TYPE_RST_STREAM);
+    frame.writeByte(0); // No flags
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     // Consume the reset frame.
     fr.nextFrame(new BaseTestHandler() {
@@ -273,21 +263,20 @@
   }
 
   @Test public void readSettingsFrame() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final int reducedTableSizeBytes = 16;
 
-    dataOut.writeShort(16); // 2 settings * 4 bytes for the code and 4 for the value.
-    dataOut.write(Http20Draft09.TYPE_SETTINGS);
-    dataOut.write(0); // No flags
-    dataOut.writeInt(0 & 0x7fffffff); // Settings are always on the connection stream 0.
-    dataOut.writeInt(Settings.HEADER_TABLE_SIZE & 0xffffff);
-    dataOut.writeInt(reducedTableSizeBytes);
-    dataOut.writeInt(Settings.ENABLE_PUSH & 0xffffff);
-    dataOut.writeInt(0);
+    frame.writeShort(16); // 2 settings * 4 bytes for the code and 4 for the value.
+    frame.writeByte(Http20Draft09.TYPE_SETTINGS);
+    frame.writeByte(0); // No flags
+    frame.writeInt(0 & 0x7fffffff); // Settings are always on the connection stream 0.
+    frame.writeInt(Settings.HEADER_TABLE_SIZE & 0xffffff);
+    frame.writeInt(reducedTableSizeBytes);
+    frame.writeInt(Settings.ENABLE_PUSH & 0xffffff);
+    frame.writeInt(0);
 
-    final Http20Draft09.Reader fr = newReader(out);
+    final Http20Draft09.Reader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     // Consume the settings frame.
     fr.nextFrame(new BaseTestHandler() {
@@ -300,24 +289,23 @@
   }
 
   @Test public void pingRoundTrip() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final int expectedPayload1 = 7;
     final int expectedPayload2 = 8;
 
     // Compose the expected PING frame.
-    dataOut.writeShort(8); // length
-    dataOut.write(Http20Draft09.TYPE_PING);
-    dataOut.write(Http20Draft09.FLAG_ACK);
-    dataOut.writeInt(0); // connection-level
-    dataOut.writeInt(expectedPayload1);
-    dataOut.writeInt(expectedPayload2);
+    frame.writeShort(8); // length
+    frame.writeByte(Http20Draft09.TYPE_PING);
+    frame.writeByte(Http20Draft09.FLAG_ACK);
+    frame.writeInt(0); // connection-level
+    frame.writeInt(expectedPayload1);
+    frame.writeInt(expectedPayload2);
 
     // Check writer sends the same bytes.
-    assertArrayEquals(out.toByteArray(), sendPingFrame(true, expectedPayload1, expectedPayload2));
+    assertEquals(frame, sendPingFrame(true, expectedPayload1, expectedPayload2));
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     fr.nextFrame(new BaseTestHandler() { // Consume the ping frame.
       @Override public void ping(boolean ack, int payload1, int payload2) {
@@ -329,23 +317,22 @@
   }
 
   @Test public void maxLengthDataFrame() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final byte[] expectedData = new byte[16383];
     Arrays.fill(expectedData, (byte) 2);
 
     // Write the data frame.
-    dataOut.writeShort(expectedData.length);
-    dataOut.write(Http20Draft09.TYPE_DATA);
-    dataOut.write(0); // no flags
-    dataOut.writeInt(expectedStreamId & 0x7fffffff);
-    dataOut.write(expectedData);
+    frame.writeShort(expectedData.length);
+    frame.writeByte(Http20Draft09.TYPE_DATA);
+    frame.writeByte(0); // no flags
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.write(expectedData);
 
     // Check writer sends the same bytes.
-    assertArrayEquals(out.toByteArray(), sendDataFrame(new OkBuffer().write(expectedData)));
+    assertEquals(frame, sendDataFrame(new OkBuffer().write(expectedData)));
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     fr.nextFrame(new BaseTestHandler() {
       @Override public void data(
@@ -371,22 +358,21 @@
   }
 
   @Test public void windowUpdateRoundTrip() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final long expectedWindowSizeIncrement = 0x7fffffff;
 
     // Compose the expected window update frame.
-    dataOut.writeShort(4); // length
-    dataOut.write(Http20Draft09.TYPE_WINDOW_UPDATE);
-    dataOut.write(0); // No flags.
-    dataOut.writeInt(expectedStreamId);
-    dataOut.writeInt((int) expectedWindowSizeIncrement);
+    frame.writeShort(4); // length
+    frame.writeByte(Http20Draft09.TYPE_WINDOW_UPDATE);
+    frame.writeByte(0); // No flags.
+    frame.writeInt(expectedStreamId);
+    frame.writeInt((int) expectedWindowSizeIncrement);
 
     // Check writer sends the same bytes.
-    assertArrayEquals(out.toByteArray(), windowUpdate(expectedWindowSizeIncrement));
+    assertEquals(frame, windowUpdate(expectedWindowSizeIncrement));
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     fr.nextFrame(new BaseTestHandler() { // Consume the window update frame.
       @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
@@ -414,24 +400,22 @@
   }
 
   @Test public void goAwayWithoutDebugDataRoundTrip() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
 
     // Compose the expected GOAWAY frame without debug data.
-    dataOut.writeShort(8); // Without debug data there's only 2 32-bit fields.
-    dataOut.write(Http20Draft09.TYPE_GOAWAY);
-    dataOut.write(0); // no flags.
-    dataOut.writeInt(0); // connection-scope
-    dataOut.writeInt(expectedStreamId); // last good stream.
-    dataOut.writeInt(expectedError.httpCode);
+    frame.writeShort(8); // Without debug data there's only 2 32-bit fields.
+    frame.writeByte(Http20Draft09.TYPE_GOAWAY);
+    frame.writeByte(0); // no flags.
+    frame.writeInt(0); // connection-scope
+    frame.writeInt(expectedStreamId); // last good stream.
+    frame.writeInt(expectedError.httpCode);
 
     // Check writer sends the same bytes.
-    assertArrayEquals(out.toByteArray(),
-        sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
+    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     fr.nextFrame(new BaseTestHandler() { // Consume the go away frame.
       @Override public void goAway(
@@ -444,25 +428,24 @@
   }
 
   @Test public void goAwayWithDebugDataRoundTrip() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
     final ByteString expectedData = ByteString.encodeUtf8("abcdefgh");
 
     // Compose the expected GOAWAY frame without debug data.
-    dataOut.writeShort(8 + expectedData.size());
-    dataOut.write(Http20Draft09.TYPE_GOAWAY);
-    dataOut.write(0); // no flags.
-    dataOut.writeInt(0); // connection-scope
-    dataOut.writeInt(0); // never read any stream!
-    dataOut.writeInt(expectedError.httpCode);
-    dataOut.write(expectedData.toByteArray());
+    frame.writeShort(8 + expectedData.size());
+    frame.writeByte(Http20Draft09.TYPE_GOAWAY);
+    frame.writeByte(0); // no flags.
+    frame.writeInt(0); // connection-scope
+    frame.writeInt(0); // never read any stream!
+    frame.writeInt(expectedError.httpCode);
+    frame.write(expectedData.toByteArray());
 
     // Check writer sends the same bytes.
-    assertArrayEquals(out.toByteArray(), sendGoAway(0, expectedError, expectedData.toByteArray()));
+    assertEquals(frame, sendGoAway(0, expectedError, expectedData.toByteArray()));
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     fr.nextFrame(new BaseTestHandler() { // Consume the go away frame.
       @Override public void goAway(
@@ -474,11 +457,6 @@
     });
   }
 
-  private Http20Draft09.Reader newReader(ByteArrayOutputStream out) {
-    OkBuffer buffer = new OkBuffer().write(out.toByteArray());
-    return new Http20Draft09.Reader(buffer, 4096, false);
-  }
-
   @Test public void frameSizeError() throws IOException {
     Http20Draft09.Writer writer = new Http20Draft09.Writer(new OkBuffer(), true);
 
@@ -503,35 +481,35 @@
     }
   }
 
-  private byte[] literalHeaders(List<Header> sentHeaders) throws IOException {
+  private OkBuffer literalHeaders(List<Header> sentHeaders) throws IOException {
     OkBuffer out = new OkBuffer();
     new HpackDraft05.Writer(out).writeHeaders(sentHeaders);
-    return out.readByteString((int) out.byteCount()).toByteArray();
+    return out;
   }
 
-  private byte[] sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
+  private OkBuffer sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
     OkBuffer out = new OkBuffer();
     new Http20Draft09.Writer(out, true).ping(ack, payload1, payload2);
-    return out.readByteString((int) out.byteCount()).toByteArray();
+    return out;
   }
 
-  private byte[] sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+  private OkBuffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
       throws IOException {
     OkBuffer out = new OkBuffer();
     new Http20Draft09.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
-    return out.readByteString((int) out.byteCount()).toByteArray();
+    return out;
   }
 
-  private byte[] sendDataFrame(OkBuffer data) throws IOException {
+  private OkBuffer sendDataFrame(OkBuffer data) throws IOException {
     OkBuffer out = new OkBuffer();
     new Http20Draft09.Writer(out, true).dataFrame(expectedStreamId, Http20Draft09.FLAG_NONE, data,
         (int) data.byteCount());
-    return out.readByteString((int) out.byteCount()).toByteArray();
+    return out;
   }
 
-  private byte[] windowUpdate(long windowSizeIncrement) throws IOException {
+  private OkBuffer windowUpdate(long windowSizeIncrement) throws IOException {
     OkBuffer out = new OkBuffer();
     new Http20Draft09.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
-    return out.readByteString((int) out.byteCount()).toByteArray();
+    return out;
   }
 }
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
index 3c6145e..39e461f 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
@@ -16,14 +16,11 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
 import java.io.IOException;
 import okio.ByteString;
 import okio.OkBuffer;
 import org.junit.Test;
 
-import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
@@ -56,27 +53,25 @@
   }
 
   @Test public void goAwayRoundTrip() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
 
     // Compose the expected GOAWAY frame without debug data
     // |C| Version(15bits) | Type(16bits) |
-    dataOut.writeInt(0x80000000 | (Spdy3.VERSION & 0x7fff) << 16 | Spdy3.TYPE_GOAWAY & 0xffff);
+    frame.writeInt(0x80000000 | (Spdy3.VERSION & 0x7fff) << 16 | Spdy3.TYPE_GOAWAY & 0xffff);
     // | Flags (8)  |  Length (24 bits)   |
-    dataOut.writeInt(8); // no flags and length is 8.
-    dataOut.writeInt(expectedStreamId); // last good stream.
-    dataOut.writeInt(expectedError.spdyGoAwayCode);
+    frame.writeInt(8); // no flags and length is 8.
+    frame.writeInt(expectedStreamId); // last good stream.
+    frame.writeInt(expectedError.spdyGoAwayCode);
 
     // Check writer sends the same bytes.
-    assertArrayEquals(out.toByteArray(),
-        sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
+    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
 
     // SPDY/3 does not send debug data, so bytes should be same!
-    assertArrayEquals(out.toByteArray(), sendGoAway(expectedStreamId, expectedError, new byte[8]));
+    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, new byte[8]));
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Spdy3.Reader(frame, false);
 
     fr.nextFrame(new BaseTestHandler() { // Consume the goAway frame.
       @Override public void goAway(
@@ -88,28 +83,19 @@
     });
   }
 
-  private Spdy3.Reader newReader(ByteArrayOutputStream out) {
-    OkBuffer data = new OkBuffer().write(out.toByteArray());
-    return new Spdy3.Reader(data, false);
-  }
-
-  private byte[] sendDataFrame(OkBuffer source) throws IOException {
-    OkBuffer out = new OkBuffer();
-    Spdy3.Writer writer = new Spdy3.Writer(out, true);
+  private void sendDataFrame(OkBuffer source) throws IOException {
+    Spdy3.Writer writer = new Spdy3.Writer(new OkBuffer(), true);
     writer.sendDataFrame(expectedStreamId, 0, source, (int) source.byteCount());
-    return out.readByteString((int) out.byteCount()).toByteArray();
   }
 
-  private byte[] windowUpdate(long increment) throws IOException {
-    OkBuffer out = new OkBuffer();
-    new Spdy3.Writer(out, true).windowUpdate(expectedStreamId, increment);
-    return out.readByteString((int) out.byteCount()).toByteArray();
+  private void windowUpdate(long increment) throws IOException {
+    new Spdy3.Writer(new OkBuffer(), true).windowUpdate(expectedStreamId, increment);
   }
 
-  private byte[] sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+  private OkBuffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
       throws IOException {
     OkBuffer out = new OkBuffer();
     new Spdy3.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
-    return out.readByteString((int) out.byteCount()).toByteArray();
+    return out;
   }
 }
/Fim/
/Fim/
/Fim/
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
index 3103513..1c0cd7b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
@@ -145,7 +145,7 @@
     }
 
     while (true) {
-      String statusLineString = readLine();
+      String statusLineString = source.readUtf8Line(true);
       StatusLine statusLine = new StatusLine(statusLineString);
 
       Response.Builder responseBuilder = new Response.Builder()
@@ -166,28 +166,11 @@
   /** Reads headers or trailers into {@code builder}. */
   public void readHeaders(Headers.Builder builder) throws IOException {
     // parse the result headers until the first blank line
-    for (String line; (line = readLine()).length() != 0; ) {
+    for (String line; (line = source.readUtf8Line(true)).length() != 0; ) {
       builder.addLine(line);
     }
   }
 
-  private String readLine() throws IOException {
-    long newline = source.seek((byte) '\n');
-
-    if (newline > 0 && source.buffer().getByte(newline - 1) == '\r') {
-      // Read everything until '\r\n', then skip the '\r\n'.
-      String result = source.readUtf8((int) (newline - 1));
-      source.skip(2);
-      return result;
-
-    } else {
-      // Read everything until '\n', then skip the '\n'.
-      String result = source.readUtf8((int) (newline));
-      source.skip(1);
-      return result;
-    }
-  }
-
   /**
    * Discards the response body so that the connection can be reused and the
    * cache entry can be completed. This needs to be done judiciously, since it
@@ -530,9 +513,9 @@
     private void readChunkSize() throws IOException {
       // read the suffix of the previous chunk
       if (bytesRemainingInChunk != NO_CHUNK_YET) {
-        readLine();
+        source.readUtf8Line(true);
       }
-      String chunkSizeString = readLine();
+      String chunkSizeString = source.readUtf8Line(true);
       int index = chunkSizeString.indexOf(";");
       if (index != -1) {
         chunkSizeString = chunkSizeString.substring(0, index);
/Fim/
diff --git a/okio/src/main/java/okio/BufferedSource.java b/okio/src/main/java/okio/BufferedSource.java
index cce5e3f..daacd42 100644
--- a/okio/src/main/java/okio/BufferedSource.java
+++ b/okio/src/main/java/okio/BufferedSource.java
@@ -40,14 +40,19 @@
    */
   void require(long byteCount) throws IOException;
 
+  /** Removes a byte from the front of this buffer and returns it. */
   byte readByte() throws IOException;
 
+  /** Removes a Big-Endian short from the front of this buffer and returns it. */
   short readShort() throws IOException;
 
+  /** Removes a Little-Endian short from the front of this buffer and returns it. */
   int readShortLe() throws IOException;
 
+  /** Removes a Big-Endian int from the front of this buffer and returns it. */
   int readInt() throws IOException;
 
+  /** Removes a Little-Endian int from the front of this buffer and returns it. */
   int readIntLe() throws IOException;
 
   /**
@@ -57,11 +62,35 @@
    */
   void skip(long byteCount) throws IOException;
 
+  /** Removes {@code byteCount} bytes from this and returns them as a byte string. */
   ByteString readByteString(int byteCount) throws IOException;
 
+  /**
+   * Removes {@code byteCount} bytes from this, decodes them as UTF-8 and
+   * returns the string.
+   */
   String readUtf8(int byteCount) throws IOException;
 
   /**
+   * Removes and returns characters up to but not including the next line break.
+   * A line break is either {@code "\n"} or {@code "\r\n"}; these characters are
+   * not included in the result.
+   *
+   * <p>This method supports two ways to handle the end of the stream:
+   * <ul>
+   *   <li><strong>Throw on EOF.</strong> Every call must consume either '\r\n'
+   *       or '\n'. If these characters are absent in the stream, an {@link
+   *       java.io.EOFException} is thrown. Use this for machine-generated data
+   *       where a missing line break implies truncated input.
+   *   <li><strong>Don't throw, just like BufferedReader.</strong> If the source
+   *       doesn't end with a line break then an implicit line break is assumed.
+   *       Null is returned once the source is exhausted. Use this for
+   *       human-generated data, where a trailing line breaks are optional.
+   * </ul>
+   */
+  String readUtf8Line(boolean throwOnEof) throws IOException;
+
+  /**
    * Returns the index of {@code b} in the buffer, refilling it if necessary
    * until it is found. This reads an unbounded number of bytes into the buffer.
    *
/Fim/
diff --git a/okio/src/main/java/okio/OkBuffer.java b/okio/src/main/java/okio/OkBuffer.java
index 10f3ea8..cc9d9ab 100644
--- a/okio/src/main/java/okio/OkBuffer.java
+++ b/okio/src/main/java/okio/OkBuffer.java
@@ -139,7 +139,6 @@
     return result;
   }
 
-  /** Removes a byte from the front of this buffer and returns it. */
   @Override public byte readByte() {
     if (byteCount == 0) throw new IllegalStateException("byteCount == 0");
 
@@ -171,7 +170,6 @@
     }
   }
 
-  /** Removes a Big-Endian short from the front of this buffer and returns it. */
   @Override public short readShort() {
     if (byteCount < 2) throw new IllegalArgumentException("byteCount < 2: " + byteCount);
 
@@ -201,7 +199,6 @@
     return (short) s;
   }
 
-  /** Removes a Big-Endian int from the front of this buffer and returns it. */
   @Override public int readInt() {
     if (byteCount < 4) throw new IllegalArgumentException("byteCount < 4: " + byteCount);
 
@@ -234,22 +231,18 @@
     return i;
   }
 
-  /** Removes a Little-Endian short from the front of this buffer and returns it. */
   public int readShortLe() {
     return Util.reverseBytesShort(readShort());
   }
 
-  /** Removes a Little-Endian int from the front of this buffer and returns it. */
   public int readIntLe() {
     return Util.reverseBytesInt(readInt());
   }
 
-  /** Removes {@code byteCount} bytes from this and returns them as a byte string. */
   public ByteString readByteString(int byteCount) {
     return new ByteString(readBytes(byteCount));
   }
 
-  /** Removes {@code byteCount} bytes from this, decodes them as UTF-8 and returns the string. */
   public String readUtf8(int byteCount) {
     checkOffsetAndCount(this.byteCount, 0, byteCount);
     if (byteCount == 0) return "";
@@ -272,6 +265,28 @@
     return result;
   }
 
+  @Override public String readUtf8Line(boolean throwOnEof) throws EOFException {
+    long newline = indexOf((byte) '\n');
+
+    if (newline == -1) {
+      if (throwOnEof) throw new EOFException();
+      return byteCount != 0 ? readUtf8((int) byteCount) : null;
+    }
+
+    if (newline > 0 && getByte(newline - 1) == '\r') {
+      // Read everything until '\r\n', then skip the '\r\n'.
+      String result = readUtf8((int) (newline - 1));
+      skip(2);
+      return result;
+
+    } else {
+      // Read everything until '\n', then skip the '\n'.
+      String result = readUtf8((int) (newline));
+      skip(1);
+      return result;
+    }
+  }
+
   private byte[] readBytes(int byteCount) {
     checkOffsetAndCount(this.byteCount, 0, byteCount);
 
/Fim/
diff --git a/okio/src/main/java/okio/RealBufferedSource.java b/okio/src/main/java/okio/RealBufferedSource.java
index f4f4ae6..16200ce 100644
--- a/okio/src/main/java/okio/RealBufferedSource.java
+++ b/okio/src/main/java/okio/RealBufferedSource.java
@@ -79,6 +79,31 @@
     return buffer.readUtf8(byteCount);
   }
 
+  @Override public String readUtf8Line(boolean throwOnEof) throws IOException {
+    long start = 0;
+    long newline;
+    while ((newline = buffer.indexOf((byte) '\n', start)) == -1) {
+      start = buffer.byteCount;
+      if (source.read(buffer, Segment.SIZE) == -1) {
+        if (throwOnEof) throw new EOFException();
+        return buffer.byteCount != 0 ? readUtf8((int) buffer.byteCount) : null;
+      }
+    }
+
+    if (newline > 0 && buffer.getByte(newline - 1) == '\r') {
+      // Read everything until '\r\n', then skip the '\r\n'.
+      String result = readUtf8((int) (newline - 1));
+      skip(2);
+      return result;
+
+    } else {
+      // Read everything until '\n', then skip the '\n'.
+      String result = readUtf8((int) (newline));
+      skip(1);
+      return result;
+    }
+  }
+
   @Override public short readShort() throws IOException {
     require(2);
     return buffer.readShort();
/Fim/
diff --git a/okio/src/test/java/okio/OkBufferReadUtf8LineTest.java b/okio/src/test/java/okio/OkBufferReadUtf8LineTest.java
new file mode 100644
index 0000000..ac3de72
--- /dev/null
+++ b/okio/src/test/java/okio/OkBufferReadUtf8LineTest.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+public final class OkBufferReadUtf8LineTest extends ReadUtf8LineTest {
+  @Override protected BufferedSource newSource(String s) {
+    return new OkBuffer().writeUtf8(s);
+  }
+}
/Fim/
diff --git a/okio/src/test/java/okio/ReadUtf8LineTest.java b/okio/src/test/java/okio/ReadUtf8LineTest.java
new file mode 100644
index 0000000..db36a79
--- /dev/null
+++ b/okio/src/test/java/okio/ReadUtf8LineTest.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.EOFException;
+import java.io.IOException;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public abstract class ReadUtf8LineTest {
+  protected abstract BufferedSource newSource(String s);
+
+  @Test public void readLines() throws IOException {
+    BufferedSource source = newSource("abc\ndef\n");
+    assertEquals("abc", source.readUtf8Line(true));
+    assertEquals("def", source.readUtf8Line(true));
+    try {
+      source.readUtf8Line(true);
+      fail();
+    } catch (EOFException expected) {
+    }
+  }
+
+  @Test public void emptyLines() throws IOException {
+    BufferedSource source = newSource("\n\n\n");
+    assertEquals("", source.readUtf8Line(true));
+    assertEquals("", source.readUtf8Line(true));
+    assertEquals("", source.readUtf8Line(true));
+    assertTrue(source.exhausted());
+  }
+
+  @Test public void crDroppedPrecedingLf() throws IOException {
+    BufferedSource source = newSource("abc\r\ndef\r\nghi\rjkl\r\n");
+    assertEquals("abc", source.readUtf8Line(true));
+    assertEquals("def", source.readUtf8Line(true));
+    assertEquals("ghi\rjkl", source.readUtf8Line(true));
+  }
+
+  @Test public void bufferedReaderCompatible() throws IOException {
+    BufferedSource source = newSource("abc\ndef");
+    assertEquals("abc", source.readUtf8Line(false));
+    assertEquals("def", source.readUtf8Line(false));
+    assertEquals(null, source.readUtf8Line(false));
+  }
+
+  @Test public void bufferedReaderCompatibleWithTrailingNewline() throws IOException {
+    BufferedSource source = newSource("abc\ndef\n");
+    assertEquals("abc", source.readUtf8Line(false));
+    assertEquals("def", source.readUtf8Line(false));
+    assertEquals(null, source.readUtf8Line(false));
+  }
+}
/Fim/
diff --git a/okio/src/test/java/okio/RealBufferedSourceReadUtf8LineTest.java b/okio/src/test/java/okio/RealBufferedSourceReadUtf8LineTest.java
new file mode 100644
index 0000000..8793640
--- /dev/null
+++ b/okio/src/test/java/okio/RealBufferedSourceReadUtf8LineTest.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.IOException;
+
+public final class RealBufferedSourceReadUtf8LineTest extends ReadUtf8LineTest {
+  /** Returns a buffered source that gets bytes of {@code data} one at a time. */
+  @Override protected BufferedSource newSource(String s) {
+    final OkBuffer buffer = new OkBuffer().writeUtf8(s);
+
+    Source slowSource = new Source() {
+      @Override public long read(OkBuffer sink, long byteCount) throws IOException {
+        return buffer.read(sink, Math.min(1, byteCount));
+      }
+
+      @Override public Source deadline(Deadline deadline) {
+        throw new UnsupportedOperationException();
+      }
+
+      @Override public void close() throws IOException {
+        throw new UnsupportedOperationException();
+      }
+    };
+
+    return Okio.buffer(slowSource);
+  }
+}
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
index beb4adb..7d8e066 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
@@ -46,6 +46,8 @@
 
   private int bodyDelayTimeMs = 0;
 
+  private List<PushPromise> promises = new ArrayList<PushPromise>();
+
   /** Creates a new mock response with an empty body. */
   public MockResponse() {
     setBody(new byte[0]);
@@ -54,7 +56,8 @@
   @Override public MockResponse clone() {
     try {
       MockResponse result = (MockResponse) super.clone();
-      result.headers = new ArrayList<String>(result.headers);
+      result.headers = new ArrayList<String>(headers);
+      result.promises = new ArrayList<PushPromise>(promises);
       return result;
     } catch (CloneNotSupportedException e) {
       throw new AssertionError();
@@ -247,6 +250,20 @@
     return bodyDelayTimeMs;
   }
 
+  /**
+   * When {@link MockWebServer#setNpnProtocols(java.util.List) protocols}
+   * include a SPDY variant, this attaches a pushed stream to this response.
+   */
+  public MockResponse withPush(PushPromise promise) {
+    this.promises.add(promise);
+    return this;
+  }
+
+  /** Returns the streams the server will push with this response. */
+  public List<PushPromise> getPushPromises() {
+    return promises;
+  }
+
   @Override public String toString() {
     return status;
   }
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 62a0675..f90b212 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -21,6 +21,7 @@
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.spdy.ErrorCode;
 import com.squareup.okhttp.internal.spdy.Header;
 import com.squareup.okhttp.internal.spdy.IncomingStreamHandler;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
@@ -695,7 +696,9 @@
         spdyHeaders.add(new Header(headerParts[0], headerParts[1]));
       }
       byte[] body = response.getBody();
-      stream.reply(spdyHeaders, body.length > 0);
+      boolean closeStreamAfterHeaders = body.length > 0 || !response.getPushPromises().isEmpty();
+      stream.reply(spdyHeaders, closeStreamAfterHeaders);
+      pushPromises(stream, response.getPushPromises());
       if (body.length > 0) {
         if (response.getBodyDelayTimeMs() != 0) {
           try {
@@ -707,6 +710,35 @@
         BufferedSink sink = Okio.buffer(stream.getSink());
         sink.write(body);
         sink.close();
+      } else if (closeStreamAfterHeaders) {
+        stream.close(ErrorCode.NO_ERROR);
+      }
+    }
+
+    private void pushPromises(SpdyStream stream, List<PushPromise> promises) throws IOException {
+      for (PushPromise pushPromise : promises) {
+        List<Header> pushedHeaders = new ArrayList<Header>();
+        pushedHeaders.add(new Header(stream.getConnection().getProtocol() == Protocol.SPDY_3
+            ? Header.TARGET_HOST
+            : Header.TARGET_AUTHORITY, getUrl(pushPromise.getPath()).getHost()));
+        pushedHeaders.add(new Header(Header.TARGET_METHOD, pushPromise.getMethod()));
+        pushedHeaders.add(new Header(Header.TARGET_PATH, pushPromise.getPath()));
+        for (int i = 0, size = pushPromise.getHeaders().size(); i < size; i++) {
+          String header = pushPromise.getHeaders().get(i);
+          String[] headerParts = header.split(":", 2);
+          if (headerParts.length != 2) {
+            throw new AssertionError("Unexpected header: " + header);
+          }
+          pushedHeaders.add(new Header(headerParts[0], headerParts[1]));
+        }
+        String requestLine = pushPromise.getMethod() + ' ' + pushPromise.getPath() + " HTTP/1.1";
+        List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
+        requestQueue.add(new RecordedRequest(requestLine, pushPromise.getHeaders(), chunkSizes, 0,
+            Util.EMPTY_BYTE_ARRAY, sequenceNumber.getAndIncrement(), socket));
+        byte[] pushedBody = pushPromise.getResponse().getBody();
+        SpdyStream pushedStream =
+            stream.getConnection().pushStream(stream.getId(), pushedHeaders, pushedBody.length > 0);
+        writeResponse(pushedStream, pushPromise.getResponse());
       }
     }
   }
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java
new file mode 100644
index 0000000..d9dd019
--- /dev/null
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.mockwebserver;
+
+import java.util.List;
+
+/** An HTTP request initiated by the server. */
+public final class PushPromise {
+  private final String method;
+  private final String path;
+  private final List<String> headers;
+  private final MockResponse response;
+
+  public PushPromise(String method, String path, List<String> headers, MockResponse response) {
+    this.method = method;
+    this.path = path;
+    this.headers = headers;
+    this.response = response;
+  }
+
+  public String getMethod() {
+    return method;
+  }
+
+  public String getPath() {
+    return path;
+  }
+
+  public List<String> getHeaders() {
+    return headers;
+  }
+
+  public MockResponse getResponse() {
+    return response;
+  }
+}
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index 9f31c72..7a41b90 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -198,18 +198,37 @@
   }
 
   /**
-   * Returns a new locally-initiated stream.
+   * Returns a new server-initiated stream.
    *
+   * @param associatedStreamId the stream that triggered the sender to create
+   *     this stream.
    * @param out true to create an output stream that we can use to send data
    *     to the remote peer. Corresponds to {@code FLAG_FIN}.
-   * @param in true to create an input stream that the remote peer can use to
-   *     send data to us. Corresponds to {@code FLAG_UNIDIRECTIONAL}.
    */
-  public SpdyStream newStream(List<Header> requestHeaders, boolean out, boolean in)
+  public SpdyStream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
+      throws IOException {
+    if (client) throw new IllegalStateException("Client cannot push requests.");
+    return newStream(associatedStreamId, requestHeaders, out, false);
+  }
+
+  /**
+   * Returns a new locally-initiated stream.
+   *
+   * @param out true to create an output stream that we can use to send data to the remote peer.
+   *     Corresponds to {@code FLAG_FIN}.
+   * @param in true to create an input stream that the remote peer can use to send data to us.
+   *     Corresponds to {@code FLAG_UNIDIRECTIONAL}.
+   */
+  public SpdyStream newStream(List<Header> requestHeaders, boolean out,
+      boolean in) throws IOException {
+    return newStream(0, requestHeaders, out, in);
+  }
+
+  private SpdyStream newStream(int associatedStreamId, List<Header> requestHeaders, boolean out,
+      boolean in)
       throws IOException {
     boolean outFinished = !out;
     boolean inFinished = !in;
-    int associatedStreamId = 0;  // TODO: permit the caller to specify an associated stream?
     int priority = -1; // TODO: permit the caller to specify a priority?
     int slot = 0; // TODO: permit the caller to specify a slot?
     SpdyStream stream;
@@ -228,9 +247,12 @@
           setIdle(false);
         }
       }
-
-      frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId, priority, slot,
-          requestHeaders);
+      if (associatedStreamId == 0) {
+        frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId, priority, slot,
+            requestHeaders);
+      } else {
+        frameWriter.pushPromise(associatedStreamId, streamId, requestHeaders);
+      }
     }
 
     if (!out) {
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index 73e1e08..8fa08ba 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -85,6 +85,10 @@
     this.requestHeaders = requestHeaders;
   }
 
+  public int getId() {
+    return id;
+  }
+
   /**
    * Returns true if this stream is open. A stream is open until either:
    * <ul>
@@ -176,9 +180,6 @@
       if (responseHeaders == null) {
         throw new NullPointerException("responseHeaders == null");
       }
-      if (isLocallyInitiated()) {
-        throw new IllegalStateException("cannot reply to a locally initiated stream");
-      }
       if (this.responseHeaders != null) {
         throw new IllegalStateException("reply already sent");
       }
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
index c1f4d3c..851a9c1 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
@@ -16,6 +16,13 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.PushPromise;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.util.Arrays;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
 
 public class HttpOverHttp20Draft09Test extends HttpOverSpdyTest {
 
@@ -23,4 +30,48 @@
     super(Protocol.HTTP_2);
     this.hostHeader = ":authority";
   }
+
+  @Test public void serverSendsPushPromise_GET() throws Exception {
+    MockResponse response = new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet")
+        .withPush(new PushPromise("GET", "/foo/bar", Arrays.asList("foo: bar"),
+            new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet")));
+    server.enqueue(response);
+    server.play();
+
+    connection = client.open(server.getUrl("/foo"));
+    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("Sweet", connection.getResponseMessage());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertContains(request.getHeaders(), ":scheme: https");
+    assertContains(request.getHeaders(), hostHeader + ": " + hostName + ":" + server.getPort());
+
+    RecordedRequest pushedRequest = server.takeRequest();
+    assertEquals("GET /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
+    assertEquals(Arrays.asList("foo: bar"), pushedRequest.getHeaders());
+  }
+
+  @Test public void serverSendsPushPromise_HEAD() throws Exception {
+    MockResponse response = new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet")
+        .withPush(new PushPromise("HEAD", "/foo/bar", Arrays.asList("foo: bar"),
+            new MockResponse().setStatus("HTTP/1.1 204 Sweet")));
+    server.enqueue(response);
+    server.play();
+
+    connection = client.open(server.getUrl("/foo"));
+    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("Sweet", connection.getResponseMessage());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertContains(request.getHeaders(), ":scheme: https");
+    assertContains(request.getHeaders(), hostHeader + ": " + hostName + ":" + server.getPort());
+
+    RecordedRequest pushedRequest = server.takeRequest();
+    assertEquals("HEAD /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
+    assertEquals(Arrays.asList("foo: bar"), pushedRequest.getHeaders());
+  }
 }
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index 18d4f75..3ae7c4e 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -76,11 +76,11 @@
   };
 
   private static final SSLContext sslContext = SslContextBuilder.localhost();
-  private final MockWebServer server = new MockWebServer();
-  private final String hostName = server.getHostName();
-  private final OkHttpClient client = new OkHttpClient();
-  private HttpURLConnection connection;
-  private HttpResponseCache cache;
+  protected final MockWebServer server = new MockWebServer();
+  protected final String hostName = server.getHostName();
+  protected final OkHttpClient client = new OkHttpClient();
+  protected HttpURLConnection connection;
+  protected HttpResponseCache cache;
 
   @Before public void setUp() throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false);
@@ -374,11 +374,11 @@
     assertContains(requestB.getHeaders(), "cookie: c=oreo");
   }
 
-  private <T> void assertContains(Collection<T> collection, T value) {
+  <T> void assertContains(Collection<T> collection, T value) {
     assertTrue(collection.toString(), collection.contains(value));
   }
 
-  private void assertContent(String expected, HttpURLConnection connection, int limit)
+  void assertContent(String expected, HttpURLConnection connection, int limit)
       throws IOException {
     connection.connect();
     assertEquals(expected, readAscii(connection.getInputStream(), limit));
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java b/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
index 0ca554c..8556e19 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
@@ -17,7 +17,6 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.DiskLruCache;
-import com.squareup.okhttp.internal.StrictLineReader;
 import com.squareup.okhttp.internal.Util;
 import java.io.BufferedWriter;
 import java.io.ByteArrayInputStream;
@@ -42,9 +41,10 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import okio.BufferedSource;
 import okio.ByteString;
+import okio.Okio;
 
-import static com.squareup.okhttp.internal.Util.US_ASCII;
 import static com.squareup.okhttp.internal.Util.UTF_8;
 
 /**
@@ -412,32 +412,32 @@
      */
     public Entry(InputStream in) throws IOException {
       try {
-        StrictLineReader reader = new StrictLineReader(in, US_ASCII);
-        url = reader.readLine();
-        requestMethod = reader.readLine();
+        BufferedSource source = Okio.buffer(Okio.source(in));
+        url = source.readUtf8Line(true);
+        requestMethod = source.readUtf8Line(true);
         Headers.Builder varyHeadersBuilder = new Headers.Builder();
-        int varyRequestHeaderLineCount = reader.readInt();
+        int varyRequestHeaderLineCount = readInt(source);
         for (int i = 0; i < varyRequestHeaderLineCount; i++) {
-          varyHeadersBuilder.addLine(reader.readLine());
+          varyHeadersBuilder.addLine(source.readUtf8Line(true));
         }
         varyHeaders = varyHeadersBuilder.build();
 
-        statusLine = reader.readLine();
+        statusLine = source.readUtf8Line(true);
         Headers.Builder responseHeadersBuilder = new Headers.Builder();
-        int responseHeaderLineCount = reader.readInt();
+        int responseHeaderLineCount = readInt(source);
         for (int i = 0; i < responseHeaderLineCount; i++) {
-          responseHeadersBuilder.addLine(reader.readLine());
+          responseHeadersBuilder.addLine(source.readUtf8Line(true));
         }
         responseHeaders = responseHeadersBuilder.build();
 
         if (isHttps()) {
-          String blank = reader.readLine();
+          String blank = source.readUtf8Line(true);
           if (blank.length() > 0) {
             throw new IOException("expected \"\" but was \"" + blank + "\"");
           }
-          String cipherSuite = reader.readLine();
-          List<Certificate> peerCertificates = readCertificateList(reader);
-          List<Certificate> localCertificates = readCertificateList(reader);
+          String cipherSuite = source.readUtf8Line(true);
+          List<Certificate> peerCertificates = readCertificateList(source);
+          List<Certificate> localCertificates = readCertificateList(source);
           handshake = Handshake.get(cipherSuite, peerCertificates, localCertificates);
         } else {
           handshake = null;
@@ -486,15 +486,15 @@
       return url.startsWith("https://");
     }
 
-    private List<Certificate> readCertificateList(StrictLineReader reader) throws IOException {
-      int length = reader.readInt();
+    private List<Certificate> readCertificateList(BufferedSource source) throws IOException {
+      int length = readInt(source);
       if (length == -1) return Collections.emptyList(); // OkHttp v1.2 used -1 to indicate null.
 
       try {
         CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
         List<Certificate> result = new ArrayList<Certificate>(length);
         for (int i = 0; i < length; i++) {
-          String line = reader.readLine();
+          String line = source.readUtf8Line(true);
           byte[] bytes = ByteString.decodeBase64(line).toByteArray();
           result.add(certificateFactory.generateCertificate(new ByteArrayInputStream(bytes)));
         }
@@ -536,6 +536,15 @@
     }
   }
 
+  private static int readInt(BufferedSource source) throws IOException {
+    String line = source.readUtf8Line(true);
+    try {
+      return Integer.parseInt(line);
+    } catch (NumberFormatException e) {
+      throw new IOException("Expected an integer but was \"" + line + "\"");
+    }
+  }
+
   private static class CacheResponseBody extends Response.Body {
     private final DiskLruCache.Snapshot snapshot;
     private final InputStream bodyIn;
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
index 1dbaa88..72ad168 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
@@ -38,6 +38,8 @@
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import okio.BufferedSource;
+import okio.Okio;
 
 /**
  * A cache that uses a bounded amount of space on a filesystem. Each cache
@@ -242,13 +244,13 @@
   }
 
   private void readJournal() throws IOException {
-    StrictLineReader reader = new StrictLineReader(new FileInputStream(journalFile), Util.US_ASCII);
+    BufferedSource source = Okio.buffer(Okio.source(new FileInputStream(journalFile)));
     try {
-      String magic = reader.readLine();
-      String version = reader.readLine();
-      String appVersionString = reader.readLine();
-      String valueCountString = reader.readLine();
-      String blank = reader.readLine();
+      String magic = source.readUtf8Line(true);
+      String version = source.readUtf8Line(true);
+      String appVersionString = source.readUtf8Line(true);
+      String valueCountString = source.readUtf8Line(true);
+      String blank = source.readUtf8Line(true);
       if (!MAGIC.equals(magic)
           || !VERSION_1.equals(version)
           || !Integer.toString(appVersion).equals(appVersionString)
@@ -261,7 +263,7 @@
       int lineCount = 0;
       while (true) {
         try {
-          readJournalLine(reader.readLine());
+          readJournalLine(source.readUtf8Line(true));
           lineCount++;
         } catch (EOFException endOfJournal) {
           break;
@@ -269,7 +271,7 @@
       }
       redundantOpCount = lineCount - lruEntries.size();
     } finally {
-      Util.closeQuietly(reader);
+      Util.closeQuietly(source);
     }
   }
 
/Fim/
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index b75ccdf..173b9ed 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -76,6 +76,7 @@
 import org.junit.Ignore;
 import org.junit.Test;
 
+import static com.squareup.okhttp.internal.Util.UTF_8;
 import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
@@ -2675,6 +2676,29 @@
     assertEquals(1, requestB.getSequenceNumber());
   }
 
+  /**
+   * We had a bug where we weren't closing Gzip streams on redirects.
+   * https://github.com/square/okhttp/issues/441
+   */
+  @Test public void gzipWithRedirectAndConnectionReuse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo")
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("Moved! Moved! Moved!".getBytes(UTF_8))));
+    server.enqueue(new MockResponse().setBody("This is the new page!"));
+    server.play();
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertContent("This is the new page!", connection);
+
+    RecordedRequest requestA = server.takeRequest();
+    assertEquals(0, requestA.getSequenceNumber());
+
+    RecordedRequest requestB = server.takeRequest();
+    assertEquals(1, requestB.getSequenceNumber());
+  }
+
   /** Returns a gzipped copy of {@code bytes}. */
   public byte[] gzip(byte[] bytes) throws IOException {
     ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
/Fim/
diff --git a/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java b/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
index e3ea98a..5062587 100644
--- a/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
+++ b/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
@@ -87,7 +87,7 @@
     try {
       OkBuffer buffer = new OkBuffer();
       body.writeTo(buffer);
-      return new String(buffer.readByteString((int) buffer.byteCount()).toByteArray(),
+      return new String(buffer.readByteString((int) buffer.size()).toByteArray(),
           body.contentType().charset());
     } catch (IOException e) {
       throw new RuntimeException(e);
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index 85e9622..8f43890 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -347,24 +347,24 @@
     @Override public synchronized void pushPromise(int streamId, int promisedStreamId,
         List<Header> requestHeaders) throws IOException {
       if (closed) throw new IOException("closed");
-      if (hpackBuffer.byteCount() != 0) throw new IllegalStateException();
+      if (hpackBuffer.size() != 0) throw new IllegalStateException();
       hpackWriter.writeHeaders(requestHeaders);
 
-      int length = (int) (4 + hpackBuffer.byteCount());
+      int length = (int) (4 + hpackBuffer.size());
       byte type = TYPE_PUSH_PROMISE;
       byte flags = FLAG_END_HEADERS;
       frameHeader(length, type, flags, streamId); // TODO: CONTINUATION
       sink.writeInt(promisedStreamId & 0x7fffffff);
-      sink.write(hpackBuffer, hpackBuffer.byteCount());
+      sink.write(hpackBuffer, hpackBuffer.size());
     }
 
     private void headers(boolean outFinished, int streamId, int priority,
         List<Header> headerBlock) throws IOException {
       if (closed) throw new IOException("closed");
-      if (hpackBuffer.byteCount() != 0) throw new IllegalStateException();
+      if (hpackBuffer.size() != 0) throw new IllegalStateException();
       hpackWriter.writeHeaders(headerBlock);
 
-      int length = (int) hpackBuffer.byteCount();
+      int length = (int) hpackBuffer.size();
       byte type = TYPE_HEADERS;
       byte flags = FLAG_END_HEADERS;
       if (outFinished) flags |= FLAG_END_STREAM;
@@ -372,7 +372,7 @@
       if (priority != -1) length += 4;
       frameHeader(length, type, flags, streamId); // TODO: CONTINUATION
       if (priority != -1) sink.writeInt(priority & 0x7fffffff);
-      sink.write(hpackBuffer, hpackBuffer.byteCount());
+      sink.write(hpackBuffer, hpackBuffer.size());
     }
 
     @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
@@ -390,7 +390,7 @@
 
     @Override public synchronized void data(boolean outFinished, int streamId, OkBuffer source)
         throws IOException {
-      data(outFinished, streamId, source, (int) source.byteCount());
+      data(outFinished, streamId, source, (int) source.size());
     }
 
     @Override public synchronized void data(boolean outFinished, int streamId, OkBuffer source,
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index 632c3b1..799efae 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -331,7 +331,7 @@
         throws IOException {
       if (closed) throw new IOException("closed");
       writeNameValueBlockToBuffer(headerBlock);
-      int length = (int) (10 + headerBlockBuffer.byteCount());
+      int length = (int) (10 + headerBlockBuffer.size());
       int type = TYPE_SYN_STREAM;
       int flags = (outFinished ? FLAG_FIN : 0) | (inFinished ? FLAG_UNIDIRECTIONAL : 0);
 
@@ -341,7 +341,7 @@
       sink.writeInt(streamId & 0x7fffffff);
       sink.writeInt(associatedStreamId & 0x7fffffff);
       sink.writeShort((priority & 0x7) << 13 | (unused & 0x1f) << 8 | (slot & 0xff));
-      sink.write(headerBlockBuffer, headerBlockBuffer.byteCount());
+      sink.write(headerBlockBuffer, headerBlockBuffer.size());
       sink.flush();
     }
 
@@ -351,12 +351,12 @@
       writeNameValueBlockToBuffer(headerBlock);
       int type = TYPE_SYN_REPLY;
       int flags = (outFinished ? FLAG_FIN : 0);
-      int length = (int) (headerBlockBuffer.byteCount() + 4);
+      int length = (int) (headerBlockBuffer.size() + 4);
 
       sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
       sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
       sink.writeInt(streamId & 0x7fffffff);
-      sink.write(headerBlockBuffer, headerBlockBuffer.byteCount());
+      sink.write(headerBlockBuffer, headerBlockBuffer.size());
       sink.flush();
     }
 
@@ -366,12 +366,12 @@
       writeNameValueBlockToBuffer(headerBlock);
       int flags = 0;
       int type = TYPE_HEADERS;
-      int length = (int) (headerBlockBuffer.byteCount() + 4);
+      int length = (int) (headerBlockBuffer.size() + 4);
 
       sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
       sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
       sink.writeInt(streamId & 0x7fffffff);
-      sink.write(headerBlockBuffer, headerBlockBuffer.byteCount());
+      sink.write(headerBlockBuffer, headerBlockBuffer.size());
     }
 
     @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
@@ -390,7 +390,7 @@
 
     @Override public synchronized void data(boolean outFinished, int streamId, OkBuffer source)
         throws IOException {
-      data(outFinished, streamId, source, (int) source.byteCount());
+      data(outFinished, streamId, source, (int) source.size());
     }
 
     @Override public synchronized void data(boolean outFinished, int streamId, OkBuffer source,
@@ -411,7 +411,7 @@
     }
 
     private void writeNameValueBlockToBuffer(List<Header> headerBlock) throws IOException {
-      if (headerBlockBuffer.byteCount() != 0) throw new IllegalStateException();
+      if (headerBlockBuffer.size() != 0) throw new IllegalStateException();
       headerBlockOut.writeInt(headerBlock.size());
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
         ByteString name = headerBlock.get(i).name;
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index 8fa08ba..f5e3200 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -363,10 +363,10 @@
       synchronized (SpdyStream.this) {
         waitUntilReadable();
         checkNotClosed();
-        if (readBuffer.byteCount() == 0) return -1; // This source is exhausted.
+        if (readBuffer.size() == 0) return -1; // This source is exhausted.
 
         // Move bytes from the read buffer into the caller's buffer.
-        read = readBuffer.read(sink, Math.min(byteCount, readBuffer.byteCount()));
+        read = readBuffer.read(sink, Math.min(byteCount, readBuffer.size()));
 
         // Flow control: notify the peer that we're ready for more data!
         unacknowledgedBytesRead += read;
@@ -402,7 +402,7 @@
         remaining = readTimeoutMillis;
       }
       try {
-        while (readBuffer.byteCount() == 0 && !finished && !closed && errorCode == null) {
+        while (readBuffer.size() == 0 && !finished && !closed && errorCode == null) {
           if (readTimeoutMillis == 0) {
             SpdyStream.this.wait();
           } else if (remaining > 0) {
@@ -425,7 +425,7 @@
         boolean flowControlError;
         synchronized (SpdyStream.this) {
           finished = this.finished;
-          flowControlError = byteCount + readBuffer.byteCount() > maxByteCount;
+          flowControlError = byteCount + readBuffer.size() > maxByteCount;
         }
 
         // If the peer sends more data than we can handle, discard it and close the connection.
@@ -448,8 +448,8 @@
 
         // Move the received data to the read buffer to the reader can read it.
         synchronized (SpdyStream.this) {
-          boolean wasEmpty = readBuffer.byteCount() == 0;
-          readBuffer.write(receiveBuffer, receiveBuffer.byteCount());
+          boolean wasEmpty = readBuffer.size() == 0;
+          readBuffer.write(receiveBuffer, receiveBuffer.size());
           if (wasEmpty) {
             SpdyStream.this.notifyAll();
           }
@@ -529,7 +529,7 @@
       synchronized (SpdyStream.this) {
         checkOutNotClosed();
       }
-      writeFrame(false, buffer.byteCount());
+      writeFrame(false, buffer.size());
       connection.flush();
     }
 
@@ -544,7 +544,7 @@
         if (closed) return;
       }
       if (!sink.finished) {
-        writeFrame(true, buffer.byteCount());
+        writeFrame(true, buffer.size());
       }
       synchronized (SpdyStream.this) {
         closed = true;
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index 268d855..3f6b689 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -53,7 +53,7 @@
     out.writeByte(0x0d); // Literal value (len = 13)
     out.writeUtf8("custom-header");
 
-    bytesIn.write(out, out.byteCount());
+    bytesIn.write(out, out.size());
     hpackReader.maxHeaderTableByteCount(1);
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
@@ -88,7 +88,7 @@
     out.writeByte(0x0d); // Literal value (len = 13)
     out.writeUtf8("custom-header");
 
-    bytesIn.write(out, out.byteCount());
+    bytesIn.write(out, out.size());
     // Set to only support 110 bytes (enough for 2 headers).
     hpackReader.maxHeaderTableByteCount(110);
     hpackReader.readHeaders();
@@ -127,7 +127,7 @@
       out.writeUtf8("custom-header");
     }
 
-    bytesIn.write(out, out.byteCount());
+    bytesIn.write(out, out.size());
     hpackReader.maxHeaderTableByteCount(16384); // Lots of headers need more room!
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
@@ -150,7 +150,7 @@
         (byte) 0x25, (byte) 0xba, (byte) 0x7f};
     out.write(huffmanBytes, 0, huffmanBytes.length);
 
-    bytesIn.write(out, out.byteCount());
+    bytesIn.write(out, out.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -175,7 +175,7 @@
     out.writeByte(0x0d); // Literal value (len = 13)
     out.writeUtf8("custom-header");
 
-    bytesIn.write(out, out.byteCount());
+    bytesIn.write(out, out.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -207,7 +207,7 @@
     hpackWriter.writeHeaders(headerBlock);
     assertEquals(expectedBytes, bytesOut);
 
-    bytesIn.write(bytesOut, bytesOut.byteCount());
+    bytesIn.write(bytesOut, bytesOut.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -231,7 +231,7 @@
     hpackWriter.writeHeaders(headerBlock);
     assertEquals(expectedBytes, bytesOut);
 
-    bytesIn.write(bytesOut, bytesOut.byteCount());
+    bytesIn.write(bytesOut, bytesOut.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -306,19 +306,19 @@
    */
   @Test public void readRequestExamplesWithoutHuffman() throws IOException {
     OkBuffer out = firstRequestWithoutHuffman();
-    bytesIn.write(out, out.byteCount());
+    bytesIn.write(out, out.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadFirstRequestWithoutHuffman();
 
     out = secondRequestWithoutHuffman();
-    bytesIn.write(out, out.byteCount());
+    bytesIn.write(out, out.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadSecondRequestWithoutHuffman();
 
     out = thirdRequestWithoutHuffman();
-    bytesIn.write(out, out.byteCount());
+    bytesIn.write(out, out.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadThirdRequestWithoutHuffman();
@@ -508,19 +508,19 @@
    */
   @Test public void readRequestExamplesWithHuffman() throws IOException {
     OkBuffer out = firstRequestWithHuffman();
-    bytesIn.write(out, out.byteCount());
+    bytesIn.write(out, out.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadFirstRequestWithHuffman();
 
     out = secondRequestWithHuffman();
-    bytesIn.write(out, out.byteCount());
+    bytesIn.write(out, out.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadSecondRequestWithHuffman();
 
     out = thirdRequestWithHuffman();
-    bytesIn.write(out, out.byteCount());
+    bytesIn.write(out, out.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadThirdRequestWithHuffman();
@@ -800,7 +800,7 @@
 
   private void assertBytes(int... bytes) {
     ByteString expected = intArrayToByteArray(bytes);
-    ByteString actual = bytesOut.readByteString((int) bytesOut.byteCount());
+    ByteString actual = bytesOut.readByteString((int) bytesOut.size());
     assertEquals(expected, actual);
   }
 
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index 9093661..248ea09 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -56,11 +56,11 @@
     // Write the headers frame, specifying no more frames are expected.
     {
       OkBuffer headerBytes = literalHeaders(sentHeaders);
-      frame.writeShort((int) headerBytes.byteCount());
+      frame.writeShort((int) headerBytes.size());
       frame.writeByte(Http20Draft09.TYPE_HEADERS);
       frame.writeByte(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_END_STREAM);
       frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.write(headerBytes, headerBytes.byteCount());
+      frame.write(headerBytes, headerBytes.size());
     }
 
     FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
@@ -90,12 +90,12 @@
 
     { // Write the headers frame, specifying priority flag and value.
       OkBuffer headerBytes = literalHeaders(sentHeaders);
-      frame.writeShort((int) (headerBytes.byteCount() + 4));
+      frame.writeShort((int) (headerBytes.size() + 4));
       frame.writeByte(Http20Draft09.TYPE_HEADERS);
       frame.writeByte(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_PRIORITY);
       frame.writeInt(expectedStreamId & 0x7fffffff);
       frame.writeInt(0); // Highest priority is 0.
-      frame.write(headerBytes, headerBytes.byteCount());
+      frame.write(headerBytes, headerBytes.size());
     }
 
     FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
@@ -126,19 +126,19 @@
     // Decoding the first header will cross frame boundaries.
     OkBuffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
     { // Write the first headers frame.
-      frame.writeShort((int) (headerBlock.byteCount() / 2));
+      frame.writeShort((int) (headerBlock.size() / 2));
       frame.writeByte(Http20Draft09.TYPE_HEADERS);
       frame.writeByte(0); // no flags
       frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.write(headerBlock, headerBlock.byteCount() / 2);
+      frame.write(headerBlock, headerBlock.size() / 2);
     }
 
     { // Write the continuation frame, specifying no more frames are expected.
-      frame.writeShort((int) headerBlock.byteCount());
+      frame.writeShort((int) headerBlock.size());
       frame.writeByte(Http20Draft09.TYPE_CONTINUATION);
       frame.writeByte(Http20Draft09.FLAG_END_HEADERS);
       frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.write(headerBlock, headerBlock.byteCount());
+      frame.write(headerBlock, headerBlock.size());
     }
 
     FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
@@ -175,12 +175,12 @@
 
     { // Write the push promise frame, specifying the associated stream ID.
       OkBuffer headerBytes = literalHeaders(pushPromise);
-      frame.writeShort((int) (headerBytes.byteCount() + 4));
+      frame.writeShort((int) (headerBytes.size() + 4));
       frame.writeByte(Http20Draft09.TYPE_PUSH_PROMISE);
       frame.writeByte(Http20Draft09.FLAG_END_PUSH_PROMISE);
       frame.writeInt(expectedStreamId & 0x7fffffff);
       frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
-      frame.write(headerBytes, headerBytes.byteCount());
+      frame.write(headerBytes, headerBytes.size());
     }
 
     FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
@@ -211,7 +211,7 @@
 
     // Decoding the first header will cross frame boundaries.
     OkBuffer headerBlock = literalHeaders(pushPromise);
-    int firstFrameLength = (int) (headerBlock.byteCount() - 1);
+    int firstFrameLength = (int) (headerBlock.size() - 1);
     { // Write the first headers frame.
       frame.writeShort(firstFrameLength + 4);
       frame.writeByte(Http20Draft09.TYPE_PUSH_PROMISE);
@@ -503,7 +503,7 @@
   private OkBuffer sendDataFrame(OkBuffer data) throws IOException {
     OkBuffer out = new OkBuffer();
     new Http20Draft09.Writer(out, true).dataFrame(expectedStreamId, Http20Draft09.FLAG_NONE, data,
-        (int) data.byteCount());
+        (int) data.size());
     return out;
   }
 
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index 6bef5dd..8c7a04b 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -69,7 +69,7 @@
   }
 
   public FrameWriter sendFrame() {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.byteCount(), Integer.MAX_VALUE));
+    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), Integer.MAX_VALUE));
     return frameWriter;
   }
 
@@ -78,7 +78,7 @@
    * won't be generated naturally.
    */
   public void sendFrame(byte[] frame) throws IOException {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.byteCount(), Integer.MAX_VALUE));
+    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), Integer.MAX_VALUE));
     bytesOut.write(frame);
   }
 
@@ -88,7 +88,7 @@
    * malformed.
    */
   public FrameWriter sendTruncatedFrame(int truncateToLength) {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.byteCount(), truncateToLength));
+    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), truncateToLength));
     return frameWriter;
   }
 
@@ -121,7 +121,7 @@
     FrameReader reader = variant.newReader(Okio.buffer(Okio.source(in)), client);
 
     Iterator<OutFrame> outFramesIterator = outFrames.iterator();
-    byte[] outBytes = bytesOut.readByteString((int) bytesOut.byteCount()).toByteArray();
+    byte[] outBytes = bytesOut.readByteString((int) bytesOut.size()).toByteArray();
     OutFrame nextOutFrame = null;
 
     for (int i = 0; i < frameCount; i++) {
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
index 39e461f..1904b90 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
@@ -85,7 +85,7 @@
 
   private void sendDataFrame(OkBuffer source) throws IOException {
     Spdy3.Writer writer = new Spdy3.Writer(new OkBuffer(), true);
-    writer.sendDataFrame(expectedStreamId, 0, source, (int) source.byteCount());
+    writer.sendDataFrame(expectedStreamId, 0, source, (int) source.size());
   }
 
   private void windowUpdate(long increment) throws IOException {
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index a02b509..6dd9695 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -1073,7 +1073,7 @@
     Source in = stream.getSource();
     OkBuffer buffer = new OkBuffer();
     while (in.read(buffer, 1024) != -1) {
-      if (buffer.byteCount() == 3 * windowUpdateThreshold) break;
+      if (buffer.size() == 3 * windowUpdateThreshold) break;
     }
     assertEquals(-1, in.read(buffer, 1));
 
@@ -1462,7 +1462,7 @@
     OkBuffer buffer = new OkBuffer();
     while (source.read(buffer, Long.MAX_VALUE) != -1) {
     }
-    String actual = buffer.readUtf8((int) buffer.byteCount());
+    String actual = buffer.readUtf8((int) buffer.size());
     assertEquals(expected, actual);
   }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index 894a418..a16da2c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -322,7 +322,7 @@
         case HTTP_OK:
           // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If that
           // happens, then we will have buffered bytes that are needed by the SSLSocket!
-          if (tunnelSource.buffer().byteCount() > 0) {
+          if (tunnelSource.buffer().size() > 0) {
             throw new IOException("TLS tunnel buffered too many bytes!");
           }
           return;
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
index 1c0cd7b..7364c52 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
@@ -255,7 +255,7 @@
 
     @Override public void write(OkBuffer source, long byteCount) throws IOException {
       if (closed) throw new IllegalStateException("closed");
-      checkOffsetAndCount(source.byteCount(), 0, byteCount);
+      checkOffsetAndCount(source.size(), 0, byteCount);
       if (byteCount > bytesRemaining) {
         throw new ProtocolException("expected " + bytesRemaining
             + " bytes but received " + byteCount);
@@ -323,7 +323,7 @@
     @Override public void write(OkBuffer source, long byteCount) throws IOException {
       if (closed) throw new IllegalStateException("closed");
       bufferedChunk.write(source, byteCount);
-      if (bufferedChunk.byteCount() > maxChunkLength) {
+      if (bufferedChunk.size() > maxChunkLength) {
         writeBufferedChunkToSocket();
       }
     }
@@ -343,11 +343,11 @@
     }
 
     private void writeBufferedChunkToSocket() throws IOException {
-      int size = (int) bufferedChunk.byteCount();
+      int size = (int) bufferedChunk.size();
       if (size == 0) return;
 
       writeHex(size);
-      sink.write(bufferedChunk, bufferedChunk.byteCount());
+      sink.write(bufferedChunk, bufferedChunk.size());
       sink.writeUtf8(CRLF);
     }
 
@@ -383,7 +383,7 @@
     /** Copy the last {@code byteCount} bytes of {@code source} to the cache body. */
     protected final void cacheWrite(OkBuffer source, long byteCount) throws IOException {
       if (cacheBody != null) {
-        Okio.copy(source, source.byteCount() - byteCount, byteCount, cacheBody);
+        Okio.copy(source, source.size() - byteCount, byteCount, cacheBody);
       }
     }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 806b075..d683d6b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -525,7 +525,7 @@
     if (!responseSource.requiresConnection()) return;
 
     // Flush the response body if there's data outstanding.
-    if (bufferedRequestBody != null && bufferedRequestBody.buffer().byteCount() > 0) {
+    if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
       bufferedRequestBody.flush();
     }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
index 68bf97a..b8f53a3 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
@@ -46,16 +46,16 @@
   @Override public void close() throws IOException {
     if (closed) return;
     closed = true;
-    if (content.byteCount() < limit) {
+    if (content.size() < limit) {
       throw new ProtocolException(
-          "content-length promised " + limit + " bytes, but received " + content.byteCount());
+          "content-length promised " + limit + " bytes, but received " + content.size());
     }
   }
 
   @Override public void write(OkBuffer source, long byteCount) throws IOException {
     if (closed) throw new IllegalStateException("closed");
-    checkOffsetAndCount(source.byteCount(), 0, byteCount);
-    if (limit != -1 && content.byteCount() > limit - byteCount) {
+    checkOffsetAndCount(source.size(), 0, byteCount);
+    if (limit != -1 && content.size() > limit - byteCount) {
       throw new ProtocolException("exceeded content-length limit of " + limit + " bytes");
     }
     content.write(source, byteCount);
@@ -69,11 +69,11 @@
   }
 
   public long contentLength() throws IOException {
-    return content.byteCount();
+    return content.size();
   }
 
   public void writeToSocket(BufferedSink socketOut) throws IOException {
     // Clone the content; otherwise we won't have data to retry.
-    socketOut.write(content.clone(), content.byteCount());
+    socketOut.write(content.clone(), content.size());
   }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 684a82b..f3afcac 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -274,7 +274,7 @@
       }
 
       if (cacheBody != null) {
-        Okio.copy(sink, sink.byteCount() - read, read, cacheBody);
+        Okio.copy(sink, sink.size() - read, read, cacheBody);
       }
 
       return read;
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RequestTest.java b/okhttp/src/test/java/com/squareup/okhttp/RequestTest.java
index e265e3b..c00c5b1 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/RequestTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/RequestTest.java
@@ -76,6 +76,6 @@
   private String bodyToHex(Request.Body body) throws IOException {
     OkBuffer buffer = new OkBuffer();
     body.writeTo(buffer);
-    return buffer.readByteString((int) buffer.byteCount()).hex();
+    return buffer.readByteString((int) buffer.size()).hex();
   }
 }
/Fim/
diff --git a/okio/src/main/java/okio/DeflaterSink.java b/okio/src/main/java/okio/DeflaterSink.java
index 276c3e6..e3a7cab 100644
--- a/okio/src/main/java/okio/DeflaterSink.java
+++ b/okio/src/main/java/okio/DeflaterSink.java
@@ -46,7 +46,7 @@
 
   @Override public void write(OkBuffer source, long byteCount)
       throws IOException {
-    checkOffsetAndCount(source.byteCount, 0, byteCount);
+    checkOffsetAndCount(source.size, 0, byteCount);
     while (byteCount > 0) {
       // Share bytes from the head segment of 'source' with the deflater.
       Segment head = source.head;
@@ -57,7 +57,7 @@
       deflate(false);
 
       // Mark those bytes as read.
-      source.byteCount -= toDeflate;
+      source.size -= toDeflate;
       head.pos += toDeflate;
       if (head.pos == head.limit) {
         source.head = head.pop();
@@ -84,7 +84,7 @@
 
       if (deflated == 0) return;
       s.limit += deflated;
-      buffer.byteCount += deflated;
+      buffer.size += deflated;
       sink.emitCompleteSegments();
     }
   }
/Fim/
diff --git a/okio/src/main/java/okio/GzipSource.java b/okio/src/main/java/okio/GzipSource.java
index 26fbaac..fe73c08 100644
--- a/okio/src/main/java/okio/GzipSource.java
+++ b/okio/src/main/java/okio/GzipSource.java
@@ -70,7 +70,7 @@
 
     // Attempt to read at least a byte of the body. If we do, we're done.
     if (section == SECTION_BODY) {
-      long offset = sink.byteCount;
+      long offset = sink.size;
       long result = inflaterSource.read(sink, byteCount);
       if (result != -1) {
         updateCrc(sink, offset, result);
/Fim/
diff --git a/okio/src/main/java/okio/InflaterSource.java b/okio/src/main/java/okio/InflaterSource.java
index f4ee469..c86c995 100644
--- a/okio/src/main/java/okio/InflaterSource.java
+++ b/okio/src/main/java/okio/InflaterSource.java
@@ -67,7 +67,7 @@
         int bytesInflated = inflater.inflate(tail.data, tail.limit, Segment.SIZE - tail.limit);
         if (bytesInflated > 0) {
           tail.limit += bytesInflated;
-          sink.byteCount += bytesInflated;
+          sink.size += bytesInflated;
           return bytesInflated;
         }
         if (inflater.finished() || inflater.needsDictionary()) {
/Fim/
diff --git a/okio/src/main/java/okio/OkBuffer.java b/okio/src/main/java/okio/OkBuffer.java
index cc9d9ab..08a9095 100644
--- a/okio/src/main/java/okio/OkBuffer.java
+++ b/okio/src/main/java/okio/OkBuffer.java
@@ -44,14 +44,14 @@
  */
 public final class OkBuffer implements BufferedSource, BufferedSink, Cloneable {
   Segment head;
-  long byteCount;
+  long size;
 
   public OkBuffer() {
   }
 
   /** Returns the number of bytes currently in this buffer. */
-  public long byteCount() {
-    return byteCount;
+  public long size() {
+    return size;
   }
 
   @Override public OkBuffer buffer() {
@@ -85,11 +85,11 @@
   }
 
   @Override public boolean exhausted() {
-    return byteCount == 0;
+    return size == 0;
   }
 
   @Override public void require(long byteCount) throws EOFException {
-    if (this.byteCount < byteCount) throw new EOFException();
+    if (this.size < byteCount) throw new EOFException();
   }
 
   @Override public long seek(byte b) throws EOFException {
@@ -109,7 +109,7 @@
       }
 
       @Override public int available() {
-        return (int) Math.min(byteCount, Integer.MAX_VALUE);
+        return (int) Math.min(size, Integer.MAX_VALUE);
       }
 
       @Override public void close() {
@@ -127,7 +127,7 @@
    * without harming throughput.
    */
   public long completeSegmentByteCount() {
-    long result = byteCount;
+    long result = size;
     if (result == 0) return 0;
 
     // Omit the tail if it's still writable.
@@ -140,7 +140,7 @@
   }
 
   @Override public byte readByte() {
-    if (byteCount == 0) throw new IllegalStateException("byteCount == 0");
+    if (size == 0) throw new IllegalStateException("size == 0");
 
     Segment segment = head;
     int pos = segment.pos;
@@ -148,7 +148,7 @@
 
     byte[] data = segment.data;
     byte b = data[pos++];
-    byteCount -= 1;
+    size -= 1;
 
     if (pos == limit) {
       head = segment.pop();
@@ -162,7 +162,7 @@
 
   /** Returns the byte at {@code i}. */
   public byte getByte(long i) {
-    checkOffsetAndCount(byteCount, i, 1);
+    checkOffsetAndCount(size, i, 1);
     for (Segment s = head; true; s = s.next) {
       int segmentByteCount = s.limit - s.pos;
       if (i < segmentByteCount) return s.data[s.pos + (int) i];
@@ -171,7 +171,7 @@
   }
 
   @Override public short readShort() {
-    if (byteCount < 2) throw new IllegalArgumentException("byteCount < 2: " + byteCount);
+    if (size < 2) throw new IllegalArgumentException("size < 2: " + size);
 
     Segment segment = head;
     int pos = segment.pos;
@@ -187,7 +187,7 @@
     byte[] data = segment.data;
     int s = (data[pos++] & 0xff) << 8
         |   (data[pos++] & 0xff);
-    byteCount -= 2;
+    size -= 2;
 
     if (pos == limit) {
       head = segment.pop();
@@ -200,7 +200,7 @@
   }
 
   @Override public int readInt() {
-    if (byteCount < 4) throw new IllegalArgumentException("byteCount < 4: " + byteCount);
+    if (size < 4) throw new IllegalArgumentException("size < 4: " + size);
 
     Segment segment = head;
     int pos = segment.pos;
@@ -219,7 +219,7 @@
         |   (data[pos++] & 0xff) << 16
         |   (data[pos++] & 0xff) << 8
         |   (data[pos++] & 0xff);
-    byteCount -= 4;
+    size -= 4;
 
     if (pos == limit) {
       head = segment.pop();
@@ -244,7 +244,7 @@
   }
 
   public String readUtf8(int byteCount) {
-    checkOffsetAndCount(this.byteCount, 0, byteCount);
+    checkOffsetAndCount(this.size, 0, byteCount);
     if (byteCount == 0) return "";
 
     Segment head = this.head;
@@ -255,7 +255,7 @@
 
     String result = new String(head.data, head.pos, byteCount, UTF_8);
     head.pos += byteCount;
-    this.byteCount -= byteCount;
+    this.size -= byteCount;
 
     if (head.pos == head.limit) {
       this.head = head.pop();
@@ -270,7 +270,7 @@
 
     if (newline == -1) {
       if (throwOnEof) throw new EOFException();
-      return byteCount != 0 ? readUtf8((int) byteCount) : null;
+      return size != 0 ? readUtf8((int) size) : null;
     }
 
     if (newline > 0 && getByte(newline - 1) == '\r') {
@@ -288,7 +288,7 @@
   }
 
   private byte[] readBytes(int byteCount) {
-    checkOffsetAndCount(this.byteCount, 0, byteCount);
+    checkOffsetAndCount(this.size, 0, byteCount);
 
     int offset = 0;
     byte[] result = new byte[byteCount];
@@ -307,7 +307,7 @@
       }
     }
 
-    this.byteCount -= byteCount;
+    this.size -= byteCount;
     return result;
   }
 
@@ -320,7 +320,7 @@
     System.arraycopy(s.data, s.pos, sink, offset, toCopy);
 
     s.pos += toCopy;
-    this.byteCount -= toCopy;
+    this.size -= toCopy;
 
     if (s.pos == s.limit) {
       this.head = s.pop();
@@ -335,14 +335,14 @@
    * with a buffer will return its segments to the pool.
    */
   public void clear() {
-    skip(byteCount);
+    skip(size);
   }
 
   /** Discards {@code byteCount} bytes from the head of this buffer. */
   public void skip(long byteCount) {
-    checkOffsetAndCount(this.byteCount, 0, byteCount);
+    checkOffsetAndCount(this.size, 0, byteCount);
 
-    this.byteCount -= byteCount;
+    this.size -= byteCount;
     while (byteCount > 0) {
       int toSkip = (int) Math.min(byteCount, head.limit - head.pos);
       byteCount -= toSkip;
@@ -383,7 +383,7 @@
       tail.limit += toCopy;
     }
 
-    this.byteCount += byteCount;
+    this.size += byteCount;
     return this;
   }
 
@@ -391,7 +391,7 @@
   @Override public OkBuffer writeByte(int b) {
     Segment tail = writableSegment(1);
     tail.data[tail.limit++] = (byte) b;
-    byteCount += 1;
+    size += 1;
     return this;
   }
 
@@ -403,7 +403,7 @@
     data[limit++] = (byte) ((s >> 8) & 0xff);
     data[limit++] = (byte)  (s       & 0xff);
     tail.limit = limit;
-    byteCount += 2;
+    size += 2;
     return this;
   }
 
@@ -417,7 +417,7 @@
     data[limit++] = (byte) ((i >>  8) & 0xff);
     data[limit++] = (byte)  (i        & 0xff);
     tail.limit = limit;
-    byteCount += 4;
+    size += 4;
     return this;
   }
 
@@ -494,7 +494,7 @@
     if (source == this) {
       throw new IllegalArgumentException("source == this");
     }
-    checkOffsetAndCount(source.byteCount, 0, byteCount);
+    checkOffsetAndCount(source.size, 0, byteCount);
 
     while (byteCount > 0) {
       // Is a prefix of the source's head segment all that we need to move?
@@ -507,8 +507,8 @@
         } else {
           // Our existing segments are sufficient. Move bytes from source's head to our tail.
           source.head.writeTo(tail, (int) byteCount);
-          source.byteCount -= byteCount;
-          this.byteCount += byteCount;
+          source.size -= byteCount;
+          this.size += byteCount;
           return;
         }
       }
@@ -525,15 +525,15 @@
         tail = tail.push(segmentToMove);
         tail.compact();
       }
-      source.byteCount -= movedByteCount;
-      this.byteCount += movedByteCount;
+      source.size -= movedByteCount;
+      this.size += movedByteCount;
       byteCount -= movedByteCount;
     }
   }
 
   @Override public long read(OkBuffer sink, long byteCount) {
-    if (this.byteCount == 0) return -1L;
-    if (byteCount > this.byteCount) byteCount = this.byteCount;
+    if (this.size == 0) return -1L;
+    if (byteCount > this.size) byteCount = this.size;
     sink.write(this, byteCount);
     return byteCount;
   }
@@ -596,15 +596,15 @@
   @Override public boolean equals(Object o) {
     if (!(o instanceof OkBuffer)) return false;
     OkBuffer that = (OkBuffer) o;
-    if (byteCount != that.byteCount) return false;
-    if (byteCount == 0) return true; // Both buffers are empty.
+    if (size != that.size) return false;
+    if (size == 0) return true; // Both buffers are empty.
 
     Segment sa = this.head;
     Segment sb = that.head;
     int posA = sa.pos;
     int posB = sb.pos;
 
-    for (long pos = 0, count; pos < byteCount; pos += count) {
+    for (long pos = 0, count; pos < size; pos += count) {
       count = Math.min(sa.limit - posA, sb.limit - posB);
 
       for (int i = 0; i < count; i++) {
@@ -639,13 +639,13 @@
   }
 
   @Override public String toString() {
-    if (byteCount == 0) {
+    if (size == 0) {
       return "OkBuffer[size=0]";
     }
 
-    if (byteCount <= 16) {
-      ByteString data = clone().readByteString((int) byteCount);
-      return String.format("OkBuffer[size=%s data=%s]", byteCount, data.hex());
+    if (size <= 16) {
+      ByteString data = clone().readByteString((int) size);
+      return String.format("OkBuffer[size=%s data=%s]", size, data.hex());
     }
 
     try {
@@ -655,7 +655,7 @@
         md5.update(s.data, s.pos, s.limit - s.pos);
       }
       return String.format("OkBuffer[size=%s md5=%s]",
-          byteCount, ByteString.of(md5.digest()).hex());
+          size, ByteString.of(md5.digest()).hex());
     } catch (NoSuchAlgorithmException e) {
       throw new AssertionError();
     }
@@ -664,7 +664,7 @@
   /** Returns a deep copy of this buffer. */
   @Override public OkBuffer clone() {
     OkBuffer result = new OkBuffer();
-    if (byteCount() == 0) return result;
+    if (size() == 0) return result;
 
     result.write(head.data, head.pos, head.limit - head.pos);
     for (Segment s = head.next; s != head; s = s.next) {
/Fim/
diff --git a/okio/src/main/java/okio/Okio.java b/okio/src/main/java/okio/Okio.java
index afe5b53..3a9b4f9 100644
--- a/okio/src/main/java/okio/Okio.java
+++ b/okio/src/main/java/okio/Okio.java
@@ -36,7 +36,7 @@
   /** Copies bytes from {@code source} to {@code sink}. */
   public static void copy(OkBuffer source, long offset, long byteCount, OutputStream sink)
       throws IOException {
-    checkOffsetAndCount(source.byteCount, offset, byteCount);
+    checkOffsetAndCount(source.size, offset, byteCount);
 
     // Skip segments that we aren't copying from.
     Segment s = source.head;
@@ -62,7 +62,7 @@
 
       @Override public void write(OkBuffer source, long byteCount)
           throws IOException {
-        checkOffsetAndCount(source.byteCount, 0, byteCount);
+        checkOffsetAndCount(source.size, 0, byteCount);
         while (byteCount > 0) {
           deadline.throwIfReached();
           Segment head = source.head;
@@ -71,7 +71,7 @@
 
           head.pos += toCopy;
           byteCount -= toCopy;
-          source.byteCount -= toCopy;
+          source.size -= toCopy;
 
           if (head.pos == head.limit) {
             source.head = head.pop();
@@ -113,7 +113,7 @@
         int bytesRead = in.read(tail.data, tail.limit, maxToCopy);
         if (bytesRead == -1) return -1;
         tail.limit += bytesRead;
-        sink.byteCount += bytesRead;
+        sink.size += bytesRead;
         return bytesRead;
       }
 
/Fim/
diff --git a/okio/src/main/java/okio/RealBufferedSink.java b/okio/src/main/java/okio/RealBufferedSink.java
index 40e63f4..4f484c2 100644
--- a/okio/src/main/java/okio/RealBufferedSink.java
+++ b/okio/src/main/java/okio/RealBufferedSink.java
@@ -120,8 +120,8 @@
 
   @Override public void flush() throws IOException {
     if (closed) throw new IllegalStateException("closed");
-    if (buffer.byteCount > 0) {
-      sink.write(buffer, buffer.byteCount);
+    if (buffer.size > 0) {
+      sink.write(buffer, buffer.size);
     }
     sink.flush();
   }
@@ -132,8 +132,8 @@
     // If flushing throws, we still need to close the stream!
     Throwable thrown = null;
     try {
-      if (buffer.byteCount > 0) {
-        sink.write(buffer, buffer.byteCount);
+      if (buffer.size > 0) {
+        sink.write(buffer, buffer.size);
       }
     } catch (IOException e) {
       thrown = e;
/Fim/
diff --git a/okio/src/main/java/okio/RealBufferedSource.java b/okio/src/main/java/okio/RealBufferedSource.java
index 16200ce..58a4765 100644
--- a/okio/src/main/java/okio/RealBufferedSource.java
+++ b/okio/src/main/java/okio/RealBufferedSource.java
@@ -45,12 +45,12 @@
     if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
     if (closed) throw new IllegalStateException("closed");
 
-    if (buffer.byteCount == 0) {
+    if (buffer.size == 0) {
       long read = source.read(buffer, Segment.SIZE);
       if (read == -1) return -1;
     }
 
-    long toRead = Math.min(byteCount, buffer.byteCount);
+    long toRead = Math.min(byteCount, buffer.size);
     return buffer.read(sink, toRead);
   }
 
@@ -59,7 +59,7 @@
   }
 
   @Override public void require(long byteCount) throws IOException {
-    while (buffer.byteCount < byteCount) {
+    while (buffer.size < byteCount) {
       if (source.read(buffer, Segment.SIZE) == -1) throw new EOFException();
     }
   }
@@ -83,10 +83,10 @@
     long start = 0;
     long newline;
     while ((newline = buffer.indexOf((byte) '\n', start)) == -1) {
-      start = buffer.byteCount;
+      start = buffer.size;
       if (source.read(buffer, Segment.SIZE) == -1) {
         if (throwOnEof) throw new EOFException();
-        return buffer.byteCount != 0 ? readUtf8((int) buffer.byteCount) : null;
+        return buffer.size != 0 ? readUtf8((int) buffer.size) : null;
       }
     }
 
@@ -126,10 +126,10 @@
 
   @Override public void skip(long byteCount) throws IOException {
     while (byteCount > 0) {
-      if (buffer.byteCount == 0 && source.read(buffer, Segment.SIZE) == -1) {
+      if (buffer.size == 0 && source.read(buffer, Segment.SIZE) == -1) {
         throw new EOFException();
       }
-      long toSkip = Math.min(byteCount, buffer.byteCount());
+      long toSkip = Math.min(byteCount, buffer.size());
       buffer.skip(toSkip);
       byteCount -= toSkip;
     }
@@ -139,7 +139,7 @@
     long start = 0;
     long index;
     while ((index = buffer.indexOf(b, start)) == -1) {
-      start = buffer.byteCount;
+      start = buffer.size;
       if (source.read(buffer, Segment.SIZE) == -1) throw new EOFException();
     }
     return index;
@@ -148,7 +148,7 @@
   @Override public InputStream inputStream() {
     return new InputStream() {
       @Override public int read() throws IOException {
-        if (buffer.byteCount == 0) {
+        if (buffer.size == 0) {
           long count = source.read(buffer, Segment.SIZE);
           if (count == -1) return -1;
         }
@@ -158,7 +158,7 @@
       @Override public int read(byte[] data, int offset, int byteCount) throws IOException {
         checkOffsetAndCount(data.length, offset, byteCount);
 
-        if (buffer.byteCount == 0) {
+        if (buffer.size == 0) {
           long count = source.read(buffer, Segment.SIZE);
           if (count == -1) return -1;
         }
@@ -167,7 +167,7 @@
       }
 
       @Override public int available() throws IOException {
-        return (int) Math.min(buffer.byteCount, Integer.MAX_VALUE);
+        return (int) Math.min(buffer.size, Integer.MAX_VALUE);
       }
 
       @Override public void close() throws IOException {
/Fim/
diff --git a/okio/src/test/java/okio/DeflaterSinkTest.java b/okio/src/test/java/okio/DeflaterSinkTest.java
index 5743c26..cecc0ff 100644
--- a/okio/src/test/java/okio/DeflaterSinkTest.java
+++ b/okio/src/test/java/okio/DeflaterSinkTest.java
@@ -33,10 +33,10 @@
     data.writeUtf8(original);
     OkBuffer sink = new OkBuffer();
     DeflaterSink deflaterSink = new DeflaterSink(sink, new Deflater());
-    deflaterSink.write(data, data.byteCount());
+    deflaterSink.write(data, data.size());
     deflaterSink.close();
     OkBuffer inflated = inflate(sink);
-    assertEquals(original, inflated.readUtf8((int) inflated.byteCount()));
+    assertEquals(original, inflated.readUtf8((int) inflated.size()));
   }
 
   @Test public void deflateWithSyncFlush() throws Exception {
@@ -45,10 +45,10 @@
     data.writeUtf8(original);
     OkBuffer sink = new OkBuffer();
     DeflaterSink deflaterSink = new DeflaterSink(sink, new Deflater());
-    deflaterSink.write(data, data.byteCount());
+    deflaterSink.write(data, data.size());
     deflaterSink.flush();
     OkBuffer inflated = inflate(sink);
-    assertEquals(original, inflated.readUtf8((int) inflated.byteCount()));
+    assertEquals(original, inflated.readUtf8((int) inflated.size()));
   }
 
   @Test public void deflateWellCompressed() throws IOException {
@@ -57,10 +57,10 @@
     data.writeUtf8(original);
     OkBuffer sink = new OkBuffer();
     DeflaterSink deflaterSink = new DeflaterSink(sink, new Deflater());
-    deflaterSink.write(data, data.byteCount());
+    deflaterSink.write(data, data.size());
     deflaterSink.close();
     OkBuffer inflated = inflate(sink);
-    assertEquals(original, inflated.readUtf8((int) inflated.byteCount()));
+    assertEquals(original, inflated.readUtf8((int) inflated.size()));
   }
 
   @Test public void deflatePoorlyCompressed() throws IOException {
@@ -69,10 +69,10 @@
     data.write(original);
     OkBuffer sink = new OkBuffer();
     DeflaterSink deflaterSink = new DeflaterSink(sink, new Deflater());
-    deflaterSink.write(data, data.byteCount());
+    deflaterSink.write(data, data.size());
     deflaterSink.close();
     OkBuffer inflated = inflate(sink);
-    assertEquals(original, inflated.readByteString((int) inflated.byteCount()));
+    assertEquals(original, inflated.readByteString((int) inflated.size()));
   }
 
   /**
@@ -85,7 +85,7 @@
     InputStream inflatedIn = new InflaterInputStream(deflatedIn, inflater);
     OkBuffer result = new OkBuffer();
     byte[] buffer = new byte[8192];
-    while (!inflater.needsInput() || deflated.byteCount() > 0 || deflatedIn.available() > 0) {
+    while (!inflater.needsInput() || deflated.size() > 0 || deflatedIn.available() > 0) {
       int count = inflatedIn.read(buffer, 0, buffer.length);
       result.write(buffer, 0, count);
     }
/Fim/
diff --git a/okio/src/test/java/okio/GzipSourceTest.java b/okio/src/test/java/okio/GzipSourceTest.java
index 49deaa4..ed01196 100644
--- a/okio/src/test/java/okio/GzipSourceTest.java
+++ b/okio/src/test/java/okio/GzipSourceTest.java
@@ -99,7 +99,7 @@
   private void assertGzipped(OkBuffer gzipped) throws IOException {
     OkBuffer gunzipped = gunzip(gzipped);
     assertEquals("It's a UNIX system! I know this!",
-        gunzipped.readUtf8((int) gunzipped.byteCount()));
+        gunzipped.readUtf8((int) gunzipped.size()));
   }
 
   /**
/Fim/
diff --git a/okio/src/test/java/okio/InflaterSourceTest.java b/okio/src/test/java/okio/InflaterSourceTest.java
index ba5c62d..1d6b518 100644
--- a/okio/src/test/java/okio/InflaterSourceTest.java
+++ b/okio/src/test/java/okio/InflaterSourceTest.java
@@ -71,7 +71,7 @@
     ByteString original = randomBytes(1024 * 1024);
     OkBuffer deflated = deflate(original);
     OkBuffer inflated = inflate(deflated);
-    assertEquals(original, inflated.readByteString((int) inflated.byteCount()));
+    assertEquals(original, inflated.readByteString((int) inflated.size()));
   }
 
   private OkBuffer decodeBase64(String s) {
@@ -79,7 +79,7 @@
   }
 
   private String readUtf8(OkBuffer buffer) {
-    return buffer.readUtf8((int) buffer.byteCount());
+    return buffer.readUtf8((int) buffer.size());
   }
 
   /** Use DeflaterOutputStream to deflate source. */
/Fim/
diff --git a/okio/src/test/java/okio/OkBufferTest.java b/okio/src/test/java/okio/OkBufferTest.java
index d19f2ca..8785ab6 100644
--- a/okio/src/test/java/okio/OkBufferTest.java
+++ b/okio/src/test/java/okio/OkBufferTest.java
@@ -30,13 +30,13 @@
   @Test public void readAndWriteUtf8() throws Exception {
     OkBuffer buffer = new OkBuffer();
     buffer.writeUtf8("ab");
-    assertEquals(2, buffer.byteCount());
+    assertEquals(2, buffer.size());
     buffer.writeUtf8("cdef");
-    assertEquals(6, buffer.byteCount());
+    assertEquals(6, buffer.size());
     assertEquals("abcd", buffer.readUtf8(4));
-    assertEquals(2, buffer.byteCount());
+    assertEquals(2, buffer.size());
     assertEquals("ef", buffer.readUtf8(2));
-    assertEquals(0, buffer.byteCount());
+    assertEquals(0, buffer.size());
     try {
       buffer.readUtf8(1);
       fail();
@@ -112,7 +112,7 @@
     assertEquals("c" + repeat('d', 10000) + "e", buffer.readUtf8(10002)); // cd...de
     assertEquals(repeat('e', 24998), buffer.readUtf8(24998)); // e...e
     assertEquals("e" + repeat('f', 50000), buffer.readUtf8(50001)); // ef...f
-    assertEquals(0, buffer.byteCount());
+    assertEquals(0, buffer.size());
   }
 
   @Test public void fillAndDrainPool() throws Exception {
@@ -165,7 +165,7 @@
     for (String s : contents) {
       OkBuffer source = new OkBuffer();
       source.writeUtf8(s);
-      buffer.write(source, source.byteCount());
+      buffer.write(source, source.size());
       expected.append(s);
     }
     List<Integer> segmentSizes = buffer.segmentSizes();
@@ -213,8 +213,8 @@
 
     assertEquals(asList(30), sink.segmentSizes());
     assertEquals(asList(Segment.SIZE - 20, Segment.SIZE), source.segmentSizes());
-    assertEquals(30, sink.byteCount());
-    assertEquals(Segment.SIZE * 2 - 20, source.byteCount());
+    assertEquals(30, sink.size());
+    assertEquals(Segment.SIZE * 2 - 20, source.size());
   }
 
   @Test public void writePrefixDoesntSplitButRequiresCompact() throws Exception {
@@ -228,8 +228,8 @@
 
     assertEquals(asList(30), sink.segmentSizes());
     assertEquals(asList(Segment.SIZE - 20, Segment.SIZE), source.segmentSizes());
-    assertEquals(30, sink.byteCount());
-    assertEquals(Segment.SIZE * 2 - 20, source.byteCount());
+    assertEquals(30, sink.size());
+    assertEquals(Segment.SIZE * 2 - 20, source.size());
   }
 
   @Test public void readExhaustedSource() throws Exception {
@@ -239,8 +239,8 @@
     OkBuffer source = new OkBuffer();
 
     assertEquals(-1, source.read(sink, 10));
-    assertEquals(10, sink.byteCount());
-    assertEquals(0, source.byteCount());
+    assertEquals(10, sink.size());
+    assertEquals(0, source.size());
   }
 
   @Test public void readZeroBytesFromSource() throws Exception {
@@ -252,8 +252,8 @@
     // Either 0 or -1 is reasonable here. For consistency with Android's
     // ByteArrayInputStream we return 0.
     assertEquals(-1, source.read(sink, 0));
-    assertEquals(10, sink.byteCount());
-    assertEquals(0, source.byteCount());
+    assertEquals(10, sink.size());
+    assertEquals(0, source.size());
   }
 
   @Test public void moveAllRequestedBytesWithRead() throws Exception {
@@ -264,8 +264,8 @@
     source.writeUtf8(repeat('b', 15));
 
     assertEquals(10, source.read(sink, 10));
-    assertEquals(20, sink.byteCount());
-    assertEquals(5, source.byteCount());
+    assertEquals(20, sink.size());
+    assertEquals(5, source.size());
     assertEquals(repeat('a', 10) + repeat('b', 10), sink.readUtf8(20));
   }
 
@@ -277,8 +277,8 @@
     source.writeUtf8(repeat('b', 20));
 
     assertEquals(20, source.read(sink, 25));
-    assertEquals(30, sink.byteCount());
-    assertEquals(0, source.byteCount());
+    assertEquals(30, sink.size());
+    assertEquals(0, source.size());
     assertEquals(repeat('a', 10) + repeat('b', 20), sink.readUtf8(30));
   }
 
@@ -397,7 +397,7 @@
     data.write(new byte[] { (byte) 0xab, (byte) 0xcd });
     assertEquals(0xab, data.readByte() & 0xff);
     assertEquals(0xcd, data.readByte() & 0xff);
-    assertEquals(0, data.byteCount());
+    assertEquals(0, data.size());
   }
 
   @Test public void readShort() throws Exception {
@@ -407,7 +407,7 @@
     });
     assertEquals((short) 0xabcd, data.readShort());
     assertEquals((short) 0xef01, data.readShort());
-    assertEquals(0, data.byteCount());
+    assertEquals(0, data.size());
   }
 
   @Test public void readShortSplitAcrossMultipleSegments() throws Exception {
@@ -416,7 +416,7 @@
     data.write(new byte[] { (byte) 0xab, (byte) 0xcd });
     data.readUtf8(Segment.SIZE - 1);
     assertEquals((short) 0xabcd, data.readShort());
-    assertEquals(0, data.byteCount());
+    assertEquals(0, data.size());
   }
 
   @Test public void readInt() throws Exception {
@@ -427,7 +427,7 @@
     });
     assertEquals(0xabcdef01, data.readInt());
     assertEquals(0x87654321, data.readInt());
-    assertEquals(0, data.byteCount());
+    assertEquals(0, data.size());
   }
 
   @Test public void readIntSplitAcrossMultipleSegments() throws Exception {
@@ -438,7 +438,7 @@
     });
     data.readUtf8(Segment.SIZE - 3);
     assertEquals(0xabcdef01, data.readInt());
-    assertEquals(0, data.byteCount());
+    assertEquals(0, data.size());
   }
 
   @Test public void byteAt() throws Exception {
@@ -448,9 +448,9 @@
     buffer.writeUtf8("c");
     assertEquals('a', buffer.getByte(0));
     assertEquals('a', buffer.getByte(0)); // getByte doesn't mutate!
-    assertEquals('c', buffer.getByte(buffer.byteCount - 1));
-    assertEquals('b', buffer.getByte(buffer.byteCount - 2));
-    assertEquals('b', buffer.getByte(buffer.byteCount - 3));
+    assertEquals('c', buffer.getByte(buffer.size - 1));
+    assertEquals('b', buffer.getByte(buffer.size - 2));
+    assertEquals('b', buffer.getByte(buffer.size - 3));
   }
 
   @Test public void getByteOfEmptyBuffer() throws Exception {
@@ -472,7 +472,7 @@
     buffer.skip(Segment.SIZE - 2);
     assertEquals('b', buffer.readByte() & 0xff);
     buffer.skip(1);
-    assertEquals(0, buffer.byteCount());
+    assertEquals(0, buffer.size());
   }
 
   @Test public void testWritePrefixToEmptyBuffer() {
@@ -487,7 +487,7 @@
     OkBuffer original = new OkBuffer();
     OkBuffer clone = original.clone();
     original.writeUtf8("abc");
-    assertEquals(0, clone.byteCount());
+    assertEquals(0, clone.size());
   }
 
   @Test public void cloneDoesNotObserveReadsFromOriginal() throws Exception {
@@ -495,7 +495,7 @@
     original.writeUtf8("abc");
     OkBuffer clone = original.clone();
     assertEquals("abc", original.readUtf8(3));
-    assertEquals(3, clone.byteCount());
+    assertEquals(3, clone.size());
     assertEquals("ab", clone.readUtf8(2));
   }
 
@@ -503,7 +503,7 @@
     OkBuffer original = new OkBuffer();
     OkBuffer clone = original.clone();
     clone.writeUtf8("abc");
-    assertEquals(0, original.byteCount());
+    assertEquals(0, original.size());
   }
 
   @Test public void originalDoesNotObserveReadsFromClone() throws Exception {
@@ -511,7 +511,7 @@
     original.writeUtf8("abc");
     OkBuffer clone = original.clone();
     assertEquals("abc", clone.readUtf8(3));
-    assertEquals(3, original.byteCount());
+    assertEquals(3, original.size());
     assertEquals("ab", original.readUtf8(2));
   }
 
/Fim/
diff --git a/okio/src/test/java/okio/OkioTest.java b/okio/src/test/java/okio/OkioTest.java
index 7613432..fa7eef3 100644
--- a/okio/src/test/java/okio/OkioTest.java
+++ b/okio/src/test/java/okio/OkioTest.java
@@ -36,7 +36,7 @@
     Sink sink = Okio.sink(out);
     sink.write(data, 3);
     assertEquals("abb", out.toString("UTF-8"));
-    sink.write(data, data.byteCount());
+    sink.write(data, data.size());
     assertEquals("a" + repeat('b', 9998) + "c", out.toString("UTF-8"));
   }
 
@@ -54,11 +54,11 @@
 
     // Source: b...bc. Sink: b...b.
     assertEquals(Segment.SIZE, source.read(sink, 20000));
-    assertEquals(repeat('b', Segment.SIZE), sink.readUtf8((int) sink.byteCount()));
+    assertEquals(repeat('b', Segment.SIZE), sink.readUtf8((int) sink.size()));
 
     // Source: b...bc. Sink: b...bc.
     assertEquals(Segment.SIZE - 1, source.read(sink, 20000));
-    assertEquals(repeat('b', Segment.SIZE - 2) + "c", sink.readUtf8((int) sink.byteCount()));
+    assertEquals(repeat('b', Segment.SIZE - 2) + "c", sink.readUtf8((int) sink.size()));
 
     // Source and sink are empty.
     assertEquals(-1, source.read(sink, 1));
/Fim/
diff --git a/okio/src/test/java/okio/RealBufferedSinkTest.java b/okio/src/test/java/okio/RealBufferedSinkTest.java
index 6e5f567..195e283 100644
--- a/okio/src/test/java/okio/RealBufferedSinkTest.java
+++ b/okio/src/test/java/okio/RealBufferedSinkTest.java
@@ -49,35 +49,35 @@
     OkBuffer sink = new OkBuffer();
     BufferedSink bufferedSink = new RealBufferedSink(sink);
     bufferedSink.writeUtf8(repeat('a', Segment.SIZE - 1));
-    assertEquals(0, sink.byteCount());
+    assertEquals(0, sink.size());
     bufferedSink.writeByte(0);
-    assertEquals(Segment.SIZE, sink.byteCount());
-    assertEquals(0, bufferedSink.buffer().byteCount());
+    assertEquals(Segment.SIZE, sink.size());
+    assertEquals(0, bufferedSink.buffer().size());
   }
 
   @Test public void bufferedSinkEmitZero() throws IOException {
     OkBuffer sink = new OkBuffer();
     BufferedSink bufferedSink = new RealBufferedSink(sink);
     bufferedSink.writeUtf8("");
-    assertEquals(0, sink.byteCount());
+    assertEquals(0, sink.size());
   }
 
   @Test public void bufferedSinkEmitMultipleSegments() throws IOException {
     OkBuffer sink = new OkBuffer();
     BufferedSink bufferedSink = new RealBufferedSink(sink);
     bufferedSink.writeUtf8(repeat('a', Segment.SIZE * 4 - 1));
-    assertEquals(Segment.SIZE * 3, sink.byteCount());
-    assertEquals(Segment.SIZE - 1, bufferedSink.buffer().byteCount());
+    assertEquals(Segment.SIZE * 3, sink.size());
+    assertEquals(Segment.SIZE - 1, bufferedSink.buffer().size());
   }
 
   @Test public void bufferedSinkFlush() throws IOException {
     OkBuffer sink = new OkBuffer();
     BufferedSink bufferedSink = new RealBufferedSink(sink);
     bufferedSink.writeByte('a');
-    assertEquals(0, sink.byteCount());
+    assertEquals(0, sink.size());
     bufferedSink.flush();
-    assertEquals(0, bufferedSink.buffer().byteCount());
-    assertEquals(1, sink.byteCount());
+    assertEquals(0, bufferedSink.buffer().size());
+    assertEquals(1, sink.size());
   }
 
   @Test public void bytesEmittedToSinkWithFlush() throws Exception {
@@ -85,28 +85,28 @@
     BufferedSink bufferedSink = new RealBufferedSink(sink);
     bufferedSink.writeUtf8("abc");
     bufferedSink.flush();
-    assertEquals(3, sink.byteCount());
+    assertEquals(3, sink.size());
   }
 
   @Test public void bytesNotEmittedToSinkWithoutFlush() throws Exception {
     OkBuffer sink = new OkBuffer();
     BufferedSink bufferedSink = new RealBufferedSink(sink);
     bufferedSink.writeUtf8("abc");
-    assertEquals(0, sink.byteCount());
+    assertEquals(0, sink.size());
   }
 
   @Test public void completeSegmentsEmitted() throws Exception {
     OkBuffer sink = new OkBuffer();
     BufferedSink bufferedSink = new RealBufferedSink(sink);
     bufferedSink.writeUtf8(repeat('a', Segment.SIZE * 3));
-    assertEquals(Segment.SIZE * 3, sink.byteCount());
+    assertEquals(Segment.SIZE * 3, sink.size());
   }
 
   @Test public void incompleteSegmentsNotEmitted() throws Exception {
     OkBuffer sink = new OkBuffer();
     BufferedSink bufferedSink = new RealBufferedSink(sink);
     bufferedSink.writeUtf8(repeat('a', Segment.SIZE * 3 - 1));
-    assertEquals(Segment.SIZE * 2, sink.byteCount());
+    assertEquals(Segment.SIZE * 2, sink.size());
   }
 
   private String repeat(char c, int count) {
/Fim/
diff --git a/okio/src/test/java/okio/RealBufferedSourceTest.java b/okio/src/test/java/okio/RealBufferedSourceTest.java
index 8b54743..646bcc2 100644
--- a/okio/src/test/java/okio/RealBufferedSourceTest.java
+++ b/okio/src/test/java/okio/RealBufferedSourceTest.java
@@ -34,32 +34,32 @@
 
     InputStream in = new RealBufferedSource(source).inputStream();
     assertEquals(0, in.available());
-    assertEquals(Segment.SIZE + 2, source.byteCount());
+    assertEquals(Segment.SIZE + 2, source.size());
 
     // Reading one byte buffers a full segment.
     assertEquals('a', in.read());
     assertEquals(Segment.SIZE - 1, in.available());
-    assertEquals(2, source.byteCount());
+    assertEquals(2, source.size());
 
     // Reading as much as possible reads the rest of that buffered segment.
     byte[] data = new byte[Segment.SIZE * 2];
     assertEquals(Segment.SIZE - 1, in.read(data, 0, data.length));
     assertEquals(repeat('b', Segment.SIZE - 1), new String(data, 0, Segment.SIZE - 1, UTF_8));
-    assertEquals(2, source.byteCount());
+    assertEquals(2, source.size());
 
     // Continuing to read buffers the next segment.
     assertEquals('b', in.read());
     assertEquals(1, in.available());
-    assertEquals(0, source.byteCount());
+    assertEquals(0, source.size());
 
     // Continuing to read reads from the buffer.
     assertEquals('c', in.read());
     assertEquals(0, in.available());
-    assertEquals(0, source.byteCount());
+    assertEquals(0, source.size());
 
     // Once we've exhausted the source, we're done.
     assertEquals(-1, in.read());
-    assertEquals(0, source.byteCount());
+    assertEquals(0, source.size());
   }
 
   @Test public void inputStreamFromSourceBounds() throws IOException {
@@ -81,8 +81,8 @@
     bufferedSource.buffer().writeUtf8("aa");
 
     bufferedSource.require(2);
-    assertEquals(2, bufferedSource.buffer().byteCount());
-    assertEquals(2, source.byteCount());
+    assertEquals(2, bufferedSource.buffer().size());
+    assertEquals(2, source.size());
   }
 
   @Test public void requireIncludesBufferBytes() throws Exception {
@@ -117,8 +117,8 @@
     BufferedSource bufferedSource = new RealBufferedSource(source);
 
     bufferedSource.require(2);
-    assertEquals(Segment.SIZE, source.byteCount());
-    assertEquals(Segment.SIZE, bufferedSource.buffer().byteCount());
+    assertEquals(Segment.SIZE, source.size());
+    assertEquals(Segment.SIZE, bufferedSource.buffer().size());
   }
 
   @Test public void skipInsufficientData() throws Exception {
@@ -139,8 +139,8 @@
     source.writeUtf8(repeat('b', Segment.SIZE));
     BufferedSource bufferedSource = new RealBufferedSource(source);
     bufferedSource.skip(2);
-    assertEquals(Segment.SIZE, source.byteCount());
-    assertEquals(Segment.SIZE - 2, bufferedSource.buffer().byteCount());
+    assertEquals(Segment.SIZE, source.size());
+    assertEquals(Segment.SIZE - 2, bufferedSource.buffer().size());
   }
 
   @Test public void skipTracksBufferFirst() throws Exception {
@@ -151,8 +151,8 @@
     bufferedSource.buffer().writeUtf8("aa");
 
     bufferedSource.skip(2);
-    assertEquals(0, bufferedSource.buffer().byteCount());
-    assertEquals(2, source.byteCount());
+    assertEquals(0, bufferedSource.buffer().size());
+    assertEquals(2, source.size());
   }
 
   private String repeat(char c, int count) {
/Fim/
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index b935acb..9c7af9d 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -15,7 +15,7 @@
   <dependencies>
     <dependency>
       <groupId>com.squareup.okhttp</groupId>
-      <artifactId>okhttp-protocols</artifactId>
+      <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
/Fim/
diff --git a/okhttp-protocols/pom.xml b/okhttp-tests/pom.xml
similarity index 65%
rename from okhttp-protocols/pom.xml
rename to okhttp-tests/pom.xml
index 5febfcc..7c1573d 100644
--- a/okhttp-protocols/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -9,8 +9,8 @@
     <version>2.0.0-SNAPSHOT</version>
   </parent>
 
-  <artifactId>okhttp-protocols</artifactId>
-  <name>OkHttp SPDY and HTTP/2.0 internals</name>
+  <artifactId>okhttp-tests</artifactId>
+  <name>OkHttp Tests</name>
 
   <dependencies>
     <dependency>
@@ -19,14 +19,26 @@
       <version>${project.version}</version>
     </dependency>
     <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
       <groupId>org.mortbay.jetty.npn</groupId>
       <artifactId>npn-boot</artifactId>
-      <optional>true</optional>
+      <scope>provided</scope>
     </dependency>
+
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 </project>
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/AsyncApiTest.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/AsyncApiTest.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/DispatcherTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/DispatcherTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/MediaTypeTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/MediaTypeTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingReceiver.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/RecordingReceiver.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RequestTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/RequestTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/SyncApiTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/SyncApiTest.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/SyncApiTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/SyncApiTest.java
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java
similarity index 100%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
similarity index 100%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
similarity index 100%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
similarity index 100%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
similarity index 100%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
similarity index 100%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
similarity index 96%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
index 31df6d2..44459b8 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
@@ -39,7 +39,7 @@
     // WARNING: clash on flags between spdy/3 and http/2!
     assertEquals(-3, settings.getUploadBandwidth(-3));
     assertEquals(-1, settings.getHeaderTableSize());
-    settings.set(Settings.UPLOAD_BANDWIDTH, 0, 42);
+    settings.set(UPLOAD_BANDWIDTH, 0, 42);
     assertEquals(42, settings.getUploadBandwidth(-3));
     settings.set(Settings.HEADER_TABLE_SIZE, 0, 8096);
     assertEquals(8096, settings.getHeaderTableSize());
@@ -47,7 +47,7 @@
     // WARNING: clash on flags between spdy/3 and http/2!
     assertEquals(-3, settings.getDownloadBandwidth(-3));
     assertEquals(true, settings.getEnablePush(true));
-    settings.set(Settings.DOWNLOAD_BANDWIDTH, 0, 53);
+    settings.set(DOWNLOAD_BANDWIDTH, 0, 53);
     assertEquals(53, settings.getDownloadBandwidth(-3));
     settings.set(Settings.ENABLE_PUSH, 0, 0);
     assertEquals(false, settings.getEnablePush(true));
@@ -57,7 +57,7 @@
     assertEquals(64, settings.getRoundTripTime(-3));
 
     assertEquals(-3, settings.getMaxConcurrentStreams(-3));
-    settings.set(Settings.MAX_CONCURRENT_STREAMS, 0, 75);
+    settings.set(MAX_CONCURRENT_STREAMS, 0, 75);
     assertEquals(75, settings.getMaxConcurrentStreams(-3));
 
     assertEquals(-3, settings.getCurrentCwnd(-3));
@@ -65,7 +65,7 @@
     assertEquals(86, settings.getCurrentCwnd(-3));
 
     assertEquals(-3, settings.getDownloadRetransRate(-3));
-    settings.set(Settings.DOWNLOAD_RETRANS_RATE, 0, 97);
+    settings.set(DOWNLOAD_RETRANS_RATE, 0, 97);
     assertEquals(97, settings.getDownloadRetransRate(-3));
 
     assertEquals(-1, settings.getInitialWindowSize());
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
similarity index 100%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
/Fim/
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
similarity index 100%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java
/Fim/
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java
/Fim/
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 7c4bb25..ecb1705 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -23,23 +23,6 @@
       <artifactId>okhttp-protocols</artifactId>
       <version>${project.version}</version>
     </dependency>
-    <dependency>
-      <groupId>org.mortbay.jetty.npn</groupId>
-      <artifactId>npn-boot</artifactId>
-      <scope>provided</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
   </dependencies>
 
   <build>
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java
rename to okhttp/src/main/java/com/squareup/okhttp/Protocol.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/BitArray.java b/okhttp/src/main/java/com/squareup/okhttp/internal/BitArray.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/BitArray.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/BitArray.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java b/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Header.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
/Fim/
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
/Fim/
diff --git a/pom.xml b/pom.xml
index c00fc46..2216c73 100644
--- a/pom.xml
+++ b/pom.xml
@@ -21,7 +21,7 @@
   <modules>
     <module>okhttp</module>
     <module>okhttp-apache</module>
-    <module>okhttp-protocols</module>
+    <module>okhttp-tests</module>
     <module>okcurl</module>
     <module>okio</module>
     <module>mockwebserver</module>
/Fim/
diff --git a/okio/src/main/java/okio/RealBufferedSink.java b/okio/src/main/java/okio/RealBufferedSink.java
index 4f484c2..f335a23 100644
--- a/okio/src/main/java/okio/RealBufferedSink.java
+++ b/okio/src/main/java/okio/RealBufferedSink.java
@@ -129,25 +129,25 @@
   @Override public void close() throws IOException {
     if (closed) return;
 
-    // If flushing throws, we still need to close the stream!
+    // Emit buffered data to the underlying sink. If this fails, we still need
+    // to close the sink; otherwise we risk leaking resources.
     Throwable thrown = null;
     try {
       if (buffer.size > 0) {
         sink.write(buffer, buffer.size);
       }
-    } catch (IOException e) {
-      thrown = e;
-    } catch (RuntimeException e) {
+    } catch (Throwable e) {
       thrown = e;
     }
 
-    sink.close();
+    try {
+      sink.close();
+    } catch (Throwable e) {
+      if (thrown == null) thrown = e;
+    }
     closed = true;
 
-    if (thrown != null) {
-      if (thrown instanceof IOException) throw (IOException) thrown;
-      else throw (RuntimeException) thrown;
-    }
+    if (thrown != null) Util.sneakyRethrow(thrown);
   }
 
   @Override public Sink deadline(Deadline deadline) {
/Fim/
diff --git a/okio/src/main/java/okio/Util.java b/okio/src/main/java/okio/Util.java
index a2bada2..e5c1ddc 100644
--- a/okio/src/main/java/okio/Util.java
+++ b/okio/src/main/java/okio/Util.java
@@ -42,4 +42,18 @@
         |  (i & 0x0000ff00) << 8
         |  (i & 0x000000ff) << 24;
   }
+
+  /**
+   * Throws {@code t}, even if the declared throws clause doesn't permit it.
+   * This is a terrible  but terribly convenient  hack that makes it easy to
+   * catch and rethrow exceptions after cleanup. See Java Puzzlers #43.
+   */
+  public static void sneakyRethrow(Throwable t) {
+    Util.<Error>sneakyThrow2(t);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T extends Throwable> void sneakyThrow2(Throwable t) throws T {
+    throw (T) t;
+  }
 }
/Fim/
diff --git a/okio/src/test/java/okio/RealBufferedSinkTest.java b/okio/src/test/java/okio/RealBufferedSinkTest.java
index 195e283..bc83b0b 100644
--- a/okio/src/test/java/okio/RealBufferedSinkTest.java
+++ b/okio/src/test/java/okio/RealBufferedSinkTest.java
@@ -17,7 +17,11 @@
 
 import java.io.IOException;
 import java.io.OutputStream;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
 import org.junit.Test;
 
 import static okio.Util.UTF_8;
@@ -109,9 +113,97 @@
     assertEquals(Segment.SIZE * 2, sink.size());
   }
 
+  @Test public void closeEmitsBufferedBytes() throws IOException {
+    OkBuffer sink = new OkBuffer();
+    BufferedSink bufferedSink = new RealBufferedSink(sink);
+    bufferedSink.writeByte('a');
+    bufferedSink.close();
+    assertEquals('a', sink.readByte());
+  }
+
+  @Test public void closeWithExceptionWhenWriting() throws IOException {
+    MockSink mockSink = new MockSink();
+    mockSink.scheduleThrow(0, new IOException());
+    BufferedSink bufferedSink = new RealBufferedSink(mockSink);
+    bufferedSink.writeByte('a');
+    try {
+      bufferedSink.close();
+      fail();
+    } catch (IOException expected) {
+    }
+    mockSink.assertLog("write(OkBuffer[size=1 data=61], 1)", "close()");
+  }
+
+  @Test public void closeWithExceptionWhenClosing() throws IOException {
+    MockSink mockSink = new MockSink();
+    mockSink.scheduleThrow(1, new IOException());
+    BufferedSink bufferedSink = new RealBufferedSink(mockSink);
+    bufferedSink.writeByte('a');
+    try {
+      bufferedSink.close();
+      fail();
+    } catch (IOException expected) {
+    }
+    mockSink.assertLog("write(OkBuffer[size=1 data=61], 1)", "close()");
+  }
+
+  @Test public void closeWithExceptionWhenWritingAndClosing() throws IOException {
+    MockSink mockSink = new MockSink();
+    mockSink.scheduleThrow(0, new IOException("first"));
+    mockSink.scheduleThrow(1, new IOException("second"));
+    BufferedSink bufferedSink = new RealBufferedSink(mockSink);
+    bufferedSink.writeByte('a');
+    try {
+      bufferedSink.close();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("first", expected.getMessage());
+    }
+    mockSink.assertLog("write(OkBuffer[size=1 data=61], 1)", "close()");
+  }
+
   private String repeat(char c, int count) {
     char[] array = new char[count];
     Arrays.fill(array, c);
     return new String(array);
   }
+
+  /** A scriptable sink. Like Mockito, but worse and requiring less configuration. */
+  private static class MockSink implements Sink {
+    private final List<String> log = new ArrayList<String>();
+    private final Map<Integer, IOException> callThrows = new LinkedHashMap<Integer, IOException>();
+
+    public void assertLog(String... messages) {
+      assertEquals(Arrays.asList(messages), log);
+    }
+
+    public void scheduleThrow(int call, IOException e) {
+      callThrows.put(call, e);
+    }
+
+    private void throwIfScheduled() throws IOException {
+      IOException exception = callThrows.get(log.size() - 1);
+      if (exception != null) throw exception;
+    }
+
+    @Override public void write(OkBuffer source, long byteCount) throws IOException {
+      log.add("write(" + source + ", " + byteCount + ")");
+      throwIfScheduled();
+    }
+
+    @Override public void flush() throws IOException {
+      log.add("flush()");
+      throwIfScheduled();
+    }
+
+    @Override public Sink deadline(Deadline deadline) {
+      log.add("deadline()");
+      return this;
+    }
+
+    @Override public void close() throws IOException {
+      log.add("close()");
+      throwIfScheduled();
+    }
+  }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
index ee5d2df..f96c2aa 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -57,6 +57,8 @@
   /**
    * {@code data.length} may be longer than the max length of the variant's data frame.
    * Implementations must send multiple frames as necessary.
+   *
+   * @param source the buffer to draw bytes from. May be null if byteCount is 0.
    */
   void data(boolean outFinished, int streamId, OkBuffer source, int byteCount) throws IOException;
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index 8f43890..a88b747 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -401,10 +401,12 @@
       dataFrame(streamId, flags, source, byteCount);
     }
 
-    void dataFrame(int streamId, byte flags, OkBuffer buffer, int length) throws IOException {
+    void dataFrame(int streamId, byte flags, OkBuffer buffer, int byteCount) throws IOException {
       byte type = TYPE_DATA;
-      frameHeader(length, type, flags, streamId);
-      sink.write(buffer, length);
+      frameHeader(byteCount, type, flags, streamId);
+      if (byteCount > 0) {
+        sink.write(buffer, byteCount);
+      }
     }
 
     @Override public synchronized void settings(Settings settings) throws IOException {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index 799efae..a71bc6f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -407,7 +407,9 @@
       }
       sink.writeInt(streamId & 0x7fffffff);
       sink.writeInt((flags & 0xff) << 24 | byteCount & 0xffffff);
-      sink.write(buffer, byteCount);
+      if (byteCount > 0) {
+        sink.write(buffer, byteCount);
+      }
     }
 
     private void writeNameValueBlockToBuffer(List<Header> headerBlock) throws IOException {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index f5e3200..b5cb418 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -61,7 +61,7 @@
   private List<Header> responseHeaders;
 
   private final SpdyDataSource source;
-  final SpdyDataOutputStream sink;
+  final SpdyDataSink sink;
 
   /**
    * The reason why this stream was abnormally closed. If there are multiple
@@ -78,7 +78,7 @@
     this.connection = connection;
     this.bytesLeftInWriteWindow = connection.peerSettings.getInitialWindowSize();
     this.source = new SpdyDataSource(connection.okHttpSettings.getInitialWindowSize());
-    this.sink = new SpdyDataOutputStream();
+    this.sink = new SpdyDataSink();
     this.source.finished = inFinished;
     this.sink.finished = outFinished;
     this.priority = priority;
@@ -501,12 +501,11 @@
   }
 
   /**
-   * An output stream that writes outgoing data frames of a stream. This class
-   * is not thread safe.
+   * A sink that writes outgoing data frames of a stream. This class is not
+   * thread safe.
    */
-  final class SpdyDataOutputStream implements Sink {
+  final class SpdyDataSink implements Sink {
     private boolean closed;
-    private final OkBuffer buffer = new OkBuffer();
 
     /**
      * True if either side has cleanly shut down this stream. We shall send
@@ -516,50 +515,6 @@
 
     @Override public void write(OkBuffer source, long byteCount) throws IOException {
       assert (!Thread.holdsLock(SpdyStream.this));
-      synchronized (SpdyStream.this) {
-        checkOutNotClosed();
-      }
-
-      buffer.write(source, byteCount);
-      writeFrame(false, buffer.completeSegmentByteCount());
-    }
-
-    @Override public void flush() throws IOException {
-      assert (!Thread.holdsLock(SpdyStream.this));
-      synchronized (SpdyStream.this) {
-        checkOutNotClosed();
-      }
-      writeFrame(false, buffer.size());
-      connection.flush();
-    }
-
-    @Override public Sink deadline(Deadline deadline) {
-      // TODO: honor deadlines.
-      return this;
-    }
-
-    @Override public void close() throws IOException {
-      assert (!Thread.holdsLock(SpdyStream.this));
-      synchronized (SpdyStream.this) {
-        if (closed) return;
-      }
-      if (!sink.finished) {
-        writeFrame(true, buffer.size());
-      }
-      synchronized (SpdyStream.this) {
-        closed = true;
-      }
-      connection.flush();
-      cancelStreamIfNecessary();
-    }
-
-    private void writeFrame(boolean outFinished, long byteCount) throws IOException {
-      assert (!Thread.holdsLock(SpdyStream.this));
-      if (byteCount == 0 && outFinished) { // Empty data frames are not flow-controlled.
-        connection.writeData(id, true, buffer, 0);
-        return;
-      }
-
       while (byteCount > 0) {
         long toWrite;
         synchronized (SpdyStream.this) {
@@ -577,9 +532,37 @@
         }
 
         byteCount -= toWrite;
-        connection.writeData(id, outFinished && byteCount == 0, buffer, toWrite);
+        connection.writeData(id, false, source, toWrite);
       }
     }
+
+    @Override public void flush() throws IOException {
+      assert (!Thread.holdsLock(SpdyStream.this));
+      synchronized (SpdyStream.this) {
+        checkOutNotClosed();
+      }
+      connection.flush();
+    }
+
+    @Override public Sink deadline(Deadline deadline) {
+      // TODO: honor deadlines.
+      return this;
+    }
+
+    @Override public void close() throws IOException {
+      assert (!Thread.holdsLock(SpdyStream.this));
+      synchronized (SpdyStream.this) {
+        if (closed) return;
+      }
+      if (!sink.finished) {
+        connection.writeData(id, true, null, 0);
+      }
+      synchronized (SpdyStream.this) {
+        closed = true;
+      }
+      connection.flush();
+      cancelStreamIfNecessary();
+    }
   }
 
   /**
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index abb65bb..26d161c 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -622,6 +622,33 @@
   }
 
   /**
+   * When a pooled connection fails, don't blame the route. Otherwise pooled
+   * connection failures can cause unnecessary SSL fallbacks.
+   *
+   * https://github.com/square/okhttp/issues/515
+   */
+  @Test public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    assertContent("abc", client.open(server.getUrl("/")));
+    assertContent("def", client.open(server.getUrl("/")));
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("TLSv1", request1.getSslProtocol()); // OkHttp's current best TLS version.
+
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("TLSv1", request2.getSslProtocol()); // OkHttp's current best TLS version.
+  }
+
+  /**
    * Verify that we don't retry connections on certificate verification errors.
    *
    * http://code.google.com/p/android/issues/detail?id=13178
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index a16da2c..d9115a9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -80,6 +80,7 @@
   private int httpMinorVersion = 1; // Assume HTTP/1.1
   private long idleStartTimeNs;
   private Handshake handshake;
+  private int recycleCount;
 
   public Connection(ConnectionPool pool, Route route) {
     this.pool = pool;
@@ -301,6 +302,18 @@
     socket.setSoTimeout(newTimeout);
   }
 
+  public void incrementRecycleCount() {
+    recycleCount++;
+  }
+
+  /**
+   * Returns the number of times this connection has been returned to the
+   * connection pool.
+   */
+  public int recycleCount() {
+    return recycleCount;
+  }
+
   /**
    * To make an HTTPS connection over an HTTP proxy, send an unencrypted
    * CONNECT request to create the proxy connection. This may need to be
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
index 0b922fc..24ab543 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
@@ -234,6 +234,7 @@
 
     synchronized (this) {
       connections.addFirst(connection);
+      connection.incrementRecycleCount();
       connection.resetIdleStartTime();
     }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
index 21f54e0..f935d5c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
@@ -144,6 +144,9 @@
    * failure on a connection returned by this route selector.
    */
   public void connectFailed(Connection connection, IOException failure) {
+    // If this is a recycled connection, don't count its failure against the route.
+    if (connection.recycleCount() > 0) return;
+
     Route failedRoute = connection.getRoute();
     if (failedRoute.getProxy().type() != Proxy.Type.DIRECT && proxySelector != null) {
       // Tell the proxy selector when we fail to connect on a fresh connection.
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/DelegatingHttpsURLConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/DelegatingHttpsURLConnection.java
new file mode 100644
index 0000000..fedf115
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/DelegatingHttpsURLConnection.java
@@ -0,0 +1,292 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Handshake;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.ProtocolException;
+import java.net.URL;
+import java.security.Permission;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.util.List;
+import java.util.Map;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocketFactory;
+
+/**
+ * Implement an HTTPS connection by delegating to an HTTP connection for
+ * everything but the HTTPS-specific stuff.
+ */
+abstract class DelegatingHttpsURLConnection extends HttpsURLConnection {
+  private final HttpURLConnection delegate;
+
+  public DelegatingHttpsURLConnection(HttpURLConnection delegate) {
+    super(delegate.getURL());
+    this.delegate = delegate;
+  }
+
+  protected abstract Handshake handshake();
+
+  @Override public abstract void setHostnameVerifier(HostnameVerifier hostnameVerifier);
+
+  @Override public abstract HostnameVerifier getHostnameVerifier();
+
+  @Override public abstract void setSSLSocketFactory(SSLSocketFactory sslSocketFactory);
+
+  @Override public abstract SSLSocketFactory getSSLSocketFactory();
+
+  @Override public String getCipherSuite() {
+    Handshake handshake = handshake();
+    return handshake != null ? handshake.cipherSuite() : null;
+  }
+
+  @Override public Certificate[] getLocalCertificates() {
+    Handshake handshake = handshake();
+    if (handshake == null) return null;
+    List<Certificate> result = handshake.localCertificates();
+    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
+  }
+
+  @Override public Certificate[] getServerCertificates() throws SSLPeerUnverifiedException {
+    Handshake handshake = handshake();
+    if (handshake == null) return null;
+    List<Certificate> result = handshake.peerCertificates();
+    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
+  }
+
+  @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
+    Handshake handshake = handshake();
+    return handshake != null ? handshake.peerPrincipal() : null;
+  }
+
+  @Override public Principal getLocalPrincipal() {
+    Handshake handshake = handshake();
+    return handshake != null ? handshake.localPrincipal() : null;
+  }
+
+  @Override public void connect() throws IOException {
+    connected = true;
+    delegate.connect();
+  }
+
+  @Override public void disconnect() {
+    delegate.disconnect();
+  }
+
+  @Override public InputStream getErrorStream() {
+    return delegate.getErrorStream();
+  }
+
+  @Override public String getRequestMethod() {
+    return delegate.getRequestMethod();
+  }
+
+  @Override public int getResponseCode() throws IOException {
+    return delegate.getResponseCode();
+  }
+
+  @Override public String getResponseMessage() throws IOException {
+    return delegate.getResponseMessage();
+  }
+
+  @Override public void setRequestMethod(String method) throws ProtocolException {
+    delegate.setRequestMethod(method);
+  }
+
+  @Override public boolean usingProxy() {
+    return delegate.usingProxy();
+  }
+
+  @Override public boolean getInstanceFollowRedirects() {
+    return delegate.getInstanceFollowRedirects();
+  }
+
+  @Override public void setInstanceFollowRedirects(boolean followRedirects) {
+    delegate.setInstanceFollowRedirects(followRedirects);
+  }
+
+  @Override public boolean getAllowUserInteraction() {
+    return delegate.getAllowUserInteraction();
+  }
+
+  @Override public Object getContent() throws IOException {
+    return delegate.getContent();
+  }
+
+  @SuppressWarnings("unchecked") // Spec does not generify
+  @Override public Object getContent(Class[] types) throws IOException {
+    return delegate.getContent(types);
+  }
+
+  @Override public String getContentEncoding() {
+    return delegate.getContentEncoding();
+  }
+
+  @Override public int getContentLength() {
+    return delegate.getContentLength();
+  }
+
+  @Override public String getContentType() {
+    return delegate.getContentType();
+  }
+
+  @Override public long getDate() {
+    return delegate.getDate();
+  }
+
+  @Override public boolean getDefaultUseCaches() {
+    return delegate.getDefaultUseCaches();
+  }
+
+  @Override public boolean getDoInput() {
+    return delegate.getDoInput();
+  }
+
+  @Override public boolean getDoOutput() {
+    return delegate.getDoOutput();
+  }
+
+  @Override public long getExpiration() {
+    return delegate.getExpiration();
+  }
+
+  @Override public String getHeaderField(int pos) {
+    return delegate.getHeaderField(pos);
+  }
+
+  @Override public Map<String, List<String>> getHeaderFields() {
+    return delegate.getHeaderFields();
+  }
+
+  @Override public Map<String, List<String>> getRequestProperties() {
+    return delegate.getRequestProperties();
+  }
+
+  @Override public void addRequestProperty(String field, String newValue) {
+    delegate.addRequestProperty(field, newValue);
+  }
+
+  @Override public String getHeaderField(String key) {
+    return delegate.getHeaderField(key);
+  }
+
+  @Override public long getHeaderFieldDate(String field, long defaultValue) {
+    return delegate.getHeaderFieldDate(field, defaultValue);
+  }
+
+  @Override public int getHeaderFieldInt(String field, int defaultValue) {
+    return delegate.getHeaderFieldInt(field, defaultValue);
+  }
+
+  @Override public String getHeaderFieldKey(int position) {
+    return delegate.getHeaderFieldKey(position);
+  }
+
+  @Override public long getIfModifiedSince() {
+    return delegate.getIfModifiedSince();
+  }
+
+  @Override public InputStream getInputStream() throws IOException {
+    return delegate.getInputStream();
+  }
+
+  @Override public long getLastModified() {
+    return delegate.getLastModified();
+  }
+
+  @Override public OutputStream getOutputStream() throws IOException {
+    return delegate.getOutputStream();
+  }
+
+  @Override public Permission getPermission() throws IOException {
+    return delegate.getPermission();
+  }
+
+  @Override public String getRequestProperty(String field) {
+    return delegate.getRequestProperty(field);
+  }
+
+  @Override public URL getURL() {
+    return delegate.getURL();
+  }
+
+  @Override public boolean getUseCaches() {
+    return delegate.getUseCaches();
+  }
+
+  @Override public void setAllowUserInteraction(boolean newValue) {
+    delegate.setAllowUserInteraction(newValue);
+  }
+
+  @Override public void setDefaultUseCaches(boolean newValue) {
+    delegate.setDefaultUseCaches(newValue);
+  }
+
+  @Override public void setDoInput(boolean newValue) {
+    delegate.setDoInput(newValue);
+  }
+
+  @Override public void setDoOutput(boolean newValue) {
+    delegate.setDoOutput(newValue);
+  }
+
+  @Override public void setIfModifiedSince(long newValue) {
+    delegate.setIfModifiedSince(newValue);
+  }
+
+  @Override public void setRequestProperty(String field, String newValue) {
+    delegate.setRequestProperty(field, newValue);
+  }
+
+  @Override public void setUseCaches(boolean newValue) {
+    delegate.setUseCaches(newValue);
+  }
+
+  @Override public void setConnectTimeout(int timeoutMillis) {
+    delegate.setConnectTimeout(timeoutMillis);
+  }
+
+  @Override public int getConnectTimeout() {
+    return delegate.getConnectTimeout();
+  }
+
+  @Override public void setReadTimeout(int timeoutMillis) {
+    delegate.setReadTimeout(timeoutMillis);
+  }
+
+  @Override public int getReadTimeout() {
+    return delegate.getReadTimeout();
+  }
+
+  @Override public String toString() {
+    return delegate.toString();
+  }
+
+  @Override public void setFixedLengthStreamingMode(int contentLength) {
+    delegate.setFixedLengthStreamingMode(contentLength);
+  }
+
+  @Override public void setChunkedStreamingMode(int chunkLength) {
+    delegate.setChunkedStreamingMode(chunkLength);
+  }
+}
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
index 827ebd7..358ec95 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
@@ -18,61 +18,23 @@
 
 import com.squareup.okhttp.Handshake;
 import com.squareup.okhttp.OkHttpClient;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.ProtocolException;
 import java.net.URL;
-import java.security.Permission;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.util.List;
-import java.util.Map;
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
 
-public final class HttpsURLConnectionImpl extends HttpsURLConnection {
-
-  /** Reuse HttpURLConnectionImpl. */
+public final class HttpsURLConnectionImpl extends DelegatingHttpsURLConnection {
   private final HttpURLConnectionImpl delegate;
 
   public HttpsURLConnectionImpl(URL url, OkHttpClient client) {
-    super(url);
-    delegate = new HttpURLConnectionImpl(url, client);
+    this(new HttpURLConnectionImpl(url, client));
   }
 
-  @Override public String getCipherSuite() {
-    Handshake handshake = handshake();
-    return handshake != null ? handshake.cipherSuite() : null;
+  public HttpsURLConnectionImpl(HttpURLConnectionImpl delegate) {
+    super(delegate);
+    this.delegate = delegate;
   }
 
-  @Override public Certificate[] getLocalCertificates() {
-    Handshake handshake = handshake();
-    if (handshake == null) return null;
-    List<Certificate> result = handshake.localCertificates();
-    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
-  }
-
-  @Override public Certificate[] getServerCertificates() throws SSLPeerUnverifiedException {
-    Handshake handshake = handshake();
-    if (handshake == null) return null;
-    List<Certificate> result = handshake.peerCertificates();
-    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
-  }
-
-  @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-    Handshake handshake = handshake();
-    return handshake != null ? handshake.peerPrincipal() : null;
-  }
-
-  @Override public Principal getLocalPrincipal() {
-    Handshake handshake = handshake();
-    return handshake != null ? handshake.localPrincipal() : null;
-  }
-
-  private Handshake handshake() {
+  @Override protected Handshake handshake() {
     if (delegate.httpEngine == null) {
       throw new IllegalStateException("Connection has not yet been established");
     }
@@ -85,212 +47,6 @@
         : delegate.handshake;
   }
 
-  @Override public void disconnect() {
-    delegate.disconnect();
-  }
-
-  @Override public InputStream getErrorStream() {
-    return delegate.getErrorStream();
-  }
-
-  @Override public String getRequestMethod() {
-    return delegate.getRequestMethod();
-  }
-
-  @Override public int getResponseCode() throws IOException {
-    return delegate.getResponseCode();
-  }
-
-  @Override public String getResponseMessage() throws IOException {
-    return delegate.getResponseMessage();
-  }
-
-  @Override public void setRequestMethod(String method) throws ProtocolException {
-    delegate.setRequestMethod(method);
-  }
-
-  @Override public boolean usingProxy() {
-    return delegate.usingProxy();
-  }
-
-  @Override public boolean getInstanceFollowRedirects() {
-    return delegate.getInstanceFollowRedirects();
-  }
-
-  @Override public void setInstanceFollowRedirects(boolean followRedirects) {
-    delegate.setInstanceFollowRedirects(followRedirects);
-  }
-
-  @Override public void connect() throws IOException {
-    connected = true;
-    delegate.connect();
-  }
-
-  @Override public boolean getAllowUserInteraction() {
-    return delegate.getAllowUserInteraction();
-  }
-
-  @Override public Object getContent() throws IOException {
-    return delegate.getContent();
-  }
-
-  @SuppressWarnings("unchecked") // Spec does not generify
-  @Override public Object getContent(Class[] types) throws IOException {
-    return delegate.getContent(types);
-  }
-
-  @Override public String getContentEncoding() {
-    return delegate.getContentEncoding();
-  }
-
-  @Override public int getContentLength() {
-    return delegate.getContentLength();
-  }
-
-  @Override public String getContentType() {
-    return delegate.getContentType();
-  }
-
-  @Override public long getDate() {
-    return delegate.getDate();
-  }
-
-  @Override public boolean getDefaultUseCaches() {
-    return delegate.getDefaultUseCaches();
-  }
-
-  @Override public boolean getDoInput() {
-    return delegate.getDoInput();
-  }
-
-  @Override public boolean getDoOutput() {
-    return delegate.getDoOutput();
-  }
-
-  @Override public long getExpiration() {
-    return delegate.getExpiration();
-  }
-
-  @Override public String getHeaderField(int pos) {
-    return delegate.getHeaderField(pos);
-  }
-
-  @Override public Map<String, List<String>> getHeaderFields() {
-    return delegate.getHeaderFields();
-  }
-
-  @Override public Map<String, List<String>> getRequestProperties() {
-    return delegate.getRequestProperties();
-  }
-
-  @Override public void addRequestProperty(String field, String newValue) {
-    delegate.addRequestProperty(field, newValue);
-  }
-
-  @Override public String getHeaderField(String key) {
-    return delegate.getHeaderField(key);
-  }
-
-  @Override public long getHeaderFieldDate(String field, long defaultValue) {
-    return delegate.getHeaderFieldDate(field, defaultValue);
-  }
-
-  @Override public int getHeaderFieldInt(String field, int defaultValue) {
-    return delegate.getHeaderFieldInt(field, defaultValue);
-  }
-
-  @Override public String getHeaderFieldKey(int position) {
-    return delegate.getHeaderFieldKey(position);
-  }
-
-  @Override public long getIfModifiedSince() {
-    return delegate.getIfModifiedSince();
-  }
-
-  @Override public InputStream getInputStream() throws IOException {
-    return delegate.getInputStream();
-  }
-
-  @Override public long getLastModified() {
-    return delegate.getLastModified();
-  }
-
-  @Override public OutputStream getOutputStream() throws IOException {
-    return delegate.getOutputStream();
-  }
-
-  @Override public Permission getPermission() throws IOException {
-    return delegate.getPermission();
-  }
-
-  @Override public String getRequestProperty(String field) {
-    return delegate.getRequestProperty(field);
-  }
-
-  @Override public URL getURL() {
-    return delegate.getURL();
-  }
-
-  @Override public boolean getUseCaches() {
-    return delegate.getUseCaches();
-  }
-
-  @Override public void setAllowUserInteraction(boolean newValue) {
-    delegate.setAllowUserInteraction(newValue);
-  }
-
-  @Override public void setDefaultUseCaches(boolean newValue) {
-    delegate.setDefaultUseCaches(newValue);
-  }
-
-  @Override public void setDoInput(boolean newValue) {
-    delegate.setDoInput(newValue);
-  }
-
-  @Override public void setDoOutput(boolean newValue) {
-    delegate.setDoOutput(newValue);
-  }
-
-  @Override public void setIfModifiedSince(long newValue) {
-    delegate.setIfModifiedSince(newValue);
-  }
-
-  @Override public void setRequestProperty(String field, String newValue) {
-    delegate.setRequestProperty(field, newValue);
-  }
-
-  @Override public void setUseCaches(boolean newValue) {
-    delegate.setUseCaches(newValue);
-  }
-
-  @Override public void setConnectTimeout(int timeoutMillis) {
-    delegate.setConnectTimeout(timeoutMillis);
-  }
-
-  @Override public int getConnectTimeout() {
-    return delegate.getConnectTimeout();
-  }
-
-  @Override public void setReadTimeout(int timeoutMillis) {
-    delegate.setReadTimeout(timeoutMillis);
-  }
-
-  @Override public int getReadTimeout() {
-    return delegate.getReadTimeout();
-  }
-
-  @Override public String toString() {
-    return delegate.toString();
-  }
-
-  @Override public void setFixedLengthStreamingMode(int contentLength) {
-    delegate.setFixedLengthStreamingMode(contentLength);
-  }
-
-  @Override public void setChunkedStreamingMode(int chunkLength) {
-    delegate.setChunkedStreamingMode(chunkLength);
-  }
-
   @Override public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
     delegate.client.setHostnameVerifier(hostnameVerifier);
   }
@@ -307,14 +63,14 @@
     return delegate.client.getSslSocketFactory();
   }
 
-  @Override public void setFixedLengthStreamingMode(long contentLength) {
-    delegate.setFixedLengthStreamingMode(contentLength);
-  }
-
   @Override public long getContentLengthLong() {
     return delegate.getContentLengthLong();
   }
 
+  @Override public void setFixedLengthStreamingMode(long contentLength) {
+    delegate.setFixedLengthStreamingMode(contentLength);
+  }
+
   @Override public long getHeaderFieldLong(String field, long defaultValue) {
     return delegate.getHeaderFieldLong(field, defaultValue);
   }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseCacheAdapter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseCacheAdapter.java
index 7c4ade4..381b8cf 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseCacheAdapter.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseCacheAdapter.java
@@ -22,7 +22,6 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseSource;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -33,16 +32,11 @@
 import java.net.ResponseCache;
 import java.net.SecureCacheResponse;
 import java.net.URI;
-import java.net.URL;
-import java.security.Permission;
-import java.security.Principal;
 import java.security.cert.Certificate;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
 
@@ -159,7 +153,7 @@
     Request request = okResponse.request();
     // Create an object of the correct class in case the ResponseCache uses instanceof.
     if (request.isHttps()) {
-      return new CacheHttpsURLConnection(okResponse);
+      return new CacheHttpsURLConnection(new CacheHttpURLConnection(okResponse));
     } else {
       return new CacheHttpURLConnection(okResponse);
     }
@@ -497,368 +491,48 @@
     public void setDefaultUseCaches(boolean defaultUseCaches) {
       super.setDefaultUseCaches(defaultUseCaches);
     }
-
   }
 
-  /**
-   * An HttpsURLConnection to offer to the cache. HttpsURLConnection is concrete; rather than
-   * completely duplicate CacheHttpURLConnection all methods that can be are delegated to a
-   * CacheHttpURLConnection instead. The intent is that all real logic (besides HTTPS-specific
-   * calls) exists in CacheHttpURLConnection.
-   */
-  private static final class CacheHttpsURLConnection extends HttpsURLConnection {
-
+  /** An HttpsURLConnection to offer to the cache. */
+  private static final class CacheHttpsURLConnection extends DelegatingHttpsURLConnection {
     private final CacheHttpURLConnection delegate;
-    private final Response response;
 
-    public CacheHttpsURLConnection(Response response) {
-      super(response.request().url());
-      this.response = response;
-      this.delegate = new CacheHttpURLConnection(response);
+    public CacheHttpsURLConnection(CacheHttpURLConnection delegate) {
+      super(delegate);
+      this.delegate = delegate;
     }
 
-    // HttpsURLConnection methods.
-
-    @Override
-    public String getCipherSuite() {
-      if (response == null || response.handshake() == null) {
-        return null;
-      }
-      return response.handshake().cipherSuite();
+    @Override protected Handshake handshake() {
+      return delegate.response.handshake();
     }
 
-    @Override
-    public Certificate[] getLocalCertificates() {
-      if (response == null || response.handshake() == null) {
-        return null;
-      }
-      List<Certificate> localCertificates = response.handshake().localCertificates();
-      if (localCertificates == null || localCertificates.size() == 0) {
-        return null;
-      }
-      return localCertificates.toArray(new Certificate[localCertificates.size()]);
-    }
-
-    @Override
-    public Certificate[] getServerCertificates() throws SSLPeerUnverifiedException {
-      if (response == null || response.handshake() == null) {
-        return null;
-      }
-      List<Certificate> peerCertificates = response.handshake().peerCertificates();
-      if (peerCertificates == null || peerCertificates.size() == 0) {
-        return null;
-      }
-      return peerCertificates.toArray(new Certificate[peerCertificates.size()]);
-    }
-
-    @Override
-    public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-      if (response == null || response.handshake() == null) {
-        return null;
-      }
-      return response.handshake().peerPrincipal();
-    }
-
-    @Override
-    public Principal getLocalPrincipal() {
-      if (response == null || response.handshake() == null) {
-        return null;
-      }
-      return response.handshake().localPrincipal();
-    }
-
-    @Override
-    public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
+    @Override public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
       throw throwRequestModificationException();
     }
 
-    @Override
-    public HostnameVerifier getHostnameVerifier() {
+    @Override public HostnameVerifier getHostnameVerifier() {
       throw throwRequestSslAccessException();
     }
 
-    @Override
-    public void setSSLSocketFactory(SSLSocketFactory socketFactory) {
+    @Override public void setSSLSocketFactory(SSLSocketFactory socketFactory) {
       throw throwRequestModificationException();
     }
 
-    @Override
-    public SSLSocketFactory getSSLSocketFactory() {
+    @Override public SSLSocketFactory getSSLSocketFactory() {
       throw throwRequestSslAccessException();
     }
 
-    // Delegated methods.
-
-    @Override
-    public void connect() throws IOException {
-      delegate.connect();
-    }
-
-    @Override
-    public void disconnect() {
-      delegate.disconnect();
-    }
-
-    @Override
-    public void setRequestProperty(String key, String value) {
-      delegate.setRequestProperty(key, value);
-    }
-
-    @Override
-    public void addRequestProperty(String key, String value) {
-      delegate.addRequestProperty(key, value);
-    }
-
-    @Override
-    public String getRequestProperty(String key) {
-      return delegate.getRequestProperty(key);
-    }
-
-    @Override
-    public Map<String, List<String>> getRequestProperties() {
-      return delegate.getRequestProperties();
-    }
-
-    @Override
-    public void setFixedLengthStreamingMode(int contentLength) {
-      delegate.setFixedLengthStreamingMode(contentLength);
-    }
-
-    @Override
-    public void setFixedLengthStreamingMode(long contentLength) {
-      delegate.setFixedLengthStreamingMode(contentLength);
-    }
-
-    @Override
-    public void setChunkedStreamingMode(int chunkLength) {
-      delegate.setChunkedStreamingMode(chunkLength);
-    }
-
-    @Override
-    public void setInstanceFollowRedirects(boolean followRedirects) {
-      delegate.setInstanceFollowRedirects(followRedirects);
-    }
-
-    @Override
-    public boolean getInstanceFollowRedirects() {
-      return delegate.getInstanceFollowRedirects();
-    }
-
-    @Override
-    public void setRequestMethod(String method) throws ProtocolException {
-      delegate.setRequestMethod(method);
-    }
-
-    @Override
-    public String getRequestMethod() {
-      return delegate.getRequestMethod();
-    }
-
-    @Override
-    public String getHeaderFieldKey(int position) {
-      return delegate.getHeaderFieldKey(position);
-    }
-
-    @Override
-    public String getHeaderField(int position) {
-      return delegate.getHeaderField(position);
-    }
-
-    @Override
-    public String getHeaderField(String fieldName) {
-      return delegate.getHeaderField(fieldName);
-    }
-
-    @Override
-    public int getResponseCode() throws IOException {
-      return delegate.getResponseCode();
-    }
-
-    @Override
-    public String getResponseMessage() throws IOException {
-      return delegate.getResponseMessage();
-    }
-
-    @Override
-    public InputStream getErrorStream() {
-      return delegate.getErrorStream();
-    }
-
-    @Override
-    public boolean usingProxy() {
-      return delegate.usingProxy();
-    }
-
-    @Override
-    public void setConnectTimeout(int timeout) {
-      delegate.setConnectTimeout(timeout);
-    }
-
-    @Override
-    public int getConnectTimeout() {
-      return delegate.getConnectTimeout();
-    }
-
-    @Override
-    public void setReadTimeout(int timeout) {
-      delegate.setReadTimeout(timeout);
-    }
-
-    @Override
-    public int getReadTimeout() {
-      return delegate.getReadTimeout();
-    }
-
-    @Override
-    public Map<String, List<String>> getHeaderFields() {
-      return delegate.getHeaderFields();
-    }
-
-    @Override
-    public Object getContent() throws IOException {
-      return delegate.getContent();
-    }
-
-    @Override
-    public Object getContent(Class[] classes) throws IOException {
-      return delegate.getContent(classes);
-    }
-
-    @Override
-    public InputStream getInputStream() throws IOException {
-      return delegate.getInputStream();
-    }
-
-    @Override
-    public OutputStream getOutputStream() throws IOException {
-      return delegate.getOutputStream();
-    }
-
-    @Override
-    public void setDoInput(boolean doInput) {
-      delegate.setDoInput(doInput);
-    }
-
-    @Override
-    public boolean getDoInput() {
-      return delegate.getDoInput();
-    }
-
-    @Override
-    public void setDoOutput(boolean doOutput) {
-      delegate.setDoOutput(doOutput);
-    }
-
-    @Override
-    public boolean getDoOutput() {
-      return delegate.getDoOutput();
-    }
-
-    @Override
-    public void setAllowUserInteraction(boolean allowUserInteraction) {
-      delegate.setAllowUserInteraction(allowUserInteraction);
-    }
-
-    @Override
-    public boolean getAllowUserInteraction() {
-      return delegate.getAllowUserInteraction();
-    }
-
-    @Override
-    public void setUseCaches(boolean useCaches) {
-      delegate.setUseCaches(useCaches);
-    }
-
-    @Override
-    public boolean getUseCaches() {
-      return delegate.getUseCaches();
-    }
-
-    @Override
-    public void setIfModifiedSince(long ifModifiedSince) {
-      delegate.setIfModifiedSince(ifModifiedSince);
-    }
-
-    @Override
-    public long getIfModifiedSince() {
-      return delegate.getIfModifiedSince();
-    }
-
-    @Override
-    public boolean getDefaultUseCaches() {
-      return delegate.getDefaultUseCaches();
-    }
-
-    @Override
-    public void setDefaultUseCaches(boolean defaultUseCaches) {
-      delegate.setDefaultUseCaches(defaultUseCaches);
-    }
-
-    @Override
-    public long getHeaderFieldDate(String name, long defaultValue) {
-      return delegate.getHeaderFieldDate(name, defaultValue);
-    }
-
-    @Override
-    public Permission getPermission() throws IOException {
-      return delegate.getPermission();
-    }
-
-    @Override
-    public URL getURL() {
-      return delegate.getURL();
-    }
-
-    @Override
-    public int getContentLength() {
-      return delegate.getContentLength();
-    }
-
-    @Override
-    public long getContentLengthLong() {
+    @Override public long getContentLengthLong() {
       return delegate.getContentLengthLong();
     }
 
-    @Override
-    public String getContentType() {
-      return delegate.getContentType();
+    @Override public void setFixedLengthStreamingMode(long contentLength) {
+      delegate.setFixedLengthStreamingMode(contentLength);
     }
 
-    @Override
-    public String getContentEncoding() {
-      return delegate.getContentEncoding();
+    @Override public long getHeaderFieldLong(String field, long defaultValue) {
+      return delegate.getHeaderFieldLong(field, defaultValue);
     }
-
-    @Override
-    public long getExpiration() {
-      return delegate.getExpiration();
-    }
-
-    @Override
-    public long getDate() {
-      return delegate.getDate();
-    }
-
-    @Override
-    public long getLastModified() {
-      return delegate.getLastModified();
-    }
-
-    @Override
-    public int getHeaderFieldInt(String name, int defaultValue) {
-      return delegate.getHeaderFieldInt(name, defaultValue);
-    }
-
-    @Override
-    public long getHeaderFieldLong(String name, long defaultValue) {
-      return delegate.getHeaderFieldLong(name, defaultValue);
-    }
-
-    @Override
-    public String toString() {
-      return delegate.toString();
-    }
-
   }
 
   private static RuntimeException throwRequestModificationException() {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
index bf5ca76..8eecf6b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
@@ -21,7 +21,7 @@
 
 /**
  * {@link com.squareup.okhttp.Protocol#HTTP_2 HTTP/2} only.
- * Processes server-initiated HTTP requestd on the client.
+ * Processes server-initiated HTTP requests on the client.
  *
  * <p>Use the stream ID to correlate response headers and data.
  *
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index a5194b1..fab8698 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -255,8 +255,9 @@
       if (associatedStreamId == 0) {
         frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId, priority, slot,
             requestHeaders);
+      } else if (client) {
+        throw new IllegalArgumentException("client streams shouldn't have associated stream IDs");
       } else { // HTTP/2 has a PUSH_PROMISE frame.
-        if (client) throw new IOException("Client attempted to push stream: " + associatedStreamId);
         frameWriter.pushPromise(associatedStreamId, streamId, requestHeaders);
       }
     }
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index 383ae4e..d86db86 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -16,6 +16,7 @@
 package com.squareup.okhttp.internal.spdy;
 
 import java.io.IOException;
+import java.util.Arrays;
 import java.util.List;
 import okio.ByteString;
 import okio.OkBuffer;
@@ -40,6 +41,27 @@
   }
 
   /**
+   * Variable-length quantity special cases strings which are longer than 127
+   * bytes.  Values such as cookies can be 4KiB, and should be possible to send.
+   *
+   * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-4.1.2
+   */
+  @Test public void largeHeaderValue() throws IOException {
+    char[] value = new char[4096];
+    Arrays.fill(value, '!');
+    List<Header> headerBlock = headerEntries("cookie", new String(value));
+
+    hpackWriter.writeHeaders(headerBlock);
+    bytesIn.write(bytesOut, bytesOut.size());
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndReset());
+  }
+
+  /**
    * HPACK has a max header table size, which can be smaller than the max header message.
    * Ensure the larger header content is not lost.
    */
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index 0f51db6..f125711 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -363,13 +363,8 @@
      */
     ByteString readByteString(boolean asciiLowercase) throws IOException {
       int firstByte = readByte();
-      int length = readInt(firstByte, PREFIX_8_BITS);
-
-      boolean huffmanDecode = false;
-      if ((length & 0x80) == 0x80) { // 1NNNNNNN
-        length &= ~0x80;
-        huffmanDecode = true;
-      }
+      boolean huffmanDecode = (firstByte & 0x80) == 0x80; // 1NNNNNNN
+      int length = readInt(firstByte, PREFIX_7_BITS);
 
       ByteString byteString = source.readByteString(length);
 
@@ -444,7 +439,7 @@
     }
 
     void writeByteString(ByteString data) throws IOException {
-      writeInt(data.size(), PREFIX_8_BITS, 0);
+      writeInt(data.size(), PREFIX_7_BITS, 0);
       out.write(data);
     }
   }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
index 0f82cc2..569da9b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
@@ -790,13 +790,9 @@
 
     /** Sets the value at {@code index} to {@code value}. */
     public void set(int index, String value) throws IOException {
-      BufferedSink writer = null;
-      try {
-        writer = Okio.buffer(Okio.sink(newOutputStream(index)));
-        writer.writeUtf8(value);
-      } finally {
-        Util.closeQuietly(writer);
-      }
+      BufferedSink writer = Okio.buffer(Okio.sink(newOutputStream(index)));
+      writer.writeUtf8(value);
+      writer.close();
     }
 
     /**
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
index 30688d8..d1bf250 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -39,7 +39,6 @@
 import java.util.concurrent.ThreadFactory;
 import okio.ByteString;
 import okio.OkBuffer;
-import okio.Sink;
 import okio.Source;
 
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
@@ -104,36 +103,6 @@
   }
 
   /**
-   * Closes {@code source}, ignoring any checked exceptions. Does nothing if
-   * {@code source} is null.
-   */
-  public static void closeQuietly(Source source) {
-    if (source != null) {
-      try {
-        source.close();
-      } catch (RuntimeException rethrown) {
-        throw rethrown;
-      } catch (Exception ignored) {
-      }
-    }
-  }
-
-  /**
-   * Closes {@code sink}, ignoring any checked exceptions. Does nothing if
-   * {@code sink} is null.
-   */
-  public static void closeQuietly(Sink sink) {
-    if (sink != null) {
-      try {
-        sink.close();
-      } catch (RuntimeException rethrown) {
-        throw rethrown;
-      } catch (Exception ignored) {
-      }
-    }
-  }
-
-  /**
    * Closes {@code socket}, ignoring any checked exceptions. Does nothing if
    * {@code socket} is null.
    */
@@ -206,17 +175,6 @@
   }
 
   /**
-   * Implements OutputStream.write(int) in terms of OutputStream.write(byte[], int, int).
-   * OutputStream assumes that you implement OutputStream.write(int) and provides default
-   * implementations of the others, but often the opposite is more efficient.
-   */
-  public static void writeSingleByte(OutputStream out, int b) throws IOException {
-    byte[] buffer = new byte[1];
-    buffer[0] = (byte) (b & 0xff);
-    out.write(buffer);
-  }
-
-  /**
    * Fills 'dst' with bytes from 'in', throwing EOFException if insufficient bytes are available.
    */
   public static void readFully(InputStream in, byte[] dst) throws IOException {
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
index a5a7d16..1380ff0 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
@@ -37,14 +37,11 @@
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.net.CacheRequest;
-import java.net.CacheResponse;
 import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
 import java.net.ResponseCache;
-import java.net.SecureCacheResponse;
-import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.URLConnection;
@@ -58,7 +55,6 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
-import java.util.Map;
 import java.util.TimeZone;
 import java.util.UUID;
 import java.util.concurrent.TimeUnit;
@@ -79,6 +75,7 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -122,6 +119,20 @@
     return client.open(url);
   }
 
+  @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
+    ResponseCache.setDefault(null);
+    client.setResponseCache(cache);
+    assertSame(cache, client.getOkResponseCache());
+    assertNull(client.getResponseCache());
+  }
+
+  @Test public void responseCacheAccessWithGlobalDefault() throws IOException {
+    ResponseCache.setDefault(cache);
+    client.setResponseCache(null);
+    assertNull(client.getOkResponseCache());
+    assertNull(client.getResponseCache());
+  }
+
   /**
    * Test that response caching is consistent with the RI and the spec.
    * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
@@ -363,26 +374,6 @@
     assertEquals(localPrincipal, c2.getLocalPrincipal());
   }
 
-  @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-    server.play();
-
-    ResponseCache.setDefault(new InsecureResponseCache());
-
-    HttpsURLConnection connection1 = (HttpsURLConnection) client.open(server.getUrl("/"));
-    connection1.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(connection1));
-
-    // Not cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) client.open(server.getUrl("/"));
-    connection2.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("DEF", readAscii(connection2));
-  }
-
   @Test public void responseCachingAndRedirects() throws Exception {
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -2043,28 +2034,6 @@
     return bytesOut.toByteArray();
   }
 
-  private class InsecureResponseCache extends ResponseCache {
-    @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-      return cache.put(uri, connection);
-    }
-
-    @Override public CacheResponse get(URI uri, String requestMethod,
-        Map<String, List<String>> requestHeaders) throws IOException {
-      final CacheResponse response = cache.get(uri, requestMethod, requestHeaders);
-      if (response instanceof SecureCacheResponse) {
-        return new CacheResponse() {
-          @Override public InputStream getBody() throws IOException {
-            return response.getBody();
-          }
-          @Override public Map<String, List<String>> getHeaders() throws IOException {
-            return response.getHeaders();
-          }
-        };
-      }
-      return response;
-    }
-  }
-
   static abstract class AbstractOkResponseCache implements OkResponseCache {
     @Override public Response get(Request request) throws IOException {
       return null;
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheTest.java
index 9d1ae04..1cbd654 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheTest.java
@@ -22,11 +22,6 @@
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
 import java.io.BufferedReader;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
@@ -52,7 +47,6 @@
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -63,18 +57,21 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.zip.GZIPOutputStream;
-
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSession;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -96,6 +93,7 @@
   private OkHttpClient client;
   private MockWebServer server;
   private MockWebServer server2;
+  private ResponseCache cache;
 
   @Before public void setUp() throws Exception {
     server =  new MockWebServer();
@@ -103,8 +101,8 @@
     server2 =  new MockWebServer();
 
     client = new OkHttpClient();
-    ResponseCache cache = new InMemoryResponseCache();
-    client.setResponseCache(cache);
+    cache = new InMemoryResponseCache();
+    ResponseCache.setDefault(cache);
   }
 
   @After public void tearDown() throws Exception {
@@ -117,6 +115,20 @@
     return client.open(url);
   }
 
+  @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
+    ResponseCache.setDefault(null);
+    client.setResponseCache(cache);
+    assertSame(cache, client.getResponseCache());
+    assertTrue(client.getOkResponseCache() instanceof ResponseCacheAdapter);
+  }
+
+  @Test public void responseCacheAccessWithGlobalDefault() throws IOException {
+    ResponseCache.setDefault(cache);
+    client.setResponseCache(null);
+    assertNull(client.getOkResponseCache());
+    assertNull(client.getResponseCache());
+  }
+
   @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
     testResponseCaching(TransferKind.FIXED_LENGTH);
   }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index 49a2c37..9540608 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -164,22 +164,13 @@
    * Sets the response cache to be used to read and write cached responses.
    */
   public OkHttpClient setResponseCache(ResponseCache responseCache) {
-    if (responseCache instanceof OkResponseCache) {
-      return setOkResponseCache((OkResponseCache) responseCache);
-    }
-    return setOkResponseCache(new ResponseCacheAdapter(responseCache));
+    return setOkResponseCache(toOkResponseCache(responseCache));
   }
 
-  /**
-   * @deprecated OkHttp 2 dropped full support for java.net.ResponseCache. That API
-   *     is broken for many reasons: URI instead of URL, no conditional updates,
-   *     no invalidation, and no mechanism for tracking hit rates. Use
-   *     {@link #setOkResponseCache} instead.
-   */
-  @Deprecated
   public ResponseCache getResponseCache() {
-    throw new UnsupportedOperationException("OkHttp 2 dropped support for java.net.ResponseCache. "
-        + "Use setOkResponseCache() instead.");
+    return responseCache instanceof ResponseCacheAdapter
+        ? ((ResponseCacheAdapter) responseCache).getDelegate()
+        : null;
   }
 
   public OkHttpClient setOkResponseCache(OkResponseCache responseCache) {
@@ -451,7 +442,7 @@
       result.cookieHandler = CookieHandler.getDefault();
     }
     if (result.responseCache == null) {
-      result.responseCache = toOkResponseCacheOrNull(ResponseCache.getDefault());
+      result.responseCache = toOkResponseCache(ResponseCache.getDefault());
     }
     if (result.sslSocketFactory == null) {
       result.sslSocketFactory = getDefaultSSLSocketFactory();
@@ -504,8 +495,10 @@
     }
   }
 
-  private OkResponseCache toOkResponseCacheOrNull(ResponseCache cache) {
-    return cache instanceof OkResponseCache ? ((OkResponseCache) cache) : null;
+  private OkResponseCache toOkResponseCache(ResponseCache responseCache) {
+    return responseCache == null || responseCache instanceof OkResponseCache
+        ? (OkResponseCache) responseCache
+        : new ResponseCacheAdapter(responseCache);
   }
 
   /**
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseCacheAdapter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseCacheAdapter.java
index 381b8cf..9d6eb22 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseCacheAdapter.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseCacheAdapter.java
@@ -52,6 +52,10 @@
     this.delegate = delegate;
   }
 
+  public ResponseCache getDelegate() {
+    return delegate;
+  }
+
   @Override
   public Response get(Request request) throws IOException {
     CacheResponse javaResponse = getJavaCachedResponse(request);
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 8021290..347e38c 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -65,6 +65,7 @@
 import javax.net.ssl.X509TrustManager;
 import okio.BufferedSink;
 import okio.ByteString;
+import okio.OkBuffer;
 import okio.Okio;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
@@ -695,11 +696,14 @@
         }
         spdyHeaders.add(new Header(headerParts[0], headerParts[1]));
       }
-      byte[] body = response.getBody();
-      boolean closeStreamAfterHeaders = body.length > 0 || !response.getPushPromises().isEmpty();
+      OkBuffer body = new OkBuffer();
+      if (response.getBody() != null) {
+        body.write(response.getBody());
+      }
+      boolean closeStreamAfterHeaders = body.size() > 0 || !response.getPushPromises().isEmpty();
       stream.reply(spdyHeaders, closeStreamAfterHeaders);
       pushPromises(stream, response.getPushPromises());
-      if (body.length > 0) {
+      if (body.size() > 0) {
         if (response.getBodyDelayTimeMs() != 0) {
           try {
             Thread.sleep(response.getBodyDelayTimeMs());
@@ -708,7 +712,22 @@
           }
         }
         BufferedSink sink = Okio.buffer(stream.getSink());
-        sink.write(body);
+        if (response.getThrottleBytesPerPeriod() == Integer.MAX_VALUE) {
+          sink.write(body, body.size());
+          sink.flush();
+        } else {
+          while (body.size() > 0) {
+            long toWrite = Math.min(body.size(), response.getThrottleBytesPerPeriod());
+            sink.write(body, toWrite);
+            sink.flush();
+            try {
+              long delayMs = response.getThrottleUnit().toMillis(response.getThrottlePeriod());
+              if (delayMs != 0) Thread.sleep(delayMs);
+            } catch (InterruptedException e) {
+              throw new AssertionError();
+            }
+          }
+        }
         sink.close();
       } else if (closeStreamAfterHeaders) {
         stream.close(ErrorCode.NO_ERROR);
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index fbfb2f5..64b81ce 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -1061,7 +1061,6 @@
 
     // Play it back.
     SpdyConnection connection = connection(peer, variant);
-    connection.okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, INITIAL_WINDOW_SIZE);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(0, stream.unacknowledgedBytesRead);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index d48e3dc..4fea5e8 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -370,7 +370,7 @@
 
         // Flow control: notify the peer that we're ready for more data!
         unacknowledgedBytesRead += read;
-        if (unacknowledgedBytesRead >= connection.okHttpSettings.getInitialWindowSize() / 2) {
+        if (unacknowledgedBytesRead >= connection.peerSettings.getInitialWindowSize() / 2) {
           connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
           unacknowledgedBytesRead = 0;
         }
@@ -380,7 +380,7 @@
       synchronized (connection) { // Multiple application threads may hit this section.
         connection.unacknowledgedBytesRead += read;
         if (connection.unacknowledgedBytesRead
-            >= connection.okHttpSettings.getInitialWindowSize() / 2) {
+            >= connection.peerSettings.getInitialWindowSize() / 2) {
           connection.writeWindowUpdateLater(0, connection.unacknowledgedBytesRead);
           connection.unacknowledgedBytesRead = 0;
         }
/Fim/
diff --git a/okio/src/main/java/okio/DeflaterSink.java b/okio/src/main/java/okio/DeflaterSink.java
index e3a7cab..ce7081d 100644
--- a/okio/src/main/java/okio/DeflaterSink.java
+++ b/okio/src/main/java/okio/DeflaterSink.java
@@ -38,6 +38,7 @@
 public final class DeflaterSink implements Sink {
   private final BufferedSink sink;
   private final Deflater deflater;
+  private boolean closed;
 
   public DeflaterSink(Sink sink, Deflater deflater) {
     this.sink = Okio.buffer(sink);
@@ -82,10 +83,13 @@
           ? deflater.deflate(s.data, s.limit, Segment.SIZE - s.limit, Deflater.SYNC_FLUSH)
           : deflater.deflate(s.data, s.limit, Segment.SIZE - s.limit);
 
-      if (deflated == 0) return;
-      s.limit += deflated;
-      buffer.size += deflated;
-      sink.emitCompleteSegments();
+      if (deflated > 0) {
+        s.limit += deflated;
+        buffer.size += deflated;
+        sink.emitCompleteSegments();
+      } else if (deflater.needsInput()) {
+        return;
+      }
     }
   }
 
@@ -95,9 +99,32 @@
   }
 
   @Override public void close() throws IOException {
-    deflater.finish();
-    deflate(false);
-    sink.close();
+    if (closed) return;
+
+    // Emit deflated data to the underlying sink. If this fails, we still need
+    // to close the deflater and the sink; otherwise we risk leaking resources.
+    Throwable thrown = null;
+    try {
+      deflater.finish();
+      deflate(false);
+    } catch (Throwable e) {
+      thrown = e;
+    }
+
+    try {
+      deflater.end();
+    } catch (Throwable e) {
+      if (thrown == null) thrown = e;
+    }
+
+    try {
+      sink.close();
+    } catch (Throwable e) {
+      if (thrown == null) thrown = e;
+    }
+    closed = true;
+
+    if (thrown != null) Util.sneakyRethrow(thrown);
   }
 
   @Override public Sink deadline(Deadline deadline) {
/Fim/
diff --git a/okio/src/main/java/okio/OkBuffer.java b/okio/src/main/java/okio/OkBuffer.java
index c2d0d19..8dc4290 100644
--- a/okio/src/main/java/okio/OkBuffer.java
+++ b/okio/src/main/java/okio/OkBuffer.java
@@ -362,9 +362,8 @@
 
   /** Like {@link InputStream#read}. */
   int read(byte[] sink, int offset, int byteCount) {
-    if (byteCount == 0) return -1;
-
     Segment s = this.head;
+    if (s == null) return -1;
     int toCopy = Math.min(byteCount, s.limit - s.pos);
     System.arraycopy(s.data, s.pos, sink, offset, toCopy);
 
/Fim/
diff --git a/okio/src/test/java/okio/DeflaterSinkTest.java b/okio/src/test/java/okio/DeflaterSinkTest.java
index 025215b..0f6b8c2 100644
--- a/okio/src/test/java/okio/DeflaterSinkTest.java
+++ b/okio/src/test/java/okio/DeflaterSinkTest.java
@@ -25,6 +25,7 @@
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
 public final class DeflaterSinkTest {
   @Test public void deflateWithClose() throws Exception {
@@ -75,6 +76,39 @@
     assertEquals(original, inflated.readByteString(inflated.size()));
   }
 
+  @Test public void multipleSegmentsWithoutCompression() throws IOException {
+    OkBuffer buffer = new OkBuffer();
+    Deflater deflater = new Deflater();
+    deflater.setLevel(Deflater.NO_COMPRESSION);
+    DeflaterSink deflaterSink = new DeflaterSink(buffer, deflater);
+    int byteCount = Segment.SIZE * 4;
+    deflaterSink.write(new OkBuffer().writeUtf8(repeat('a', byteCount)), byteCount);
+    deflaterSink.close();
+    assertEquals(repeat('a', byteCount), inflate(buffer).readUtf8(byteCount));
+  }
+
+  /**
+   * This test deflates a single segment of without compression because that's
+   * the easiest way to force close() to emit a large amount of data to the
+   * underlying sink.
+   */
+  @Test public void closeWithExceptionWhenWritingAndClosing() throws IOException {
+    MockSink mockSink = new MockSink();
+    mockSink.scheduleThrow(0, new IOException("first"));
+    mockSink.scheduleThrow(1, new IOException("second"));
+    Deflater deflater = new Deflater();
+    deflater.setLevel(Deflater.NO_COMPRESSION);
+    DeflaterSink deflaterSink = new DeflaterSink(mockSink, deflater);
+    deflaterSink.write(new OkBuffer().writeUtf8(repeat('a', Segment.SIZE)), Segment.SIZE);
+    try {
+      deflaterSink.close();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("first", expected.getMessage());
+    }
+    mockSink.assertLogContains("close()");
+  }
+
   /**
    * Uses streaming decompression to inflate {@code deflated}. The input must
    * either be finished or have a trailing sync flush.
/Fim/
diff --git a/okio/src/test/java/okio/MockSink.java b/okio/src/test/java/okio/MockSink.java
new file mode 100644
index 0000000..bae3259
--- /dev/null
+++ b/okio/src/test/java/okio/MockSink.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+/** A scriptable sink. Like Mockito, but worse and requiring less configuration. */
+class MockSink implements Sink {
+  private final List<String> log = new ArrayList<String>();
+  private final Map<Integer, IOException> callThrows = new LinkedHashMap<Integer, IOException>();
+
+  public void assertLog(String... messages) {
+    assertEquals(Arrays.asList(messages), log);
+  }
+
+  public void assertLogContains(String message) {
+    assertTrue(log.contains(message));
+  }
+
+  public void scheduleThrow(int call, IOException e) {
+    callThrows.put(call, e);
+  }
+
+  private void throwIfScheduled() throws IOException {
+    IOException exception = callThrows.get(log.size() - 1);
+    if (exception != null) throw exception;
+  }
+
+  @Override public void write(OkBuffer source, long byteCount) throws IOException {
+    log.add("write(" + source + ", " + byteCount + ")");
+    source.skip(byteCount);
+    throwIfScheduled();
+  }
+
+  @Override public void flush() throws IOException {
+    log.add("flush()");
+    throwIfScheduled();
+  }
+
+  @Override public Sink deadline(Deadline deadline) {
+    log.add("deadline()");
+    return this;
+  }
+
+  @Override public void close() throws IOException {
+    log.add("close()");
+    throwIfScheduled();
+  }
+}
/Fim/
diff --git a/okio/src/test/java/okio/RealBufferedSinkTest.java b/okio/src/test/java/okio/RealBufferedSinkTest.java
index 67d3a80..80a1317 100644
--- a/okio/src/test/java/okio/RealBufferedSinkTest.java
+++ b/okio/src/test/java/okio/RealBufferedSinkTest.java
@@ -17,11 +17,7 @@
 
 import java.io.IOException;
 import java.io.OutputStream;
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
 import org.junit.Test;
 
 import static okio.Util.UTF_8;
@@ -216,43 +212,4 @@
     Arrays.fill(array, c);
     return new String(array);
   }
-
-  /** A scriptable sink. Like Mockito, but worse and requiring less configuration. */
-  private static class MockSink implements Sink {
-    private final List<String> log = new ArrayList<String>();
-    private final Map<Integer, IOException> callThrows = new LinkedHashMap<Integer, IOException>();
-
-    public void assertLog(String... messages) {
-      assertEquals(Arrays.asList(messages), log);
-    }
-
-    public void scheduleThrow(int call, IOException e) {
-      callThrows.put(call, e);
-    }
-
-    private void throwIfScheduled() throws IOException {
-      IOException exception = callThrows.get(log.size() - 1);
-      if (exception != null) throw exception;
-    }
-
-    @Override public void write(OkBuffer source, long byteCount) throws IOException {
-      log.add("write(" + source + ", " + byteCount + ")");
-      throwIfScheduled();
-    }
-
-    @Override public void flush() throws IOException {
-      log.add("flush()");
-      throwIfScheduled();
-    }
-
-    @Override public Sink deadline(Deadline deadline) {
-      log.add("deadline()");
-      return this;
-    }
-
-    @Override public void close() throws IOException {
-      log.add("close()");
-      throwIfScheduled();
-    }
-  }
 }
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index a44af61..fd6007d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -45,7 +45,7 @@
   private final List<OutFrame> outFrames = new ArrayList<OutFrame>();
   private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<InFrame>();
   private int port;
-  private final ExecutorService executor = Executors.newCachedThreadPool(
+  private final ExecutorService executor = Executors.newSingleThreadExecutor(
       Util.threadFactory("MockSpdyPeer", false));
   private ServerSocket serverSocket;
   private Socket socket;
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
index ba1f288..7f4fa11 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
@@ -376,8 +376,9 @@
   }
 
   private static void deleteIfExists(File file) throws IOException {
-    if (file.exists() && !file.delete()) {
-      throw new IOException();
+    // If delete() fails, make sure it's because the file didn't exist!
+    if (!file.delete() && file.exists()) {
+      throw new IOException("failed to delete " + file);
     }
   }
 
@@ -477,7 +478,7 @@
    * Returns the maximum number of bytes that this cache should use to store
    * its data.
    */
-  public long getMaxSize() {
+  public synchronized long getMaxSize() {
     return maxSize;
   }
 
@@ -580,9 +581,7 @@
 
     for (int i = 0; i < valueCount; i++) {
       File file = entry.getCleanFile(i);
-      if (!file.delete()) {
-        throw new IOException("failed to delete " + file);
-      }
+      deleteIfExists(file);
       size -= entry.lengths[i];
       entry.lengths[i] = 0;
     }
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index d86db86..42ddcab 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -306,6 +306,48 @@
     assertTrue(hpackReader.getAndReset().isEmpty());
   }
 
+  /** Ensure a later toggle of the same index emits! */
+  @Test public void toggleIndexOffOn() throws IOException {
+
+    bytesIn.writeByte(0x82); // Copy static header 1 to the header table as index 1.
+    bytesIn.writeByte(0x81); // Remove index 1 from the reference set.
+
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+    assertEquals(1, hpackReader.headerCount);
+    assertTrue(hpackReader.getAndReset().isEmpty());
+
+    bytesIn.writeByte(0x81); // Add index 1 back to the reference set.
+
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());
+  }
+
+  /** Check later toggle of the same index for large header sets. */
+  @Test public void toggleIndexOffBeyond64Entries() throws IOException {
+    int expectedHeaderCount = 65;
+
+    for (int i = 0; i < expectedHeaderCount; i++) {
+      bytesIn.writeByte(0x82 + i); // Copy static header 1 to the header table as index 1.
+      bytesIn.writeByte(0x81); // Remove index 1 from the reference set.
+    }
+
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+    assertEquals(expectedHeaderCount, hpackReader.headerCount);
+    assertTrue(hpackReader.getAndReset().isEmpty());
+
+    bytesIn.writeByte(0x81); // Add index 1 back to the reference set.
+
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+    assertEquals(expectedHeaderCount, hpackReader.headerCount);
+    assertHeaderReferenced(headerTableLength() - expectedHeaderCount);
+    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());
+  }
+
   /**
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.4
    */
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index f125711..440b6d5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -115,6 +115,11 @@
     BitArray referencedHeaders = new BitArray.FixedCapacity();
 
     /**
+     * Set bit positions indicate {@code headerTable[pos]} was already emitted.
+     */
+    BitArray emittedReferencedHeaders = new BitArray.FixedCapacity();
+
+    /**
      * Set bit positions indicate {@code STATIC_HEADER_TABLE[pos]} should be
      * emitted.
      */
@@ -168,6 +173,7 @@
           entriesToEvict++;
         }
         referencedHeaders.shiftLeft(entriesToEvict);
+        emittedReferencedHeaders.shiftLeft(entriesToEvict);
         System.arraycopy(headerTable, nextHeaderIndex + 1, headerTable,
             nextHeaderIndex + 1 + entriesToEvict, headerCount);
         nextHeaderIndex += entriesToEvict;
@@ -209,6 +215,7 @@
     private void clearReferenceSet() {
       referencedStaticHeaders = 0L;
       referencedHeaders.clear();
+      emittedReferencedHeaders.clear();
     }
 
     void emitReferenceSet() {
@@ -218,7 +225,7 @@
         }
       }
       for (int i = headerTable.length - 1; i != nextHeaderIndex; --i) {
-        if (referencedHeaders.get(i)) {
+        if (referencedHeaders.get(i) && !emittedReferencedHeaders.get(i)) {
           emittedHeaders.add(headerTable[i]);
         }
       }
@@ -231,6 +238,7 @@
     List<Header> getAndReset() {
       List<Header> result = new ArrayList<Header>(emittedHeaders);
       emittedHeaders.clear();
+      emittedReferencedHeaders.clear();
       return result;
     }
 
@@ -243,7 +251,12 @@
           insertIntoHeaderTable(-1, staticEntry);
         }
       } else {
-        referencedHeaders.toggle(headerTableIndex(index));
+        int headerTableIndex = headerTableIndex(index);
+        if (!referencedHeaders.get(headerTableIndex)) { // When re-referencing, emit immediately.
+          emittedHeaders.add(headerTable[headerTableIndex]);
+          emittedReferencedHeaders.set(headerTableIndex);
+        }
+        referencedHeaders.toggle(headerTableIndex);
       }
     }
 
@@ -308,14 +321,17 @@
       int bytesToRecover = (headerTableByteCount + delta) - maxHeaderTableByteCount;
       int entriesEvicted = evictToRecoverBytes(bytesToRecover);
 
-      if (index == -1) {
-        if (headerCount + 1 > headerTable.length) {
+      if (index == -1) { // Adding a value to the header table.
+        if (headerCount + 1 > headerTable.length) { // Need to grow the header table.
           Header[] doubled = new Header[headerTable.length * 2];
           System.arraycopy(headerTable, 0, doubled, headerTable.length, headerTable.length);
           if (doubled.length == 64) {
             referencedHeaders = ((BitArray.FixedCapacity) referencedHeaders).toVariableCapacity();
+            emittedReferencedHeaders =
+                ((BitArray.FixedCapacity) emittedReferencedHeaders).toVariableCapacity();
           }
           referencedHeaders.shiftLeft(headerTable.length);
+          emittedReferencedHeaders.shiftLeft(headerTable.length);
           nextHeaderIndex = headerTable.length - 1;
           headerTable = doubled;
         }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
index 1e7bc40..231ce3b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -49,13 +49,16 @@
  *
  * <p>NPN (Next Protocol Negotiation) was developed for SPDY. It is widely
  * available and we support it on both Android (4.1+) and OpenJDK 7 (via the
- * Jetty NPN-boot library).
+ * Jetty NPN-boot library). NPN is not yet available on Java 8.
  *
  * <p>ALPN (Application Layer Protocol Negotiation) is the successor to NPN. It
- * has some technical advantages over NPN. We support it on Android (4.4+) only.
+ * has some technical advantages over NPN. ALPN first arrived in Android 4.4,
+ * but that release suffers a <a href="http://goo.gl/y5izPP">concurrency bug</a>
+ * so we don't use it. ALPN will be supported in the future.
  *
  * <p>On platforms that support both extensions, OkHttp will use both,
- * preferring ALPN's result. Future versions of OkHttp will drop support NPN.
+ * preferring ALPN's result. Future versions of OkHttp will drop support for
+ * NPN.
  *
  * <h3>Deflater Sync Flush</h3>
  * SPDY header compression requires a recent version of {@code
@@ -170,21 +173,14 @@
       // Attempt to find Android 4.1+ APIs.
       Method setNpnProtocols = null;
       Method getNpnSelectedProtocol = null;
-      Method setAlpnProtocols = null;
-      Method getAlpnSelectedProtocol = null;
       try {
         setNpnProtocols = openSslSocketClass.getMethod("setNpnProtocols", byte[].class);
         getNpnSelectedProtocol = openSslSocketClass.getMethod("getNpnSelectedProtocol");
-        try {
-          setAlpnProtocols = openSslSocketClass.getMethod("setAlpnProtocols", byte[].class);
-          getAlpnSelectedProtocol = openSslSocketClass.getMethod("getAlpnSelectedProtocol");
-        } catch (NoSuchMethodException ignored) {
-        }
       } catch (NoSuchMethodException ignored) {
       }
 
       return new Android(openSslSocketClass, setUseSessionTickets, setHostname, setNpnProtocols,
-          getNpnSelectedProtocol, setAlpnProtocols, getAlpnSelectedProtocol);
+          getNpnSelectedProtocol);
     } catch (ClassNotFoundException ignored) {
       // This isn't an Android runtime.
     } catch (NoSuchMethodException ignored) {
@@ -225,21 +221,13 @@
     private final Method setNpnProtocols;
     private final Method getNpnSelectedProtocol;
 
-    // Non-null on Android 4.4+.
-    private final Method setAlpnProtocols;
-    private final Method getAlpnSelectedProtocol;
-
-    private Android(
-        Class<?> openSslSocketClass, Method setUseSessionTickets, Method setHostname,
-        Method setNpnProtocols, Method getNpnSelectedProtocol, Method setAlpnProtocols,
-        Method getAlpnSelectedProtocol) {
+    private Android(Class<?> openSslSocketClass, Method setUseSessionTickets, Method setHostname,
+        Method setNpnProtocols, Method getNpnSelectedProtocol) {
       this.openSslSocketClass = openSslSocketClass;
       this.setUseSessionTickets = setUseSessionTickets;
       this.setHostname = setHostname;
       this.setNpnProtocols = setNpnProtocols;
       this.getNpnSelectedProtocol = getNpnSelectedProtocol;
-      this.setAlpnProtocols = setAlpnProtocols;
-      this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
     }
 
     @Override public void connectSocket(Socket socket, InetSocketAddress address,
@@ -273,9 +261,6 @@
       if (!openSslSocketClass.isInstance(socket)) return;
       try {
         Object[] parameters = { concatLengthPrefixed(npnProtocols) };
-        if (setAlpnProtocols != null) {
-          setAlpnProtocols.invoke(socket, parameters);
-        }
         setNpnProtocols.invoke(socket, parameters);
       } catch (IllegalAccessException e) {
         throw new AssertionError(e);
@@ -288,11 +273,6 @@
       if (getNpnSelectedProtocol == null) return null;
       if (!openSslSocketClass.isInstance(socket)) return null;
       try {
-        if (getAlpnSelectedProtocol != null) {
-          // Prefer ALPN's result if it is present.
-          byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invoke(socket);
-          if (alpnResult != null) return ByteString.of(alpnResult);
-        }
         byte[] npnResult = (byte[]) getNpnSelectedProtocol.invoke(socket);
         if (npnResult == null) return null;
         return ByteString.of(npnResult);
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
index acbfdd5..45dd06a 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
@@ -54,6 +54,13 @@
     assertMediaType("text/plain; a=1; a=2; b=3");
     assertMediaType("text/plain; charset=utf-16");
     assertMediaType("text/plain; \t \n \r a=b");
+    assertMediaType("text/plain;");
+    assertMediaType("text/plain; ");
+    assertMediaType("text/plain; a=1;");
+    assertMediaType("text/plain; a=1; ");
+    assertMediaType("text/plain; a=1;; b=2");
+    assertMediaType("text/plain;;");
+    assertMediaType("text/plain; ;");
   }
 
   @Test public void testInvalidParse() throws Exception {
@@ -64,14 +71,10 @@
     assertInvalid("text/");
     assertInvalid("te<t/plain");
     assertInvalid("text/pl@in");
-    assertInvalid("text/plain;");
-    assertInvalid("text/plain; ");
     assertInvalid("text/plain; a");
     assertInvalid("text/plain; a=");
     assertInvalid("text/plain; a=@");
     assertInvalid("text/plain; a=\"@");
-    assertInvalid("text/plain; a=1;");
-    assertInvalid("text/plain; a=1; ");
     assertInvalid("text/plain; a=1; b");
     assertInvalid("text/plain; a=1; b=");
     assertInvalid("text/plain; a=\u2025");
@@ -140,6 +143,14 @@
     assertEquals("ISO-8859-1", charset.charset(Charset.forName("US-ASCII")).name());
   }
 
+  @Test public void testParseDanglingSemicolon() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;");
+    assertEquals("text", mediaType.type());
+    assertEquals("plain", mediaType.subtype());
+    assertEquals(null, mediaType.charset());
+    assertEquals("text/plain;", mediaType.toString());
+  }
+
   private void assertMediaType(String string) {
     MediaType mediaType = MediaType.parse(string);
     assertEquals(string, mediaType.toString());
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/MediaType.java b/okhttp/src/main/java/com/squareup/okhttp/MediaType.java
index 2c09596..b0b7f45 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/MediaType.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/MediaType.java
@@ -29,7 +29,7 @@
   private static final String QUOTED = "\"([^\"]*)\"";
   private static final Pattern TYPE_SUBTYPE = Pattern.compile(TOKEN + "/" + TOKEN);
   private static final Pattern PARAMETER = Pattern.compile(
-      ";\\s*" + TOKEN + "=(?:" + TOKEN + "|" + QUOTED + ")");
+      ";\\s*(?:" + TOKEN + "=(?:" + TOKEN + "|" + QUOTED + "))?");
 
   private final String mediaType;
   private final String type;
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index 1a20f8e..823ae30 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -1448,32 +1448,7 @@
     peer.sendFrame().data(true, 1, data(0));
     peer.play();
 
-    final List events = new ArrayList();
-    PushObserver observer = new PushObserver() {
-
-      @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
-        assertEquals(2, streamId);
-        events.add(requestHeaders);
-        return false;
-      }
-
-      @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
-        assertEquals(2, streamId);
-        assertTrue(last);
-        events.add(responseHeaders);
-        return false;
-      }
-
-      @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
-          boolean last) throws IOException {
-        events.add(new AssertionError("onData"));
-        return false;
-      }
-
-      @Override public void onReset(int streamId, ErrorCode errorCode) {
-        events.add(new AssertionError("onReset"));
-      }
-    };
+    RecordingPushObserver observer = new RecordingPushObserver();
 
     // play it back
     SpdyConnection connection = connectionBuilder(peer, HTTP_20_DRAFT_09)
@@ -1484,9 +1459,8 @@
     // verify the peer received what was expected
     assertEquals(TYPE_HEADERS, peer.takeFrame().type);
 
-    assertEquals(2, events.size());
-    assertEquals(expectedRequestHeaders, events.get(0));
-    assertEquals(expectedResponseHeaders, events.get(1));
+    assertEquals(expectedRequestHeaders, observer.takeEvent());
+    assertEquals(expectedResponseHeaders, observer.takeEvent());
   }
 
   @Test public void doublePushPromise() throws Exception {
@@ -1619,4 +1593,43 @@
     @Override public void onReset(int streamId, ErrorCode errorCode) {
     }
   };
+
+  private static class RecordingPushObserver implements PushObserver {
+    final List<Object> events = new ArrayList<Object>();
+
+    public synchronized Object takeEvent() throws InterruptedException {
+      while (events.isEmpty()) {
+        wait();
+      }
+      return events.remove(0);
+    }
+
+    @Override public synchronized boolean onRequest(int streamId, List<Header> requestHeaders) {
+      assertEquals(2, streamId);
+      events.add(requestHeaders);
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized boolean onHeaders(
+        int streamId, List<Header> responseHeaders, boolean last) {
+      assertEquals(2, streamId);
+      assertTrue(last);
+      events.add(responseHeaders);
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized boolean onData(
+        int streamId, BufferedSource source, int byteCount, boolean last) {
+      events.add(new AssertionError("onData"));
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized void onReset(int streamId, ErrorCode errorCode) {
+      events.add(new AssertionError("onReset"));
+      notifyAll();
+    }
+  }
 }
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
index 151128d..089c73e 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
@@ -37,6 +37,7 @@
 import java.util.logging.Logger;
 import java.util.zip.GZIPOutputStream;
 import javax.net.ssl.SSLContext;
+import okio.Buffer;
 
 /**
  * This benchmark is fake, but may be useful for certain relative comparisons.
@@ -191,7 +192,7 @@
     }
 
     if (chunked) {
-      result.setChunkedBody(body, 1024);
+      result.setChunkedBody(new Buffer().write(body), 1024);
     } else {
       result.setBody(body);
     }
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
index 7d8e066..dfae1c5 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
@@ -15,16 +15,12 @@
  */
 package com.squareup.okhttp.mockwebserver;
 
-import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
 import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import okio.Buffer;
 
 /** A scripted response to be replayed by the mock web server. */
 public final class MockResponse implements Cloneable {
@@ -34,7 +30,7 @@
   private List<String> headers = new ArrayList<String>();
 
   /** The response body content, or null if {@code bodyStream} is set. */
-  private byte[] body;
+  private Buffer body;
   /** The response body content, or null if {@code body} is set. */
   private InputStream bodyStream;
 
@@ -50,7 +46,7 @@
 
   /** Creates a new mock response with an empty body. */
   public MockResponse() {
-    setBody(new byte[0]);
+    setBody(new Buffer());
   }
 
   @Override public MockResponse clone() {
@@ -132,18 +128,22 @@
   }
 
   /** Returns the raw HTTP payload, or null if this response is streamed. */
-  public byte[] getBody() {
-    return body;
+  public Buffer getBody() {
+    return body != null ? body.clone() : null; // Defensive copy.
   }
 
   /** Returns an input stream containing the raw HTTP payload. */
   InputStream getBodyStream() {
-    return bodyStream != null ? bodyStream : new ByteArrayInputStream(body);
+    return bodyStream != null ? bodyStream : getBody().inputStream();
   }
 
   public MockResponse setBody(byte[] body) {
-    setHeader("Content-Length", body.length);
-    this.body = body;
+    return setBody(new Buffer().write(body));
+  }
+
+  public MockResponse setBody(Buffer body) {
+    setHeader("Content-Length", body.size());
+    this.body = body.clone(); // Defensive copy.
     this.bodyStream = null;
     return this;
   }
@@ -157,39 +157,29 @@
 
   /** Sets the response body to the UTF-8 encoded bytes of {@code body}. */
   public MockResponse setBody(String body) {
-    try {
-      return setBody(body.getBytes("UTF-8"));
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
-    }
+    return setBody(new Buffer().writeUtf8(body));
   }
 
   /**
    * Sets the response body to {@code body}, chunked every {@code maxChunkSize}
    * bytes.
    */
-  public MockResponse setChunkedBody(byte[] body, int maxChunkSize) {
+  public MockResponse setChunkedBody(Buffer body, int maxChunkSize) {
     removeHeader("Content-Length");
     headers.add(CHUNKED_BODY_HEADER);
 
-    try {
-      ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-      int pos = 0;
-      while (pos < body.length) {
-        int chunkSize = Math.min(body.length - pos, maxChunkSize);
-        bytesOut.write(Integer.toHexString(chunkSize).getBytes(Util.US_ASCII));
-        bytesOut.write("\r\n".getBytes(Util.US_ASCII));
-        bytesOut.write(body, pos, chunkSize);
-        bytesOut.write("\r\n".getBytes(Util.US_ASCII));
-        pos += chunkSize;
-      }
-      bytesOut.write("0\r\n\r\n".getBytes(Util.US_ASCII)); // Last chunk + empty trailer + crlf.
-
-      this.body = bytesOut.toByteArray();
-      return this;
-    } catch (IOException e) {
-      throw new AssertionError(); // In-memory I/O doesn't throw IOExceptions.
+    Buffer bytesOut = new Buffer();
+    while (!body.exhausted()) {
+      long chunkSize = Math.min(body.size(), maxChunkSize);
+      bytesOut.writeUtf8(Long.toHexString(chunkSize));
+      bytesOut.writeUtf8("\r\n");
+      bytesOut.write(body, chunkSize);
+      bytesOut.writeUtf8("\r\n");
     }
+    bytesOut.writeUtf8("0\r\n\r\n"); // Last chunk + empty trailer + CRLF.
+
+    this.body = bytesOut;
+    return this;
   }
 
   /**
@@ -197,11 +187,7 @@
    * every {@code maxChunkSize} bytes.
    */
   public MockResponse setChunkedBody(String body, int maxChunkSize) {
-    try {
-      return setChunkedBody(body.getBytes("UTF-8"), maxChunkSize);
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
-    }
+    return setChunkedBody(new Buffer().writeUtf8(body), maxChunkSize);
   }
 
   public SocketPolicy getSocketPolicy() {
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 16df7f9..0f0a875 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -695,10 +695,8 @@
         }
         spdyHeaders.add(new Header(headerParts[0], headerParts[1]));
       }
-      Buffer body = new Buffer();
-      if (response.getBody() != null) {
-        body.write(response.getBody());
-      }
+      Buffer body = response.getBody();
+      if (body == null) body = new Buffer();
       boolean closeStreamAfterHeaders = body.size() > 0 || !response.getPushPromises().isEmpty();
       stream.reply(spdyHeaders, closeStreamAfterHeaders);
       pushPromises(stream, response.getPushPromises());
@@ -753,9 +751,9 @@
         List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
         requestQueue.add(new RecordedRequest(requestLine, pushPromise.getHeaders(), chunkSizes, 0,
             Util.EMPTY_BYTE_ARRAY, sequenceNumber.getAndIncrement(), socket));
-        byte[] pushedBody = pushPromise.getResponse().getBody();
+        Buffer pushedBody = pushPromise.getResponse().getBody();
         SpdyStream pushedStream =
-            stream.getConnection().pushStream(stream.getId(), pushedHeaders, pushedBody.length > 0);
+            stream.getConnection().pushStream(stream.getId(), pushedHeaders, pushedBody.size() > 0);
         writeResponse(pushedStream, pushPromise.getResponse());
       }
     }
/Fim/
diff --git a/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java b/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
index 46db2be..5590e01 100644
--- a/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
+++ b/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
@@ -219,10 +219,10 @@
     assertEquals(text, EntityUtils.toString(entity, UTF_8));
   }
 
-  private static byte[] gzip(String body) throws IOException {
+  private static Buffer gzip(String body) throws IOException {
     Buffer buffer = new Buffer();
     Okio.buffer(new GzipSink(buffer)).writeUtf8(body).close();
-    return buffer.readByteString(buffer.size()).toByteArray();
+    return buffer;
   }
 
   private static String gunzip(HttpEntity body) throws IOException {
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index c725a75..fe7824a 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -25,11 +25,9 @@
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.OutputStream;
 import java.net.Authenticator;
 import java.net.CookieManager;
 import java.net.HttpURLConnection;
@@ -43,10 +41,13 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.zip.GZIPOutputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Ignore;
@@ -224,8 +225,9 @@
   }
 
   @Test public void gzippedResponseBody() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Encoding: gzip")
-        .setBody(gzip("ABCABCABC".getBytes(Util.UTF_8))));
+    server.enqueue(new MockResponse()
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("ABCABCABC")));
     server.play();
     assertContent("ABCABCABC", client.open(server.getUrl("/r1")), Integer.MAX_VALUE);
   }
@@ -453,12 +455,12 @@
     return result.toString();
   }
 
-  public byte[] gzip(byte[] bytes) throws IOException {
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
-    gzippedOut.write(bytes);
-    gzippedOut.close();
-    return bytesOut.toByteArray();
+  public Buffer gzip(String bytes) throws IOException {
+    Buffer bytesOut = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
+    sink.writeUtf8(bytes);
+    sink.close();
+    return bytesOut;
   }
 
   class SpdyRequest implements Runnable {
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
index 541351a..9052db7 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
@@ -29,7 +29,6 @@
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.BufferedReader;
-import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
@@ -63,11 +62,14 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
-import java.util.zip.GZIPOutputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -936,7 +938,7 @@
 
   private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
     server.enqueue(
-        response.setBody(gzip("ABCABCABC".getBytes("UTF-8"))).addHeader("Content-Encoding: gzip"));
+        response.setBody(gzip("ABCABCABC")).addHeader("Content-Encoding: gzip"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
@@ -952,7 +954,7 @@
 
   @Test public void notModifiedSpecifiesEncoding() throws Exception {
     server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC".getBytes("UTF-8")))
+        .setBody(gzip("ABCABCABC"))
         .addHeader("Content-Encoding: gzip")
         .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
@@ -2013,7 +2015,9 @@
   private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
     response.setSocketPolicy(DISCONNECT_AT_END);
     List<String> headers = new ArrayList<String>(response.getHeaders());
-    response.setBody(Arrays.copyOfRange(response.getBody(), 0, numBytesToKeep));
+    Buffer truncatedBody = new Buffer();
+    truncatedBody.write(response.getBody(), numBytesToKeep);
+    response.setBody(truncatedBody);
     response.getHeaders().clear();
     response.getHeaders().addAll(headers);
     return response;
@@ -2065,18 +2069,18 @@
 
   enum TransferKind {
     CHUNKED() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize)
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
           throws IOException {
         response.setChunkedBody(content, chunkSize);
       }
     },
     FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
       }
     },
     END_OF_STREAM() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
         response.setSocketPolicy(DISCONNECT_AT_END);
         for (Iterator<String> h = response.getHeaders().iterator(); h.hasNext(); ) {
@@ -2088,10 +2092,10 @@
       }
     };
 
-    abstract void setBody(MockResponse response, byte[] content, int chunkSize) throws IOException;
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
 
     void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, content.getBytes("UTF-8"), chunkSize);
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
     }
   }
 
@@ -2100,12 +2104,12 @@
   }
 
   /** Returns a gzipped copy of {@code bytes}. */
-  public byte[] gzip(byte[] bytes) throws IOException {
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
-    gzippedOut.write(bytes);
-    gzippedOut.close();
-    return bytesOut.toByteArray();
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
   }
 
   static abstract class AbstractOkResponseCache implements OkResponseCache {
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheTest.java
index 1cbd654..849658f 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheTest.java
@@ -56,12 +56,15 @@
 import java.util.TimeZone;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
-import java.util.zip.GZIPOutputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSession;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -734,7 +737,7 @@
 
   private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
     server.enqueue(
-        response.setBody(gzip("ABCABCABC".getBytes("UTF-8"))).addHeader("Content-Encoding: gzip"));
+        response.setBody(gzip("ABCABCABC")).addHeader("Content-Encoding: gzip"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
@@ -750,7 +753,7 @@
 
   @Test public void notModifiedSpecifiesEncoding() throws Exception {
     server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC".getBytes("UTF-8")))
+        .setBody(gzip("ABCABCABC"))
         .addHeader("Content-Encoding: gzip")
         .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
@@ -1420,7 +1423,9 @@
   private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
     response.setSocketPolicy(DISCONNECT_AT_END);
     List<String> headers = new ArrayList<String>(response.getHeaders());
-    response.setBody(Arrays.copyOfRange(response.getBody(), 0, numBytesToKeep));
+    Buffer truncatedBody = new Buffer();
+    truncatedBody.write(response.getBody(), numBytesToKeep);
+    response.setBody(truncatedBody);
     response.getHeaders().clear();
     response.getHeaders().addAll(headers);
     return response;
@@ -1471,18 +1476,18 @@
 
   enum TransferKind {
     CHUNKED() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize)
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
           throws IOException {
         response.setChunkedBody(content, chunkSize);
       }
     },
     FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
       }
     },
     END_OF_STREAM() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
         response.setSocketPolicy(DISCONNECT_AT_END);
         for (Iterator<String> h = response.getHeaders().iterator(); h.hasNext(); ) {
@@ -1494,10 +1499,10 @@
       }
     };
 
-    abstract void setBody(MockResponse response, byte[] content, int chunkSize) throws IOException;
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
 
     void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, content.getBytes("UTF-8"), chunkSize);
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
     }
   }
 
@@ -1506,12 +1511,12 @@
   }
 
   /** Returns a gzipped copy of {@code bytes}. */
-  public byte[] gzip(byte[] bytes) throws IOException {
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
-    gzippedOut.write(bytes);
-    gzippedOut.close();
-    return bytesOut.toByteArray();
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
   }
 
   private static class InsecureResponseCache extends ResponseCache {
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index cecbdb8..16fe0f6 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -29,7 +29,6 @@
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -66,7 +65,6 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.zip.GZIPInputStream;
-import java.util.zip.GZIPOutputStream;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLException;
@@ -74,6 +72,10 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Ignore;
@@ -710,10 +712,10 @@
   @Test public void contentDisagreesWithChunkedHeader() throws IOException {
     MockResponse mockResponse = new MockResponse();
     mockResponse.setChunkedBody("abc", 3);
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    bytesOut.write(mockResponse.getBody());
-    bytesOut.write("\r\nYOU SHOULD NOT SEE THIS".getBytes("UTF-8"));
-    mockResponse.setBody(bytesOut.toByteArray());
+    Buffer buffer = new Buffer();
+    buffer.writeAll(mockResponse.getBody());
+    buffer.write("\r\nYOU SHOULD NOT SEE THIS".getBytes("UTF-8"));
+    mockResponse.setBody(buffer);
     mockResponse.clearHeaders();
     mockResponse.addHeader("Transfer-encoding: chunked");
 
@@ -1086,7 +1088,8 @@
    * imply a bug in the implementation.
    */
   @Test public void gzipEncodingEnabledByDefault() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody(gzip("ABCABCABC".getBytes("UTF-8")))
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
         .addHeader("Content-Encoding: gzip"));
     server.play();
 
@@ -1100,7 +1103,7 @@
   }
 
   @Test public void clientConfiguredGzipContentEncoding() throws Exception {
-    byte[] bodyBytes = gzip("ABCDEFGHIJKLMNOPQRSTUVWXYZ".getBytes("UTF-8"));
+    Buffer bodyBytes = gzip("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
     server.enqueue(new MockResponse()
         .setBody(bodyBytes)
         .addHeader("Content-Encoding: gzip"));
@@ -1110,7 +1113,7 @@
     connection.addRequestProperty("Accept-Encoding", "gzip");
     InputStream gunzippedIn = new GZIPInputStream(connection.getInputStream());
     assertEquals("ABCDEFGHIJKLMNOPQRSTUVWXYZ", readAscii(gunzippedIn, Integer.MAX_VALUE));
-    assertEquals(bodyBytes.length, connection.getContentLength());
+    assertEquals(bodyBytes.size(), connection.getContentLength());
 
     RecordedRequest request = server.takeRequest();
     assertContains(request.getHeaders(), "Accept-Encoding: gzip");
@@ -1162,7 +1165,7 @@
 
     MockResponse responseOne = new MockResponse();
     responseOne.addHeader("Content-Encoding: gzip");
-    transferKind.setBody(responseOne, gzip("one (gzipped)".getBytes("UTF-8")), 5);
+    transferKind.setBody(responseOne, gzip("one (gzipped)"), 5);
     server.enqueue(responseOne);
     MockResponse responseTwo = new MockResponse();
     transferKind.setBody(responseTwo, "two (identity)", 5);
@@ -1186,7 +1189,7 @@
         .setSocketPolicy(SHUTDOWN_INPUT_AT_END));
     server.enqueue(new MockResponse()
         .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("b".getBytes(UTF_8))));
+        .setBody(gzip("b")));
     server.play();
 
     // Seed the pool with a bad connection.
@@ -1253,7 +1256,7 @@
   @Test public void streamDiscardingIsTimely() throws Exception {
     // This response takes at least a full second to serve: 10,000 bytes served 100 bytes at a time.
     server.enqueue(new MockResponse()
-        .setBody(new byte[10000])
+        .setBody(new Buffer().write(new byte[10000]))
         .throttleBody(100, 10, MILLISECONDS));
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
@@ -2176,7 +2179,7 @@
   }
 
   @Test public void singleByteReadIsSigned() throws IOException {
-    server.enqueue(new MockResponse().setBody(new byte[] {-2, -1}));
+    server.enqueue(new MockResponse().setBody(new Buffer().writeByte(-2).writeByte(-1)));
     server.play();
 
     connection = client.open(server.getUrl("/"));
@@ -2836,7 +2839,7 @@
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /foo")
         .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("Moved! Moved! Moved!".getBytes(UTF_8))));
+        .setBody(gzip("Moved! Moved! Moved!")));
     server.enqueue(new MockResponse().setBody("This is the new page!"));
     server.play();
 
@@ -2870,12 +2873,12 @@
   }
 
   /** Returns a gzipped copy of {@code bytes}. */
-  public byte[] gzip(byte[] bytes) throws IOException {
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
-    gzippedOut.write(bytes);
-    gzippedOut.close();
-    return bytesOut.toByteArray();
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink gzipSink = Okio.buffer(new GzipSink(result));
+    gzipSink.writeUtf8(data);
+    gzipSink.close();
+    return result;
   }
 
   /**
@@ -2910,7 +2913,7 @@
 
   enum TransferKind {
     CHUNKED() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize)
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
           throws IOException {
         response.setChunkedBody(content, chunkSize);
       }
@@ -2919,7 +2922,7 @@
       }
     },
     FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
       }
       @Override void setForRequest(HttpURLConnection connection, int contentLength) {
@@ -2927,7 +2930,7 @@
       }
     },
     END_OF_STREAM() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
         response.setSocketPolicy(DISCONNECT_AT_END);
         for (Iterator<String> h = response.getHeaders().iterator(); h.hasNext(); ) {
@@ -2941,12 +2944,12 @@
       }
     };
 
-    abstract void setBody(MockResponse response, byte[] content, int chunkSize) throws IOException;
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
 
     abstract void setForRequest(HttpURLConnection connection, int contentLength);
 
     void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, content.getBytes("UTF-8"), chunkSize);
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
     }
   }
 
/Fim/
diff --git a/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java b/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
index cb0e24e..e15044b 100644
--- a/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
+++ b/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
@@ -16,6 +16,8 @@
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.TrustManagerFactory;
+import okio.Buffer;
+import okio.Okio;
 
 public class SampleServer extends Dispatcher {
   private final SSLContext sslContext;
@@ -82,9 +84,9 @@
         .addHeader("content-type: " + contentType(path));
   }
 
-  private byte[] fileToBytes(File file) throws IOException {
-    byte[] result = new byte[(int) file.length()];
-    Util.readFully(new FileInputStream(file), result);
+  private Buffer fileToBytes(File file) throws IOException {
+    Buffer result = new Buffer();
+    result.writeAll(Okio.source(new FileInputStream(file)));
     return result;
   }
 
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index 16fe0f6..6a45924 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -2506,7 +2506,7 @@
 
   private void reusedConnectionFailsWithPost(TransferKind transferKind, int requestSize)
       throws Exception {
-    server.enqueue(new MockResponse().setBody("A").setSocketPolicy(SHUTDOWN_INPUT_AT_END));
+    server.enqueue(new MockResponse().setBody("A").setSocketPolicy(DISCONNECT_AT_END));
     server.enqueue(new MockResponse().setBody("B"));
     server.enqueue(new MockResponse().setBody("C"));
     server.play();
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
index a08773f..326872a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
@@ -179,10 +179,7 @@
     int suffixLength = cn.length() - (asterisk + 1);
     int suffixStart = hostName.length() - suffixLength;
     if (hostName.indexOf('.', asterisk) < suffixStart) {
-      // TODO: remove workaround for *.clients.google.com http://b/5426333
-      if (!hostName.endsWith(".clients.google.com")) {
-        return false; // wildcard '*' can't match a '.'
-      }
+      return false; // wildcard '*' can't match a '.'
     }
 
     if (!hostName.regionMatches(suffixStart, cn, asterisk + 1, suffixLength)) {
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
index 089c73e..91534c2 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
@@ -84,7 +84,7 @@
   int headerCount;
 
   /** Which ALPN/NPN protocols are in use. Only useful with TLS. */
-  List<Protocol> protocols = Arrays.asList(Protocol.HTTP_11);
+  List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
 
   public static void main(String[] args) {
     List<String> allArgs = new ArrayList<String>();
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index dacf227..dc4d742 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -111,7 +111,7 @@
   private int port = -1;
   private boolean npnEnabled = true;
   private List<Protocol> npnProtocols
-      = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_11);
+      = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
 
   public int getPort() {
     if (port == -1) throw new IllegalStateException("Cannot retrieve port before calling play()");
@@ -180,7 +180,7 @@
    */
   public void setNpnProtocols(List<Protocol> protocols) {
     protocols = Util.immutableList(protocols);
-    if (!protocols.contains(Protocol.HTTP_11)) {
+    if (!protocols.contains(Protocol.HTTP_1_1)) {
       throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
     }
     if (protocols.contains(null)) {
@@ -309,7 +309,7 @@
       }
 
       public void processConnection() throws Exception {
-        Protocol protocol = Protocol.HTTP_11;
+        Protocol protocol = Protocol.HTTP_1_1;
         Socket socket;
         if (sslSocketFactory != null) {
           if (tunnelProxy) {
@@ -337,14 +337,14 @@
             ByteString protocolBytes = Platform.get().getNpnSelectedProtocol(sslSocket);
             protocol = protocolBytes != null
                 ? Protocol.get(protocolBytes.utf8())
-                : Protocol.HTTP_11;
+                : Protocol.HTTP_1_1;
           }
           openClientSockets.remove(raw);
         } else {
           socket = raw;
         }
 
-        if (protocol != Protocol.HTTP_11) {
+        if (protocol != Protocol.HTTP_1_1) {
           SpdySocketHandler spdySocketHandler = new SpdySocketHandler(socket, protocol);
           SpdyConnection spdyConnection = new SpdyConnection.Builder(false, socket)
               .protocol(protocol)
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
index e4b8b51..716c502 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
@@ -75,7 +75,7 @@
     httpServer.play();
     httpAddress = new Address(httpServer.getHostName(), httpServer.getPort(), socketFactory, null,
         null, HttpAuthenticator.SYSTEM_DEFAULT, null,
-        Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_11));
+        Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1));
     httpSocketAddress = new InetSocketAddress(InetAddress.getByName(httpServer.getHostName()),
         httpServer.getPort());
 
@@ -83,7 +83,7 @@
     spdyAddress = new Address(spdyServer.getHostName(), spdyServer.getPort(), socketFactory,
         sslContext.getSocketFactory(), new RecordingHostnameVerifier(),
         HttpAuthenticator.SYSTEM_DEFAULT, null,
-        Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_11));
+        Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1));
     spdySocketAddress = new InetSocketAddress(InetAddress.getByName(spdyServer.getHostName()),
         spdyServer.getPort());
 
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
index eb833e7..b3f5470 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
@@ -33,7 +33,7 @@
   public static void main(String[] args) throws Exception {
     URL url = new URL("https://http2.iijplus.jp/push/test1");
     HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient()
-        .setProtocols(Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_11))
+        .setProtocols(Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1))
         .open(url);
 
     connection.setHostnameVerifier(new HostnameVerifier() {
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
index 03b0f9d..b155fb2 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
@@ -33,7 +33,7 @@
   public static void main(String[] args) throws Exception {
     URL url = new URL("https://www.google.ca/");
     HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient()
-        .setProtocols(Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_11)).open(url);
+        .setProtocols(Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1)).open(url);
 
     connection.setHostnameVerifier(new HostnameVerifier() {
       @Override public boolean verify(String s, SSLSession sslSession) {
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index fe7824a..99080cc 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -86,7 +86,7 @@
 
   @Before public void setUp() throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false);
-    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_11));
+    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     String systemTmpDir = System.getProperty("java.io.tmpdir");
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
index ebfb282..ecf337c 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
@@ -79,7 +79,7 @@
   }
 
   private final OkAuthenticator authenticator = HttpAuthenticator.SYSTEM_DEFAULT;
-  private final List<Protocol> protocols = Arrays.asList(Protocol.HTTP_11);
+  private final List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
   private final FakeDns dns = new FakeDns();
   private final FakeProxySelector proxySelector = new FakeProxySelector();
 
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index efd9962..49c7219 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -2720,7 +2720,7 @@
     enableNpn(protocol);
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    client.setProtocols(Arrays.asList(Protocol.HTTP_11, protocol));
+    client.setProtocols(Arrays.asList(Protocol.HTTP_1_1, protocol));
     connection = client.open(server.getUrl("/"));
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
     assertEquals(Arrays.asList(protocol.toString()), protocolValues);
@@ -2776,7 +2776,7 @@
   @Test public void setProtocols() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    client.setProtocols(Arrays.asList(Protocol.HTTP_11));
+    client.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
     assertContent("A", client.open(server.getUrl("/")));
   }
 
@@ -2790,7 +2790,7 @@
 
   @Test public void setProtocolsWithNull() throws Exception {
     try {
-      client.setProtocols(Arrays.asList(Protocol.HTTP_11, null));
+      client.setProtocols(Arrays.asList(Protocol.HTTP_1_1, null));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -3065,7 +3065,7 @@
   private void enableNpn(Protocol protocol) {
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_11));
+    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
     server.useHttps(sslContext.getSocketFactory(), false);
     server.setNpnEnabled(true);
     server.setNpnProtocols(client.getProtocols());
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Address.java b/okhttp/src/main/java/com/squareup/okhttp/Address.java
index 8f80cf4..d044f57 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Address.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Address.java
@@ -108,7 +108,7 @@
   /**
    * Returns the protocols the client supports. This method always returns a
    * non-null list that contains minimally
-   * {@link Protocol#HTTP_11}.
+   * {@link Protocol#HTTP_1_1}.
    */
   public List<Protocol> getProtocols() {
     return protocols;
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index eb223cc..a9c519f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -195,12 +195,12 @@
     handshake = Handshake.get(sslSocket.getSession());
 
     ByteString maybeProtocol;
-    Protocol selectedProtocol = Protocol.HTTP_11;
+    Protocol selectedProtocol = Protocol.HTTP_1_1;
     if (useNpn && (maybeProtocol = platform.getNpnSelectedProtocol(sslSocket)) != null) {
       selectedProtocol = Protocol.get(maybeProtocol.utf8()); // Throws IOE on unknown.
     }
 
-    if (selectedProtocol == Protocol.HTTP_11) {
+    if (selectedProtocol == Protocol.HTTP_1_1) {
       httpConnection = new HttpConnection(pool, this, socket, readTimeout, writeTimeout);
     } else {
       sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index ffe68b9..ed54fc8 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -338,7 +338,7 @@
    */
   public OkHttpClient setProtocols(List<Protocol> protocols) {
     protocols = Util.immutableList(protocols);
-    if (!protocols.contains(Protocol.HTTP_11)) {
+    if (!protocols.contains(Protocol.HTTP_1_1)) {
       throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
     }
     if (protocols.contains(null)) {
@@ -447,7 +447,7 @@
       result.connectionPool = ConnectionPool.getDefault();
     }
     if (result.protocols == null) {
-      result.protocols = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_11);
+      result.protocols = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
     }
     return result;
   }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
index b4c0286..e73491e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
@@ -31,7 +31,7 @@
 public enum Protocol {
   HTTP_2("h2-10"),
   SPDY_3("spdy/3.1"),
-  HTTP_11("http/1.1");
+  HTTP_1_1("http/1.1");
 
   private final String protocol;
 
@@ -45,7 +45,7 @@
    */
   public static Protocol get(String protocol) throws IOException {
     // Unroll the loop over values() to save an allocation.
-    if (protocol.equals(HTTP_11.protocol)) return HTTP_11;
+    if (protocol.equals(HTTP_1_1.protocol)) return HTTP_1_1;
     if (protocol.equals(HTTP_2.protocol)) return HTTP_2;
     if (protocol.equals(SPDY_3.protocol)) return SPDY_3;
     throw new IOException("Unexpected protocol: " + protocol);
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
index fd198d8..15aaff4 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
@@ -189,7 +189,7 @@
 
       Response.Builder responseBuilder = new Response.Builder()
           .statusLine(statusLine)
-          .header(OkHeaders.SELECTED_PROTOCOL, Protocol.HTTP_11.toString());
+          .header(OkHeaders.SELECTED_PROTOCOL, Protocol.HTTP_1_1.toString());
 
       Headers.Builder headersBuilder = new Headers.Builder();
       readHeaders(headersBuilder);
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
index e73491e..d2b9220 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
@@ -29,9 +29,40 @@
  * to identify how HTTP messages are framed.
  */
 public enum Protocol {
-  HTTP_2("h2-10"),
+  /**
+   * A plaintext framing that includes persistent connections.
+   *
+   * <p>This version of OkHttp implements <a
+   * href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>, and tracks
+   * revisions to that spec.
+   */
+  HTTP_1_1("http/1.1"),
+
+  /**
+   * Chromium's binary-framed protocol that includes header compression,
+   * multiplexing multiple requests on the same socket, and server-push.
+   * HTTP/1.1 semantics are layered on SPDY/3.
+   *
+   * <p>This version of OkHttp implements SPDY 3 <a
+   * href="http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">draft
+   * 3.1</a>. Future releases of OkHttp may use this identifier for a newer draft
+   * of the SPDY spec.
+   */
   SPDY_3("spdy/3.1"),
-  HTTP_1_1("http/1.1");
+
+  /**
+   * The IETF's binary-framed protocol that includes header compression,
+   * multiplexing multiple requests on the same socket, and server-push.
+   * HTTP/1.1 semantics are layered on HTTP/2.
+   *
+   * <p>This version of OkHttp implements HTTP/2 <a
+   * href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-10">draft 10</a>
+   * with HPACK <a
+   * href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06">draft
+   * 6</a>. Future releases of OkHttp may use this identifier for a newer draft
+   * of these specs.
+   */
+  HTTP_2("h2-10");
 
   private final String protocol;
 
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index dc4d742..861b0e9 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -334,9 +334,9 @@
           sslSocket.startHandshake();
 
           if (npnEnabled) {
-            ByteString protocolBytes = Platform.get().getNpnSelectedProtocol(sslSocket);
-            protocol = protocolBytes != null
-                ? Protocol.get(protocolBytes.utf8())
+            String protocolString = Platform.get().getNpnSelectedProtocol(sslSocket);
+            protocol = protocolString != null
+                ? Protocol.get(protocolString)
                 : Protocol.HTTP_1_1;
           }
           openClientSockets.remove(raw);
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
index 885570a..9cf2512 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Protocol;
 import java.io.IOException;
 import java.net.ProtocolException;
 import org.junit.Test;
@@ -29,7 +30,7 @@
     int code = 200;
     StatusLine statusLine = new StatusLine("HTTP/1." + version + " " + code + " " + message);
     assertEquals(message, statusLine.message());
-    assertEquals(version, statusLine.httpMinorVersion());
+    assertEquals(Protocol.HTTP_1_1, statusLine.protocol());
     assertEquals(code, statusLine.code());
   }
 
@@ -38,7 +39,7 @@
     int code = 503;
     StatusLine statusLine = new StatusLine("HTTP/1." + version + " " + code + " ");
     assertEquals("", statusLine.message());
-    assertEquals(version, statusLine.httpMinorVersion());
+    assertEquals(Protocol.HTTP_1_1, statusLine.protocol());
     assertEquals(code, statusLine.code());
   }
 
@@ -52,7 +53,7 @@
     int code = 503;
     StatusLine statusLine = new StatusLine("HTTP/1." + version + " " + code);
     assertEquals("", statusLine.message());
-    assertEquals(version, statusLine.httpMinorVersion());
+    assertEquals(Protocol.HTTP_1_1, statusLine.protocol());
     assertEquals(code, statusLine.code());
   }
 
@@ -60,7 +61,7 @@
   @Test public void shoutcast() throws IOException {
     StatusLine statusLine = new StatusLine("ICY 200 OK");
     assertEquals("OK", statusLine.message());
-    assertEquals(0, statusLine.httpMinorVersion());
+    assertEquals(Protocol.HTTP_1_0, statusLine.protocol());
     assertEquals(200, statusLine.code());
   }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index 045db0d..0e6fe43 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -28,7 +28,6 @@
 import java.net.Proxy;
 import java.net.Socket;
 import javax.net.ssl.SSLSocket;
-import okio.ByteString;
 
 import static java.net.HttpURLConnection.HTTP_OK;
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
@@ -67,7 +66,7 @@
   private boolean connected = false;
   private HttpConnection httpConnection;
   private SpdyConnection spdyConnection;
-  private int httpMinorVersion = 1; // Assume HTTP/1.1
+  private Protocol protocol = Protocol.HTTP_1_1;
   private long idleStartTimeNs;
   private Handshake handshake;
   private int recycleCount;
@@ -194,16 +193,15 @@
 
     handshake = Handshake.get(sslSocket.getSession());
 
-    ByteString maybeProtocol;
-    Protocol selectedProtocol = Protocol.HTTP_1_1;
+    String maybeProtocol;
     if (useNpn && (maybeProtocol = platform.getNpnSelectedProtocol(sslSocket)) != null) {
-      selectedProtocol = Protocol.get(maybeProtocol.utf8()); // Throws IOE on unknown.
+      protocol = Protocol.get(maybeProtocol); // Throws IOE on unknown.
     }
 
-    if (selectedProtocol == Protocol.SPDY_3 || selectedProtocol == Protocol.HTTP_2) {
+    if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
       sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
       spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, socket)
-          .protocol(selectedProtocol).build();
+          .protocol(protocol).build();
       spdyConnection.sendConnectionHeader();
     } else {
       httpConnection = new HttpConnection(pool, this, socket, readTimeout, writeTimeout);
@@ -293,16 +291,20 @@
   }
 
   /**
-   * Returns the minor HTTP version that should be used for future requests on
-   * this connection. Either 0 for HTTP/1.0, or 1 for HTTP/1.1. The default
-   * value is 1 for new connections.
+   * Returns the protocol negotiated by this connection, or {@link
+   * Protocol#HTTP_1_1} if no protocol has been negotiated.
    */
-  public int getHttpMinorVersion() {
-    return httpMinorVersion;
+  public Protocol getProtocol() {
+    return protocol;
   }
 
-  public void setHttpMinorVersion(int httpMinorVersion) {
-    this.httpMinorVersion = httpMinorVersion;
+  /**
+   * Sets the protocol negotiated by this connection. Typically this is used
+   * when an HTTP/1.1 request is sent and an HTTP/1.0 response is received.
+   */
+  public void setProtocol(Protocol protocol) {
+    if (protocol == null) throw new IllegalArgumentException("protocol == null");
+    this.protocol = protocol;
   }
 
   /**
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index 515a5d2..da16e80 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -81,8 +81,8 @@
     return statusLine.message();
   }
 
-  public int httpMinorVersion() {
-    return statusLine.httpMinorVersion();
+  public Protocol protocol() {
+    return statusLine.protocol();
   }
 
   /**
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
index ce3e800..d71f372 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -38,7 +38,6 @@
 import java.util.zip.DeflaterOutputStream;
 import javax.net.ssl.SSLSocket;
 import okio.Buffer;
-import okio.ByteString;
 
 /**
  * Access to Platform-specific features necessary for SPDY and advanced TLS.
@@ -111,7 +110,7 @@
   }
 
   /** Returns the negotiated protocol, or null if no protocol was negotiated. */
-  public ByteString getNpnSelectedProtocol(SSLSocket socket) {
+  public String getNpnSelectedProtocol(SSLSocket socket) {
     return null;
   }
 
@@ -270,13 +269,13 @@
       }
     }
 
-    @Override public ByteString getNpnSelectedProtocol(SSLSocket socket) {
+    @Override public String getNpnSelectedProtocol(SSLSocket socket) {
       if (getNpnSelectedProtocol == null) return null;
       if (!openSslSocketClass.isInstance(socket)) return null;
       try {
         byte[] npnResult = (byte[]) getNpnSelectedProtocol.invoke(socket);
         if (npnResult == null) return null;
-        return ByteString.of(npnResult);
+        return new String(npnResult, Util.UTF_8);
       } catch (InvocationTargetException e) {
         throw new RuntimeException(e);
       } catch (IllegalAccessException e) {
@@ -318,7 +317,7 @@
       }
     }
 
-    @Override public ByteString getNpnSelectedProtocol(SSLSocket socket) {
+    @Override public String getNpnSelectedProtocol(SSLSocket socket) {
       try {
         JettyNpnProvider provider =
             (JettyNpnProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
@@ -328,7 +327,7 @@
               "NPN callback dropped so SPDY is disabled. Is npn-boot on the boot class path?");
           return null;
         }
-        return provider.unsupported ? null : ByteString.encodeUtf8(provider.selected);
+        return provider.unsupported ? null : provider.selected;
       } catch (InvocationTargetException e) {
         throw new AssertionError();
       } catch (IllegalAccessException e) {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
index 1b2dd6f..7206ec2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
@@ -191,7 +191,7 @@
 
       Headers.Builder headersBuilder = new Headers.Builder();
       readHeaders(headersBuilder);
-      headersBuilder.add(OkHeaders.SELECTED_PROTOCOL, statusLine.getProtocol().toString());
+      headersBuilder.add(OkHeaders.SELECTED_PROTOCOL, statusLine.protocol().toString());
       responseBuilder.headers(headersBuilder.build());
 
       if (statusLine.code() != HTTP_CONTINUE) {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 8a2c308..fdeadcd 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -22,6 +22,7 @@
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.OkResponseCache;
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseSource;
@@ -526,7 +527,7 @@
       result.header("Host", hostHeader(request.url()));
     }
 
-    if ((connection == null || connection.getHttpMinorVersion() != 0)
+    if ((connection == null || connection.getProtocol() != Protocol.HTTP_1_0)
         && request.header("Connection") == null) {
       result.header("Connection", "Keep-Alive");
     }
@@ -613,7 +614,7 @@
         .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
         .setResponseSource(responseSource)
         .build();
-    connection.setHttpMinorVersion(response.httpMinorVersion());
+    connection.setProtocol(response.protocol());
     receiveHeaders(response.headers());
 
     if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
index 2ffe039..0a1f8a7 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
@@ -93,7 +93,7 @@
     httpEngine.writingRequestHeaders();
     String requestLine = RequestLine.get(request,
         httpEngine.getConnection().getRoute().getProxy().type(),
-        httpEngine.getConnection().getHttpMinorVersion());
+        httpEngine.getConnection().getProtocol());
     httpConnection.writeRequest(request.getHeaders(), requestLine);
   }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
index c918df3..54f5786 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
@@ -1,5 +1,6 @@
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import java.net.Proxy;
 import java.net.URL;
@@ -13,7 +14,7 @@
    * to the application by {@link HttpURLConnectionImpl#getHeaderFields}, so
    * it needs to be set even if the transport is SPDY.
    */
-  static String get(Request request, Proxy.Type proxyType, int httpMinorVersion) {
+  static String get(Request request, Proxy.Type proxyType, Protocol protocol) {
     StringBuilder result = new StringBuilder();
     result.append(request.method());
     result.append(" ");
@@ -25,7 +26,7 @@
     }
 
     result.append(" ");
-    result.append(version(httpMinorVersion));
+    result.append(version(protocol));
     return result.toString();
   }
 
@@ -49,7 +50,7 @@
     return pathAndQuery;
   }
 
-  public static String version(int httpMinorVersion) {
-    return httpMinorVersion == 1 ? "HTTP/1.1" : "HTTP/1.0";
+  public static String version(Protocol protocol) {
+    return protocol == Protocol.HTTP_1_0 ? "HTTP/1.0" : "HTTP/1.1";
   }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index a03fe30..a23787f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -89,7 +89,7 @@
     httpEngine.writingRequestHeaders();
     boolean hasRequestBody = httpEngine.hasRequestBody();
     boolean hasResponseBody = true;
-    String version = RequestLine.version(httpEngine.getConnection().getHttpMinorVersion());
+    String version = RequestLine.version(httpEngine.getConnection().getProtocol());
     stream = spdyConnection.newStream(
         writeNameValueBlock(request, spdyConnection.getProtocol(), version), hasRequestBody,
         hasResponseBody);
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
index 72e401f..fc7f5af 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
@@ -10,7 +10,7 @@
   public static final int HTTP_CONTINUE = 100;
 
   private final String statusLine;
-  private final int httpMinorVersion;
+  private final Protocol protocol;
   private final int responseCode;
   private final String responseMessage;
 
@@ -21,19 +21,23 @@
 
     // Parse protocol like "HTTP/1.1" followed by a space.
     int codeStart;
-    int httpMinorVersion;
+    Protocol protocol;
     if (statusLine.startsWith("HTTP/1.")) {
       if (statusLine.length() < 9 || statusLine.charAt(8) != ' ') {
         throw new ProtocolException("Unexpected status line: " + statusLine);
       }
-      httpMinorVersion = statusLine.charAt(7) - '0';
+      int httpMinorVersion = statusLine.charAt(7) - '0';
       codeStart = 9;
-      if (httpMinorVersion < 0 || httpMinorVersion > 9) {
+      if (httpMinorVersion == 0) {
+        protocol = Protocol.HTTP_1_0;
+      } else if (httpMinorVersion == 1) {
+        protocol = Protocol.HTTP_1_1;
+      } else {
         throw new ProtocolException("Unexpected status line: " + statusLine);
       }
     } else if (statusLine.startsWith("ICY ")) {
       // Shoutcast uses ICY instead of "HTTP/1.0".
-      httpMinorVersion = 0;
+      protocol = Protocol.HTTP_1_0;
       codeStart = 4;
     } else {
       throw new ProtocolException("Unexpected status line: " + statusLine);
@@ -63,23 +67,16 @@
     this.responseMessage = responseMessage;
     this.responseCode = responseCode;
     this.statusLine = statusLine;
-    this.httpMinorVersion = httpMinorVersion;
+    this.protocol = protocol;
   }
 
   public String getStatusLine() {
     return statusLine;
   }
 
-  /**
-   * Returns the status line's HTTP minor version. This returns 0 for HTTP/1.0
-   * and 1 for HTTP/1.1. This returns 1 if the HTTP version is unknown.
-   */
-  public int httpMinorVersion() {
-    return httpMinorVersion != -1 ? httpMinorVersion : 1;
-  }
-
-  public Protocol getProtocol() {
-    return httpMinorVersion == 0 ? Protocol.HTTP_1_0 : Protocol.HTTP_1_1;
+  /** Returns either {@link Protocol#HTTP_1_1} or {@link Protocol#HTTP_1_0}. */
+  public Protocol protocol() {
+    return protocol;
   }
 
   /** Returns the HTTP status code or -1 if it is unknown. */
/Fim/
diff --git a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
index f223551..3f4e725 100644
--- a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
+++ b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
@@ -23,6 +23,7 @@
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.http.StatusLine;
 import io.airlift.command.Arguments;
 import io.airlift.command.Command;
 import io.airlift.command.HelpOption;
@@ -127,7 +128,7 @@
     try {
       Response response = client.execute(request);
       if (showHeaders) {
-        System.out.println(response.statusLine());
+        System.out.println(StatusLine.get(response));
         Headers headers = response.headers();
         for (int i = 0, count = headers.size(); i < count; i++) {
           System.out.println(headers.name(i) + ": " + headers.value(i));
/Fim/
diff --git a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
index 5ac0db4..d05591f 100644
--- a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
+++ b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
@@ -68,7 +68,7 @@
 
   private static HttpResponse transformResponse(Response response) {
     int code = response.code();
-    String message = response.statusMessage();
+    String message = response.message();
     BasicHttpResponse httpResponse = new BasicHttpResponse(HTTP_1_1, code, message);
 
     Response.Body body = response.body();
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
index 0f18da8..5d3c950 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
@@ -40,7 +40,9 @@
         SpdyTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
     Headers headers = response.headers();
     assertEquals(4, headers.size());
-    assertEquals("HTTP/1.1 200 OK", response.statusLine());
+    assertEquals(Protocol.HTTP_1_1, response.protocol());
+    assertEquals(200, response.code());
+    assertEquals("OK", response.message());
     assertEquals("no-cache, no-store", headers.get("cache-control"));
     assertEquals("Cookie2", headers.get("set-cookie"));
     assertEquals(Protocol.SPDY_3.toString(), headers.get(OkHeaders.SELECTED_PROTOCOL));
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/JavaApiConverterTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/JavaApiConverterTest.java
index 19275d2..5769047 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/JavaApiConverterTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/JavaApiConverterTest.java
@@ -20,6 +20,7 @@
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.SslContextBuilder;
@@ -183,7 +184,9 @@
     assertEquals("GET", request.method());
 
     // Check the response
-    assertEquals(statusLine, response.statusLine());
+    assertEquals(Protocol.HTTP_1_1, response.protocol());
+    assertEquals(200, response.code());
+    assertEquals("Fantastic", response.message());
     Headers okResponseHeaders = response.headers();
     assertEquals("baz", okResponseHeaders.get("xyzzy"));
     assertEquals(body, response.body().string());
@@ -225,7 +228,9 @@
     Response response = JavaApiConverter.createOkResponse(request, cacheResponse);
     assertSame(request, response.request());
 
-    assertNotNullAndEquals(statusLine, response.statusLine());
+    assertEquals(Protocol.HTTP_1_1, response.protocol());
+    assertEquals(200, response.code());
+    assertEquals("Fantastic", response.message());
     Headers okResponseHeaders = response.headers();
     assertEquals("baz", okResponseHeaders.get("xyzzy"));
     assertEquals("HelloWorld", response.body().string());
@@ -283,7 +288,9 @@
     Response response = JavaApiConverter.createOkResponse(request, cacheResponse);
     assertSame(request, response.request());
 
-    assertNotNullAndEquals(statusLine, response.statusLine());
+    assertEquals(Protocol.HTTP_1_1, response.protocol());
+    assertEquals(200, response.code());
+    assertEquals("Fantastic", response.message());
     Headers okResponseHeaders = response.headers();
     assertEquals("baz", okResponseHeaders.get("xyzzy"));
     assertEquals("HelloWorld", response.body().string());
@@ -425,11 +432,12 @@
   }
 
   @Test public void createJavaUrlConnection_responseHeadersOk() throws Exception {
-    final String statusLine = "HTTP/1.1 200 Fantastic";
     Response.Body responseBody = createResponseBody("BodyText");
     Response okResponse = new Response.Builder()
         .request(createArbitraryOkRequest())
-        .statusLine(statusLine)
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Fantastic")
         .addHeader("A", "c")
         .addHeader("B", "d")
         .addHeader("A", "e")
@@ -443,20 +451,20 @@
     assertEquals(responseBody.contentLength(), httpUrlConnection.getContentLength());
 
     // Check retrieval by string key.
-    assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
+    assertEquals("HTTP/1.1 200 Fantastic", httpUrlConnection.getHeaderField(null));
     assertEquals("e", httpUrlConnection.getHeaderField("A"));
     // The RI and OkHttp supports case-insensitive matching for this method.
     assertEquals("e", httpUrlConnection.getHeaderField("a"));
 
     // Check retrieval using a Map.
     Map<String, List<String>> responseHeaders = httpUrlConnection.getHeaderFields();
-    assertEquals(Arrays.asList(statusLine), responseHeaders.get(null));
+    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), responseHeaders.get(null));
     assertEquals(newSet("c", "e"), newSet(responseHeaders.get("A")));
     // OkHttp supports case-insensitive matching here. The RI does not.
     assertEquals(newSet("c", "e"), newSet(responseHeaders.get("a")));
 
     // Check the Map iterator contains the expected mappings.
-    assertHeadersContainsMapping(responseHeaders, null, statusLine);
+    assertHeadersContainsMapping(responseHeaders, null, "HTTP/1.1 200 Fantastic");
     assertHeadersContainsMapping(responseHeaders, "A", "c", "e");
     assertHeadersContainsMapping(responseHeaders, "B", "d");
 
@@ -474,7 +482,7 @@
 
     // Check retrieval of headers by index.
     assertEquals(null, httpUrlConnection.getHeaderFieldKey(0));
-    assertEquals(statusLine, httpUrlConnection.getHeaderField(0));
+    assertEquals("HTTP/1.1 200 Fantastic", httpUrlConnection.getHeaderField(0));
     // After header zero there may be additional entries provided at the beginning or end by the
     // implementation. It's probably important that the relative ordering of the headers is
     // preserved, particularly if there are multiple value for the same key.
@@ -578,9 +586,10 @@
             .url("http://insecure/request")
             .method("GET", null)
             .build();
-    String statusLine = "HTTP/1.1 200 Fantastic";
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
-        .statusLine(statusLine)
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Fantastic")
         .addHeader("key1", "value1_1")
         .addHeader("key2", "value2")
         .addHeader("key1", "value1_2")
@@ -590,7 +599,7 @@
     assertFalse(javaCacheResponse instanceof SecureCacheResponse);
     Map<String, List<String>> javaHeaders = javaCacheResponse.getHeaders();
     assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
-    assertEquals(Arrays.asList(statusLine), javaHeaders.get(null));
+    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
     assertNull(javaCacheResponse.getBody());
   }
 
@@ -600,10 +609,11 @@
             .url("http://insecure/request")
             .method("POST", createRequestBody("RequestBody"))
             .build();
-    String statusLine = "HTTP/1.1 200 Fantastic";
     Response.Body responseBody = createResponseBody("ResponseBody");
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
-        .statusLine(statusLine)
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Fantastic")
         .addHeader("key1", "value1_1")
         .addHeader("key2", "value2")
         .addHeader("key1", "value1_2")
@@ -613,7 +623,7 @@
     assertFalse(javaCacheResponse instanceof SecureCacheResponse);
     Map<String, List<String>> javaHeaders = javaCacheResponse.getHeaders();
     assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
-    assertEquals(Arrays.asList(statusLine), javaHeaders.get(null));
+    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
     assertEquals("ResponseBody", readAll(javaCacheResponse.getBody()));
   }
 
@@ -623,12 +633,13 @@
             .url("https://secure/request")
             .method("POST", createRequestBody("RequestBody") )
             .build();
-    String statusLine = "HTTP/1.1 200 Fantastic";
     Response.Body responseBody = createResponseBody("ResponseBody");
     Handshake handshake = Handshake.get("SecureCipher", Arrays.<Certificate>asList(SERVER_CERT),
         Arrays.<Certificate>asList(LOCAL_CERT));
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
-        .statusLine(statusLine)
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Fantastic")
         .addHeader("key1", "value1_1")
         .addHeader("key2", "value2")
         .addHeader("key1", "value1_2")
@@ -639,7 +650,7 @@
         (SecureCacheResponse) JavaApiConverter.createJavaCacheResponse(okResponse);
     Map<String, List<String>> javaHeaders = javaCacheResponse.getHeaders();
     assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
-    assertEquals(Arrays.asList(statusLine), javaHeaders.get(null));
+    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
     assertEquals("ResponseBody", readAll(javaCacheResponse.getBody()));
     assertEquals(handshake.cipherSuite(), javaCacheResponse.getCipherSuite());
     assertEquals(handshake.localCertificates(), javaCacheResponse.getLocalCertificateChain());
@@ -752,7 +763,9 @@
   private static Response createArbitraryOkResponse(Request request) {
     return new Response.Builder()
         .request(request)
-        .statusLine("HTTP/1.1 200 Arbitrary")
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Arbitrary")
         .build();
   }
 
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
index 9cf2512..f339f9e 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
@@ -28,19 +28,19 @@
     String message = "Temporary Redirect";
     int version = 1;
     int code = 200;
-    StatusLine statusLine = new StatusLine("HTTP/1." + version + " " + code + " " + message);
-    assertEquals(message, statusLine.message());
-    assertEquals(Protocol.HTTP_1_1, statusLine.protocol());
-    assertEquals(code, statusLine.code());
+    StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code + " " + message);
+    assertEquals(message, statusLine.message);
+    assertEquals(Protocol.HTTP_1_1, statusLine.protocol);
+    assertEquals(code, statusLine.code);
   }
 
   @Test public void emptyMessage() throws IOException {
     int version = 1;
     int code = 503;
-    StatusLine statusLine = new StatusLine("HTTP/1." + version + " " + code + " ");
-    assertEquals("", statusLine.message());
-    assertEquals(Protocol.HTTP_1_1, statusLine.protocol());
-    assertEquals(code, statusLine.code());
+    StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code + " ");
+    assertEquals("", statusLine.message);
+    assertEquals(Protocol.HTTP_1_1, statusLine.protocol);
+    assertEquals(code, statusLine.code);
   }
 
   /**
@@ -51,18 +51,18 @@
   @Test public void emptyMessageAndNoLeadingSpace() throws IOException {
     int version = 1;
     int code = 503;
-    StatusLine statusLine = new StatusLine("HTTP/1." + version + " " + code);
-    assertEquals("", statusLine.message());
-    assertEquals(Protocol.HTTP_1_1, statusLine.protocol());
-    assertEquals(code, statusLine.code());
+    StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code);
+    assertEquals("", statusLine.message);
+    assertEquals(Protocol.HTTP_1_1, statusLine.protocol);
+    assertEquals(code, statusLine.code);
   }
 
   // https://github.com/square/okhttp/issues/386
   @Test public void shoutcast() throws IOException {
-    StatusLine statusLine = new StatusLine("ICY 200 OK");
-    assertEquals("OK", statusLine.message());
-    assertEquals(Protocol.HTTP_1_0, statusLine.protocol());
-    assertEquals(200, statusLine.code());
+    StatusLine statusLine = StatusLine.parse("ICY 200 OK");
+    assertEquals("OK", statusLine.message);
+    assertEquals(Protocol.HTTP_1_0, statusLine.protocol);
+    assertEquals(200, statusLine.code);
   }
 
   @Test public void missingProtocol() throws IOException {
@@ -110,7 +110,7 @@
 
   private void assertInvalid(String statusLine) throws IOException {
     try {
-      new StatusLine(statusLine);
+      StatusLine.parse(statusLine);
       fail();
     } catch (ProtocolException expected) {
     }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java b/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
index c28abd5..e299d57 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
@@ -23,6 +23,7 @@
 import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
 import com.squareup.okhttp.internal.http.JavaApiConverter;
 import com.squareup.okhttp.internal.http.OkHeaders;
+import com.squareup.okhttp.internal.http.StatusLine;
 import java.io.BufferedWriter;
 import java.io.ByteArrayInputStream;
 import java.io.File;
@@ -387,7 +388,9 @@
     private final String url;
     private final Headers varyHeaders;
     private final String requestMethod;
-    private final String statusLine;
+    private final Protocol protocol;
+    private final int code;
+    private final String message;
     private final Headers responseHeaders;
     private final Handshake handshake;
 
@@ -452,7 +455,10 @@
         }
         varyHeaders = varyHeadersBuilder.build();
 
-        statusLine = source.readUtf8LineStrict();
+        StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+        protocol = statusLine.protocol;
+        code = statusLine.code;
+        message = statusLine.message;
         Headers.Builder responseHeadersBuilder = new Headers.Builder();
         int responseHeaderLineCount = readInt(source);
         for (int i = 0; i < responseHeaderLineCount; i++) {
@@ -481,7 +487,9 @@
       this.url = response.request().urlString();
       this.varyHeaders = OkHeaders.varyHeaders(response);
       this.requestMethod = response.request().method();
-      this.statusLine = response.statusLine();
+      this.protocol = response.protocol();
+      this.code = response.code();
+      this.message = response.message();
       this.responseHeaders = response.headers();
       this.handshake = response.handshake();
     }
@@ -503,7 +511,7 @@
         writer.write('\n');
       }
 
-      writer.write(statusLine);
+      writer.write(new StatusLine(protocol, code, message).toString());
       writer.write('\n');
       writer.write(Integer.toString(responseHeaders.size()));
       writer.write('\n');
@@ -572,7 +580,9 @@
       String contentLength = responseHeaders.get("Content-Length");
       return new Response.Builder()
           .request(request)
-          .statusLine(statusLine)
+          .protocol(protocol)
+          .code(code)
+          .message(message)
           .headers(responseHeaders)
           .body(new CacheResponseBody(snapshot, contentType, contentLength))
           .handshake(handshake)
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index da16e80..dbb2280 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -16,7 +16,6 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.http.OkHeaders;
-import com.squareup.okhttp.internal.http.StatusLine;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
@@ -36,7 +35,9 @@
  */
 public final class Response {
   private final Request request;
-  private final StatusLine statusLine;
+  private final Protocol protocol;
+  private final int code;
+  private final String message;
   private final Handshake handshake;
   private final Headers headers;
   private final Body body;
@@ -46,7 +47,9 @@
 
   private Response(Builder builder) {
     this.request = builder.request;
-    this.statusLine = builder.statusLine;
+    this.protocol = builder.protocol;
+    this.code = builder.code;
+    this.message = builder.message;
     this.handshake = builder.handshake;
     this.headers = builder.headers.build();
     this.body = builder.body;
@@ -69,20 +72,22 @@
     return request;
   }
 
-  public String statusLine() {
-    return statusLine.getStatusLine();
-  }
-
-  public int code() {
-    return statusLine.code();
-  }
-
-  public String statusMessage() {
-    return statusLine.message();
-  }
-
+  /**
+   * Returns the HTTP protocol, such as {@link Protocol#HTTP_1_1} or {@link
+   * Protocol#HTTP_1_0}.
+   */
   public Protocol protocol() {
-    return statusLine.protocol();
+    return protocol;
+  }
+
+  /** Returns the HTTP status code or -1 if it is unknown. */
+  public int code() {
+    return code;
+  }
+
+  /** Returns the HTTP status message or null if it is unknown. */
+  public String message() {
+    return message;
   }
 
   /**
@@ -229,7 +234,9 @@
 
   public static class Builder {
     private Request request;
-    private StatusLine statusLine;
+    private Protocol protocol;
+    private int code = -1;
+    private String message;
     private Handshake handshake;
     private Headers.Builder headers;
     private Body body;
@@ -241,7 +248,9 @@
 
     private Builder(Response response) {
       this.request = response.request;
-      this.statusLine = response.statusLine;
+      this.protocol = response.protocol;
+      this.code = response.code;
+      this.message = response.message;
       this.handshake = response.handshake;
       this.headers = response.headers.newBuilder();
       this.body = response.body;
@@ -253,18 +262,19 @@
       return this;
     }
 
-    public Builder statusLine(StatusLine statusLine) {
-      if (statusLine == null) throw new IllegalArgumentException("statusLine == null");
-      this.statusLine = statusLine;
+    public Builder protocol(Protocol protocol) {
+      this.protocol = protocol;
       return this;
     }
 
-    public Builder statusLine(String statusLine) {
-      try {
-        return statusLine(new StatusLine(statusLine));
-      } catch (IOException e) {
-        throw new IllegalArgumentException(e);
-      }
+    public Builder code(int code) {
+      this.code = code;
+      return this;
+    }
+
+    public Builder message(String message) {
+      this.message = message;
+      return this;
     }
 
     public Builder handshake(Handshake handshake) {
@@ -308,7 +318,7 @@
 
     // TODO: move out of public API
     public Builder setResponseSource(ResponseSource responseSource) {
-      return header(OkHeaders.RESPONSE_SOURCE, responseSource + " " + statusLine.code());
+      return header(OkHeaders.RESPONSE_SOURCE, responseSource + " " + code);
     }
 
     public Builder redirectedBy(Response redirectedBy) {
@@ -318,7 +328,8 @@
 
     public Response build() {
       if (request == null) throw new IllegalStateException("request == null");
-      if (statusLine == null) throw new IllegalStateException("statusLine == null");
+      if (protocol == null) throw new IllegalStateException("protocol == null");
+      if (code < 0) throw new IllegalStateException("code < 0: " + code);
       return new Response(this);
     }
   }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
index c807dfb..9eb762f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
@@ -2,11 +2,11 @@
 
 import com.squareup.okhttp.CacheControl;
 import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseSource;
 import com.squareup.okhttp.internal.Util;
-import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.util.Date;
 import okio.BufferedSource;
@@ -35,15 +35,6 @@
     }
   };
 
-  private static final StatusLine GATEWAY_TIMEOUT_STATUS_LINE;
-  static {
-    try {
-      GATEWAY_TIMEOUT_STATUS_LINE = new StatusLine("HTTP/1.1 504 Gateway Timeout");
-    } catch (IOException e) {
-      throw new AssertionError();
-    }
-  }
-
   public final Request request;
   public final Response response;
   public final ResponseSource source;
@@ -166,7 +157,9 @@
         // We're forbidden from using the network, but the cache is insufficient.
         Response noneResponse = new Response.Builder()
             .request(candidate.request)
-            .statusLine(GATEWAY_TIMEOUT_STATUS_LINE)
+            .protocol(Protocol.HTTP_1_1)
+            .code(504)
+            .message("Gateway Timeout")
             .setResponseSource(ResponseSource.NONE)
             .body(EMPTY_BODY)
             .build();
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
index 7206ec2..eca3843 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
@@ -183,18 +183,19 @@
     }
 
     while (true) {
-      String statusLineString = source.readUtf8LineStrict();
-      StatusLine statusLine = new StatusLine(statusLineString);
+      StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
 
       Response.Builder responseBuilder = new Response.Builder()
-          .statusLine(statusLine);
+          .protocol(statusLine.protocol)
+          .code(statusLine.code)
+          .message(statusLine.message);
 
       Headers.Builder headersBuilder = new Headers.Builder();
       readHeaders(headersBuilder);
-      headersBuilder.add(OkHeaders.SELECTED_PROTOCOL, statusLine.protocol().toString());
+      headersBuilder.add(OkHeaders.SELECTED_PROTOCOL, statusLine.protocol.toString());
       responseBuilder.headers(headersBuilder.build());
 
-      if (statusLine.code() != HTTP_CONTINUE) {
+      if (statusLine.code != HTTP_CONTINUE) {
         state = STATE_OPEN_RESPONSE_BODY;
         return responseBuilder;
       }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
index c7a0d9a..8c769a8 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
@@ -158,7 +158,9 @@
   @Override public final String getHeaderField(String fieldName) {
     try {
       Response response = getResponse().getResponse();
-      return fieldName == null ? response.statusLine() : response.headers().get(fieldName);
+      return fieldName == null
+          ? StatusLine.get(response).toString()
+          : response.headers().get(fieldName);
     } catch (IOException e) {
       return null;
     }
@@ -175,7 +177,7 @@
   @Override public final Map<String, List<String>> getHeaderFields() {
     try {
       Response response = getResponse().getResponse();
-      return OkHeaders.toMultimap(response.headers(), response.statusLine());
+      return OkHeaders.toMultimap(response.headers(), StatusLine.get(response).toString());
     } catch (IOException e) {
       return Collections.emptyMap();
     }
@@ -488,7 +490,7 @@
   }
 
   @Override public String getResponseMessage() throws IOException {
-    return getResponse().getResponse().statusMessage();
+    return getResponse().getResponse().message();
   }
 
   @Override public final int getResponseCode() throws IOException {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/JavaApiConverter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/JavaApiConverter.java
index 08348c9..ba5d5b2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/JavaApiConverter.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/JavaApiConverter.java
@@ -67,8 +67,10 @@
     okResponseBuilder.request(okRequest);
 
     // Status line
-    String statusLine = extractStatusLine(httpUrlConnection);
-    okResponseBuilder.statusLine(statusLine);
+    StatusLine statusLine = StatusLine.parse(extractStatusLine(httpUrlConnection));
+    okResponseBuilder.protocol(statusLine.protocol);
+    okResponseBuilder.code(statusLine.code);
+    okResponseBuilder.message(statusLine.message);
 
     // Response headers
     Headers okHeaders = extractOkResponseHeaders(httpUrlConnection);
@@ -115,7 +117,10 @@
     okResponseBuilder.request(request);
 
     // Status line: Java has this as one of the headers.
-    okResponseBuilder.statusLine(extractStatusLine(javaResponse));
+    StatusLine statusLine = StatusLine.parse(extractStatusLine(javaResponse));
+    okResponseBuilder.protocol(statusLine.protocol);
+    okResponseBuilder.code(statusLine.code);
+    okResponseBuilder.message(statusLine.message);
 
     // Response headers
     Headers okHeaders = extractOkHeaders(javaResponse);
@@ -218,7 +223,7 @@
         @Override
         public Map<String, List<String>> getHeaders() throws IOException {
           // Java requires that the entry with a null key be the status line.
-          return OkHeaders.toMultimap(headers, response.statusLine());
+          return OkHeaders.toMultimap(headers, StatusLine.get(response).toString());
         }
 
         @Override
@@ -232,7 +237,7 @@
         @Override
         public Map<String, List<String>> getHeaders() throws IOException {
           // Java requires that the entry with a null key be the status line.
-          return OkHeaders.toMultimap(headers, response.statusLine());
+          return OkHeaders.toMultimap(headers, StatusLine.get(response).toString());
         }
 
         @Override
@@ -474,19 +479,21 @@
         throw new IllegalArgumentException("Invalid header index: " + position);
       }
       if (position == 0) {
-        return response.statusLine();
+        return StatusLine.get(response).toString();
       }
       return response.headers().value(position - 1);
     }
 
     @Override
     public String getHeaderField(String fieldName) {
-      return fieldName == null ? response.statusLine() : response.headers().get(fieldName);
+      return fieldName == null
+          ? StatusLine.get(response).toString()
+          : response.headers().get(fieldName);
     }
 
     @Override
     public Map<String, List<String>> getHeaderFields() {
-      return OkHeaders.toMultimap(response.headers(), response.statusLine());
+      return OkHeaders.toMultimap(response.headers(), StatusLine.get(response).toString());
     }
 
     @Override
@@ -496,7 +503,7 @@
 
     @Override
     public String getResponseMessage() throws IOException {
-      return response.statusMessage();
+      return response.message();
     }
 
     @Override
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index a23787f..426b6a4 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -202,8 +202,11 @@
     if (status == null) throw new ProtocolException("Expected ':status' header not present");
     if (version == null) throw new ProtocolException("Expected ':version' header not present");
 
+    StatusLine statusLine = StatusLine.parse(version + " " + status);
     return new Response.Builder()
-        .statusLine(new StatusLine(version + " " + status))
+        .protocol(statusLine.protocol)
+        .code(statusLine.code)
+        .message(statusLine.message)
         .headers(headersBuilder.build());
   }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
index fc7f5af..31d7187 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
@@ -1,21 +1,31 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.net.ProtocolException;
 
+/** An HTTP response status line like "HTTP/1.1 200 OK". */
 public final class StatusLine {
   /** Numeric status code, 307: Temporary Redirect. */
   public static final int HTTP_TEMP_REDIRECT = 307;
   public static final int HTTP_CONTINUE = 100;
 
-  private final String statusLine;
-  private final Protocol protocol;
-  private final int responseCode;
-  private final String responseMessage;
+  public final Protocol protocol;
+  public final int code;
+  public final String message;
 
-  /** Sets the response status line (like "HTTP/1.0 200 OK"). */
-  public StatusLine(String statusLine) throws IOException {
+  public StatusLine(Protocol protocol, int code, String message) {
+    this.protocol = protocol;
+    this.code = code;
+    this.message = message;
+  }
+
+  public static StatusLine get(Response response) {
+    return new StatusLine(response.protocol(), response.code(), response.message());
+  }
+
+  public static StatusLine parse(String statusLine) throws IOException {
     // H T T P / 1 . 1   2 0 0   T e m p o r a r y   R e d i r e c t
     // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
 
@@ -47,45 +57,33 @@
     if (statusLine.length() < codeStart + 3) {
       throw new ProtocolException("Unexpected status line: " + statusLine);
     }
-    int responseCode;
+    int code;
     try {
-      responseCode = Integer.parseInt(statusLine.substring(codeStart, codeStart + 3));
+      code = Integer.parseInt(statusLine.substring(codeStart, codeStart + 3));
     } catch (NumberFormatException e) {
       throw new ProtocolException("Unexpected status line: " + statusLine);
     }
 
     // Parse an optional response message like "OK" or "Not Modified". If it
     // exists, it is separated from the response code by a space.
-    String responseMessage = "";
+    String message = "";
     if (statusLine.length() > codeStart + 3) {
       if (statusLine.charAt(codeStart + 3) != ' ') {
         throw new ProtocolException("Unexpected status line: " + statusLine);
       }
-      responseMessage = statusLine.substring(codeStart + 4);
+      message = statusLine.substring(codeStart + 4);
     }
 
-    this.responseMessage = responseMessage;
-    this.responseCode = responseCode;
-    this.statusLine = statusLine;
-    this.protocol = protocol;
+    return new StatusLine(protocol, code, message);
   }
 
-  public String getStatusLine() {
-    return statusLine;
-  }
-
-  /** Returns either {@link Protocol#HTTP_1_1} or {@link Protocol#HTTP_1_0}. */
-  public Protocol protocol() {
-    return protocol;
-  }
-
-  /** Returns the HTTP status code or -1 if it is unknown. */
-  public int code() {
-    return responseCode;
-  }
-
-  /** Returns the HTTP status message or null if it is unknown. */
-  public String message() {
-    return responseMessage;
+  @Override public String toString() {
+    StringBuilder result = new StringBuilder();
+    result.append(protocol == Protocol.HTTP_1_0 ? "HTTP/1.0" : "HTTP/1.1");
+    result.append(" ").append(code);
+    if (message != null) {
+      result.append(" ").append(message);
+    }
+    return result.toString();
   }
 }
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft10FrameLoggerTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft10FrameLoggerTest.java
new file mode 100644
index 0000000..f342e5c
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft10FrameLoggerTest.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.spdy.Http20Draft10.FLAG_ACK;
+import static com.squareup.okhttp.internal.spdy.Http20Draft10.FLAG_END_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Http20Draft10.FLAG_END_STREAM;
+import static com.squareup.okhttp.internal.spdy.Http20Draft10.FLAG_NONE;
+import static com.squareup.okhttp.internal.spdy.Http20Draft10.FrameLogger.formatFlags;
+import static com.squareup.okhttp.internal.spdy.Http20Draft10.FrameLogger.formatHeader;
+import static com.squareup.okhttp.internal.spdy.Http20Draft10.TYPE_DATA;
+import static com.squareup.okhttp.internal.spdy.Http20Draft10.TYPE_GOAWAY;
+import static com.squareup.okhttp.internal.spdy.Http20Draft10.TYPE_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Http20Draft10.TYPE_SETTINGS;
+import static org.junit.Assert.assertEquals;
+
+public class Http20Draft10FrameLoggerTest {
+
+  /** Real stream traffic applied to the log format. */
+  @Test public void exampleStream() {
+    assertEquals(">> 0x00000000     5 SETTINGS      ",
+        formatHeader(false, 0, 5, TYPE_SETTINGS, FLAG_NONE));
+    assertEquals(">> 0x00000003   100 HEADERS       END_HEADERS",
+        formatHeader(false, 3, 100, TYPE_HEADERS, FLAG_END_HEADERS));
+    assertEquals(">> 0x00000003     0 DATA          END_STREAM",
+        formatHeader(false, 3, 0, TYPE_DATA, FLAG_END_STREAM));
+    assertEquals("<< 0x00000000    15 SETTINGS      ",
+        formatHeader(true, 0, 15, TYPE_SETTINGS, FLAG_NONE));
+    assertEquals(">> 0x00000000     0 SETTINGS      ACK",
+        formatHeader(false, 0, 0, TYPE_SETTINGS, FLAG_ACK));
+    assertEquals("<< 0x00000000     0 SETTINGS      ACK",
+        formatHeader(true, 0, 0, TYPE_SETTINGS, FLAG_ACK));
+    assertEquals("<< 0x00000003    22 HEADERS       END_HEADERS",
+        formatHeader(true, 3, 22, TYPE_HEADERS, FLAG_END_HEADERS));
+    assertEquals("<< 0x00000003   226 DATA          END_STREAM",
+        formatHeader(true, 3, 226, TYPE_DATA, FLAG_END_STREAM));
+    assertEquals(">> 0x00000000     8 GOAWAY        ",
+        formatHeader(false, 0, 8, TYPE_GOAWAY, FLAG_NONE));
+  }
+
+  /**
+   * Ensures that valid flag combinations appear visually correct, and invalid show in hex.  This
+   * also demonstrates how sparse the lookup table is.
+   */
+  @Test public void allFormattedFlagsWithValidBits() {
+    List<String> formattedFlags = new ArrayList<String>(0x40); // Highest valid flag is 0x20.
+    for (byte i = 0; i < 0x40; i++) formattedFlags.add(formatFlags(TYPE_HEADERS, i));
+
+    assertEquals(Arrays.asList(
+        "",
+        "END_STREAM",
+        "END_SEGMENT",
+        "END_STREAM|END_SEGMENT",
+        "END_HEADERS",
+        "END_STREAM|END_HEADERS",
+        "END_SEGMENT|END_HEADERS",
+        "END_STREAM|END_SEGMENT|END_HEADERS",
+        "PRIORITY",
+        "END_STREAM|PRIORITY",
+        "END_SEGMENT|PRIORITY",
+        "END_STREAM|END_SEGMENT|PRIORITY",
+        "END_HEADERS|PRIORITY",
+        "END_STREAM|END_HEADERS|PRIORITY",
+        "END_SEGMENT|END_HEADERS|PRIORITY",
+        "END_STREAM|END_SEGMENT|END_HEADERS|PRIORITY",
+        "PAD_LOW",
+        "END_STREAM|PAD_LOW",
+        "END_SEGMENT|PAD_LOW",
+        "END_STREAM|END_SEGMENT|PAD_LOW",
+        "00010100",
+        "END_STREAM|END_HEADERS|PAD_LOW",
+        "END_SEGMENT|END_HEADERS|PAD_LOW",
+        "END_STREAM|END_SEGMENT|END_HEADERS|PAD_LOW",
+        "00011000",
+        "END_STREAM|PRIORITY|PAD_LOW",
+        "END_SEGMENT|PRIORITY|PAD_LOW",
+        "END_STREAM|END_SEGMENT|PRIORITY|PAD_LOW",
+        "00011100",
+        "END_STREAM|END_HEADERS|PRIORITY|PAD_LOW",
+        "END_SEGMENT|END_HEADERS|PRIORITY|PAD_LOW",
+        "END_STREAM|END_SEGMENT|END_HEADERS|PRIORITY|PAD_LOW",
+        "00100000",
+        "00100001",
+        "00100010",
+        "00100011",
+        "00100100",
+        "00100101",
+        "00100110",
+        "00100111",
+        "00101000",
+        "00101001",
+        "00101010",
+        "00101011",
+        "00101100",
+        "00101101",
+        "00101110",
+        "00101111",
+        "PAD_LOW|PAD_HIGH",
+        "END_STREAM|PAD_LOW|PAD_HIGH",
+        "END_SEGMENT|PAD_LOW|PAD_HIGH",
+        "END_STREAM|END_SEGMENT|PAD_LOW|PAD_HIGH",
+        "00110100",
+        "END_STREAM|END_HEADERS|PAD_LOW|PAD_HIGH",
+        "END_SEGMENT|END_HEADERS|PAD_LOW|PAD_HIGH",
+        "END_STREAM|END_SEGMENT|END_HEADERS|PAD_LOW|PAD_HIGH",
+        "00111000",
+        "END_STREAM|PRIORITY|PAD_LOW|PAD_HIGH",
+        "END_SEGMENT|PRIORITY|PAD_LOW|PAD_HIGH",
+        "END_STREAM|END_SEGMENT|PRIORITY|PAD_LOW|PAD_HIGH",
+        "00111100",
+        "END_STREAM|END_HEADERS|PRIORITY|PAD_LOW|PAD_HIGH",
+        "END_SEGMENT|END_HEADERS|PRIORITY|PAD_LOW|PAD_HIGH",
+        "END_STREAM|END_SEGMENT|END_HEADERS|PRIORITY|PAD_LOW|PAD_HIGH"
+    ), formattedFlags);
+  }
+}
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft10Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft10Test.java
index 1f489a8..3196892 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft10Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft10Test.java
@@ -808,7 +808,7 @@
       assertEquals("PROTOCOL_ERROR padding > 16383: 65535", e.getMessage());
     }
   }  
-  
+
   @Test public void tooLargeDataFrame() throws IOException {
     try {
       sendDataFrame(new Buffer().write(new byte[0x1000000]));
@@ -922,7 +922,7 @@
     Http20Draft10.Writer writer = new Http20Draft10.Writer(new Buffer(), true);
 
     try {
-      writer.frameHeader(16384, Http20Draft10.TYPE_DATA, FLAG_NONE, 0);
+      writer.frameHeader(0, 16384, Http20Draft10.TYPE_DATA, FLAG_NONE);
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("FRAME_SIZE_ERROR length > 16383: 16384", e.getMessage());
@@ -935,7 +935,7 @@
     try {
       int streamId = 3;
       streamId |= 1L << 31; // set reserved bit
-      writer.frameHeader(16383, Http20Draft10.TYPE_DATA, FLAG_NONE, streamId);
+      writer.frameHeader(streamId, 16383, Http20Draft10.TYPE_DATA, FLAG_NONE);
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("reserved bit set: -2147483645", e.getMessage());
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft10.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft10.java
index dd44989..4f6c5ea 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft10.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft10.java
@@ -18,6 +18,7 @@
 import com.squareup.okhttp.Protocol;
 import java.io.IOException;
 import java.util.List;
+import java.util.logging.Logger;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -25,11 +26,16 @@
 import okio.Source;
 import okio.Timeout;
 
+import static com.squareup.okhttp.internal.spdy.Http20Draft10.FrameLogger.formatHeader;
+import static java.lang.String.format;
+import static java.util.logging.Level.FINE;
+
 /**
  * Read and write HTTP/2 v10 frames.
- * http://tools.ietf.org/html/draft-ietf-httpbis-http2-10
+ * <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-10
  */
 public final class Http20Draft10 implements Variant {
+  private static final Logger logger = Logger.getLogger(Http20Draft10.class.getName());
 
   @Override public Protocol getProtocol() {
     return Protocol.HTTP_2;
@@ -50,14 +56,14 @@
   static final byte TYPE_CONTINUATION = 0x9;
 
   static final byte FLAG_NONE = 0x0;
-  static final byte FLAG_ACK = 0x1;
-  static final byte FLAG_END_STREAM = 0x1;
+  static final byte FLAG_ACK = 0x1; // Used for settings and ping.
+  static final byte FLAG_END_STREAM = 0x1; // Used for headers and data.
   static final byte FLAG_END_SEGMENT = 0x2;
   static final byte FLAG_END_HEADERS = 0x4; // Used for headers and continuation.
   static final byte FLAG_END_PUSH_PROMISE = 0x4;
-  static final byte FLAG_PRIORITY = 0x8;
-  static final byte FLAG_PAD_LOW = 0x10;
-  static final byte FLAG_PAD_HIGH = 0x20;
+  static final byte FLAG_PRIORITY = 0x8; // Used for headers
+  static final byte FLAG_PAD_LOW = 0x10; // Used for headers, data, and continuation
+  static final byte FLAG_PAD_HIGH = 0x20; // Used for headers, data, and continuation
 
   @Override public FrameReader newReader(BufferedSource source, boolean client) {
     return new Reader(source, 4096, client);
@@ -89,6 +95,7 @@
     @Override public void readConnectionHeader() throws IOException {
       if (client) return; // Nothing to read; servers don't send connection headers!
       ByteString connectionHeader = source.readByteString(CONNECTION_HEADER.size());
+      if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionHeader.hex()));
       if (!CONNECTION_HEADER.equals(connectionHeader)) {
         throw ioException("Expected a connection header but was %s", connectionHeader.utf8());
       }
@@ -110,6 +117,7 @@
       byte flags = (byte) (w1 & 0xff);
       // boolean r = (w2 & 0x80000000) != 0; // Reserved: Ignore first bit.
       int streamId = (w2 & 0x7fffffff); // 31-bit opaque identifier.
+      if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
 
       switch (type) {
         case TYPE_DATA:
@@ -346,13 +354,14 @@
       byte type = TYPE_SETTINGS;
       byte flags = FLAG_ACK;
       int streamId = 0;
-      frameHeader(length, type, flags, streamId);
+      frameHeader(streamId, length, type, flags);
       sink.flush();
     }
 
     @Override public synchronized void connectionHeader() throws IOException {
       if (closed) throw new IOException("closed");
       if (!client) return; // Nothing to write; servers don't send connection headers!
+      if (logger.isLoggable(FINE)) logger.fine(format(">> CONNECTION %s", CONNECTION_HEADER.hex()));
       sink.write(CONNECTION_HEADER.toByteArray());
       sink.flush();
     }
@@ -386,7 +395,7 @@
       int length = (int) (4 + hpackBuffer.size());
       byte type = TYPE_PUSH_PROMISE;
       byte flags = FLAG_END_HEADERS;
-      frameHeader(length, type, flags, streamId); // TODO: CONTINUATION
+      frameHeader(streamId, length, type, flags); // TODO: CONTINUATION
       sink.writeInt(promisedStreamId & 0x7fffffff);
       sink.write(hpackBuffer, hpackBuffer.size());
     }
@@ -403,7 +412,7 @@
       if (outFinished) flags |= FLAG_END_STREAM;
       if (priority != -1) flags |= FLAG_PRIORITY;
       if (priority != -1) length += 4;
-      frameHeader(length, type, flags, streamId); // TODO: CONTINUATION
+      frameHeader(streamId, length, type, flags); // TODO: CONTINUATION
       if (priority != -1) sink.writeInt(priority & 0x7fffffff);
       sink.write(hpackBuffer, hpackBuffer.size());
     }
@@ -416,7 +425,7 @@
       int length = 4;
       byte type = TYPE_RST_STREAM;
       byte flags = FLAG_NONE;
-      frameHeader(length, type, flags, streamId);
+      frameHeader(streamId, length, type, flags);
       sink.writeInt(errorCode.httpCode);
       sink.flush();
     }
@@ -436,7 +445,7 @@
 
     void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IOException {
       byte type = TYPE_DATA;
-      frameHeader(byteCount, type, flags, streamId);
+      frameHeader(streamId, byteCount, type, flags);
       if (byteCount > 0) {
         sink.write(buffer, byteCount);
       }
@@ -448,7 +457,7 @@
       byte type = TYPE_SETTINGS;
       byte flags = FLAG_NONE;
       int streamId = 0;
-      frameHeader(length, type, flags, streamId);
+      frameHeader(streamId, length, type, flags);
       for (int i = 0; i < Settings.COUNT; i++) {
         if (!settings.isSet(i)) continue;
         int id = i;
@@ -467,7 +476,7 @@
       byte type = TYPE_PING;
       byte flags = ack ? FLAG_ACK : FLAG_NONE;
       int streamId = 0;
-      frameHeader(length, type, flags, streamId);
+      frameHeader(streamId, length, type, flags);
       sink.writeInt(payload1);
       sink.writeInt(payload2);
       sink.flush();
@@ -481,7 +490,7 @@
       byte type = TYPE_GOAWAY;
       byte flags = FLAG_NONE;
       int streamId = 0;
-      frameHeader(length, type, flags, streamId);
+      frameHeader(streamId, length, type, flags);
       sink.writeInt(lastGoodStreamId);
       sink.writeInt(errorCode.httpCode);
       if (debugData.length > 0) {
@@ -500,7 +509,7 @@
       int length = 4;
       byte type = TYPE_WINDOW_UPDATE;
       byte flags = FLAG_NONE;
-      frameHeader(length, type, flags, streamId);
+      frameHeader(streamId, length, type, flags);
       sink.writeInt((int) windowSizeIncrement);
       sink.flush();
     }
@@ -510,7 +519,8 @@
       sink.close();
     }
 
-    void frameHeader(int length, byte type, byte flags, int streamId) throws IOException {
+    void frameHeader(int streamId, int length, byte type, byte flags) throws IOException {
+      if (logger.isLoggable(FINE)) logger.fine(formatHeader(false, streamId, length, type, flags));
       if (length > 16383) throw illegalArgument("FRAME_SIZE_ERROR length > 16383: %s", length);
       if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
       sink.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
@@ -519,11 +529,11 @@
   }
 
   private static IllegalArgumentException illegalArgument(String message, Object... args) {
-    throw new IllegalArgumentException(String.format(message, args));
+    throw new IllegalArgumentException(format(message, args));
   }
 
   private static IOException ioException(String message, Object... args) throws IOException {
-    throw new IOException(String.format(message, args));
+    throw new IOException(format(message, args));
   }
 
   /**
@@ -574,6 +584,7 @@
       length = (short) ((w1 & 0x3fff0000) >> 16);
       byte type = (byte) ((w1 & 0xff00) >> 8);
       flags = (byte) (w1 & 0xff);
+      if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
       padding = readPadding(source, flags);
       length = left = lengthWithoutPadding(length, flags, padding);
       streamId = (w2 & 0x7fffffff);
@@ -608,4 +619,118 @@
     }
     return (short) (length - padding);
   }
+
+  /**
+   * Logs a human-readable representation of HTTP/2 frame headers.
+   *
+   * <p>The format is:
+   *
+   * <pre>
+   *   direction streamID length type flags
+   * </pre>
+   * Where direction is {@code <<} for inbound and {@code >>} for outbound.
+   *
+   * <p> For example, the following would indicate a HEAD request sent from
+   * the client.
+   * <pre>
+   * {@code
+   *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
+   * }
+   * </pre>
+   */
+  static final class FrameLogger {
+
+    static String formatHeader(boolean inbound, int streamId, int length, byte type, byte flags) {
+      String formattedType = type < TYPES.length ? TYPES[type] : format("0x%02x", type);
+      String formattedFlags = formatFlags(type, flags);
+      return format("%s 0x%08x %5d %-13s %s", inbound ? "<<" : ">>", streamId, length,
+          formattedType, formattedFlags);
+    }
+
+    /**
+     * Looks up valid string representing flags from the table. Invalid
+     * combinations are represented in binary.
+     */
+    // Visible for testing.
+    static String formatFlags(byte type, byte flags) {
+      if (flags == 0) return "";
+      switch (type) { // Special case types that have 0 or 1 flag.
+        case TYPE_PUSH_PROMISE:
+          return flags == FLAG_END_PUSH_PROMISE ? "END_PUSH_PROMISE" : BINARY[flags];
+        case TYPE_SETTINGS:
+        case TYPE_PING:
+          return flags == FLAG_ACK ? "ACK" : BINARY[flags];
+        case TYPE_PRIORITY:
+        case TYPE_RST_STREAM:
+        case TYPE_GOAWAY:
+        case TYPE_WINDOW_UPDATE:
+          return BINARY[flags];
+      }
+      return flags < FLAGS.length ? FLAGS[flags] : BINARY[flags];
+    }
+
+    /** Lookup table for valid frame types. */
+    private static final String[] TYPES = new String[] {
+        "DATA",
+        "HEADERS",
+        "PRIORITY",
+        "RST_STREAM",
+        "SETTINGS",
+        "PUSH_PROMISE",
+        "PING",
+        "GOAWAY",
+        "WINDOW_UPDATE",
+        "CONTINUATION"
+    };
+
+    /**
+     * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid
+     * combinations are represented in binary.
+     */
+    private static final String[] FLAGS = new String[0x40]; // Highest bit flag is 0x20.
+    private static final String[] BINARY = new String[256];
+
+    static {
+      for (int i = 0; i < BINARY.length; i++) {
+        BINARY[i] = format("%8s", Integer.toBinaryString(i)).replace(' ', '0');
+      }
+
+      FLAGS[FLAG_NONE] = "";
+      FLAGS[FLAG_END_STREAM] = "END_STREAM";
+      FLAGS[FLAG_END_SEGMENT] = "END_SEGMENT";
+      FLAGS[FLAG_END_STREAM | FLAG_END_SEGMENT] = "END_STREAM|END_SEGMENT";
+      int[] prefixFlags =
+          new int[] {FLAG_END_STREAM, FLAG_END_SEGMENT, FLAG_END_SEGMENT | FLAG_END_STREAM};
+
+      FLAGS[FLAG_PAD_LOW] = "PAD_LOW";
+      FLAGS[FLAG_PAD_LOW | FLAG_PAD_HIGH] = "PAD_LOW|PAD_HIGH";
+      int[] suffixFlags = new int[] {FLAG_PAD_LOW, FLAG_PAD_LOW | FLAG_PAD_HIGH};
+
+      for (int prefixFlag : prefixFlags) {
+        for (int suffixFlag : suffixFlags) {
+          FLAGS[prefixFlag | suffixFlag] = FLAGS[prefixFlag] + '|' + FLAGS[suffixFlag];
+        }
+      }
+
+      FLAGS[FLAG_END_HEADERS] = "END_HEADERS";
+      FLAGS[FLAG_PRIORITY] = "PRIORITY";
+      FLAGS[FLAG_END_HEADERS | FLAG_PRIORITY] = "END_HEADERS|PRIORITY";
+      int[] frameFlags =
+          new int[] {FLAG_END_HEADERS, FLAG_PRIORITY, FLAG_END_HEADERS | FLAG_PRIORITY};
+
+      for (int frameFlag : frameFlags) {
+        for (int prefixFlag : prefixFlags) {
+          FLAGS[prefixFlag | frameFlag] = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag];
+          for (int suffixFlag : suffixFlags) {
+            FLAGS[prefixFlag | frameFlag | suffixFlag] =
+                FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + '|' + FLAGS[suffixFlag];
+          }
+        }
+      }
+
+      for (int i = 0; i < FLAGS.length; i++) { // Fill in holes with binary representation.
+        if (FLAGS[i] == null) FLAGS[i] = BINARY[i];
+      }
+    }
+  }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index 19483e3..40bb659 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -27,6 +27,7 @@
 import java.io.IOException;
 import java.net.Proxy;
 import java.net.Socket;
+import java.net.URL;
 import javax.net.ssl.SSLSocket;
 
 import static java.net.HttpURLConnection.HTTP_OK;
@@ -133,8 +134,8 @@
     socket.close();
   }
 
-  public void connect(int connectTimeout, int readTimeout, int writeTimeout,
-      TunnelRequest tunnelRequest) throws IOException {
+  public void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)
+      throws IOException {
     if (connected) throw new IllegalStateException("already connected");
 
     if (route.proxy.type() != Proxy.Type.HTTP) {
@@ -158,12 +159,12 @@
    * Create an {@code SSLSocket} and perform the TLS handshake and certificate
    * validation.
    */
-  private void upgradeToTls(TunnelRequest tunnelRequest, int readTimeout, int writeTimeout)
+  private void upgradeToTls(Request tunnelRequest, int readTimeout, int writeTimeout)
       throws IOException {
     Platform platform = Platform.get();
 
     // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
-    if (requiresTunnel()) {
+    if (tunnelRequest != null) {
       makeTunnel(tunnelRequest, readTimeout, writeTimeout);
     }
 
@@ -303,15 +304,6 @@
     this.protocol = protocol;
   }
 
-  /**
-   * Returns true if the HTTP connection needs to tunnel one protocol over
-   * another, such as when using HTTPS through an HTTP proxy. When doing so,
-   * we must avoid buffering bytes intended for the higher-level protocol.
-   */
-  public boolean requiresTunnel() {
-    return route.address.sslSocketFactory != null && route.proxy.type() == Proxy.Type.HTTP;
-  }
-
   public void updateReadTimeout(int newTimeout) throws IOException {
     if (!connected) throw new IllegalStateException("updateReadTimeout - not connected");
     socket.setSoTimeout(newTimeout);
@@ -334,12 +326,12 @@
    * CONNECT request to create the proxy connection. This may need to be
    * retried if the proxy requires authorization.
    */
-  private void makeTunnel(TunnelRequest tunnelRequest, int readTimeout, int writeTimeout)
+  private void makeTunnel(Request request, int readTimeout, int writeTimeout)
       throws IOException {
     HttpConnection tunnelConnection = new HttpConnection(
         pool, this, socket, readTimeout, writeTimeout);
-    Request request = tunnelRequest.getRequest();
-    String requestLine = tunnelRequest.requestLine();
+    URL url = request.url();
+    String requestLine = "CONNECT " + url.getHost() + ":" + url.getPort() + " HTTP/1.1";
     while (true) {
       tunnelConnection.writeRequest(request.headers(), requestLine);
       tunnelConnection.flush();
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Route.java b/okhttp/src/main/java/com/squareup/okhttp/Route.java
index d5e8744..2693e28 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Route.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Route.java
@@ -78,6 +78,14 @@
     return !tlsVersion.equals(RouteSelector.SSL_V3);
   }
 
+  /**
+   * Returns true if this route tunnels HTTPS through an HTTP proxy. See <a
+   * href="http://www.ietf.org/rfc/rfc2817.txt">RFC 2817, Section 5.2</a>.
+   */
+  public boolean requiresTunnel() {
+    return address.sslSocketFactory != null && proxy.type() == Proxy.Type.HTTP;
+  }
+
   @Override public boolean equals(Object obj) {
     if (obj instanceof Route) {
       Route other = (Route) obj;
/Fim/
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index fdeadcd..5257b37 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -27,7 +27,6 @@
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseSource;
 import com.squareup.okhttp.Route;
-import com.squareup.okhttp.TunnelRequest;
 import com.squareup.okhttp.internal.Dns;
 import java.io.IOException;
 import java.io.InputStream;
@@ -252,7 +251,7 @@
 
     if (!connection.isConnected()) {
       connection.connect(client.getConnectTimeout(), client.getReadTimeout(),
-          client.getWriteTimeout(), getTunnelConfig());
+          client.getWriteTimeout(), tunnelRequest(connection, request));
       if (connection.isSpdy()) client.getConnectionPool().share(connection);
       client.getRoutesDatabase().connected(connection.getRoute());
     } else if (!connection.isSpdy()) {
@@ -703,15 +702,35 @@
     return cached.newBuilder().headers(result.build()).build();
   }
 
-  private TunnelRequest getTunnelConfig() {
-    if (!request.isHttps()) return null;
+  /**
+   * Returns a request that creates a TLS tunnel via an HTTP proxy, or null if
+   * no tunnel is necessary. Everything in the tunnel request is sent
+   * unencrypted to the proxy server, so tunnels include only the minimum set of
+   * headers. This avoids sending potentially sensitive data like HTTP cookies
+   * to the proxy unencrypted.
+   */
+  private Request tunnelRequest(Connection connection, Request request) throws IOException {
+    if (!connection.getRoute().requiresTunnel()) return null;
 
     String userAgent = request.header("User-Agent");
     if (userAgent == null) userAgent = getDefaultUserAgent();
 
-    URL url = request.url();
-    return new TunnelRequest(url.getHost(), getEffectivePort(url), userAgent,
-        request.header("Proxy-Authorization"));
+    String host = request.url().getHost();
+    int port = getEffectivePort(request.url());
+    String authority = (port == getDefaultPort("https")) ? host : (host + ":" + port);
+    Request.Builder result = new Request.Builder()
+        .url(new URL("https", host, port, "/"))
+        .header("Host", authority)
+        .header("User-Agent", userAgent)
+        .header("Proxy-Connection", "Keep-Alive"); // For HTTP/1.0 proxies like Squid.
+
+    // Copy over the Proxy-Authorization header if it exists.
+    String proxyAuthorization = request.header("Proxy-Authorization");
+    if (proxyAuthorization != null) {
+      result.header("Proxy-Authorization", proxyAuthorization);
+    }
+
+    return result.build();
   }
 
   public void receiveHeaders(Headers headers) throws IOException {
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/SyncApiTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/SyncApiTest.java
index 1219659..31ea894 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/SyncApiTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/SyncApiTest.java
@@ -25,7 +25,9 @@
 import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.util.UUID;
+import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLContext;
+import okio.BufferedSource;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -92,6 +94,35 @@
     assertEquals(2, server.takeRequest().getSequenceNumber());
   }
 
+  @Test public void timeoutsUpdatedOnReusedConnections() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
+    server.play();
+
+    // First request: time out after 1000ms.
+    client.setReadTimeout(1000, TimeUnit.MILLISECONDS);
+    onSuccess(new Request.Builder().url(server.getUrl("/a")).build()).assertBody("abc");
+
+    // Second request: time out after 250ms.
+    client.setReadTimeout(250, TimeUnit.MILLISECONDS);
+    Request request = new Request.Builder().url(server.getUrl("/b")).build();
+    Response response = client.execute(request);
+    BufferedSource bodySource = response.body().source();
+    assertEquals('d', bodySource.readByte());
+
+    // The second byte of this request will be delayed by 750ms so we should time out after 250ms.
+    long startNanos = System.nanoTime();
+    try {
+      bodySource.readByte();
+      fail();
+    } catch (IOException expected) {
+      // Timed out as expected.
+      long elapsedNanos = System.nanoTime() - startNanos;
+      long elapsedMillis = TimeUnit.NANOSECONDS.toMillis(elapsedNanos);
+      assertTrue(String.format("Timed out: %sms", elapsedMillis), elapsedMillis < 500);
+    }
+  }
+
   @Test public void tls() throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse()
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index 40bb659..a65e591 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -150,7 +150,7 @@
     if (route.address.sslSocketFactory != null) {
       upgradeToTls(tunnelRequest, readTimeout, writeTimeout);
     } else {
-      httpConnection = new HttpConnection(pool, this, socket, readTimeout, writeTimeout);
+      httpConnection = new HttpConnection(pool, this, socket);
     }
     connected = true;
   }
@@ -201,7 +201,7 @@
           .protocol(protocol).build();
       spdyConnection.sendConnectionHeader();
     } else {
-      httpConnection = new HttpConnection(pool, this, socket, readTimeout, writeTimeout);
+      httpConnection = new HttpConnection(pool, this, socket);
     }
   }
 
@@ -304,9 +304,14 @@
     this.protocol = protocol;
   }
 
-  public void updateReadTimeout(int newTimeout) throws IOException {
-    if (!connected) throw new IllegalStateException("updateReadTimeout - not connected");
-    socket.setSoTimeout(newTimeout);
+  public void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis) throws IOException {
+    if (!connected) throw new IllegalStateException("setTimeouts - not connected");
+
+    // Don't set timeouts on shared SPDY connections.
+    if (httpConnection != null) {
+      socket.setSoTimeout(readTimeoutMillis);
+      httpConnection.setTimeouts(readTimeoutMillis, writeTimeoutMillis);
+    }
   }
 
   public void incrementRecycleCount() {
@@ -328,8 +333,8 @@
    */
   private void makeTunnel(Request request, int readTimeout, int writeTimeout)
       throws IOException {
-    HttpConnection tunnelConnection = new HttpConnection(
-        pool, this, socket, readTimeout, writeTimeout);
+    HttpConnection tunnelConnection = new HttpConnection(pool, this, socket);
+    tunnelConnection.setTimeouts(readTimeout, writeTimeout);
     URL url = request.url();
     String requestLine = "CONNECT " + url.getHost() + ":" + url.getPort() + " HTTP/1.1";
     while (true) {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
index eca3843..e2f49ff 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
@@ -80,19 +80,21 @@
   private int state = STATE_IDLE;
   private int onIdle = ON_IDLE_HOLD;
 
-  public HttpConnection(ConnectionPool pool, Connection connection, Socket socket,
-      int readTimeout, int writeTimeout)
+  public HttpConnection(ConnectionPool pool, Connection connection, Socket socket)
       throws IOException {
     this.pool = pool;
     this.connection = connection;
     this.socket = socket;
     this.source = Okio.buffer(Okio.source(socket));
-    if (readTimeout != 0) {
-      source.timeout().timeout(readTimeout, TimeUnit.MILLISECONDS);
-    }
     this.sink = Okio.buffer(Okio.sink(socket));
-    if (writeTimeout != 0) {
-      sink.timeout().timeout(writeTimeout, TimeUnit.MILLISECONDS);
+  }
+
+  public void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis) {
+    if (readTimeoutMillis != 0) {
+      source.timeout().timeout(readTimeoutMillis, TimeUnit.MILLISECONDS);
+    }
+    if (writeTimeoutMillis != 0) {
+      sink.timeout().timeout(writeTimeoutMillis, TimeUnit.MILLISECONDS);
     }
   }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 5257b37..7b2d851 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -254,10 +254,8 @@
           client.getWriteTimeout(), tunnelRequest(connection, request));
       if (connection.isSpdy()) client.getConnectionPool().share(connection);
       client.getRoutesDatabase().connected(connection.getRoute());
-    } else if (!connection.isSpdy()) {
-      connection.updateReadTimeout(client.getReadTimeout());
     }
-
+    connection.setTimeouts(client.getReadTimeout(), client.getWriteTimeout());
     route = connection.getRoute();
   }
 
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index ea4bc6e..62eba14 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -2468,6 +2468,18 @@
     assertEquals("GET /?query HTTP/1.1", request.getRequestLine());
   }
 
+  @Test public void doOutputForMethodThatDoesntSupportOutput() throws Exception {
+    server.play();
+    connection = client.open(server.getUrl("/"));
+    connection.setRequestMethod("HEAD");
+    connection.setDoOutput(true);
+    try {
+      connection.connect();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
   // http://code.google.com/p/android/issues/detail?id=20442
   @Test public void inputStreamAvailableWithChunkedEncoding() throws Exception {
     testInputStreamAvailable(TransferKind.CHUNKED);
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Job.java b/okhttp/src/main/java/com/squareup/okhttp/Job.java
index 9c3ea50..843da42 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Job.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Job.java
@@ -18,22 +18,12 @@
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.OkHeaders;
-import com.squareup.okhttp.internal.huc.HttpURLConnectionImpl;
 import java.io.IOException;
 import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.URL;
 import okio.BufferedSink;
 import okio.BufferedSource;
 
-import static com.squareup.okhttp.internal.Util.getEffectivePort;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
-import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
-import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
-import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
-import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
-import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+import static com.squareup.okhttp.internal.http.HttpEngine.MAX_REDIRECTS;
 
 final class Job extends NamedRunnable {
   private final Dispatcher dispatcher;
@@ -141,9 +131,9 @@
       }
 
       Response response = engine.getResponse();
-      Request redirect = processResponse(engine, response);
+      Request followUp = engine.followUpRequest();
 
-      if (redirect == null) {
+      if (followUp == null) {
         engine.releaseConnection();
         return response.newBuilder()
             .body(new RealResponseBody(response, engine.getResponseBody()))
@@ -151,76 +141,24 @@
             .build();
       }
 
-      if (!sameConnection(request, redirect)) {
+      if (engine.getResponse().isRedirect() && ++redirectionCount > MAX_REDIRECTS) {
+        throw new ProtocolException("Too many redirects: " + redirectionCount);
+      }
+
+      // TODO: drop from POST to GET when redirected? HttpURLConnection does.
+      // TODO: confirm that Cookies are not retained across hosts.
+
+      if (!engine.sameConnection(followUp)) {
         engine.releaseConnection();
       }
 
       Connection connection = engine.close();
       redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.
-      request = redirect;
+      request = followUp;
       engine = new HttpEngine(client, request, false, connection, null, null);
     }
   }
 
-  /**
-   * Figures out the HTTP request to make in response to receiving {@code
-   * response}. This will either add authentication headers or follow
-   * redirects. If a follow-up is either unnecessary or not applicable, this
-   * returns null.
-   */
-  private Request processResponse(HttpEngine engine, Response response) throws IOException {
-    Request request = response.request();
-    Proxy selectedProxy = engine.getRoute() != null
-        ? engine.getRoute().getProxy()
-        : client.getProxy();
-    int responseCode = response.code();
-
-    switch (responseCode) {
-      case HTTP_PROXY_AUTH:
-        if (selectedProxy.type() != Proxy.Type.HTTP) {
-          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
-        }
-        // fall-through
-      case HTTP_UNAUTHORIZED:
-        return OkHeaders.processAuthHeader(client.getAuthenticator(), response, selectedProxy);
-
-      case HTTP_TEMP_REDIRECT:
-        // "If the 307 status code is received in response to a request other than GET or HEAD,
-        // the user agent MUST NOT automatically redirect the request"
-        if (!request.method().equals("GET") && !request.method().equals("HEAD")) return null;
-        // fall-through
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-        String location = response.header("Location");
-        if (location == null) return null;
-        URL url = new URL(request.url(), location);
-
-        // Don't follow redirects to unsupported protocols.
-        if (!url.getProtocol().equals("https") && !url.getProtocol().equals("http")) return null;
-
-        // If configured, don't follow redirects between SSL and non-SSL.
-        boolean sameProtocol = url.getProtocol().equals(request.url().getProtocol());
-        if (!sameProtocol && !client.getFollowSslRedirects()) return null;
-
-        if (++redirectionCount > HttpURLConnectionImpl.MAX_REDIRECTS) {
-          throw new ProtocolException("Too many redirects: " + redirectionCount);
-        }
-
-        return this.request.newBuilder().url(url).build();
-
-      default:
-        return null;
-    }
-  }
-
-  static boolean sameConnection(Request a, Request b) {
-    return a.url().getHost().equals(b.url().getHost())
-        && getEffectivePort(a.url()) == getEffectivePort(b.url())
-        && a.url().getProtocol().equals(b.url().getProtocol());
-  }
-
   static class RealResponseBody extends Response.Body {
     private final Response response;
     private final BufferedSource source;
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index ed23e24..ae9adf8 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -28,7 +28,12 @@
 import okio.BufferedSource;
 
 import static com.squareup.okhttp.internal.Util.UTF_8;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
+import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
+import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
 import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
 
 /**
@@ -126,6 +131,20 @@
     return new Builder(this);
   }
 
+  /** Returns true if this response redirects to another resource. */
+  public boolean isRedirect() {
+    switch (code) {
+      case HTTP_TEMP_REDIRECT:
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_MOVED_TEMP:
+      case HTTP_SEE_OTHER:
+        return true;
+      default:
+        return false;
+    }
+  }
+
   /**
    * Returns the response for the HTTP redirect or authorization challenge that
    * triggered this response, or null if this response wasn't triggered by an
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 7b2d851..b644105 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -34,6 +34,7 @@
 import java.net.CookieHandler;
 import java.net.HttpURLConnection;
 import java.net.ProtocolException;
+import java.net.Proxy;
 import java.net.URL;
 import java.net.UnknownHostException;
 import java.security.cert.CertificateException;
@@ -54,8 +55,15 @@
 import static com.squareup.okhttp.internal.Util.getDefaultPort;
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
+import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
+import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
 import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
 import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
 
 /**
  * Handles a single HTTP request/response pair. Each HTTP engine follows this
@@ -75,7 +83,13 @@
  * <p>The request and response may be served by the HTTP response cache, by the
  * network, or by both in the event of a conditional GET.
  */
-public class HttpEngine {
+public final class HttpEngine {
+  /**
+   * How many redirects should we follow? Chrome follows 21; Firefox, curl,
+   * and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
+   */
+  public static final int MAX_REDIRECTS = 20;
+
   final OkHttpClient client;
 
   private Connection connection;
@@ -159,7 +173,7 @@
    * source if necessary. Prepares the request headers and gets ready to start
    * writing the request body if it exists.
    */
-  public final void sendRequest() throws IOException {
+  public void sendRequest() throws IOException {
     if (responseSource != null) return; // Already sent.
     if (transport != null) throw new IllegalStateException();
 
@@ -273,12 +287,12 @@
   }
 
   /** Returns the request body or null if this request doesn't have a body. */
-  public final Sink getRequestBody() {
+  public Sink getRequestBody() {
     if (responseSource == null) throw new IllegalStateException();
     return requestBodyOut;
   }
 
-  public final BufferedSink getBufferedRequestBody() {
+  public BufferedSink getBufferedRequestBody() {
     BufferedSink result = bufferedRequestBody;
     if (result != null) return result;
     Sink requestBody = getRequestBody();
@@ -287,38 +301,38 @@
         : null;
   }
 
-  public final boolean hasResponse() {
+  public boolean hasResponse() {
     return response != null;
   }
 
-  public final ResponseSource responseSource() {
+  public ResponseSource responseSource() {
     return responseSource;
   }
 
-  public final Request getRequest() {
+  public Request getRequest() {
     return request;
   }
 
   /** Returns the engine's response. */
   // TODO: the returned body will always be null.
-  public final Response getResponse() {
+  public Response getResponse() {
     if (response == null) throw new IllegalStateException();
     return response;
   }
 
-  public final BufferedSource getResponseBody() {
+  public BufferedSource getResponseBody() {
     if (response == null) throw new IllegalStateException();
     return responseBody;
   }
 
-  public final InputStream getResponseBodyBytes() {
+  public InputStream getResponseBodyBytes() {
     InputStream result = responseBodyBytes;
     return result != null
         ? result
         : (responseBodyBytes = Okio.buffer(getResponseBody()).inputStream());
   }
 
-  public final Connection getConnection() {
+  public Connection getConnection() {
     return connection;
   }
 
@@ -389,7 +403,7 @@
    * either exhausted or closed. If it is unneeded when this is called, it will
    * be released immediately.
    */
-  public final void releaseConnection() throws IOException {
+  public void releaseConnection() throws IOException {
     if (transport != null && connection != null) {
       transport.releaseConnectionOnIdle();
     }
@@ -402,7 +416,7 @@
    * the caller's responsibility to close the request body and response body
    * streams; otherwise resources may be leaked.
    */
-  public final void disconnect() throws IOException {
+  public void disconnect() throws IOException {
     if (transport != null) {
       transport.disconnect(this);
     }
@@ -412,7 +426,7 @@
    * Release any resources held by this engine. If a connection is still held by
    * this engine, it is returned.
    */
-  public final Connection close() {
+  public Connection close() {
     if (bufferedRequestBody != null) {
       // This also closes the wrapped requestBodyOut.
       closeQuietly(bufferedRequestBody);
@@ -483,7 +497,7 @@
    * Returns true if the response must have a (possibly 0-length) body.
    * See RFC 2616 section 4.3.
    */
-  public final boolean hasResponseBody() {
+  public boolean hasResponseBody() {
     // HEAD requests never yield a body regardless of the response headers.
     if (request.method().equals("HEAD")) {
       return false;
@@ -569,7 +583,7 @@
    * Flushes the remaining request header and body, parses the HTTP response
    * headers and starts reading the HTTP response body if it exists.
    */
-  public final void readResponse() throws IOException {
+  public void readResponse() throws IOException {
     if (response != null) return;
     if (responseSource == null) throw new IllegalStateException("call sendRequest() first!");
     if (!responseSource.requiresConnection()) return;
@@ -737,4 +751,64 @@
       cookieHandler.put(request.uri(), OkHeaders.toMultimap(headers, null));
     }
   }
+
+  /**
+   * Figures out the HTTP request to make in response to receiving this engine's
+   * response. This will either add authentication headers or follow redirects.
+   * If a follow-up is either unnecessary or not applicable, this returns null.
+   */
+  public Request followUpRequest() throws IOException {
+    if (response == null) throw new IllegalStateException();
+    Proxy selectedProxy = getRoute() != null
+        ? getRoute().getProxy()
+        : client.getProxy();
+    int responseCode = response.code();
+
+    switch (responseCode) {
+      case HTTP_PROXY_AUTH:
+        if (selectedProxy.type() != Proxy.Type.HTTP) {
+          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+        }
+        // fall-through
+      case HTTP_UNAUTHORIZED:
+        return OkHeaders.processAuthHeader(client.getAuthenticator(), response, selectedProxy);
+
+      case HTTP_TEMP_REDIRECT:
+        // "If the 307 status code is received in response to a request other than GET or HEAD,
+        // the user agent MUST NOT automatically redirect the request"
+        if (!request.method().equals("GET") && !request.method().equals("HEAD")) return null;
+        // fall-through
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_MOVED_TEMP:
+      case HTTP_SEE_OTHER:
+        String location = response.header("Location");
+        if (location == null) return null;
+        URL url = new URL(request.url(), location);
+
+        // Don't follow redirects to unsupported protocols.
+        if (!url.getProtocol().equals("https") && !url.getProtocol().equals("http")) return null;
+
+        // If configured, don't follow redirects between SSL and non-SSL.
+        boolean sameProtocol = url.getProtocol().equals(request.url().getProtocol());
+        if (!sameProtocol && !client.getFollowSslRedirects()) return null;
+
+        return request.newBuilder().url(url).build();
+
+      default:
+        return null;
+    }
+  }
+
+  /**
+   * Returns true if an HTTP request for {@code followUp} can use the same
+   * engine as this connection.
+   */
+  public boolean sameConnection(Request followUp) {
+    URL a = request.url();
+    URL b = followUp.url();
+    return a.getHost().equals(b.getHost())
+        && getEffectivePort(a) == getEffectivePort(b)
+        && a.getProtocol().equals(b.getProtocol());
+  }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java b/okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
index 8d56565..a16383e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
@@ -54,9 +54,6 @@
 import okio.BufferedSink;
 import okio.Sink;
 
-import static com.squareup.okhttp.internal.Util.getEffectivePort;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
-
 /**
  * This implementation uses HttpEngine to send requests and receive responses.
  * This class may use multiple HttpEngines to follow redirects, authentication
@@ -71,13 +68,6 @@
  */
 public class HttpURLConnectionImpl extends HttpURLConnection {
 
-  /**
-   * How many redirects should we follow? Chrome follows 21; Firefox, curl,
-   * and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
-   */
-  // TODO find a better location for this constant
-  public static final int MAX_REDIRECTS = 20;
-
   final OkHttpClient client;
 
   private Headers.Builder requestHeaders = new Headers.Builder();
@@ -340,20 +330,32 @@
         continue;
       }
 
-      Retry retry = processResponseHeaders();
-      if (retry == Retry.NONE) {
+      Response response = httpEngine.getResponse();
+      Request followUp = httpEngine.followUpRequest();
+
+      if (followUp == null) {
         httpEngine.releaseConnection();
         return httpEngine;
       }
 
+      if (response.isRedirect() && ++redirectionCount > HttpEngine.MAX_REDIRECTS) {
+        throw new ProtocolException("Too many redirects: " + redirectionCount);
+      }
+
       // The first request was insufficient. Prepare for another...
+      if (response.isRedirect()) {
+        url = followUp.url(); // Get the redirected URL.
+      } else {
+        requestHeaders = followUp.headers().newBuilder(); // Get the follow-up's credentials!
+      }
+
       String retryMethod = method;
       Sink requestBody = httpEngine.getRequestBody();
 
       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM
       // redirect should keep the same method, Chrome, Firefox and the
       // RI all issue GETs when following any redirect.
-      int responseCode = httpEngine.getResponse().code();
+      int responseCode = response.code();
       if (responseCode == HTTP_MULT_CHOICE
           || responseCode == HTTP_MOVED_PERM
           || responseCode == HTTP_MOVED_TEMP
@@ -367,7 +369,7 @@
         throw new HttpRetryException("Cannot retry streamed HTTP body", responseCode);
       }
 
-      if (retry == Retry.DIFFERENT_CONNECTION) {
+      if (!httpEngine.sameConnection(followUp)) {
         httpEngine.releaseConnection();
       }
 
@@ -406,78 +408,6 @@
     }
   }
 
-  enum Retry {
-    NONE,
-    SAME_CONNECTION,
-    DIFFERENT_CONNECTION
-  }
-
-  /**
-   * Returns the retry action to take for the current response headers. The
-   * headers, proxy and target URL for this connection may be adjusted to
-   * prepare for a follow up request.
-   */
-  private Retry processResponseHeaders() throws IOException {
-    Connection connection = httpEngine.getConnection();
-    Proxy selectedProxy = connection != null
-        ? connection.getRoute().getProxy()
-        : client.getProxy();
-    final int responseCode = getResponseCode();
-    switch (responseCode) {
-      case HTTP_PROXY_AUTH:
-        if (selectedProxy.type() != Proxy.Type.HTTP) {
-          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
-        }
-        // fall-through
-      case HTTP_UNAUTHORIZED:
-        Request successorRequest = OkHeaders.processAuthHeader(client.getAuthenticator(),
-            httpEngine.getResponse(), selectedProxy);
-        if (successorRequest == null) return Retry.NONE;
-        requestHeaders = successorRequest.getHeaders().newBuilder();
-        return Retry.SAME_CONNECTION;
-
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-      case HTTP_TEMP_REDIRECT:
-        if (!getInstanceFollowRedirects()) {
-          return Retry.NONE;
-        }
-        if (++redirectionCount > MAX_REDIRECTS) {
-          throw new ProtocolException("Too many redirects: " + redirectionCount);
-        }
-        if (responseCode == HTTP_TEMP_REDIRECT && !method.equals("GET") && !method.equals("HEAD")) {
-          // "If the 307 status code is received in response to a request other than GET or HEAD,
-          // the user agent MUST NOT automatically redirect the request"
-          return Retry.NONE;
-        }
-        String location = getHeaderField("Location");
-        if (location == null) {
-          return Retry.NONE;
-        }
-        URL previousUrl = url;
-        url = new URL(previousUrl, location);
-        if (!url.getProtocol().equals("https") && !url.getProtocol().equals("http")) {
-          return Retry.NONE; // Don't follow redirects to unsupported protocols.
-        }
-        boolean sameProtocol = previousUrl.getProtocol().equals(url.getProtocol());
-        if (!sameProtocol && !client.getFollowSslRedirects()) {
-          return Retry.NONE; // This client doesn't follow redirects across protocols.
-        }
-        boolean sameHost = previousUrl.getHost().equals(url.getHost());
-        boolean samePort = getEffectivePort(previousUrl) == getEffectivePort(url);
-        if (sameHost && samePort && sameProtocol) {
-          return Retry.SAME_CONNECTION;
-        } else {
-          return Retry.DIFFERENT_CONNECTION;
-        }
-
-      default:
-        return Retry.NONE;
-    }
-  }
-
   /**
    * Returns true if either:
    * <ul>
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/AsyncApiTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/AsyncApiTest.java
index d3af9d1..b51b815 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/AsyncApiTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/AsyncApiTest.java
@@ -26,6 +26,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
+import java.util.Arrays;
 import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
@@ -261,58 +262,118 @@
     receiver.await(server.getUrl("/20")).assertFailure("Too many redirects: 21");
   }
 
-  @Test public void canceledBeforeResponseReadIsNeverDelivered() throws Exception {
+  /**
+   * This test puts a request in front of one that is to be canceled, so that it is canceled
+   * before I/O takes place.
+   */
+  @Test public void canceledBeforeIOSignalsOnFailure() throws Exception {
     client.getDispatcher().setMaxRequests(1); // Force requests to be executed serially.
     server.setDispatcher(new Dispatcher() {
       char nextResponse = 'A';
       @Override public MockResponse dispatch(RecordedRequest request) {
-        client.cancel("request A");
+        client.cancel("request B");
         return new MockResponse().setBody(Character.toString(nextResponse++));
       }
     });
     server.play();
 
-    // Canceling a request after the server has received a request but before
-    // it has delivered the response. That request will never be received to the
-    // client.
     Request requestA = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
     client.enqueue(requestA, receiver);
     assertEquals("/a", server.takeRequest().getPath());
 
-    // We then make a second request (not canceled) to make sure the receiver
-    // has nothing left to wait for.
     Request requestB = new Request.Builder().url(server.getUrl("/b")).tag("request B").build();
     client.enqueue(requestB, receiver);
     assertEquals("/b", server.takeRequest().getPath());
-    receiver.await(requestB.url()).assertBody("B");
 
-    // At this point we know the receiver is ready: if it hasn't received 'A'
-    // yet it never will.
-    receiver.assertNoResponse(requestA.url());
+    receiver.await(requestA.url()).assertBody("A");
+    // At this point we know the receiver is ready, and that it will receive a cancel failure.
+    receiver.await(requestB.url()).assertFailure("Canceled");
   }
 
-  @Test public void canceledAfterResponseIsDeliveredDoesNothing() throws Exception {
+  @Test public void canceledBeforeIOSignalsOnFailure_HTTP_2() throws Exception {
+    enableNpn(Protocol.HTTP_2);
+    canceledBeforeIOSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeIOSignalsOnFailure_SPDY_3() throws Exception {
+    enableNpn(Protocol.SPDY_3);
+    canceledBeforeIOSignalsOnFailure();
+  }
+
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure() throws Exception {
+    server.setDispatcher(new Dispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        client.cancel("request A");
+        return new MockResponse().setBody("A");
+      }
+    });
+    server.play();
+
+    Request requestA = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
+    client.enqueue(requestA, receiver);
+    assertEquals("/a", server.takeRequest().getPath());
+
+    receiver.await(requestA.url()).assertFailure("Canceled");
+  }
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure_HTTP_2() throws Exception {
+    enableNpn(Protocol.HTTP_2);
+    canceledBeforeResponseReadSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure_SPDY_3() throws Exception {
+    enableNpn(Protocol.SPDY_3);
+    canceledBeforeResponseReadSignalsOnFailure();
+  }
+
+  /**
+   * There's a race condition where the cancel may apply after the stream has already been
+   * processed.
+   */
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
 
     final CountDownLatch latch = new CountDownLatch(1);
     final AtomicReference<String> bodyRef = new AtomicReference<String>();
+    final AtomicReference<Failure> failureRef = new AtomicReference<Failure>();
 
     Request request = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
     client.enqueue(request, new Response.Receiver() {
       @Override public void onFailure(Failure failure) {
-        throw new AssertionError();
+        latch.countDown();
+        failureRef.set(failure); // This should never occur as we don't signal twice.
       }
 
       @Override public void onResponse(Response response) throws IOException {
         client.cancel("request A");
-        bodyRef.set(response.body().string());
-        latch.countDown();
+        try {
+          bodyRef.set(response.body().string());
+        } catch (IOException e) { // It is ok if this broke the stream.
+          bodyRef.set("A");
+          throw e; // We expect to not loop into onFailure in this case.
+        } finally {
+          latch.countDown();
+        }
       }
     });
 
     latch.await();
     assertEquals("A", bodyRef.get());
+    assertNull(failureRef.get());
+  }
+
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTP_2()
+      throws Exception {
+    enableNpn(Protocol.HTTP_2);
+    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
+  }
+
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_SPDY_3()
+      throws Exception {
+    enableNpn(Protocol.SPDY_3);
+    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
   }
 
   @Test public void connectionReuseWhenResponseBodyConsumed() throws Exception {
@@ -372,4 +433,18 @@
     assertEquals("text/plain; charset=utf-8", request2.getHeader("Content-Type"));
     assertEquals(1, request2.getSequenceNumber());
   }
+
+
+  /**
+   * Tests that use this will fail unless boot classpath is set. Ex. {@code
+   * -Xbootclasspath/p:/tmp/npn-boot-1.1.7.v20140316.jar}
+   */
+  private void enableNpn(Protocol protocol) {
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.setNpnEnabled(true);
+    server.setNpnProtocols(client.getProtocols());
+  }
 }
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index 62eba14..241b51a 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -3086,7 +3086,7 @@
 
   /**
    * Tests that use this will fail unless boot classpath is set. Ex. {@code
-   * -Xbootclasspath/p:/tmp/npn-boot-8.1.2.v20120308.jar}
+   * -Xbootclasspath/p:/tmp/npn-boot-1.1.7.v20140316.jar}
    */
   private void enableNpn(Protocol protocol) {
     client.setSslSocketFactory(sslContext.getSocketFactory());
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index 0ec53a1..5c01e74 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -16,6 +16,7 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.http.HttpEngine;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.Iterator;
@@ -113,17 +114,18 @@
     }
   }
 
-  /**
-   * Cancel all jobs with the tag {@code tag}. If a canceled job is running it
-   * may continue running until it reaches a safe point to finish.
-   */
+  /** Cancel all jobs with the tag {@code tag}. */
   public synchronized void cancel(Object tag) {
     for (Iterator<Job> i = readyJobs.iterator(); i.hasNext(); ) {
       if (Util.equal(tag, i.next().tag())) i.remove();
     }
 
     for (Job job : runningJobs) {
-      if (Util.equal(tag, job.tag())) job.canceled = true;
+      if (Util.equal(tag, job.tag())) {
+        job.canceled = true;
+        HttpEngine engine = job.engine;
+        if (engine != null) engine.disconnect();
+      }
     }
   }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Job.java b/okhttp/src/main/java/com/squareup/okhttp/Job.java
index 843da42..d69463c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Job.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Job.java
@@ -20,6 +20,7 @@
 import com.squareup.okhttp.internal.http.OkHeaders;
 import java.io.IOException;
 import java.net.ProtocolException;
+import java.util.concurrent.CancellationException;
 import okio.BufferedSink;
 import okio.BufferedSource;
 
@@ -59,12 +60,21 @@
   }
 
   @Override protected void execute() {
+    boolean signalledReceiver = false;
     try {
       Response response = getResponse();
-      if (response != null && !canceled) {
+      if (canceled) {
+        signalledReceiver = true;
+        responseReceiver.onFailure(new Failure.Builder()
+            .request(request)
+            .exception(new CancellationException("Canceled"))
+            .build());
+      } else {
+        signalledReceiver = true;
         responseReceiver.onResponse(response);
       }
     } catch (IOException e) {
+      if (signalledReceiver) return; // Do not signal the receiver twice!
       responseReceiver.onFailure(new Failure.Builder()
           .request(request)
           .exception(e)
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index b644105..499d966 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -416,9 +416,12 @@
    * the caller's responsibility to close the request body and response body
    * streams; otherwise resources may be leaked.
    */
-  public void disconnect() throws IOException {
+  public void disconnect() {
     if (transport != null) {
-      transport.disconnect(this);
+      try {
+        transport.disconnect(this);
+      } catch (IOException ignored) {
+      }
     }
   }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java b/okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
index a16383e..cd04354 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
@@ -107,10 +107,7 @@
     // Calling disconnect() before a connection exists should have no effect.
     if (httpEngine == null) return;
 
-    try {
-      httpEngine.disconnect();
-    } catch (IOException ignored) {
-    }
+    httpEngine.disconnect();
 
     // This doesn't close the stream because doing so would require all stream
     // access to be synchronized. It's expected that the thread using the
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
index c585255..06b0aef 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
@@ -49,7 +49,7 @@
   /**
    * Returns the round trip time for this ping in nanoseconds, waiting for the
    * response to arrive if necessary. Returns -1 if the response was
-   * cancelled.
+   * canceled.
    */
   public long roundTripTime() throws InterruptedException {
     latch.await();
@@ -58,7 +58,7 @@
 
   /**
    * Returns the round trip time for this ping in nanoseconds, or -1 if the
-   * response was cancelled, or -2 if the timeout elapsed before the round
+   * response was canceled, or -2 if the timeout elapsed before the round
    * trip completed.
    */
   public long roundTripTime(long timeout, TimeUnit unit) throws InterruptedException {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
index 8eecf6b..fa478ad 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
@@ -60,7 +60,7 @@
   boolean onData(int streamId, BufferedSource source, int byteCount, boolean last)
       throws IOException;
 
-  /** Indicates the reason why this stream was cancelled. */
+  /** Indicates the reason why this stream was canceled. */
   void onReset(int streamId, ErrorCode errorCode);
 
   PushObserver CANCEL = new PushObserver() {
/Fim/
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index 9c7af9d..e02945c 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -30,7 +30,7 @@
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
-      <scope>test</scope>
+      <optional>true</optional>
     </dependency>
   </dependencies>
 
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java
new file mode 100644
index 0000000..0ec7499
--- /dev/null
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.mockwebserver.rule;
+
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.IOException;
+import java.net.ServerSocket;
+import java.net.URL;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.junit.rules.ExternalResource;
+
+/**
+ * Allows you to use {@link MockWebServer} as a JUnit test rule.
+ *
+ * <p>This rule starts {@link MockWebServer} on an available port before your test runs, and shuts
+ * it down after it completes.
+ */
+public class MockWebServerRule extends ExternalResource {
+  private static final Logger logger = Logger.getLogger(MockWebServerRule.class.getName());
+
+  private final int port = pickPort();
+  private final MockWebServer server = new MockWebServer();
+
+  @Override protected void before() {
+    try {
+      server.play(port);
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override protected void after() {
+    try {
+      server.shutdown();
+    } catch (IOException e) {
+      logger.log(Level.WARNING, "MockWebServer shutdown failed", e);
+    }
+  }
+
+  public int getPort() {
+    return port;
+  }
+
+  public int getRequestCount() {
+    return server.getRequestCount();
+  }
+
+  public void enqueue(MockResponse response) {
+    server.enqueue(response);
+  }
+
+  public RecordedRequest takeRequest() throws InterruptedException {
+    return server.takeRequest();
+  }
+
+  public URL getUrl(String path) {
+    return server.getUrl(path);
+  }
+
+  /** For any other functionality, use the {@linkplain MockWebServer} directly. */
+  public MockWebServer get() {
+    return server;
+  }
+
+  private static int pickPort() {
+    ServerSocket socket = null;
+    try {
+      socket = new ServerSocket(0);
+      return socket.getLocalPort();
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    } finally {
+      Util.closeQuietly(socket);
+    }
+  }
+}
/Fim/
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java
new file mode 100644
index 0000000..b43e5bf
--- /dev/null
+++ b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.mockwebserver.rule;
+
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.net.ConnectException;
+import java.net.HttpURLConnection;
+import java.net.ServerSocket;
+import java.net.URL;
+import org.junit.After;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class MockWebServerRuleTest {
+
+  private MockWebServerRule server = new MockWebServerRule();
+
+  @After public void tearDown() {
+    server.after();
+  }
+
+  @Test public void whenRuleCreatedPortIsAvailableAndServerNotYetPlayed() throws IOException {
+    assertTrue(server.getPort() > 0);
+
+    try {
+      server.get().getPort();
+      fail();
+    } catch (IllegalStateException e) {
+
+    }
+
+    // Verify the port is available.
+    new ServerSocket(server.getPort()).close();
+  }
+
+  @Test public void differentRulesGetDifferentPorts() throws IOException {
+    assertNotEquals(server.getPort(), new MockWebServerRule().getPort());
+  }
+
+  @Test public void beforePlaysServer() throws Exception {
+    server.before();
+    assertEquals(server.getPort(), server.get().getPort());
+    server.getUrl("/").openConnection().connect();
+  }
+
+  @Test public void afterStopsServer() throws Exception {
+    server.before();
+    server.after();
+
+    try {
+      server.getUrl("/").openConnection().connect();
+      fail();
+    } catch (ConnectException e) {
+    }
+  }
+
+  @Test public void typicalUsage() throws Exception {
+    server.before(); // Implicitly called when @Rule.
+
+    server.enqueue(new MockResponse().setBody("hello world"));
+
+    URL url = server.getUrl("/aaa");
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    InputStream in = connection.getInputStream();
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    assertEquals("hello world", reader.readLine());
+
+    assertEquals(1, server.getRequestCount());
+    assertEquals("GET /aaa HTTP/1.1", server.takeRequest().getRequestLine());
+
+    server.after(); // Implicitly called when @Rule.
+  }
+}
+
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
index 89e9f6e..996a37f 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
@@ -84,7 +84,7 @@
 
   @Override public void enqueue(URL url) throws Exception {
     requestsInFlight.incrementAndGet();
-    client.call(new Request.Builder().tag(System.nanoTime()).url(url).build()).execute(callback);
+    client.newCall(new Request.Builder().tag(System.nanoTime()).url(url).build()).execute(callback);
   }
 
   @Override public synchronized boolean acceptingJobs() {
/Fim/
diff --git a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
index 3f4e725..d2dfcc8 100644
--- a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
+++ b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
@@ -126,7 +126,7 @@
     client = createClient();
     Request request = createRequest();
     try {
-      Response response = client.execute(request);
+      Response response = client.newCall(request).execute();
       if (showHeaders) {
         System.out.println(StatusLine.get(response));
         Headers headers = response.headers();
/Fim/
diff --git a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
index d05591f..3d2ae39 100644
--- a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
+++ b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
@@ -159,7 +159,7 @@
   @Override public HttpResponse execute(HttpHost host, HttpRequest request, HttpContext context)
       throws IOException {
     Request okRequest = transformRequest(request);
-    Response okResponse = client.execute(okRequest);
+    Response okResponse = client.newCall(okRequest).execute();
     return transformResponse(okResponse);
   }
 
/Fim/
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
new file mode 100644
index 0000000..dc66d6f
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
@@ -0,0 +1,781 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.RecordingHostnameVerifier;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.mockwebserver.Dispatcher;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.SocketPolicy;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.util.Arrays;
+import java.util.UUID;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.net.ssl.SSLContext;
+import okio.BufferedSource;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CallTest {
+  private MockWebServer server = new MockWebServer();
+  private OkHttpClient client = new OkHttpClient();
+  private RecordingCallback callback = new RecordingCallback();
+
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+  private HttpResponseCache cache;
+
+  @Before public void setUp() throws Exception {
+    String tmp = System.getProperty("java.io.tmpdir");
+    File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
+    cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
+  }
+
+  @After public void tearDown() throws Exception {
+    server.shutdown();
+    cache.delete();
+  }
+
+  @Test public void illegalToExecuteTwice() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    Call call = client.newCall(request);
+    call.execute();
+
+    try {
+      call.execute();
+      fail();
+    } catch (IllegalStateException e){
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    try {
+      call.execute(callback);
+      fail();
+    } catch (IllegalStateException e){
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    assertTrue(server.takeRequest().getHeaders().contains("User-Agent: SyncApiTest"));
+  }
+
+  @Test public void illegalToExecuteTwice_Async() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    Call call = client.newCall(request);
+    call.execute(callback);
+
+    try {
+      call.execute();
+      fail();
+    } catch (IllegalStateException e){
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    try {
+      call.execute(callback);
+      fail();
+    } catch (IllegalStateException e){
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    assertTrue(server.takeRequest().getHeaders().contains("User-Agent: SyncApiTest"));
+  }
+
+  @Test public void get() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertContainsHeaders("Content-Type: text/plain")
+        .assertBody("abc");
+
+    assertTrue(server.takeRequest().getHeaders().contains("User-Agent: SyncApiTest"));
+  }
+
+  @Test public void get_Async() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("User-Agent", "AsyncApiTest")
+        .build();
+    client.newCall(request).execute(callback);
+
+    callback.await(request.url())
+        .assertCode(200)
+        .assertContainsHeaders("Content-Type: text/plain")
+        .assertBody("abc");
+
+    assertTrue(server.takeRequest().getHeaders().contains("User-Agent: AsyncApiTest"));
+  }
+
+  @Test public void connectionPooling() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.enqueue(new MockResponse().setBody("ghi"));
+    server.play();
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/a")).build())
+        .assertBody("abc");
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/b")).build())
+        .assertBody("def");
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/c")).build())
+        .assertBody("ghi");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionPooling_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.enqueue(new MockResponse().setBody("ghi"));
+    server.play();
+
+    client.newCall(new Request.Builder().url(server.getUrl("/a")).build()).execute(callback);
+    callback.await(server.getUrl("/a")).assertBody("abc");
+
+    client.newCall(new Request.Builder().url(server.getUrl("/b")).build()).execute(callback);
+    callback.await(server.getUrl("/b")).assertBody("def");
+
+    client.newCall(new Request.Builder().url(server.getUrl("/c")).build()).execute(callback);
+    callback.await(server.getUrl("/c")).assertBody("ghi");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionReuseWhenResponseBodyConsumed_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.play();
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).build();
+    client.newCall(request).execute(new Response.Callback() {
+      @Override public void onFailure(Failure failure) {
+        throw new AssertionError();
+      }
+
+      @Override public void onResponse(Response response) throws IOException {
+        InputStream bytes = response.body().byteStream();
+        assertEquals('a', bytes.read());
+        assertEquals('b', bytes.read());
+        assertEquals('c', bytes.read());
+
+        // This request will share a connection with 'A' cause it's all done.
+        client.newCall(new Request.Builder().url(server.getUrl("/b")).build()).execute(callback);
+      }
+    });
+
+    callback.await(server.getUrl("/b")).assertCode(200).assertBody("def");
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reuse!
+  }
+
+  @Test public void timeoutsUpdatedOnReusedConnections() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
+    server.play();
+
+    // First request: time out after 1000ms.
+    client.setReadTimeout(1000, TimeUnit.MILLISECONDS);
+    executeSynchronously(new Request.Builder().url(server.getUrl("/a")).build()).assertBody("abc");
+
+    // Second request: time out after 250ms.
+    client.setReadTimeout(250, TimeUnit.MILLISECONDS);
+    Request request = new Request.Builder().url(server.getUrl("/b")).build();
+    Response response = client.newCall(request).execute();
+    BufferedSource bodySource = response.body().source();
+    assertEquals('d', bodySource.readByte());
+
+    // The second byte of this request will be delayed by 750ms so we should time out after 250ms.
+    long startNanos = System.nanoTime();
+    try {
+      bodySource.readByte();
+      fail();
+    } catch (IOException expected) {
+      // Timed out as expected.
+      long elapsedNanos = System.nanoTime() - startNanos;
+      long elapsedMillis = TimeUnit.NANOSECONDS.toMillis(elapsedNanos);
+      assertTrue(String.format("Timed out: %sms", elapsedMillis), elapsedMillis < 500);
+    }
+  }
+
+  @Test public void tls() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build())
+        .assertHandshake();
+  }
+
+  @Test public void tls_Async() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request).execute(callback);
+
+    callback.await(request.url()).assertHandshake();
+  }
+
+  @Test public void recoverFromTlsHandshakeFailure() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build())
+        .assertBody("abc");
+  }
+
+  @Test public void recoverFromTlsHandshakeFailure_Async() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request).execute(callback);
+
+    callback.await(request.url()).assertBody("abc");
+  }
+
+  @Test public void setFollowSslRedirectsFalse() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: http://square.com"));
+    server.play();
+
+    client.setFollowSslRedirects(false);
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Response response = client.newCall(request).execute();
+    assertEquals(301, response.code());
+  }
+
+  @Test public void post() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .post(Request.Body.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("def", recordedRequest.getUtf8Body());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void post_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .post(Request.Body.create(MediaType.parse("text/plain"), "def"))
+        .build();
+    client.newCall(request).execute(callback);
+
+    callback.await(request.url())
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("def", recordedRequest.getUtf8Body());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.play();
+
+    // Seed the connection pool so we have something that can fail.
+    Request request1 = new Request.Builder().url(server.getUrl("/")).build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("abc", response1.body().string());
+
+    Request request2 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .post(Request.Body.create(MediaType.parse("text/plain"), "body!"))
+        .build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("def", response2.body().string());
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals(0, get.getSequenceNumber());
+
+    RecordedRequest post1 = server.takeRequest();
+    assertEquals("body!", post1.getUtf8Body());
+    assertEquals(1, post1.getSequenceNumber());
+
+    RecordedRequest post2 = server.takeRequest();
+    assertEquals("body!", post2.getUtf8Body());
+    assertEquals(0, post2.getSequenceNumber());
+  }
+
+  @Test public void conditionalCacheHit() throws Exception {
+    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    client.setOkResponseCache(cache);
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build())
+        .assertCode(200).assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build())
+        .assertCode(200).assertBody("A");
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  @Test public void conditionalCacheHit_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    client.setOkResponseCache(cache);
+
+    Request request1 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request1).execute(callback);
+    callback.await(request1.url()).assertCode(200).assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    Request request2 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request2).execute(callback);
+    callback.await(request2.url()).assertCode(200).assertBody("A");
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  @Test public void conditionalCacheMiss() throws Exception {
+    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.play();
+
+    client.setOkResponseCache(cache);
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build())
+        .assertCode(200).assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build())
+        .assertCode(200).assertBody("B");
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  @Test public void conditionalCacheMiss_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.play();
+
+    client.setOkResponseCache(cache);
+
+    Request request1 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request1).execute(callback);
+    callback.await(request1.url()).assertCode(200).assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    Request request2 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request2).execute(callback);
+    callback.await(request2.url()).assertCode(200).assertBody("B");
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  @Test public void redirect() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .addHeader("Test", "Redirect from /a to /b")
+        .setBody("/a has moved!"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /c")
+        .addHeader("Test", "Redirect from /b to /c")
+        .setBody("/b has moved!"));
+    server.enqueue(new MockResponse().setBody("C"));
+    server.play();
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/a")).build())
+        .assertCode(200)
+        .assertBody("C")
+        .redirectedBy()
+        .assertCode(302)
+        .assertContainsHeaders("Test: Redirect from /b to /c")
+        .redirectedBy()
+        .assertCode(301)
+        .assertContainsHeaders("Test: Redirect from /a to /b");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
+  }
+
+  @Test public void redirect_Async() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .addHeader("Test", "Redirect from /a to /b")
+        .setBody("/a has moved!"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /c")
+        .addHeader("Test", "Redirect from /b to /c")
+        .setBody("/b has moved!"));
+    server.enqueue(new MockResponse().setBody("C"));
+    server.play();
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).build();
+    client.newCall(request).execute(callback);
+
+    callback.await(server.getUrl("/c"))
+        .assertCode(200)
+        .assertBody("C")
+        .redirectedBy()
+        .assertCode(302)
+        .assertContainsHeaders("Test: Redirect from /b to /c")
+        .redirectedBy()
+        .assertCode(301)
+        .assertContainsHeaders("Test: Redirect from /a to /b");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
+  }
+
+  @Test public void follow20Redirects() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
+    server.play();
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/0")).build())
+        .assertCode(200)
+        .assertBody("Success!");
+  }
+
+  @Test public void follow20Redirects_Async() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
+    server.play();
+
+    Request request = new Request.Builder().url(server.getUrl("/0")).build();
+    client.newCall(request).execute(callback);
+    callback.await(server.getUrl("/20"))
+        .assertCode(200)
+        .assertBody("Success!");
+  }
+
+  @Test public void doesNotFollow21Redirects() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.play();
+
+    try {
+      client.newCall(new Request.Builder().url(server.getUrl("/0")).build()).execute();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Too many redirects: 21", e.getMessage());
+    }
+  }
+
+  @Test public void doesNotFollow21Redirects_Async() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.play();
+
+    Request request = new Request.Builder().url(server.getUrl("/0")).build();
+    client.newCall(request).execute(callback);
+    callback.await(server.getUrl("/20")).assertFailure("Too many redirects: 21");
+  }
+
+  @Test public void canceledBeforeExecute() throws Exception {
+    server.play();
+
+    Call call = client.newCall(new Request.Builder().url(server.getUrl("/a")).build());
+    call.cancel();
+
+    assertNull(call.execute());
+    assertEquals(0, server.getRequestCount());
+  }
+
+  @Test public void cancelBeforeBodyIsRead() throws Exception {
+    server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
+    server.play();
+
+    final Call call = client.newCall(new Request.Builder().url(server.getUrl("/a")).build());
+    ExecutorService executor = Executors.newSingleThreadExecutor();
+    Future<Response> result = executor.submit(new Callable<Response>() {
+      @Override public Response call() throws Exception {
+        return call.execute();
+      }
+    });
+
+    Thread.sleep(100); // wait for it to go in flight.
+
+    call.cancel();
+    try {
+      result.get().body().bytes();
+      fail();
+    } catch (IOException e) {
+    }
+    assertEquals(1, server.getRequestCount());
+  }
+
+  /**
+   * This test puts a request in front of one that is to be canceled, so that it is canceled before
+   * I/O takes place.
+   */
+  @Test public void canceledBeforeIOSignalsOnFailure() throws Exception {
+    client.getDispatcher().setMaxRequests(1); // Force requests to be executed serially.
+    server.setDispatcher(new Dispatcher() {
+      char nextResponse = 'A';
+
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        client.cancel("request B");
+        return new MockResponse().setBody(Character.toString(nextResponse++));
+      }
+    });
+    server.play();
+
+    Request requestA = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
+    client.newCall(requestA).execute(callback);
+    assertEquals("/a", server.takeRequest().getPath());
+
+    Request requestB = new Request.Builder().url(server.getUrl("/b")).tag("request B").build();
+    client.newCall(requestB).execute(callback);
+    assertEquals("/b", server.takeRequest().getPath());
+
+    callback.await(requestA.url()).assertBody("A");
+    // At this point we know the callback is ready, and that it will receive a cancel failure.
+    callback.await(requestB.url()).assertFailure("Canceled");
+  }
+
+  @Test public void canceledBeforeIOSignalsOnFailure_HTTP_2() throws Exception {
+    enableNpn(Protocol.HTTP_2);
+    canceledBeforeIOSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeIOSignalsOnFailure_SPDY_3() throws Exception {
+    enableNpn(Protocol.SPDY_3);
+    canceledBeforeIOSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure() throws Exception {
+    server.setDispatcher(new Dispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        client.cancel("request A");
+        return new MockResponse().setBody("A");
+      }
+    });
+    server.play();
+
+    Request requestA = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
+    client.newCall(requestA).execute(callback);
+    assertEquals("/a", server.takeRequest().getPath());
+
+    callback.await(requestA.url()).assertFailure("Canceled");
+  }
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure_HTTP_2() throws Exception {
+    enableNpn(Protocol.HTTP_2);
+    canceledBeforeResponseReadSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure_SPDY_3() throws Exception {
+    enableNpn(Protocol.SPDY_3);
+    canceledBeforeResponseReadSignalsOnFailure();
+  }
+
+  /**
+   * There's a race condition where the cancel may apply after the stream has already been
+   * processed.
+   */
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<String> bodyRef = new AtomicReference<String>();
+    final AtomicReference<Failure> failureRef = new AtomicReference<Failure>();
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
+    final Call call = client.newCall(request);
+    call.execute(new Response.Callback() {
+      @Override public void onFailure(Failure failure) {
+        latch.countDown();
+        failureRef.set(failure); // This should never occur as we don't signal twice.
+      }
+
+      @Override public void onResponse(Response response) throws IOException {
+        call.cancel();
+        try {
+          bodyRef.set(response.body().string());
+        } catch (IOException e) { // It is ok if this broke the stream.
+          bodyRef.set("A");
+          throw e; // We expect to not loop into onFailure in this case.
+        } finally {
+          latch.countDown();
+        }
+      }
+    });
+
+    latch.await();
+    assertEquals("A", bodyRef.get());
+    assertNull(failureRef.get());
+  }
+
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTP_2()
+      throws Exception {
+    enableNpn(Protocol.HTTP_2);
+    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
+  }
+
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_SPDY_3()
+      throws Exception {
+    enableNpn(Protocol.SPDY_3);
+    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
+  }
+
+  private RecordedResponse executeSynchronously(Request request) throws IOException {
+    Response response = client.newCall(request).execute();
+    return new RecordedResponse(request, response, response.body().string(), null);
+  }
+
+  /**
+   * Tests that use this will fail unless boot classpath is set. Ex. {@code
+   * -Xbootclasspath/p:/tmp/npn-boot-1.1.7.v20140316.jar}
+   */
+  private void enableNpn(Protocol protocol) {
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.setNpnEnabled(true);
+    server.setNpnProtocols(client.getProtocols());
+  }
+}
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
index b159571..8e01880 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
@@ -1,5 +1,6 @@
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.Call.AsyncCall;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
@@ -40,53 +41,53 @@
   }
 
   @Test public void enqueuedJobsRunImmediately() throws Exception {
-    client.call(newRequest("http://a/1")).execute(callback);
+    client.newCall(newRequest("http://a/1")).execute(callback);
     executor.assertJobs("http://a/1");
   }
 
   @Test public void maxRequestsEnforced() throws Exception {
     dispatcher.setMaxRequests(3);
-    client.call(newRequest("http://a/1")).execute(callback);
-    client.call(newRequest("http://a/2")).execute(callback);
-    client.call(newRequest("http://b/1")).execute(callback);
-    client.call(newRequest("http://b/2")).execute(callback);
+    client.newCall(newRequest("http://a/1")).execute(callback);
+    client.newCall(newRequest("http://a/2")).execute(callback);
+    client.newCall(newRequest("http://b/1")).execute(callback);
+    client.newCall(newRequest("http://b/2")).execute(callback);
     executor.assertJobs("http://a/1", "http://a/2", "http://b/1");
   }
 
   @Test public void maxPerHostEnforced() throws Exception {
     dispatcher.setMaxRequestsPerHost(2);
-    client.call(newRequest("http://a/1")).execute(callback);
-    client.call(newRequest("http://a/2")).execute(callback);
-    client.call(newRequest("http://a/3")).execute(callback);
+    client.newCall(newRequest("http://a/1")).execute(callback);
+    client.newCall(newRequest("http://a/2")).execute(callback);
+    client.newCall(newRequest("http://a/3")).execute(callback);
     executor.assertJobs("http://a/1", "http://a/2");
   }
 
   @Test public void increasingMaxRequestsPromotesJobsImmediately() throws Exception {
     dispatcher.setMaxRequests(2);
-    client.call(newRequest("http://a/1")).execute(callback);
-    client.call(newRequest("http://b/1")).execute(callback);
-    client.call(newRequest("http://c/1")).execute(callback);
-    client.call(newRequest("http://a/2")).execute(callback);
-    client.call(newRequest("http://b/2")).execute(callback);
+    client.newCall(newRequest("http://a/1")).execute(callback);
+    client.newCall(newRequest("http://b/1")).execute(callback);
+    client.newCall(newRequest("http://c/1")).execute(callback);
+    client.newCall(newRequest("http://a/2")).execute(callback);
+    client.newCall(newRequest("http://b/2")).execute(callback);
     dispatcher.setMaxRequests(4);
     executor.assertJobs("http://a/1", "http://b/1", "http://c/1", "http://a/2");
   }
 
   @Test public void increasingMaxPerHostPromotesJobsImmediately() throws Exception {
     dispatcher.setMaxRequestsPerHost(2);
-    client.call(newRequest("http://a/1")).execute(callback);
-    client.call(newRequest("http://a/2")).execute(callback);
-    client.call(newRequest("http://a/3")).execute(callback);
-    client.call(newRequest("http://a/4")).execute(callback);
-    client.call(newRequest("http://a/5")).execute(callback);
+    client.newCall(newRequest("http://a/1")).execute(callback);
+    client.newCall(newRequest("http://a/2")).execute(callback);
+    client.newCall(newRequest("http://a/3")).execute(callback);
+    client.newCall(newRequest("http://a/4")).execute(callback);
+    client.newCall(newRequest("http://a/5")).execute(callback);
     dispatcher.setMaxRequestsPerHost(4);
     executor.assertJobs("http://a/1", "http://a/2", "http://a/3", "http://a/4");
   }
 
   @Test public void oldJobFinishesNewJobCanRunDifferentHost() throws Exception {
     dispatcher.setMaxRequests(1);
-    client.call(newRequest("http://a/1")).execute(callback);
-    client.call(newRequest("http://b/1")).execute(callback);
+    client.newCall(newRequest("http://a/1")).execute(callback);
+    client.newCall(newRequest("http://b/1")).execute(callback);
     executor.finishJob("http://a/1");
     executor.assertJobs("http://b/1");
   }
@@ -94,27 +95,27 @@
   @Test public void oldJobFinishesNewJobWithSameHostStarts() throws Exception {
     dispatcher.setMaxRequests(2);
     dispatcher.setMaxRequestsPerHost(1);
-    client.call(newRequest("http://a/1")).execute(callback);
-    client.call(newRequest("http://b/1")).execute(callback);
-    client.call(newRequest("http://b/2")).execute(callback);
-    client.call(newRequest("http://a/2")).execute(callback);
+    client.newCall(newRequest("http://a/1")).execute(callback);
+    client.newCall(newRequest("http://b/1")).execute(callback);
+    client.newCall(newRequest("http://b/2")).execute(callback);
+    client.newCall(newRequest("http://a/2")).execute(callback);
     executor.finishJob("http://a/1");
     executor.assertJobs("http://b/1", "http://a/2");
   }
 
   @Test public void oldJobFinishesNewJobCantRunDueToHostLimit() throws Exception {
     dispatcher.setMaxRequestsPerHost(1);
-    client.call(newRequest("http://a/1")).execute(callback);
-    client.call(newRequest("http://b/1")).execute(callback);
-    client.call(newRequest("http://a/2")).execute(callback);
+    client.newCall(newRequest("http://a/1")).execute(callback);
+    client.newCall(newRequest("http://b/1")).execute(callback);
+    client.newCall(newRequest("http://a/2")).execute(callback);
     executor.finishJob("http://b/1");
     executor.assertJobs("http://a/1");
   }
 
   @Test public void cancelingReadyJobPreventsItFromStarting() throws Exception {
     dispatcher.setMaxRequestsPerHost(1);
-    client.call(newRequest("http://a/1")).execute(callback);
-    client.call(newRequest("http://a/2", "tag1")).execute(callback);
+    client.newCall(newRequest("http://a/1")).execute(callback);
+    client.newCall(newRequest("http://a/2", "tag1")).execute(callback);
     dispatcher.cancel("tag1");
     executor.finishJob("http://a/1");
     executor.assertJobs();
@@ -122,8 +123,8 @@
 
   @Test public void cancelingRunningJobTakesNoEffectUntilJobFinishes() throws Exception {
     dispatcher.setMaxRequests(1);
-    client.call(newRequest("http://a/1", "tag1")).execute(callback);
-    client.call(newRequest("http://a/2")).execute(callback);
+    client.newCall(newRequest("http://a/1", "tag1")).execute(callback);
+    client.newCall(newRequest("http://a/2")).execute(callback);
     dispatcher.cancel("tag1");
     executor.assertJobs("http://a/1");
     executor.finishJob("http://a/1");
@@ -131,26 +132,26 @@
   }
 
   class RecordingExecutor extends AbstractExecutorService {
-    private List<Job> jobs = new ArrayList<Job>();
+    private List<AsyncCall> calls = new ArrayList<AsyncCall>();
 
     @Override public void execute(Runnable command) {
-      jobs.add((Job) command);
+      calls.add((AsyncCall) command);
     }
 
     public void assertJobs(String... expectedUrls) {
       List<String> actualUrls = new ArrayList<String>();
-      for (Job job : jobs) {
-        actualUrls.add(job.request().urlString());
+      for (AsyncCall call : calls) {
+        actualUrls.add(call.request().urlString());
       }
       assertEquals(Arrays.asList(expectedUrls), actualUrls);
     }
 
     public void finishJob(String url) {
-      for (Iterator<Job> i = jobs.iterator(); i.hasNext(); ) {
-        Job job = i.next();
-        if (job.request().urlString().equals(url)) {
+      for (Iterator<AsyncCall> i = calls.iterator(); i.hasNext(); ) {
+        AsyncCall call = i.next();
+        if (call.request().urlString().equals(url)) {
           i.remove();
-          dispatcher.finished(job);
+          dispatcher.finished(call);
           return;
         }
       }
/Fim/
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/com/squareup/okhttp/Call.java
index 161a80c..429e122 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Call.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java
@@ -15,42 +15,258 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.NamedRunnable;
+import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.OkHeaders;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.concurrent.CancellationException;
+import okio.BufferedSink;
+import okio.BufferedSource;
+
+import static com.squareup.okhttp.internal.http.HttpEngine.MAX_REDIRECTS;
+
 /**
- * A call is an asynchronous {@code request} that has been prepared for
- * execution. Once executed, a call can be cancelled. As this object represents
- * a single request/response pair (or stream), it cannot be executed twice.
+ * A call is a request that has been prepared for execution. A call can be
+ * canceled. As this object represents a single request/response pair (stream),
+ * it cannot be executed twice.
  */
 public final class Call {
   private final OkHttpClient client;
   private final Dispatcher dispatcher;
-  private final Request request;
+  private int redirectionCount;
 
-  public Call(OkHttpClient client, Dispatcher dispatcher,
-      Request request) {
+  // Guarded by this.
+  private boolean executed;
+  volatile boolean canceled;
+
+  /** The request; possibly a consequence of redirects or auth headers. */
+  private Request request;
+  HttpEngine engine;
+
+  Call(OkHttpClient client, Dispatcher dispatcher, Request request) {
     this.client = client;
     this.dispatcher = dispatcher;
     this.request = request;
   }
 
   /**
-   * Schedules the {@code request} to be executed at some point in the future.
-   * The {@link OkHttpClient#getDispatcher dispatcher} defines when the request
-   * will run: usually immediately unless there are several other requests
-   * currently being executed.
+   * Invokes the request immediately, and blocks until the response can be
+   * processed or is in error.
+   *
+   * <p>The caller may read the response body with the response's
+   * {@link Response#body} method.  To facilitate connection recycling, callers
+   * should always {@link Response.Body#close() close the response body}.
+   *
+   * <p>Note that transport-layer success (receiving a HTTP response code,
+   * headers and body) does not necessarily indicate application-layer success:
+   * {@code response} may still indicate an unhappy HTTP response code like 404
+   * or 500.
+   *
+   * @return null if the call was canceled.
+   *
+   * @throws IOException if the request could not be executed due to a
+   *     connectivity problem or timeout. Because networks can fail during an
+   *     exchange, it is possible that the remote server accepted the request
+   *     before the failure.
+   *
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  public Response execute() throws IOException {
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already Executed");
+      executed = true;
+    }
+    Response result = getResponse(); // Since we don't cancel, this won't be null.
+    engine.releaseConnection(); // Transfer ownership of the body to the caller.
+    return result;
+  }
+
+  /**
+   * Schedules the request to be executed at some point in the future.
+   *
+   * <p>The {@link OkHttpClient#getDispatcher dispatcher} defines when the
+   * request will run: usually immediately unless there are several other
+   * requests currently being executed.
    *
    * <p>This client will later call back {@code responseCallback} with either
    * an HTTP response or a failure exception. If you {@link #cancel} a request
    * before it completes the callback will not be invoked.
+   *
+   * @throws IllegalStateException when the call has already been executed.
    */
   public void execute(Response.Callback responseCallback) {
-    dispatcher.enqueue(client, request, responseCallback);
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already Executed");
+      executed = true;
+    }
+    dispatcher.enqueue(new AsyncCall(responseCallback));
   }
 
   /**
-   * Cancels the request, if possible. Requests that are already complete cannot
-   * be canceled.
+   * Cancels the request, if possible. Requests that are already complete
+   * cannot be canceled.
    */
   public void cancel() {
-    dispatcher.cancel(request.tag());
+    canceled = true;
+    if (engine != null) engine.disconnect();
+  }
+
+  final class AsyncCall extends NamedRunnable {
+    private final Response.Callback responseCallback;
+
+    private AsyncCall(Response.Callback responseCallback) {
+      super("OkHttp %s", request.urlString());
+      this.responseCallback = responseCallback;
+    }
+
+    String host() {
+      return request.url().getHost();
+    }
+
+    Request request() {
+      return request;
+    }
+
+    Object tag() {
+      return request.tag();
+    }
+
+    Call get() {
+      return Call.this;
+    }
+
+    @Override protected void execute() {
+      boolean signalledCallback = false;
+      try {
+        Response response = getResponse();
+        if (canceled) {
+          signalledCallback = true;
+          responseCallback.onFailure(new Failure.Builder()
+              .request(request)
+              .exception(new CancellationException("Canceled"))
+              .build());
+        } else {
+          signalledCallback = true;
+          responseCallback.onResponse(response);
+        }
+      } catch (IOException e) {
+        if (signalledCallback) return; // Do not signal the callback twice!
+        responseCallback.onFailure(new Failure.Builder()
+            .request(request)
+            .exception(e)
+            .build());
+      } finally {
+        engine.close(); // Close the connection if it isn't already.
+        dispatcher.finished(this);
+      }
+    }
+  }
+
+  /**
+   * Performs the request and returns the response. May return null if this
+   * call was canceled.
+   */
+  private Response getResponse() throws IOException {
+    Response redirectedBy = null;
+
+    // Copy body metadata to the appropriate request headers.
+    Request.Body body = request.body();
+    if (body != null) {
+      MediaType contentType = body.contentType();
+      if (contentType == null) throw new IllegalStateException("contentType == null");
+
+      Request.Builder requestBuilder = request.newBuilder();
+      requestBuilder.header("Content-Type", contentType.toString());
+
+      long contentLength = body.contentLength();
+      if (contentLength != -1) {
+        requestBuilder.header("Content-Length", Long.toString(contentLength));
+        requestBuilder.removeHeader("Transfer-Encoding");
+      } else {
+        requestBuilder.header("Transfer-Encoding", "chunked");
+        requestBuilder.removeHeader("Content-Length");
+      }
+
+      request = requestBuilder.build();
+    }
+
+    // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
+    engine = new HttpEngine(client, request, false, null, null, null);
+
+    while (true) {
+      if (canceled) return null;
+
+      try {
+        engine.sendRequest();
+
+        if (body != null) {
+          BufferedSink sink = engine.getBufferedRequestBody();
+          body.writeTo(sink);
+          sink.flush();
+        }
+
+        engine.readResponse();
+      } catch (IOException e) {
+        HttpEngine retryEngine = engine.recover(e, null);
+        if (retryEngine != null) {
+          engine = retryEngine;
+          continue;
+        }
+
+        // Give up; recovery is not possible.
+        throw e;
+      }
+
+      Response response = engine.getResponse();
+      Request followUp = engine.followUpRequest();
+
+      if (followUp == null) {
+        engine.releaseConnection();
+        return response.newBuilder()
+            .body(new RealResponseBody(response, engine.getResponseBody()))
+            .redirectedBy(redirectedBy)
+            .build();
+      }
+
+      if (engine.getResponse().isRedirect() && ++redirectionCount > MAX_REDIRECTS) {
+        throw new ProtocolException("Too many redirects: " + redirectionCount);
+      }
+
+      // TODO: drop from POST to GET when redirected? HttpURLConnection does.
+      // TODO: confirm that Cookies are not retained across hosts.
+
+      if (!engine.sameConnection(followUp)) {
+        engine.releaseConnection();
+      }
+
+      Connection connection = engine.close();
+      redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.
+      request = followUp;
+      engine = new HttpEngine(client, request, false, connection, null, null);
+    }
+  }
+
+  private static class RealResponseBody extends Response.Body {
+    private final Response response;
+    private final BufferedSource source;
+
+    RealResponseBody(Response response, BufferedSource source) {
+      this.response = response;
+      this.source = source;
+    }
+
+    @Override public MediaType contentType() {
+      String contentType = response.header("Content-Type");
+      return contentType != null ? MediaType.parse(contentType) : null;
+    }
+
+    @Override public long contentLength() {
+      return OkHeaders.contentLength(response);
+    }
+
+    @Override public BufferedSource source() {
+      return source;
+    }
   }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index 1c295bb..4569867 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.Call.AsyncCall;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import java.util.ArrayDeque;
@@ -28,22 +29,22 @@
 /**
  * Policy on when async requests are executed.
  *
- * <p>Each dispatcher uses an {@link ExecutorService} to run jobs internally. If you
+ * <p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you
  * supply your own executor, it should be able to run {@linkplain #getMaxRequests the
- * configured maximum} number of jobs concurrently.
+ * configured maximum} number of calls concurrently.
  */
 public final class Dispatcher {
   private int maxRequests = 64;
   private int maxRequestsPerHost = 5;
 
-  /** Executes jobs. Created lazily. */
+  /** Executes calls. Created lazily. */
   private ExecutorService executorService;
 
-  /** Ready jobs in the order they'll be run. */
-  private final Deque<Job> readyJobs = new ArrayDeque<Job>();
+  /** Ready calls in the order they'll be run. */
+  private final Deque<AsyncCall> readyCalls = new ArrayDeque<AsyncCall>();
 
-  /** Running jobs. Includes canceled jobs that haven't finished yet. */
-  private final Deque<Job> runningJobs = new ArrayDeque<Job>();
+  /** Running calls. Includes canceled calls that haven't finished yet. */
+  private final Deque<AsyncCall> runningCalls = new ArrayDeque<AsyncCall>();
 
   public Dispatcher(ExecutorService executorService) {
     this.executorService = executorService;
@@ -62,7 +63,7 @@
 
   /**
    * Set the maximum number of requests to execute concurrently. Above this
-   * requests queue in memory, waiting for the running jobs to complete.
+   * requests queue in memory, waiting for the running calls to complete.
    *
    * <p>If more than {@code maxRequests} requests are in flight when this is
    * invoked, those requests will remain in flight.
@@ -72,7 +73,7 @@
       throw new IllegalArgumentException("max < 1: " + maxRequests);
     }
     this.maxRequests = maxRequests;
-    promoteJobs();
+    promoteCalls();
   }
 
   public synchronized int getMaxRequests() {
@@ -93,70 +94,65 @@
       throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
     }
     this.maxRequestsPerHost = maxRequestsPerHost;
-    promoteJobs();
+    promoteCalls();
   }
 
   public synchronized int getMaxRequestsPerHost() {
     return maxRequestsPerHost;
   }
 
-  synchronized void enqueue(OkHttpClient client, Request request, Response.Callback callback) {
-    // Copy the client. Otherwise changes (socket factory, redirect policy,
-    // etc.) may incorrectly be reflected in the request when it is executed.
-    client = client.copyWithDefaults();
-    Job job = new Job(this, client, request, callback);
-
-    if (runningJobs.size() < maxRequests && runningJobsForHost(job) < maxRequestsPerHost) {
-      runningJobs.add(job);
-      getExecutorService().execute(job);
+  synchronized void enqueue(AsyncCall call) {
+    if (runningCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
+      runningCalls.add(call);
+      getExecutorService().execute(call);
     } else {
-      readyJobs.add(job);
+      readyCalls.add(call);
     }
   }
 
-  /** Cancel all jobs with the tag {@code tag}. */
+  /** Cancel all calls with the tag {@code tag}. */
   public synchronized void cancel(Object tag) {
-    for (Iterator<Job> i = readyJobs.iterator(); i.hasNext(); ) {
+    for (Iterator<AsyncCall> i = readyCalls.iterator(); i.hasNext(); ) {
       if (Util.equal(tag, i.next().tag())) i.remove();
     }
 
-    for (Job job : runningJobs) {
-      if (Util.equal(tag, job.tag())) {
-        job.canceled = true;
-        HttpEngine engine = job.engine;
+    for (AsyncCall call : runningCalls) {
+      if (Util.equal(tag, call.tag())) {
+        call.get().canceled = true;
+        HttpEngine engine = call.get().engine;
         if (engine != null) engine.disconnect();
       }
     }
   }
 
-  /** Used by {@code Job#run} to signal completion. */
-  synchronized void finished(Job job) {
-    if (!runningJobs.remove(job)) throw new AssertionError("Job wasn't running!");
-    promoteJobs();
+  /** Used by {@code AsyncCall#run} to signal completion. */
+  synchronized void finished(AsyncCall call) {
+    if (!runningCalls.remove(call)) throw new AssertionError("AsyncCall wasn't running!");
+    promoteCalls();
   }
 
-  private void promoteJobs() {
-    if (runningJobs.size() >= maxRequests) return; // Already running max capacity.
-    if (readyJobs.isEmpty()) return; // No ready jobs to promote.
+  private void promoteCalls() {
+    if (runningCalls.size() >= maxRequests) return; // Already running max capacity.
+    if (readyCalls.isEmpty()) return; // No ready calls to promote.
 
-    for (Iterator<Job> i = readyJobs.iterator(); i.hasNext(); ) {
-      Job job = i.next();
+    for (Iterator<AsyncCall> i = readyCalls.iterator(); i.hasNext(); ) {
+      AsyncCall call = i.next();
 
-      if (runningJobsForHost(job) < maxRequestsPerHost) {
+      if (runningCallsForHost(call) < maxRequestsPerHost) {
         i.remove();
-        runningJobs.add(job);
-        getExecutorService().execute(job);
+        runningCalls.add(call);
+        getExecutorService().execute(call);
       }
 
-      if (runningJobs.size() >= maxRequests) return; // Reached max capacity.
+      if (runningCalls.size() >= maxRequests) return; // Reached max capacity.
     }
   }
 
-  /** Returns the number of running jobs that share a host with {@code job}. */
-  private int runningJobsForHost(Job job) {
+  /** Returns the number of running calls that share a host with {@code call}. */
+  private int runningCallsForHost(AsyncCall call) {
     int result = 0;
-    for (Job j : runningJobs) {
-      if (j.host().equals(job.host())) result++;
+    for (AsyncCall c : runningCalls) {
+      if (c.host().equals(call.host())) result++;
     }
     return result;
   }
/Fim/
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index 9cd255f..54c6196 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -21,7 +21,6 @@
 import com.squareup.okhttp.internal.huc.HttpsURLConnectionImpl;
 import com.squareup.okhttp.internal.huc.ResponseCacheAdapter;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
-import java.io.IOException;
 import java.net.CookieHandler;
 import java.net.HttpURLConnection;
 import java.net.Proxy;
@@ -353,38 +352,13 @@
   }
 
   /**
-   * Invokes {@code request} immediately, and blocks until the response can be
-   * processed or is in error.
-   *
-   * <p>The caller may read the response body with the response's
-   * {@link Response#body} method.  To facilitate connection recycling, callers
-   * should always {@link Response.Body#close() close the response body}.
-   *
-   * <p>Note that transport-layer success (receiving a HTTP response code,
-   * headers and body) does not necessarily indicate application-layer
-   * success: {@code response} may still indicate an unhappy HTTP response
-   * code like 404 or 500.
-   *
-   * @throws IOException if the request could not be executed due to a
-   *     connectivity problem or timeout. Because networks can fail during an
-   *     exchange, it is possible that the remote server accepted the request
-   *     before the failure.
+   * Prepares the {@code request} to be executed at some point in the future.
    */
-  public Response execute(Request request) throws IOException {
+  public Call newCall(Request request) {
     // Copy the client. Otherwise changes (socket factory, redirect policy,
     // etc.) may incorrectly be reflected in the request when it is executed.
     OkHttpClient client = copyWithDefaults();
-    Job job = new Job(dispatcher, client, request, null);
-    Response result = job.getResponse(); // Since we don't cancel, this won't be null.
-    job.engine.releaseConnection(); // Transfer ownership of the body to the caller.
-    return result;
-  }
-
-  /**
-   * Prepares the {@code request} to be executed at some point in the future.
-   */
-  public Call call(Request request) {
-    return new Call(this, dispatcher, request);
+    return new Call(client, dispatcher, request);
   }
 
   /**
/Fim/
diff --git a/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java b/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
index 0508be9..3059629 100644
--- a/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
+++ b/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
@@ -80,7 +80,7 @@
     Request request = new Request.Builder()
         .url(url)
         .build();
-    Response response = client.execute(request);
+    Response response = client.newCall(request).execute();
     String responseSource = response.header(OkHeaders.RESPONSE_SOURCE);
     int responseCode = response.code();
 
/Fim/
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java b/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java
index 3283446..25f9c86 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java
+++ b/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java
@@ -13,7 +13,7 @@
         .url("https://raw.github.com/square/okhttp/master/README.md")
         .build();
 
-    Response response = client.execute(request);
+    Response response = client.newCall(request).execute();
     System.out.println(response.body().string());
   }
 
/Fim/
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java b/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java
index d4defb4..68ac4e0 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java
+++ b/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java
@@ -17,7 +17,7 @@
         .method("POST", body)
         .build();
 
-    Response response = client.execute(request);
+    Response response = client.newCall(request).execute();
     System.out.println(response.body().string());
   }
 
/Fim/
diff --git a/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java b/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
index 29fd1b0..e616d41 100644
--- a/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
+++ b/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
@@ -31,7 +31,7 @@
         .build();
 
     // Execute the request and retrieve the response.
-    Response response = client.execute(request);
+    Response response = client.newCall(request).execute();
 
     // Deserialize HTTP response to concrete type.
     Reader body = response.body().charStream();
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
index dc66d6f..26b6682 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
@@ -29,6 +29,7 @@
 import java.util.Arrays;
 import java.util.UUID;
 import java.util.concurrent.Callable;
+import java.util.concurrent.CancellationException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -619,7 +620,11 @@
     Call call = client.newCall(new Request.Builder().url(server.getUrl("/a")).build());
     call.cancel();
 
-    assertNull(call.execute());
+    try {
+      call.execute();
+      fail();
+    } catch (CancellationException e){
+    }
     assertEquals(0, server.getRequestCount());
   }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/com/squareup/okhttp/Call.java
index 429e122..a55fb4b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Call.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java
@@ -63,7 +63,7 @@
    * {@code response} may still indicate an unhappy HTTP response code like 404
    * or 500.
    *
-   * @return null if the call was canceled.
+   * @throws CancellationException if the call was canceled.
    *
    * @throws IOException if the request could not be executed due to a
    *     connectivity problem or timeout. Because networks can fail during an
@@ -77,8 +77,9 @@
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
     }
-    Response result = getResponse(); // Since we don't cancel, this won't be null.
+    Response result = getResponse();
     engine.releaseConnection(); // Transfer ownership of the body to the caller.
+    if (result == null) throw new CancellationException("Cancelled");
     return result;
   }
 
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
index c44f386..940f350 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
@@ -25,8 +25,12 @@
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import java.net.CookieManager;
+import java.net.HttpCookie;
 import java.net.HttpURLConnection;
 import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
 import java.util.UUID;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
@@ -41,6 +45,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
@@ -622,6 +627,61 @@
     assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
   }
 
+  @Test public void postRedirectsToGet() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /page2")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("Page 2"));
+    server.play();
+
+    Response response = client.newCall(new Request.Builder()
+        .url(server.getUrl("/page1"))
+        .post(Request.Body.create(MediaType.parse("text/plain"), "Request Body"))
+        .build()).execute();
+    assertEquals("Page 2", response.body().string());
+
+    RecordedRequest page1 = server.takeRequest();
+    assertEquals("POST /page1 HTTP/1.1", page1.getRequestLine());
+    assertEquals("Request Body", page1.getUtf8Body());
+
+    RecordedRequest page2 = server.takeRequest();
+    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
+  }
+
+  @Test public void redirectsDoNotIncludeTooManyCookies() throws Exception {
+    MockWebServer redirectTarget = new MockWebServer();
+    redirectTarget.enqueue(new MockResponse().setBody("Page 2"));
+    redirectTarget.play();
+
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + redirectTarget.getUrl("/")));
+    server.play();
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    HttpCookie cookie = new HttpCookie("c", "cookie");
+    cookie.setDomain(server.getCookieDomain());
+    cookie.setPath("/");
+    String portList = Integer.toString(server.getPort());
+    cookie.setPortlist(portList);
+    cookieManager.getCookieStore().add(server.getUrl("/").toURI(), cookie);
+    client.setCookieHandler(cookieManager);
+
+    Response response = client.newCall(new Request.Builder()
+        .url(server.getUrl("/page1"))
+        .build()).execute();
+    assertEquals("Page 2", response.body().string());
+
+    RecordedRequest request1 = server.takeRequest();
+    assertContains(request1.getHeaders(), "Cookie: $Version=\"1\"; "
+        + "c=\"cookie\";$Path=\"/\";$Domain=\"" + server.getCookieDomain()
+        + "\";$Port=\"" + portList + "\"");
+
+    RecordedRequest request2 = redirectTarget.takeRequest();
+    assertContainsNoneMatching(request2.getHeaders(), "Cookie.*");
+  }
+
   @Test public void redirect_Async() throws Exception {
     server.enqueue(new MockResponse()
         .setResponseCode(301)
@@ -886,4 +946,19 @@
     server.setNpnEnabled(true);
     server.setNpnProtocols(client.getProtocols());
   }
+
+  private void assertContains(Collection<String> collection, String element) {
+    for (String c : collection) {
+      if (c != null && c.equalsIgnoreCase(element)) return;
+    }
+    fail("No " + element + " in " + collection);
+  }
+
+  private void assertContainsNoneMatching(List<String> headers, String pattern) {
+    for (String header : headers) {
+      if (header.matches(pattern)) {
+        fail("Header " + header + " matches " + pattern);
+      }
+    }
+  }
 }
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index 2cc11f0..e671ba1 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -19,11 +19,8 @@
 import com.squareup.okhttp.ConnectionPool;
 import com.squareup.okhttp.Credentials;
 import com.squareup.okhttp.HttpResponseCache;
-import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.RecordingAuthenticator;
 import com.squareup.okhttp.internal.RecordingHostnameVerifier;
 import com.squareup.okhttp.internal.RecordingOkAuthenticator;
@@ -1925,9 +1922,9 @@
 
     RecordedRequest page2 = server.takeRequest();
     assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
-    assertContainsNoneMatching(page2.getHeaders(), "Content-Length");
-    assertContains(page2.getHeaders(), "Content-Type: text/plain; charset=utf-8");
-    assertContains(page2.getHeaders(), "Transfer-Encoding: identity");
+    assertContainsNoneMatching(page2.getHeaders(), "Content-Length.*");
+    assertContainsNoneMatching(page2.getHeaders(), "Content-Type.*");
+    assertContainsNoneMatching(page2.getHeaders(), "Transfer-Encoding.*");
   }
 
   @Test public void response305UseProxy() throws Exception {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/com/squareup/okhttp/Call.java
index 3eba08f..042f32b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Call.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java
@@ -204,10 +204,9 @@
       try {
         engine.sendRequest();
 
-        if (body != null) {
+        if (request.body() != null) {
           BufferedSink sink = engine.getBufferedRequestBody();
-          body.writeTo(sink);
-          sink.flush();
+          request.body().writeTo(sink);
         }
 
         engine.readResponse();
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index f5579b3..6bc9e4d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -802,7 +802,16 @@
         boolean sameProtocol = url.getProtocol().equals(request.url().getProtocol());
         if (!sameProtocol && !client.getFollowSslRedirects()) return null;
 
-        return request.newBuilder().url(url).build();
+        // Redirects don't include a request body.
+        Request.Builder requestBuilder = originalRequest.newBuilder();
+        if (HttpMethod.hasRequestBody(originalRequest.method())) {
+          requestBuilder.method("GET", null);
+          requestBuilder.removeHeader("Transfer-Encoding");
+          requestBuilder.removeHeader("Content-Length");
+          requestBuilder.removeHeader("Content-Type");
+        }
+
+        return requestBuilder.url(url).build();
 
       default:
         return null;
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java b/okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
index cd04354..19b0b1f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
@@ -340,25 +340,14 @@
       }
 
       // The first request was insufficient. Prepare for another...
-      if (response.isRedirect()) {
-        url = followUp.url(); // Get the redirected URL.
-      } else {
-        requestHeaders = followUp.headers().newBuilder(); // Get the follow-up's credentials!
-      }
+      url = followUp.url();
+      requestHeaders = followUp.headers().newBuilder();
 
-      String retryMethod = method;
+      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect
+      // should keep the same method, Chrome, Firefox and the RI all issue GETs
+      // when following any redirect.
       Sink requestBody = httpEngine.getRequestBody();
-
-      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM
-      // redirect should keep the same method, Chrome, Firefox and the
-      // RI all issue GETs when following any redirect.
-      int responseCode = response.code();
-      if (responseCode == HTTP_MULT_CHOICE
-          || responseCode == HTTP_MOVED_PERM
-          || responseCode == HTTP_MOVED_TEMP
-          || responseCode == HTTP_SEE_OTHER) {
-        retryMethod = "GET";
-        requestHeaders.removeAll("Content-Length");
+      if (!followUp.method().equals(method)) {
         requestBody = null;
       }
 
@@ -371,7 +360,7 @@
       }
 
       Connection connection = httpEngine.close();
-      httpEngine = newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);
+      httpEngine = newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody);
     }
   }
 
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java
index 0ec7499..05c94cf 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java
@@ -15,12 +15,10 @@
  */
 package com.squareup.okhttp.mockwebserver.rule;
 
-import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.IOException;
-import java.net.ServerSocket;
 import java.net.URL;
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -35,12 +33,14 @@
 public class MockWebServerRule extends ExternalResource {
   private static final Logger logger = Logger.getLogger(MockWebServerRule.class.getName());
 
-  private final int port = pickPort();
   private final MockWebServer server = new MockWebServer();
+  private boolean started;
 
   @Override protected void before() {
+    if (started) return;
+    started = true;
     try {
-      server.play(port);
+      server.play();
     } catch (IOException e) {
       throw new RuntimeException(e);
     }
@@ -55,7 +55,8 @@
   }
 
   public int getPort() {
-    return port;
+    if (!started) before();
+    return server.getPort();
   }
 
   public int getRequestCount() {
@@ -78,16 +79,4 @@
   public MockWebServer get() {
     return server;
   }
-
-  private static int pickPort() {
-    ServerSocket socket = null;
-    try {
-      socket = new ServerSocket(0);
-      return socket.getLocalPort();
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    } finally {
-      Util.closeQuietly(socket);
-    }
-  }
 }
/Fim/
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java
index b43e5bf..ebf69f4 100644
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java
+++ b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java
@@ -40,18 +40,8 @@
     server.after();
   }
 
-  @Test public void whenRuleCreatedPortIsAvailableAndServerNotYetPlayed() throws IOException {
+  @Test public void whenRuleCreatedPortIsAvailable() throws IOException {
     assertTrue(server.getPort() > 0);
-
-    try {
-      server.get().getPort();
-      fail();
-    } catch (IllegalStateException e) {
-
-    }
-
-    // Verify the port is available.
-    new ServerSocket(server.getPort()).close();
   }
 
   @Test public void differentRulesGetDifferentPorts() throws IOException {
/Fim/
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
index 996a37f..31d57ef 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
@@ -84,7 +84,7 @@
 
   @Override public void enqueue(URL url) throws Exception {
     requestsInFlight.incrementAndGet();
-    client.newCall(new Request.Builder().tag(System.nanoTime()).url(url).build()).execute(callback);
+    client.newCall(new Request.Builder().tag(System.nanoTime()).url(url).build()).enqueue(callback);
   }
 
   @Override public synchronized boolean acceptingJobs() {
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
index 1add776..5f273df 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
@@ -304,7 +304,7 @@
     }
 
     try {
-      call.execute(callback);
+      call.enqueue(callback);
       fail();
     } catch (IllegalStateException e){
       assertEquals("Already Executed", e.getMessage());
@@ -325,7 +325,7 @@
         .build();
 
     Call call = client.newCall(request);
-    call.execute(callback);
+    call.enqueue(callback);
 
     try {
       call.execute();
@@ -335,7 +335,7 @@
     }
 
     try {
-      call.execute(callback);
+      call.enqueue(callback);
       fail();
     } catch (IllegalStateException e){
       assertEquals("Already Executed", e.getMessage());
@@ -354,7 +354,7 @@
         .url(server.getUrl("/"))
         .header("User-Agent", "AsyncApiTest")
         .build();
-    client.newCall(request).execute(callback);
+    client.newCall(request).enqueue(callback);
 
     callback.await(request.url())
         .assertCode(200)
@@ -390,13 +390,13 @@
     server.enqueue(new MockResponse().setBody("ghi"));
     server.play();
 
-    client.newCall(new Request.Builder().url(server.getUrl("/a")).build()).execute(callback);
+    client.newCall(new Request.Builder().url(server.getUrl("/a")).build()).enqueue(callback);
     callback.await(server.getUrl("/a")).assertBody("abc");
 
-    client.newCall(new Request.Builder().url(server.getUrl("/b")).build()).execute(callback);
+    client.newCall(new Request.Builder().url(server.getUrl("/b")).build()).enqueue(callback);
     callback.await(server.getUrl("/b")).assertBody("def");
 
-    client.newCall(new Request.Builder().url(server.getUrl("/c")).build()).execute(callback);
+    client.newCall(new Request.Builder().url(server.getUrl("/c")).build()).enqueue(callback);
     callback.await(server.getUrl("/c")).assertBody("ghi");
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
@@ -410,7 +410,7 @@
     server.play();
 
     Request request = new Request.Builder().url(server.getUrl("/a")).build();
-    client.newCall(request).execute(new Response.Callback() {
+    client.newCall(request).enqueue(new Response.Callback() {
       @Override public void onFailure(Failure failure) {
         throw new AssertionError();
       }
@@ -422,7 +422,7 @@
         assertEquals('c', bytes.read());
 
         // This request will share a connection with 'A' cause it's all done.
-        client.newCall(new Request.Builder().url(server.getUrl("/b")).build()).execute(callback);
+        client.newCall(new Request.Builder().url(server.getUrl("/b")).build()).enqueue(callback);
       }
     });
 
@@ -487,7 +487,7 @@
     Request request = new Request.Builder()
         .url(server.getUrl("/"))
         .build();
-    client.newCall(request).execute(callback);
+    client.newCall(request).enqueue(callback);
 
     callback.await(request.url()).assertHandshake();
   }
@@ -517,7 +517,7 @@
     Request request = new Request.Builder()
         .url(server.getUrl("/"))
         .build();
-    client.newCall(request).execute(callback);
+    client.newCall(request).enqueue(callback);
 
     callback.await(request.url()).assertBody("abc");
   }
@@ -546,7 +546,7 @@
         .url(server.getUrl("/"))
         .post(Request.Body.create(MediaType.parse("text/plain"), "def"))
         .build();
-    client.newCall(request).execute(callback);
+    client.newCall(request).enqueue(callback);
 
     callback.await(request.url())
         .assertCode(200)
@@ -618,14 +618,14 @@
     Request request1 = new Request.Builder()
         .url(server.getUrl("/"))
         .build();
-    client.newCall(request1).execute(callback);
+    client.newCall(request1).enqueue(callback);
     callback.await(request1.url()).assertCode(200).assertBody("A");
     assertNull(server.takeRequest().getHeader("If-None-Match"));
 
     Request request2 = new Request.Builder()
         .url(server.getUrl("/"))
         .build();
-    client.newCall(request2).execute(callback);
+    client.newCall(request2).enqueue(callback);
     callback.await(request2.url()).assertCode(200).assertBody("A");
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
   }
@@ -656,14 +656,14 @@
     Request request1 = new Request.Builder()
         .url(server.getUrl("/"))
         .build();
-    client.newCall(request1).execute(callback);
+    client.newCall(request1).enqueue(callback);
     callback.await(request1.url()).assertCode(200).assertBody("A");
     assertNull(server.takeRequest().getHeader("If-None-Match"));
 
     Request request2 = new Request.Builder()
         .url(server.getUrl("/"))
         .build();
-    client.newCall(request2).execute(callback);
+    client.newCall(request2).enqueue(callback);
     callback.await(request2.url()).assertCode(200).assertBody("B");
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
   }
@@ -767,7 +767,7 @@
     server.play();
 
     Request request = new Request.Builder().url(server.getUrl("/a")).build();
-    client.newCall(request).execute(callback);
+    client.newCall(request).enqueue(callback);
 
     callback.await(server.getUrl("/c"))
         .assertCode(200)
@@ -810,7 +810,7 @@
     server.play();
 
     Request request = new Request.Builder().url(server.getUrl("/0")).build();
-    client.newCall(request).execute(callback);
+    client.newCall(request).enqueue(callback);
     callback.await(server.getUrl("/20"))
         .assertCode(200)
         .assertBody("Success!");
@@ -843,7 +843,7 @@
     server.play();
 
     Request request = new Request.Builder().url(server.getUrl("/0")).build();
-    client.newCall(request).execute(callback);
+    client.newCall(request).enqueue(callback);
     callback.await(server.getUrl("/20")).assertFailure("Too many redirects: 21");
   }
 
@@ -901,11 +901,11 @@
     server.play();
 
     Request requestA = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
-    client.newCall(requestA).execute(callback);
+    client.newCall(requestA).enqueue(callback);
     assertEquals("/a", server.takeRequest().getPath());
 
     Request requestB = new Request.Builder().url(server.getUrl("/b")).tag("request B").build();
-    client.newCall(requestB).execute(callback);
+    client.newCall(requestB).enqueue(callback);
     assertEquals("/b", server.takeRequest().getPath());
 
     callback.await(requestA.url()).assertBody("A");
@@ -933,7 +933,7 @@
     server.play();
 
     Request requestA = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
-    client.newCall(requestA).execute(callback);
+    client.newCall(requestA).enqueue(callback);
     assertEquals("/a", server.takeRequest().getPath());
 
     callback.await(requestA.url()).assertFailure("Canceled");
@@ -963,7 +963,7 @@
 
     Request request = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
     final Call call = client.newCall(request);
-    call.execute(new Response.Callback() {
+    call.enqueue(new Response.Callback() {
       @Override public void onFailure(Failure failure) {
         latch.countDown();
         failureRef.set(failure); // This should never occur as we don't signal twice.
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
index 8e01880..59e35e2 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
@@ -41,53 +41,53 @@
   }
 
   @Test public void enqueuedJobsRunImmediately() throws Exception {
-    client.newCall(newRequest("http://a/1")).execute(callback);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
     executor.assertJobs("http://a/1");
   }
 
   @Test public void maxRequestsEnforced() throws Exception {
     dispatcher.setMaxRequests(3);
-    client.newCall(newRequest("http://a/1")).execute(callback);
-    client.newCall(newRequest("http://a/2")).execute(callback);
-    client.newCall(newRequest("http://b/1")).execute(callback);
-    client.newCall(newRequest("http://b/2")).execute(callback);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/2")).enqueue(callback);
     executor.assertJobs("http://a/1", "http://a/2", "http://b/1");
   }
 
   @Test public void maxPerHostEnforced() throws Exception {
     dispatcher.setMaxRequestsPerHost(2);
-    client.newCall(newRequest("http://a/1")).execute(callback);
-    client.newCall(newRequest("http://a/2")).execute(callback);
-    client.newCall(newRequest("http://a/3")).execute(callback);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    client.newCall(newRequest("http://a/3")).enqueue(callback);
     executor.assertJobs("http://a/1", "http://a/2");
   }
 
   @Test public void increasingMaxRequestsPromotesJobsImmediately() throws Exception {
     dispatcher.setMaxRequests(2);
-    client.newCall(newRequest("http://a/1")).execute(callback);
-    client.newCall(newRequest("http://b/1")).execute(callback);
-    client.newCall(newRequest("http://c/1")).execute(callback);
-    client.newCall(newRequest("http://a/2")).execute(callback);
-    client.newCall(newRequest("http://b/2")).execute(callback);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    client.newCall(newRequest("http://c/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    client.newCall(newRequest("http://b/2")).enqueue(callback);
     dispatcher.setMaxRequests(4);
     executor.assertJobs("http://a/1", "http://b/1", "http://c/1", "http://a/2");
   }
 
   @Test public void increasingMaxPerHostPromotesJobsImmediately() throws Exception {
     dispatcher.setMaxRequestsPerHost(2);
-    client.newCall(newRequest("http://a/1")).execute(callback);
-    client.newCall(newRequest("http://a/2")).execute(callback);
-    client.newCall(newRequest("http://a/3")).execute(callback);
-    client.newCall(newRequest("http://a/4")).execute(callback);
-    client.newCall(newRequest("http://a/5")).execute(callback);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    client.newCall(newRequest("http://a/3")).enqueue(callback);
+    client.newCall(newRequest("http://a/4")).enqueue(callback);
+    client.newCall(newRequest("http://a/5")).enqueue(callback);
     dispatcher.setMaxRequestsPerHost(4);
     executor.assertJobs("http://a/1", "http://a/2", "http://a/3", "http://a/4");
   }
 
   @Test public void oldJobFinishesNewJobCanRunDifferentHost() throws Exception {
     dispatcher.setMaxRequests(1);
-    client.newCall(newRequest("http://a/1")).execute(callback);
-    client.newCall(newRequest("http://b/1")).execute(callback);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
     executor.finishJob("http://a/1");
     executor.assertJobs("http://b/1");
   }
@@ -95,27 +95,27 @@
   @Test public void oldJobFinishesNewJobWithSameHostStarts() throws Exception {
     dispatcher.setMaxRequests(2);
     dispatcher.setMaxRequestsPerHost(1);
-    client.newCall(newRequest("http://a/1")).execute(callback);
-    client.newCall(newRequest("http://b/1")).execute(callback);
-    client.newCall(newRequest("http://b/2")).execute(callback);
-    client.newCall(newRequest("http://a/2")).execute(callback);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/2")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
     executor.finishJob("http://a/1");
     executor.assertJobs("http://b/1", "http://a/2");
   }
 
   @Test public void oldJobFinishesNewJobCantRunDueToHostLimit() throws Exception {
     dispatcher.setMaxRequestsPerHost(1);
-    client.newCall(newRequest("http://a/1")).execute(callback);
-    client.newCall(newRequest("http://b/1")).execute(callback);
-    client.newCall(newRequest("http://a/2")).execute(callback);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
     executor.finishJob("http://b/1");
     executor.assertJobs("http://a/1");
   }
 
   @Test public void cancelingReadyJobPreventsItFromStarting() throws Exception {
     dispatcher.setMaxRequestsPerHost(1);
-    client.newCall(newRequest("http://a/1")).execute(callback);
-    client.newCall(newRequest("http://a/2", "tag1")).execute(callback);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2", "tag1")).enqueue(callback);
     dispatcher.cancel("tag1");
     executor.finishJob("http://a/1");
     executor.assertJobs();
@@ -123,8 +123,8 @@
 
   @Test public void cancelingRunningJobTakesNoEffectUntilJobFinishes() throws Exception {
     dispatcher.setMaxRequests(1);
-    client.newCall(newRequest("http://a/1", "tag1")).execute(callback);
-    client.newCall(newRequest("http://a/2")).execute(callback);
+    client.newCall(newRequest("http://a/1", "tag1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
     dispatcher.cancel("tag1");
     executor.assertJobs("http://a/1");
     executor.finishJob("http://a/1");
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/com/squareup/okhttp/Call.java
index 042f32b..b34e2f9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Call.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java
@@ -96,7 +96,7 @@
    *
    * @throws IllegalStateException when the call has already been executed.
    */
-  public void execute(Response.Callback responseCallback) {
+  public void enqueue(Response.Callback responseCallback) {
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index ceb149e..33f8124 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -331,7 +331,7 @@
       readAscii(connection.getInputStream(), Integer.MAX_VALUE);
       fail("Should have timed out!");
     } catch (IOException e){
-      assertEquals("Read timed out", e.getMessage());
+      assertEquals("timeout", e.getMessage());
     }
   }
 
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index 07eb1cb..e00d824 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -28,6 +28,7 @@
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.Okio;
+import okio.Sink;
 import okio.Source;
 import org.junit.After;
 import org.junit.Test;
@@ -978,33 +979,94 @@
     assertEquals(-1, ping.roundTripTime());
   }
 
-  @Test public void readTimeoutExpires() throws Exception {
+  @Test public void getResponseHeadersTimesOut() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // RST_STREAM
     peer.play();
 
     // play it back
     SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    stream.setReadTimeout(1000);
+    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    long startNanos = System.nanoTime();
+    try {
+      stream.getResponseHeaders();
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void readTimesOut() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
     Source source = stream.getSource();
     long startNanos = System.nanoTime();
     try {
       source.read(new Buffer(), 1);
       fail();
-    } catch (IOException expected) {
+    } catch (InterruptedIOException expected) {
     }
     long elapsedNanos = System.nanoTime() - startNanos;
-    assertEquals(1000d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(1, connection.openStreamCount());
-    connection.ping().roundTripTime(); // Prevent the peer from exiting prematurely.
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void writeTimesOutAwaitingStreamWindow() throws Exception {
+    // Set the peer's receive window to 5 bytes!
+    Settings peerSettings = new Settings().set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 5);
+
+    // write the mocking script
+    peer.sendFrame().settings(peerSettings);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, SPDY3);
+    connection.ping().roundTripTime(); // Make sure settings have been received.
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    Sink sink = stream.getSink();
+    sink.write(new Buffer().writeUtf8("abcde"), 5);
+    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    long startNanos = System.nanoTime();
+    try {
+      sink.write(new Buffer().writeUtf8("f"), 1); // This will time out waiting on the write window.
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_PING, peer.takeFrame().type);
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_DATA, peer.takeFrame().type);
+    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
   }
 
   @Test public void headers() throws Exception {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 426b6a4..07713ec 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -34,6 +34,7 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;
+import java.util.concurrent.TimeUnit;
 import okio.Buffer;
 import okio.ByteString;
 import okio.Sink;
@@ -93,7 +94,7 @@
     stream = spdyConnection.newStream(
         writeNameValueBlock(request, spdyConnection.getProtocol(), version), hasRequestBody,
         hasResponseBody);
-    stream.setReadTimeout(httpEngine.client.getReadTimeout());
+    stream.readTimeout().timeout(httpEngine.client.getReadTimeout(), TimeUnit.MILLISECONDS);
   }
 
   @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
@@ -308,18 +309,15 @@
     }
 
     private boolean discardStream() {
+      long oldTimeoutNanos = stream.readTimeout().timeoutNanos();
+      stream.readTimeout().timeout(DISCARD_STREAM_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
       try {
-        long socketTimeout = stream.getReadTimeoutMillis();
-        stream.setReadTimeout(socketTimeout);
-        stream.setReadTimeout(DISCARD_STREAM_TIMEOUT_MILLIS);
-        try {
-          Util.skipAll(this, DISCARD_STREAM_TIMEOUT_MILLIS);
-          return true;
-        } finally {
-          stream.setReadTimeout(socketTimeout);
-        }
+        Util.skipAll(this, DISCARD_STREAM_TIMEOUT_MILLIS);
+        return true;
       } catch (IOException e) {
         return false;
+      } finally {
+        stream.readTimeout().timeout(oldTimeoutNanos, TimeUnit.NANOSECONDS);
       }
     }
   }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index ea06d46..e4aae61 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -19,9 +19,9 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.InterruptedIOException;
-import java.net.SocketTimeoutException;
 import java.util.ArrayList;
 import java.util.List;
+import okio.AsyncTimeout;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.Sink;
@@ -54,7 +54,6 @@
   private final int id;
   private final SpdyConnection connection;
   private final int priority;
-  private long readTimeoutMillis = 0;
 
   /** Headers sent by the stream initiator. Immutable and non null. */
   private final List<Header> requestHeaders;
@@ -64,6 +63,8 @@
 
   private final SpdyDataSource source;
   final SpdyDataSink sink;
+  private final SpdyTimeout readTimeout = new SpdyTimeout();
+  private final SpdyTimeout writeTimeout = new SpdyTimeout();
 
   /**
    * The reason why this stream was abnormally closed. If there are multiple
@@ -134,33 +135,16 @@
    * have not been received yet.
    */
   public synchronized List<Header> getResponseHeaders() throws IOException {
-    long remaining = 0;
-    long start = 0;
-    if (readTimeoutMillis != 0) {
-      start = (System.nanoTime() / 1000000);
-      remaining = readTimeoutMillis;
-    }
+    readTimeout.enter();
     try {
       while (responseHeaders == null && errorCode == null) {
-        if (readTimeoutMillis == 0) { // No timeout configured.
-          wait();
-        } else if (remaining > 0) {
-          wait(remaining);
-          remaining = start + readTimeoutMillis - (System.nanoTime() / 1000000);
-        } else {
-          throw new SocketTimeoutException("Read response header timeout. readTimeoutMillis: "
-                            + readTimeoutMillis);
-        }
+        waitForIo();
       }
-      if (responseHeaders != null) {
-        return responseHeaders;
-      }
-      throw new IOException("stream was reset: " + errorCode);
-    } catch (InterruptedException e) {
-      InterruptedIOException rethrow = new InterruptedIOException();
-      rethrow.initCause(e);
-      throw rethrow;
+    } finally {
+      readTimeout.exitAndThrowIfTimedOut();
     }
+    if (responseHeaders != null) return responseHeaders;
+    throw new IOException("stream was reset: " + errorCode);
   }
 
   /**
@@ -200,16 +184,12 @@
     }
   }
 
-  /**
-   * Sets the maximum time to wait on input stream reads before failing with a
-   * {@code SocketTimeoutException}, or {@code 0} to wait indefinitely.
-   */
-  public void setReadTimeout(long readTimeoutMillis) {
-    this.readTimeoutMillis = readTimeoutMillis;
+  public Timeout readTimeout() {
+    return readTimeout;
   }
 
-  public long getReadTimeoutMillis() {
-    return readTimeoutMillis;
+  public Timeout writeTimeout() {
+    return writeTimeout;
   }
 
   /** Returns a source that reads data from the peer. */
@@ -394,31 +374,15 @@
       return read;
     }
 
-    /**
-     * Returns once the input stream is either readable or finished. Throws
-     * a {@link SocketTimeoutException} if the read timeout elapses before
-     * that happens.
-     */
+    /** Returns once the source is either readable or finished. */
     private void waitUntilReadable() throws IOException {
-      long start = 0;
-      long remaining = 0;
-      if (readTimeoutMillis != 0) {
-        start = (System.nanoTime() / 1000000);
-        remaining = readTimeoutMillis;
-      }
+      readTimeout.enter();
       try {
         while (readBuffer.size() == 0 && !finished && !closed && errorCode == null) {
-          if (readTimeoutMillis == 0) {
-            SpdyStream.this.wait();
-          } else if (remaining > 0) {
-            SpdyStream.this.wait(remaining);
-            remaining = start + readTimeoutMillis - (System.nanoTime() / 1000000);
-          } else {
-            throw new SocketTimeoutException("Read timed out");
-          }
+          waitForIo();
         }
-      } catch (InterruptedException e) {
-        throw new InterruptedIOException();
+      } finally {
+        readTimeout.exitAndThrowIfTimedOut();
       }
     }
 
@@ -463,8 +427,7 @@
     }
 
     @Override public Timeout timeout() {
-      // TODO: honor timeouts.
-      return Timeout.NONE;
+      return readTimeout;
     }
 
     @Override public void close() throws IOException {
@@ -523,12 +486,13 @@
       while (byteCount > 0) {
         long toWrite;
         synchronized (SpdyStream.this) {
+          writeTimeout.enter();
           try {
-            while (bytesLeftInWriteWindow <= 0) {
-              SpdyStream.this.wait(); // Wait until we receive a WINDOW_UPDATE.
+            while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
+              waitForIo(); // Wait until we receive a WINDOW_UPDATE.
             }
-          } catch (InterruptedException e) {
-            throw new InterruptedIOException();
+          } finally {
+            writeTimeout.exitAndThrowIfTimedOut();
           }
 
           checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
@@ -550,8 +514,7 @@
     }
 
     @Override public Timeout timeout() {
-      // TODO: honor timeouts.
-      return Timeout.NONE;
+      return writeTimeout;
     }
 
     @Override public void close() throws IOException {
@@ -588,4 +551,31 @@
       throw new IOException("stream was reset: " + errorCode);
     }
   }
+
+  /**
+   * Like {@link #wait}, but throws an {@code InterruptedIOException} when
+   * interrupted instead of the more awkward {@link InterruptedException}.
+   */
+  private void waitForIo() throws InterruptedIOException {
+    try {
+      wait();
+    } catch (InterruptedException e) {
+      throw new InterruptedIOException();
+    }
+  }
+
+  /**
+   * The Okio timeout watchdog will call {@link #timedOut} if the timeout is
+   * reached. In that case we close the stream (asynchronously) which will
+   * notify the waiting thread.
+   */
+  class SpdyTimeout extends AsyncTimeout {
+    @Override protected void timedOut() {
+      closeLater(ErrorCode.CANCEL);
+    }
+
+    public void exitAndThrowIfTimedOut() throws InterruptedIOException {
+      if (exit()) throw new InterruptedIOException("timeout");
+    }
+  }
 }
/Fim/
diff --git a/pom.xml b/pom.xml
index 96155c9..45e0525 100644
--- a/pom.xml
+++ b/pom.xml
@@ -33,7 +33,7 @@
 
     <!-- Compilation -->
     <java.version>1.6</java.version>
-    <okio.version>0.8.0</okio.version>
+    <okio.version>0.9.0</okio.version>
     <!-- Targetted to jdk7u60-b13; Oracle jdk7u55-b13. -->
     <npn.version>1.1.7.v20140316</npn.version>
     <!-- Targetted to OpenJDK 8 b132 -->
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
index 00ff3ea..f22cfb9 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
@@ -18,7 +18,6 @@
 import com.squareup.okhttp.internal.RecordingAuthenticator;
 import com.squareup.okhttp.internal.http.RecordingProxySelector;
 import com.squareup.okhttp.internal.huc.AuthenticatorAdapter;
-import com.squareup.okhttp.internal.huc.CacheAdapter;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
 import java.net.Authenticator;
 import java.net.CookieManager;
@@ -63,21 +62,18 @@
   @Test public void copyWithDefaultsWhenDefaultIsGlobal() throws Exception {
     ProxySelector proxySelector = new RecordingProxySelector();
     CookieManager cookieManager = new CookieManager();
-    ResponseCache responseCache = new AbstractResponseCache();
     Authenticator authenticator = new RecordingAuthenticator();
     SocketFactory socketFactory = SocketFactory.getDefault(); // Global isn't configurable.
     OkHostnameVerifier hostnameVerifier = OkHostnameVerifier.INSTANCE; // Global isn't configurable.
 
     CookieManager.setDefault(cookieManager);
     ProxySelector.setDefault(proxySelector);
-    ResponseCache.setDefault(responseCache);
     Authenticator.setDefault(authenticator);
 
     OkHttpClient client = new OkHttpClient().copyWithDefaults();
 
     assertSame(proxySelector, client.getProxySelector());
     assertSame(cookieManager, client.getCookieHandler());
-    assertSame(responseCache, ((CacheAdapter) client.internalCache()).getDelegate());
     assertSame(AuthenticatorAdapter.INSTANCE, client.getAuthenticator());
     assertSame(socketFactory, client.getSocketFactory());
     assertSame(hostnameVerifier, client.getHostnameVerifier());
@@ -89,6 +85,14 @@
     assertNull(client.getCache());
   }
 
+  @Test public void copyWithDefaultsDoesNotHonorGlobalResponseCache() throws Exception {
+    ResponseCache responseCache = new AbstractResponseCache();
+    ResponseCache.setDefault(responseCache);
+
+    OkHttpClient client = new OkHttpClient().copyWithDefaults();
+    assertNull(client.internalCache());
+  }
+
   /**
    * When copying the client, stateful things like the connection pool are
    * shared across all clients.
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
index 3af3b15..b598cb3 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
@@ -112,7 +112,7 @@
 
     client = new OkHttpClient();
     cache = new InMemoryResponseCache();
-    ResponseCache.setDefault(cache);
+    Internal.instance.setResponseCache(client, cache);
   }
 
   @After public void tearDown() throws Exception {
@@ -123,19 +123,6 @@
     return client.open(url);
   }
 
-  @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
-    ResponseCache.setDefault(null);
-    Internal.instance.setResponseCache(client, cache);
-    assertTrue(Internal.instance.internalCache(client) instanceof CacheAdapter);
-  }
-
-  @Test public void responseCacheAccessWithGlobalDefault() throws IOException {
-    ResponseCache.setDefault(cache);
-    Internal.instance.setResponseCache(client, null);
-    assertNull(Internal.instance.internalCache(client));
-    assertNull(client.getCache());
-  }
-
   @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
     testResponseCaching(TransferKind.FIXED_LENGTH);
   }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index 8224266..6370e3e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -491,11 +491,6 @@
     if (result.cookieHandler == null) {
       result.cookieHandler = CookieHandler.getDefault();
     }
-    if (result.cache == null && result.cacheAdapter == null) {
-      // TODO: drop support for the default response cache.
-      ResponseCache defaultCache = ResponseCache.getDefault();
-      result.cacheAdapter = defaultCache != null ? new CacheAdapter(defaultCache) : null;
-    }
     if (result.socketFactory == null) {
       result.socketFactory = SocketFactory.getDefault();
     }
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft06Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft07Test.java
similarity index 70%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft06Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft07Test.java
index 8c17465..2ebd58e 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft06Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft07Test.java
@@ -24,28 +24,29 @@
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.Util.headerEntries;
+import static okio.ByteString.decodeHex;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-public class HpackDraft06Test {
+public class HpackDraft07Test {
 
   private final Buffer bytesIn = new Buffer();
-  private HpackDraft06.Reader hpackReader;
+  private HpackDraft07.Reader hpackReader;
   private Buffer bytesOut = new Buffer();
-  private HpackDraft06.Writer hpackWriter;
+  private HpackDraft07.Writer hpackWriter;
 
   @Before public void reset() {
     hpackReader = newReader(bytesIn);
-    hpackWriter = new HpackDraft06.Writer(bytesOut);
+    hpackWriter = new HpackDraft07.Writer(bytesOut);
   }
 
   /**
    * Variable-length quantity special cases strings which are longer than 127
    * bytes.  Values such as cookies can be 4KiB, and should be possible to send.
    *
-   * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#section-4.1.2
+   * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#section-4.1.1
    */
   @Test public void largeHeaderValue() throws IOException {
     char[] value = new char[4096];
@@ -67,17 +68,14 @@
    * Ensure the larger header content is not lost.
    */
   @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
-    Buffer out = new Buffer();
+    bytesIn.writeByte(0x00); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
 
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x0a); // Literal name (len = 10)
-    out.writeUtf8("custom-key");
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
 
-    out.writeByte(0x0d); // Literal value (len = 13)
-    out.writeUtf8("custom-header");
-
-    bytesIn.writeAll(out);
-    hpackReader.maxHeaderTableByteCount(1);
+    hpackReader.maxHeaderTableByteCountSetting(1);
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -88,32 +86,29 @@
 
   /** Oldest entries are evicted to support newer ones. */
   @Test public void testEviction() throws IOException {
-    Buffer out = new Buffer();
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-foo");
 
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x0a); // Literal name (len = 10)
-    out.writeUtf8("custom-foo");
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
 
-    out.writeByte(0x0d); // Literal value (len = 13)
-    out.writeUtf8("custom-header");
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-bar");
 
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x0a); // Literal name (len = 10)
-    out.writeUtf8("custom-bar");
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
 
-    out.writeByte(0x0d); // Literal value (len = 13)
-    out.writeUtf8("custom-header");
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-baz");
 
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x0a); // Literal name (len = 10)
-    out.writeUtf8("custom-baz");
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
 
-    out.writeByte(0x0d); // Literal value (len = 13)
-    out.writeUtf8("custom-header");
-
-    bytesIn.writeAll(out);
     // Set to only support 110 bytes (enough for 2 headers).
-    hpackReader.maxHeaderTableByteCount(110);
+    hpackReader.maxHeaderTableByteCountSetting(110);
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -133,25 +128,22 @@
         hpackReader.getAndReset());
 
     // Simulate receiving a small settings frame, that implies eviction.
-    hpackReader.maxHeaderTableByteCount(55);
+    hpackReader.maxHeaderTableByteCountSetting(55);
     assertEquals(1, hpackReader.headerCount);
   }
 
   /** Header table backing array is initially 8 long, let's ensure it grows. */
   @Test public void dynamicallyGrowsBeyond64Entries() throws IOException {
-    Buffer out = new Buffer();
-
     for (int i = 0; i < 256; i++) {
-      out.writeByte(0x00); // Literal indexed
-      out.writeByte(0x0a); // Literal name (len = 10)
-      out.writeUtf8("custom-foo");
+      bytesIn.writeByte(0x40); // Literal indexed
+      bytesIn.writeByte(0x0a); // Literal name (len = 10)
+      bytesIn.writeUtf8("custom-foo");
 
-      out.writeByte(0x0d); // Literal value (len = 13)
-      out.writeUtf8("custom-header");
+      bytesIn.writeByte(0x0d); // Literal value (len = 13)
+      bytesIn.writeUtf8("custom-header");
     }
 
-    bytesIn.writeAll(out);
-    hpackReader.maxHeaderTableByteCount(16384); // Lots of headers need more room!
+    hpackReader.maxHeaderTableByteCountSetting(16384); // Lots of headers need more room!
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -161,19 +153,12 @@
   }
 
   @Test public void huffmanDecodingSupported() throws IOException {
-    Buffer out = new Buffer();
+    bytesIn.writeByte(0x44); // == Literal indexed ==
+                             // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x8c); // Literal value Huffman encoded 12 bytes
+                             // decodes to www.example.com which is length 15
+    bytesIn.write(decodeHex("e7cf9bebe89b6fb16fa9b6ff"));
 
-    out.writeByte(0x04); // == Literal indexed ==
-                         // Indexed name (idx = 4) -> :path
-    out.writeByte(0x8b); // Literal value Huffman encoded 11 bytes
-                         // decodes to www.example.com which is length 15
-    byte[] huffmanBytes = new byte[] {
-        (byte) 0xdb, (byte) 0x6d, (byte) 0x88, (byte) 0x3e,
-        (byte) 0x68, (byte) 0xd1, (byte) 0xcb, (byte) 0x12,
-        (byte) 0x25, (byte) 0xba, (byte) 0x7f};
-    out.write(huffmanBytes, 0, huffmanBytes.length);
-
-    bytesIn.writeAll(out);
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -186,19 +171,16 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#appendix-D.1.1
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#appendix-D.1.1
    */
   @Test public void readLiteralHeaderFieldWithIndexing() throws IOException {
-    Buffer out = new Buffer();
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
 
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x0a); // Literal name (len = 10)
-    out.writeUtf8("custom-key");
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
 
-    out.writeByte(0x0d); // Literal value (len = 13)
-    out.writeUtf8("custom-header");
-
-    bytesIn.writeAll(out);
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -213,48 +195,19 @@
   }
 
   /**
-   * Literal Header Field without Indexing - New Name
-   */
-  @Test public void literalHeaderFieldWithoutIndexingNewName() throws IOException {
-    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
-
-    Buffer expectedBytes = new Buffer();
-
-    expectedBytes.writeByte(0x40); // Not indexed
-    expectedBytes.writeByte(0x0a); // Literal name (len = 10)
-    expectedBytes.write("custom-key".getBytes(), 0, 10);
-
-    expectedBytes.writeByte(0x0d); // Literal value (len = 13)
-    expectedBytes.write("custom-header".getBytes(), 0, 13);
-
-    hpackWriter.writeHeaders(headerBlock);
-    assertEquals(expectedBytes, bytesOut);
-
-    bytesIn.writeAll(bytesOut);
-    hpackReader.readHeaders();
-    hpackReader.emitReferenceSet();
-
-    assertEquals(0, hpackReader.headerCount);
-
-    assertEquals(headerBlock, hpackReader.getAndReset());
-  }
-
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#appendix-D.1.2
+   * https://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#appendix-D.2.2
    */
   @Test public void literalHeaderFieldWithoutIndexingIndexedName() throws IOException {
     List<Header> headerBlock = headerEntries(":path", "/sample/path");
 
-    Buffer expectedBytes = new Buffer();
-    expectedBytes.writeByte(0x44); // == Literal not indexed ==
-                                   // Indexed name (idx = 4) -> :path
-    expectedBytes.writeByte(0x0c); // Literal value (len = 12)
-    expectedBytes.write("/sample/path".getBytes(), 0, 12);
+    bytesIn.writeByte(0x04); // == Literal not indexed ==
+                             // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("/sample/path");
 
     hpackWriter.writeHeaders(headerBlock);
-    assertEquals(expectedBytes, bytesOut);
+    assertEquals(bytesIn, bytesOut);
 
-    bytesIn.writeAll(bytesOut);
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -263,8 +216,59 @@
     assertEquals(headerBlock, hpackReader.getAndReset());
   }
 
+  @Test public void literalHeaderFieldWithoutIndexingNewName() throws IOException {
+    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
+
+    bytesIn.writeByte(0x00); // Not indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(bytesIn, bytesOut);
+
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndReset());
+  }
+
+  @Test public void literalHeaderFieldNeverIndexedIndexedName() throws IOException {
+    bytesIn.writeByte(0x14); // == Literal never indexed ==
+                             // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("/sample/path");
+
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerEntries(":path", "/sample/path"), hpackReader.getAndReset());
+  }
+
+  @Test public void literalHeaderFieldNeverIndexedNewName() throws IOException {
+    bytesIn.writeByte(0x10); // Never indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndReset());
+  }
+
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#appendix-D.1.3
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#appendix-D.1.3
    */
   @Test public void readIndexedHeaderField() throws IOException {
     bytesIn.writeByte(0x82); // == Indexed - Add ==
@@ -283,10 +287,21 @@
     assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());
   }
 
+  // Example taken from twitter/hpack DecoderTest.testUnusedIndex
+  @Test public void readIndexedHeaderFieldIndex0() throws IOException {
+    bytesIn.writeByte(0x80); // == Indexed - Add idx = 0
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("index == 0", e.getMessage());
+    }
+  }
+
   // Example taken from twitter/hpack DecoderTest.testIllegalIndex
   @Test public void readIndexedHeaderFieldTooLargeIndex() throws IOException {
-    bytesIn.writeByte(0xff); // == Indexed - Add ==
-    bytesIn.writeByte(0x00); // idx = 127
+    bytesIn.writeShort(0xff00); // == Indexed - Add idx = 127
 
     try {
       hpackReader.readHeaders();
@@ -299,11 +314,7 @@
   // Example taken from twitter/hpack DecoderTest.testInsidiousIndex
   @Test public void readIndexedHeaderFieldInsidiousIndex() throws IOException {
     bytesIn.writeByte(0xff); // == Indexed - Add ==
-    bytesIn.writeByte(0x80); // idx = -2147483521
-    bytesIn.writeByte(0x80);
-    bytesIn.writeByte(0x80);
-    bytesIn.writeByte(0x80);
-    bytesIn.writeByte(0x08);
+    bytesIn.write(decodeHex("8080808008")); // idx = -2147483521
 
     try {
       hpackReader.readHeaders();
@@ -315,37 +326,60 @@
 
   // Example taken from twitter/hpack DecoderTest.testIllegalEncodeContextUpdate
   @Test public void readHeaderTableStateChangeInvalid() throws IOException {
-    bytesIn.writeByte(0x80); // header table state change
-    bytesIn.writeByte(0x81); // should be 0x80 for empty!
+    bytesIn.writeByte(0x31); // header table state should be 0x30 for empty!
 
     try {
       hpackReader.readHeaders();
       fail();
     } catch (IOException e) {
-      assertEquals("Invalid header table state change -127", e.getMessage());
+      assertEquals("Invalid header table state change 49", e.getMessage());
+    }
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testMaxHeaderTableSize
+  @Test public void minMaxHeaderTableSize() throws IOException {
+    bytesIn.writeByte(0x20);
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.maxHeaderTableByteCount());
+
+    bytesIn.writeByte(0x2f); // encode size 4096
+    bytesIn.writeByte(0xf1);
+    bytesIn.writeByte(0x1f);
+    hpackReader.readHeaders();
+
+    assertEquals(4096, hpackReader.maxHeaderTableByteCount());
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testIllegalMaxHeaderTableSize
+  @Test public void cannotSetTableSizeLargerThanSettingsValue() throws IOException {
+    bytesIn.writeByte(0x2f); // encode size 4097
+    bytesIn.writeByte(0xf2);
+    bytesIn.writeByte(0x1f);
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Invalid header table byte count 4097", e.getMessage());
     }
   }
 
   // Example taken from twitter/hpack DecoderTest.testInsidiousMaxHeaderSize
   @Test public void readHeaderTableStateChangeInsidiousMaxHeaderByteCount() throws IOException {
-    bytesIn.writeByte(0x80); // header table state change
-    bytesIn.writeByte(0x7F); // encoded -1879048193
-    bytesIn.writeByte(0x80);
-    bytesIn.writeByte(0xFF);
-    bytesIn.writeByte(0xFF);
-    bytesIn.writeByte(0xFF);
-    bytesIn.writeByte(0x08);
+    bytesIn.writeByte(0x2f); // TODO: header table state change
+    bytesIn.write(decodeHex("f1ffffff07")); // count = -2147483648
 
     try {
       hpackReader.readHeaders();
       fail();
     } catch (IOException e) {
-      assertEquals("Invalid header table byte count -1879048193", e.getMessage());
+      assertEquals("Invalid header table byte count -2147483648", e.getMessage());
     }
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#section-3.2.1
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#section-3.2.1
    */
   @Test public void toggleIndex() throws IOException {
     // Static table entries are copied to the top of the reference set.
@@ -370,7 +404,6 @@
 
   /** Ensure a later toggle of the same index emits! */
   @Test public void toggleIndexOffOn() throws IOException {
-
     bytesIn.writeByte(0x82); // Copy static header 1 to the header table as index 1.
     bytesIn.writeByte(0x81); // Remove index 1 from the reference set.
 
@@ -411,13 +444,13 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#appendix-D.1.4
+   * https://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#appendix-D.2.4
    */
   @Test public void readIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
     bytesIn.writeByte(0x82); // == Indexed - Add ==
                              // idx = 2 -> :method: GET
 
-    hpackReader.maxHeaderTableByteCount(0); // SETTINGS_HEADER_TABLE_SIZE == 0
+    hpackReader.maxHeaderTableByteCountSetting(0); // SETTINGS_HEADER_TABLE_SIZE == 0
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -428,40 +461,36 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#appendix-D.2
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#appendix-D.2
    */
   @Test public void readRequestExamplesWithoutHuffman() throws IOException {
-    bytesIn.writeAll(firstRequestWithoutHuffman());
+    firstRequestWithoutHuffman();
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadFirstRequestWithoutHuffman();
 
-    bytesIn.writeAll(secondRequestWithoutHuffman());
+    secondRequestWithoutHuffman();
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadSecondRequestWithoutHuffman();
 
-    bytesIn.writeAll(thirdRequestWithoutHuffman());
+    thirdRequestWithoutHuffman();
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadThirdRequestWithoutHuffman();
   }
 
-  private Buffer firstRequestWithoutHuffman() {
-    Buffer out = new Buffer();
-
-    out.writeByte(0x82); // == Indexed - Add ==
-                         // idx = 2 -> :method: GET
-    out.writeByte(0x87); // == Indexed - Add ==
-                         // idx = 7 -> :scheme: http
-    out.writeByte(0x86); // == Indexed - Add ==
-                         // idx = 6 -> :path: /
-    out.writeByte(0x04); // == Literal indexed ==
-                         // Indexed name (idx = 4) -> :authority
-    out.writeByte(0x0f); // Literal value (len = 15)
-    out.writeUtf8("www.example.com");
-
-    return out;
+  private void firstRequestWithoutHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x87); // == Indexed - Add ==
+                             // idx = 7 -> :scheme: http
+    bytesIn.writeByte(0x86); // == Indexed - Add ==
+                             // idx = 6 -> :path: /
+    bytesIn.writeByte(0x44); // == Literal indexed ==
+                             // Indexed name (idx = 4) -> :authority
+    bytesIn.writeByte(0x0f); // Literal value (len = 15)
+    bytesIn.writeUtf8("www.example.com");
   }
 
   private void checkReadFirstRequestWithoutHuffman() {
@@ -498,15 +527,11 @@
         ":authority", "www.example.com"), hpackReader.getAndReset());
   }
 
-  private Buffer secondRequestWithoutHuffman() {
-    Buffer out = new Buffer();
-
-    out.writeByte(0x1b); // == Literal indexed ==
-                         // Indexed name (idx = 27) -> cache-control
-    out.writeByte(0x08); // Literal value (len = 8)
-    out.writeUtf8("no-cache");
-
-    return out;
+  private void secondRequestWithoutHuffman() {
+    bytesIn.writeByte(0x5c); // == Literal indexed ==
+                             // Indexed name (idx = 28) -> cache-control
+    bytesIn.writeByte(0x08); // Literal value (len = 8)
+    bytesIn.writeUtf8("no-cache");
   }
 
   private void checkReadSecondRequestWithoutHuffman() {
@@ -549,26 +574,21 @@
         "cache-control", "no-cache"), hpackReader.getAndReset());
   }
 
-  private Buffer thirdRequestWithoutHuffman() {
-    Buffer out = new Buffer();
-
-    out.writeByte(0x80); // == Empty reference set ==
-    out.writeByte(0x80); // idx = 0, flag = 1
-    out.writeByte(0x85); // == Indexed - Add ==
-                         // idx = 5 -> :method: GET
-    out.writeByte(0x8c); // == Indexed - Add ==
-                         // idx = 12 -> :scheme: https
-    out.writeByte(0x8b); // == Indexed - Add ==
-                         // idx = 11 -> :path: /index.html
-    out.writeByte(0x84); // == Indexed - Add ==
-                         // idx = 4 -> :authority: www.example.com
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x0a); // Literal name (len = 10)
-    out.writeUtf8("custom-key");
-    out.writeByte(0x0c); // Literal value (len = 12)
-    out.writeUtf8("custom-value");
-
-    return out;
+  private void thirdRequestWithoutHuffman() {
+    bytesIn.writeByte(0x30); // == Empty reference set ==
+    bytesIn.writeByte(0x85); // == Indexed - Add ==
+                             // idx = 5 -> :method: GET
+    bytesIn.writeByte(0x8c); // == Indexed - Add ==
+                             // idx = 12 -> :scheme: https
+    bytesIn.writeByte(0x8b); // == Indexed - Add ==
+                             // idx = 11 -> :path: /index.html
+    bytesIn.writeByte(0x84); // == Indexed - Add ==
+                             // idx = 4 -> :authority: www.example.com
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("custom-value");
   }
 
   private void checkReadThirdRequestWithoutHuffman() {
@@ -628,45 +648,37 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#appendix-D.3
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#appendix-D.3
    */
   @Test public void readRequestExamplesWithHuffman() throws IOException {
-    bytesIn.writeAll(firstRequestWithHuffman());
+    firstRequestWithHuffman();
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadFirstRequestWithHuffman();
 
-    bytesIn.writeAll(secondRequestWithHuffman());
+    secondRequestWithHuffman();
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadSecondRequestWithHuffman();
 
-    bytesIn.writeAll(thirdRequestWithHuffman());
+    thirdRequestWithHuffman();
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadThirdRequestWithHuffman();
   }
 
-  private Buffer firstRequestWithHuffman() {
-    Buffer out = new Buffer();
-
-    out.writeByte(0x82); // == Indexed - Add ==
-                         // idx = 2 -> :method: GET
-    out.writeByte(0x87); // == Indexed - Add ==
-                         // idx = 7 -> :scheme: http
-    out.writeByte(0x86); // == Indexed - Add ==
-                         // idx = 6 -> :path: /
-    out.writeByte(0x04); // == Literal indexed ==
-                         // Indexed name (idx = 4) -> :authority
-    out.writeByte(0x8b); // Literal value Huffman encoded 11 bytes
-                         // decodes to www.example.com which is length 15
-    byte[] huffmanBytes = new byte[] {
-        (byte) 0xdb, (byte) 0x6d, (byte) 0x88, (byte) 0x3e,
-        (byte) 0x68, (byte) 0xd1, (byte) 0xcb, (byte) 0x12,
-        (byte) 0x25, (byte) 0xba, (byte) 0x7f};
-    out.write(huffmanBytes, 0, huffmanBytes.length);
-
-    return out;
+  private void firstRequestWithHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x87); // == Indexed - Add ==
+                             // idx = 7 -> :scheme: http
+    bytesIn.writeByte(0x86); // == Indexed - Add ==
+                             // idx = 6 -> :path: /
+    bytesIn.writeByte(0x44); // == Literal indexed ==
+                             // Indexed name (idx = 4) -> :authority
+    bytesIn.writeByte(0x8c); // Literal value Huffman encoded 12 bytes
+                             // decodes to www.example.com which is length 15
+    bytesIn.write(decodeHex("e7cf9bebe89b6fb16fa9b6ff"));
   }
 
   private void checkReadFirstRequestWithHuffman() {
@@ -703,19 +715,12 @@
         ":authority", "www.example.com"), hpackReader.getAndReset());
   }
 
-  private Buffer secondRequestWithHuffman() {
-    Buffer out = new Buffer();
-
-    out.writeByte(0x1b); // == Literal indexed ==
-                         // Indexed name (idx = 27) -> cache-control
-    out.writeByte(0x86); // Literal value Huffman encoded 6 bytes
-                         // decodes to no-cache which is length 8
-    byte[] huffmanBytes = new byte[] {
-        (byte) 0x63, (byte) 0x65, (byte) 0x4a, (byte) 0x13,
-        (byte) 0x98, (byte) 0xff};
-    out.write(huffmanBytes, 0, huffmanBytes.length);
-
-    return out;
+  private void secondRequestWithHuffman() {
+    bytesIn.writeByte(0x5c); // == Literal indexed ==
+                             // Indexed name (idx = 28) -> cache-control
+    bytesIn.writeByte(0x86); // Literal value Huffman encoded 6 bytes
+                             // decodes to no-cache which is length 8
+    bytesIn.write(decodeHex("b9b9949556bf"));
   }
 
   private void checkReadSecondRequestWithHuffman() {
@@ -758,35 +763,23 @@
         "cache-control", "no-cache"), hpackReader.getAndReset());
   }
 
-  private Buffer thirdRequestWithHuffman() {
-    Buffer out = new Buffer();
-
-    out.writeByte(0x80); // == Empty reference set ==
-    out.writeByte(0x80); // idx = 0, flag = 1
-    out.writeByte(0x85); // == Indexed - Add ==
-                         // idx = 5 -> :method: GET
-    out.writeByte(0x8c); // == Indexed - Add ==
-                         // idx = 12 -> :scheme: https
-    out.writeByte(0x8b); // == Indexed - Add ==
-                         // idx = 11 -> :path: /index.html
-    out.writeByte(0x84); // == Indexed - Add ==
-                         // idx = 4 -> :authority: www.example.com
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x88); // Literal name Huffman encoded 8 bytes
-                         // decodes to custom-key which is length 10
-    byte[] huffmanBytes = new byte[] {
-        (byte) 0x4e, (byte) 0xb0, (byte) 0x8b, (byte) 0x74,
-        (byte) 0x97, (byte) 0x90, (byte) 0xfa, (byte) 0x7f};
-    out.write(huffmanBytes, 0, huffmanBytes.length);
-    out.writeByte(0x89); // Literal value Huffman encoded 6 bytes
-                         // decodes to custom-value which is length 12
-    huffmanBytes = new byte[] {
-        (byte) 0x4e, (byte) 0xb0, (byte) 0x8b, (byte) 0x74,
-        (byte) 0x97, (byte) 0x9a, (byte) 0x17, (byte) 0xa8,
-        (byte) 0xff};
-    out.write(huffmanBytes, 0, huffmanBytes.length);
-
-    return out;
+  private void thirdRequestWithHuffman() {
+    bytesIn.writeByte(0x30); // == Empty reference set ==
+    bytesIn.writeByte(0x85); // == Indexed - Add ==
+                             // idx = 5 -> :method: GET
+    bytesIn.writeByte(0x8c); // == Indexed - Add ==
+                             // idx = 12 -> :scheme: https
+    bytesIn.writeByte(0x8b); // == Indexed - Add ==
+                             // idx = 11 -> :path: /index.html
+    bytesIn.writeByte(0x84); // == Indexed - Add ==
+                             // idx = 4 -> :authority: www.example.com
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x88); // Literal name Huffman encoded 8 bytes
+                             // decodes to custom-key which is length 10
+    bytesIn.write(decodeHex("571c5cdb737b2faf"));
+    bytesIn.writeByte(0x89); // Literal value Huffman encoded 6 bytes
+                             // decodes to custom-value which is length 12
+    bytesIn.write(decodeHex("571c5cdb73724d9c57"));
   }
 
   private void checkReadThirdRequestWithHuffman() {
@@ -906,8 +899,8 @@
     assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString(false));
   }
 
-  private HpackDraft06.Reader newReader(Buffer source) {
-    return new HpackDraft06.Reader(4096, source);
+  private HpackDraft07.Reader newReader(Buffer source) {
+    return new HpackDraft07.Reader(4096, source);
   }
 
   private Buffer byteStream(int... bytes) {
@@ -920,10 +913,9 @@
     assertEquals(size, entry.hpackSize);
   }
 
-  private void assertBytes(int... bytes) {
+  private void assertBytes(int... bytes) throws IOException {
     ByteString expected = intArrayToByteArray(bytes);
-    // TODO change to bytesOut.readByteString() once Okio 0.8.1+ is available.
-    ByteString actual = bytesOut.readByteString(bytesOut.size());
+    ByteString actual = bytesOut.readByteString();
     assertEquals(expected, actual);
   }
 
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft10Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft10Test.java
index 35fbb4f..49ec906 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft10Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft10Test.java
@@ -944,7 +944,7 @@
 
   private Buffer literalHeaders(List<Header> sentHeaders) throws IOException {
     Buffer out = new Buffer();
-    new HpackDraft06.Writer(out).writeHeaders(sentHeaders);
+    new HpackDraft07.Writer(out).writeHeaders(sentHeaders);
     return out;
   }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
index 354d825..f543c9d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
@@ -65,7 +65,7 @@
    * <p>This version of OkHttp implements HTTP/2 <a
    * href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-10">draft 10</a>
    * with HPACK <a
-   * href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06">draft
+   * href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07">draft
    * 6</a>. Future releases of OkHttp may use this identifier for a newer draft
    * of these specs.
    */
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
index c4518fa..1832c6d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -367,7 +367,6 @@
       result.writeByte(protocol.toString().length());
       result.writeUtf8(protocol.toString());
     }
-    // TODO change to result.readByteArray() when Okio 0.8.1+ is available.
-    return result.readByteArray(result.size());
+    return result.readByteArray();
   }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft06.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft07.java
similarity index 83%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft06.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft07.java
index 5cd798e..8894068 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft06.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft07.java
@@ -15,15 +15,16 @@
 import okio.Source;
 
 /**
- * Read and write HPACK v06.
+ * Read and write HPACK v07.
  *
- * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06
+ * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07
  *
  * This implementation uses an array for the header table with a bitset for
  * references.  Dynamic entries are added to the array, starting in the last
  * position moving forward.  When the array fills, it is doubled.
  */
-final class HpackDraft06 {
+final class HpackDraft07 {
+  private static final int PREFIX_4_BITS = 0x0f;
   private static final int PREFIX_6_BITS = 0x3f;
   private static final int PREFIX_7_BITS = 0x7f;
 
@@ -36,11 +37,12 @@
       new Header(Header.TARGET_SCHEME, "http"),
       new Header(Header.TARGET_SCHEME, "https"),
       new Header(Header.RESPONSE_STATUS, "200"),
-      new Header(Header.RESPONSE_STATUS, "500"),
-      new Header(Header.RESPONSE_STATUS, "404"),
-      new Header(Header.RESPONSE_STATUS, "403"),
+      new Header(Header.RESPONSE_STATUS, "204"),
+      new Header(Header.RESPONSE_STATUS, "206"),
+      new Header(Header.RESPONSE_STATUS, "304"),
       new Header(Header.RESPONSE_STATUS, "400"),
-      new Header(Header.RESPONSE_STATUS, "401"),
+      new Header(Header.RESPONSE_STATUS, "404"),
+      new Header(Header.RESPONSE_STATUS, "500"),
       new Header("accept-charset", ""),
       new Header("accept-encoding", ""),
       new Header("accept-language", ""),
@@ -90,14 +92,15 @@
       new Header("www-authenticate", "")
   };
 
-  private HpackDraft06() {
+  private HpackDraft07() {
   }
 
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#section-3.2
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#section-3.2
   static final class Reader {
 
     private final List<Header> emittedHeaders = new ArrayList<Header>();
     private final BufferedSource source;
+    private int maxHeaderTableByteCountSetting;
     private int maxHeaderTableByteCount;
 
     // Visible for testing.
@@ -118,8 +121,9 @@
     BitArray emittedReferencedHeaders = new BitArray.FixedCapacity();
     int headerTableByteCount = 0;
 
-    Reader(int maxHeaderTableByteCount, Source source) {
-      this.maxHeaderTableByteCount = maxHeaderTableByteCount;
+    Reader(int maxHeaderTableByteCountSetting, Source source) {
+      this.maxHeaderTableByteCountSetting = maxHeaderTableByteCountSetting;
+      this.maxHeaderTableByteCount = maxHeaderTableByteCountSetting;
       this.source = Okio.buffer(source);
     }
 
@@ -129,11 +133,18 @@
 
     /**
      * Called by the reader when the peer sent a new header table size setting.
-     * <p>
-     * Evicts entries or clears the table as needed.
+     * While this establishes the maximum header table size, the
+     * {@link #maxHeaderTableByteCount} set during processing may limit the
+     * table size to a smaller amount.
+     * <p> Evicts entries or clears the table as needed.
      */
-    void maxHeaderTableByteCount(int newMaxHeaderTableByteCount) {
-      this.maxHeaderTableByteCount = newMaxHeaderTableByteCount;
+    void maxHeaderTableByteCountSetting(int newMaxHeaderTableByteCountSetting) {
+      this.maxHeaderTableByteCountSetting = newMaxHeaderTableByteCountSetting;
+      this.maxHeaderTableByteCount = maxHeaderTableByteCountSetting;
+      adjustHeaderTableByteCount();
+    }
+
+    private void adjustHeaderTableByteCount() {
       if (maxHeaderTableByteCount < headerTableByteCount) {
         if (maxHeaderTableByteCount == 0) {
           clearHeaderTable();
@@ -173,46 +184,39 @@
 
     /**
      * Read {@code byteCount} bytes of headers from the source stream into the
-     * set of emitted headers.
+     * set of emitted headers. This implementation does not propagate the never
+     * indexed flag of a header.
      */
     void readHeaders() throws IOException {
       while (!source.exhausted()) {
         int b = source.readByte() & 0xff;
         if (b == 0x80) { // 10000000
-          b = source.readByte();
-          if ((b & 0x80) == 0x80) { // 1NNNNNNN
-            if ((b & PREFIX_7_BITS) == 0) {
-              clearReferenceSet();
-            } else {
-              throw new IOException("Invalid header table state change " + b);
-            }
-          } else {
-            int headerTableByteCount = b != PREFIX_7_BITS ? b : readInt(b, PREFIX_7_BITS);
-            if (headerTableByteCount < 0) {
-              throw new IOException("Invalid header table byte count " + headerTableByteCount);
-            }
-            maxHeaderTableByteCount = Math.min(headerTableByteCount, maxHeaderTableByteCount);
-            int toEvict = headerTableByteCount - maxHeaderTableByteCount;
-            if (toEvict > 0) evictToRecoverBytes(toEvict);
-          }
+          throw new IOException("index == 0");
         } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
           int index = readInt(b, PREFIX_7_BITS);
           readIndexedHeader(index - 1);
-        } else { // 0NNNNNNN
-          if (b == 0x40) { // 01000000
-            readLiteralHeaderWithoutIndexingNewName();
-          } else if ((b & 0x40) == 0x40) {  // 01NNNNNN
-            int index = readInt(b, PREFIX_6_BITS);
-            readLiteralHeaderWithoutIndexingIndexedName(index - 1);
-          } else if (b == 0) { // 00000000
-            readLiteralHeaderWithIncrementalIndexingNewName();
-          } else if ((b & 0xc0) == 0) { // 00NNNNNN
-            int index = readInt(b, PREFIX_6_BITS);
-            readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
-          } else {
-            // TODO: we should throw something that we can coerce to a PROTOCOL_ERROR
-            throw new AssertionError("unhandled byte: " + Integer.toBinaryString(b));
+        } else if (b == 0x40) { // 01000000
+          readLiteralHeaderWithIncrementalIndexingNewName();
+        } else if ((b & 0x40) == 0x40) {  // 01NNNNNN
+          int index = readInt(b, PREFIX_6_BITS);
+          readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
+        } else if ((b & 0x20) == 0x20) {  // 001NNNNN
+          if ((b & 0x10) == 0x10) { // 0011NNNN
+            if ((b & 0x0f) != 0) throw new IOException("Invalid header table state change " + b);
+            clearReferenceSet(); // 00110000
+          } else { // 0010NNNN
+            maxHeaderTableByteCount = readInt(b, PREFIX_4_BITS);
+            if (maxHeaderTableByteCount < 0
+                || maxHeaderTableByteCount > maxHeaderTableByteCountSetting) {
+              throw new IOException("Invalid header table byte count " + maxHeaderTableByteCount);
+            }
+            adjustHeaderTableByteCount();
           }
+        } else if (b == 0x10 || b == 0) { // 000?0000 - Ignore never indexed bit.
+          readLiteralHeaderWithoutIndexingNewName();
+        } else { // 000?NNNN - Ignore never indexed bit.
+          int index = readInt(b, PREFIX_4_BITS);
+          readLiteralHeaderWithoutIndexingIndexedName(index - 1);
         }
       }
     }
@@ -419,6 +423,8 @@
       this.out = out;
     }
 
+    /** This does not use "never indexed" semantics for sensitive headers. */
+    // https://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#section-4.3.3
     void writeHeaders(List<Header> headerBlock) throws IOException {
       // TODO: implement index tracking
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
@@ -426,17 +432,17 @@
         Integer staticIndex = NAME_TO_FIRST_INDEX.get(name);
         if (staticIndex != null) {
           // Literal Header Field without Indexing - Indexed Name.
-          writeInt(staticIndex + 1, PREFIX_6_BITS, 0x40);
+          writeInt(staticIndex + 1, PREFIX_4_BITS, 0);
           writeByteString(headerBlock.get(i).value);
         } else {
-          out.writeByte(0x40); // Literal Header without Indexing - New Name.
+          out.writeByte(0x00); // Literal Header without Indexing - New Name.
           writeByteString(name);
           writeByteString(headerBlock.get(i).value);
         }
       }
     }
 
-    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#section-4.1.1
+    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#section-4.1.1
     void writeInt(int value, int prefixMask, int bits) throws IOException {
       // Write the raw value for a single byte value.
       if (value < prefixMask) {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft10.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft10.java
index 036f098..23d2959 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft10.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft10.java
@@ -83,13 +83,13 @@
     private final boolean client;
 
     // Visible for testing.
-    final HpackDraft06.Reader hpackReader;
+    final HpackDraft07.Reader hpackReader;
 
     Reader(BufferedSource source, int headerTableSize, boolean client) {
       this.source = source;
       this.client = client;
       this.continuation = new ContinuationSource(this.source);
-      this.hpackReader = new HpackDraft06.Reader(headerTableSize, continuation);
+      this.hpackReader = new HpackDraft07.Reader(headerTableSize, continuation);
     }
 
     @Override public void readConnectionHeader() throws IOException {
@@ -272,7 +272,7 @@
       }
       handler.settings(false, settings);
       if (settings.getHeaderTableSize() >= 0) {
-        hpackReader.maxHeaderTableByteCount(settings.getHeaderTableSize());
+        hpackReader.maxHeaderTableByteCountSetting(settings.getHeaderTableSize());
       }
     }
 
@@ -333,14 +333,14 @@
     private final BufferedSink sink;
     private final boolean client;
     private final Buffer hpackBuffer;
-    private final HpackDraft06.Writer hpackWriter;
+    private final HpackDraft07.Writer hpackWriter;
     private boolean closed;
 
     Writer(BufferedSink sink, boolean client) {
       this.sink = sink;
       this.client = client;
       this.hpackBuffer = new Buffer();
-      this.hpackWriter = new HpackDraft06.Writer(hpackBuffer);
+      this.hpackWriter = new HpackDraft07.Writer(hpackBuffer);
     }
 
     @Override public synchronized void flush() throws IOException {
@@ -539,7 +539,7 @@
   /**
    * Decompression of the header block occurs above the framing layer. This
    * class lazily reads continuation frames as they are needed by {@link
-   * HpackDraft06.Reader#readHeaders()}.
+   * HpackDraft07.Reader#readHeaders()}.
    */
   static final class ContinuationSource implements Source {
     private final BufferedSource source;
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
index 5b9c22f..3acb376 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
@@ -32,49 +32,49 @@
 class Huffman {
 
   // Appendix C: Huffman Codes
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#appendix-C
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#appendix-C
   private static final int[] CODES = {
-      0x7ffffba, 0x7ffffbb, 0x7ffffbc, 0x7ffffbd, 0x7ffffbe, 0x7ffffbf, 0x7ffffc0, 0x7ffffc1,
-      0x7ffffc2, 0x7ffffc3, 0x7ffffc4, 0x7ffffc5, 0x7ffffc6, 0x7ffffc7, 0x7ffffc8, 0x7ffffc9,
-      0x7ffffca, 0x7ffffcb, 0x7ffffcc, 0x7ffffcd, 0x7ffffce, 0x7ffffcf, 0x7ffffd0, 0x7ffffd1,
-      0x7ffffd2, 0x7ffffd3, 0x7ffffd4, 0x7ffffd5, 0x7ffffd6, 0x7ffffd7, 0x7ffffd8, 0x7ffffd9, 0xe8,
-      0xffc, 0x3ffa, 0x7ffc, 0x7ffd, 0x24, 0x6e, 0x7ffe, 0x7fa, 0x7fb, 0x3fa, 0x7fc, 0xe9, 0x25,
-      0x4, 0x0, 0x5, 0x6, 0x7, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x1ec, 0xea, 0x3fffe, 0x2d,
-      0x1fffc, 0x1ed, 0x3ffb, 0x6f, 0xeb, 0xec, 0xed, 0xee, 0x70, 0x1ee, 0x1ef, 0x1f0, 0x1f1, 0x3fb,
-      0x1f2, 0xef, 0x1f3, 0x1f4, 0x1f5, 0x1f6, 0x1f7, 0xf0, 0xf1, 0x1f8, 0x1f9, 0x1fa, 0x1fb, 0x1fc,
-      0x3fc, 0x3ffc, 0x7ffffda, 0x1ffc, 0x3ffd, 0x2e, 0x7fffe, 0x8, 0x2f, 0x9, 0x30, 0x1, 0x31,
-      0x32, 0x33, 0xa, 0x71, 0x72, 0xb, 0x34, 0xc, 0xd, 0xe, 0xf2, 0xf, 0x10, 0x11, 0x35, 0x73,
-      0x36, 0xf3, 0xf4, 0xf5, 0x1fffd, 0x7fd, 0x1fffe, 0xffd, 0x7ffffdb, 0x7ffffdc, 0x7ffffdd,
-      0x7ffffde, 0x7ffffdf, 0x7ffffe0, 0x7ffffe1, 0x7ffffe2, 0x7ffffe3, 0x7ffffe4, 0x7ffffe5,
-      0x7ffffe6, 0x7ffffe7, 0x7ffffe8, 0x7ffffe9, 0x7ffffea, 0x7ffffeb, 0x7ffffec, 0x7ffffed,
-      0x7ffffee, 0x7ffffef, 0x7fffff0, 0x7fffff1, 0x7fffff2, 0x7fffff3, 0x7fffff4, 0x7fffff5,
-      0x7fffff6, 0x7fffff7, 0x7fffff8, 0x7fffff9, 0x7fffffa, 0x7fffffb, 0x7fffffc, 0x7fffffd,
-      0x7fffffe, 0x7ffffff, 0x3ffff80, 0x3ffff81, 0x3ffff82, 0x3ffff83, 0x3ffff84, 0x3ffff85,
-      0x3ffff86, 0x3ffff87, 0x3ffff88, 0x3ffff89, 0x3ffff8a, 0x3ffff8b, 0x3ffff8c, 0x3ffff8d,
-      0x3ffff8e, 0x3ffff8f, 0x3ffff90, 0x3ffff91, 0x3ffff92, 0x3ffff93, 0x3ffff94, 0x3ffff95,
-      0x3ffff96, 0x3ffff97, 0x3ffff98, 0x3ffff99, 0x3ffff9a, 0x3ffff9b, 0x3ffff9c, 0x3ffff9d,
-      0x3ffff9e, 0x3ffff9f, 0x3ffffa0, 0x3ffffa1, 0x3ffffa2, 0x3ffffa3, 0x3ffffa4, 0x3ffffa5,
-      0x3ffffa6, 0x3ffffa7, 0x3ffffa8, 0x3ffffa9, 0x3ffffaa, 0x3ffffab, 0x3ffffac, 0x3ffffad,
-      0x3ffffae, 0x3ffffaf, 0x3ffffb0, 0x3ffffb1, 0x3ffffb2, 0x3ffffb3, 0x3ffffb4, 0x3ffffb5,
-      0x3ffffb6, 0x3ffffb7, 0x3ffffb8, 0x3ffffb9, 0x3ffffba, 0x3ffffbb, 0x3ffffbc, 0x3ffffbd,
-      0x3ffffbe, 0x3ffffbf, 0x3ffffc0, 0x3ffffc1, 0x3ffffc2, 0x3ffffc3, 0x3ffffc4, 0x3ffffc5,
-      0x3ffffc6, 0x3ffffc7, 0x3ffffc8, 0x3ffffc9, 0x3ffffca, 0x3ffffcb, 0x3ffffcc, 0x3ffffcd,
-      0x3ffffce, 0x3ffffcf, 0x3ffffd0, 0x3ffffd1, 0x3ffffd2, 0x3ffffd3, 0x3ffffd4, 0x3ffffd5,
-      0x3ffffd6, 0x3ffffd7, 0x3ffffd8, 0x3ffffd9, 0x3ffffda, 0x3ffffdb
+      0x3ffffba, 0x3ffffbb, 0x3ffffbc, 0x3ffffbd, 0x3ffffbe, 0x3ffffbf, 0x3ffffc0, 0x3ffffc1,
+      0x3ffffc2, 0x3ffffc3, 0x3ffffc4, 0x3ffffc5, 0x3ffffc6, 0x3ffffc7, 0x3ffffc8, 0x3ffffc9,
+      0x3ffffca, 0x3ffffcb, 0x3ffffcc, 0x3ffffcd, 0x3ffffce, 0x3ffffcf, 0x3ffffd0, 0x3ffffd1,
+      0x3ffffd2, 0x3ffffd3, 0x3ffffd4, 0x3ffffd5, 0x3ffffd6, 0x3ffffd7, 0x3ffffd8, 0x3ffffd9, 0x6,
+      0x1ffc, 0x1f0, 0x3ffc, 0x7ffc, 0x1e, 0x64, 0x1ffd, 0x3fa, 0x1f1, 0x3fb, 0x3fc, 0x65, 0x66,
+      0x1f, 0x7, 0x0, 0x1, 0x2, 0x8, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0xec, 0x1fffc, 0x27,
+      0x7ffd, 0x3fd, 0x7ffe, 0x67, 0xed, 0xee, 0x68, 0xef, 0x69, 0x6a, 0x1f2, 0xf0, 0x1f3, 0x1f4,
+      0x1f5, 0x6b, 0x6c, 0xf1, 0xf2, 0x1f6, 0x1f7, 0x6d, 0x28, 0xf3, 0x1f8, 0x1f9, 0xf4, 0x1fa,
+      0x1fb, 0x7fc, 0x3ffffda, 0x7fd, 0x3ffd, 0x6e, 0x3fffe, 0x9, 0x6f, 0xa, 0x29, 0xb, 0x70, 0x2a,
+      0x2b, 0xc, 0xf5, 0xf6, 0x2c, 0x2d, 0x2e, 0xd, 0x2f, 0x1fc, 0x30, 0x31, 0xe, 0x71, 0x72, 0x73,
+      0x74, 0x75, 0xf7, 0x1fffd, 0xffc, 0x1fffe, 0xffd, 0x3ffffdb, 0x3ffffdc, 0x3ffffdd, 0x3ffffde,
+      0x3ffffdf, 0x3ffffe0, 0x3ffffe1, 0x3ffffe2, 0x3ffffe3, 0x3ffffe4, 0x3ffffe5, 0x3ffffe6,
+      0x3ffffe7, 0x3ffffe8, 0x3ffffe9, 0x3ffffea, 0x3ffffeb, 0x3ffffec, 0x3ffffed, 0x3ffffee,
+      0x3ffffef, 0x3fffff0, 0x3fffff1, 0x3fffff2, 0x3fffff3, 0x3fffff4, 0x3fffff5, 0x3fffff6,
+      0x3fffff7, 0x3fffff8, 0x3fffff9, 0x3fffffa, 0x3fffffb, 0x3fffffc, 0x3fffffd, 0x3fffffe,
+      0x3ffffff, 0x1ffff80, 0x1ffff81, 0x1ffff82, 0x1ffff83, 0x1ffff84, 0x1ffff85, 0x1ffff86,
+      0x1ffff87, 0x1ffff88, 0x1ffff89, 0x1ffff8a, 0x1ffff8b, 0x1ffff8c, 0x1ffff8d, 0x1ffff8e,
+      0x1ffff8f, 0x1ffff90, 0x1ffff91, 0x1ffff92, 0x1ffff93, 0x1ffff94, 0x1ffff95, 0x1ffff96,
+      0x1ffff97, 0x1ffff98, 0x1ffff99, 0x1ffff9a, 0x1ffff9b, 0x1ffff9c, 0x1ffff9d, 0x1ffff9e,
+      0x1ffff9f, 0x1ffffa0, 0x1ffffa1, 0x1ffffa2, 0x1ffffa3, 0x1ffffa4, 0x1ffffa5, 0x1ffffa6,
+      0x1ffffa7, 0x1ffffa8, 0x1ffffa9, 0x1ffffaa, 0x1ffffab, 0x1ffffac, 0x1ffffad, 0x1ffffae,
+      0x1ffffaf, 0x1ffffb0, 0x1ffffb1, 0x1ffffb2, 0x1ffffb3, 0x1ffffb4, 0x1ffffb5, 0x1ffffb6,
+      0x1ffffb7, 0x1ffffb8, 0x1ffffb9, 0x1ffffba, 0x1ffffbb, 0x1ffffbc, 0x1ffffbd, 0x1ffffbe,
+      0x1ffffbf, 0x1ffffc0, 0x1ffffc1, 0x1ffffc2, 0x1ffffc3, 0x1ffffc4, 0x1ffffc5, 0x1ffffc6,
+      0x1ffffc7, 0x1ffffc8, 0x1ffffc9, 0x1ffffca, 0x1ffffcb, 0x1ffffcc, 0x1ffffcd, 0x1ffffce,
+      0x1ffffcf, 0x1ffffd0, 0x1ffffd1, 0x1ffffd2, 0x1ffffd3, 0x1ffffd4, 0x1ffffd5, 0x1ffffd6,
+      0x1ffffd7, 0x1ffffd8, 0x1ffffd9, 0x1ffffda, 0x1ffffdb
   };
 
   private static final byte[] CODE_LENGTHS = {
-      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-      27, 27, 27, 27, 27, 27, 27, 27, 27, 8, 12, 14, 15, 15, 6, 7, 15, 11, 11, 10, 11, 8, 6, 5, 4,
-      5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 9, 8, 18, 6, 17, 9, 14, 7, 8, 8, 8, 8, 7, 9, 9, 9, 9, 10, 9, 8,
-      9, 9, 9, 9, 9, 8, 8, 9, 9, 9, 9, 9, 10, 14, 27, 13, 14, 6, 19, 5, 6, 5, 6, 4, 6, 6, 6, 5, 7,
-      7, 5, 6, 5, 5, 5, 8, 5, 5, 5, 6, 7, 6, 8, 8, 8, 17, 11, 17, 12, 27, 27, 27, 27, 27, 27, 27,
-      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-      27, 27, 27, 27, 27, 27, 27, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
       26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+      26, 26, 26, 26, 26, 26, 26, 26, 26, 5, 13, 9, 14, 15, 6, 7, 13, 10, 9, 10, 10, 7, 7, 6, 5, 4,
+      4, 4, 5, 6, 6, 6, 6, 6, 6, 6, 8, 17, 6, 15, 10, 15, 7, 8, 8, 7, 8, 7, 7, 9, 8, 9, 9, 9, 7, 7,
+      8, 8, 9, 9, 7, 6, 8, 9, 9, 8, 9, 9, 11, 26, 11, 14, 7, 18, 5, 7, 5, 6, 5, 7, 6, 6, 5, 8, 8, 6,
+      6, 6, 5, 6, 9, 6, 6, 5, 7, 7, 7, 7, 7, 8, 17, 12, 17, 12, 26, 26, 26, 26, 26, 26, 26, 26, 26,
       26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-      26, 26, 26, 26, 26, 26, 26
+      26, 26, 26, 26, 26, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+      25, 25, 25, 25, 25
   };
 
   private static final Huffman INSTANCE = new Huffman();
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
index 10ea5b4..c2f426c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
@@ -63,7 +63,7 @@
    * HTTP/1.1 semantics are layered on HTTP/2.
    *
    * <p>This version of OkHttp implements HTTP/2 <a
-   * href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-12">draft 10</a>
+   * href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-12">draft 12</a>
    * with HPACK <a
    * href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07">draft
    * 6</a>. Future releases of OkHttp may use this identifier for a newer draft
/Fim/
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index ccafa41..41e6b6a 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -40,4 +40,17 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <!-- Do not deploy this as an artifact to Maven central. -->
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-deploy-plugin</artifactId>
+        <configuration>
+          <skip>true</skip>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
/Fim/
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
index 2dbaea0..9be8641 100644
--- a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
@@ -272,7 +272,9 @@
           throw new ProtocolException(method + " does not support writing");
         }
       }
-      httpEngine = newHttpEngine(method, null, null, null);
+      // If the user set content length to zero, we know there will not be a request body.
+      RetryableSink requestBody = doOutput && fixedContentLength == 0 ? Util.emptySink() : null;
+      httpEngine = newHttpEngine(method, null, requestBody, null);
     } catch (IOException e) {
       httpEngineFailure = e;
       throw e;
/Fim/
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/guide/Recipes.java b/samples/guide/src/main/java/com/squareup/okhttp/guide/Recipes.java
index f57366b..089a14f 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/guide/Recipes.java
+++ b/samples/guide/src/main/java/com/squareup/okhttp/guide/Recipes.java
@@ -4,12 +4,15 @@
 import com.squareup.okhttp.Cache;
 import com.squareup.okhttp.Callback;
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
 import java.io.File;
 import java.io.IOException;
 import java.util.Map;
+import okio.BufferedSink;
 
 public final class Recipes {
   public void getResponseSynchronously() throws Exception {
@@ -19,9 +22,7 @@
         .build();
 
     Response response = client.newCall(request).execute();
-    if (response.code() < 200 || response.code() >= 300) {
-      throw new IOException("Unexpected code " + response);
-    }
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
     Headers responseHeaders = response.headers();
     for (int i = 0; i < responseHeaders.size(); i++) {
@@ -43,9 +44,7 @@
       }
 
       @Override public void onResponse(Response response) throws IOException {
-        if (response.code() < 200 || response.code() >= 300) {
-          throw new IOException("Unexpected code " + response);
-        }
+        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
         Headers responseHeaders = response.headers();
         for (int i = 0; i < responseHeaders.size(); i++) {
@@ -65,6 +64,8 @@
         .url("https://api.github.com/gists/c2a7c39532239ff261be")
         .build();
     Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
     Gist gist = gson.fromJson(response.body().charStream(), Gist.class);
     for (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {
       System.out.println(entry.getKey());
@@ -93,18 +94,16 @@
         .build();
 
     Response response1 = client.newCall(request).execute();
-    if (response1.code() < 200 || response1.code() >= 300) {
-      throw new IOException("Unexpected code " + response1);
-    }
+    if (!response1.isSuccessful()) throw new IOException("Unexpected code " + response1);
+
     String response1Body = response1.body().string();
     System.out.println("Response 1 response:          " + response1);
     System.out.println("Response 1 cache response:    " + response1.cacheResponse());
     System.out.println("Response 1 network response:  " + response1.networkResponse());
 
     Response response2 = client.newCall(request).execute();
-    if (response2.code() < 200 || response2.code() >= 300) {
-      throw new IOException("Unexpected code " + response2);
-    }
+    if (!response2.isSuccessful()) throw new IOException("Unexpected code " + response2);
+
     String response2Body = response2.body().string();
     System.out.println("Response 2 response:          " + response2);
     System.out.println("Response 2 cache response:    " + response2.cacheResponse());
@@ -113,11 +112,89 @@
     System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));
   }
 
+  public void postString() throws Exception {
+    MediaType mediaType = MediaType.parse("text/x-markdown; charset=utf-8");
+    String postBody = ""
+        + "Releases\n"
+        + "--------\n"
+        + "\n"
+        + " * _1.0_ May 6, 2013\n"
+        + " * _1.1_ June 15, 2013\n"
+        + " * _1.2_ August 11, 2013\n";
+
+    OkHttpClient client = new OkHttpClient();
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(RequestBody.create(mediaType, postBody))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public void postFile() throws Exception {
+    MediaType mediaType = MediaType.parse("text/x-markdown; charset=utf-8");
+    File file = new File("README.md");
+
+    OkHttpClient client = new OkHttpClient();
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(RequestBody.create(mediaType, file))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public void postStreaming() throws Exception {
+    RequestBody requestBody = new RequestBody() {
+      MediaType mediaType = MediaType.parse("text/x-markdown; charset=utf-8");
+
+      @Override public MediaType contentType() {
+        return mediaType;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("Numbers\n");
+        sink.writeUtf8("-------\n");
+        for (int i = 2; i <= 997; i++) {
+          sink.writeUtf8(String.format(" * %s = %s\n", i, factor(i)));
+        }
+      }
+
+      private String factor(int n) {
+        for (int i = 2; i < n; i++) {
+          int x = n / i;
+          if (x * i == n) return factor(x) + "  " + i;
+        }
+        return Integer.toString(n);
+      }
+    };
+
+    OkHttpClient client = new OkHttpClient();
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(requestBody)
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
   public static void main(String[] args) throws Exception {
     Recipes recipes = new Recipes();
     recipes.getResponseSynchronously();
     recipes.getResponseAsynchronously();
     recipes.parseResponseWithGson();
     recipes.cacheResponse();
+    recipes.postString();
+    recipes.postFile();
+    recipes.postStreaming();
   }
 }
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft12Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft12Test.java
index 13a6618..bf2b43a 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft12Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft12Test.java
@@ -70,6 +70,8 @@
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBytes);
 
+    assertEquals(frame, sendHeaderFrames(true, sentHeaders)); // Check writer sends the same bytes.
+
     fr.nextFrame(new BaseTestHandler() {
       @Override
       public void headers(boolean outFinished, boolean inFinished, int streamId,
@@ -119,15 +121,16 @@
 
   /** Headers are compressed, then framed. */
   @Test public void headersFrameThenContinuation() throws IOException {
-    // Decoding the first header will cross frame boundaries.
-    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+    final List<Header> sentHeaders = largeHeaders();
+
+    Buffer headerBlock = literalHeaders(sentHeaders);
 
     // Write the first headers frame.
-    frame.writeShort((int) (headerBlock.size() / 2));
+    frame.writeShort(Http20Draft12.MAX_FRAME_SIZE);
     frame.writeByte(Http20Draft12.TYPE_HEADERS);
     frame.writeByte(0); // no flags
     frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.write(headerBlock, headerBlock.size() / 2);
+    frame.write(headerBlock, Http20Draft12.MAX_FRAME_SIZE);
 
     // Write the continuation frame, specifying no more frames are expected.
     frame.writeShort((int) headerBlock.size());
@@ -136,6 +139,8 @@
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBlock);
 
+    assertEquals(frame, sendHeaderFrames(false, sentHeaders)); // Check writer sends the same bytes.
+
     // Reading the above frames should result in a concatenated headerBlock.
     fr.nextFrame(new BaseTestHandler() {
       @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
@@ -144,7 +149,7 @@
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
-        assertEquals(headerEntries("foo", "barrr", "baz", "qux"), headerBlock);
+        assertEquals(sentHeaders, headerBlock);
         assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     });
@@ -169,6 +174,8 @@
     frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
     frame.writeAll(headerBytes);
 
+    assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
+
     fr.nextFrame(new BaseTestHandler() {
       @Override
       public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
@@ -182,31 +189,27 @@
   /** Headers are compressed, then framed. */
   @Test public void pushPromiseThenContinuation() throws IOException {
     final int expectedPromisedStreamId = 11;
-
-    final List<Header> pushPromise = Arrays.asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/")
-    );
+    final List<Header> pushPromise = largeHeaders();
 
     // Decoding the first header will cross frame boundaries.
     Buffer headerBlock = literalHeaders(pushPromise);
-    int firstFrameLength = (int) (headerBlock.size() - 1);
+
     // Write the first headers frame.
-    frame.writeShort(firstFrameLength + 4);
+    frame.writeShort(Http20Draft12.MAX_FRAME_SIZE);
     frame.writeByte(Http20Draft12.TYPE_PUSH_PROMISE);
     frame.writeByte(0); // no flags
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
-    frame.write(headerBlock, firstFrameLength);
+    frame.write(headerBlock, 16379);
 
     // Write the continuation frame, specifying no more frames are expected.
-    frame.writeShort(1);
+    frame.writeShort((int) headerBlock.size());
     frame.writeByte(Http20Draft12.TYPE_CONTINUATION);
     frame.writeByte(FLAG_END_HEADERS);
     frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.write(headerBlock, 1);
+    frame.writeAll(headerBlock);
+
+    assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
 
     // Reading the above frames should result in a concatenated headerBlock.
     fr.nextFrame(new BaseTestHandler() {
@@ -330,7 +333,7 @@
   }
 
   @Test public void maxLengthDataFrame() throws IOException {
-    final byte[] expectedData = new byte[16383];
+    final byte[] expectedData = new byte[Http20Draft12.MAX_FRAME_SIZE];
     Arrays.fill(expectedData, (byte) 2);
 
     frame.writeShort(expectedData.length);
@@ -347,7 +350,7 @@
           int length) throws IOException {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
-        assertEquals(16383, length);
+        assertEquals(Http20Draft12.MAX_FRAME_SIZE, length);
         ByteString data = source.readByteString(length);
         for (byte b : data.toByteArray()) {
           assertEquals(2, b);
@@ -358,7 +361,7 @@
 
   /** We do not send SETTINGS_COMPRESS_DATA = 1, nor want to. Let's make sure we error. */
   @Test public void compressedDataFrameWhenSettingDisabled() throws IOException {
-    byte[] expectedData = new byte[16383];
+    byte[] expectedData = new byte[Http20Draft12.MAX_FRAME_SIZE];
     Arrays.fill(expectedData, (byte) 2);
     Buffer zipped = gzip(expectedData);
     int zippedSize = (int) zipped.size();
@@ -455,7 +458,7 @@
   }
 
   /**
-   * Padding is encoded over 2 bytes, so maximum value is 65535, but maximum frame size is 16383.
+   * Padding is encoded over 2 bytes, so maximum value is 65535, but maximum frame size is Http20Draft12.MAX_FRAME_SIZE.
    */
   @Test public void readPaddedDataFrameWithTooMuchPadding() throws IOException {
     int dataLength = 1123;
@@ -546,7 +549,7 @@
   }
 
   /**
-   * Padding is encoded over 2 bytes, so maximum value is 65535, but maximum frame size is 16383.
+   * Padding is encoded over 2 bytes, so maximum value is 65535, but maximum frame size is Http20Draft12.MAX_FRAME_SIZE.
    */
   @Test public void readPaddedHeadersFrameWithTooMuchPadding() throws IOException {
     byte[] padding = new byte[0xffff];
@@ -674,7 +677,7 @@
   }
 
   /**
-   * Padding is encoded over 2 bytes, so maximum value is 65535, but maximum frame size is 16383.
+   * Padding is encoded over 2 bytes, so maximum value is 65535, but maximum frame size is Http20Draft12.MAX_FRAME_SIZE.
    */
   @Test public void readPaddedContinuationFrameWithTooMuchPadding() throws IOException {
     byte[] padding = new byte[0xffff];
@@ -817,7 +820,7 @@
     try {
       int streamId = 3;
       streamId |= 1L << 31; // set reserved bit
-      writer.frameHeader(streamId, 16383, Http20Draft12.TYPE_DATA, FLAG_NONE);
+      writer.frameHeader(streamId, Http20Draft12.MAX_FRAME_SIZE, Http20Draft12.TYPE_DATA, FLAG_NONE);
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("reserved bit set: -2147483645", e.getMessage());
@@ -911,6 +914,18 @@
     return out;
   }
 
+  private Buffer sendHeaderFrames(boolean outFinished, List<Header> headers) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft12.Writer(out, true).headers(outFinished, expectedStreamId, headers);
+    return out;
+  }
+
+  private Buffer sendPushPromiseFrames(int streamId, List<Header> headers) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft12.Writer(out, true).pushPromise(expectedStreamId, streamId, headers);
+    return out;
+  }
+
   private Buffer sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
     Buffer out = new Buffer();
     new Http20Draft12.Writer(out, true).ping(ack, payload1, payload2);
@@ -971,4 +986,15 @@
     Okio.buffer(new GzipSink(buffer)).write(data).close();
     return buffer;
   }
+
+  /** Create a sufficiently large header set to overflow Http20Draft12.MAX_FRAME_SIZE bytes. */
+  private static List<Header> largeHeaders() {
+    String[] nameValues = new String[32];
+    char[] chars = new char[512];
+    for (int i = 0; i < nameValues.length;) {
+      Arrays.fill(chars, (char) i);
+      nameValues[i++] = nameValues[i++] = String.valueOf(chars);
+    }
+    return headerEntries(nameValues);
+  }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft12.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft12.java
index cdad14c..887a93a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft12.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft12.java
@@ -45,6 +45,8 @@
   private static final ByteString CONNECTION_PREFACE
       = ByteString.encodeUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n");
 
+  static final int MAX_FRAME_SIZE = 0x3fff; // 16383
+
   static final byte TYPE_DATA = 0x0;
   static final byte TYPE_HEADERS = 0x1;
   static final byte TYPE_PRIORITY = 0x2;
@@ -82,7 +84,7 @@
   }
 
   @Override public int maxFrameSize() {
-    return 16383;
+    return MAX_FRAME_SIZE;
   }
 
   static final class Reader implements FrameReader {
@@ -120,7 +122,7 @@
       }
 
       // boolean r = (w1 & 0xc0000000) != 0; // Reserved: Ignore first 2 bits.
-      short length = (short) ((w1 & 0x3fff0000) >> 16); // 14-bit unsigned == max 16383
+      short length = (short) ((w1 & 0x3fff0000) >> 16); // 14-bit unsigned == MAX_FRAME_SIZE
       byte type = (byte) ((w1 & 0xff00) >> 8);
       byte flags = (byte) (w1 & 0xff);
       // boolean r = (w2 & 0x80000000) != 0; // Reserved: Ignore first bit.
@@ -432,26 +434,40 @@
       if (hpackBuffer.size() != 0) throw new IllegalStateException();
       hpackWriter.writeHeaders(requestHeaders);
 
-      int length = (int) (4 + hpackBuffer.size());
+      long byteCount = hpackBuffer.size();
+      int length = (int) Math.min(MAX_FRAME_SIZE - 4, byteCount);
       byte type = TYPE_PUSH_PROMISE;
-      byte flags = FLAG_END_HEADERS;
-      frameHeader(streamId, length, type, flags); // TODO: CONTINUATION
+      byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
+      frameHeader(streamId, length + 4, type, flags);
       sink.writeInt(promisedStreamId & 0x7fffffff);
-      sink.writeAll(hpackBuffer);
+      sink.write(hpackBuffer, length);
+
+      if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
     }
 
-    private void headers(boolean outFinished, int streamId, List<Header> headerBlock)
-        throws IOException {
+    void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
       if (closed) throw new IOException("closed");
       if (hpackBuffer.size() != 0) throw new IllegalStateException();
       hpackWriter.writeHeaders(headerBlock);
 
-      int length = (int) hpackBuffer.size();
+      long byteCount = hpackBuffer.size();
+      int length = (int) Math.min(MAX_FRAME_SIZE, byteCount);
       byte type = TYPE_HEADERS;
-      byte flags = FLAG_END_HEADERS;
+      byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
       if (outFinished) flags |= FLAG_END_STREAM;
-      frameHeader(streamId, length, type, flags); // TODO: CONTINUATION
-      sink.writeAll(hpackBuffer);
+      frameHeader(streamId, length, type, flags);
+      sink.write(hpackBuffer, length);
+
+      if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+    }
+
+    private void writeContinuationFrames(int streamId, long byteCount) throws IOException {
+      while (byteCount > 0) {
+        int length = (int) Math.min(MAX_FRAME_SIZE, byteCount);
+        byteCount -= length;
+        frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);
+        sink.write(hpackBuffer, length);
+      }
     }
 
     @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
@@ -558,7 +574,9 @@
 
     void frameHeader(int streamId, int length, byte type, byte flags) throws IOException {
       if (logger.isLoggable(FINE)) logger.fine(formatHeader(false, streamId, length, type, flags));
-      if (length > 16383) throw illegalArgument("FRAME_SIZE_ERROR length > 16383: %s", length);
+      if (length > MAX_FRAME_SIZE) {
+        throw illegalArgument("FRAME_SIZE_ERROR length > %d: %d", MAX_FRAME_SIZE, length);
+      }
       if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
       sink.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
       sink.writeInt(streamId & 0x7fffffff);
@@ -640,7 +658,9 @@
     } else if ((flags & FLAG_PAD_LOW) != 0) {
       padding = source.readByte() & 0xff;
     }
-    if (padding > 16383) throw ioException("PROTOCOL_ERROR padding > 16383: %s", padding);
+    if (padding > MAX_FRAME_SIZE) {
+      throw ioException("PROTOCOL_ERROR padding > %d: %d", MAX_FRAME_SIZE, padding);
+    }
     return (short) padding;
   }
 
/Fim/
diff --git a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
index 4cc8c41..b3ceb7f 100644
--- a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
+++ b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
@@ -25,7 +25,8 @@
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.http.StatusLine;
-import com.squareup.okhttp.internal.spdy.Http20Draft12;
+import com.squareup.okhttp.internal.spdy.Http20Draft13;
+
 import io.airlift.command.Arguments;
 import io.airlift.command.Command;
 import io.airlift.command.HelpOption;
@@ -265,7 +266,7 @@
   }
 
   private static void enableHttp2FrameLogging() {
-    Logger logger = Logger.getLogger(Http20Draft12.class.getName());
+    Logger logger = Logger.getLogger(Http20Draft13.class.getName());
     logger.setLevel(Level.FINE);
     ConsoleHandler handler = new ConsoleHandler();
     handler.setLevel(Level.FINE);
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft12Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft13Test.java
similarity index 96%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft12Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft13Test.java
index 5ac3b11..b78fd10 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft12Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft13Test.java
@@ -24,9 +24,9 @@
 
 import static org.junit.Assert.assertEquals;
 
-public class HttpOverHttp20Draft12Test extends HttpOverSpdyTest {
+public class HttpOverHttp20Draft13Test extends HttpOverSpdyTest {
 
-  public HttpOverHttp20Draft12Test() {
+  public HttpOverHttp20Draft13Test() {
     super(Protocol.HTTP_2);
     this.hostHeader = ":authority";
   }
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft07Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft08Test.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft07Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft08Test.java
index 6bff540..2b74c8d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft07Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft08Test.java
@@ -30,23 +30,23 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-public class HpackDraft07Test {
+public class HpackDraft08Test {
 
   private final Buffer bytesIn = new Buffer();
-  private HpackDraft07.Reader hpackReader;
+  private HpackDraft08.Reader hpackReader;
   private Buffer bytesOut = new Buffer();
-  private HpackDraft07.Writer hpackWriter;
+  private HpackDraft08.Writer hpackWriter;
 
   @Before public void reset() {
     hpackReader = newReader(bytesIn);
-    hpackWriter = new HpackDraft07.Writer(bytesOut);
+    hpackWriter = new HpackDraft08.Writer(bytesOut);
   }
 
   /**
    * Variable-length quantity special cases strings which are longer than 127
    * bytes.  Values such as cookies can be 4KiB, and should be possible to send.
    *
-   * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#section-4.1.1
+   * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#section-4.1.1
    */
   @Test public void largeHeaderValue() throws IOException {
     char[] value = new char[4096];
@@ -157,7 +157,7 @@
                              // Indexed name (idx = 4) -> :path
     bytesIn.writeByte(0x8c); // Literal value Huffman encoded 12 bytes
                              // decodes to www.example.com which is length 15
-    bytesIn.write(decodeHex("e7cf9bebe89b6fb16fa9b6ff"));
+    bytesIn.write(decodeHex("f1e3c2e5f23a6ba0ab90f4ff"));
 
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
@@ -171,7 +171,7 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#appendix-D.1.1
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#appendix-D.1.1
    */
   @Test public void readLiteralHeaderFieldWithIndexing() throws IOException {
     bytesIn.writeByte(0x40); // Literal indexed
@@ -195,7 +195,7 @@
   }
 
   /**
-   * https://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#appendix-D.2.2
+   * https://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#appendix-D.2.2
    */
   @Test public void literalHeaderFieldWithoutIndexingIndexedName() throws IOException {
     List<Header> headerBlock = headerEntries(":path", "/sample/path");
@@ -268,7 +268,7 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#appendix-D.1.3
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#appendix-D.1.3
    */
   @Test public void readIndexedHeaderField() throws IOException {
     bytesIn.writeByte(0x82); // == Indexed - Add ==
@@ -379,7 +379,7 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#section-3.2.1
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#section-3.2.1
    */
   @Test public void toggleIndex() throws IOException {
     // Static table entries are copied to the top of the reference set.
@@ -444,7 +444,7 @@
   }
 
   /**
-   * https://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#appendix-D.2.4
+   * https://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#appendix-D.2.4
    */
   @Test public void readIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
     bytesIn.writeByte(0x82); // == Indexed - Add ==
@@ -461,7 +461,7 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#appendix-D.2
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#appendix-D.2
    */
   @Test public void readRequestExamplesWithoutHuffman() throws IOException {
     firstRequestWithoutHuffman();
@@ -648,7 +648,7 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#appendix-D.3
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#appendix-D.3
    */
   @Test public void readRequestExamplesWithHuffman() throws IOException {
     firstRequestWithHuffman();
@@ -676,9 +676,9 @@
                              // idx = 6 -> :path: /
     bytesIn.writeByte(0x44); // == Literal indexed ==
                              // Indexed name (idx = 4) -> :authority
-    bytesIn.writeByte(0x8c); // Literal value Huffman encoded 12 bytes
+    bytesIn.writeByte(0x0f); // Literal value Huffman encoded 12 bytes
                              // decodes to www.example.com which is length 15
-    bytesIn.write(decodeHex("e7cf9bebe89b6fb16fa9b6ff"));
+    bytesIn.write(decodeHex("7777772e6578616d706c652e636f6d"));
   }
 
   private void checkReadFirstRequestWithHuffman() {
@@ -720,7 +720,7 @@
                              // Indexed name (idx = 28) -> cache-control
     bytesIn.writeByte(0x86); // Literal value Huffman encoded 6 bytes
                              // decodes to no-cache which is length 8
-    bytesIn.write(decodeHex("b9b9949556bf"));
+    bytesIn.write(decodeHex("a8eb10649cbf"));
   }
 
   private void checkReadSecondRequestWithHuffman() {
@@ -776,10 +776,10 @@
     bytesIn.writeByte(0x40); // Literal indexed
     bytesIn.writeByte(0x88); // Literal name Huffman encoded 8 bytes
                              // decodes to custom-key which is length 10
-    bytesIn.write(decodeHex("571c5cdb737b2faf"));
-    bytesIn.writeByte(0x89); // Literal value Huffman encoded 6 bytes
+    bytesIn.write(decodeHex("25a849e95ba97d7f"));
+    bytesIn.writeByte(0x89); // Literal value Huffman encoded 9 bytes
                              // decodes to custom-value which is length 12
-    bytesIn.write(decodeHex("571c5cdb73724d9c57"));
+    bytesIn.write(decodeHex("25a849e95bb8e8b4bf"));
   }
 
   private void checkReadThirdRequestWithHuffman() {
@@ -906,8 +906,8 @@
     assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString());
   }
 
-  private HpackDraft07.Reader newReader(Buffer source) {
-    return new HpackDraft07.Reader(4096, source);
+  private HpackDraft08.Reader newReader(Buffer source) {
+    return new HpackDraft08.Reader(4096, source);
   }
 
   private Buffer byteStream(int... bytes) {
/Fim/
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft12FrameLoggerTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft13FrameLoggerTest.java
similarity index 70%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft12FrameLoggerTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft13FrameLoggerTest.java
index d0ebd53..3ab2ca3 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft12FrameLoggerTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft13FrameLoggerTest.java
@@ -20,22 +20,22 @@
 import java.util.List;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.spdy.Http20Draft12.FLAG_ACK;
-import static com.squareup.okhttp.internal.spdy.Http20Draft12.FLAG_END_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Http20Draft12.FLAG_END_STREAM;
-import static com.squareup.okhttp.internal.spdy.Http20Draft12.FLAG_NONE;
-import static com.squareup.okhttp.internal.spdy.Http20Draft12.FrameLogger.formatFlags;
-import static com.squareup.okhttp.internal.spdy.Http20Draft12.FrameLogger.formatHeader;
-import static com.squareup.okhttp.internal.spdy.Http20Draft12.TYPE_CONTINUATION;
-import static com.squareup.okhttp.internal.spdy.Http20Draft12.TYPE_DATA;
-import static com.squareup.okhttp.internal.spdy.Http20Draft12.TYPE_GOAWAY;
-import static com.squareup.okhttp.internal.spdy.Http20Draft12.TYPE_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Http20Draft12.TYPE_PING;
-import static com.squareup.okhttp.internal.spdy.Http20Draft12.TYPE_PUSH_PROMISE;
-import static com.squareup.okhttp.internal.spdy.Http20Draft12.TYPE_SETTINGS;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_ACK;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_END_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_END_STREAM;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_NONE;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FrameLogger.formatFlags;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FrameLogger.formatHeader;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.TYPE_CONTINUATION;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.TYPE_DATA;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.TYPE_GOAWAY;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.TYPE_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.TYPE_PING;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.TYPE_PUSH_PROMISE;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.TYPE_SETTINGS;
 import static org.junit.Assert.assertEquals;
 
-public class Http20Draft12FrameLoggerTest {
+public class Http20Draft13FrameLoggerTest {
 
   /** Real stream traffic applied to the log format. */
   @Test public void exampleStream() {
@@ -103,14 +103,14 @@
         "END_STREAM|END_HEADERS",
         "END_SEGMENT|END_HEADERS",
         "END_STREAM|END_SEGMENT|END_HEADERS",
-        "PAD_LOW",
-        "END_STREAM|PAD_LOW",
-        "END_SEGMENT|PAD_LOW",
-        "END_STREAM|END_SEGMENT|PAD_LOW",
+        "PADDED",
+        "END_STREAM|PADDED",
+        "END_SEGMENT|PADDED",
+        "END_STREAM|END_SEGMENT|PADDED",
         "00001100",
-        "END_STREAM|END_HEADERS|PAD_LOW",
-        "END_SEGMENT|END_HEADERS|PAD_LOW",
-        "END_STREAM|END_SEGMENT|END_HEADERS|PAD_LOW",
+        "END_STREAM|END_HEADERS|PADDED",
+        "END_SEGMENT|END_HEADERS|PADDED",
+        "END_STREAM|END_SEGMENT|END_HEADERS|PADDED",
         "00010000",
         "00010001",
         "00010010",
@@ -119,14 +119,14 @@
         "00010101",
         "00010110",
         "00010111",
-        "PAD_LOW|PAD_HIGH",
-        "END_STREAM|PAD_LOW|PAD_HIGH",
-        "END_SEGMENT|PAD_LOW|PAD_HIGH",
-        "END_STREAM|END_SEGMENT|PAD_LOW|PAD_HIGH",
+        "00011000",
+        "00011001",
+        "00011010",
+        "00011011",
         "00011100",
-        "END_STREAM|END_HEADERS|PAD_LOW|PAD_HIGH",
-        "END_SEGMENT|END_HEADERS|PAD_LOW|PAD_HIGH",
-        "END_STREAM|END_SEGMENT|END_HEADERS|PAD_LOW|PAD_HIGH",
+        "00011101",
+        "00011110",
+        "00011111",
         "PRIORITY",
         "END_STREAM|PRIORITY",
         "END_SEGMENT|PRIORITY",
@@ -136,13 +136,13 @@
         "END_SEGMENT|END_HEADERS|PRIORITY",
         "END_STREAM|END_SEGMENT|END_HEADERS|PRIORITY",
         "00101000",
-        "END_STREAM|PRIORITY|PAD_LOW",
-        "END_SEGMENT|PRIORITY|PAD_LOW",
-        "END_STREAM|END_SEGMENT|PRIORITY|PAD_LOW",
+        "END_STREAM|PRIORITY|PADDED",
+        "END_SEGMENT|PRIORITY|PADDED",
+        "END_STREAM|END_SEGMENT|PRIORITY|PADDED",
         "00101100",
-        "END_STREAM|END_HEADERS|PRIORITY|PAD_LOW",
-        "END_SEGMENT|END_HEADERS|PRIORITY|PAD_LOW",
-        "END_STREAM|END_SEGMENT|END_HEADERS|PRIORITY|PAD_LOW",
+        "END_STREAM|END_HEADERS|PRIORITY|PADDED",
+        "END_SEGMENT|END_HEADERS|PRIORITY|PADDED",
+        "END_STREAM|END_SEGMENT|END_HEADERS|PRIORITY|PADDED",
         "00110000",
         "00110001",
         "00110010",
@@ -152,13 +152,13 @@
         "00110110",
         "00110111",
         "00111000",
-        "END_STREAM|PRIORITY|PAD_LOW|PAD_HIGH",
-        "END_SEGMENT|PRIORITY|PAD_LOW|PAD_HIGH",
-        "END_STREAM|END_SEGMENT|PRIORITY|PAD_LOW|PAD_HIGH",
+        "00111001",
+        "00111010",
+        "00111011",
         "00111100",
-        "END_STREAM|END_HEADERS|PRIORITY|PAD_LOW|PAD_HIGH",
-        "END_SEGMENT|END_HEADERS|PRIORITY|PAD_LOW|PAD_HIGH",
-        "END_STREAM|END_SEGMENT|END_HEADERS|PRIORITY|PAD_LOW|PAD_HIGH"
+        "00111101",
+        "00111110",
+        "00111111"
     ), formattedFlags);
   }
 }
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft13Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft13Test.java
new file mode 100644
index 0000000..4f626fa
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft13Test.java
@@ -0,0 +1,679 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+
+import com.squareup.okhttp.internal.Util;
+
+import org.junit.Test;
+
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.GzipSink;
+import okio.Okio;
+import static com.squareup.okhttp.internal.Util.headerEntries;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_COMPRESSED;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_END_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_END_STREAM;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_NONE;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_PADDED;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_PRIORITY;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class Http20Draft13Test {
+  final Buffer frame = new Buffer();
+  final FrameReader fr = new Http20Draft13.Reader(frame, 4096, false);
+  final int expectedStreamId = 15;
+
+  @Test public void unknownFrameTypeSkipped() throws IOException {
+    frame.writeShort(4); // has a 4-byte field
+    frame.writeByte(99); // type 99
+    frame.writeByte(0); // no flags
+    frame.writeInt(expectedStreamId);
+    frame.writeInt(111111111); // custom data
+
+    fr.nextFrame(new BaseTestHandler()); // Should not callback.
+  }
+
+  @Test public void onlyOneLiteralHeadersFrame() throws IOException {
+    final List<Header> sentHeaders = headerEntries("name", "value");
+
+    Buffer headerBytes = literalHeaders(sentHeaders);
+    frame.writeShort((int) headerBytes.size());
+    frame.writeByte(Http20Draft13.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_END_STREAM);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBytes);
+
+    assertEquals(frame, sendHeaderFrames(true, sentHeaders)); // Check writer sends the same bytes.
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override
+      public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertTrue(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(sentHeaders, headerBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  @Test public void headersWithPriority() throws IOException {
+    final List<Header> sentHeaders = headerEntries("name", "value");
+
+    Buffer headerBytes = literalHeaders(sentHeaders);
+    frame.writeShort((int) (headerBytes.size() + 5));
+    frame.writeByte(Http20Draft13.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_PRIORITY);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(0); // Independent stream.
+    frame.writeByte(255); // Heaviest weight, zero-indexed.
+    frame.writeAll(headerBytes);
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void priority(int streamId, int streamDependency, int weight,
+          boolean exclusive) {
+        assertEquals(0, streamDependency);
+        assertEquals(256, weight);
+        assertFalse(exclusive);
+      }
+
+      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> nameValueBlock,
+          HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(sentHeaders, nameValueBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void headersFrameThenContinuation() throws IOException {
+    final List<Header> sentHeaders = largeHeaders();
+
+    Buffer headerBlock = literalHeaders(sentHeaders);
+
+    // Write the first headers frame.
+    frame.writeShort(Http20Draft13.MAX_FRAME_SIZE);
+    frame.writeByte(Http20Draft13.TYPE_HEADERS);
+    frame.writeByte(0); // no flags
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.write(headerBlock, Http20Draft13.MAX_FRAME_SIZE);
+
+    // Write the continuation frame, specifying no more frames are expected.
+    frame.writeShort((int) headerBlock.size());
+    frame.writeByte(Http20Draft13.TYPE_CONTINUATION);
+    frame.writeByte(FLAG_END_HEADERS);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBlock);
+
+    assertEquals(frame, sendHeaderFrames(false, sentHeaders)); // Check writer sends the same bytes.
+
+    // Reading the above frames should result in a concatenated headerBlock.
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(sentHeaders, headerBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  @Test public void pushPromise() throws IOException {
+    final int expectedPromisedStreamId = 11;
+
+    final List<Header> pushPromise = Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/")
+    );
+
+    // Write the push promise frame, specifying the associated stream ID.
+    Buffer headerBytes = literalHeaders(pushPromise);
+    frame.writeShort((int) (headerBytes.size() + 4));
+    frame.writeByte(Http20Draft13.TYPE_PUSH_PROMISE);
+    frame.writeByte(Http20Draft13.FLAG_END_PUSH_PROMISE);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
+    frame.writeAll(headerBytes);
+
+    assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override
+      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedPromisedStreamId, promisedStreamId);
+        assertEquals(pushPromise, headerBlock);
+      }
+    });
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void pushPromiseThenContinuation() throws IOException {
+    final int expectedPromisedStreamId = 11;
+    final List<Header> pushPromise = largeHeaders();
+
+    // Decoding the first header will cross frame boundaries.
+    Buffer headerBlock = literalHeaders(pushPromise);
+
+    // Write the first headers frame.
+    frame.writeShort(Http20Draft13.MAX_FRAME_SIZE);
+    frame.writeByte(Http20Draft13.TYPE_PUSH_PROMISE);
+    frame.writeByte(0); // no flags
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
+    frame.write(headerBlock, 16379);
+
+    // Write the continuation frame, specifying no more frames are expected.
+    frame.writeShort((int) headerBlock.size());
+    frame.writeByte(Http20Draft13.TYPE_CONTINUATION);
+    frame.writeByte(FLAG_END_HEADERS);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBlock);
+
+    assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
+
+    // Reading the above frames should result in a concatenated headerBlock.
+    fr.nextFrame(new BaseTestHandler() {
+      @Override
+      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedPromisedStreamId, promisedStreamId);
+        assertEquals(pushPromise, headerBlock);
+      }
+    });
+  }
+
+  @Test public void readRstStreamFrame() throws IOException {
+    frame.writeShort(4);
+    frame.writeByte(Http20Draft13.TYPE_RST_STREAM);
+    frame.writeByte(0); // No flags
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void rstStream(int streamId, ErrorCode errorCode) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(ErrorCode.COMPRESSION_ERROR, errorCode);
+      }
+    });
+  }
+
+  @Test public void readSettingsFrame() throws IOException {
+    final int reducedTableSizeBytes = 16;
+
+    frame.writeShort(12); // 2 settings * 6 bytes (2 for the code and 4 for the value).
+    frame.writeByte(Http20Draft13.TYPE_SETTINGS);
+    frame.writeByte(0); // No flags
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(1); // SETTINGS_HEADER_TABLE_SIZE
+    frame.writeInt(reducedTableSizeBytes);
+    frame.writeShort(2); // SETTINGS_ENABLE_PUSH
+    frame.writeInt(0);
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void settings(boolean clearPrevious, Settings settings) {
+        assertFalse(clearPrevious); // No clearPrevious in HTTP/2.
+        assertEquals(reducedTableSizeBytes, settings.getHeaderTableSize());
+        assertEquals(false, settings.getEnablePush(true));
+      }
+    });
+  }
+
+  @Test public void readSettingsFrameInvalidPushValue() throws IOException {
+    frame.writeShort(6); // 2 for the code and 4 for the value
+    frame.writeByte(Http20Draft13.TYPE_SETTINGS);
+    frame.writeByte(0); // No flags
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(2);
+    frame.writeInt(2);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1", e.getMessage());
+    }
+  }
+
+  @Test public void readSettingsFrameInvalidSettingId() throws IOException {
+    frame.writeShort(6); // 2 for the code and 4 for the value
+    frame.writeByte(Http20Draft13.TYPE_SETTINGS);
+    frame.writeByte(0); // No flags
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(7); // old number for SETTINGS_INITIAL_WINDOW_SIZE
+    frame.writeInt(1);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR invalid settings id: 7", e.getMessage());
+    }
+  }
+
+  @Test public void readSettingsFrameNegativeWindowSize() throws IOException {
+    frame.writeShort(6); // 2 for the code and 4 for the value
+    frame.writeByte(Http20Draft13.TYPE_SETTINGS);
+    frame.writeByte(0); // No flags
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(4); // SETTINGS_INITIAL_WINDOW_SIZE
+    frame.writeInt(Integer.MIN_VALUE);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1", e.getMessage());
+    }
+  }
+
+  @Test public void pingRoundTrip() throws IOException {
+    final int expectedPayload1 = 7;
+    final int expectedPayload2 = 8;
+
+    frame.writeShort(8); // length
+    frame.writeByte(Http20Draft13.TYPE_PING);
+    frame.writeByte(Http20Draft13.FLAG_ACK);
+    frame.writeInt(0); // connection-level
+    frame.writeInt(expectedPayload1);
+    frame.writeInt(expectedPayload2);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendPingFrame(true, expectedPayload1, expectedPayload2));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void ping(boolean ack, int payload1, int payload2) {
+        assertTrue(ack);
+        assertEquals(expectedPayload1, payload1);
+        assertEquals(expectedPayload2, payload2);
+      }
+    });
+  }
+
+  @Test public void maxLengthDataFrame() throws IOException {
+    final byte[] expectedData = new byte[Http20Draft13.MAX_FRAME_SIZE];
+    Arrays.fill(expectedData, (byte) 2);
+
+    frame.writeShort(expectedData.length);
+    frame.writeByte(Http20Draft13.TYPE_DATA);
+    frame.writeByte(0); // no flags
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.write(expectedData);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendDataFrame(new Buffer().write(expectedData)));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void data(boolean inFinished, int streamId, BufferedSource source,
+          int length) throws IOException {
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(Http20Draft13.MAX_FRAME_SIZE, length);
+        ByteString data = source.readByteString(length);
+        for (byte b : data.toByteArray()) {
+          assertEquals(2, b);
+        }
+      }
+    });
+  }
+
+  /** We do not send SETTINGS_COMPRESS_DATA = 1, nor want to. Let's make sure we error. */
+  @Test public void compressedDataFrameWhenSettingDisabled() throws IOException {
+    byte[] expectedData = new byte[Http20Draft13.MAX_FRAME_SIZE];
+    Arrays.fill(expectedData, (byte) 2);
+    Buffer zipped = gzip(expectedData);
+    int zippedSize = (int) zipped.size();
+
+    frame.writeShort(zippedSize);
+    frame.writeByte(Http20Draft13.TYPE_DATA);
+    frame.writeByte(FLAG_COMPRESSED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    zipped.readAll(frame);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA",
+          e.getMessage());
+    }
+  }
+
+  @Test public void readPaddedDataFrame() throws IOException {
+    int dataLength = 1123;
+    byte[] expectedData = new byte[dataLength];
+    Arrays.fill(expectedData, (byte) 2);
+
+    int paddingLength = 254;
+    byte[] padding = new byte[paddingLength];
+    Arrays.fill(padding, (byte) 0);
+
+    frame.writeShort(dataLength + paddingLength + 1);
+    frame.writeByte(Http20Draft13.TYPE_DATA);
+    frame.writeByte(FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(paddingLength);
+    frame.write(expectedData);
+    frame.write(padding);
+
+    fr.nextFrame(assertData());
+    assertTrue(frame.exhausted()); // Padding was skipped.
+  }
+
+  @Test public void readPaddedDataFrameZeroPadding() throws IOException {
+    int dataLength = 1123;
+    byte[] expectedData = new byte[dataLength];
+    Arrays.fill(expectedData, (byte) 2);
+
+    frame.writeShort(dataLength + 1);
+    frame.writeByte(Http20Draft13.TYPE_DATA);
+    frame.writeByte(FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(0);
+    frame.write(expectedData);
+
+    fr.nextFrame(assertData());
+  }
+
+  @Test public void readPaddedHeadersFrame() throws IOException {
+    int paddingLength = 254;
+    byte[] padding = new byte[paddingLength];
+    Arrays.fill(padding, (byte) 0);
+
+    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+    frame.writeShort((int) headerBlock.size() + paddingLength + 1);
+    frame.writeByte(Http20Draft13.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(paddingLength);
+    frame.writeAll(headerBlock);
+    frame.write(padding);
+
+    fr.nextFrame(assertHeaderBlock());
+    assertTrue(frame.exhausted()); // Padding was skipped.
+  }
+
+  @Test public void readPaddedHeadersFrameZeroPadding() throws IOException {
+    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+    frame.writeShort((int) headerBlock.size() + 1);
+    frame.writeByte(Http20Draft13.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(0);
+    frame.writeAll(headerBlock);
+
+    fr.nextFrame(assertHeaderBlock());
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void readPaddedHeadersFrameThenContinuation() throws IOException {
+    int paddingLength = 254;
+    byte[] padding = new byte[paddingLength];
+    Arrays.fill(padding, (byte) 0);
+
+    // Decoding the first header will cross frame boundaries.
+    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+
+    // Write the first headers frame.
+    frame.writeShort((int) (headerBlock.size() / 2) + paddingLength + 1);
+    frame.writeByte(Http20Draft13.TYPE_HEADERS);
+    frame.writeByte(FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(paddingLength);
+    frame.write(headerBlock, headerBlock.size() / 2);
+    frame.write(padding);
+
+    // Write the continuation frame, specifying no more frames are expected.
+    frame.writeShort((int) headerBlock.size());
+    frame.writeByte(Http20Draft13.TYPE_CONTINUATION);
+    frame.writeByte(FLAG_END_HEADERS);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBlock);
+
+    fr.nextFrame(assertHeaderBlock());
+    assertTrue(frame.exhausted());
+  }
+
+  @Test public void tooLargeDataFrame() throws IOException {
+    try {
+      sendDataFrame(new Buffer().write(new byte[0x1000000]));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("FRAME_SIZE_ERROR length > 16383: 16777216", e.getMessage());
+    }
+  }
+
+  @Test public void windowUpdateRoundTrip() throws IOException {
+    final long expectedWindowSizeIncrement = 0x7fffffff;
+
+    frame.writeShort(4); // length
+    frame.writeByte(Http20Draft13.TYPE_WINDOW_UPDATE);
+    frame.writeByte(0); // No flags.
+    frame.writeInt(expectedStreamId);
+    frame.writeInt((int) expectedWindowSizeIncrement);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, windowUpdate(expectedWindowSizeIncrement));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedWindowSizeIncrement, windowSizeIncrement);
+      }
+    });
+  }
+
+  @Test public void badWindowSizeIncrement() throws IOException {
+    try {
+      windowUpdate(0);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 0",
+          e.getMessage());
+    }
+    try {
+      windowUpdate(0x80000000L);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 2147483648",
+          e.getMessage());
+    }
+  }
+
+  @Test public void goAwayWithoutDebugDataRoundTrip() throws IOException {
+    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
+
+    frame.writeShort(8); // Without debug data there's only 2 32-bit fields.
+    frame.writeByte(Http20Draft13.TYPE_GOAWAY);
+    frame.writeByte(0); // no flags.
+    frame.writeInt(0); // connection-scope
+    frame.writeInt(expectedStreamId); // last good stream.
+    frame.writeInt(expectedError.httpCode);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void goAway(
+          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+        assertEquals(expectedStreamId, lastGoodStreamId);
+        assertEquals(expectedError, errorCode);
+        assertEquals(0, debugData.size());
+      }
+    });
+  }
+
+  @Test public void goAwayWithDebugDataRoundTrip() throws IOException {
+    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
+    final ByteString expectedData = ByteString.encodeUtf8("abcdefgh");
+
+    // Compose the expected GOAWAY frame without debug data.
+    frame.writeShort(8 + expectedData.size());
+    frame.writeByte(Http20Draft13.TYPE_GOAWAY);
+    frame.writeByte(0); // no flags.
+    frame.writeInt(0); // connection-scope
+    frame.writeInt(0); // never read any stream!
+    frame.writeInt(expectedError.httpCode);
+    frame.write(expectedData.toByteArray());
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendGoAway(0, expectedError, expectedData.toByteArray()));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void goAway(
+          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+        assertEquals(0, lastGoodStreamId);
+        assertEquals(expectedError, errorCode);
+        assertEquals(expectedData, debugData);
+      }
+    });
+  }
+
+  @Test public void frameSizeError() throws IOException {
+    Http20Draft13.Writer writer = new Http20Draft13.Writer(new Buffer(), true);
+
+    try {
+      writer.frameHeader(0, 16384, Http20Draft13.TYPE_DATA, FLAG_NONE);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("FRAME_SIZE_ERROR length > 16383: 16384", e.getMessage());
+    }
+  }
+
+  @Test public void streamIdHasReservedBit() throws IOException {
+    Http20Draft13.Writer writer = new Http20Draft13.Writer(new Buffer(), true);
+
+    try {
+      int streamId = 3;
+      streamId |= 1L << 31; // set reserved bit
+      writer.frameHeader(streamId, Http20Draft13.MAX_FRAME_SIZE, Http20Draft13.TYPE_DATA, FLAG_NONE);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("reserved bit set: -2147483645", e.getMessage());
+    }
+  }
+
+  private Buffer literalHeaders(List<Header> sentHeaders) throws IOException {
+    Buffer out = new Buffer();
+    new HpackDraft08.Writer(out).writeHeaders(sentHeaders);
+    return out;
+  }
+
+  private Buffer sendHeaderFrames(boolean outFinished, List<Header> headers) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft13.Writer(out, true).headers(outFinished, expectedStreamId, headers);
+    return out;
+  }
+
+  private Buffer sendPushPromiseFrames(int streamId, List<Header> headers) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft13.Writer(out, true).pushPromise(expectedStreamId, streamId, headers);
+    return out;
+  }
+
+  private Buffer sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft13.Writer(out, true).ping(ack, payload1, payload2);
+    return out;
+  }
+
+  private Buffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+      throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft13.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
+    return out;
+  }
+
+  private Buffer sendDataFrame(Buffer data) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft13.Writer(out, true).dataFrame(expectedStreamId, FLAG_NONE, data,
+        (int) data.size());
+    return out;
+  }
+
+  private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft13.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
+    return out;
+  }
+
+  private FrameReader.Handler assertHeaderBlock() {
+    return new BaseTestHandler() {
+      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(headerEntries("foo", "barrr", "baz", "qux"), headerBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    };
+  }
+
+  private FrameReader.Handler assertData() {
+    return new BaseTestHandler() {
+      @Override public void data(boolean inFinished, int streamId, BufferedSource source,
+          int length) throws IOException {
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(1123, length);
+        ByteString data = source.readByteString(length);
+        for (byte b : data.toByteArray()) {
+          assertEquals(2, b);
+        }
+      }
+    };
+  }
+
+  private static Buffer gzip(byte[] data) throws IOException {
+    Buffer buffer = new Buffer();
+    Okio.buffer(new GzipSink(buffer)).write(data).close();
+    return buffer;
+  }
+
+  /** Create a sufficiently large header set to overflow Http20Draft12.MAX_FRAME_SIZE bytes. */
+  private static List<Header> largeHeaders() {
+    String[] nameValues = new String[32];
+    char[] chars = new char[512];
+    for (int i = 0; i < nameValues.length;) {
+      Arrays.fill(chars, (char) i);
+      nameValues[i++] = nameValues[i++] = String.valueOf(chars);
+    }
+    return headerEntries(nameValues);
+  }
+}
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java
index e700dd6..5f25e48 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java
@@ -46,7 +46,7 @@
 import static org.junit.Assert.fail;
 
 public final class Http2ConnectionTest {
-  private static final Variant HTTP_2 = new Http20Draft12();
+  private static final Variant HTTP_2 = new Http20Draft13();
   private final MockSpdyPeer peer = new MockSpdyPeer();
 
   @After public void tearDown() throws Exception {
@@ -140,7 +140,7 @@
 
     // verify the peer's settings were read and applied.
     assertEquals(0, connection.peerSettings.getHeaderTableSize());
-    Http20Draft12.Reader frameReader = (Http20Draft12.Reader) connection.readerRunnable.frameReader;
+    Http20Draft13.Reader frameReader = (Http20Draft13.Reader) connection.readerRunnable.frameReader;
     assertEquals(0, frameReader.hpackReader.maxHeaderTableByteCount());
     // TODO: when supported, check the frameWriter's compression table is unaffected.
   }
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index 1002575..7e1823b 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -278,7 +278,7 @@
 
     @Override
     public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
-      this.type = Http20Draft12.TYPE_PUSH_PROMISE;
+      this.type = Http20Draft13.TYPE_PUSH_PROMISE;
       this.streamId = streamId;
       this.associatedStreamId = associatedStreamId;
       this.headerBlock = headerBlock;
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
index 3305663..a33b1d5 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
@@ -62,14 +62,9 @@
     settings.set(MAX_CONCURRENT_STREAMS, 0, 75);
     assertEquals(75, settings.getMaxConcurrentStreams(-3));
 
-    // WARNING: clash on flags between spdy/3 and HTTP/2!
     assertEquals(-3, settings.getCurrentCwnd(-3));
     settings.set(Settings.CURRENT_CWND, 0, 86);
     assertEquals(86, settings.getCurrentCwnd(-3));
-    settings.clear();
-    assertEquals(true, settings.getCompressData(true));
-    settings.set(Settings.COMPRESS_DATA, 0, 1);
-    assertEquals(true, settings.getCompressData(false));
 
     assertEquals(-3, settings.getDownloadRetransRate(-3));
     settings.set(DOWNLOAD_RETRANS_RATE, 0, 97);
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index 469b1f3..d52c68d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -399,11 +399,11 @@
    * <ul>
    *   <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
    *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
-   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-12">h2-12</a>
+   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-13">h2-13</a>
    * </ul>
    *
    * <p><strong>This is an evolving set.</strong> Future releases may drop
-   * support for transitional protocols (like h2-12), in favor of their
+   * support for transitional protocols (like h2-13), in favor of their
    * successors (h2). The http/1.1 transport will never be dropped.
    *
    * <p>If multiple protocols are specified, <a
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
index c2f426c..ddde627 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
@@ -63,13 +63,13 @@
    * HTTP/1.1 semantics are layered on HTTP/2.
    *
    * <p>This version of OkHttp implements HTTP/2 <a
-   * href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-12">draft 12</a>
+   * href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-13">draft 12</a>
    * with HPACK <a
-   * href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07">draft
+   * href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08">draft
    * 6</a>. Future releases of OkHttp may use this identifier for a newer draft
    * of these specs.
    */
-  HTTP_2("h2-12");
+  HTTP_2("h2-13");
 
   private final String protocol;
 
@@ -92,7 +92,7 @@
 
   /**
    * Returns the string used to identify this protocol for ALPN and NPN, like
-   * "http/1.1", "spdy/3.1" or "h2-12".
+   * "http/1.1", "spdy/3.1" or "h2-13".
    */
   @Override public String toString() {
     return protocol;
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
index 6d9c784..db30282 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
@@ -15,7 +15,7 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-// http://tools.ietf.org/html/draft-ietf-httpbis-http2-12#section-7
+// http://tools.ietf.org/html/draft-ietf-httpbis-http2-13#section-7
 public enum ErrorCode {
   /** Not an error! For SPDY stream resets, prefer null over NO_ERROR. */
   NO_ERROR(0, -1, 0),
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft07.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft08.java
similarity index 98%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft07.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft08.java
index 574e142..2f78403 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft07.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft08.java
@@ -30,15 +30,15 @@
 import okio.Source;
 
 /**
- * Read and write HPACK v07.
+ * Read and write HPACK v08.
  *
- * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07
+ * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08
  *
  * This implementation uses an array for the header table with a bitset for
  * references.  Dynamic entries are added to the array, starting in the last
  * position moving forward.  When the array fills, it is doubled.
  */
-final class HpackDraft07 {
+final class HpackDraft08 {
   private static final int PREFIX_4_BITS = 0x0f;
   private static final int PREFIX_6_BITS = 0x3f;
   private static final int PREFIX_7_BITS = 0x7f;
@@ -59,7 +59,7 @@
       new Header(Header.RESPONSE_STATUS, "404"),
       new Header(Header.RESPONSE_STATUS, "500"),
       new Header("accept-charset", ""),
-      new Header("accept-encoding", ""),
+      new Header("accept-encoding", "gzip, deflate"),
       new Header("accept-language", ""),
       new Header("accept-ranges", ""),
       new Header("accept", ""),
@@ -107,10 +107,10 @@
       new Header("www-authenticate", "")
   };
 
-  private HpackDraft07() {
+  private HpackDraft08() {
   }
 
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#section-3.2
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#section-3.2
   static final class Reader {
 
     private final List<Header> emittedHeaders = new ArrayList<>();
@@ -429,7 +429,7 @@
     }
 
     /** This does not use "never indexed" semantics for sensitive headers. */
-    // https://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#section-4.3.3
+    // https://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#section-4.3.3
     void writeHeaders(List<Header> headerBlock) throws IOException {
       // TODO: implement index tracking
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
@@ -447,7 +447,7 @@
       }
     }
 
-    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#section-4.1.1
+    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#section-4.1.1
     void writeInt(int value, int prefixMask, int bits) throws IOException {
       // Write the raw value for a single byte value.
       if (value < prefixMask) {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft12.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft13.java
similarity index 87%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft12.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft13.java
index 887a93a..4c40a17 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft12.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft13.java
@@ -15,28 +15,29 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.Protocol;
 import java.io.IOException;
 import java.util.List;
 import java.util.logging.Logger;
+
+import com.squareup.okhttp.Protocol;
+
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.Source;
 import okio.Timeout;
-
-import static com.squareup.okhttp.internal.spdy.Http20Draft12.FrameLogger.formatHeader;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FrameLogger.formatHeader;
 import static java.lang.String.format;
 import static java.util.logging.Level.FINE;
 import static okio.ByteString.EMPTY;
 
 /**
- * Read and write HTTP/2 v12 frames.
- * <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-12
+ * Read and write HTTP/2 v13 frames.
+ * <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-13
  */
-public final class Http20Draft12 implements Variant {
-  private static final Logger logger = Logger.getLogger(Http20Draft12.class.getName());
+public final class Http20Draft13 implements Variant {
+  private static final Logger logger = Logger.getLogger(Http20Draft13.class.getName());
 
   @Override public Protocol getProtocol() {
     return Protocol.HTTP_2;
@@ -57,8 +58,6 @@
   static final byte TYPE_GOAWAY = 0x7;
   static final byte TYPE_WINDOW_UPDATE = 0x8;
   static final byte TYPE_CONTINUATION = 0x9;
-  static final byte TYPE_ALTSVC = 0xa;
-  static final byte TYPE_BLOCKED = 0xb;
 
   static final byte FLAG_NONE = 0x0;
   static final byte FLAG_ACK = 0x1; // Used for settings and ping.
@@ -66,8 +65,7 @@
   static final byte FLAG_END_SEGMENT = 0x2;
   static final byte FLAG_END_HEADERS = 0x4; // Used for headers and continuation.
   static final byte FLAG_END_PUSH_PROMISE = 0x4;
-  static final byte FLAG_PAD_LOW = 0x8; // Used for headers, data, and continuation.
-  static final byte FLAG_PAD_HIGH = 0x10; // Used for headers, data, and continuation.
+  static final byte FLAG_PADDED = 0x8; // Used for headers and data.
   static final byte FLAG_PRIORITY = 0x20; // Used for headers.
   static final byte FLAG_COMPRESSED = 0x20; // Used for data.
 
@@ -93,13 +91,13 @@
     private final boolean client;
 
     // Visible for testing.
-    final HpackDraft07.Reader hpackReader;
+    final HpackDraft08.Reader hpackReader;
 
     Reader(BufferedSource source, int headerTableSize, boolean client) {
       this.source = source;
       this.client = client;
       this.continuation = new ContinuationSource(this.source);
-      this.hpackReader = new HpackDraft07.Reader(headerTableSize, continuation);
+      this.hpackReader = new HpackDraft08.Reader(headerTableSize, continuation);
     }
 
     @Override public void readConnectionPreface() throws IOException {
@@ -166,16 +164,9 @@
           readWindowUpdate(handler, length, flags, streamId);
           break;
 
-        case TYPE_ALTSVC:
-          readAlternateService(handler, length, flags, streamId);
-          break;
-
-        case TYPE_BLOCKED: // Ignore as this is experimental.
-          if (length != 0) throw ioException("TYPE_BLOCKED length != 0: %s", length);
-          break;
-
         default:
-          throw ioException("PROTOCOL_ERROR: unknown frame type %s", type);
+          // Implementations MUST discard frames that have unknown or unsupported types.
+          source.skip(length);
       }
       return true;
     }
@@ -186,7 +177,7 @@
 
       boolean endStream = (flags & FLAG_END_STREAM) != 0;
 
-      short padding = readPadding(source, flags);
+      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
 
       if ((flags & FLAG_PRIORITY) != 0) {
         readPriority(handler, streamId);
@@ -223,7 +214,7 @@
         throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
       }
 
-      short padding = readPadding(source, flags);
+      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
       length = lengthWithoutPadding(length, flags, padding);
 
       handler.data(inFinished, streamId, source, length);
@@ -266,10 +257,10 @@
         return;
       }
 
-      if (length % 5 != 0) throw ioException("TYPE_SETTINGS length %% 5 != 0: %s", length);
+      if (length % 6 != 0) throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length);
       Settings settings = new Settings();
-      for (int i = 0; i < length; i += 5) {
-        int id = source.readByte();
+      for (int i = 0; i < length; i += 6) {
+        short id = source.readShort();
         int value = source.readInt();
 
         switch (id) {
@@ -307,9 +298,10 @@
       if (streamId == 0) {
         throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
       }
-      short padding = readPadding(source, flags);
+      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
       int promisedStreamId = source.readInt() & 0x7fffffff;
       length -= 4; // account for above read.
+      length = lengthWithoutPadding(length, flags, padding);
       List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
       handler.pushPromise(streamId, promisedStreamId, headerBlock);
     }
@@ -350,20 +342,6 @@
       handler.windowUpdate(streamId, increment);
     }
 
-    private void readAlternateService(Handler handler, short length, byte flags, int streamId)
-        throws IOException {
-      long maxAge = source.readInt() & 0xffffffffL;
-      int port = source.readShort() & 0xffff;
-      source.readByte(); // Reserved.
-      int protocolLength = source.readByte() & 0xff;
-      ByteString protocol = source.readByteString(protocolLength);
-      int hostLength = source.readByte() & 0xff;
-      String host = source.readUtf8(hostLength);
-      int originLength = length - 9 - protocolLength - hostLength;
-      String origin = source.readUtf8(originLength);
-      handler.alternateService(streamId, origin, protocol, host, port, maxAge);
-    }
-
     @Override public void close() throws IOException {
       source.close();
     }
@@ -373,14 +351,14 @@
     private final BufferedSink sink;
     private final boolean client;
     private final Buffer hpackBuffer;
-    private final HpackDraft07.Writer hpackWriter;
+    private final HpackDraft08.Writer hpackWriter;
     private boolean closed;
 
     Writer(BufferedSink sink, boolean client) {
       this.sink = sink;
       this.client = client;
       this.hpackBuffer = new Buffer();
-      this.hpackWriter = new HpackDraft07.Writer(hpackBuffer);
+      this.hpackWriter = new HpackDraft08.Writer(hpackBuffer);
     }
 
     @Override public synchronized void flush() throws IOException {
@@ -506,7 +484,7 @@
 
     @Override public synchronized void settings(Settings settings) throws IOException {
       if (closed) throw new IOException("closed");
-      int length = settings.size() * 5;
+      int length = settings.size() * 6;
       byte type = TYPE_SETTINGS;
       byte flags = FLAG_NONE;
       int streamId = 0;
@@ -516,7 +494,7 @@
         int id = i;
         if (id == 4) id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
         else if (id == 7) id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
-        sink.writeByte(id);
+        sink.writeShort(id);
         sink.writeInt(settings.get(i));
       }
       sink.flush();
@@ -594,7 +572,7 @@
   /**
    * Decompression of the header block occurs above the framing layer. This
    * class lazily reads continuation frames as they are needed by {@link
-   * HpackDraft07.Reader#readHeaders()}.
+   * HpackDraft08.Reader#readHeaders()}.
    */
   static final class ContinuationSource implements Source {
     private final BufferedSource source;
@@ -636,41 +614,19 @@
       int previousStreamId = streamId;
       int w1 = source.readInt();
       int w2 = source.readInt();
-      length = (short) ((w1 & 0x3fff0000) >> 16);
+      length = left = (short) ((w1 & 0x3fff0000) >> 16);
       byte type = (byte) ((w1 & 0xff00) >> 8);
       flags = (byte) (w1 & 0xff);
       if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
-      padding = readPadding(source, flags);
-      length = left = lengthWithoutPadding(length, flags, padding);
       streamId = (w2 & 0x7fffffff);
       if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
       if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
     }
   }
 
-  private static short readPadding(BufferedSource source, byte flags) throws IOException {
-    if ((flags & FLAG_PAD_HIGH) != 0 && (flags & FLAG_PAD_LOW) == 0) {
-      throw ioException("PROTOCOL_ERROR FLAG_PAD_HIGH set without FLAG_PAD_LOW");
-    }
-    int padding = 0;
-    if ((flags & FLAG_PAD_HIGH) != 0) {
-      padding = source.readShort() & 0xffff;
-    } else if ((flags & FLAG_PAD_LOW) != 0) {
-      padding = source.readByte() & 0xff;
-    }
-    if (padding > MAX_FRAME_SIZE) {
-      throw ioException("PROTOCOL_ERROR padding > %d: %d", MAX_FRAME_SIZE, padding);
-    }
-    return (short) padding;
-  }
-
   private static short lengthWithoutPadding(short length, byte flags, short padding)
       throws IOException {
-    if ((flags & FLAG_PAD_HIGH) != 0) { // account for reading the padding length.
-      length -= 2;
-    } else if ((flags & FLAG_PAD_LOW) != 0) {
-      length--;
-    }
+    if ((flags & FLAG_PADDED) != 0) length--; // Account for reading the padding length.
     if (padding > length) {
       throw ioException("PROTOCOL_ERROR padding %s > remaining length %s", padding, length);
     }
@@ -719,8 +675,6 @@
         case TYPE_RST_STREAM:
         case TYPE_GOAWAY:
         case TYPE_WINDOW_UPDATE:
-        case TYPE_ALTSVC:
-        case TYPE_BLOCKED:
           return BINARY[flags];
       }
       String result = flags < FLAGS.length ? FLAGS[flags] : BINARY[flags];
@@ -744,9 +698,7 @@
         "PING",
         "GOAWAY",
         "WINDOW_UPDATE",
-        "CONTINUATION",
-        "ALTSVC",
-        "BLOCKED"
+        "CONTINUATION"
     };
 
     /**
@@ -768,14 +720,9 @@
       int[] prefixFlags =
           new int[] {FLAG_END_STREAM, FLAG_END_SEGMENT, FLAG_END_SEGMENT | FLAG_END_STREAM};
 
-      FLAGS[FLAG_PAD_LOW] = "PAD_LOW";
-      FLAGS[FLAG_PAD_LOW | FLAG_PAD_HIGH] = "PAD_LOW|PAD_HIGH";
-      int[] suffixFlags = new int[] {FLAG_PAD_LOW, FLAG_PAD_LOW | FLAG_PAD_HIGH};
-
+      FLAGS[FLAG_PADDED] = "PADDED";
       for (int prefixFlag : prefixFlags) {
-        for (int suffixFlag : suffixFlags) {
-          FLAGS[prefixFlag | suffixFlag] = FLAGS[prefixFlag] + '|' + FLAGS[suffixFlag];
-        }
+         FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
       }
 
       FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
@@ -787,10 +734,8 @@
       for (int frameFlag : frameFlags) {
         for (int prefixFlag : prefixFlags) {
           FLAGS[prefixFlag | frameFlag] = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag];
-          for (int suffixFlag : suffixFlags) {
-            FLAGS[prefixFlag | frameFlag | suffixFlag] =
-                FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + '|' + FLAGS[suffixFlag];
-          }
+          FLAGS[prefixFlag | frameFlag | FLAG_PADDED] =
+              FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + "|PADDED";
         }
       }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
index 5fd2d54..ab15011 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
@@ -31,49 +31,47 @@
 class Huffman {
 
   // Appendix C: Huffman Codes
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-07#appendix-C
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#appendix-C
   private static final int[] CODES = {
-      0x3ffffba, 0x3ffffbb, 0x3ffffbc, 0x3ffffbd, 0x3ffffbe, 0x3ffffbf, 0x3ffffc0, 0x3ffffc1,
-      0x3ffffc2, 0x3ffffc3, 0x3ffffc4, 0x3ffffc5, 0x3ffffc6, 0x3ffffc7, 0x3ffffc8, 0x3ffffc9,
-      0x3ffffca, 0x3ffffcb, 0x3ffffcc, 0x3ffffcd, 0x3ffffce, 0x3ffffcf, 0x3ffffd0, 0x3ffffd1,
-      0x3ffffd2, 0x3ffffd3, 0x3ffffd4, 0x3ffffd5, 0x3ffffd6, 0x3ffffd7, 0x3ffffd8, 0x3ffffd9, 0x6,
-      0x1ffc, 0x1f0, 0x3ffc, 0x7ffc, 0x1e, 0x64, 0x1ffd, 0x3fa, 0x1f1, 0x3fb, 0x3fc, 0x65, 0x66,
-      0x1f, 0x7, 0x0, 0x1, 0x2, 0x8, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0xec, 0x1fffc, 0x27,
-      0x7ffd, 0x3fd, 0x7ffe, 0x67, 0xed, 0xee, 0x68, 0xef, 0x69, 0x6a, 0x1f2, 0xf0, 0x1f3, 0x1f4,
-      0x1f5, 0x6b, 0x6c, 0xf1, 0xf2, 0x1f6, 0x1f7, 0x6d, 0x28, 0xf3, 0x1f8, 0x1f9, 0xf4, 0x1fa,
-      0x1fb, 0x7fc, 0x3ffffda, 0x7fd, 0x3ffd, 0x6e, 0x3fffe, 0x9, 0x6f, 0xa, 0x29, 0xb, 0x70, 0x2a,
-      0x2b, 0xc, 0xf5, 0xf6, 0x2c, 0x2d, 0x2e, 0xd, 0x2f, 0x1fc, 0x30, 0x31, 0xe, 0x71, 0x72, 0x73,
-      0x74, 0x75, 0xf7, 0x1fffd, 0xffc, 0x1fffe, 0xffd, 0x3ffffdb, 0x3ffffdc, 0x3ffffdd, 0x3ffffde,
-      0x3ffffdf, 0x3ffffe0, 0x3ffffe1, 0x3ffffe2, 0x3ffffe3, 0x3ffffe4, 0x3ffffe5, 0x3ffffe6,
-      0x3ffffe7, 0x3ffffe8, 0x3ffffe9, 0x3ffffea, 0x3ffffeb, 0x3ffffec, 0x3ffffed, 0x3ffffee,
-      0x3ffffef, 0x3fffff0, 0x3fffff1, 0x3fffff2, 0x3fffff3, 0x3fffff4, 0x3fffff5, 0x3fffff6,
-      0x3fffff7, 0x3fffff8, 0x3fffff9, 0x3fffffa, 0x3fffffb, 0x3fffffc, 0x3fffffd, 0x3fffffe,
-      0x3ffffff, 0x1ffff80, 0x1ffff81, 0x1ffff82, 0x1ffff83, 0x1ffff84, 0x1ffff85, 0x1ffff86,
-      0x1ffff87, 0x1ffff88, 0x1ffff89, 0x1ffff8a, 0x1ffff8b, 0x1ffff8c, 0x1ffff8d, 0x1ffff8e,
-      0x1ffff8f, 0x1ffff90, 0x1ffff91, 0x1ffff92, 0x1ffff93, 0x1ffff94, 0x1ffff95, 0x1ffff96,
-      0x1ffff97, 0x1ffff98, 0x1ffff99, 0x1ffff9a, 0x1ffff9b, 0x1ffff9c, 0x1ffff9d, 0x1ffff9e,
-      0x1ffff9f, 0x1ffffa0, 0x1ffffa1, 0x1ffffa2, 0x1ffffa3, 0x1ffffa4, 0x1ffffa5, 0x1ffffa6,
-      0x1ffffa7, 0x1ffffa8, 0x1ffffa9, 0x1ffffaa, 0x1ffffab, 0x1ffffac, 0x1ffffad, 0x1ffffae,
-      0x1ffffaf, 0x1ffffb0, 0x1ffffb1, 0x1ffffb2, 0x1ffffb3, 0x1ffffb4, 0x1ffffb5, 0x1ffffb6,
-      0x1ffffb7, 0x1ffffb8, 0x1ffffb9, 0x1ffffba, 0x1ffffbb, 0x1ffffbc, 0x1ffffbd, 0x1ffffbe,
-      0x1ffffbf, 0x1ffffc0, 0x1ffffc1, 0x1ffffc2, 0x1ffffc3, 0x1ffffc4, 0x1ffffc5, 0x1ffffc6,
-      0x1ffffc7, 0x1ffffc8, 0x1ffffc9, 0x1ffffca, 0x1ffffcb, 0x1ffffcc, 0x1ffffcd, 0x1ffffce,
-      0x1ffffcf, 0x1ffffd0, 0x1ffffd1, 0x1ffffd2, 0x1ffffd3, 0x1ffffd4, 0x1ffffd5, 0x1ffffd6,
-      0x1ffffd7, 0x1ffffd8, 0x1ffffd9, 0x1ffffda, 0x1ffffdb
+      0x1ff8, 0x7fffd8, 0xfffffe2, 0xfffffe3, 0xfffffe4, 0xfffffe5, 0xfffffe6, 0xfffffe7, 0xfffffe8,
+      0xffffea, 0x3ffffffc, 0xfffffe9, 0xfffffea, 0x3ffffffd, 0xfffffeb, 0xfffffec, 0xfffffed,
+      0xfffffee, 0xfffffef, 0xffffff0, 0xffffff1, 0xffffff2, 0x3ffffffe, 0xffffff3, 0xffffff4,
+      0xffffff5, 0xffffff6, 0xffffff7, 0xffffff8, 0xffffff9, 0xffffffa, 0xffffffb, 0x14, 0x3f8,
+      0x3f9, 0xffa, 0x1ff9, 0x15, 0xf8, 0x7fa, 0x3fa, 0x3fb, 0xf9, 0x7fb, 0xfa, 0x16, 0x17, 0x18,
+      0x0, 0x1, 0x2, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x5c, 0xfb, 0x7ffc, 0x20, 0xffb,
+      0x3fc, 0x1ffa, 0x21, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
+      0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0xfc, 0x73, 0xfd, 0x1ffb, 0x7fff0,
+      0x1ffc, 0x3ffc, 0x22, 0x7ffd, 0x3, 0x23, 0x4, 0x24, 0x5, 0x25, 0x26, 0x27, 0x6, 0x74, 0x75,
+      0x28, 0x29, 0x2a, 0x7, 0x2b, 0x76, 0x2c, 0x8, 0x9, 0x2d, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7ffe,
+      0x7fc, 0x3ffd, 0x1ffd, 0xffffffc, 0xfffe6, 0x3fffd2, 0xfffe7, 0xfffe8, 0x3fffd3, 0x3fffd4,
+      0x3fffd5, 0x7fffd9, 0x3fffd6, 0x7fffda, 0x7fffdb, 0x7fffdc, 0x7fffdd, 0x7fffde, 0xffffeb,
+      0x7fffdf, 0xffffec, 0xffffed, 0x3fffd7, 0x7fffe0, 0xffffee, 0x7fffe1, 0x7fffe2, 0x7fffe3,
+      0x7fffe4, 0x1fffdc, 0x3fffd8, 0x7fffe5, 0x3fffd9, 0x7fffe6, 0x7fffe7, 0xffffef, 0x3fffda,
+      0x1fffdd, 0xfffe9, 0x3fffdb, 0x3fffdc, 0x7fffe8, 0x7fffe9, 0x1fffde, 0x7fffea, 0x3fffdd,
+      0x3fffde, 0xfffff0, 0x1fffdf, 0x3fffdf, 0x7fffeb, 0x7fffec, 0x1fffe0, 0x1fffe1, 0x3fffe0,
+      0x1fffe2, 0x7fffed, 0x3fffe1, 0x7fffee, 0x7fffef, 0xfffea, 0x3fffe2, 0x3fffe3, 0x3fffe4,
+      0x7ffff0, 0x3fffe5, 0x3fffe6, 0x7ffff1, 0x3ffffe0, 0x3ffffe1, 0xfffeb, 0x7fff1, 0x3fffe7,
+      0x7ffff2, 0x3fffe8, 0x1ffffec, 0x3ffffe2, 0x3ffffe3, 0x3ffffe4, 0x7ffffde, 0x7ffffdf,
+      0x3ffffe5, 0xfffff1, 0x1ffffed, 0x7fff2, 0x1fffe3, 0x3ffffe6, 0x7ffffe0, 0x7ffffe1, 0x3ffffe7,
+      0x7ffffe2, 0xfffff2, 0x1fffe4, 0x1fffe5, 0x3ffffe8, 0x3ffffe9, 0xffffffd, 0x7ffffe3,
+      0x7ffffe4, 0x7ffffe5, 0xfffec, 0xfffff3, 0xfffed, 0x1fffe6, 0x3fffe9, 0x1fffe7, 0x1fffe8,
+      0x7ffff3, 0x3fffea, 0x3fffeb, 0x1ffffee, 0x1ffffef, 0xfffff4, 0xfffff5, 0x3ffffea, 0x7ffff4,
+      0x3ffffeb, 0x7ffffe6, 0x3ffffec, 0x3ffffed, 0x7ffffe7, 0x7ffffe8, 0x7ffffe9, 0x7ffffea,
+      0x7ffffeb, 0xffffffe, 0x7ffffec, 0x7ffffed, 0x7ffffee, 0x7ffffef, 0x7fffff0, 0x3ffffee
   };
 
   private static final byte[] CODE_LENGTHS = {
-      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-      26, 26, 26, 26, 26, 26, 26, 26, 26, 5, 13, 9, 14, 15, 6, 7, 13, 10, 9, 10, 10, 7, 7, 6, 5, 4,
-      4, 4, 5, 6, 6, 6, 6, 6, 6, 6, 8, 17, 6, 15, 10, 15, 7, 8, 8, 7, 8, 7, 7, 9, 8, 9, 9, 9, 7, 7,
-      8, 8, 9, 9, 7, 6, 8, 9, 9, 8, 9, 9, 11, 26, 11, 14, 7, 18, 5, 7, 5, 6, 5, 7, 6, 6, 5, 8, 8, 6,
-      6, 6, 5, 6, 9, 6, 6, 5, 7, 7, 7, 7, 7, 8, 17, 12, 17, 12, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-      26, 26, 26, 26, 26, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-      25, 25, 25, 25, 25
+      13, 23, 28, 28, 28, 28, 28, 28, 28, 24, 30, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 28, 30,
+      28, 28, 28, 28, 28, 28, 28, 28, 28, 6, 10, 10, 12, 13, 6, 8, 11, 10, 10, 8, 11, 8, 6, 6, 6, 5,
+      5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 8, 15, 6, 12, 10, 13, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+      7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 8, 13, 19, 13, 14, 6, 15, 5, 6, 5, 6, 5, 6, 6, 6, 5, 7, 7, 6,
+      6, 6, 5, 6, 7, 6, 5, 5, 6, 7, 7, 7, 7, 7, 15, 11, 14, 13, 28, 20, 22, 20, 20, 22, 22, 22, 23,
+      22, 23, 23, 23, 23, 23, 24, 23, 24, 24, 22, 23, 24, 23, 23, 23, 23, 21, 22, 23, 22, 23, 23,
+      24, 22, 21, 20, 22, 22, 23, 23, 21, 23, 22, 22, 24, 21, 22, 23, 23, 21, 21, 22, 21, 23, 22,
+      23, 23, 20, 22, 22, 22, 23, 22, 22, 23, 26, 26, 20, 19, 22, 23, 22, 25, 26, 26, 26, 27, 27,
+      26, 24, 25, 19, 21, 26, 27, 27, 26, 27, 24, 21, 21, 26, 26, 28, 27, 27, 27, 20, 24, 20, 21,
+      22, 21, 21, 23, 22, 22, 25, 25, 24, 24, 26, 23, 26, 27, 26, 26, 27, 27, 27, 27, 27, 28, 27,
+      27, 27, 27, 27, 26
   };
 
   private static final Huffman INSTANCE = new Huffman();
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
index 4a034e6..9c914db 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
@@ -50,8 +50,6 @@
   static final int MAX_CONCURRENT_STREAMS = 4;
   /** spdy/3: Current CWND in Packets. */
   static final int CURRENT_CWND = 5;
-  /** HTTP/2: The peer must not gzip a DATA frame when this is 0. */
-  static final int COMPRESS_DATA = 5;
   /** spdy/3: Retransmission rate. Percentage */
   static final int DOWNLOAD_RETRANS_RATE = 6;
   /** Window size in bytes. */
@@ -173,13 +171,6 @@
     return (bit & set) != 0 ? values[CURRENT_CWND] : defaultValue;
   }
 
-  /** HTTP/2 only. */
-  // TODO: honor this setting in HTTP/2.
-  boolean getCompressData(boolean defaultValue) {
-    int bit = 1 << COMPRESS_DATA;
-    return ((bit & set) != 0 ? values[COMPRESS_DATA] : defaultValue ? 1 : 0) == 1;
-  }
-
   /** spdy/3 only. */
   int getDownloadRetransRate(int defaultValue) {
     int bit = 1 << DOWNLOAD_RETRANS_RATE;
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index 8e22f70..ed342a2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -133,7 +133,7 @@
     pushObserver = builder.pushObserver;
     client = builder.client;
     handler = builder.handler;
-    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-12#section-5.1.1
+    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-13#section-5.1.1
     nextStreamId = builder.client ? 1 : 2;
     if (builder.client && protocol == Protocol.HTTP_2) {
       nextStreamId += 2; // In HTTP/2, 1 on client is reserved for Upgrade.
@@ -152,7 +152,7 @@
     hostName = builder.hostName;
 
     if (protocol == Protocol.HTTP_2) {
-      variant = new Http20Draft12();
+      variant = new Http20Draft13();
       // Like newSingleThreadExecutor, except lazy creates the thread.
       pushExecutor = new ThreadPoolExecutor(0, 1,
           0L, TimeUnit.MILLISECONDS,
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
index 05e06f5..ccaf3d9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
@@ -223,7 +223,6 @@
       try {
         cache.readJournal();
         cache.processJournal();
-        cache.journalWriter = Okio.buffer(Okio.appendingSink(cache.journalFile));
         return cache;
       } catch (IOException journalIsCorrupt) {
         Platform.get().logW("DiskLruCache " + directory + " is corrupt: "
@@ -266,6 +265,13 @@
         }
       }
       redundantOpCount = lineCount - lruEntries.size();
+
+      // If we ended on a truncated line, rebuild the journal before appending to it.
+      if (!source.exhausted()) {
+        rebuildJournal();
+      } else {
+        journalWriter = Okio.buffer(Okio.appendingSink(journalFile));
+      }
     } finally {
       Util.closeQuietly(source);
     }
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
index dcda4e9..b9fa9d0 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
@@ -825,6 +825,28 @@
     assertEquals("A", get(url).body().string());
   }
 
+  @Test public void clientSideNoStore() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("B"));
+
+    Request request1 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .cacheControl(new CacheControl.Builder().noStore().build())
+        .build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("A", response1.body().string());
+
+    Request request2 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("B", response2.body().string());
+  }
+
   @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
     assertNonIdentityEncodingCached(
         new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
@@ -958,6 +980,27 @@
     assertEquals("110 HttpURLConnection \"Response is stale\"", response.header("Warning"));
   }
 
+  @Test public void requestMaxStaleDirectiveWithNoValue() throws IOException {
+    // Add a stale response to the cache.
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=120")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+
+    // With max-stale, we'll return that stale response.
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Cache-Control", "max-stale")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("A", response.body().string());
+    assertEquals("110 HttpURLConnection \"Response is stale\"", response.header("Warning"));
+  }
+
   @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("A")
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java b/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
index c19d779..774f785 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
@@ -192,17 +192,17 @@
         } else if ("no-store".equalsIgnoreCase(directive)) {
           noStore = true;
         } else if ("max-age".equalsIgnoreCase(directive)) {
-          maxAgeSeconds = HeaderParser.parseSeconds(parameter);
+          maxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
         } else if ("s-maxage".equalsIgnoreCase(directive)) {
-          sMaxAgeSeconds = HeaderParser.parseSeconds(parameter);
+          sMaxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
         } else if ("public".equalsIgnoreCase(directive)) {
           isPublic = true;
         } else if ("must-revalidate".equalsIgnoreCase(directive)) {
           mustRevalidate = true;
         } else if ("max-stale".equalsIgnoreCase(directive)) {
-          maxStaleSeconds = HeaderParser.parseSeconds(parameter);
+          maxStaleSeconds = HeaderParser.parseSeconds(parameter, Integer.MAX_VALUE);
         } else if ("min-fresh".equalsIgnoreCase(directive)) {
-          minFreshSeconds = HeaderParser.parseSeconds(parameter);
+          minFreshSeconds = HeaderParser.parseSeconds(parameter, -1);
         } else if ("only-if-cached".equalsIgnoreCase(directive)) {
           onlyIfCached = true;
         } else if ("no-transform".equalsIgnoreCase(directive)) {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
index 2363d53..44f7451 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
@@ -60,7 +60,9 @@
       return false;
     }
 
-    if (responseCaching.noStore()) {
+    // A 'no-store' directive on request or response prevents the response from being cached.
+    CacheControl requestCaching = request.cacheControl();
+    if (responseCaching.noStore() || requestCaching.noStore()) {
       return false;
     }
 
@@ -124,7 +126,7 @@
           } else if ("ETag".equalsIgnoreCase(fieldName)) {
             etag = value;
           } else if ("Age".equalsIgnoreCase(fieldName)) {
-            ageSeconds = HeaderParser.parseSeconds(value);
+            ageSeconds = HeaderParser.parseSeconds(value, -1);
           } else if (OkHeaders.SENT_MILLIS.equalsIgnoreCase(fieldName)) {
             sentRequestMillis = Long.parseLong(value);
           } else if (OkHeaders.RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
index e9af130..55f82ad 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
@@ -47,9 +47,9 @@
 
   /**
    * Returns {@code value} as a positive integer, or 0 if it is negative, or
-   * -1 if it cannot be parsed.
+   * {@code defaultValue} if it cannot be parsed.
    */
-  public static int parseSeconds(String value) {
+  public static int parseSeconds(String value, int defaultValue) {
     try {
       long seconds = Long.parseLong(value);
       if (seconds > Integer.MAX_VALUE) {
@@ -60,7 +60,7 @@
         return (int) seconds;
       }
     } catch (NumberFormatException e) {
-      return -1;
+      return defaultValue;
     }
   }
 
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index 3dac6d3..630a218 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -74,7 +74,7 @@
   }
 
   public FrameWriter sendFrame() {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), Integer.MAX_VALUE));
+    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), false));
     return frameWriter;
   }
 
@@ -83,17 +83,27 @@
    * won't be generated naturally.
    */
   public void sendFrame(byte[] frame) throws IOException {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), Integer.MAX_VALUE));
+    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), false));
     bytesOut.write(frame);
   }
 
   /**
-   * Sends a frame, truncated to {@code truncateToLength} bytes. This is only
-   * useful for testing error handling as the truncated frame will be
-   * malformed.
+   * Shortens the last frame from its original length to {@code length}. This
+   * will cause the peer to close the socket as soon as this frame has been
+   * written; otherwise the peer stays open until explicitly closed.
    */
-  public FrameWriter sendTruncatedFrame(int truncateToLength) {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), truncateToLength));
+  public FrameWriter truncateLastFrame(int length) {
+    OutFrame lastFrame = outFrames.remove(outFrames.size() - 1);
+    if (length >= bytesOut.size() - lastFrame.start) throw new IllegalArgumentException();
+
+    // Move everything from bytesOut into a new buffer.
+    Buffer fullBuffer = new Buffer();
+    bytesOut.read(fullBuffer, bytesOut.size());
+
+    // Copy back all but what we're truncating.
+    fullBuffer.read(bytesOut, lastFrame.start + length);
+
+    outFrames.add(new OutFrame(lastFrame.sequence, lastFrame.start, true));
     return frameWriter;
   }
 
@@ -136,18 +146,25 @@
 
       if (nextOutFrame != null && nextOutFrame.sequence == i) {
         long start = nextOutFrame.start;
-        int truncateToLength = nextOutFrame.truncateToLength;
+        boolean truncated;
         long end;
         if (outFramesIterator.hasNext()) {
           nextOutFrame = outFramesIterator.next();
           end = nextOutFrame.start;
+          truncated = false;
         } else {
           end = outBytes.length;
+          truncated = nextOutFrame.truncated;
         }
 
-        // write a frame
-        int length = (int) Math.min(end - start, truncateToLength);
+        // Write a frame.
+        int length = (int) (end - start);
         out.write(outBytes, (int) start, length);
+
+        // If the last frame was truncated, immediately close the connection.
+        if (truncated) {
+          socket.close();
+        }
       } else {
         // read a frame
         InFrame inFrame = new InFrame(i, reader);
@@ -155,7 +172,6 @@
         inFrames.add(inFrame);
       }
     }
-    Util.closeQuietly(socket);
   }
 
   public Socket openSocket() throws IOException {
@@ -179,12 +195,12 @@
   private static class OutFrame {
     private final int sequence;
     private final long start;
-    private final int truncateToLength;
+    private final boolean truncated;
 
-    private OutFrame(int sequence, long start, int truncateToLength) {
+    private OutFrame(int sequence, long start, boolean truncated) {
       this.sequence = sequence;
       this.start = start;
-      this.truncateToLength = truncateToLength;
+      this.truncated = truncated;
     }
   }
 
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
index f8a42eb..640d9db 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
@@ -1109,7 +1109,8 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendTruncatedFrame(8 + 100).data(false, 1, data(1024), 1024);
+    peer.sendFrame().data(false, 1, data(1024), 1024);
+    peer.truncateLastFrame(8 + 100);
     peer.play();
 
     // play it back
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
index 61b2cc3..d14a25b 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
@@ -1105,8 +1105,10 @@
     server2.enqueue(new MockResponse().setBody("Page 2"));
     server2.play();
 
-    server.enqueue(new MockResponse().setResponseCode(401));
-    server.enqueue(new MockResponse().setResponseCode(302)
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
         .addHeader("Location: " + server2.getUrl("/b")));
     server.play();
 
@@ -1230,6 +1232,18 @@
     assertEquals(0, server.getRequestCount());
   }
 
+  @Test public void cancelTagImmediatelyAfterEnqueue() throws Exception {
+    server.play();
+    Call call = client.newCall(new Request.Builder()
+        .url(server.getUrl("/a"))
+        .tag("request")
+        .build());
+    call.enqueue(callback);
+    client.cancel("request");
+    assertEquals(0, server.getRequestCount());
+    callback.await(server.getUrl("/a")).assertFailure("Canceled");
+  }
+
   @Test public void cancelBeforeBodyIsRead() throws Exception {
     server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
     server.play();
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
index 68713b9..3d7701f 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
@@ -112,15 +112,6 @@
     executor.assertJobs("http://a/1");
   }
 
-  @Test public void cancelingReadyJobPreventsItFromStarting() throws Exception {
-    dispatcher.setMaxRequestsPerHost(1);
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://a/2", "tag1")).enqueue(callback);
-    dispatcher.cancel("tag1");
-    executor.finishJob("http://a/1");
-    executor.assertJobs();
-  }
-
   @Test public void cancelingRunningJobTakesNoEffectUntilJobFinishes() throws Exception {
     dispatcher.setMaxRequests(1);
     client.newCall(newRequest("http://a/1", "tag1")).enqueue(callback);
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/com/squareup/okhttp/Call.java
index 8719fe7..4d374b2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Call.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java
@@ -150,6 +150,10 @@
       return request.tag();
     }
 
+    void cancel() {
+      Call.this.cancel();
+    }
+
     Call get() {
       return Call.this;
     }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index 21f6025..95eb7b0 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -115,8 +115,10 @@
 
   /** Cancel all calls with the tag {@code tag}. */
   public synchronized void cancel(Object tag) {
-    for (Iterator<AsyncCall> i = readyCalls.iterator(); i.hasNext(); ) {
-      if (Util.equal(tag, i.next().tag())) i.remove();
+    for (AsyncCall call : readyCalls) {
+      if (Util.equal(tag, call.tag())) {
+        call.cancel();
+      }
     }
 
     for (AsyncCall call : runningCalls) {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index d3ebee2..458fb6d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -695,7 +695,7 @@
         }
       }
       if (streamsToNotify != null && delta != 0) {
-        for (SpdyStream stream : streams.values()) {
+        for (SpdyStream stream : streamsToNotify) {
           synchronized (stream) {
             stream.addBytesToWriteWindow(delta);
           }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
index 8a6cbf3..bb67b83 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
@@ -58,7 +58,7 @@
   static final int MAX_HEADER_LIST_SIZE = 6;
   /** Window size in bytes. */
   static final int INITIAL_WINDOW_SIZE = 7;
-  /** spdy/3: Window size in bytes. */
+  /** spdy/3: Size of the client certificate vector. Unsupported. */
   static final int CLIENT_CERTIFICATE_VECTOR_SIZE = 8;
   /** Flow control options. */
   static final int FLOW_CONTROL_OPTIONS = 10;
/Fim/
diff --git a/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java b/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
index a557423..82e13eb 100644
--- a/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
+++ b/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
@@ -37,7 +37,7 @@
     Request request = fromArgs("-X", "PUT", "http://example.com").createRequest();
     assertEquals("PUT", request.method());
     assertEquals("http://example.com", request.urlString());
-    assertNull(request.body());
+    assertEquals(0, request.body().contentLength());
   }
 
   @Test public void dataPost() {
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
index 4ebbb7e..9b989ca 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
@@ -273,6 +273,62 @@
     postZeroLength();
   }
 
+  @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(401));
+    server.enqueue(new MockResponse());
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .method("POST", RequestBody.create(null, body))
+        .build();
+
+    String credential = Credentials.basic("jesse", "secret");
+    client.setAuthenticator(new RecordingOkAuthenticator(credential));
+
+    Response response = client.newCall(request).execute();
+    assertEquals(200, response.code());
+
+    RecordedRequest recordedRequest1 = server.takeRequest();
+    assertEquals("POST", recordedRequest1.getMethod());
+    assertEquals(body, recordedRequest1.getUtf8Body());
+    assertNull(recordedRequest1.getHeader("Authorization"));
+
+    RecordedRequest recordedRequest2 = server.takeRequest();
+    assertEquals("POST", recordedRequest2.getMethod());
+    assertEquals(body, recordedRequest2.getUtf8Body());
+    assertEquals(credential, recordedRequest2.getHeader("Authorization"));
+  }
+
   @Test public void delete() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
     server.play();
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
index d77bb2d..2d999e7 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
@@ -93,7 +93,7 @@
 
     Request delete = new Request.Builder().url("http://localhost/api").delete().build();
     assertEquals("DELETE", delete.method());
-    assertNull(delete.body());
+    assertEquals(0L, delete.body().contentLength());
 
     Request post = new Request.Builder().url("http://localhost/api").post(body).build();
     assertEquals("POST", post.method());
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index 04e101d..2c275e0 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -126,14 +126,14 @@
 
   byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
 
-  /** An output stream can be written to more than once, so we can't guess content length. */
-  @Test public void noDefaultContentLengthOnPost() throws Exception {
+  @Test public void noDefaultContentLengthOnStreamingPost() throws Exception {
     MockResponse response = new MockResponse().setBody("ABCDE");
     server.enqueue(response);
     server.play();
 
     connection = client.open(server.getUrl("/foo"));
     connection.setDoOutput(true);
+    connection.setChunkedStreamingMode(0);
     connection.getOutputStream().write(postBytes);
     assertContent("ABCDE", connection, Integer.MAX_VALUE);
 
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index ae98b44..e46ef42 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -18,8 +18,8 @@
 
 import com.squareup.okhttp.Cache;
 import com.squareup.okhttp.Challenge;
-import com.squareup.okhttp.ConnectionSpec;
 import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.ConnectionSpec;
 import com.squareup.okhttp.Credentials;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.OkUrlFactory;
@@ -1380,6 +1380,61 @@
     assertEquals(Arrays.toString(requestBody), Arrays.toString(request.getBody()));
   }
 
+  @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(401));
+    server.enqueue(new MockResponse());
+    server.play();
+
+    String credential = Credentials.basic("jesse", "secret");
+    client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
+
+    connection = client.open(server.getUrl("/"));
+    connection.setDoOutput(true);
+    OutputStream outputStream = connection.getOutputStream();
+    outputStream.write(body.getBytes("UTF-8"));
+    outputStream.close();
+    assertEquals(200, connection.getResponseCode());
+
+    RecordedRequest recordedRequest1 = server.takeRequest();
+    assertEquals("POST", recordedRequest1.getMethod());
+    assertEquals(body, recordedRequest1.getUtf8Body());
+    assertNull(recordedRequest1.getHeader("Authorization"));
+
+    RecordedRequest recordedRequest2 = server.takeRequest();
+    assertEquals("POST", recordedRequest2.getMethod());
+    assertEquals(body, recordedRequest2.getUtf8Body());
+    assertEquals(credential, recordedRequest2.getHeader("Authorization"));
+  }
+
   @Test public void nonStandardAuthenticationScheme() throws Exception {
     List<String> calls = authCallsForHeader("WWW-Authenticate: Foo");
     assertEquals(Collections.<String>emptyList(), calls);
/Fim/
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
index 85fa7f3..fbcf90c 100644
--- a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
@@ -298,14 +298,12 @@
         if (method.equals("GET")) {
           // they are requesting a stream to write to. This implies a POST method
           method = "POST";
-        } else if (!HttpMethod.hasRequestBody(method)) {
-          // If the request method is neither POST nor PUT nor PATCH, then you're not writing
+        } else if (!HttpMethod.permitsRequestBody(method)) {
           throw new ProtocolException(method + " does not support writing");
         }
       }
       // If the user set content length to zero, we know there will not be a request body.
-      RetryableSink requestBody = doOutput && fixedContentLength == 0 ? Util.emptySink() : null;
-      httpEngine = newHttpEngine(method, null, requestBody, null);
+      httpEngine = newHttpEngine(method, null, null, null);
     } catch (IOException e) {
       httpEngineFailure = e;
       throw e;
@@ -323,7 +321,7 @@
     }
 
     boolean bufferRequestBody = false;
-    if (HttpMethod.hasRequestBody(method)) {
+    if (HttpMethod.permitsRequestBody(method)) {
       // Specify how the request body is terminated.
       if (fixedContentLength != -1) {
         builder.header("Content-Length", Long.toString(fixedContentLength));
/Fim/
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
index 5f01af5..07cc214 100644
--- a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
@@ -301,7 +301,6 @@
     Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
     assertFalse(request.isHttps());
     assertEquals(uri, request.uri());
-    assertNull(request.body());
     Headers okRequestHeaders = request.headers();
     assertEquals(0, okRequestHeaders.size());
     assertEquals("POST", request.method());
@@ -315,7 +314,6 @@
     Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
     assertTrue(request.isHttps());
     assertEquals(uri, request.uri());
-    assertNull(request.body());
     Headers okRequestHeaders = request.headers();
     assertEquals(1, okRequestHeaders.size());
     assertEquals("Bar", okRequestHeaders.get("Foo"));
@@ -335,7 +333,6 @@
     Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
     assertTrue(request.isHttps());
     assertEquals(uri, request.uri());
-    assertNull(request.body());
     Headers okRequestHeaders = request.headers();
     assertEquals(1, okRequestHeaders.size());
     assertEquals("Bar", okRequestHeaders.get("Foo"));
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/com/squareup/okhttp/Call.java
index 4d374b2..cf9cc1e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Call.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java
@@ -16,9 +16,7 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.NamedRunnable;
-import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.HttpMethod;
 import com.squareup.okhttp.internal.http.OkHeaders;
 import com.squareup.okhttp.internal.http.RetryableSink;
 import java.io.IOException;
@@ -223,8 +221,6 @@
       }
 
       request = requestBuilder.build();
-    } else if (HttpMethod.hasRequestBody(request.method())) {
-      requestBodyOut = Util.emptySink();
     }
 
     // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index cb303c4..890a34a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -16,6 +16,7 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpMethod;
 import java.io.IOException;
 import java.net.MalformedURLException;
@@ -224,9 +225,12 @@
       if (method == null || method.length() == 0) {
         throw new IllegalArgumentException("method == null || method.length() == 0");
       }
-      if (body != null && !HttpMethod.hasRequestBody(method)) {
+      if (body != null && !HttpMethod.permitsRequestBody(method)) {
         throw new IllegalArgumentException("method " + method + " must not have a request body.");
       }
+      if (body == null && HttpMethod.permitsRequestBody(method)) {
+        body = RequestBody.create(null, Util.EMPTY_BYTE_ARRAY);
+      }
       this.method = method;
       this.body = body;
       return this;
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
index 17bf29d..bd24493 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -16,7 +16,6 @@
 
 package com.squareup.okhttp.internal;
 
-import com.squareup.okhttp.internal.http.RetryableSink;
 import com.squareup.okhttp.internal.spdy.Header;
 import java.io.Closeable;
 import java.io.File;
@@ -243,12 +242,6 @@
     return result;
   }
 
-  public static RetryableSink emptySink() {
-    return EMPTY_SINK;
-  }
-
-  private static final RetryableSink EMPTY_SINK = new RetryableSink(0);
-
   /**
    * Returns a copy of {@code a} containing only elements also in {@code b}. The returned elements
    * are in the same order as in {@code a}.
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index b671057..c63fd6f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -28,7 +28,6 @@
 import com.squareup.okhttp.Route;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.InternalCache;
-import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.Version;
 import java.io.IOException;
 import java.io.InputStream;
@@ -242,8 +241,28 @@
 
       // Create a request body if we don't have one already. We'll already have
       // one if we're retrying a failed POST.
-      if (hasRequestBody() && requestBodyOut == null) {
-        requestBodyOut = transport.createRequestBody(request);
+      if (permitsRequestBody() && requestBodyOut == null) {
+        long contentLength = OkHeaders.contentLength(request);
+        if (bufferRequestBody) {
+          if (contentLength > Integer.MAX_VALUE) {
+            throw new IllegalStateException("Use setFixedLengthStreamingMode() or "
+                + "setChunkedStreamingMode() for requests larger than 2 GiB.");
+          }
+
+          if (contentLength != -1) {
+            // Buffer a request body of a known length.
+            transport.writeRequestHeaders(request);
+            requestBodyOut = new RetryableSink((int) contentLength);
+          } else {
+            // Buffer a request body of an unknown length. Don't write request
+            // headers until the entire body is ready; otherwise we can't set the
+            // Content-Length header correctly.
+            requestBodyOut = new RetryableSink();
+          }
+        } else {
+          transport.writeRequestHeaders(request);
+          requestBodyOut = transport.createRequestBody(request, contentLength);
+        }
       }
 
     } else {
@@ -305,9 +324,8 @@
     sentRequestMillis = System.currentTimeMillis();
   }
 
-  boolean hasRequestBody() {
-    return HttpMethod.hasRequestBody(userRequest.method())
-        && !Util.emptySink().equals(requestBodyOut);
+  boolean permitsRequestBody() {
+    return HttpMethod.permitsRequestBody(userRequest.method());
   }
 
   /** Returns the request body or null if this request doesn't have a body. */
@@ -637,7 +655,7 @@
       } else {
         requestBodyOut.close();
       }
-      if (requestBodyOut instanceof RetryableSink && !Util.emptySink().equals(requestBodyOut)) {
+      if (requestBodyOut instanceof RetryableSink) {
         transport.writeRequestBody((RetryableSink) requestBodyOut);
       }
     }
@@ -810,7 +828,7 @@
 
         // Redirects don't include a request body.
         Request.Builder requestBuilder = userRequest.newBuilder();
-        if (HttpMethod.hasRequestBody(userRequest.method())) {
+        if (HttpMethod.permitsRequestBody(userRequest.method())) {
           requestBuilder.method("GET", null);
           requestBuilder.removeHeader("Transfer-Encoding");
           requestBuilder.removeHeader("Content-Length");
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
index b9f839d..78ffb41 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
@@ -30,10 +30,14 @@
         || method.equals("DELETE");
   }
 
-  public static boolean hasRequestBody(String method) {
+  public static boolean requiresRequestBody(String method) {
     return method.equals("POST")
         || method.equals("PUT")
-        || method.equals("PATCH")
+        || method.equals("PATCH");
+  }
+
+  public static boolean permitsRequestBody(String method) {
+    return requiresRequestBody(method)
         || method.equals("DELETE"); // Permitted as spec is ambiguous.
   }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
index c61bf20..de501bd 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
@@ -31,36 +31,14 @@
     this.httpConnection = httpConnection;
   }
 
-  @Override public Sink createRequestBody(Request request) throws IOException {
-    long contentLength = OkHeaders.contentLength(request);
-
-    if (httpEngine.bufferRequestBody) {
-      if (contentLength > Integer.MAX_VALUE) {
-        throw new IllegalStateException("Use setFixedLengthStreamingMode() or "
-            + "setChunkedStreamingMode() for requests larger than 2 GiB.");
-      }
-
-      if (contentLength != -1) {
-        // Buffer a request body of a known length.
-        writeRequestHeaders(request);
-        return new RetryableSink((int) contentLength);
-      } else {
-        // Buffer a request body of an unknown length. Don't write request
-        // headers until the entire body is ready; otherwise we can't set the
-        // Content-Length header correctly.
-        return new RetryableSink();
-      }
-    }
-
+  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
     if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
       // Stream a request body of unknown length.
-      writeRequestHeaders(request);
       return httpConnection.newChunkedSink();
     }
 
     if (contentLength != -1) {
       // Stream a request body of a known length.
-      writeRequestHeaders(request);
       return httpConnection.newFixedLengthSink(contentLength);
     }
 
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
index af32e23..9c50b70 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
@@ -19,7 +19,6 @@
 import java.io.IOException;
 import java.net.ProtocolException;
 import okio.Buffer;
-import okio.BufferedSink;
 import okio.Sink;
 import okio.Timeout;
 
@@ -72,8 +71,9 @@
     return content.size();
   }
 
-  public void writeToSocket(BufferedSink socketOut) throws IOException {
+  public void writeToSocket(Sink socketOut) throws IOException {
     // Clone the content; otherwise we won't have data to retry.
-    socketOut.writeAll(content.clone());
+    Buffer buffer = content.clone();
+    socketOut.write(buffer, buffer.size());
   }
 }
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index e07d105..afb30a9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -76,9 +76,7 @@
     this.spdyConnection = spdyConnection;
   }
 
-  @Override public Sink createRequestBody(Request request) throws IOException {
-    // TODO: if bufferRequestBody is set, we must buffer the whole request
-    writeRequestHeaders(request);
+  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
     return stream.getSink();
   }
 
@@ -86,17 +84,17 @@
     if (stream != null) return;
 
     httpEngine.writingRequestHeaders();
-    boolean hasRequestBody = httpEngine.hasRequestBody();
+    boolean permitsRequestBody = httpEngine.permitsRequestBody();
     boolean hasResponseBody = true;
     String version = RequestLine.version(httpEngine.getConnection().getProtocol());
     stream = spdyConnection.newStream(
-        writeNameValueBlock(request, spdyConnection.getProtocol(), version), hasRequestBody,
+        writeNameValueBlock(request, spdyConnection.getProtocol(), version), permitsRequestBody,
         hasResponseBody);
     stream.readTimeout().timeout(httpEngine.client.getReadTimeout(), TimeUnit.MILLISECONDS);
   }
 
   @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
-    throw new UnsupportedOperationException();
+    requestBody.writeToSocket(stream.getSink());
   }
 
   @Override public void flushRequest() throws IOException {
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
index 05a398a..add6e8b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
@@ -30,23 +30,8 @@
    */
   int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
 
-  /**
-   * Returns an output stream where the request body can be written. The
-   * returned stream will of one of two types:
-   * <ul>
-   * <li><strong>Direct.</strong> Bytes are written to the socket and
-   * forgotten. This is most efficient, particularly for large request
-   * bodies. The returned stream may be buffered; the caller must call
-   * {@link #flushRequest} before reading the response.</li>
-   * <li><strong>Buffered.</strong> Bytes are written to an in memory
-   * buffer, and must be explicitly flushed with a call to {@link
-   * #writeRequestBody}. This allows HTTP authorization (401, 407)
-   * responses to be retransmitted transparently.</li>
-   * </ul>
-   */
-  // TODO: don't bother retransmitting the request body? It's quite a corner
-  // case and there's uncertainty whether Firefox or Chrome do this
-  Sink createRequestBody(Request request) throws IOException;
+  /** Returns an output stream where the request body can be streamed. */
+  Sink createRequestBody(Request request, long contentLength) throws IOException;
 
   /** This should update the HTTP engine's sentRequestMillis field. */
   void writeRequestHeaders(Request request) throws IOException;
/Fim/
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
index fb21a08..8e93b47 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
@@ -22,10 +22,13 @@
 import com.squareup.okhttp.internal.Util;
 import java.io.File;
 import java.io.IOException;
+import java.net.ProtocolException;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.Arrays;
 import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import okio.BufferedSink;
@@ -34,17 +37,15 @@
 
 /** A basic SPDY/HTTP_2 server that serves the contents of a local directory. */
 public final class SpdyServer implements IncomingStreamHandler {
+  static final Logger logger = Logger.getLogger(SpdyServer.class.getName());
+
   private final List<Protocol> spdyProtocols = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3);
 
   private final File baseDirectory;
-  private SSLSocketFactory sslSocketFactory;
-  private Protocol protocol;
+  private final SSLSocketFactory sslSocketFactory;
 
-  public SpdyServer(File baseDirectory) {
+  public SpdyServer(File baseDirectory, SSLSocketFactory sslSocketFactory) {
     this.baseDirectory = baseDirectory;
-  }
-
-  public void useHttps(SSLSocketFactory sslSocketFactory) {
     this.sslSocketFactory = sslSocketFactory;
   }
 
@@ -53,52 +54,67 @@
     serverSocket.setReuseAddress(true);
 
     while (true) {
-      Socket socket = serverSocket.accept();
-      if (sslSocketFactory != null) {
-        socket = doSsl(socket);
+      Socket socket = null;
+      try {
+        socket = serverSocket.accept();
+
+        SSLSocket sslSocket = doSsl(socket);
+        String protocolString = Platform.get().getSelectedProtocol(sslSocket);
+        Protocol protocol = protocolString != null ? Protocol.get(protocolString) : null;
+        if (protocol == null || !spdyProtocols.contains(protocol)) {
+          throw new ProtocolException("Protocol " + protocol + " unsupported");
+        }
+        SpdyConnection spdyConnection = new SpdyConnection.Builder(false, sslSocket)
+            .protocol(protocol)
+            .handler(this)
+            .build();
+        spdyConnection.sendConnectionPreface();
+      } catch (IOException e) {
+        logger.log(Level.INFO, "SpdyServer connection failure: " + e);
+        Util.closeQuietly(socket);
+      } catch (Exception e) {
+        logger.log(Level.WARNING, "SpdyServer unexpected failure", e);
+        Util.closeQuietly(socket);
       }
-      new SpdyConnection.Builder(false, socket).protocol(protocol).handler(this).build();
     }
   }
 
-  private Socket doSsl(Socket socket) throws IOException {
-    SSLSocket sslSocket =
-        (SSLSocket) sslSocketFactory.createSocket(socket, socket.getInetAddress().getHostAddress(),
-            socket.getPort(), true);
+  private SSLSocket doSsl(Socket socket) throws IOException {
+    SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(
+        socket, socket.getInetAddress().getHostAddress(), socket.getPort(), true);
     sslSocket.setUseClientMode(false);
     Platform.get().configureTlsExtensions(sslSocket, null, spdyProtocols);
     sslSocket.startHandshake();
-    String protocolString = Platform.get().getSelectedProtocol(sslSocket);
-    protocol = protocolString != null ? Protocol.get(protocolString) : null;
-    if (protocol == null || !spdyProtocols.contains(protocol)) {
-      throw new IllegalStateException("Protocol " + protocol + " unsupported");
-    }
     return sslSocket;
   }
 
   @Override public void receive(final SpdyStream stream) throws IOException {
-    List<Header> requestHeaders = stream.getRequestHeaders();
-    String path = null;
-    for (int i = 0, size = requestHeaders.size(); i < size; i++) {
-      if (requestHeaders.get(i).name.equals(Header.TARGET_PATH)) {
-        path = requestHeaders.get(i).value.utf8();
-        break;
+    try {
+      List<Header> requestHeaders = stream.getRequestHeaders();
+      String path = null;
+      for (int i = 0, size = requestHeaders.size(); i < size; i++) {
+        if (requestHeaders.get(i).name.equals(Header.TARGET_PATH)) {
+          path = requestHeaders.get(i).value.utf8();
+          break;
+        }
       }
-    }
 
-    if (path == null) {
-      // TODO: send bad request error
-      throw new AssertionError();
-    }
+      if (path == null) {
+        // TODO: send bad request error
+        throw new AssertionError();
+      }
 
-    File file = new File(baseDirectory + path);
+      File file = new File(baseDirectory + path);
 
-    if (file.isDirectory()) {
-      serveDirectory(stream, file.list());
-    } else if (file.exists()) {
-      serveFile(stream, file);
-    } else {
-      send404(stream, path);
+      if (file.isDirectory()) {
+        serveDirectory(stream, file.listFiles());
+      } else if (file.exists()) {
+        serveFile(stream, file);
+      } else {
+        send404(stream, path);
+      }
+    } catch (IOException e) {
+      System.out.println(e.getMessage());
     }
   }
 
@@ -114,7 +130,7 @@
     out.close();
   }
 
-  private void serveDirectory(SpdyStream stream, String[] files) throws IOException {
+  private void serveDirectory(SpdyStream stream, File[] files) throws IOException {
     List<Header> responseHeaders = Arrays.asList(
         new Header(":status", "200"),
         new Header(":version", "HTTP/1.1"),
@@ -122,8 +138,9 @@
     );
     stream.reply(responseHeaders, true);
     BufferedSink out = Okio.buffer(stream.getSink());
-    for (String file : files) {
-      out.writeUtf8("<a href='" + file + "'>" + file + "</a><br>");
+    for (File file : files) {
+      String target = file.isDirectory() ? (file.getName() + "/") : file.getName();
+      out.writeUtf8("<a href='" + target + "'>" + target + "</a><br>");
     }
     out.close();
   }
@@ -146,7 +163,14 @@
   }
 
   private String contentType(File file) {
-    return file.getName().endsWith(".html") ? "text/html" : "text/plain";
+    if (file.getName().endsWith(".css")) return "text/css";
+    if (file.getName().endsWith(".gif")) return "image/gif";
+    if (file.getName().endsWith(".html")) return "text/html";
+    if (file.getName().endsWith(".jpeg")) return "image/jpeg";
+    if (file.getName().endsWith(".jpg")) return "image/jpeg";
+    if (file.getName().endsWith(".js")) return "application/javascript";
+    if (file.getName().endsWith(".png")) return "image/png";
+    return "text/plain";
   }
 
   public static void main(String... args) throws Exception {
@@ -155,8 +179,8 @@
       return;
     }
 
-    SpdyServer server = new SpdyServer(new File(args[0]));
-    server.useHttps(SslContextBuilder.localhost().getSocketFactory());
+    SpdyServer server = new SpdyServer(new File(args[0]),
+        SslContextBuilder.localhost().getSocketFactory());
     server.run();
   }
 }
/Fim/
diff --git a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
index 129b35a..c6a85e1 100644
--- a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
+++ b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
@@ -49,7 +49,9 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+import okio.BufferedSource;
 import okio.Okio;
+import okio.Sink;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
 
@@ -151,9 +153,15 @@
         System.out.println();
       }
 
-      response.body().source().readAll(Okio.sink(System.out));
+      // Stream the response to the System.out as it is returned from the server.
+      Sink out = Okio.sink(System.out);
+      BufferedSource source = response.body().source();
+      while (!source.exhausted()) {
+        out.write(source.buffer(), source.buffer().size());
+        out.flush();
+      }
+
       response.body().close();
-      System.out.flush();
     } catch (IOException e) {
       e.printStackTrace();
     } finally {
/Fim/
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
index 110412e..074d9ad 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
@@ -941,8 +941,9 @@
     sink.write(new Buffer().writeUtf8("abcde"), 5);
     stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
     long startNanos = System.nanoTime();
+    sink.write(new Buffer().writeUtf8("f"), 1);
     try {
-      sink.write(new Buffer().writeUtf8("f"), 1); // This will time out waiting on the write window.
+      sink.flush(); // This will time out waiting on the write window.
       fail();
     } catch (InterruptedIOException expected) {
     }
@@ -957,6 +958,31 @@
     assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
   }
 
+  @Test public void outgoingWritesAreBatched() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+
+    // two outgoing writes
+    Sink sink = stream.getSink();
+    sink.write(new Buffer().writeUtf8("abcde"), 5);
+    sink.write(new Buffer().writeUtf8("fghij"), 5);
+    sink.close();
+
+    // verify the peer received one incoming frame
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    MockSpdyPeer.InFrame data = peer.takeFrame();
+    assertEquals(TYPE_DATA, data.type);
+    assertTrue(Arrays.equals("abcdefghij".getBytes("UTF-8"), data.data));
+    assertTrue(data.inFinished);
+  }
+
   @Test public void headers() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
/Fim/
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index 331536d..abc5df6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -53,7 +53,6 @@
 
   private final int id;
   private final SpdyConnection connection;
-  private long readTimeoutMillis = 0;
 
   /** Headers sent by the stream initiator. Immutable and non null. */
   private final List<Header> requestHeaders;
@@ -468,6 +467,14 @@
    * thread safe.
    */
   final class SpdyDataSink implements Sink {
+    private static final long EMIT_BUFFER_SIZE = 16384;
+
+    /**
+     * Buffer of outgoing data. This batches writes of small writes into this sink as larges
+     * frames written to the outgoing connection. Batching saves the (small) framing overhead.
+     */
+    private final Buffer sendBuffer = new Buffer();
+
     private boolean closed;
 
     /**
@@ -478,26 +485,34 @@
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
       assert (!Thread.holdsLock(SpdyStream.this));
-      while (byteCount > 0) {
-        long toWrite;
-        synchronized (SpdyStream.this) {
-          writeTimeout.enter();
-          try {
-            while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
-              waitForIo(); // Wait until we receive a WINDOW_UPDATE.
-            }
-          } finally {
-            writeTimeout.exitAndThrowIfTimedOut();
-          }
+      sendBuffer.write(source, byteCount);
+      while (sendBuffer.size() >= EMIT_BUFFER_SIZE) {
+        emitDataFrame(false);
+      }
+    }
 
-          checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
-          toWrite = Math.min(bytesLeftInWriteWindow, byteCount);
-          bytesLeftInWriteWindow -= toWrite;
+    /**
+     * Emit a single data frame to the connection. The frame's size be limited by this stream's
+     * write window. This method will block until the write window is nonempty.
+     */
+    private void emitDataFrame(boolean outFinished) throws IOException {
+      long toWrite;
+      synchronized (SpdyStream.this) {
+        writeTimeout.enter();
+        try {
+          while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
+            waitForIo(); // Wait until we receive a WINDOW_UPDATE.
+          }
+        } finally {
+          writeTimeout.exitAndThrowIfTimedOut();
         }
 
-        byteCount -= toWrite;
-        connection.writeData(id, false, source, toWrite);
+        checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
+        toWrite = Math.min(bytesLeftInWriteWindow, sendBuffer.size());
+        bytesLeftInWriteWindow -= toWrite;
       }
+
+      connection.writeData(id, outFinished && toWrite == sendBuffer.size(), sendBuffer, toWrite);
     }
 
     @Override public void flush() throws IOException {
@@ -505,6 +520,9 @@
       synchronized (SpdyStream.this) {
         checkOutNotClosed();
       }
+      while (sendBuffer.size() > 0) {
+        emitDataFrame(false);
+      }
       connection.flush();
     }
 
@@ -518,7 +536,15 @@
         if (closed) return;
       }
       if (!sink.finished) {
-        connection.writeData(id, true, null, 0);
+        // Emit the remaining data, setting the END_STREAM flag on the last frame.
+        if (sendBuffer.size() > 0) {
+          while (sendBuffer.size() > 0) {
+            emitDataFrame(true);
+          }
+        } else {
+          // Send an empty frame just so we can set the END_STREAM flag.
+          connection.writeData(id, true, null, 0);
+        }
       }
       synchronized (SpdyStream.this) {
         closed = true;
/Fim/
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java
index 88f7de6..a113eed 100644
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java
+++ b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java
@@ -30,6 +30,10 @@
   /**
    * Called when a server message is received. The {@code type} indicates whether the
    * {@code payload} should be interpreted as UTF-8 text or binary data.
+   *
+   * <p>Implementations <strong>must</strong> call {@code source.close()} before returning. This
+   * indicates completion of parsing the message payload and will consume any remaining bytes in
+   * the message.
    */
   void onMessage(BufferedSource payload, PayloadType type) throws IOException;
 
/Fim/
