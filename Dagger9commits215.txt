diff --git a/README.md b/README.md
new file mode 100644
index 0000000..3ef0375
--- /dev/null
+++ b/README.md
@@ -0,0 +1,21 @@
+Square Injector
+===============
+
+A JSR-330 dependency injector for Android and Java.
+
+License
+=======
+
+    Copyright 2012 Square, Inc.
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
/Fim/
diff --git a/LICENSE.txt b/LICENSE.txt
new file mode 100644
index 0000000..d645695
--- /dev/null
+++ b/LICENSE.txt
@@ -0,0 +1,202 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
/Fim/
diff --git a/checkstyle.xml b/checkstyle.xml
new file mode 100644
index 0000000..665f784
--- /dev/null
+++ b/checkstyle.xml
@@ -0,0 +1,120 @@
+<?xml version="1.0"?>
+<!DOCTYPE module PUBLIC
+    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
+    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
+
+<module name="Checker">
+    <module name="NewlineAtEndOfFile"/>
+    <module name="FileLength"/>
+    <module name="FileTabCharacter"/>
+
+    <!-- Trailing spaces -->
+    <module name="RegexpSingleline">
+        <property name="format" value="\s+$"/>
+        <property name="message" value="Line has trailing spaces."/>
+    </module>
+
+    <module name="TreeWalker">
+        <property name="cacheFile" value="${checkstyle.cache.file}"/>
+
+        <!-- Checks for Javadoc comments.                     -->
+        <!-- See http://checkstyle.sf.net/config_javadoc.html -->
+        <!--module name="JavadocMethod"/-->
+        <module name="JavadocType"/>
+        <!--module name="JavadocVariable"/-->
+        <module name="JavadocStyle"/>
+
+
+        <!-- Checks for Naming Conventions.                  -->
+        <!-- See http://checkstyle.sf.net/config_naming.html -->
+        <module name="ConstantName"/>
+        <module name="LocalFinalVariableName"/>
+        <module name="LocalVariableName"/>
+        <module name="MemberName"/>
+        <module name="MethodName"/>
+        <module name="PackageName"/>
+        <module name="ParameterName"/>
+        <module name="StaticVariableName"/>
+        <module name="TypeName"/>
+
+
+        <!-- Checks for imports                              -->
+        <!-- See http://checkstyle.sf.net/config_import.html -->
+        <module name="AvoidStarImport"/>
+        <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
+        <module name="RedundantImport"/>
+        <module name="UnusedImports"/>
+
+
+        <!-- Checks for Size Violations.                    -->
+        <!-- See http://checkstyle.sf.net/config_sizes.html -->
+        <module name="LineLength">
+            <property name="max" value="120"/>
+        </module>
+        <module name="MethodLength"/>
+        <module name="ParameterNumber"/>
+
+
+        <!-- Checks for whitespace                               -->
+        <!-- See http://checkstyle.sf.net/config_whitespace.html -->
+        <module name="GenericWhitespace"/>
+        <module name="EmptyForIteratorPad"/>
+        <module name="MethodParamPad"/>
+        <module name="NoWhitespaceAfter"/>
+        <module name="NoWhitespaceBefore"/>
+        <module name="OperatorWrap"/>
+        <module name="ParenPad"/>
+        <module name="TypecastParenPad"/>
+        <module name="WhitespaceAfter"/>
+        <module name="WhitespaceAround"/>
+
+
+        <!-- Modifier Checks                                    -->
+        <!-- See http://checkstyle.sf.net/config_modifiers.html -->
+        <!--module name="ModifierOrder"/-->
+        <module name="RedundantModifier"/>
+
+
+        <!-- Checks for blocks. You know, those {}'s         -->
+        <!-- See http://checkstyle.sf.net/config_blocks.html -->
+        <module name="AvoidNestedBlocks"/>
+        <!--module name="EmptyBlock"/-->
+        <module name="LeftCurly"/>
+        <module name="NeedBraces"/>
+        <module name="RightCurly"/>
+
+
+        <!-- Checks for common coding problems               -->
+        <!-- See http://checkstyle.sf.net/config_coding.html -->
+        <!--module name="AvoidInlineConditionals"/-->
+        <module name="CovariantEquals"/>
+        <module name="DoubleCheckedLocking"/>
+        <module name="EmptyStatement"/>
+        <module name="EqualsAvoidNull"/>
+        <module name="EqualsHashCode"/>
+        <!--module name="HiddenField"/-->
+        <module name="IllegalInstantiation"/>
+        <module name="InnerAssignment"/>
+        <!--module name="MagicNumber"/-->
+        <module name="MissingSwitchDefault"/>
+        <module name="RedundantThrows"/>
+        <module name="SimplifyBooleanExpression"/>
+        <module name="SimplifyBooleanReturn"/>
+
+        <!-- Checks for class design                         -->
+        <!-- See http://checkstyle.sf.net/config_design.html -->
+        <!--module name="DesignForExtension"/-->
+        <module name="FinalClass"/>
+        <module name="HideUtilityClassConstructor"/>
+        <module name="InterfaceIsType"/>
+        <!--s/module name="VisibilityModifier"/-->
+
+
+        <!-- Miscellaneous other checks.                   -->
+        <!-- See http://checkstyle.sf.net/config_misc.html -->
+        <module name="ArrayTypeStyle"/>
+        <!--module name="FinalParameters"/-->
+        <module name="TodoComment"/>
+        <module name="UpperEll"/>
+    </module>
+</module>
/Fim/
diff --git a/pom.xml b/pom.xml
new file mode 100644
index 0000000..d6521d6
--- /dev/null
+++ b/pom.xml
@@ -0,0 +1,128 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2012 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <groupId>com.squareup</groupId>
+    <artifactId>injector</artifactId>
+    <version>1.0-SNAPSHOT</version>
+    <packaging>jar</packaging>
+
+    <name>Injector</name>
+    <description>A JSR-330 dependency injector.</description>
+    <url>http://git.squareup.com/square/injector/</url>
+
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+
+        <!-- Compilation -->
+        <android-maven.version>3.2.0</android-maven.version>
+        <java.version>1.6</java.version>
+
+        <!-- Dependencies -->
+        <android.version>2.2.1</android.version>
+        <android.platform>8</android.platform>
+
+        <!-- Test Dependencies -->
+        <junit.version>4.10</junit.version>
+        <fest.version>1.4</fest.version>
+    </properties>
+
+    <scm>
+        <url>http://git.squareup.com/square/injector/</url>
+        <connection>scm:git:git://git.squareup.com/square/injector.git</connection>
+        <developerConnection>scm:git:ssh://git@git.squareup.com/square/injector.git</developerConnection>
+    </scm>
+
+    <issueManagement>
+        <system>GitHub Issues</system>
+        <url>http://git.squareup.com/square/injector/issues</url>
+    </issueManagement>
+
+    <licenses>
+        <license>
+            <name>Apache 2.0</name>
+            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+        </license>
+    </licenses>
+
+    <organization>
+        <name>Square, Inc.</name>
+        <url>http://squareup.com</url>
+    </organization>
+
+    <dependencies>
+        <dependency>
+            <groupId>javax.inject</groupId>
+            <artifactId>javax.inject</artifactId>
+            <version>1</version>
+        </dependency>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <version>${junit.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.easytesting</groupId>
+            <artifactId>fest-assert</artifactId>
+            <version>${fest.version}</version>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <finalName>square-${project.artifactId}-${project.version}</finalName>
+
+        <plugins>
+            <plugin>
+                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+                <artifactId>android-maven-plugin</artifactId>
+                <version>${android-maven.version}</version>
+            </plugin>
+
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <version>2.5</version>
+                <configuration>
+                    <source>${java.version}</source>
+                    <target>${java.version}</target>
+                </configuration>
+            </plugin>
+
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-checkstyle-plugin</artifactId>
+                <version>2.9.1</version>
+                <configuration>
+                    <failsOnError>true</failsOnError>
+                    <configLocation>checkstyle.xml</configLocation>
+                </configuration>
+                <executions>
+                    <execution>
+                        <phase>verify</phase>
+                        <goals>
+                            <goal>checkstyle</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+        </plugins>
+    </build>
+</project>
/Fim/
diff --git a/src/main/java/com/squareup/injector/Binding.java b/src/main/java/com/squareup/injector/Binding.java
new file mode 100644
index 0000000..10dec08
--- /dev/null
+++ b/src/main/java/com/squareup/injector/Binding.java
@@ -0,0 +1,51 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import javax.inject.Provider;
+
+/**
+ * Injects a value of a specific type.
+ *
+ * @author Jesse Wilson
+ */
+abstract class Binding<T> implements Provider<T>, MembersInjector<T> {
+  final Object requiredBy;
+  final Key<T> key;
+
+  protected Binding(Object requiredBy, Key<T> key) {
+    this.requiredBy = requiredBy;
+    this.key = key;
+  }
+
+  /**
+   * Links this binding to its dependencies.
+   */
+  void attach(Linker linker) {
+  }
+
+  @Override public void injectMembers(T t) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override public T get() {
+    throw new UnsupportedOperationException();
+  }
+
+  public boolean isSingleton() {
+    return false;
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/BuiltInBinding.java b/src/main/java/com/squareup/injector/BuiltInBinding.java
new file mode 100644
index 0000000..f490c29
--- /dev/null
+++ b/src/main/java/com/squareup/injector/BuiltInBinding.java
@@ -0,0 +1,46 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+
+/**
+ * Injects a Provider or a MembersInjector.
+ *
+ * @author Jesse Wilson
+ */
+final class BuiltInBinding<T> extends Binding<T> {
+  private Binding<?> delegate;
+
+  public BuiltInBinding(Key<T> key, Object requiredBy) {
+    super(requiredBy, key);
+  }
+
+  @Override void attach(Linker linker) {
+    Type providedType = ((ParameterizedType) key.type).getActualTypeArguments()[0];
+    delegate = linker.getBinding(new Key<T>(providedType, key.annotation), requiredBy);
+  }
+
+  @Override public void injectMembers(T t) {
+    throw new UnsupportedOperationException();
+  }
+
+  @SuppressWarnings("unchecked") // At runtime we know 'T' is a Provider.
+  @Override public T get() {
+    return (T) delegate;
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/ConstructorBinding.java b/src/main/java/com/squareup/injector/ConstructorBinding.java
new file mode 100644
index 0000000..023c839
--- /dev/null
+++ b/src/main/java/com/squareup/injector/ConstructorBinding.java
@@ -0,0 +1,148 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.List;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+/**
+ * A binding that uses the constructor of a concrete class.
+ *
+ * @author Jesse Wilson
+ */
+final class ConstructorBinding<T> extends Binding<T> {
+  private final Constructor<T> constructor;
+  private final Field[] fields;
+  private Binding<?>[] parameters;
+  private Binding<?>[] fieldBindings;
+
+  private ConstructorBinding(Class<?> type, Key<T> key, Constructor<T> constructor, Field[] fields) {
+    super(type, key);
+    this.constructor = constructor;
+    this.fields = fields;
+  }
+
+  @Override void attach(Linker linker) {
+    // Field bindings.
+    fieldBindings = new Binding<?>[fields.length];
+    for (int i = 0; i < fields.length; i++) {
+      Field field = fields[i];
+      Key<Object> fieldKey = Key.get(field.getGenericType(), field.getAnnotations(), field);
+      fieldBindings[i] = linker.getBinding(fieldKey, field);
+    }
+
+    // Constructor bindings.
+    Type[] types = constructor.getGenericParameterTypes();
+    Annotation[][] annotations = constructor.getParameterAnnotations();
+    parameters = new Binding[types.length];
+    for (int i = 0; i < parameters.length; i++) {
+      String name = constructor + " parameter " + i;
+      parameters[i] = linker.getBinding(Key.get(types[i], annotations[i], name), constructor);
+    }
+  }
+
+  @Override public T get() {
+    Object[] args = new Object[parameters.length];
+    for (int i = 0; i < parameters.length; i++) {
+      args[i] = parameters[i].get();
+    }
+    T result;
+    try {
+      result = constructor.newInstance(args);
+    } catch (IllegalAccessException e) {
+      throw new AssertionError(e);
+    } catch (InvocationTargetException e) {
+      throw new RuntimeException(e.getCause());
+    } catch (InstantiationException e) {
+      throw new RuntimeException(e);
+    }
+    injectMembers(result);
+    return result;
+  }
+
+  @Override public void injectMembers(T t) {
+    try {
+      for (int i = 0; i < fields.length; i++) {
+        fields[i].set(t, fieldBindings[i].get());
+      }
+    } catch (IllegalAccessException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  @Override public boolean isSingleton() {
+    return constructor.getDeclaringClass().isAnnotationPresent(Singleton.class);
+  }
+
+  public static <T> Binding<T> create(Key<T> key) {
+    if (!(key.type instanceof Class) || key.annotation != null) {
+      throw new IllegalArgumentException("No binding for " + key);
+    }
+
+    @SuppressWarnings("unchecked") // The key type implies the class type.
+    Class<T> type = (Class<T>) key.type;
+
+    /*
+     * Lookup the injectable fields and their corresponding keys.
+     */
+    final List<Field> injectedFields = new ArrayList<Field>();
+    for (Class<?> c = type; c != Object.class; c = c.getSuperclass()) {
+      for (Field field : c.getDeclaredFields()) {
+        if (field.getAnnotation(Inject.class) == null) {
+          continue;
+        }
+        field.setAccessible(true);
+        injectedFields.add(field);
+      }
+    }
+
+    /*
+     * Lookup @Inject-annotated constructors. If there's no @Inject-annotated
+     * constructor, use a default constructor if the class has other injections.
+     */
+    Constructor<T> injectedConstructor = null;
+    for (Constructor<T> constructor : (Constructor<T>[]) type.getDeclaredConstructors()) {
+      if (constructor.getAnnotation(Inject.class) == null) {
+        continue;
+      }
+      if (injectedConstructor != null) {
+        throw new IllegalArgumentException("Too many injectable constructors on " + type);
+      }
+      constructor.setAccessible(true);
+      injectedConstructor = constructor;
+    }
+    if (injectedConstructor == null) {
+      if (injectedFields.isEmpty()) {
+        throw new IllegalArgumentException("No injectable constructor on " + type);
+      }
+      try {
+        injectedConstructor = type.getDeclaredConstructor();
+      } catch (NoSuchMethodException e) {
+        throw new IllegalArgumentException("No injectable constructor on " + type);
+      }
+    }
+
+    return new ConstructorBinding<T>(type, key, injectedConstructor,
+        injectedFields.toArray(new Field[injectedFields.size()]));
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/Injector.java b/src/main/java/com/squareup/injector/Injector.java
new file mode 100644
index 0000000..2552d54
--- /dev/null
+++ b/src/main/java/com/squareup/injector/Injector.java
@@ -0,0 +1,154 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import javax.inject.Provider;
+
+/**
+ * Dependency injector.
+ *
+ * <p>The following injection features are supported:
+ * <ul>
+ *   <li>Field injection. A class may have any number of field injections, and
+ *       fields may be of any visibility. Static fields will be injected each
+ *       time an instance is injected.
+ *   <li>Constructor injection. A class may have a single {@code
+ *       @Inject}-annotated constructor. Classes that have fields injected
+ *       may omit the {@link @Inject} annotation if they have a public
+ *       no-arguments constructor.
+ *   <li>Injection of {@code @Provides} method parameters.
+ *   <li>{@code @Provides} methods annotated {@code @Singleton}.
+ *   <li>Constructor-injected classes annotated {@code @Singleton}.
+ *   <li>Injection of {@link Provider}s.
+ *   <li>Binding annotations on injected parameters and fields.
+ *   <li>JSR 330 annotations.
+ * </ul>
+ *
+ * <p>The following injection features are not currently supported:
+ * <ul>
+ *   <li>Method injection.</li>
+ *   <li>Circular dependencies.</li>
+ * </ul>
+ *
+ * @author Jesse Wilson
+ */
+public final class Injector {
+  private static final Object UNINITIALIZED = new Object();
+
+  /** All errors encountered during injection. */
+  private final List<String> errors = new ArrayList<String>();
+
+  /** All of the injector's bindings. */
+  private final Map<Key<?>, Binding<?>> bindings = new HashMap<Key<?>, Binding<?>>();
+
+  /**
+   * Creates an injector defined by {@code modules} and immediately uses it to
+   * create an instance of {@code type}. The modules can be of any type, and
+   * must contain {@code @Provides} methods.
+   */
+  public <T> T inject(Class<T> type, Object... modules) {
+    Key<T> key = new Key<T>(type, null);
+    return new Injector().inject(key, modules);
+  }
+
+  private <T> T inject(Key<T> key, Object[] modules) {
+    if (!bindings.isEmpty()) {
+      throw new IllegalStateException("Injectors may only inject once.");
+    }
+
+    for (Object module : modules) {
+      try {
+        install(module);
+      } catch (Exception e) {
+        errors.add(e.getMessage());
+      }
+    }
+
+    Linker linker = new Linker(this);
+    linker.getBinding(key, "root injection"); // Seed this requirement early.
+    linker.link(bindings.values());
+
+    if (!errors.isEmpty()) {
+      StringBuilder message = new StringBuilder();
+      message.append("Errors creating injector:");
+      for (String error : errors) {
+        message.append("\n  ").append(error);
+      }
+      throw new IllegalArgumentException(message.toString());
+    }
+
+    return linker.getBinding(key, "root injection").get();
+  }
+
+  private void install(Object module) {
+    boolean hasProvidesMethods = false;
+    for (Class<?> c = module.getClass(); c != Object.class; c = c.getSuperclass()) {
+      for (Method method : c.getDeclaredMethods()) {
+        if (method.getAnnotation(Provides.class) != null) {
+          install(module, method);
+          hasProvidesMethods = true;
+        }
+      }
+    }
+    if (!hasProvidesMethods) {
+      throw new IllegalArgumentException("No @Provides methods on " + module);
+    }
+  }
+
+  private <T> void install(Object module, Method method) {
+    Key<T> key = Key.get(method.getGenericReturnType(), method.getAnnotations(), method);
+    putBinding(new ProviderMethodBinding<T>(method, key, module));
+  }
+
+  @SuppressWarnings("unchecked") // Typesafe heterogeneous container.
+  <T> Binding<T> getBinding(Key<T> key) {
+    return (Binding<T>) bindings.get(key);
+  }
+
+  <T> void putBinding(final Binding<T> binding) {
+    if (binding.isSingleton()) {
+      bindings.put(binding.key, new Binding<T>(binding.requiredBy, binding.key) {
+        private Object onlyInstance = UNINITIALIZED;
+        @Override void attach(Linker linker) {
+          binding.attach(linker);
+        }
+        @Override public void injectMembers(T t) {
+          binding.injectMembers(t);
+        }
+        @Override public T get() {
+          if (onlyInstance == UNINITIALIZED) {
+            onlyInstance = binding.get();
+          }
+          return (T) onlyInstance;
+        }
+        @Override public boolean isSingleton() {
+          return binding.isSingleton();
+        }
+      });
+    } else {
+      bindings.put(binding.key, binding);
+    }
+  }
+
+  void addError(String message) {
+    errors.add(message);
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/Key.java b/src/main/java/com/squareup/injector/Key.java
new file mode 100644
index 0000000..f44d421
--- /dev/null
+++ b/src/main/java/com/squareup/injector/Key.java
@@ -0,0 +1,71 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import javax.inject.Qualifier;
+
+/**
+ * Identifies the value to be injected.
+ *
+ * @author Jesse Wilson
+ */
+final class Key<T> {
+  final Type type;
+  final Annotation annotation;
+
+  Key(Type type, Annotation annotation) {
+    this.type = type;
+    this.annotation = annotation;
+  }
+
+  static <T> Key<T> get(Type type, Annotation[] annotations, Object subject) {
+    Annotation bindingAnnotation = null;
+    for (Annotation a : annotations) {
+      if (a.annotationType().getAnnotation(Qualifier.class) == null) {
+        continue;
+      }
+      if (bindingAnnotation != null) {
+        throw new IllegalArgumentException("Too many binding annotations on " + subject);
+      }
+      bindingAnnotation = a;
+    }
+    return new Key<T>(type, bindingAnnotation);
+  }
+
+  private static boolean equal(Object a, Object b) {
+    return a == null ? b == null : a.equals(b);
+  }
+
+  @Override public boolean equals(Object o) {
+    return o instanceof Key
+        && ((Key) o).type.equals(type)
+        && equal(annotation, ((Key) o).annotation);
+  }
+
+  @Override public int hashCode() {
+    int result = type.hashCode();
+    if (annotation != null) {
+      result += (37 * annotation.hashCode());
+    }
+    return result;
+  }
+
+  @Override public String toString() {
+    return "key[type=" + type + ",annotation=" + annotation + "]";
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/Linker.java b/src/main/java/com/squareup/injector/Linker.java
new file mode 100644
index 0000000..ac15740
--- /dev/null
+++ b/src/main/java/com/squareup/injector/Linker.java
@@ -0,0 +1,117 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.ArrayDeque;
+import java.util.Collection;
+import java.util.Queue;
+import javax.inject.Provider;
+
+/**
+ * Links bindings to their dependencies.
+ *
+ * @author Jesse Wilson
+ */
+final class Linker {
+  private final Injector injector;
+
+  /** Bindings requiring a call to attach(). May contain deferred bindings. */
+  private final Queue<Binding<?>> unattachedBindings = new ArrayDeque<Binding<?>>();
+
+  /** True unless calls to getBinding() were unable to satisfy the binding. */
+  private boolean currentAttachSuccess = true;
+
+  public Linker(Injector injector) {
+    this.injector = injector;
+  }
+
+  /**
+   * Links the bindings in {@code bindings}, creating JIT bindings as necessary
+   * to fill in the gaps.
+   */
+  public void link(Collection<Binding<?>> bindings) {
+    unattachedBindings.addAll(bindings);
+
+    Binding binding;
+    while ((binding = unattachedBindings.poll()) != null) {
+      if (binding instanceof DeferredBinding) {
+        promoteDeferredBinding((DeferredBinding<?>) binding);
+      } else {
+        attachBinding(binding);
+      }
+    }
+  }
+
+  private void attachBinding(Binding binding) {
+    currentAttachSuccess = true;
+    binding.attach(this);
+    if (!currentAttachSuccess) {
+      unattachedBindings.add(binding);
+    }
+  }
+
+  private <T> void promoteDeferredBinding(DeferredBinding<T> deferred) {
+    try {
+      Binding<T> promoted;
+      if (deferred.key.type instanceof ParameterizedType) {
+        Type rawType = ((ParameterizedType) deferred.key.type).getRawType();
+        if (rawType == Provider.class || rawType == MembersInjector.class) {
+          // Handle injections like Provider<Foo> and MembersInjector<Foo> by delegating.
+          promoted = new BuiltInBinding<T>(deferred.key, deferred.requiredBy);
+        } else {
+          throw new IllegalArgumentException("No binding for " + deferred.key);
+        }
+      } else {
+        // Handle all other injections with constructor bindings.
+        promoted = ConstructorBinding.create(deferred.key);
+      }
+      unattachedBindings.add(promoted);
+      injector.putBinding(promoted);
+    } catch (Exception e) {
+      injector.addError(e.getMessage() + " required by " + deferred.requiredBy);
+      injector.putBinding(new UnresolvedBinding<T>(deferred.requiredBy, deferred.key));
+    }
+  }
+
+  /**
+   * Returns the binding if it exists immediately. Otherwise this returns
+   * null. The injector will create that binding later and reattach the
+   * caller's binding.
+   */
+  public <T> Binding<T> getBinding(final Key<T> key, final Object requiredBy) {
+    Binding<T> binding = injector.getBinding(key);
+    if (binding == null) {
+      // We can't satisfy this binding. Make sure it'll work next time!
+      unattachedBindings.add(new DeferredBinding<T>(requiredBy, key));
+      currentAttachSuccess = false;
+    }
+    return binding;
+  }
+
+  private static class DeferredBinding<T> extends Binding<T> {
+    private DeferredBinding(Object requiredBy, Key<T> key) {
+      super(requiredBy, key);
+    }
+  }
+
+  private static class UnresolvedBinding<T> extends Binding<T> {
+    private UnresolvedBinding(Object definedBy, Key<T> key) {
+      super(definedBy, key);
+    }
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/MembersInjector.java b/src/main/java/com/squareup/injector/MembersInjector.java
new file mode 100644
index 0000000..4a00117
--- /dev/null
+++ b/src/main/java/com/squareup/injector/MembersInjector.java
@@ -0,0 +1,41 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+/**
+ * Injects dependencies into the fields and methods on instances of type
+ * {@code T}. Ignores the presence or absence of an injectable constructor.
+ *
+ * @param <T> type to inject members of
+ *
+ * @author Bob Lee
+ * @author Jesse Wilson
+ */
+public interface MembersInjector<T> {
+
+  /**
+   * Injects dependencies into the fields and methods of {@code instance}.
+   * Ignores the presence or absence of an injectable constructor.
+   *
+   * <p>Whenever the injector creates an instance, it performs this injection
+   * automatically (after first performing constructor injection), so if you're
+   * able to let the injector create all your objects for you, you'll never need
+   * to use this method.
+   *
+   * @param instance to inject members on. May be {@code null}.
+   */
+  void injectMembers(T instance);
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/ProviderMethodBinding.java b/src/main/java/com/squareup/injector/ProviderMethodBinding.java
new file mode 100644
index 0000000..fef0e4f
--- /dev/null
+++ b/src/main/java/com/squareup/injector/ProviderMethodBinding.java
@@ -0,0 +1,69 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import javax.inject.Singleton;
+
+/**
+ * Invokes a method to provide a value. The method's parameters are injected.
+ *
+ * @author Jesse Wilson
+ */
+final class ProviderMethodBinding<T> extends Binding<T> {
+  private Binding[] parameters;
+  private final Method method;
+  private final Object instance;
+
+  public ProviderMethodBinding(Method method, Key<T> key, Object instance) {
+    super(method, key);
+    this.method = method;
+    this.instance = instance;
+    method.setAccessible(true);
+  }
+
+  @Override void attach(Linker linker) {
+    Type[] types = method.getGenericParameterTypes();
+    Annotation[][] annotations = method.getParameterAnnotations();
+    parameters = new Binding[types.length];
+    for (int i = 0; i < parameters.length; i++) {
+      String name = method + " parameter " + i;
+      parameters[i] = linker.getBinding(Key.get(types[i], annotations[i], name), method);
+    }
+  }
+
+  @SuppressWarnings("unchecked") // The caller is required to make 'method' and 'T' match
+  @Override public T get() {
+    Object[] args = new Object[parameters.length];
+    for (int i = 0; i < parameters.length; i++) {
+      args[i] = parameters[i].get();
+    }
+    try {
+      return (T) method.invoke(instance, args);
+    } catch (IllegalAccessException e) {
+      throw new RuntimeException(e);
+    } catch (InvocationTargetException e) {
+      throw new RuntimeException(e.getCause());
+    }
+  }
+
+  @Override public boolean isSingleton() {
+    return method.isAnnotationPresent(Singleton.class);
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/Provides.java b/src/main/java/com/squareup/injector/Provides.java
new file mode 100644
index 0000000..13dd77d
--- /dev/null
+++ b/src/main/java/com/squareup/injector/Provides.java
@@ -0,0 +1,34 @@
+/**
+ * Copyright (C) 2007 Google Inc.
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Annotates methods of a module to create a provider method binding. The
+ * method's return type is bound to it's returned value. The injector will pass
+ * dependencies to the method as parameters.
+ *
+ * @author Bob Lee
+ */
+@Documented @Target(METHOD) @Retention(RUNTIME)
+public @interface Provides {}
/Fim/
diff --git a/src/test/java/com/squareup/injector/InjectorTest.java b/src/test/java/com/squareup/injector/InjectorTest.java
new file mode 100644
index 0000000..a96a839
--- /dev/null
+++ b/src/test/java/com/squareup/injector/InjectorTest.java
@@ -0,0 +1,297 @@
+/*
+ * Copyright (C) 2010 Google Inc.
+ * Copyright (C) 2012 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.inject.Inject;
+import javax.inject.Named;
+import javax.inject.Provider;
+import javax.inject.Singleton;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * @author Jesse Wilson
+ */
+@SuppressWarnings("unused")
+public final class InjectorTest {
+  @Test public void basicInjection() {
+    G g = new Injector().inject(G.class, new Object() {
+      @Provides E provideE(F f) {
+        return new E(f);
+      }
+      @Provides F provideF() {
+        return new F();
+      }
+    });
+
+    assertThat(g.a).isNotNull();
+    assertThat(g.b).isNotNull();
+    assertThat(g.c).isNotNull();
+    assertThat(g.d).isNotNull();
+    assertThat(g.e).isNotNull();
+    assertThat(g.e.f).isNotNull();
+  }
+
+  @Test public void memberInjection() {
+    MembersInjectors membersInjectors = new Injector().inject(MembersInjectors.class, new Object() {
+      @Provides E provideE(F f) {
+        return new E(f);
+      }
+      @Provides F provideF() {
+        return new F();
+      }
+    });
+
+    G g = new G(new C(), new D());
+    membersInjectors.gInjector.injectMembers(g);
+    assertThat(g.a).isNotNull();
+    assertThat(g.b).isNotNull();
+    assertThat(g.c).isNotNull();
+    assertThat(g.d).isNotNull();
+    assertThat(g.e).isNotNull();
+    assertThat(g.e.f).isNotNull();
+  }
+
+  static class A {
+    @Inject A() {}
+  }
+
+  static class B {
+    @Inject B() {}
+  }
+
+  @Singleton
+  static class C {
+    @Inject C() {}
+  }
+
+  @Singleton
+  static class D {
+    @Inject D() {}
+  }
+
+  static class E {
+    F f;
+    E(F f) {
+      this.f = f;
+    }
+  }
+
+  static class F {}
+
+  static class G {
+    @Inject A a;
+    @Inject B b;
+    C c;
+    D d;
+    @Inject E e;
+    @Inject G(C c, D d) {
+      this.c = c;
+      this.d = d;
+    }
+  }
+
+  static class MembersInjectors {
+    @Inject MembersInjector<G> gInjector;
+  }
+
+  @Test public void providerInjection() {
+    H h = new Injector().inject(H.class);
+    assertThat(h.aProvider.get()).isNotNull();
+    assertThat(h.aProvider.get()).isNotNull();
+    assertThat(h.aProvider.get()).isNotSameAs(h.aProvider.get());
+  }
+
+  static class H {
+    @Inject Provider<A> aProvider;
+  }
+
+  @Test public void singletons() {
+    J j = new Injector().inject(J.class, new Object() {
+      @Provides @Singleton F provideK() {
+        return new F();
+      }
+    });
+    assertThat(j.fProvider.get()).isSameAs(j.fProvider.get());
+    assertThat(j.iProvider.get()).isSameAs(j.iProvider.get());
+  }
+
+  @Singleton
+  static class I {
+    @Inject I() {}
+  }
+
+  static class J {
+    @Inject Provider<F> fProvider;
+    @Inject Provider<I> iProvider;
+    @Inject J() {}
+  }
+
+  @Test public void bindingAnnotations() {
+    final A one = new A();
+    final A two = new A();
+
+    K k = new Injector().inject(K.class, new Object() {
+      @Provides @Named("one") A getOne() {
+        return one;
+      }
+      @Provides @Named("two") A getTwo() {
+        return two;
+      }
+    });
+
+    assertThat(k.a).isNotNull();
+    assertThat(one).isSameAs(k.aOne);
+    assertThat(two).isSameAs(k.aTwo);
+  }
+
+  public static class K {
+    @Inject A a;
+    @Inject @Named("one") A aOne;
+    @Inject @Named("two") A aTwo;
+  }
+
+  @Test public void singletonBindingAnnotationAndProvider() {
+    final AtomicReference<A> a1 = new AtomicReference<A>();
+    final AtomicReference<A> a2 = new AtomicReference<A>();
+
+    L l = new Injector().inject(L.class, new Object() {
+      @Provides @Singleton @Named("one") F provideF(Provider<A> aProvider) {
+        a1.set(aProvider.get());
+        a2.set(aProvider.get());
+        return new F();
+      }
+    });
+
+    assertThat(a1.get()).isNotNull();
+    assertThat(a2.get()).isNotNull();
+    assertThat(a1.get()).isNotSameAs(a2.get());
+    assertThat(l).isSameAs(l.lProvider.get());
+  }
+
+  @Singleton
+  public static class L {
+    @Inject @Named("one") F f;
+    @Inject Provider<L> lProvider;
+  }
+
+  @Test public void singletonInGraph() {
+    M m = new Injector().inject(M.class, new Object() {
+      @Provides @Singleton F provideF() {
+        return new F();
+      }
+    });
+
+    assertThat(m.f1).isSameAs(m.f2);
+    assertThat(m.f1).isSameAs(m.n1.f1);
+    assertThat(m.f1).isSameAs(m.n1.f2);
+    assertThat(m.f1).isSameAs(m.n2.f1);
+    assertThat(m.f1).isSameAs(m.n2.f2);
+    assertThat(m.f1).isSameAs(m.n1.fProvider.get());
+    assertThat(m.f1).isSameAs(m.n2.fProvider.get());
+  }
+
+  public static class M {
+    @Inject N n1;
+    @Inject N n2;
+    @Inject F f1;
+    @Inject F f2;
+  }
+
+  public static class N {
+    @Inject F f1;
+    @Inject F f2;
+    @Inject Provider<F> fProvider;
+  }
+
+  @Test public void noJitBindingsForAnnotations() {
+    try {
+      new Injector().inject(O.class);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  public static class O {
+    @Inject @Named("a") A a;
+  }
+
+  @Test public void subclasses() {
+    Q q = new Injector().inject(Q.class, new Object() {
+      @Provides F provideF() {
+        return new F();
+      }
+    });
+    assertThat(q.f).isNotNull();
+  }
+
+  public static class P {
+    @Inject F f;
+  }
+
+  public static class Q extends P {
+    @Inject Q() {}
+  }
+
+  @Test public void singletonsAreNotEager() {
+    final AtomicBoolean sInjected = new AtomicBoolean();
+
+    R.injected = false;
+    new Injector().inject(A.class, new Object() {
+      @Provides F provideF(R r) {
+        return new F();
+      }
+
+      @Provides @Singleton S provideS() {
+        sInjected.set(true);
+        return new S();
+      }
+    });
+
+    assertThat(R.injected).isFalse();
+    assertThat(sInjected.get()).isFalse();
+  }
+
+  @Singleton
+  static class R {
+    static boolean injected = false;
+    @Inject R() {
+      injected = true;
+    }
+  }
+
+  static class S {}
+
+  @Test public void providerMethodsConflict() {
+    try {
+      new Injector().inject(G.class, new Object() {
+        @Provides A provideA1() {
+          throw new AssertionError();
+        }
+        @Provides A provideA2() {
+          throw new AssertionError();
+        }
+      });
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+}
/Fim/
diff --git a/pom.xml b/pom.xml
index d6521d6..6d0c9b1 100644
--- a/pom.xml
+++ b/pom.xml
@@ -31,16 +31,12 @@
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 
         <!-- Compilation -->
-        <android-maven.version>3.2.0</android-maven.version>
         <java.version>1.6</java.version>
 
-        <!-- Dependencies -->
-        <android.version>2.2.1</android.version>
-        <android.platform>8</android.platform>
-
         <!-- Test Dependencies -->
         <junit.version>4.10</junit.version>
         <fest.version>1.4</fest.version>
+        <javax.inject.version>1</javax.inject.version>
     </properties>
 
     <scm>
@@ -70,7 +66,7 @@
         <dependency>
             <groupId>javax.inject</groupId>
             <artifactId>javax.inject</artifactId>
-            <version>1</version>
+            <version>${javax.inject.version}</version>
         </dependency>
         <dependency>
             <groupId>junit</groupId>
@@ -91,12 +87,6 @@
 
         <plugins>
             <plugin>
-                <groupId>com.jayway.maven.plugins.android.generation2</groupId>
-                <artifactId>android-maven-plugin</artifactId>
-                <version>${android-maven.version}</version>
-            </plugin>
-
-            <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
                 <version>2.5</version>
/Fim/
diff --git a/src/main/java/com/squareup/injector/ConstructorBinding.java b/src/main/java/com/squareup/injector/ConstructorBinding.java
index 023c839..bd82365 100644
--- a/src/main/java/com/squareup/injector/ConstructorBinding.java
+++ b/src/main/java/com/squareup/injector/ConstructorBinding.java
@@ -136,7 +136,7 @@
         throw new IllegalArgumentException("No injectable constructor on " + type);
       }
       try {
-        injectedConstructor = type.getDeclaredConstructor();
+        injectedConstructor = type.getConstructor();
       } catch (NoSuchMethodException e) {
         throw new IllegalArgumentException("No injectable constructor on " + type);
       }
/Fim/
diff --git a/src/main/java/com/squareup/injector/Injector.java b/src/main/java/com/squareup/injector/Injector.java
index 2552d54..6ed2d4b 100644
--- a/src/main/java/com/squareup/injector/Injector.java
+++ b/src/main/java/com/squareup/injector/Injector.java
@@ -38,7 +38,7 @@
  *   <li>{@code @Provides} methods annotated {@code @Singleton}.
  *   <li>Constructor-injected classes annotated {@code @Singleton}.
  *   <li>Injection of {@link Provider}s.
- *   <li>Binding annotations on injected parameters and fields.
+ *   <li>Qualifier annotations on injected parameters and fields.
  *   <li>JSR 330 annotations.
  * </ul>
  *
@@ -65,8 +65,7 @@
    * must contain {@code @Provides} methods.
    */
   public <T> T inject(Class<T> type, Object... modules) {
-    Key<T> key = new Key<T>(type, null);
-    return new Injector().inject(key, modules);
+    return inject(new Key<T>(type, null), modules);
   }
 
   private <T> T inject(Key<T> key, Object[] modules) {
/Fim/
diff --git a/src/main/java/com/squareup/injector/Key.java b/src/main/java/com/squareup/injector/Key.java
index f44d421..06c5ab7 100644
--- a/src/main/java/com/squareup/injector/Key.java
+++ b/src/main/java/com/squareup/injector/Key.java
@@ -25,6 +25,13 @@
  * @author Jesse Wilson
  */
 final class Key<T> {
+  private static final LruCache<Class<? extends Annotation>, Boolean> IS_QUALIFIER_ANNOTATION
+      = new LruCache<Class<? extends Annotation>, Boolean>(Integer.MAX_VALUE) {
+    @Override protected Boolean create(Class<? extends Annotation> annotationType) {
+      return annotationType.isAnnotationPresent(Qualifier.class);
+    }
+  };
+
   final Type type;
   final Annotation annotation;
 
@@ -36,7 +43,7 @@
   static <T> Key<T> get(Type type, Annotation[] annotations, Object subject) {
     Annotation bindingAnnotation = null;
     for (Annotation a : annotations) {
-      if (a.annotationType().getAnnotation(Qualifier.class) == null) {
+      if (!IS_QUALIFIER_ANNOTATION.get(a.annotationType())) {
         continue;
       }
       if (bindingAnnotation != null) {
/Fim/
diff --git a/src/main/java/com/squareup/injector/Linker.java b/src/main/java/com/squareup/injector/Linker.java
index ac15740..53a326b 100644
--- a/src/main/java/com/squareup/injector/Linker.java
+++ b/src/main/java/com/squareup/injector/Linker.java
@@ -17,8 +17,8 @@
 
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
-import java.util.ArrayDeque;
 import java.util.Collection;
+import java.util.LinkedList;
 import java.util.Queue;
 import javax.inject.Provider;
 
@@ -31,7 +31,7 @@
   private final Injector injector;
 
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
-  private final Queue<Binding<?>> unattachedBindings = new ArrayDeque<Binding<?>>();
+  private final Queue<Binding<?>> unattachedBindings = new LinkedList<Binding<?>>();
 
   /** True unless calls to getBinding() were unable to satisfy the binding. */
   private boolean currentAttachSuccess = true;
@@ -57,14 +57,19 @@
     }
   }
 
-  private void attachBinding(Binding binding) {
-    currentAttachSuccess = true;
-    binding.attach(this);
-    if (!currentAttachSuccess) {
-      unattachedBindings.add(binding);
-    }
-  }
-
+  /**
+   * Creates a just-in-time binding for the key in {@code deferred}. The type of
+   * binding to be created depends on the key's type:
+   * <ul>
+   *   <li>Injections of {@code Provider<Foo>} and {@code MembersInjector<Bar>}
+   *       will delegate to the bindings of {@code Foo} and {@code Bar}
+   *       respectively.
+   *   <li>Injections of other types will use the injectable constructors of
+   *       those classes.
+   * </ul>
+   * Once the just-in-time binding has been created, it is enqueued to be
+   * attached until its own dependencies have been satisfied.
+   */
   private <T> void promoteDeferredBinding(DeferredBinding<T> deferred) {
     try {
       Binding<T> promoted;
@@ -89,6 +94,19 @@
   }
 
   /**
+   * Attempts to attach {@code binding} to its dependencies. If any dependency
+   * is not available, the attach will fail. We'll enqueue creation of that
+   * dependency and retry the attachment later.
+   */
+  private void attachBinding(Binding binding) {
+    currentAttachSuccess = true;
+    binding.attach(this);
+    if (!currentAttachSuccess) {
+      unattachedBindings.add(binding);
+    }
+  }
+
+  /**
    * Returns the binding if it exists immediately. Otherwise this returns
    * null. The injector will create that binding later and reattach the
    * caller's binding.
/Fim/
diff --git a/src/main/java/com/squareup/injector/LruCache.java b/src/main/java/com/squareup/injector/LruCache.java
new file mode 100644
index 0000000..e12b0de
--- /dev/null
+++ b/src/main/java/com/squareup/injector/LruCache.java
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.injector;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+/**
+ * Private copy of {@code android.util.LruCache}.
+ */
+class LruCache<K, V> {
+  private final LinkedHashMap<K, V> map;
+
+  /** Size of this cache in units. Not necessarily the number of elements. */
+  private int size;
+  private int maxSize;
+
+  private int putCount;
+  private int createCount;
+  private int evictionCount;
+  private int hitCount;
+  private int missCount;
+
+  /**
+   * @param maxSize for caches that do not override {@link #sizeOf}, this is
+   *     the maximum number of entries in the cache. For all other caches,
+   *     this is the maximum sum of the sizes of the entries in this cache.
+   */
+  public LruCache(int maxSize) {
+    if (maxSize <= 0) {
+      throw new IllegalArgumentException("maxSize <= 0");
+    }
+    this.maxSize = maxSize;
+    this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
+  }
+
+  /**
+   * Returns the value for {@code key} if it exists in the cache or can be
+   * created by {@code #create}. If a value was returned, it is moved to the
+   * head of the queue. This returns null if a value is not cached and cannot
+   * be created.
+   */
+  public final V get(K key) {
+    if (key == null) {
+      throw new NullPointerException("key == null");
+    }
+
+    V mapValue;
+    synchronized (this) {
+      mapValue = map.get(key);
+      if (mapValue != null) {
+        hitCount++;
+        return mapValue;
+      }
+      missCount++;
+    }
+
+    /*
+    * Attempt to create a value. This may take a long time, and the map
+    * may be different when create() returns. If a conflicting value was
+    * added to the map while create() was working, we leave that value in
+    * the map and release the created value.
+    */
+
+    V createdValue = create(key);
+    if (createdValue == null) {
+      return null;
+    }
+
+    synchronized (this) {
+      createCount++;
+      mapValue = map.put(key, createdValue);
+
+      if (mapValue != null) {
+        // There was a conflict so undo that last put
+        map.put(key, mapValue);
+      } else {
+        size += safeSizeOf(key, createdValue);
+      }
+    }
+
+    if (mapValue != null) {
+      entryRemoved(false, key, createdValue, mapValue);
+      return mapValue;
+    } else {
+      trimToSize(maxSize);
+      return createdValue;
+    }
+  }
+
+  /**
+   * Caches {@code value} for {@code key}. The value is moved to the head of
+   * the queue.
+   *
+   * @return the previous value mapped by {@code key}.
+   */
+  public final V put(K key, V value) {
+    if (key == null || value == null) {
+      throw new NullPointerException("key == null || value == null");
+    }
+
+    V previous;
+    synchronized (this) {
+      putCount++;
+      size += safeSizeOf(key, value);
+      previous = map.put(key, value);
+      if (previous != null) {
+        size -= safeSizeOf(key, previous);
+      }
+    }
+
+    if (previous != null) {
+      entryRemoved(false, key, previous, value);
+    }
+
+    trimToSize(maxSize);
+    return previous;
+  }
+
+  /**
+   * @param maxSize the maximum size of the cache before returning. May be -1
+   *     to evict even 0-sized elements.
+   */
+  private void trimToSize(int maxSize) {
+    while (true) {
+      K key;
+      V value;
+      synchronized (this) {
+        if (size < 0 || (map.isEmpty() && size != 0)) {
+          throw new IllegalStateException(getClass().getName()
+              + ".sizeOf() is reporting inconsistent results!");
+        }
+
+        if (size <= maxSize || map.isEmpty()) {
+          break;
+        }
+
+        Map.Entry<K, V> toEvict = map.entrySet().iterator().next();
+        key = toEvict.getKey();
+        value = toEvict.getValue();
+        map.remove(key);
+        size -= safeSizeOf(key, value);
+        evictionCount++;
+      }
+
+      entryRemoved(true, key, value, null);
+    }
+  }
+
+  /**
+   * Removes the entry for {@code key} if it exists.
+   *
+   * @return the previous value mapped by {@code key}.
+   */
+  public final V remove(K key) {
+    if (key == null) {
+      throw new NullPointerException("key == null");
+    }
+
+    V previous;
+    synchronized (this) {
+      previous = map.remove(key);
+      if (previous != null) {
+        size -= safeSizeOf(key, previous);
+      }
+    }
+
+    if (previous != null) {
+      entryRemoved(false, key, previous, null);
+    }
+
+    return previous;
+  }
+
+  /**
+   * Called for entries that have been evicted or removed. This method is
+   * invoked when a value is evicted to make space, removed by a call to
+   * {@link #remove}, or replaced by a call to {@link #put}. The default
+   * implementation does nothing.
+   *
+   * <p>The method is called without synchronization: other threads may
+   * access the cache while this method is executing.
+   *
+   * @param evicted true if the entry is being removed to make space, false
+   *     if the removal was caused by a {@link #put} or {@link #remove}.
+   * @param newValue the new value for {@code key}, if it exists. If non-null,
+   *     this removal was caused by a {@link #put}. Otherwise it was caused by
+   *     an eviction or a {@link #remove}.
+   */
+  protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}
+
+  /**
+   * Called after a cache miss to compute a value for the corresponding key.
+   * Returns the computed value or null if no value can be computed. The
+   * default implementation returns null.
+   *
+   * <p>The method is called without synchronization: other threads may
+   * access the cache while this method is executing.
+   *
+   * <p>If a value for {@code key} exists in the cache when this method
+   * returns, the created value will be released with {@link #entryRemoved}
+   * and discarded. This can occur when multiple threads request the same key
+   * at the same time (causing multiple values to be created), or when one
+   * thread calls {@link #put} while another is creating a value for the same
+   * key.
+   */
+  protected V create(K key) {
+    return null;
+  }
+
+  private int safeSizeOf(K key, V value) {
+    int result = sizeOf(key, value);
+    if (result < 0) {
+      throw new IllegalStateException("Negative size: " + key + "=" + value);
+    }
+    return result;
+  }
+
+  /**
+   * Returns the size of the entry for {@code key} and {@code value} in
+   * user-defined units.  The default implementation returns 1 so that size
+   * is the number of entries and max size is the maximum number of entries.
+   *
+   * <p>An entry's size must not change while it is in the cache.
+   */
+  protected int sizeOf(K key, V value) {
+    return 1;
+  }
+
+  /**
+   * Clear the cache, calling {@link #entryRemoved} on each removed entry.
+   */
+  public final void evictAll() {
+    trimToSize(-1); // -1 will evict 0-sized elements
+  }
+
+  /**
+   * For caches that do not override {@link #sizeOf}, this returns the number
+   * of entries in the cache. For all other caches, this returns the sum of
+   * the sizes of the entries in this cache.
+   */
+  public synchronized final int size() {
+    return size;
+  }
+
+  /**
+   * For caches that do not override {@link #sizeOf}, this returns the maximum
+   * number of entries in the cache. For all other caches, this returns the
+   * maximum sum of the sizes of the entries in this cache.
+   */
+  public synchronized final int maxSize() {
+    return maxSize;
+  }
+
+  /**
+   * Returns the number of times {@link #get} returned a value.
+   */
+  public synchronized final int hitCount() {
+    return hitCount;
+  }
+
+  /**
+   * Returns the number of times {@link #get} returned null or required a new
+   * value to be created.
+   */
+  public synchronized final int missCount() {
+    return missCount;
+  }
+
+  /**
+   * Returns the number of times {@link #create(Object)} returned a value.
+   */
+  public synchronized final int createCount() {
+    return createCount;
+  }
+
+  /**
+   * Returns the number of times {@link #put} was called.
+   */
+  public synchronized final int putCount() {
+    return putCount;
+  }
+
+  /**
+   * Returns the number of values that have been evicted.
+   */
+  public synchronized final int evictionCount() {
+    return evictionCount;
+  }
+
+  /**
+   * Returns a copy of the current contents of the cache, ordered from least
+   * recently accessed to most recently accessed.
+   */
+  public synchronized final Map<K, V> snapshot() {
+    return new LinkedHashMap<K, V>(map);
+  }
+
+  @Override public synchronized final String toString() {
+    int accesses = hitCount + missCount;
+    int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;
+    return String.format("LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]",
+        maxSize, hitCount, missCount, hitPercent);
+  }
+}
\ No newline at end of file
/Fim/
diff --git a/src/test/java/com/squareup/injector/InjectorTest.java b/src/test/java/com/squareup/injector/InjectorTest.java
index a96a839..4331856 100644
--- a/src/test/java/com/squareup/injector/InjectorTest.java
+++ b/src/test/java/com/squareup/injector/InjectorTest.java
@@ -109,7 +109,7 @@
     }
   }
 
-  static class MembersInjectors {
+  public static class MembersInjectors {
     @Inject MembersInjector<G> gInjector;
   }
 
@@ -120,7 +120,7 @@
     assertThat(h.aProvider.get()).isNotSameAs(h.aProvider.get());
   }
 
-  static class H {
+  public static class H {
     @Inject Provider<A> aProvider;
   }
 
@@ -294,4 +294,13 @@
     } catch (IllegalArgumentException expected) {
     }
   }
+
+  @Test public void singletonsInjectedOnlyIntoProviders() {
+    H h = new Injector().inject(H.class, new Object() {
+      @Provides @Singleton A provideA() {
+        return new A();
+      }
+    });
+    assertThat(h.aProvider.get()).isSameAs(h.aProvider.get());
+  }
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/BuiltInBinding.java b/src/main/java/com/squareup/injector/BuiltInBinding.java
index f490c29..0f1d5ef 100644
--- a/src/main/java/com/squareup/injector/BuiltInBinding.java
+++ b/src/main/java/com/squareup/injector/BuiltInBinding.java
@@ -32,7 +32,7 @@
 
   @Override void attach(Linker linker) {
     Type providedType = ((ParameterizedType) key.type).getActualTypeArguments()[0];
-    delegate = linker.getBinding(new Key<T>(providedType, key.annotation), requiredBy);
+    delegate = linker.requestBinding(new Key<T>(providedType, key.annotation), requiredBy);
   }
 
   @Override public void injectMembers(T t) {
/Fim/
diff --git a/src/main/java/com/squareup/injector/ConstructorBinding.java b/src/main/java/com/squareup/injector/ConstructorBinding.java
index bd82365..b631b28 100644
--- a/src/main/java/com/squareup/injector/ConstructorBinding.java
+++ b/src/main/java/com/squareup/injector/ConstructorBinding.java
@@ -48,7 +48,7 @@
     for (int i = 0; i < fields.length; i++) {
       Field field = fields[i];
       Key<Object> fieldKey = Key.get(field.getGenericType(), field.getAnnotations(), field);
-      fieldBindings[i] = linker.getBinding(fieldKey, field);
+      fieldBindings[i] = linker.requestBinding(fieldKey, field);
     }
 
     // Constructor bindings.
@@ -57,7 +57,7 @@
     parameters = new Binding[types.length];
     for (int i = 0; i < parameters.length; i++) {
       String name = constructor + " parameter " + i;
-      parameters[i] = linker.getBinding(Key.get(types[i], annotations[i], name), constructor);
+      parameters[i] = linker.requestBinding(Key.get(types[i], annotations[i], name), constructor);
     }
   }
 
/Fim/
diff --git a/src/main/java/com/squareup/injector/Injector.java b/src/main/java/com/squareup/injector/Injector.java
index 6ed2d4b..e22afab 100644
--- a/src/main/java/com/squareup/injector/Injector.java
+++ b/src/main/java/com/squareup/injector/Injector.java
@@ -82,7 +82,7 @@
     }
 
     Linker linker = new Linker(this);
-    linker.getBinding(key, "root injection"); // Seed this requirement early.
+    linker.requestBinding(key, "root injection"); // Seed this requirement early.
     linker.link(bindings.values());
 
     if (!errors.isEmpty()) {
@@ -94,7 +94,7 @@
       throw new IllegalArgumentException(message.toString());
     }
 
-    return linker.getBinding(key, "root injection").get();
+    return linker.requestBinding(key, "root injection").get();
   }
 
   private void install(Object module) {
/Fim/
diff --git a/src/main/java/com/squareup/injector/Linker.java b/src/main/java/com/squareup/injector/Linker.java
index 53a326b..9f4bd97 100644
--- a/src/main/java/com/squareup/injector/Linker.java
+++ b/src/main/java/com/squareup/injector/Linker.java
@@ -33,7 +33,7 @@
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
   private final Queue<Binding<?>> unattachedBindings = new LinkedList<Binding<?>>();
 
-  /** True unless calls to getBinding() were unable to satisfy the binding. */
+  /** True unless calls to requestBinding() were unable to satisfy the binding. */
   private boolean currentAttachSuccess = true;
 
   public Linker(Injector injector) {
@@ -111,7 +111,7 @@
    * null. The injector will create that binding later and reattach the
    * caller's binding.
    */
-  public <T> Binding<T> getBinding(final Key<T> key, final Object requiredBy) {
+  public <T> Binding<T> requestBinding(final Key<T> key, final Object requiredBy) {
     Binding<T> binding = injector.getBinding(key);
     if (binding == null) {
       // We can't satisfy this binding. Make sure it'll work next time!
/Fim/
diff --git a/src/main/java/com/squareup/injector/ProviderMethodBinding.java b/src/main/java/com/squareup/injector/ProviderMethodBinding.java
index fef0e4f..f91953b 100644
--- a/src/main/java/com/squareup/injector/ProviderMethodBinding.java
+++ b/src/main/java/com/squareup/injector/ProviderMethodBinding.java
@@ -44,7 +44,7 @@
     parameters = new Binding[types.length];
     for (int i = 0; i < parameters.length; i++) {
       String name = method + " parameter " + i;
-      parameters[i] = linker.getBinding(Key.get(types[i], annotations[i], name), method);
+      parameters[i] = linker.requestBinding(Key.get(types[i], annotations[i], name), method);
     }
   }
 
/Fim/
diff --git a/src/main/java/com/squareup/codegen/JavaWriter.java b/src/main/java/com/squareup/codegen/JavaWriter.java
new file mode 100644
index 0000000..2848e7a
--- /dev/null
+++ b/src/main/java/com/squareup/codegen/JavaWriter.java
@@ -0,0 +1,322 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.codegen;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Emits Java source files.
+ *
+ * @author Jesse Wilson
+ */
+public final class JavaWriter {
+  private static final Pattern TYPE_PATTERN = Pattern.compile("[\\w.$]+\\.([A-Z][\\w.$]+)");
+  private static final String INDENT = "  ";
+
+  /** Map fully qualified type names to their short names. */
+  private final Map<String, String> importedTypes = new HashMap<String, String>();
+
+  private String packagePrefix;
+  private final List<Scope> scopes = new ArrayList<Scope>();
+  private final Writer out;
+
+  /**
+   * @param out the stream to which Java source will be written. This should be
+   *     a buffered stream.
+   */
+  public JavaWriter(Writer out) {
+    this.out = out;
+  }
+
+  /**
+   * Emit a package declaration.
+   */
+  public void addPackage(String packageName) throws IOException {
+    if (this.packagePrefix != null) {
+      throw new IllegalStateException();
+    }
+    out.write("package ");
+    out.write(packageName);
+    out.write(";\n");
+    this.packagePrefix = packageName + ".";
+  }
+
+  /**
+   * Emit an import for the named class. For the duration of the file, all
+   * references to this class will be automatically shortened.
+   */
+  public void addImport(String type) throws IOException {
+    Matcher matcher = TYPE_PATTERN.matcher(type);
+    if (!matcher.matches()) {
+      throw new IllegalArgumentException(type);
+    }
+    if (importedTypes.put(type, matcher.group(1)) != null) {
+      throw new IllegalArgumentException(type);
+    }
+    out.write("import ");
+    out.write(type);
+    out.write(";\n");
+  }
+
+  /**
+   * Emits a type name, shorting it from an import if possible.
+   */
+  private void type(String type) throws IOException {
+    if (this.packagePrefix == null) {
+      throw new IllegalStateException();
+    }
+    String imported;
+    if ((imported = importedTypes.get(type)) != null) {
+      out.write(imported);
+    } else if (type.startsWith(packagePrefix)) {
+      out.write(type.substring(packagePrefix.length()));
+    } else if (type.startsWith("java.lang.")) {
+      out.write(type.substring("java.lang.".length()));
+    } else {
+      out.write(type);
+    }
+  }
+
+  /**
+   * Emits a type declaration.
+   *
+   * @param kind such as "class", "interface" or "enum".
+   */
+  public void beginType(String type, String kind, int modifiers) throws IOException {
+    indent();
+    modifiers(modifiers);
+    out.write(kind);
+    out.write(" ");
+    type(type);
+    out.write(" {\n");
+    pushScope(Scope.TYPE_DECLARATION);
+  }
+
+  /**
+   * Completes the current type declaration.
+   */
+  public void endType() throws IOException {
+    if (popScope() != Scope.TYPE_DECLARATION) {
+      throw new IllegalStateException();
+    }
+    indent();
+    out.write("}\n");
+  }
+
+  /**
+   * Emits a field declaration.
+   */
+  public void field(String type, String name, int modifiers, String... initialValue)
+      throws IOException {
+    if (initialValue.length > 1) {
+      throw new IllegalArgumentException("expected at most one declaration");
+    }
+
+    indent();
+    modifiers(modifiers);
+    type(type);
+    out.write(" ");
+    out.write(name);
+
+    if (initialValue.length == 1) {
+      out.write(" = ");
+      out.write(initialValue[0]);
+    }
+    out.write(";\n");
+  }
+
+  /**
+   * Emits a method declaration.
+   *
+   * @param returnType the method's return type, or null for constructors.
+   * @param parameters alternating parameter types and names.
+   * @param name the method name, or the class name for constructors.
+   */
+  public void beginMethod(String returnType, String name, int modifiers, String... parameters)
+      throws IOException {
+    indent();
+    modifiers(modifiers);
+    if (returnType != null) {
+      type(returnType);
+      out.write(" ");
+    }
+    out.write(name);
+    out.write("(");
+    for (int p = 0; p < parameters.length; ) {
+      if (p != 0) {
+        out.write(", ");
+      }
+      type(parameters[p++]);
+      out.write(" ");
+      type(parameters[p++]);
+    }
+    out.write(")");
+    if ((modifiers & Modifier.ABSTRACT) != 0) {
+      out.write(";\n");
+      pushScope(Scope.ABSTRACT_METHOD);
+    } else {
+      out.write(" {\n");
+      pushScope(Scope.NON_ABSTRACT_METHOD);
+    }
+  }
+
+  /**
+   * @param s a code statement like "int i = 5". Shouldn't contain any trialing
+   * semicolon or newline character.
+   */
+  public void statement(String s) throws IOException {
+    checkInMethod();
+    indent();
+    out.write(s);
+    out.write(";\n");
+  }
+
+  /**
+   * @param controlFlow the control flow construct and its code, such as
+   *     "if (foo == 5)". Shouldn't contain braces or newline characters.
+   */
+  public void beginControlFlow(String controlFlow) throws IOException {
+    checkInMethod();
+    indent();
+    out.write(controlFlow);
+    out.write(" {\n");
+    pushScope(Scope.CONTROL_FLOW);
+  }
+
+  /**
+   * @param controlFlow the control flow construct and its code, such as
+   *     "else if (foo == 10)". Shouldn't contain braces or newline characters.
+   */
+  public void nextControlFlow(String controlFlow) throws IOException {
+    if (popScope() != Scope.CONTROL_FLOW) {
+      throw new IllegalArgumentException();
+    }
+
+    indent();
+    pushScope(Scope.CONTROL_FLOW);
+    out.write("} ");
+    out.write(controlFlow);
+    out.write(" {\n");
+  }
+
+  /**
+   * @param controlFlow the optional control flow construct and its code, such
+   *     as "while(foo == 20)". Only used for "do/while" control flows.
+   */
+  public void endControlFlow(String... controlFlow) throws IOException {
+    if (controlFlow.length > 1) {
+      throw new IllegalArgumentException("expected 'while' part of do loop");
+    }
+    if (popScope() != Scope.CONTROL_FLOW) {
+      throw new IllegalArgumentException();
+    }
+
+    indent();
+    if (controlFlow.length == 1) {
+      out.write("} ");
+      out.write(controlFlow[0]);
+      out.write(";\n");
+    } else {
+      out.write("}\n");
+    }
+  }
+
+  /**
+   * Completes the current method declaration.
+   */
+  public void endMethod() throws IOException {
+    Scope popped = popScope();
+    if (popped == Scope.NON_ABSTRACT_METHOD) {
+      indent();
+      out.write("}\n");
+    } else if (popped != Scope.ABSTRACT_METHOD) {
+      throw new IllegalStateException();
+    }
+  }
+
+  /**
+   * Emit modifier names.
+   */
+  private void modifiers(int modifiers) throws IOException {
+    if ((modifiers & Modifier.PUBLIC) != 0) {
+      out.write("public ");
+    }
+    if ((modifiers & Modifier.PRIVATE) != 0) {
+      out.write("private ");
+    }
+    if ((modifiers & Modifier.PROTECTED) != 0) {
+      out.write("protected ");
+    }
+    if ((modifiers & Modifier.STATIC) != 0) {
+      out.write("static ");
+    }
+    if ((modifiers & Modifier.FINAL) != 0) {
+      out.write("final ");
+    }
+    if ((modifiers & Modifier.ABSTRACT) != 0) {
+      out.write("abstract ");
+    }
+    if ((modifiers & Modifier.SYNCHRONIZED) != 0) {
+      out.write("synchronized ");
+    }
+    if ((modifiers & Modifier.TRANSIENT) != 0) {
+      out.write("transient ");
+    }
+    if ((modifiers & Modifier.VOLATILE) != 0) {
+      out.write("volatile ");
+    }
+  }
+
+  private void indent() throws IOException {
+    for (int i = 0; i < scopes.size(); i++) {
+      out.write(INDENT);
+    }
+  }
+
+  private void checkInMethod() {
+    Scope scope = peekScope();
+    if (scope != Scope.NON_ABSTRACT_METHOD && scope != Scope.CONTROL_FLOW) {
+      throw new IllegalArgumentException();
+    }
+  }
+
+  private void pushScope(Scope pushed) {
+    scopes.add(pushed);
+  }
+
+  private Scope peekScope() {
+    return scopes.get(scopes.size() - 1);
+  }
+
+  private Scope popScope() {
+    return scopes.remove(scopes.size() - 1);
+  }
+
+  private enum Scope {
+    TYPE_DECLARATION,
+    ABSTRACT_METHOD,
+    NON_ABSTRACT_METHOD,
+    CONTROL_FLOW,
+  }
+}
/Fim/
diff --git a/src/test/java/com/squareup/codegen/JavaWriterTest.java b/src/test/java/com/squareup/codegen/JavaWriterTest.java
new file mode 100644
index 0000000..9a33de3
--- /dev/null
+++ b/src/test/java/com/squareup/codegen/JavaWriterTest.java
@@ -0,0 +1,206 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.codegen;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.lang.reflect.Modifier;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+public final class JavaWriterTest {
+  private final StringWriter stringWriter = new StringWriter();
+  private final JavaWriter javaWriter = new JavaWriter(stringWriter);
+
+  @Test public void typeDeclaration() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", Modifier.PUBLIC | Modifier.FINAL);
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "public final class Foo {\n"
+        + "}\n");
+  }
+
+  @Test public void fieldDeclaration() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.field("java.lang.String", "string", Modifier.PRIVATE | Modifier.STATIC);
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  private static String string;\n"
+        + "}\n");
+  }
+
+  @Test public void fieldDeclarationWithInitialValue() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.field("java.lang.String", "string", 0, "\"bar\" + \"baz\"");
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  String string = \"bar\" + \"baz\";\n"
+        + "}\n");
+  }
+
+  @Test public void abstractMethodDeclaration() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod("java.lang.String", "foo", Modifier.ABSTRACT | Modifier.PUBLIC,
+        "java.lang.Object", "object", "java.lang.String", "s");
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  public abstract String foo(Object object, String s);\n"
+        + "}\n");
+  }
+
+  @Test public void nonAbstractMethodDeclaration() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  int foo(String s) {\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  @Test public void constructorDeclaration() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod(null, "Foo", Modifier.PUBLIC, "java.lang.String", "s");
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  public Foo(String s) {\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  @Test public void statement() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
+    javaWriter.statement("int j = s.length() + 13");
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  int foo(String s) {\n"
+        + "    int j = s.length() + 13;\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  @Test public void addImport() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.addImport("java.util.ArrayList");
+    javaWriter.beginType("com.squareup.Foo", "class", Modifier.PUBLIC | Modifier.FINAL);
+    javaWriter.field("java.util.ArrayList", "list", 0, "new java.util.ArrayList()");
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "import java.util.ArrayList;\n"
+        + "public final class Foo {\n"
+        + "  ArrayList list = new java.util.ArrayList();\n"
+        + "}\n");
+  }
+
+  @Test public void ifControlFlow() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
+    javaWriter.beginControlFlow("if (s.isEmpty())");
+    javaWriter.statement("int j = s.length() + 13");
+    javaWriter.endControlFlow();
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  int foo(String s) {\n"
+        + "    if (s.isEmpty()) {\n"
+        + "      int j = s.length() + 13;\n"
+        + "    }\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  @Test public void doWhileControlFlow() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
+    javaWriter.beginControlFlow("do");
+    javaWriter.statement("int j = s.length() + 13");
+    javaWriter.endControlFlow("while (s.isEmpty())");
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  int foo(String s) {\n"
+        + "    do {\n"
+        + "      int j = s.length() + 13;\n"
+        + "    } while (s.isEmpty());\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  @Test public void tryCatchFinallyControlFlow() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
+    javaWriter.beginControlFlow("try");
+    javaWriter.statement("int j = s.length() + 13");
+    javaWriter.nextControlFlow("catch (RuntimeException e)");
+    javaWriter.statement("e.printStackTrace()");
+    javaWriter.nextControlFlow("finally");
+    javaWriter.statement("int k = 13");
+    javaWriter.endControlFlow();
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  int foo(String s) {\n"
+        + "    try {\n"
+        + "      int j = s.length() + 13;\n"
+        + "    } catch (RuntimeException e) {\n"
+        + "      e.printStackTrace();\n"
+        + "    } finally {\n"
+        + "      int k = 13;\n"
+        + "    }\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  private void assertCode(String expected) {
+    assertThat(stringWriter.toString()).isEqualTo(expected);
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/codegen/JavaWriter.java b/src/main/java/com/squareup/codegen/JavaWriter.java
new file mode 100644
index 0000000..a9aa974
--- /dev/null
+++ b/src/main/java/com/squareup/codegen/JavaWriter.java
@@ -0,0 +1,322 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.codegen;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Emits Java source files.
+ *
+ * @author Jesse Wilson
+ */
+public final class JavaWriter {
+  private static final Pattern TYPE_PATTERN = Pattern.compile("[\\w.$]+\\.([A-Z][\\w.$]+)");
+  private static final String INDENT = "  ";
+
+  /** Map fully qualified type names to their short names. */
+  private final Map<String, String> importedTypes = new HashMap<String, String>();
+
+  private String packagePrefix;
+  private final List<Scope> scopes = new ArrayList<Scope>();
+  private final Writer out;
+
+  /**
+   * @param out the stream to which Java source will be written. This should be
+   *     a buffered stream.
+   */
+  public JavaWriter(Writer out) {
+    this.out = out;
+  }
+
+  /**
+   * Emit a package declaration.
+   */
+  public void addPackage(String packageName) throws IOException {
+    if (this.packagePrefix != null) {
+      throw new IllegalStateException();
+    }
+    out.write("package ");
+    out.write(packageName);
+    out.write(";\n");
+    this.packagePrefix = packageName + ".";
+  }
+
+  /**
+   * Emit an import for the named class. For the duration of the file, all
+   * references to this class will be automatically shortened.
+   */
+  public void addImport(String type) throws IOException {
+    Matcher matcher = TYPE_PATTERN.matcher(type);
+    if (!matcher.matches()) {
+      throw new IllegalArgumentException(type);
+    }
+    if (importedTypes.put(type, matcher.group(1)) != null) {
+      throw new IllegalArgumentException(type);
+    }
+    out.write("import ");
+    out.write(type);
+    out.write(";\n");
+  }
+
+  /**
+   * Emits a type name, shorting it from an import if possible.
+   */
+  private void type(String type) throws IOException {
+    if (this.packagePrefix == null) {
+      throw new IllegalStateException();
+    }
+    String imported;
+    if ((imported = importedTypes.get(type)) != null) {
+      out.write(imported);
+    } else if (type.startsWith(packagePrefix)) {
+      out.write(type.substring(packagePrefix.length()));
+    } else if (type.startsWith("java.lang.")) {
+      out.write(type.substring("java.lang.".length()));
+    } else {
+      out.write(type);
+    }
+  }
+
+  /**
+   * Emits a type declaration.
+   *
+   * @param kind such as "class", "interface" or "enum".
+   */
+  public void beginType(String type, String kind, int modifiers) throws IOException {
+    indent();
+    modifiers(modifiers);
+    out.write(kind);
+    out.write(" ");
+    type(type);
+    out.write(" {\n");
+    pushScope(Scope.TYPE_DECLARATION);
+  }
+
+  /**
+   * Completes the current type declaration.
+   */
+  public void endType() throws IOException {
+    if (popScope() != Scope.TYPE_DECLARATION) {
+      throw new IllegalStateException();
+    }
+    indent();
+    out.write("}\n");
+  }
+
+  /**
+   * Emits a field declaration.
+   */
+  public void field(String type, String name, int modifiers, String... initialValue)
+      throws IOException {
+    if (initialValue.length > 1) {
+      throw new IllegalArgumentException("expected at most one declaration");
+    }
+
+    indent();
+    modifiers(modifiers);
+    type(type);
+    out.write(" ");
+    out.write(name);
+
+    if (initialValue.length == 1) {
+      out.write(" = ");
+      out.write(initialValue[0]);
+    }
+    out.write(";\n");
+  }
+
+  /**
+   * Emits a method declaration.
+   *
+   * @param returnType the method's return type, or null for constructors.
+   * @param parameters alternating parameter types and names.
+   * @param name the method name, or the class name for constructors.
+   */
+  public void beginMethod(String returnType, String name, int modifiers, String... parameters)
+      throws IOException {
+    indent();
+    modifiers(modifiers);
+    if (returnType != null) {
+      type(returnType);
+      out.write(" ");
+    }
+    out.write(name);
+    out.write("(");
+    for (int p = 0; p < parameters.length; ) {
+      if (p != 0) {
+        out.write(", ");
+      }
+      type(parameters[p++]);
+      out.write(" ");
+      type(parameters[p++]);
+    }
+    out.write(")");
+    if ((modifiers & Modifier.ABSTRACT) != 0) {
+      out.write(";\n");
+      pushScope(Scope.ABSTRACT_METHOD);
+    } else {
+      out.write(" {\n");
+      pushScope(Scope.NON_ABSTRACT_METHOD);
+    }
+  }
+
+  /**
+   * @param s a code statement like "int i = 5". Shouldn't contain a trailing
+   * semicolon or newline character.
+   */
+  public void statement(String s) throws IOException {
+    checkInMethod();
+    indent();
+    out.write(s);
+    out.write(";\n");
+  }
+
+  /**
+   * @param controlFlow the control flow construct and its code, such as
+   *     "if (foo == 5)". Shouldn't contain braces or newline characters.
+   */
+  public void beginControlFlow(String controlFlow) throws IOException {
+    checkInMethod();
+    indent();
+    out.write(controlFlow);
+    out.write(" {\n");
+    pushScope(Scope.CONTROL_FLOW);
+  }
+
+  /**
+   * @param controlFlow the control flow construct and its code, such as
+   *     "else if (foo == 10)". Shouldn't contain braces or newline characters.
+   */
+  public void nextControlFlow(String controlFlow) throws IOException {
+    if (popScope() != Scope.CONTROL_FLOW) {
+      throw new IllegalArgumentException();
+    }
+
+    indent();
+    pushScope(Scope.CONTROL_FLOW);
+    out.write("} ");
+    out.write(controlFlow);
+    out.write(" {\n");
+  }
+
+  /**
+   * @param controlFlow the optional control flow construct and its code, such
+   *     as "while(foo == 20)". Only used for "do/while" control flows.
+   */
+  public void endControlFlow(String... controlFlow) throws IOException {
+    if (controlFlow.length > 1) {
+      throw new IllegalArgumentException("expected 'while' part of do loop");
+    }
+    if (popScope() != Scope.CONTROL_FLOW) {
+      throw new IllegalArgumentException();
+    }
+
+    indent();
+    if (controlFlow.length == 1) {
+      out.write("} ");
+      out.write(controlFlow[0]);
+      out.write(";\n");
+    } else {
+      out.write("}\n");
+    }
+  }
+
+  /**
+   * Completes the current method declaration.
+   */
+  public void endMethod() throws IOException {
+    Scope popped = popScope();
+    if (popped == Scope.NON_ABSTRACT_METHOD) {
+      indent();
+      out.write("}\n");
+    } else if (popped != Scope.ABSTRACT_METHOD) {
+      throw new IllegalStateException();
+    }
+  }
+
+  /**
+   * Emit modifier names.
+   */
+  private void modifiers(int modifiers) throws IOException {
+    if ((modifiers & Modifier.PUBLIC) != 0) {
+      out.write("public ");
+    }
+    if ((modifiers & Modifier.PRIVATE) != 0) {
+      out.write("private ");
+    }
+    if ((modifiers & Modifier.PROTECTED) != 0) {
+      out.write("protected ");
+    }
+    if ((modifiers & Modifier.STATIC) != 0) {
+      out.write("static ");
+    }
+    if ((modifiers & Modifier.FINAL) != 0) {
+      out.write("final ");
+    }
+    if ((modifiers & Modifier.ABSTRACT) != 0) {
+      out.write("abstract ");
+    }
+    if ((modifiers & Modifier.SYNCHRONIZED) != 0) {
+      out.write("synchronized ");
+    }
+    if ((modifiers & Modifier.TRANSIENT) != 0) {
+      out.write("transient ");
+    }
+    if ((modifiers & Modifier.VOLATILE) != 0) {
+      out.write("volatile ");
+    }
+  }
+
+  private void indent() throws IOException {
+    for (int i = 0; i < scopes.size(); i++) {
+      out.write(INDENT);
+    }
+  }
+
+  private void checkInMethod() {
+    Scope scope = peekScope();
+    if (scope != Scope.NON_ABSTRACT_METHOD && scope != Scope.CONTROL_FLOW) {
+      throw new IllegalArgumentException();
+    }
+  }
+
+  private void pushScope(Scope pushed) {
+    scopes.add(pushed);
+  }
+
+  private Scope peekScope() {
+    return scopes.get(scopes.size() - 1);
+  }
+
+  private Scope popScope() {
+    return scopes.remove(scopes.size() - 1);
+  }
+
+  private enum Scope {
+    TYPE_DECLARATION,
+    ABSTRACT_METHOD,
+    NON_ABSTRACT_METHOD,
+    CONTROL_FLOW,
+  }
+}
/Fim/
diff --git a/src/test/java/com/squareup/codegen/JavaWriterTest.java b/src/test/java/com/squareup/codegen/JavaWriterTest.java
new file mode 100644
index 0000000..9a33de3
--- /dev/null
+++ b/src/test/java/com/squareup/codegen/JavaWriterTest.java
@@ -0,0 +1,206 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.codegen;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.lang.reflect.Modifier;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+public final class JavaWriterTest {
+  private final StringWriter stringWriter = new StringWriter();
+  private final JavaWriter javaWriter = new JavaWriter(stringWriter);
+
+  @Test public void typeDeclaration() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", Modifier.PUBLIC | Modifier.FINAL);
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "public final class Foo {\n"
+        + "}\n");
+  }
+
+  @Test public void fieldDeclaration() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.field("java.lang.String", "string", Modifier.PRIVATE | Modifier.STATIC);
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  private static String string;\n"
+        + "}\n");
+  }
+
+  @Test public void fieldDeclarationWithInitialValue() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.field("java.lang.String", "string", 0, "\"bar\" + \"baz\"");
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  String string = \"bar\" + \"baz\";\n"
+        + "}\n");
+  }
+
+  @Test public void abstractMethodDeclaration() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod("java.lang.String", "foo", Modifier.ABSTRACT | Modifier.PUBLIC,
+        "java.lang.Object", "object", "java.lang.String", "s");
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  public abstract String foo(Object object, String s);\n"
+        + "}\n");
+  }
+
+  @Test public void nonAbstractMethodDeclaration() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  int foo(String s) {\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  @Test public void constructorDeclaration() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod(null, "Foo", Modifier.PUBLIC, "java.lang.String", "s");
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  public Foo(String s) {\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  @Test public void statement() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
+    javaWriter.statement("int j = s.length() + 13");
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  int foo(String s) {\n"
+        + "    int j = s.length() + 13;\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  @Test public void addImport() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.addImport("java.util.ArrayList");
+    javaWriter.beginType("com.squareup.Foo", "class", Modifier.PUBLIC | Modifier.FINAL);
+    javaWriter.field("java.util.ArrayList", "list", 0, "new java.util.ArrayList()");
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "import java.util.ArrayList;\n"
+        + "public final class Foo {\n"
+        + "  ArrayList list = new java.util.ArrayList();\n"
+        + "}\n");
+  }
+
+  @Test public void ifControlFlow() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
+    javaWriter.beginControlFlow("if (s.isEmpty())");
+    javaWriter.statement("int j = s.length() + 13");
+    javaWriter.endControlFlow();
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  int foo(String s) {\n"
+        + "    if (s.isEmpty()) {\n"
+        + "      int j = s.length() + 13;\n"
+        + "    }\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  @Test public void doWhileControlFlow() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
+    javaWriter.beginControlFlow("do");
+    javaWriter.statement("int j = s.length() + 13");
+    javaWriter.endControlFlow("while (s.isEmpty())");
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  int foo(String s) {\n"
+        + "    do {\n"
+        + "      int j = s.length() + 13;\n"
+        + "    } while (s.isEmpty());\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  @Test public void tryCatchFinallyControlFlow() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
+    javaWriter.beginControlFlow("try");
+    javaWriter.statement("int j = s.length() + 13");
+    javaWriter.nextControlFlow("catch (RuntimeException e)");
+    javaWriter.statement("e.printStackTrace()");
+    javaWriter.nextControlFlow("finally");
+    javaWriter.statement("int k = 13");
+    javaWriter.endControlFlow();
+    javaWriter.endMethod();
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  int foo(String s) {\n"
+        + "    try {\n"
+        + "      int j = s.length() + 13;\n"
+        + "    } catch (RuntimeException e) {\n"
+        + "      e.printStackTrace();\n"
+        + "    } finally {\n"
+        + "      int k = 13;\n"
+        + "    }\n"
+        + "  }\n"
+        + "}\n");
+  }
+
+  private void assertCode(String expected) {
+    assertThat(stringWriter.toString()).isEqualTo(expected);
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/codegen/JavaWriter.java b/src/main/java/com/squareup/codegen/JavaWriter.java
index a9aa974..898363b 100644
--- a/src/main/java/com/squareup/codegen/JavaWriter.java
+++ b/src/main/java/com/squareup/codegen/JavaWriter.java
@@ -147,7 +147,7 @@
   }
 
   /**
-   * Emits a method declaration.
+   * Emit a method declaration.
    *
    * @param returnType the method's return type, or null for constructors.
    * @param parameters alternating parameter types and names.
/Fim/
diff --git a/src/main/java/com/squareup/injector/Injector.java b/src/main/java/com/squareup/injector/Injector.java
index ba47305..0d4d6bb 100644
--- a/src/main/java/com/squareup/injector/Injector.java
+++ b/src/main/java/com/squareup/injector/Injector.java
@@ -15,7 +15,6 @@
  */
 package com.squareup.injector;
 
-import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -73,12 +72,9 @@
       throw new IllegalStateException("Injectors may only inject once.");
     }
 
-    for (Object module : modules) {
-      try {
-        install(module);
-      } catch (Exception e) {
-        errors.add(e.getMessage());
-      }
+    Map<Key<?>, Binding<?>> combined = Modules.moduleToMap(Modules.combine(modules));
+    for (Binding<?> binding : combined.values()) {
+      putBinding(binding);
     }
 
     Linker linker = new Linker(this);
@@ -98,34 +94,15 @@
     return root.get(); // Linker.link() guarantees that this will be non-null.
   }
 
-  private void install(Object module) {
-    boolean hasProvidesMethods = false;
-    for (Class<?> c = module.getClass(); c != Object.class; c = c.getSuperclass()) {
-      for (Method method : c.getDeclaredMethods()) {
-        if (method.getAnnotation(Provides.class) != null) {
-          install(module, method);
-          hasProvidesMethods = true;
-        }
-      }
-    }
-    if (!hasProvidesMethods) {
-      throw new IllegalArgumentException("No @Provides methods on " + module);
-    }
-  }
-
-  private <T> void install(Object module, Method method) {
-    Key<T> key = Key.get(method.getGenericReturnType(), method.getAnnotations(), method);
-    putBinding(new ProviderMethodBinding<T>(method, key, module));
-  }
-
   @SuppressWarnings("unchecked") // Typesafe heterogeneous container.
   <T> Binding<T> getBinding(Key<T> key) {
     return (Binding<T>) bindings.get(key);
   }
 
   <T> void putBinding(final Binding<T> binding) {
+    Binding<T> toInsert = binding;
     if (binding.isSingleton()) {
-      bindings.put(binding.key, new Binding<T>(binding.requiredBy, binding.key) {
+      toInsert = new Binding<T>(binding.requiredBy, binding.key) {
         private Object onlyInstance = UNINITIALIZED;
         @Override void attach(Linker linker) {
           binding.attach(linker);
@@ -142,9 +119,11 @@
         @Override public boolean isSingleton() {
           return binding.isSingleton();
         }
-      });
-    } else {
-      bindings.put(binding.key, binding);
+      };
+    }
+
+    if (bindings.put(toInsert.key, toInsert) != null) {
+      throw new IllegalArgumentException("Duplicate binding: " + toInsert.key);
     }
   }
 
/Fim/
diff --git a/src/main/java/com/squareup/injector/Linker.java b/src/main/java/com/squareup/injector/Linker.java
index adda65c..26e5a85 100644
--- a/src/main/java/com/squareup/injector/Linker.java
+++ b/src/main/java/com/squareup/injector/Linker.java
@@ -72,6 +72,10 @@
    * attached until its own dependencies have been satisfied.
    */
   private <T> void promoteDeferredBinding(DeferredBinding<T> deferred) {
+    if (injector.getBinding(deferred.key) != null) {
+      return; // A binding for this key has already been promoted.
+    }
+
     try {
       Binding<T> promoted;
       if (deferred.key.type instanceof ParameterizedType) {
/Fim/
diff --git a/src/main/java/com/squareup/injector/Modules.java b/src/main/java/com/squareup/injector/Modules.java
new file mode 100644
index 0000000..7513800
--- /dev/null
+++ b/src/main/java/com/squareup/injector/Modules.java
@@ -0,0 +1,98 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import java.lang.reflect.Method;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Helper methods for dealing with collections of bindings. Any object whose
+ * declaring class defines one or more {@code @Provides} is considered to be a
+ * collection of bindings.
+ *
+ * @author Jesse Wilson
+ */
+public final class Modules {
+  /**
+   * Returns a map containing the bindings in {@code object}.
+   *
+   * @param  module either a {@code map} of bindings, or an instance of a class
+   *     that declares one or more {@code @Provides} methods.
+   */
+  static Map<Key<?>, Binding<?>> moduleToMap(Object module) {
+    if (module instanceof Map) {
+      return (Map<Key<?>, Binding<?>>) module;
+    }
+    return extractBindings(module);
+  }
+
+  /**
+   * Creates bindings for the {@code @Provides} methods of {@code module}. The
+   * returned bindings are not attached to a particular injector and cannot be
+   * used to inject values.
+   */
+  private static Map<Key<?>, Binding<?>> extractBindings(Object module) {
+    Map<Key<?>, Binding<?>> result = new HashMap<Key<?>, Binding<?>>();
+    for (Class<?> c = module.getClass(); c != Object.class; c = c.getSuperclass()) {
+      for (Method method : c.getDeclaredMethods()) {
+        if (method.getAnnotation(Provides.class) == null) {
+          continue;
+        }
+        Binding<Object> binding = methodToBinding(module, method);
+        result.put(binding.key, binding);
+      }
+    }
+    if (result.isEmpty()) {
+      throw new IllegalArgumentException("No @Provides methods on " + module);
+    }
+    return result;
+  }
+
+  private static <T> Binding<T> methodToBinding(Object module, Method method) {
+    Key<T> key = Key.get(method.getGenericReturnType(), method.getAnnotations(), method);
+    return new ProviderMethodBinding<T>(method, key, module);
+  }
+
+  /**
+   * Returns a module containing the union of the bindings of {@code base} and
+   * the bindings of {@code overrides}. If any key is represented in both
+   * modules, the binding from {@code overrides} is retained.
+   */
+  public static Object override(Object base, Object overrides) {
+    Map<Key<?>, Binding<?>> result = new HashMap<Key<?>, Binding<?>>();
+    result.putAll(moduleToMap(base));
+    result.putAll(moduleToMap(overrides));
+    return result;
+  }
+
+  /**
+   * Returns a module containing all bindings in {@code modules}.
+   */
+  public static Object combine(Object... modules) {
+    Map<Key<?>, Binding<?>> result = new HashMap<Key<?>, Binding<?>>();
+    int expectedSize = 0;
+    for (Object module : modules) {
+      Map<Key<?>, Binding<?>> moduleBindings = moduleToMap(module);
+      expectedSize += moduleBindings.size();
+      result.putAll(moduleBindings);
+    }
+    if (result.size() != expectedSize) {
+      throw new IllegalArgumentException("Duplicate bindings!");
+    }
+    return result;
+  }
+}
/Fim/
diff --git a/src/test/java/com/squareup/injector/InjectorTest.java b/src/test/java/com/squareup/injector/InjectorTest.java
index 4331856..60431b7 100644
--- a/src/test/java/com/squareup/injector/InjectorTest.java
+++ b/src/test/java/com/squareup/injector/InjectorTest.java
@@ -303,4 +303,25 @@
     });
     assertThat(h.aProvider.get()).isSameAs(h.aProvider.get());
   }
+
+  @Test public void moduleOverrides() {
+    Object base = new Object() {
+      @Provides F provideF() {
+        throw new AssertionError();
+      }
+      @Provides E provideE(F f) {
+        return new E(f);
+      }
+    };
+
+    Object overrides = new Object() {
+      @Provides F provideF() {
+        return new F();
+      }
+    };
+
+    E e = new Injector().inject(E.class, Modules.override(base, overrides));
+    assertThat(e).isNotNull();
+    assertThat(e.f).isNotNull();
+  }
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/Modules.java b/src/main/java/com/squareup/injector/Modules.java
index 7513800..5e36c48 100644
--- a/src/main/java/com/squareup/injector/Modules.java
+++ b/src/main/java/com/squareup/injector/Modules.java
@@ -27,6 +27,9 @@
  * @author Jesse Wilson
  */
 public final class Modules {
+  private Modules() {
+  }
+
   /**
    * Returns a map containing the bindings in {@code object}.
    *
/Fim/
diff --git a/src/main/java/com/squareup/codegen/GeneratorKeys.java b/src/main/java/com/squareup/codegen/GeneratorKeys.java
new file mode 100644
index 0000000..aaea52b
--- /dev/null
+++ b/src/main/java/com/squareup/codegen/GeneratorKeys.java
@@ -0,0 +1,106 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.codegen;
+
+import java.util.List;
+import java.util.Map;
+import javax.inject.Qualifier;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Creates keys using javac's mirror APIs.
+ *
+ * @author Jesse Wilson
+ */
+public final class GeneratorKeys {
+  GeneratorKeys() {
+  }
+
+  public static String get(ExecutableElement method) {
+    StringBuilder result = new StringBuilder();
+    AnnotationMirror qualifier = getQualifier(method.getAnnotationMirrors(), method);
+    if (qualifier != null) {
+      qualifierToString(qualifier, result);
+    }
+    typeToString(method.getReturnType(), result);
+    return result.toString();
+  }
+
+  public static String get(VariableElement parameter) {
+    StringBuilder result = new StringBuilder();
+    AnnotationMirror qualifier = getQualifier(parameter.getAnnotationMirrors(), parameter);
+    if (qualifier != null) {
+      qualifierToString(qualifier, result);
+    }
+    typeToString(parameter.asType(), result);
+    return result.toString();
+  }
+
+  private static void qualifierToString(AnnotationMirror qualifier, StringBuilder result) {
+    // TODO: guarantee that element values are sorted by name (if there are multiple)
+    result.append('@');
+    result.append(((TypeElement) qualifier.getAnnotationType().asElement()).getQualifiedName());
+    result.append('(');
+    for (Map.Entry<? extends ExecutableElement,? extends AnnotationValue> entry
+        : qualifier.getElementValues().entrySet()) {
+      result.append(entry.getKey().getSimpleName());
+      result.append('=');
+      result.append(entry.getValue().getValue());
+    }
+    result.append(")/");
+  }
+
+  private static AnnotationMirror getQualifier(
+      List<? extends AnnotationMirror> annotations, Object member) {
+    AnnotationMirror qualifier = null;
+    for (AnnotationMirror annotation : annotations) {
+      if (annotation.getAnnotationType().asElement().getAnnotation(Qualifier.class) == null) {
+        continue;
+      }
+      if (qualifier != null) {
+        throw new IllegalArgumentException("Too many qualifier annotations on " + member);
+      }
+      qualifier = annotation;
+    }
+    return qualifier;
+  }
+
+  private static void typeToString(TypeMirror type, StringBuilder result) {
+    if (type instanceof DeclaredType) {
+      DeclaredType declaredType = (DeclaredType) type;
+      result.append(((TypeElement) declaredType.asElement()).getQualifiedName().toString());
+      List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+      if (!typeArguments.isEmpty()) {
+        result.append("<");
+        for (int i = 0; i < typeArguments.size(); i++) {
+          if (i != 0) {
+            result.append(", ");
+          }
+          typeToString(typeArguments.get(i), result);
+        }
+        result.append(">");
+      }
+    } else {
+      throw new UnsupportedOperationException("Uninjectable type " + type);
+    }
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/codegen/JavaWriter.java b/src/main/java/com/squareup/codegen/JavaWriter.java
index 3584773..4ac5ae1 100644
--- a/src/main/java/com/squareup/codegen/JavaWriter.java
+++ b/src/main/java/com/squareup/codegen/JavaWriter.java
@@ -17,6 +17,7 @@
 
 import java.io.IOException;
 import java.io.Writer;
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -31,7 +32,7 @@
  * @author Jesse Wilson
  */
 public final class JavaWriter {
-  private static final Pattern TYPE_PATTERN = Pattern.compile("[\\w.$]+\\.([A-Z][\\w.$]+)");
+  private static final Pattern TYPE_PATTERN = Pattern.compile("(?:[\\w$]+\\.)*([\\w$]+)");
   private static final String INDENT = "  ";
 
   /** Map fully qualified type names to their short names. */
@@ -63,7 +64,14 @@
   }
 
   /**
-   * Emit an import for the named class. For the duration of the file, all
+   * Equivalent to {@code addImport(type.getName())}.
+   */
+  public void addImport(Class<?> type) throws IOException {
+    addImport(type.getName());
+  }
+
+  /**
+   * Emit an import for {@code type}. For the duration of the file, all
    * references to this class will be automatically shortened.
    */
   public void addImport(String type) throws IOException {
@@ -80,21 +88,41 @@
   }
 
   /**
-   * Emits a type name, shorting it from an import if possible.
+   * Emits a name like {@code java.lang.String} or {@code
+   * java.util.List<java.lang.String>}, shorting it with imports if
+   * possible.
    */
   private void type(String type) throws IOException {
     if (this.packagePrefix == null) {
       throw new IllegalStateException();
     }
-    String imported;
-    if ((imported = importedTypes.get(type)) != null) {
-      out.write(imported);
-    } else if (type.startsWith(packagePrefix)) {
-      out.write(type.substring(packagePrefix.length()));
-    } else if (type.startsWith("java.lang.")) {
-      out.write(type.substring("java.lang.".length()));
-    } else {
-      out.write(type);
+
+    Matcher m = TYPE_PATTERN.matcher(type);
+    int pos = 0;
+    while (true) {
+      boolean found = m.find(pos);
+
+      // copy non-matching characters like "<"
+      int typeStart = found ? m.start() : type.length();
+      out.write(type, pos, typeStart - pos);
+
+      if (!found) {
+        break;
+      }
+
+      // copy a single class name, shortening it if possible
+      String name = m.group(0);
+      String imported;
+      if ((imported = importedTypes.get(name)) != null) {
+        out.write(imported);
+      } else if (name.startsWith(packagePrefix)) {
+        out.write(name.substring(packagePrefix.length()));
+      } else if (name.startsWith("java.lang.")) {
+        out.write(name.substring("java.lang.".length()));
+      } else {
+        out.write(name);
+      }
+      pos = m.end();
     }
   }
 
@@ -104,11 +132,39 @@
    * @param kind such as "class", "interface" or "enum".
    */
   public void beginType(String type, String kind, int modifiers) throws IOException {
+    beginType(type, kind, modifiers, null);
+  }
+
+  /**
+   * Emits a type declaration.
+   *
+   * @param kind such as "class", "interface" or "enum".
+   * @param extendsType the class to extend, or null for no extends clause.
+   */
+  public void beginType(String type, String kind, int modifiers,
+      String extendsType, String... implementsTypes) throws IOException {
     indent();
     modifiers(modifiers);
     out.write(kind);
     out.write(" ");
     type(type);
+    if (extendsType != null) {
+      out.write("\n");
+      indent();
+      out.write("    extends ");
+      type(extendsType);
+    }
+    if (implementsTypes.length > 0) {
+      out.write("\n");
+      indent();
+      out.write("    implements ");
+      for (int i = 0; i < implementsTypes.length; i++) {
+        if (i != 0) {
+          out.write(", ");
+        }
+        type(implementsTypes[i]);
+      }
+    }
     out.write(" {\n");
     pushScope(Scope.TYPE_DECLARATION);
   }
@@ -127,21 +183,21 @@
   /**
    * Emits a field declaration.
    */
-  public void field(String type, String name, int modifiers, String... initialValue)
-      throws IOException {
-    if (initialValue.length > 1) {
-      throw new IllegalArgumentException("expected at most one declaration");
-    }
+  public void field(String type, String name, int modifiers) throws IOException {
+    field(type, name, modifiers, null);
+  }
 
+  public void field(String type, String name, int modifiers, String initialValue)
+      throws IOException {
     indent();
     modifiers(modifiers);
     type(type);
     out.write(" ");
     out.write(name);
 
-    if (initialValue.length == 1) {
+    if (initialValue != null) {
       out.write(" = ");
-      out.write(initialValue[0]);
+      out.write(initialValue);
     }
     out.write(";\n");
   }
@@ -182,13 +238,31 @@
   }
 
   /**
-   * @param s a code statement like "int i = 5". Shouldn't contain a trailing
-   * semicolon or newline character.
+   * Annotates the next element with {@code annotation}. The annotation has no
+   * attributes.
    */
-  public void statement(String s) throws IOException {
+  public void annotation(String annotation) throws IOException {
+    indent();
+    out.write("@");
+    type(annotation);
+    out.write("\n");
+  }
+
+  /**
+   * Equivalent to {@code annotation(annotationType.getName())}.
+   */
+  public void annotation(Class<? extends Annotation> annotationType) throws IOException {
+    annotation(annotationType.getName());
+  }
+
+  /**
+   * @param pattern a code pattern like "int i = %s". Shouldn't contain a
+   * trailing semicolon or newline character.
+   */
+  public void statement(String pattern, Object... args) throws IOException {
     checkInMethod();
     indent();
-    out.write(s);
+    out.write(String.format(pattern, args));
     out.write(";\n");
   }
 
@@ -220,22 +294,23 @@
     out.write(" {\n");
   }
 
+  public void endControlFlow() throws IOException {
+    endControlFlow(null);
+  }
+
   /**
    * @param controlFlow the optional control flow construct and its code, such
    *     as "while(foo == 20)". Only used for "do/while" control flows.
    */
-  public void endControlFlow(String... controlFlow) throws IOException {
-    if (controlFlow.length > 1) {
-      throw new IllegalArgumentException("expected 'while' part of do loop");
-    }
+  public void endControlFlow(String controlFlow) throws IOException {
     if (popScope() != Scope.CONTROL_FLOW) {
       throw new IllegalArgumentException();
     }
 
     indent();
-    if (controlFlow.length == 1) {
+    if (controlFlow != null) {
       out.write("} ");
-      out.write(controlFlow[0]);
+      out.write(controlFlow);
       out.write(";\n");
     } else {
       out.write("}\n");
@@ -255,6 +330,45 @@
     }
   }
 
+  /**
+   * Returns the string literal representing {@code data}, including wrapping
+   * quotes.
+   */
+  public static String stringLiteral(String data) {
+    StringBuilder result = new StringBuilder();
+    result.append('"');
+    for (int i = 0; i < data.length(); i++) {
+      char c = data.charAt(i);
+      switch (c) {
+        case '"':
+          result.append("\\\"");
+          break;
+        case '\\':
+          result.append("\\\\");
+          break;
+        case '\t':
+          result.append("\\\t");
+          break;
+        case '\b':
+          result.append("\\\b");
+          break;
+        case '\n':
+          result.append("\\\n");
+          break;
+        case '\r':
+          result.append("\\\r");
+          break;
+        case '\f':
+          result.append("\\\f");
+          break;
+        default:
+          result.append(c);
+      }
+    }
+    result.append('"');
+    return result.toString();
+  }
+
   public void close() throws IOException {
     out.close();
   }
/Fim/
diff --git a/src/main/java/com/squareup/codegen/ProvidesProcessor.java b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
new file mode 100644
index 0000000..84ae421
--- /dev/null
+++ b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
@@ -0,0 +1,231 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.codegen;
+
+import com.squareup.injector.Provides;
+import com.squareup.injector.internal.Binding;
+import com.squareup.injector.internal.Linker;
+import com.squareup.injector.internal.ModuleAdapter;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.annotation.processing.SupportedAnnotationTypes;
+import javax.annotation.processing.SupportedSourceVersion;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.tools.Diagnostic;
+import javax.tools.JavaFileObject;
+
+import static java.lang.reflect.Modifier.FINAL;
+import static java.lang.reflect.Modifier.PRIVATE;
+import static java.lang.reflect.Modifier.PUBLIC;
+import static java.lang.reflect.Modifier.STATIC;
+
+/**
+ * Generates an implementation of {@link ModuleAdapter} that includes a binding
+ * for each {@code @Provides} method of a target class.
+ *
+ * @author Jesse Wilson
+ */
+@SupportedAnnotationTypes("com.squareup.injector.Provides")
+@SupportedSourceVersion(SourceVersion.RELEASE_6)
+public final class ProvidesProcessor extends AbstractProcessor {
+  private final String bindingsMap = parameterizedType(Map.class,
+      String.class.getName(), Binding.class.getName() + "<?>");
+  private final String bindingsHashMap = parameterizedType(HashMap.class,
+      String.class.getName(), Binding.class.getName() + "<?>");
+
+  @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
+    try {
+      Map<TypeElement, List<ExecutableElement>> providerMethods = providerMethodsByClass(env);
+      for (Map.Entry<TypeElement, List<ExecutableElement>> module : providerMethods.entrySet()) {
+        generateProvides(module.getKey(), module.getValue());
+      }
+    } catch (IOException e) {
+      processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "Code gen failed: " + e);
+    }
+    return !types.isEmpty();
+  }
+
+  /**
+   * Returns a map containing all {@code @Provides} methods, indexed by class.
+   */
+  private Map<TypeElement, List<ExecutableElement>> providerMethodsByClass(RoundEnvironment env) {
+    Map<TypeElement, List<ExecutableElement>> result
+        = new HashMap<TypeElement, List<ExecutableElement>>();
+    for (Element providerMethod : env.getElementsAnnotatedWith(Provides.class)) {
+      TypeElement type = (TypeElement) providerMethod.getEnclosingElement();
+      Set<Modifier> typeModifiers = type.getModifiers();
+      if (type.getKind() != ElementKind.CLASS) {
+        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
+            "Unexpected @Provides on " + providerMethod);
+        continue;
+      }
+      if (typeModifiers.contains(Modifier.PRIVATE)
+          || typeModifiers.contains(Modifier.ABSTRACT)) {
+        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
+            "Unexpected modifiers on type declaring @Provides method: " + providerMethod);
+      }
+
+      Set<Modifier> methodModifiers = providerMethod.getModifiers();
+      if (methodModifiers.contains(Modifier.PRIVATE)
+          || methodModifiers.contains(Modifier.ABSTRACT)
+          || methodModifiers.contains(Modifier.STATIC)) {
+        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
+            "Unexpected modifiers on @Provides method: " + providerMethod);
+        continue;
+      }
+
+      List<ExecutableElement> methods = result.get(type);
+      if (methods == null) {
+        methods = new ArrayList<ExecutableElement>();
+        result.put(type, methods);
+      }
+      methods.add((ExecutableElement) providerMethod);
+    }
+
+    return result;
+  }
+
+  private void generateProvides(TypeElement type, List<ExecutableElement> providerMethods)
+      throws IOException {
+    JavaFileObject sourceFile = processingEnv.getFiler()
+        .createSourceFile(type.getQualifiedName() + "$ModuleAdapter", type);
+    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
+
+    writer.addPackage(getPackage(type).getQualifiedName().toString());
+    writer.addImport(Binding.class);
+    writer.addImport(ModuleAdapter.class);
+    writer.addImport(Map.class);
+    writer.addImport(Linker.class);
+
+    String typeName = type.getQualifiedName().toString();
+    writer.beginType(typeName + "$ModuleAdapter", "class", PUBLIC | FINAL, null,
+        parameterizedType(ModuleAdapter.class, typeName));
+
+    writer.annotation(Override.class);
+    writer.beginMethod(bindingsMap, "getBindings", PUBLIC, typeName, "module");
+    writer.statement("%s result = new %s()", bindingsMap, bindingsHashMap);
+    for (ExecutableElement providerMethod : providerMethods) {
+      String key = GeneratorKeys.get(providerMethod);
+      writer.statement("result.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
+          providerMethod.getSimpleName().toString() + "Binding");
+    }
+    writer.statement("return result");
+    writer.endMethod();
+
+    for (ExecutableElement providerMethod : providerMethods) {
+      writeBindingClass(writer, providerMethod);
+    }
+
+    writer.endType();
+    writer.close();
+  }
+
+  /**
+   * Returns a string like {@code java.util.List<java.lang.String>}.
+   */
+  private static String parameterizedType(Class<?> raw, String... parameters) {
+    StringBuilder result = new StringBuilder();
+    result.append(raw.getName());
+    result.append("<");
+    for (int i = 0; i < parameters.length; i++) {
+      if (i != 0) {
+        result.append(", ");
+      }
+      result.append(parameters[i]);
+    }
+    result.append(">");
+    return result.toString();
+  }
+
+  private void writeBindingClass(JavaWriter writer, ExecutableElement providerMethod)
+      throws IOException {
+    String methodName = providerMethod.getSimpleName().toString();
+    String key = GeneratorKeys.get(providerMethod);
+    String moduleType = typeToString(providerMethod.getEnclosingElement().asType());
+    String className = providerMethod.getSimpleName() + "Binding";
+    String returnType = typeToString(providerMethod.getReturnType());
+
+    writer.beginType(className, "class", PRIVATE | STATIC,
+        parameterizedType(Binding.class, returnType));
+    writer.field(moduleType, "module", PRIVATE | FINAL);
+    List<? extends VariableElement> parameters = providerMethod.getParameters();
+    for (int p = 0; p < parameters.size(); p++) {
+      TypeMirror parameterType = parameters.get(p).asType();
+      writer.field(parameterizedType(Binding.class, typeToString(parameterType)), "p" + p, PRIVATE);
+    }
+
+    writer.beginMethod(null, className, PUBLIC, moduleType, "module");
+    writer.statement("super(%s.class, %s)", moduleType, JavaWriter.stringLiteral(key));
+    writer.statement("this.module = module");
+    writer.endMethod();
+
+    writer.annotation(Override.class);
+    writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
+    for (int p = 0; p < parameters.size(); p++) {
+      VariableElement parameter = parameters.get(p);
+      String parameterKey = GeneratorKeys.get(parameter);
+      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
+          "p" + p,
+          parameterizedType(Binding.class, typeToString(parameter.asType())),
+          JavaWriter.stringLiteral(parameterKey), moduleType);
+    }
+    writer.endMethod();
+
+    writer.annotation(Override.class);
+    writer.beginMethod(returnType, "get", PUBLIC);
+    StringBuilder args = new StringBuilder();
+    for (int p = 0; p < parameters.size(); p++) {
+      if (p != 0) {
+        args.append(", ");
+      }
+      args.append(String.format("%s.get()", "p" + p));
+    }
+    writer.statement("return module.%s(%s)", methodName, args.toString());
+    writer.endMethod();
+
+    writer.annotation(Override.class);
+    writer.beginMethod(boolean.class.getName(), "isSingleton", PUBLIC);
+    writer.statement("return %s", true);
+    writer.endMethod();
+
+    writer.endType();
+  }
+
+  private String typeToString(TypeMirror type) {
+    return type.toString();
+  }
+
+  private PackageElement getPackage(Element type) {
+    while (type.getKind() != ElementKind.PACKAGE) {
+      type = type.getEnclosingElement();
+    }
+    return (PackageElement) type;
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Keys.java b/src/main/java/com/squareup/injector/internal/Keys.java
index 4b6bbb6..0d74700 100644
--- a/src/main/java/com/squareup/injector/internal/Keys.java
+++ b/src/main/java/com/squareup/injector/internal/Keys.java
@@ -80,17 +80,17 @@
    *     This array may contain at most one qualifier annotation.
    */
   public static String get(Type type, Annotation[] annotations, Object subject) {
-    Annotation bindingAnnotation = null;
+    Annotation qualifier = null;
     for (Annotation a : annotations) {
       if (!IS_QUALIFIER_ANNOTATION.get(a.annotationType())) {
         continue;
       }
-      if (bindingAnnotation != null) {
-        throw new IllegalArgumentException("Too many binding annotations on " + subject);
+      if (qualifier != null) {
+        throw new IllegalArgumentException("Too many qualifier annotations on " + subject);
       }
-      bindingAnnotation = a;
+      qualifier = a;
     }
-    return get(type, bindingAnnotation);
+    return get(type, qualifier);
   }
 
   private static void typeToString(Type type, StringBuilder result) {
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ModuleAdapter.java b/src/main/java/com/squareup/injector/internal/ModuleAdapter.java
new file mode 100644
index 0000000..957c525
--- /dev/null
+++ b/src/main/java/com/squareup/injector/internal/ModuleAdapter.java
@@ -0,0 +1,27 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector.internal;
+
+import java.util.Map;
+
+/**
+ * Interface implemented by generated module classes.
+ *
+ * @author Jesse Wilson
+ */
+public interface ModuleAdapter<T> {
+  Map<String, Binding<?>> getBindings(T t);
+}
/Fim/
diff --git a/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/src/main/resources/META-INF/services/javax.annotation.processing.Processor
new file mode 100644
index 0000000..60b652d
--- /dev/null
+++ b/src/main/resources/META-INF/services/javax.annotation.processing.Processor
@@ -0,0 +1 @@
+com.squareup.codegen.ProvidesProcessor
/Fim/
diff --git a/src/test/java/com/squareup/codegen/JavaProcessorTest.java b/src/test/java/com/squareup/codegen/JavaProcessorTest.java
new file mode 100644
index 0000000..66ccec3
--- /dev/null
+++ b/src/test/java/com/squareup/codegen/JavaProcessorTest.java
@@ -0,0 +1,26 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.codegen;
+
+/**
+ * @author Jesse Wilson
+ */
+public class JavaProcessorTest {
+
+  // TEST @Provides on interface
+  // TEST @Provides with illegal modifiers (abstract, private, static)
+  // TEST @Provides with illegal class (private)
+}
/Fim/
diff --git a/src/test/java/com/squareup/codegen/JavaWriterTest.java b/src/test/java/com/squareup/codegen/JavaWriterTest.java
index 9a33de3..03e3f6b 100644
--- a/src/test/java/com/squareup/codegen/JavaWriterTest.java
+++ b/src/test/java/com/squareup/codegen/JavaWriterTest.java
@@ -106,7 +106,7 @@
     javaWriter.addPackage("com.squareup");
     javaWriter.beginType("com.squareup.Foo", "class", 0);
     javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
-    javaWriter.statement("int j = s.length() + 13");
+    javaWriter.statement("int j = s.length() + %s", 13);
     javaWriter.endMethod();
     javaWriter.endType();
     assertCode(""
@@ -137,7 +137,7 @@
     javaWriter.beginType("com.squareup.Foo", "class", 0);
     javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
     javaWriter.beginControlFlow("if (s.isEmpty())");
-    javaWriter.statement("int j = s.length() + 13");
+    javaWriter.statement("int j = s.length() + %s", 13);
     javaWriter.endControlFlow();
     javaWriter.endMethod();
     javaWriter.endType();
@@ -157,7 +157,7 @@
     javaWriter.beginType("com.squareup.Foo", "class", 0);
     javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
     javaWriter.beginControlFlow("do");
-    javaWriter.statement("int j = s.length() + 13");
+    javaWriter.statement("int j = s.length() + %s", 13);
     javaWriter.endControlFlow("while (s.isEmpty())");
     javaWriter.endMethod();
     javaWriter.endType();
@@ -177,11 +177,11 @@
     javaWriter.beginType("com.squareup.Foo", "class", 0);
     javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
     javaWriter.beginControlFlow("try");
-    javaWriter.statement("int j = s.length() + 13");
+    javaWriter.statement("int j = s.length() + %s", 13);
     javaWriter.nextControlFlow("catch (RuntimeException e)");
-    javaWriter.statement("e.printStackTrace()");
+    javaWriter.statement("%s.printStackTrace()", "e");
     javaWriter.nextControlFlow("finally");
-    javaWriter.statement("int k = 13");
+    javaWriter.statement("int k = %s", 13);
     javaWriter.endControlFlow();
     javaWriter.endMethod();
     javaWriter.endType();
@@ -200,6 +200,59 @@
         + "}\n");
   }
 
+  @Test public void annotatedType() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.addImport("javax.inject.Singleton");
+    javaWriter.annotation("javax.inject.Singleton");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "import javax.inject.Singleton;\n"
+        + "@Singleton\n"
+        + "class Foo {\n"
+        + "}\n");
+  }
+
+  @Test public void annotatedMember() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.annotation(Deprecated.class);
+    javaWriter.field("java.lang.String", "s", 0);
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "class Foo {\n"
+        + "  @Deprecated\n"
+        + "  String s;\n"
+        + "}\n");
+  }
+
+  @Test public void parameterizedType() throws IOException {
+    javaWriter.addPackage("com.squareup");
+    javaWriter.addImport("java.util.Map");
+    javaWriter.addImport("java.util.Date");
+    javaWriter.beginType("com.squareup.Foo", "class", 0);
+    javaWriter.field("java.util.Map<java.lang.String, java.util.Date>", "map", 0);
+    javaWriter.endType();
+    assertCode(""
+        + "package com.squareup;\n"
+        + "import java.util.Map;\n"
+        + "import java.util.Date;\n"
+        + "class Foo {\n"
+        + "  Map<String, Date> map;\n"
+        + "}\n");
+  }
+
+  @Test public void testStringLiteral() {
+    assertThat(JavaWriter.stringLiteral("")).isEqualTo("\"\"");
+    assertThat(JavaWriter.stringLiteral("JavaWriter")).isEqualTo("\"JavaWriter\"");
+    assertThat(JavaWriter.stringLiteral("\\")).isEqualTo("\"\\\\\"");
+    assertThat(JavaWriter.stringLiteral("\"")).isEqualTo("\"\\\"\"");
+    assertThat(JavaWriter.stringLiteral("\t")).isEqualTo("\"\\\t\"");
+    assertThat(JavaWriter.stringLiteral("\n")).isEqualTo("\"\\\n\"");
+  }
+
   private void assertCode(String expected) {
     assertThat(stringWriter.toString()).isEqualTo(expected);
   }
/Fim/
diff --git a/src/test/java/com/squareup/injector/internal/KeysTest.java b/src/test/java/com/squareup/injector/internal/KeysTest.java
index bed93cd..680a8be 100644
--- a/src/test/java/com/squareup/injector/internal/KeysTest.java
+++ b/src/test/java/com/squareup/injector/internal/KeysTest.java
@@ -76,7 +76,8 @@
   }
 
   @Named("foo") String annotated;
-  @Test public void testIsAnnotatedTrue() throws NoSuchFieldException {
+  @Test public void testAnnotated() throws NoSuchFieldException {
+    assertThat(fieldKey("annotated")).isEqualTo("@javax.inject.Named(value=foo)/java.lang.String");
     assertThat(Keys.isAnnotated(fieldKey("annotated"))).isTrue();
   }
 
/Fim/
diff --git a/src/main/java/com/squareup/codegen/CodeGen.java b/src/main/java/com/squareup/codegen/CodeGen.java
new file mode 100644
index 0000000..d6d1fef
--- /dev/null
+++ b/src/main/java/com/squareup/codegen/CodeGen.java
@@ -0,0 +1,54 @@
+/**
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.codegen;
+
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.PackageElement;
+
+/**
+ * Support for annotation processors.
+ *
+ * @author Jesse Wilson
+ */
+public final class CodeGen {
+  private CodeGen() {
+  }
+
+  public static PackageElement getPackage(Element type) {
+    while (type.getKind() != ElementKind.PACKAGE) {
+      type = type.getEnclosingElement();
+    }
+    return (PackageElement) type;
+  }
+
+  /**
+   * Returns a string like {@code java.util.List<java.lang.String>}.
+   */
+  public static String parameterizedType(Class<?> raw, String... parameters) {
+    StringBuilder result = new StringBuilder();
+    result.append(raw.getName());
+    result.append("<");
+    for (int i = 0; i < parameters.length; i++) {
+      if (i != 0) {
+        result.append(", ");
+      }
+      result.append(parameters[i]);
+    }
+    result.append(">");
+    return result.toString();
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/codegen/ProvidesProcessor.java b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
index 84ae421..d401b92 100644
--- a/src/main/java/com/squareup/codegen/ProvidesProcessor.java
+++ b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
@@ -34,7 +34,6 @@
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
-import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
@@ -55,16 +54,16 @@
 @SupportedAnnotationTypes("com.squareup.injector.Provides")
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class ProvidesProcessor extends AbstractProcessor {
-  private final String bindingsMap = parameterizedType(Map.class,
-      String.class.getName(), Binding.class.getName() + "<?>");
-  private final String bindingsHashMap = parameterizedType(HashMap.class,
-      String.class.getName(), Binding.class.getName() + "<?>");
+  private static final String bindingsMap = CodeGen.parameterizedType(
+      Map.class, String.class.getName(), Binding.class.getName() + "<?>");
+  private static final String bindingsHashMap = CodeGen.parameterizedType(
+      HashMap.class, String.class.getName(), Binding.class.getName() + "<?>");
 
   @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
     try {
       Map<TypeElement, List<ExecutableElement>> providerMethods = providerMethodsByClass(env);
       for (Map.Entry<TypeElement, List<ExecutableElement>> module : providerMethods.entrySet()) {
-        generateProvides(module.getKey(), module.getValue());
+        writeModuleAdapter(module.getKey(), module.getValue());
       }
     } catch (IOException e) {
       processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "Code gen failed: " + e);
@@ -112,13 +111,17 @@
     return result;
   }
 
-  private void generateProvides(TypeElement type, List<ExecutableElement> providerMethods)
+  /**
+   * Write a companion class for {@code type} that implements {@link
+   * ModuleAdapter} to expose its provider methods.
+   */
+  private void writeModuleAdapter(TypeElement type, List<ExecutableElement> providerMethods)
       throws IOException {
     JavaFileObject sourceFile = processingEnv.getFiler()
         .createSourceFile(type.getQualifiedName() + "$ModuleAdapter", type);
     JavaWriter writer = new JavaWriter(sourceFile.openWriter());
 
-    writer.addPackage(getPackage(type).getQualifiedName().toString());
+    writer.addPackage(CodeGen.getPackage(type).getQualifiedName().toString());
     writer.addImport(Binding.class);
     writer.addImport(ModuleAdapter.class);
     writer.addImport(Map.class);
@@ -126,7 +129,7 @@
 
     String typeName = type.getQualifiedName().toString();
     writer.beginType(typeName + "$ModuleAdapter", "class", PUBLIC | FINAL, null,
-        parameterizedType(ModuleAdapter.class, typeName));
+        CodeGen.parameterizedType(ModuleAdapter.class, typeName));
 
     writer.annotation(Override.class);
     writer.beginMethod(bindingsMap, "getBindings", PUBLIC, typeName, "module");
@@ -147,38 +150,22 @@
     writer.close();
   }
 
-  /**
-   * Returns a string like {@code java.util.List<java.lang.String>}.
-   */
-  private static String parameterizedType(Class<?> raw, String... parameters) {
-    StringBuilder result = new StringBuilder();
-    result.append(raw.getName());
-    result.append("<");
-    for (int i = 0; i < parameters.length; i++) {
-      if (i != 0) {
-        result.append(", ");
-      }
-      result.append(parameters[i]);
-    }
-    result.append(">");
-    return result.toString();
-  }
-
   private void writeBindingClass(JavaWriter writer, ExecutableElement providerMethod)
       throws IOException {
     String methodName = providerMethod.getSimpleName().toString();
     String key = GeneratorKeys.get(providerMethod);
-    String moduleType = typeToString(providerMethod.getEnclosingElement().asType());
+    String moduleType = providerMethod.getEnclosingElement().asType().toString();
     String className = providerMethod.getSimpleName() + "Binding";
-    String returnType = typeToString(providerMethod.getReturnType());
+    String returnType = providerMethod.getReturnType().toString();
 
     writer.beginType(className, "class", PRIVATE | STATIC,
-        parameterizedType(Binding.class, returnType));
+        CodeGen.parameterizedType(Binding.class, returnType));
     writer.field(moduleType, "module", PRIVATE | FINAL);
     List<? extends VariableElement> parameters = providerMethod.getParameters();
     for (int p = 0; p < parameters.size(); p++) {
       TypeMirror parameterType = parameters.get(p).asType();
-      writer.field(parameterizedType(Binding.class, typeToString(parameterType)), "p" + p, PRIVATE);
+      writer.field(CodeGen.parameterizedType(Binding.class, parameterType.toString()),
+          "p" + p, PRIVATE);
     }
 
     writer.beginMethod(null, className, PUBLIC, moduleType, "module");
@@ -191,9 +178,9 @@
     for (int p = 0; p < parameters.size(); p++) {
       VariableElement parameter = parameters.get(p);
       String parameterKey = GeneratorKeys.get(parameter);
-      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
-          "p" + p,
-          parameterizedType(Binding.class, typeToString(parameter.asType())),
+      writer.statement("p%d = (%s) linker.requestBinding(%s, %s.class)",
+          p,
+          CodeGen.parameterizedType(Binding.class, parameter.asType().toString()),
           JavaWriter.stringLiteral(parameterKey), moduleType);
     }
     writer.endMethod();
@@ -205,7 +192,7 @@
       if (p != 0) {
         args.append(", ");
       }
-      args.append(String.format("%s.get()", "p" + p));
+      args.append(String.format("p%d.get()", p));
     }
     writer.statement("return module.%s(%s)", methodName, args.toString());
     writer.endMethod();
@@ -217,15 +204,4 @@
 
     writer.endType();
   }
-
-  private String typeToString(TypeMirror type) {
-    return type.toString();
-  }
-
-  private PackageElement getPackage(Element type) {
-    while (type.getKind() != ElementKind.PACKAGE) {
-      type = type.getEnclosingElement();
-    }
-    return (PackageElement) type;
-  }
 }
/Fim/
diff --git a/src/main/java/com/squareup/codegen/GeneratorKeys.java b/src/main/java/com/squareup/codegen/GeneratorKeys.java
index 6c45577..4b92db6 100644
--- a/src/main/java/com/squareup/codegen/GeneratorKeys.java
+++ b/src/main/java/com/squareup/codegen/GeneratorKeys.java
@@ -67,7 +67,7 @@
     result.append('@');
     result.append(((TypeElement) qualifier.getAnnotationType().asElement()).getQualifiedName());
     result.append('(');
-    for (Map.Entry<? extends ExecutableElement,? extends AnnotationValue> entry
+    for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry
         : qualifier.getElementValues().entrySet()) {
       result.append(entry.getKey().getSimpleName());
       result.append('=');
/Fim/
diff --git a/src/main/java/com/squareup/codegen/ProvidesProcessor.java b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
index d401b92..5c2b337 100644
--- a/src/main/java/com/squareup/codegen/ProvidesProcessor.java
+++ b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
@@ -54,9 +54,9 @@
 @SupportedAnnotationTypes("com.squareup.injector.Provides")
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class ProvidesProcessor extends AbstractProcessor {
-  private static final String bindingsMap = CodeGen.parameterizedType(
+  private static final String BINDINGS_MAP = CodeGen.parameterizedType(
       Map.class, String.class.getName(), Binding.class.getName() + "<?>");
-  private static final String bindingsHashMap = CodeGen.parameterizedType(
+  private static final String BINDINGS_HASH_MAP = CodeGen.parameterizedType(
       HashMap.class, String.class.getName(), Binding.class.getName() + "<?>");
 
   @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
@@ -132,8 +132,8 @@
         CodeGen.parameterizedType(ModuleAdapter.class, typeName));
 
     writer.annotation(Override.class);
-    writer.beginMethod(bindingsMap, "getBindings", PUBLIC, typeName, "module");
-    writer.statement("%s result = new %s()", bindingsMap, bindingsHashMap);
+    writer.beginMethod(BINDINGS_MAP, "getBindings", PUBLIC, typeName, "module");
+    writer.statement("%s result = new %s()", BINDINGS_MAP, BINDINGS_HASH_MAP);
     for (ExecutableElement providerMethod : providerMethods) {
       String key = GeneratorKeys.get(providerMethod);
       writer.statement("result.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Keys.java b/src/main/java/com/squareup/injector/internal/Keys.java
index 0d74700..c35264d 100644
--- a/src/main/java/com/squareup/injector/internal/Keys.java
+++ b/src/main/java/com/squareup/injector/internal/Keys.java
@@ -173,26 +173,15 @@
   }
 
   private static Type boxIfPrimitive(Type type) {
-    if (type == byte.class) {
-      return Byte.class;
-    } if (type == short.class) {
-      return Short.class;
-    } if (type == int.class) {
-      return Integer.class;
-    } else if (type == long.class) {
-      return Long.class;
-    } else if (type == char.class) {
-      return Character.class;
-    } else if (type == boolean.class) {
-      return Boolean.class;
-    } else if (type == float.class) {
-      return Float.class;
-    } else if (type == double.class) {
-      return Double.class;
-    } else if (type == void.class) {
-      return Void.class;
-    } else {
-      return type;
-    }
+    if (type == byte.class) return Byte.class;
+    if (type == short.class) return Short.class;
+    if (type == int.class) return Integer.class;
+    if (type == long.class) return Long.class;
+    if (type == char.class) return Character.class;
+    if (type == boolean.class) return Boolean.class;
+    if (type == float.class) return Float.class;
+    if (type == double.class) return Double.class;
+    if (type == void.class) return Void.class;
+    return type;
   }
 }
/Fim/
diff --git a/src/main/java/com/squareup/codegen/CodeGen.java b/src/main/java/com/squareup/codegen/CodeGen.java
index b875612..960aa8c 100644
--- a/src/main/java/com/squareup/codegen/CodeGen.java
+++ b/src/main/java/com/squareup/codegen/CodeGen.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
/Fim/
diff --git a/src/main/java/com/squareup/codegen/GeneratorKeys.java b/src/main/java/com/squareup/codegen/GeneratorKeys.java
index 4b92db6..4f4f5a4 100644
--- a/src/main/java/com/squareup/codegen/GeneratorKeys.java
+++ b/src/main/java/com/squareup/codegen/GeneratorKeys.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
/Fim/
diff --git a/src/main/java/com/squareup/codegen/InjectProcessor.java b/src/main/java/com/squareup/codegen/InjectProcessor.java
index 0b29b2c..9d9e324 100644
--- a/src/main/java/com/squareup/codegen/InjectProcessor.java
+++ b/src/main/java/com/squareup/codegen/InjectProcessor.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
/Fim/
diff --git a/src/main/java/com/squareup/codegen/ProvidesProcessor.java b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
index 8451a24..80b5ded 100644
--- a/src/main/java/com/squareup/codegen/ProvidesProcessor.java
+++ b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
/Fim/
diff --git a/src/main/java/com/squareup/injector/DependencyGraph.java b/src/main/java/com/squareup/injector/DependencyGraph.java
new file mode 100644
index 0000000..092f2c3
--- /dev/null
+++ b/src/main/java/com/squareup/injector/DependencyGraph.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.injector;
+
+import com.squareup.injector.internal.Binding;
+import com.squareup.injector.internal.Keys;
+import com.squareup.injector.internal.Linker;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * A dependency graph.
+ *
+ * <p>The following injection features are supported:
+ * <ul>
+ *   <li>Field injection. A class may have any number of field injections, and
+ *       fields may be of any visibility. Static fields will be injected each
+ *       time an instance is injected.
+ *   <li>Constructor injection. A class may have a single {@code
+ *       @Inject}-annotated constructor. Classes that have fields injected
+ *       may omit the {@link @Inject} annotation if they have a public
+ *       no-arguments constructor.
+ *   <li>Injection of {@code @Provides} method parameters.
+ *   <li>{@code @Provides} methods annotated {@code @Singleton}.
+ *   <li>Constructor-injected classes annotated {@code @Singleton}.
+ *   <li>Injection of {@link javax.inject.Provider}s.
+ *   <li>Qualifier annotations on injected parameters and fields.
+ *   <li>JSR 330 annotations.
+ * </ul>
+ *
+ * <p>The following injection features are not currently supported:
+ * <ul>
+ *   <li>Method injection.</li>
+ *   <li>Circular dependencies.</li>
+ * </ul>
+ *
+ * @author Jesse Wilson
+ */
+public final class DependencyGraph {
+  private final Class<?> injectorClass;
+  private final Map<Class<?>, Binding<?>> bindings;
+
+  private DependencyGraph(Class<?> injectorClass, Map<Class<?>, Binding<?>> bindings) {
+    this.injectorClass = injectorClass;
+    this.bindings = bindings;
+  }
+
+  /**
+   * Returns a new dependency graph using the {@literal @}{@link
+   * Injector}-annotated object and {@code modules}.
+   */
+  public static DependencyGraph get(Object injector, Object... overrides) {
+    Class<?> injectorClass = injector.getClass();
+    Injector annotation = injectorClass.getAnnotation(Injector.class);
+    if (annotation == null) {
+      throw new IllegalArgumentException("No @Injector on " + injectorClass.getName());
+    }
+    Class<?>[] entryPoints = annotation.entryPoints();
+    Class<?>[] modules = annotation.modules();
+
+    /*
+     * Create a linker and install all of the user's modules. Modules provided
+     * at runtime may override modules provided in the @Injector annotation.
+     */
+    Linker linker = new Linker();
+    linker.installModules(classesToObjects(modules));
+    linker.installModules(overrides);
+
+    /*
+     * Request the bindings we'll need from the linker. This will cause the
+     * linker to link these bindings in the link step.
+     */
+    getEntryPointsMap(linker, injectorClass, entryPoints);
+
+    /*
+     * Fill out the graph, creating JIT bindings as necessary.
+     */
+    linker.link();
+
+    /*
+     * Link success. Return a new linked dependency graph.
+     */
+    return new DependencyGraph(injectorClass,
+        getEntryPointsMap(linker, injectorClass, entryPoints));
+  }
+
+  private static Object[] classesToObjects(Class<?>[] moduleClasses) {
+    try {
+      Object[] moduleObjects = new Object[moduleClasses.length];
+      for (int i = 0; i < moduleClasses.length; i++) {
+        Class<?> module = moduleClasses[i];
+        moduleObjects[i] = module.newInstance();
+      }
+      return moduleObjects;
+    } catch (RuntimeException e) {
+      throw e;
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  /**
+   * Returns a map from class to entry point.
+   *
+   * <p>If executed before {@code link()}, this tells the linker which keys are
+   * required. Since the bindings haven't been linked, the returned map may
+   * contain null bindings and should not be used.
+   *
+   * <p>If executed after {@code link()}, the bindings will not be null and the
+   * map can be used.
+   */
+  private static Map<Class<?>, Binding<?>> getEntryPointsMap(Linker linker, Class<?> injectorClass,
+      Class<?>[] entryPoints) {
+    Map<Class<?>, Binding<?>> result = new HashMap<Class<?>, Binding<?>>();
+    result.put(injectorClass, linker.requestBinding(Keys.get(injectorClass), "injector"));
+    for (Class<?> entryPoint : entryPoints) {
+      result.put(entryPoint, linker.requestBinding(Keys.get(entryPoint), "entry point"));
+    }
+    return result;
+  }
+
+  @SuppressWarnings("unchecked") // bindings is a typesafe heterogeneous container
+  public void inject(Object instance) {
+    Binding<Object> binding = (Binding<Object>) bindings.get(instance.getClass());
+    if (binding == null) {
+      throw new IllegalArgumentException("No binding for " + instance.getClass().getName() + ". "
+          + "You must explicitly add it as an entry point of " + injectorClass.getName() + ".");
+    }
+    binding.injectMembers(instance);
+  }
+}
/Fim/
diff --git a/src/main/java/com/squareup/injector/Injector.java b/src/main/java/com/squareup/injector/Injector.java
index ca1d450..470a9a2 100644
--- a/src/main/java/com/squareup/injector/Injector.java
+++ b/src/main/java/com/squareup/injector/Injector.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -15,51 +15,18 @@
  */
 package com.squareup.injector;
 
-import com.squareup.injector.internal.Binding;
-import com.squareup.injector.internal.InternalInjector;
-import com.squareup.injector.internal.Keys;
-import java.util.Map;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
 
 /**
- * Dependency injector.
- *
- * <p>The following injection features are supported:
- * <ul>
- *   <li>Field injection. A class may have any number of field injections, and
- *       fields may be of any visibility. Static fields will be injected each
- *       time an instance is injected.
- *   <li>Constructor injection. A class may have a single {@code
- *       @Inject}-annotated constructor. Classes that have fields injected
- *       may omit the {@link @Inject} annotation if they have a public
- *       no-arguments constructor.
- *   <li>Injection of {@code @Provides} method parameters.
- *   <li>{@code @Provides} methods annotated {@code @Singleton}.
- *   <li>Constructor-injected classes annotated {@code @Singleton}.
- *   <li>Injection of {@link javax.inject.Provider}s.
- *   <li>Qualifier annotations on injected parameters and fields.
- *   <li>JSR 330 annotations.
- * </ul>
- *
- * <p>The following injection features are not currently supported:
- * <ul>
- *   <li>Method injection.</li>
- *   <li>Circular dependencies.</li>
- * </ul>
+ * Annotates the root of the dependency graph.
  *
  * @author Jesse Wilson
  */
-public final class Injector {
-  /**
-   * Creates an injector defined by {@code modules} and immediately uses it to
-   * create an instance of {@code type}. The modules can be of any type, and
-   * must contain {@code @Provides} methods.
-   */
-  public <T> T inject(Class<T> type, Object... modules) {
-    InternalInjector injector = new InternalInjector();
-    Map<String, Binding<?>> combined = Modules.moduleToMap(Modules.combine(modules));
-    for (Binding<?> binding : combined.values()) {
-      injector.putBinding(binding);
-    }
-    return (T) injector.inject(Keys.get(type));
-  }
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE) public @interface Injector {
+  Class<?>[] modules() default {};
+  Class<?>[] entryPoints() default {};
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/MembersInjector.java b/src/main/java/com/squareup/injector/MembersInjector.java
index 4a00117..3767d39 100644
--- a/src/main/java/com/squareup/injector/MembersInjector.java
+++ b/src/main/java/com/squareup/injector/MembersInjector.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
/Fim/
diff --git a/src/main/java/com/squareup/injector/Provides.java b/src/main/java/com/squareup/injector/Provides.java
index fbb7e1f..fb0b4f7 100644
--- a/src/main/java/com/squareup/injector/Provides.java
+++ b/src/main/java/com/squareup/injector/Provides.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2007 Google Inc.
  * Copyright (C) 2012 Square, Inc.
  *
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Binding.java b/src/main/java/com/squareup/injector/internal/Binding.java
index 710fdc3..c408887 100644
--- a/src/main/java/com/squareup/injector/internal/Binding.java
+++ b/src/main/java/com/squareup/injector/internal/Binding.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/BuiltInBinding.java b/src/main/java/com/squareup/injector/internal/BuiltInBinding.java
index b9e4b70..434bfa0 100644
--- a/src/main/java/com/squareup/injector/internal/BuiltInBinding.java
+++ b/src/main/java/com/squareup/injector/internal/BuiltInBinding.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ConstructorBinding.java b/src/main/java/com/squareup/injector/internal/ConstructorBinding.java
index 41b7893..ae1ab7f 100644
--- a/src/main/java/com/squareup/injector/internal/ConstructorBinding.java
+++ b/src/main/java/com/squareup/injector/internal/ConstructorBinding.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
/Fim/
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Keys.java b/src/main/java/com/squareup/injector/internal/Keys.java
index c35264d..5b870c1 100644
--- a/src/main/java/com/squareup/injector/internal/Keys.java
+++ b/src/main/java/com/squareup/injector/internal/Keys.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Linker.java b/src/main/java/com/squareup/injector/internal/Linker.java
index 0bb3c8d..5ebb7a2 100644
--- a/src/main/java/com/squareup/injector/internal/Linker.java
+++ b/src/main/java/com/squareup/injector/internal/Linker.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -15,8 +15,11 @@
  */
 package com.squareup.injector.internal;
 
-import java.util.Collection;
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
 import java.util.Queue;
 
 /**
@@ -25,7 +28,7 @@
  * @author Jesse Wilson
  */
 public final class Linker {
-  private final InternalInjector injector;
+  private static final Object UNINITIALIZED = new Object();
 
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
   private final Queue<Binding<?>> unattachedBindings = new LinkedList<Binding<?>>();
@@ -33,8 +36,21 @@
   /** True unless calls to requestBinding() were unable to satisfy the binding. */
   private boolean currentAttachSuccess = true;
 
-  public Linker(InternalInjector injector) {
-    this.injector = injector;
+  /** All errors encountered during injection. */
+  private final List<String> errors = new ArrayList<String>();
+
+  /** All of the injector's bindings. */
+  private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
+
+  /**
+   * Adds the {@code @Provides} bindings from {@code modules}. There may not
+   * be any duplicated bindings in {@code modules}, though multiple calls to
+   * this method may contain duplicates: last installed wins.
+   */
+  public void installModules(Object[] modules) {
+    for (Binding<?> binding : Modules.getBindings(modules).values()) {
+      putBinding(binding);
+    }
   }
 
   /**
@@ -42,28 +58,37 @@
    * to fill in the gaps. When this returns all bindings and their dependencies
    * will be attached.
    */
-  public void link(Collection<Binding<?>> bindings) {
-    unattachedBindings.addAll(bindings);
+  public void link() {
+    unattachedBindings.addAll(bindings.values());
 
     Binding binding;
     while ((binding = unattachedBindings.poll()) != null) {
       if (binding instanceof DeferredBinding) {
-        if (injector.getBinding(binding.key) != null) {
+        if (getBinding(binding.key) != null) {
           continue; // A binding for this key has already been promoted.
         }
         try {
           Binding<?> jitBinding = createJitBinding((DeferredBinding<?>) binding);
           // Enqueue the JIT binding so its own dependencies can be linked.
           unattachedBindings.add(jitBinding);
-          injector.putBinding(jitBinding);
+          putBinding(jitBinding);
         } catch (Exception e) {
-          injector.addError(e.getMessage() + " required by " + binding.requiredBy);
-          injector.putBinding(new UnresolvedBinding<Object>(binding.requiredBy, binding.key));
+          addError(e.getMessage() + " required by " + binding.requiredBy);
+          putBinding(new UnresolvedBinding<Object>(binding.requiredBy, binding.key));
         }
       } else {
         attachBinding(binding);
       }
     }
+
+    if (!errors.isEmpty()) {
+      StringBuilder message = new StringBuilder();
+      message.append("Errors creating injector:");
+      for (String error : errors) {
+        message.append("\n  ").append(error);
+      }
+      throw new IllegalArgumentException(message.toString());
+    }
   }
 
   /**
@@ -111,7 +136,7 @@
    * caller's binding.
    */
   public Binding<?> requestBinding(String key, final Object requiredBy) {
-    Binding<?> binding = injector.getBinding(key);
+    Binding<?> binding = getBinding(key);
     if (binding == null) {
       // We can't satisfy this binding. Make sure it'll work next time!
       unattachedBindings.add(new DeferredBinding<Object>(requiredBy, key));
@@ -120,6 +145,41 @@
     return binding;
   }
 
+  private Binding<?> getBinding(String key) {
+    return bindings.get(key);
+  }
+
+  private <T> void putBinding(final Binding<T> binding) {
+    Binding<T> toInsert = binding;
+    if (binding.isSingleton()) {
+      toInsert = new Binding<T>(binding.requiredBy, binding.key) {
+        private Object onlyInstance = UNINITIALIZED;
+        @Override public void attach(Linker linker) {
+          binding.attach(linker);
+        }
+        @Override public void injectMembers(T t) {
+          binding.injectMembers(t);
+        }
+        @SuppressWarnings("unchecked") // 'onlyInstance is either UNINITIALIZED' or a 'T'.
+        @Override public T get() {
+          if (onlyInstance == UNINITIALIZED) {
+            onlyInstance = binding.get();
+          }
+          return (T) onlyInstance;
+        }
+        @Override public boolean isSingleton() {
+          return binding.isSingleton();
+        }
+      };
+    }
+
+    bindings.put(toInsert.key, toInsert);
+  }
+
+  private void addError(String message) {
+    errors.add(message);
+  }
+
   private static class DeferredBinding<T> extends Binding<T> {
     private DeferredBinding(Object requiredBy, String key) {
       super(requiredBy, key);
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/LruCache.java b/src/main/java/com/squareup/injector/internal/LruCache.java
index 35f93d8..f00d6c2 100644
--- a/src/main/java/com/squareup/injector/internal/LruCache.java
+++ b/src/main/java/com/squareup/injector/internal/LruCache.java
@@ -13,7 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.squareup.injector.internal;
 
 import java.util.LinkedHashMap;
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/ModuleAdapter.java b/src/main/java/com/squareup/injector/internal/ModuleAdapter.java
index 957c525..00fbd51 100644
--- a/src/main/java/com/squareup/injector/internal/ModuleAdapter.java
+++ b/src/main/java/com/squareup/injector/internal/ModuleAdapter.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
/Fim/
diff --git a/src/main/java/com/squareup/injector/Modules.java b/src/main/java/com/squareup/injector/internal/Modules.java
similarity index 67%
rename from src/main/java/com/squareup/injector/Modules.java
rename to src/main/java/com/squareup/injector/internal/Modules.java
index 03e0479..b0a8c93 100644
--- a/src/main/java/com/squareup/injector/Modules.java
+++ b/src/main/java/com/squareup/injector/internal/Modules.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -13,10 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector;
+package com.squareup.injector.internal;
 
-import com.squareup.injector.internal.Binding;
-import com.squareup.injector.internal.Keys;
+import com.squareup.injector.Provides;
 import java.lang.reflect.Method;
 import java.util.HashMap;
 import java.util.Map;
@@ -28,21 +27,27 @@
  *
  * @author Jesse Wilson
  */
-public final class Modules {
+final class Modules {
   private Modules() {
   }
 
   /**
-   * Returns a map containing the bindings in {@code object}.
+   * Returns a module containing all bindings in {@code modules}.
    *
-   * @param  module either a {@code map} of bindings, or an instance of a class
-   *     that declares one or more {@code @Provides} methods.
+   * @throws IllegalArgumentException if any bindings are duplicated.
    */
-  static Map<String, Binding<?>> moduleToMap(Object module) {
-    if (module instanceof Map) {
-      return (Map<String, Binding<?>>) module;
+  public static Map<String, Binding<?>> getBindings(Object... modules) {
+    Map<String, Binding<?>> result = new HashMap<String, Binding<?>>();
+    int expectedSize = 0;
+    for (Object module : modules) {
+      Map<String, Binding<?>> moduleBindings = extractBindings(module);
+      expectedSize += moduleBindings.size();
+      result.putAll(moduleBindings);
     }
-    return extractBindings(module);
+    if (result.size() != expectedSize) {
+      throw new IllegalArgumentException("Duplicate bindings!");
+    }
+    return result;
   }
 
   /**
@@ -71,33 +76,4 @@
     String key = Keys.get(method.getGenericReturnType(), method.getAnnotations(), method);
     return new ProviderMethodBinding<T>(method, key, module);
   }
-
-  /**
-   * Returns a module containing the union of the bindings of {@code base} and
-   * the bindings of {@code overrides}. If any key is represented in both
-   * modules, the binding from {@code overrides} is retained.
-   */
-  public static Object override(Object base, Object overrides) {
-    Map<String, Binding<?>> result = new HashMap<String, Binding<?>>();
-    result.putAll(moduleToMap(base));
-    result.putAll(moduleToMap(overrides));
-    return result;
-  }
-
-  /**
-   * Returns a module containing all bindings in {@code modules}.
-   */
-  public static Object combine(Object... modules) {
-    Map<String, Binding<?>> result = new HashMap<String, Binding<?>>();
-    int expectedSize = 0;
-    for (Object module : modules) {
-      Map<String, Binding<?>> moduleBindings = moduleToMap(module);
-      expectedSize += moduleBindings.size();
-      result.putAll(moduleBindings);
-    }
-    if (result.size() != expectedSize) {
-      throw new IllegalArgumentException("Duplicate bindings!");
-    }
-    return result;
-  }
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/ProviderMethodBinding.java b/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
similarity index 97%
rename from src/main/java/com/squareup/injector/ProviderMethodBinding.java
rename to src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
index 33ee791..3d06771 100644
--- a/src/main/java/com/squareup/injector/ProviderMethodBinding.java
+++ b/src/main/java/com/squareup/injector/internal/ProviderMethodBinding.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Copyright (C) 2012 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.injector;
+package com.squareup.injector.internal;
 
 import com.squareup.injector.internal.Binding;
 import com.squareup.injector.internal.Keys;
/Fim/
diff --git a/src/test/java/com/squareup/injector/InjectorTest.java b/src/test/java/com/squareup/injector/InjectorTest.java
index 60431b7..553aa2e 100644
--- a/src/test/java/com/squareup/injector/InjectorTest.java
+++ b/src/test/java/com/squareup/injector/InjectorTest.java
@@ -32,15 +32,23 @@
  */
 @SuppressWarnings("unused")
 public final class InjectorTest {
+
+  @Injector
+  public static class GInjector extends AbstractInjector<GInjector> {
+    @Inject Provider<G> gProvider;
+  }
+
   @Test public void basicInjection() {
-    G g = new Injector().inject(G.class, new Object() {
+    GInjector gInjector = new GInjector().inject(new Object() {
       @Provides E provideE(F f) {
         return new E(f);
       }
+
       @Provides F provideF() {
         return new F();
       }
     });
+    G g = gInjector.gProvider.get();
 
     assertThat(g.a).isNotNull();
     assertThat(g.b).isNotNull();
@@ -50,11 +58,17 @@
     assertThat(g.e.f).isNotNull();
   }
 
+  @Injector
+  public static class GMembersInjector extends AbstractInjector<GMembersInjector> {
+    @Inject MembersInjector<G> gInjector;
+  }
+
   @Test public void memberInjection() {
-    MembersInjectors membersInjectors = new Injector().inject(MembersInjectors.class, new Object() {
+    GMembersInjector membersInjectors = new GMembersInjector().inject(new Object() {
       @Provides E provideE(F f) {
         return new E(f);
       }
+
       @Provides F provideF() {
         return new F();
       }
@@ -109,29 +123,26 @@
     }
   }
 
-  public static class MembersInjectors {
-    @Inject MembersInjector<G> gInjector;
-  }
-
   @Test public void providerInjection() {
-    H h = new Injector().inject(H.class);
-    assertThat(h.aProvider.get()).isNotNull();
-    assertThat(h.aProvider.get()).isNotNull();
-    assertThat(h.aProvider.get()).isNotSameAs(h.aProvider.get());
+    AProviderInjector aProviderInjector = new AProviderInjector().inject();
+    assertThat(aProviderInjector.aProvider.get()).isNotNull();
+    assertThat(aProviderInjector.aProvider.get()).isNotNull();
+    assertThat(aProviderInjector.aProvider.get()).isNotSameAs(aProviderInjector.aProvider.get());
   }
 
-  public static class H {
+  @Injector
+  public static class AProviderInjector extends AbstractInjector<AProviderInjector> {
     @Inject Provider<A> aProvider;
   }
 
   @Test public void singletons() {
-    J j = new Injector().inject(J.class, new Object() {
+    FiInjector fiInjector = new FiInjector().inject(new Object() {
       @Provides @Singleton F provideK() {
         return new F();
       }
     });
-    assertThat(j.fProvider.get()).isSameAs(j.fProvider.get());
-    assertThat(j.iProvider.get()).isSameAs(j.iProvider.get());
+    assertThat(fiInjector.fProvider.get()).isSameAs(fiInjector.fProvider.get());
+    assertThat(fiInjector.iProvider.get()).isSameAs(fiInjector.iProvider.get());
   }
 
   @Singleton
@@ -139,17 +150,17 @@
     @Inject I() {}
   }
 
-  static class J {
+  @Injector
+  public static class FiInjector extends AbstractInjector<FiInjector> {
     @Inject Provider<F> fProvider;
     @Inject Provider<I> iProvider;
-    @Inject J() {}
   }
 
   @Test public void bindingAnnotations() {
     final A one = new A();
     final A two = new A();
 
-    K k = new Injector().inject(K.class, new Object() {
+    NamedInjector k = new NamedInjector().inject(new Object() {
       @Provides @Named("one") A getOne() {
         return one;
       }
@@ -163,7 +174,8 @@
     assertThat(two).isSameAs(k.aTwo);
   }
 
-  public static class K {
+  @Injector
+  public static class NamedInjector extends AbstractInjector<NamedInjector> {
     @Inject A a;
     @Inject @Named("one") A aOne;
     @Inject @Named("two") A aTwo;
@@ -173,20 +185,27 @@
     final AtomicReference<A> a1 = new AtomicReference<A>();
     final AtomicReference<A> a2 = new AtomicReference<A>();
 
-    L l = new Injector().inject(L.class, new Object() {
+    LInjector lInjector = new LInjector().inject(new Object() {
       @Provides @Singleton @Named("one") F provideF(Provider<A> aProvider) {
         a1.set(aProvider.get());
         a2.set(aProvider.get());
         return new F();
       }
     });
+    lInjector.lProvider.get();
 
     assertThat(a1.get()).isNotNull();
     assertThat(a2.get()).isNotNull();
     assertThat(a1.get()).isNotSameAs(a2.get());
+    L l = lInjector.lProvider.get();
     assertThat(l).isSameAs(l.lProvider.get());
   }
 
+  @Injector
+  public static class LInjector extends AbstractInjector<LInjector> {
+    @Inject Provider<L> lProvider;
+  }
+
   @Singleton
   public static class L {
     @Inject @Named("one") F f;
@@ -194,22 +213,23 @@
   }
 
   @Test public void singletonInGraph() {
-    M m = new Injector().inject(M.class, new Object() {
+    MultipleInjector multipleInjector = new MultipleInjector().inject(new Object() {
       @Provides @Singleton F provideF() {
         return new F();
       }
     });
 
-    assertThat(m.f1).isSameAs(m.f2);
-    assertThat(m.f1).isSameAs(m.n1.f1);
-    assertThat(m.f1).isSameAs(m.n1.f2);
-    assertThat(m.f1).isSameAs(m.n2.f1);
-    assertThat(m.f1).isSameAs(m.n2.f2);
-    assertThat(m.f1).isSameAs(m.n1.fProvider.get());
-    assertThat(m.f1).isSameAs(m.n2.fProvider.get());
+    assertThat(multipleInjector.f1).isSameAs(multipleInjector.f2);
+    assertThat(multipleInjector.f1).isSameAs(multipleInjector.n1.f1);
+    assertThat(multipleInjector.f1).isSameAs(multipleInjector.n1.f2);
+    assertThat(multipleInjector.f1).isSameAs(multipleInjector.n2.f1);
+    assertThat(multipleInjector.f1).isSameAs(multipleInjector.n2.f2);
+    assertThat(multipleInjector.f1).isSameAs(multipleInjector.n1.fProvider.get());
+    assertThat(multipleInjector.f1).isSameAs(multipleInjector.n2.fProvider.get());
   }
 
-  public static class M {
+  @Injector
+  public static class MultipleInjector extends AbstractInjector<MultipleInjector> {
     @Inject N n1;
     @Inject N n2;
     @Inject F f1;
@@ -224,23 +244,29 @@
 
   @Test public void noJitBindingsForAnnotations() {
     try {
-      new Injector().inject(O.class);
+      new AnnotatedJitInjector().inject();
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
 
-  public static class O {
+  @Injector
+  public static class AnnotatedJitInjector extends AbstractInjector<AnnotatedJitInjector> {
     @Inject @Named("a") A a;
   }
 
   @Test public void subclasses() {
-    Q q = new Injector().inject(Q.class, new Object() {
+    QInjector qInjector = new QInjector().inject(new Object() {
       @Provides F provideF() {
         return new F();
       }
     });
-    assertThat(q.f).isNotNull();
+    assertThat(qInjector.q.f).isNotNull();
+  }
+
+  @Injector
+  public static class QInjector extends AbstractInjector<QInjector> {
+    @Inject Q q;
   }
 
   public static class P {
@@ -255,7 +281,7 @@
     final AtomicBoolean sInjected = new AtomicBoolean();
 
     R.injected = false;
-    new Injector().inject(A.class, new Object() {
+    AProviderInjector aProviderInjector = new AProviderInjector().inject(new Object() {
       @Provides F provideF(R r) {
         return new F();
       }
@@ -282,10 +308,11 @@
 
   @Test public void providerMethodsConflict() {
     try {
-      new Injector().inject(G.class, new Object() {
+      new GInjector().inject(new Object() {
         @Provides A provideA1() {
           throw new AssertionError();
         }
+
         @Provides A provideA2() {
           throw new AssertionError();
         }
@@ -296,7 +323,7 @@
   }
 
   @Test public void singletonsInjectedOnlyIntoProviders() {
-    H h = new Injector().inject(H.class, new Object() {
+    AProviderInjector h = new AProviderInjector().inject(new Object() {
       @Provides @Singleton A provideA() {
         return new A();
       }
@@ -305,23 +332,37 @@
   }
 
   @Test public void moduleOverrides() {
-    Object base = new Object() {
-      @Provides F provideF() {
-        throw new AssertionError();
-      }
-      @Provides E provideE(F f) {
-        return new E(f);
-      }
-    };
-
     Object overrides = new Object() {
       @Provides F provideF() {
         return new F();
       }
     };
 
-    E e = new Injector().inject(E.class, Modules.override(base, overrides));
+    EProviderInjector injector = new EProviderInjector().inject(overrides);
+    E e = injector.eProvider.get();
     assertThat(e).isNotNull();
     assertThat(e.f).isNotNull();
   }
+
+  @Injector(modules = { BaseModule.class })
+  public static class EProviderInjector extends AbstractInjector<EProviderInjector> {
+    @Inject Provider<E> eProvider;
+  }
+
+  static class BaseModule {
+    @Provides F provideF() {
+      throw new AssertionError();
+    }
+    @Provides E provideE(F f) {
+      return new E(f);
+    }
+  }
+
+  public static abstract class AbstractInjector<T> {
+    @SuppressWarnings("unchecked")
+    public T inject(Object... modules) {
+      DependencyGraph.get(this, modules).inject(this);
+      return (T) this;
+    }
+  }
 }
/Fim/
diff --git a/src/main/java/com/squareup/codegen/CodeGen.java b/src/main/java/com/squareup/codegen/CodeGen.java
index 4df4354..7c09347 100644
--- a/src/main/java/com/squareup/codegen/CodeGen.java
+++ b/src/main/java/com/squareup/codegen/CodeGen.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.codegen;
 
+import com.squareup.injector.internal.Keys;
 import java.util.List;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
@@ -48,14 +49,7 @@
    */
   public static TypeMirror getApplicationSupertype(TypeElement type) {
     TypeMirror supertype = type.getSuperclass();
-    String supertypeName = supertype.toString();
-    if (supertypeName.startsWith("android.")
-        || supertypeName.startsWith("java.")
-        || supertypeName.startsWith("javax.")) {
-      return null;
-    } else {
-      return supertype;
-    }
+    return Keys.isPlatformType(supertype.toString()) ? null : supertype;
   }
 
   /** Returns a fully qualified class name to complement {@code type}. */
@@ -88,6 +82,17 @@
     return result.toString();
   }
 
+  /** Returns a string for the raw type of {@code type}. Primitive types are always boxed. */
+  public static String rawTypeToString(TypeMirror type, char innerClassSeparator) {
+    if (!(type instanceof DeclaredType)) {
+      throw new IllegalArgumentException("Unexpected type: " + type);
+    }
+    StringBuilder result = new StringBuilder();
+    DeclaredType declaredType = (DeclaredType) type;
+    rawTypeToString(result, (TypeElement) declaredType.asElement(), innerClassSeparator);
+    return result.toString();
+  }
+
   /**
    * Appends a string for {@code type} to {@code result}. Primitive types are
    * always boxed.
@@ -134,7 +139,7 @@
     }, null);
   }
 
-  private static void rawTypeToString(StringBuilder result, TypeElement type,
+  static void rawTypeToString(StringBuilder result, TypeElement type,
       char innerClassSeparator) {
     String packageName = getPackage(type).getQualifiedName().toString();
     String qualifiedName = type.getQualifiedName().toString();
/Fim/
diff --git a/src/main/java/com/squareup/codegen/GeneratorKeys.java b/src/main/java/com/squareup/codegen/GeneratorKeys.java
index 6f98c06..3293299 100644
--- a/src/main/java/com/squareup/codegen/GeneratorKeys.java
+++ b/src/main/java/com/squareup/codegen/GeneratorKeys.java
@@ -33,21 +33,23 @@
   private GeneratorKeys() {
   }
 
-  public static String get(TypeElement type) {
-    return get(type.asType());
+  /**
+   * Returns the members injector key for the raw type of {@code type}.
+   * Parameterized types are not currently supported for members injection in
+   * generated code.
+   */
+  public static String rawMembersKey(TypeMirror type) {
+    return "members/" + CodeGen.rawTypeToString(type, '$');
   }
 
-
-  public static String getMembersKey(TypeMirror type) {
-    return "members/" + get(type);
-  }
-
+  /** Returns the provider key for {@code type}. */
   public static String get(TypeMirror type) {
     StringBuilder result = new StringBuilder();
     CodeGen.typeToString(type, result, '$');
     return result.toString();
   }
 
+  /** Returns the provided key for {@code method}. */
   public static String get(ExecutableElement method) {
     StringBuilder result = new StringBuilder();
     AnnotationMirror qualifier = getQualifier(method.getAnnotationMirrors(), method);
@@ -58,6 +60,7 @@
     return result.toString();
   }
 
+  /** Returns the provider key for {@code parameter}. */
   public static String get(VariableElement parameter) {
     StringBuilder result = new StringBuilder();
     AnnotationMirror qualifier = getQualifier(parameter.getAnnotationMirrors(), parameter);
/Fim/
diff --git a/src/main/java/com/squareup/codegen/InjectProcessor.java b/src/main/java/com/squareup/codegen/InjectProcessor.java
index c9e2927..67df620 100644
--- a/src/main/java/com/squareup/codegen/InjectProcessor.java
+++ b/src/main/java/com/squareup/codegen/InjectProcessor.java
@@ -172,15 +172,15 @@
           fieldName(f), PRIVATE);
     }
     if (supertype != null) {
-      writer.field(CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(supertype)),
-          "supertype", PRIVATE);
+      writer.field(CodeGen.parameterizedType(Binding.class,
+          CodeGen.rawTypeToString(supertype, '.')), "supertype", PRIVATE);
     }
 
     writer.beginMethod(null, adapterName, PUBLIC);
     String key = (constructor != null)
-        ? JavaWriter.stringLiteral(GeneratorKeys.get(type))
+        ? JavaWriter.stringLiteral(GeneratorKeys.get(type.asType()))
         : null;
-    String membersKey = JavaWriter.stringLiteral(GeneratorKeys.getMembersKey(type.asType()));
+    String membersKey = JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(type.asType()));
     boolean singleton = type.getAnnotation(Singleton.class) != null;
     writer.statement("super(%s, %s, %s /*singleton*/, %s.class)",
         key, membersKey, singleton, typeName);
@@ -209,8 +209,8 @@
     if (supertype != null) {
       writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
           "supertype",
-          CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(supertype)),
-          JavaWriter.stringLiteral(GeneratorKeys.getMembersKey(supertype)),
+          CodeGen.parameterizedType(Binding.class, CodeGen.rawTypeToString(supertype, '.')),
+          JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(supertype)),
           typeName);
     }
     writer.endMethod();
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/AtInjectBinding.java b/src/main/java/com/squareup/injector/internal/AtInjectBinding.java
index 7300fda..996a921 100644
--- a/src/main/java/com/squareup/injector/internal/AtInjectBinding.java
+++ b/src/main/java/com/squareup/injector/internal/AtInjectBinding.java
@@ -32,19 +32,21 @@
 final class AtInjectBinding<T> extends Binding<T> {
   private final Constructor<T> constructor;
   private final Field[] fields;
+  private final Class<?> supertype;
   private Binding<?>[] parameters;
   private Binding<?>[] fieldBindings;
-  // TODO: delegate to supertype members injector (which may be generated)
+  private Binding<? super T> supertypeBinding;
 
   /**
    * @param constructor the injectable constructor, or null if this binding
    *     supports members injection only.
    */
   private AtInjectBinding(String key, String membersKey, boolean singleton, Class<?> type,
-      Constructor<T> constructor, Field[] fields) {
+      Constructor<T> constructor, Field[] fields, Class<?> supertype) {
     super(key, membersKey, singleton, type);
     this.constructor = constructor;
     this.fields = fields;
+    this.supertype = supertype;
   }
 
   @Override public void attach(Linker linker) {
@@ -66,6 +68,12 @@
         parameters[i] = linker.requestBinding(key, constructor);
       }
     }
+
+    // Supertype binding.
+    if (supertype != null && !Keys.isPlatformType(supertype.getName())) {
+      supertypeBinding = (Binding<? super T>) linker.requestBinding(
+          Keys.getMembersKey(supertype), membersKey);
+    }
   }
 
   @Override public T get() {
@@ -95,6 +103,9 @@
       for (int i = 0; i < fields.length; i++) {
         fields[i].set(t, fieldBindings[i].get());
       }
+      if (supertypeBinding != null) {
+        supertypeBinding.injectMembers(t);
+      }
     } catch (IllegalAccessException e) {
       throw new AssertionError(e);
     }
@@ -176,6 +187,6 @@
 
     String membersKey = Keys.getMembersKey(type);
     return new AtInjectBinding<T>(key, membersKey, singleton, type, injectedConstructor,
-        injectedFields.toArray(new Field[injectedFields.size()]));
+        injectedFields.toArray(new Field[injectedFields.size()]), type.getSuperclass());
   }
 }
/Fim/
diff --git a/src/main/java/com/squareup/injector/internal/Keys.java b/src/main/java/com/squareup/injector/internal/Keys.java
index 8e355ec..10d6cf6 100644
--- a/src/main/java/com/squareup/injector/internal/Keys.java
+++ b/src/main/java/com/squareup/injector/internal/Keys.java
@@ -199,6 +199,11 @@
         : null;
   }
 
+  /** Returns true if {@code name} is the name of a platform-provided class. */
+  public static boolean isPlatformType(String name) {
+    return name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.");
+  }
+
   private static Type boxIfPrimitive(Type type) {
     if (type == byte.class) return Byte.class;
     if (type == short.class) return Short.class;
/Fim/
diff --git a/src/test/java/com/squareup/injector/InjectionTest.java b/src/test/java/com/squareup/injector/InjectionTest.java
index 1e1ddf1..46485c1 100644
--- a/src/test/java/com/squareup/injector/InjectionTest.java
+++ b/src/test/java/com/squareup/injector/InjectionTest.java
@@ -398,7 +398,7 @@
     }
   }
 
-  @Test public void noJitBindingsForAbstractClasses() {
+  @Test public void noProvideBindingsForAbstractClasses() {
     class TestEntryPoint {
       @Inject AbstractList abstractList;
     }
@@ -417,6 +417,37 @@
     }
   }
 
+  static class ExtendsParameterizedType extends AbstractList<Integer> {
+    @Inject String string;
+    @Override public Integer get(int i) {
+      return i;
+    }
+    @Override public int size() {
+      return 5;
+    }
+  }
+
+  /**
+   * We've had bugs where we look for the wrong keys when a class extends a
+   * parameterized class. Explicitly test that we can inject such classes.
+   */
+  @Test public void extendsParameterizedType() {
+    class TestEntryPoint {
+      @Inject ExtendsParameterizedType extendsParameterizedType;
+    }
+
+    @Module(entryPoints = TestEntryPoint.class)
+    class TestModule {
+      @Provides String provideString() {
+        return "injected";
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    assertThat(entryPoint.extendsParameterizedType.string).isEqualTo("injected");
+  }
+
   // TODO: test injecting parameterized types
   // TODO: test injecting wildcard types
   // TODO: test constructor binding for a class that has a type parameter
/Fim/
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..133735f
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,22 @@
+.classpath
+.project
+.settings
+eclipsebin
+
+bin
+gen
+build
+out
+lib
+
+target
+pom.xml.*
+release.properties
+
+.idea
+*.iml
+classes
+
+obj
+
+.DS_Store
/Fim/
diff --git a/src/main/java/com/squareup/codegen/ProvidesProcessor.java b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
index 641c223..b930323 100644
--- a/src/main/java/com/squareup/codegen/ProvidesProcessor.java
+++ b/src/main/java/com/squareup/codegen/ProvidesProcessor.java
@@ -91,14 +91,12 @@
       TypeElement type = (TypeElement) providerMethod.getEnclosingElement();
       Set<Modifier> typeModifiers = type.getModifiers();
       if (type.getKind() != ElementKind.CLASS) {
-        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
-            "Unexpected @Provides on " + providerMethod);
+        error("Unexpected @Provides on " + providerMethod);
         continue;
       }
       if (typeModifiers.contains(Modifier.PRIVATE)
           || typeModifiers.contains(Modifier.ABSTRACT)) {
-        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
-            "Classes declaring @Provides methods must not be private or abstract: "
+        error("Classes declaring @Provides methods must not be private or abstract: "
                 + type.getQualifiedName());
       }
 
@@ -106,8 +104,7 @@
       if (methodModifiers.contains(Modifier.PRIVATE)
           || methodModifiers.contains(Modifier.ABSTRACT)
           || methodModifiers.contains(Modifier.STATIC)) {
-        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
-            "@Provides methods must not be private, abstract or static: "
+        error("@Provides methods must not be private, abstract or static: "
                 + type.getQualifiedName() + "." + providerMethod);
         continue;
       }
/Fim/
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/README.md
/Fim/
diff --git a/README.md b/README.md
index 683b64e..9e7ed32 100644
--- a/README.md
+++ b/README.md
@@ -162,38 +162,46 @@
 }
 ```
 
-### Providers
+### Lazy injections
 
-Not to be confused with `@Provides`, a `Provider` is a special dependency that can be used to retrieve any number of instances. Use a `Provider` to make a dependency lazy:
+Sometimes you need to make a dependency lazily created.  For any binding `T`, you can create a `Lazy<T>` which defers instantiation until the first call to `Lazy<T>`'s `get()` method. If `T` is a singleton, then `Lazy<T>` will be the same instance for all injections within the ObjectGraph.  Otherwise, each injection site will get its own `Lazy<T>` instance.  Regardless, subsequent calls to any given instance of `Lazy<T>` will return the same underlying instance of `T`.
 
 ```java
 class GridingCoffeeMaker {
-  @Inject Provider<Grinder> grinderProvider;
+  @Inject Lazy<Grinder> lazyGrinder;
 
   public void brew() {
-    if (needsGrinding()) {
-      Grinder grinder = grinderProvider.get();
-      ...
+    while (needsGrinding()) {
+      // Grinder created once on first call to .get() and cached.
+      lazyGrinder.get().grind();
     }
   }
 }
 ```
 
-Or when multiple values are required:
+### Provider injections
+
+Sometimes you need multiple instances to be returned instead of just injecting a single value.  While you have several options (Factories, Builders, etc.)   one option is to inject a `Provider<T>` instead of just `T`.  A `Provider<T>` creates a new instance of `T` each time `.get()` is called.
 
 ```java
+
 class BigCoffeeMaker {
   @Inject Provider<Filter> filterProvider;
 
   public void brew(int numberOfPots) {
+	...
     for (int p = 0; p < numberOfPots; p++) {
-      Filter coffeeFilter = filterProvider.get();
+      maker.addFilter(filterProvider.get()); //new filter every time.
+      maker.addCoffee(...);
+      maker.percolate();
       ...
     }
   }
 }
 ```
 
+***Note:*** *Injecting `Provider<T>` has the possibility of creating confusing code, and may be a design smell of mis-scoped or mis-structured objects in your graph.  Often you will want to use a `Factory<T>` or a `Lazy<T>` or re-organize the lifetimes and structure of your code to be able to just inject a `T`.  Injecting `Provider<T>` can, however, be a life saver in some cases.  A common use is when you must use a legacy architecture that doesn't line up with your object's natural lifetimes (e.g. servlets are singletons by design, but only are valid in the context of request-specfic data).*
+
 ### Qualifiers
 
 Sometimes the type alone is insufficient to identify a dependency. For example, a sophisticated coffee maker app may want separate heaters for the water and the hot plate.
/Fim/
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index b66155c..c7464c9 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -151,12 +151,7 @@
     private <T> void handleSetBindings(Map<String, Binding<?>> bindings, Method method, String key) {
       String elementKey =
           Keys.getElementKey(method.getGenericReturnType(), method.getAnnotations(), method);
-      SetBinding<T> elementBinding = (SetBinding<T>) bindings.get(elementKey);
-      if (elementBinding == null) {
-        elementBinding = new SetBinding<T>(elementKey);
-        bindings.put(elementBinding.provideKey, elementBinding);
-      }
-      elementBinding.add(Linker.scope(new ProviderMethodBinding<T>(method, key, module)));
+      SetBinding.<T>add(bindings, elementKey, new ProviderMethodBinding<T>(method, key, module));
     }
 
     @Override protected Object newModule() {
/Fim/
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index 9f596c6..84181b9 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -18,6 +18,7 @@
 
 import java.util.Collections;
 import java.util.LinkedHashSet;
+import java.util.Map;
 import java.util.Set;
 
 /**
@@ -25,7 +26,17 @@
  * {@code @Provides} {@code @Element}), to which it delegates provision
  * requests on an as-needed basis.
  */
-final class SetBinding<T> extends Binding<Set<T>> {
+public final class SetBinding<T> extends Binding<Set<T>> {
+
+  public static <T> void add(Map<String, Binding<?>> bindings, String elementKey, Binding<?> binding) {
+    SetBinding<T> elementBinding = (SetBinding<T>) bindings.get(elementKey);
+    if (elementBinding == null) {
+      elementBinding = new SetBinding<T>(elementKey);
+      bindings.put(elementBinding.provideKey, elementBinding);
+    }
+    elementBinding.contributors.add(Linker.scope(binding));
+  }
+
   private final Set<Binding<?>> contributors = new LinkedHashSet<Binding<?>>();
 
   public SetBinding(String key) {
@@ -49,8 +60,4 @@
   @Override public String toString() {
     return "SetBinding" + contributors;
   }
-
-  public void add(Binding<?> binding) {
-    contributors.add(binding);
-  }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/GeneratorKeys.java b/core/src/main/java/dagger/internal/codegen/GeneratorKeys.java
index 17e2e47..ced0a48 100644
--- a/core/src/main/java/dagger/internal/codegen/GeneratorKeys.java
+++ b/core/src/main/java/dagger/internal/codegen/GeneratorKeys.java
@@ -17,6 +17,8 @@
 
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
+
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
@@ -29,6 +31,8 @@
  * APIs not available on Android.
  */
 final class GeneratorKeys {
+  private static final String SET_PREFIX = Set.class.getName() + "<";
+
   private GeneratorKeys() {
   }
 
@@ -59,6 +63,19 @@
     return result.toString();
   }
 
+  /** Returns the provided key for {@code method} wrapped by {@code Set}. */
+  public static String getElementKey(ExecutableElement method) {
+    StringBuilder result = new StringBuilder();
+    AnnotationMirror qualifier = getQualifier(method.getAnnotationMirrors(), method);
+    if (qualifier != null) {
+      qualifierToString(qualifier, result);
+    }
+    result.append(SET_PREFIX);
+    CodeGen.typeToString(method.getReturnType(), result, '$');
+    result.append(">");
+    return result.toString();
+  }
+
   /** Returns the provider key for {@code variable}. */
   public static String get(VariableElement variable) {
     StringBuilder result = new StringBuilder();
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index f908a7f..78d88f6 100644
--- a/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -20,6 +20,7 @@
 import dagger.internal.Binding;
 import dagger.internal.Linker;
 import dagger.internal.ModuleAdapter;
+import dagger.internal.SetBinding;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -106,12 +107,6 @@
         continue;
       }
 
-      if (providerMethod.getAnnotation(dagger.Element.class) != null) {
-        error("@Element binding not supported with code generation: "
-            + type.getQualifiedName() + "." + providerMethod);
-        continue;
-      }
-
       List<ExecutableElement> methods = result.get(type);
       if (methods == null) {
         methods = new ArrayList<ExecutableElement>();
@@ -158,6 +153,7 @@
 
     writer.addPackage(CodeGen.getPackage(type).getQualifiedName().toString());
     writer.addImport(Binding.class);
+    writer.addImport(SetBinding.class);
     writer.addImport(ModuleAdapter.class);
     writer.addImport(Map.class);
     writer.addImport(Linker.class);
@@ -206,9 +202,15 @@
     writer.annotation(Override.class);
     writer.beginMethod("void", "getBindings", PUBLIC, BINDINGS_MAP, "map");
     for (ExecutableElement providerMethod : providerMethods) {
-      String key = GeneratorKeys.get(providerMethod);
-      writer.statement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
-          providerMethod.getSimpleName().toString() + "Binding");
+      if (providerMethod.getAnnotation(dagger.Element.class) != null) {
+        String key = GeneratorKeys.getElementKey(providerMethod);
+        writer.statement("SetBinding.add(map, %s, new %s(module))", JavaWriter.stringLiteral(key),
+            providerMethod.getSimpleName().toString() + "Binding");
+      } else {
+        String key = GeneratorKeys.get(providerMethod);
+        writer.statement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
+            providerMethod.getSimpleName().toString() + "Binding");
+      }
     }
     writer.endMethod();
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 1fe6c45..7356c66 100644
--- a/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -19,6 +19,7 @@
 import dagger.Provides;
 import dagger.internal.Binding;
 import dagger.internal.Linker;
+import dagger.internal.SetBinding;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
@@ -61,13 +62,12 @@
     collectIncludesRecursively(rootModule, allModules);
 
     Linker linker = new BuildTimeLinker(processingEnv, rootModule.getQualifiedName().toString());
-    Map<String, ProviderMethodBinding> baseBindings
-        = new LinkedHashMap<String, ProviderMethodBinding>();
-    Map<String, ProviderMethodBinding> overrideBindings
-        = new LinkedHashMap<String, ProviderMethodBinding>();
+    Map<String, Binding<?>> baseBindings = new LinkedHashMap<String, Binding<?>>();
+    Map<String, Binding<?>> overrideBindings = new LinkedHashMap<String, Binding<?>>();
     for (TypeElement module : allModules.values()) {
       Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
       boolean overrides = (Boolean) annotation.get("overrides");
+      Map<String, Binding<?>> addTo = overrides ? overrideBindings : baseBindings;
 
       // Gather the entry points from the annotation.
       for (Object entryPoint : (Object[]) annotation.get("entryPoints")) {
@@ -86,13 +86,17 @@
         ExecutableElement providerMethod = (ExecutableElement) enclosed;
         String key = GeneratorKeys.get(providerMethod);
         ProviderMethodBinding binding = new ProviderMethodBinding(key, providerMethod);
-        Map<String, ProviderMethodBinding> addTo = overrides ? overrideBindings : baseBindings;
-        ProviderMethodBinding clobbered = addTo.put(key, binding);
-        if (clobbered != null) {
-          processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
-              "Duplicate bindings for " + key
-                  + ": " + shortMethodName(clobbered.method)
-                  + ", " + shortMethodName(binding.method));
+        if (providerMethod.getAnnotation(dagger.Element.class) != null) {
+          String elementKey = GeneratorKeys.getElementKey(providerMethod);
+          SetBinding.add(addTo, elementKey, binding);
+        } else {
+          ProviderMethodBinding clobbered = (ProviderMethodBinding) addTo.put(key, binding);
+          if (clobbered != null) {
+            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
+                "Duplicate bindings for " + key
+                    + ": " + shortMethodName(clobbered.method)
+                    + ", " + shortMethodName(binding.method));
+          }
         }
       }
     }
/Fim/
diff --git a/androidmanifest/README.md b/androidmanifest/README.md
new file mode 100644
index 0000000..c6ff27e
--- /dev/null
+++ b/androidmanifest/README.md
@@ -0,0 +1,54 @@
+AndroidManifest Plugin
+======================
+
+This plugin parses an `AndroidManifest.xml` file for entry points. It has
+designed to be used both in a standalone manner (such as with Ant) and as a
+Maven plugin.
+
+
+Maven Usage
+-----------
+
+```xml
+<plugin>
+  <groupId>com.squareup</groupId>
+  <artifactId>dagger-androidmanifest-plugin</artifactId>
+  <version>(latest version)</version>
+  <executions>
+    <execution>
+      <phase>generate-sources</phase>
+      <goals>
+        <goal>generate</goals>
+      </goals>
+    </execution>
+  </executions>
+</plugin>
+```
+
+Optional configuration:
+
+ * `androidManifest` - Path to the `AndroidManifest.xml` file.
+ * `moduleName` - Class name
+ * `outputDirectory` - Generated source directory, automatically added to build path.
+
+
+
+Ant Usage
+---------
+
+```xml
+<macrodef name="generate-dagger-module">
+  <attribute name="dir"/>
+  <attribute name="name"/>
+
+  <sequential>
+    <mkdir dir="@{dir}/src"/>
+    <java classname="dagger.androidmanifest.ModuleGenerator"
+          classpath="${com.squareup:dagger:jar}:${com.squareup:dagger-androidmanifest-plugin:jar}">
+      <arg value="@{dir}/AndroidManifest.xml"/>
+      <arg value="@{name}"/>
+      <arg value="@{dir}/gen"/>
+    </java>
+  </sequential>
+</macrodef>
+```
/Fim/
diff --git a/androidmanifest/pom.xml b/androidmanifest/pom.xml
index b8797c0..dcdbc80 100644
--- a/androidmanifest/pom.xml
+++ b/androidmanifest/pom.xml
@@ -25,7 +25,7 @@
         <version>1.0-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
-    <artifactId>dagger-androidmanifest</artifactId>
+    <artifactId>dagger-androidmanifest-plugin</artifactId>
     <packaging>jar</packaging>
     <name>Dagger AndroidManifest.xml Module Generator</name>
 
@@ -35,5 +35,24 @@
             <artifactId>dagger</artifactId>
             <version>${project.version}</version>
         </dependency>
+        <dependency>
+            <groupId>org.apache.maven</groupId>
+            <artifactId>maven-core</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.maven</groupId>
+            <artifactId>maven-plugin-api</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.easytesting</groupId>
+            <artifactId>fest-assert</artifactId>
+            <scope>test</scope>
+        </dependency>
     </dependencies>
 </project>
/Fim/
diff --git a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorMojo.java b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorMojo.java
new file mode 100644
index 0000000..d4b35ed
--- /dev/null
+++ b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorMojo.java
@@ -0,0 +1,69 @@
+// Copyright 2012 Square, Inc.
+package dagger.androidmanifest;
+
+import org.apache.maven.plugin.AbstractMojo;
+import org.apache.maven.plugin.MojoExecutionException;
+import org.apache.maven.project.MavenProject;
+import org.xml.sax.SAXException;
+
+import javax.xml.parsers.ParserConfigurationException;
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * Goal which generates an ActivitiesModule for the specified {@code AndroidManifest.xml}.
+ *
+ * @goal generate
+ * @phase generate-sources
+ */
+@SuppressWarnings({ "JavaDoc", "UnusedDeclaration" }) // Class and non-standard Javadoc used by Maven.
+public class ModuleGeneratorMojo extends AbstractMojo {
+
+  /**
+   * The {@code AndroidManifest.xml} file.
+   *
+   * @parameter default-value="${project.basedir}/AndroidManifest.xml"
+   * @required
+   */
+  private File androidManifest;
+
+  /**
+   * The {@code AndroidManifest.xml} file.
+   *
+   * @parameter default-value="ActivitiesModule"
+   * @required
+   */
+  private String moduleName;
+
+  /**
+   * Location of the file.
+   *
+   * @parameter expression="${project.build.directory}/generated-sources/dagger"
+   * @required
+   */
+  private File outputDirectory;
+
+  /**
+   * Maven project.
+   *
+   * @parameter expression="${project}"
+   * @required
+   * @readonly
+   */
+  private MavenProject project;
+
+  public void execute() throws MojoExecutionException {
+    try {
+      // Attempt to generate the module from the specified manifest.
+      ModuleGenerator.generate(androidManifest, moduleName, outputDirectory);
+      // Add the generated source file to the compile path.
+      project.addCompileSourceRoot(outputDirectory.getAbsolutePath());
+    } catch (IOException e) {
+      throw new MojoExecutionException("Unable to generate module.", e);
+    } catch (SAXException e) {
+      throw new MojoExecutionException("Unable to generate module.", e);
+    } catch (ParserConfigurationException e) {
+      throw new MojoExecutionException("Unable to generate module.", e);
+    }
+  }
+}
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index ae19bd1..ed91ed8 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -29,6 +29,24 @@
     <packaging>jar</packaging>
     <name>Dagger</name>
 
+    <dependencies>
+        <dependency>
+            <groupId>javax.inject</groupId>
+            <artifactId>javax.inject</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.easytesting</groupId>
+            <artifactId>fest-assert</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+
     <build>
         <plugins>
             <plugin>
/Fim/
diff --git a/pom.xml b/pom.xml
index 81b6dff..43074fe 100644
--- a/pom.xml
+++ b/pom.xml
@@ -45,11 +45,12 @@
 
         <!-- Compilation -->
         <java.version>1.6</java.version>
+        <javax.inject.version>1</javax.inject.version>
+        <maven.version>2.0.6</maven.version>
 
         <!-- Test Dependencies -->
         <junit.version>4.10</junit.version>
         <fest.version>1.4</fest.version>
-        <javax.inject.version>1</javax.inject.version>
     </properties>
 
     <scm>
@@ -75,25 +76,35 @@
         <url>http://squareup.com</url>
     </organization>
 
-    <dependencies>
-        <dependency>
-            <groupId>javax.inject</groupId>
-            <artifactId>javax.inject</artifactId>
-            <version>${javax.inject.version}</version>
-        </dependency>
-        <dependency>
-            <groupId>junit</groupId>
-            <artifactId>junit</artifactId>
-            <version>${junit.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>org.easytesting</groupId>
-            <artifactId>fest-assert</artifactId>
-            <version>${fest.version}</version>
-            <scope>test</scope>
-        </dependency>
-    </dependencies>
+    <dependencyManagement>
+        <dependencies>
+            <dependency>
+                <groupId>javax.inject</groupId>
+                <artifactId>javax.inject</artifactId>
+                <version>${javax.inject.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.apache.maven</groupId>
+                <artifactId>maven-plugin-api</artifactId>
+                <version>${maven.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.apache.maven</groupId>
+                <artifactId>maven-core</artifactId>
+                <version>${maven.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>junit</groupId>
+                <artifactId>junit</artifactId>
+                <version>${junit.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>org.easytesting</groupId>
+                <artifactId>fest-assert</artifactId>
+                <version>${fest.version}</version>
+            </dependency>
+        </dependencies>
+    </dependencyManagement>
 
     <build>
         <finalName>square-${project.artifactId}-${project.version}</finalName>
/Fim/
diff --git a/core/src/main/java/dagger/Element.java b/core/src/main/java/dagger/OneOf.java
similarity index 97%
rename from core/src/main/java/dagger/Element.java
rename to core/src/main/java/dagger/OneOf.java
index 52ab02a..279e4c2 100644
--- a/core/src/main/java/dagger/Element.java
+++ b/core/src/main/java/dagger/OneOf.java
@@ -34,6 +34,6 @@
  * @author Christian Gruber
  */
 @Documented @Target(METHOD) @Retention(RUNTIME)
-public @interface Element {
+public @interface OneOf {
 
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index b5e7d5c..3597fa2 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -17,7 +17,7 @@
 package dagger.internal;
 
 
-import dagger.Element;
+import dagger.OneOf;
 import dagger.Module;
 import dagger.ObjectGraph;
 import dagger.Provides;
@@ -119,7 +119,7 @@
         for (Method method : c.getDeclaredMethods()) {
           if (method.isAnnotationPresent(Provides.class)) {
             String key = Keys.get(method.getGenericReturnType(), method.getAnnotations(), method);
-            if (method.isAnnotationPresent(Element.class)) {
+            if (method.isAnnotationPresent(OneOf.class)) {
               handleSetBindings(bindings, method, key);
             } else {
               handleBindings(bindings, method, key);
/Fim/
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index 84181b9..86eb25f 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -23,7 +23,7 @@
 
 /**
  * A {@code Binding<T>} which contains contributors (other bindings marked with
- * {@code @Provides} {@code @Element}), to which it delegates provision
+ * {@code @Provides} {@code @OneOf}), to which it delegates provision
  * requests on an as-needed basis.
  */
 public final class SetBinding<T> extends Binding<Set<T>> {
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 3e2ff28..fdeda8b 100644
--- a/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import dagger.Module;
+import dagger.OneOf;
 import dagger.Provides;
 import dagger.internal.Binding;
 import dagger.internal.Linker;
@@ -86,7 +87,7 @@
         ExecutableElement providerMethod = (ExecutableElement) enclosed;
         String key = GeneratorKeys.get(providerMethod);
         ProviderMethodBinding binding = new ProviderMethodBinding(key, providerMethod);
-        if (providerMethod.getAnnotation(dagger.Element.class) != null) {
+        if (providerMethod.getAnnotation(OneOf.class) != null) {
           String elementKey = GeneratorKeys.getElementKey(providerMethod);
           SetBinding.add(addTo, elementKey, binding);
         } else {
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 894aa30..ca61ac1 100644
--- a/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import dagger.Module;
+import dagger.OneOf;
 import dagger.Provides;
 import dagger.internal.Binding;
 import dagger.internal.Linker;
@@ -199,7 +200,7 @@
     writer.annotation(Override.class);
     writer.beginMethod("void", "getBindings", PUBLIC, BINDINGS_MAP, "map");
     for (ExecutableElement providerMethod : providerMethods) {
-      if (providerMethod.getAnnotation(dagger.Element.class) != null) {
+      if (providerMethod.getAnnotation(OneOf.class) != null) {
         String key = GeneratorKeys.getElementKey(providerMethod);
         writer.statement("SetBinding.add(map, %s, new %s(module))", JavaWriter.stringLiteral(key),
             providerMethod.getSimpleName().toString() + "Binding");
/Fim/
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index b05496e..4d07c82 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -41,8 +41,8 @@
 
     @Module(entryPoints = TestEntryPoint.class)
     class TestModule {
-      @Provides @Element String provideFirstString() { return "string1"; }
-      @Provides @Element String provideSecondString() { return "string2"; }
+      @Provides @OneOf String provideFirstString() { return "string1"; }
+      @Provides @OneOf String provideSecondString() { return "string2"; }
     }
 
     TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
@@ -56,12 +56,12 @@
 
     @Module
     class TestIncludesModule {
-      @Provides @Element String provideSecondString() { return "string2"; }
+      @Provides @OneOf String provideSecondString() { return "string2"; }
     }
 
     @Module(entryPoints = TestEntryPoint.class, includes = TestIncludesModule.class)
     class TestModule {
-      @Provides @Element String provideFirstString() { return "string1"; }
+      @Provides @OneOf String provideFirstString() { return "string1"; }
     }
 
     TestEntryPoint ep = injectWithModule(new TestEntryPoint(),
@@ -79,8 +79,8 @@
 
     @Module(entryPoints = TestEntryPoint.class)
     class TestModule {
-      @Provides @Element @Singleton Integer a() { return singletonCounter.getAndIncrement(); }
-      @Provides @Element Integer b() { return defaultCounter.getAndIncrement(); }
+      @Provides @OneOf @Singleton Integer a() { return singletonCounter.getAndIncrement(); }
+      @Provides @OneOf Integer b() { return defaultCounter.getAndIncrement(); }
     }
 
     TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
@@ -100,8 +100,8 @@
 
     @Module(entryPoints = { TestEntryPoint1.class, TestEntryPoint2.class })
     class TestModule {
-      @Provides @Element @Singleton Integer a() { return singletonCounter.getAndIncrement(); }
-      @Provides @Element Integer b() { return defaultCounter.getAndIncrement(); }
+      @Provides @OneOf @Singleton Integer a() { return singletonCounter.getAndIncrement(); }
+      @Provides @OneOf Integer b() { return defaultCounter.getAndIncrement(); }
     }
 
     ObjectGraph graph = ObjectGraph.get(new TestModule());
@@ -122,10 +122,10 @@
 
     @Module(entryPoints = TestEntryPoint.class)
     class TestModule {
-      @Provides @Element String provideString1() { return "string1"; }
-      @Provides @Element String provideString2() { return "string2"; }
-      @Provides @Element @Named("foo") String provideString3() { return "string3"; }
-      @Provides @Element @Named("foo") String provideString4() { return "string4"; }
+      @Provides @OneOf String provideString1() { return "string1"; }
+      @Provides @OneOf String provideString2() { return "string2"; }
+      @Provides @OneOf @Named("foo") String provideString3() { return "string3"; }
+      @Provides @OneOf @Named("foo") String provideString4() { return "string4"; }
     }
 
     TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
@@ -146,7 +146,7 @@
     final AtomicReference<String> logoutput = new AtomicReference<String>();
     @Module
     class LogModule {
-      @Provides @Element LogSink outputtingLogSink() {
+      @Provides @OneOf LogSink outputtingLogSink() {
         return new LogSink() {
           @Override public void log(LogMessage message) {
             StringWriter sw = new StringWriter();
@@ -158,7 +158,7 @@
     }
     @Module(entryPoints = TestEntryPoint.class)
     class TestModule {
-      @Provides @Element LogSink nullLogger() {
+      @Provides @OneOf LogSink nullLogger() {
         return new LogSink() { @Override public void log(LogMessage message) {} };
       }
     }
/Fim/
diff --git a/core/src/test/java/dagger/internal/KeysTest.java b/core/src/test/java/dagger/internal/KeysTest.java
index 3c42506..b1de562 100644
--- a/core/src/test/java/dagger/internal/KeysTest.java
+++ b/core/src/test/java/dagger/internal/KeysTest.java
@@ -15,7 +15,7 @@
  */
 package dagger.internal;
 
-import dagger.Element;
+import dagger.OneOf;
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.Provides;
@@ -128,7 +128,7 @@
     assertThat(Keys.getLazyKey(fieldKey("providerOfTypeAnnotated"))).isNull();
   }
 
-  @Provides @Element String elementProvides() { return "foo"; }
+  @Provides @OneOf String elementProvides() { return "foo"; }
 
   @Test public void testGetElementKey_NoQualifier() throws NoSuchMethodException {
     Method method = KeysTest.class.getDeclaredMethod("elementProvides", new Class<?>[]{});
@@ -137,7 +137,7 @@
   }
 
   @Named("foo")
-  @Provides @Element String qualifiedElementProvides() { return "foo"; }
+  @Provides @OneOf String qualifiedElementProvides() { return "foo"; }
 
   @Test public void testGetElementKey_WithQualifier() throws NoSuchMethodException {
     Method method = KeysTest.class.getDeclaredMethod("qualifiedElementProvides", new Class<?>[]{});
/Fim/
diff --git a/core/src/main/java/dagger/internal/StaticInjection.java b/core/src/main/java/dagger/internal/StaticInjection.java
index 19bea23..7f57380 100644
--- a/core/src/main/java/dagger/internal/StaticInjection.java
+++ b/core/src/main/java/dagger/internal/StaticInjection.java
@@ -15,10 +15,14 @@
  */
 package dagger.internal;
 
+import dagger.ObjectGraph;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import javax.inject.Inject;
 
 /**
@@ -26,17 +30,27 @@
  *
  * @author Jesse Wilson
  */
-public final class StaticInjection {
-  private final Field[] fields;
-  private Binding<?>[] bindings;
+public abstract class StaticInjection {
+  private static final Logger LOGGER = Logger.getLogger(ObjectGraph.class.getName());
 
-  private StaticInjection(Field[] fields) {
-    this.fields = fields;
-  }
+  public abstract void attach(Linker linker);
 
-  public static StaticInjection get(Class<?> c) {
+  public abstract void inject();
+
+  public static StaticInjection get(Class<?> injectedClass) {
+    try {
+      String adapter = injectedClass.getName() + "$StaticInjection";
+      Class<?> c = Class.forName(adapter);
+      Constructor<?> constructor = c.getConstructor();
+      constructor.setAccessible(true);
+      return (StaticInjection) constructor.newInstance();
+    } catch (Exception e) {
+      LOGGER.log(Level.FINE, "No generated static injection for " + injectedClass.getName()
+          + ". Falling back to reflection.", e);
+    }
+
     List<Field> fields = new ArrayList<Field>();
-    for (Field field : c.getDeclaredFields()) {
+    for (Field field : injectedClass.getDeclaredFields()) {
       if (field.getAnnotation(Inject.class) == null
           || !Modifier.isStatic(field.getModifiers())) {
         continue;
@@ -45,27 +59,38 @@
       fields.add(field);
     }
     if (fields.isEmpty()) {
-      throw new IllegalArgumentException("No static injections: " + c.getName());
+      throw new IllegalArgumentException("No static injections: " + injectedClass.getName());
     }
-    return new StaticInjection(fields.toArray(new Field[fields.size()]));
+    return new ReflectiveStaticInjection(fields.toArray(new Field[fields.size()]));
   }
 
-  public void attach(Linker linker) {
-    bindings = new Binding<?>[fields.length];
-    for (int i = 0; i < fields.length; i++) {
-      Field field = fields[i];
-      String key = Keys.get(field.getGenericType(), field.getAnnotations(), field);
-      bindings[i] = linker.requestBinding(key, field);
-    }
-  }
+  static class ReflectiveStaticInjection extends StaticInjection {
+    private final Field[] fields;
+    private Binding<?>[] bindings;
 
-  public void inject() {
-    try {
-      for (int f = 0; f < fields.length; f++) {
-        fields[f].set(null, bindings[f].get());
+    private ReflectiveStaticInjection(Field[] fields) {
+      this.fields = fields;
+    }
+
+    @Override
+    public void attach(Linker linker) {
+      bindings = new Binding<?>[fields.length];
+      for (int i = 0; i < fields.length; i++) {
+        Field field = fields[i];
+        String key = Keys.get(field.getGenericType(), field.getAnnotations(), field);
+        bindings[i] = linker.requestBinding(key, field);
       }
-    } catch (IllegalAccessException e) {
-      throw new AssertionError(e);
+    }
+
+    @Override
+    public void inject() {
+      try {
+        for (int f = 0; f < fields.length; f++) {
+          fields[f].set(null, bindings[f].get());
+        }
+      } catch (IllegalAccessException e) {
+        throw new AssertionError(e);
+      }
     }
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/InjectProcessor.java b/core/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 1b6de4d..c4421c6 100644
--- a/core/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/core/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -17,6 +17,7 @@
 
 import dagger.internal.Binding;
 import dagger.internal.Linker;
+import dagger.internal.StaticInjection;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.LinkedHashSet;
@@ -53,7 +54,12 @@
   @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
     try {
       for (InjectedClass injectedClass : getInjectedClasses(env)) {
-        writeInjectAdapter(injectedClass.type, injectedClass.constructor, injectedClass.fields);
+        if (injectedClass.constructor != null || !injectedClass.fields.isEmpty()) {
+          writeInjectAdapter(injectedClass.type, injectedClass.constructor, injectedClass.fields);
+        }
+        if (!injectedClass.staticFields.isEmpty()) {
+          writeStaticInjection(injectedClass.type, injectedClass.staticFields);
+        }
       }
     } catch (IOException e) {
       error("Code gen failed: %s", e);
@@ -82,17 +88,21 @@
    */
   private InjectedClass getInjectedClass(TypeElement type) {
     boolean isAbstract = type.getModifiers().contains(Modifier.ABSTRACT);
+    List<Element> staticFields = new ArrayList<Element>();
     ExecutableElement constructor = null;
     List<Element> fields = new ArrayList<Element>();
     for (Element member : type.getEnclosedElements()) {
-      if (member.getAnnotation(Inject.class) == null
-          || member.getModifiers().contains(Modifier.STATIC)) {
+      if (member.getAnnotation(Inject.class) == null) {
         continue;
       }
 
       switch (member.getKind()) {
         case FIELD:
-          fields.add(member);
+          if (member.getModifiers().contains(Modifier.STATIC)) {
+            staticFields.add(member);
+          } else {
+            fields.add(member);
+          }
           break;
         case CONSTRUCTOR:
           if (constructor != null) {
@@ -113,7 +123,7 @@
       constructor = findNoArgsConstructor(type);
     }
 
-    return new InjectedClass(type, constructor, fields);
+    return new InjectedClass(type, staticFields, constructor, fields);
   }
 
   /**
@@ -270,6 +280,55 @@
     writer.close();
   }
 
+  /**
+   * Write a companion class for {@code type} that extends {@link StaticInjection}.
+   */
+  private void writeStaticInjection(TypeElement type, List<Element> fields) throws IOException {
+    String typeName = type.getQualifiedName().toString();
+    String adapterName = CodeGen.adapterName(type, "$StaticInjection");
+    JavaFileObject sourceFile = processingEnv.getFiler()
+        .createSourceFile(adapterName, type);
+    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
+
+    writer.addPackage(CodeGen.getPackage(type).getQualifiedName().toString());
+    writer.addImport(StaticInjection.class);
+    writer.addImport(Binding.class);
+    writer.addImport(Linker.class);
+
+    writer.beginType(adapterName, "class", PUBLIC | FINAL, StaticInjection.class.getName());
+
+    for (int f = 0; f < fields.size(); f++) {
+      TypeMirror fieldType = fields.get(f).asType();
+      writer.field(CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(fieldType)),
+          fieldName(f), PRIVATE);
+    }
+
+    writer.annotation(Override.class);
+    writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
+    for (int f = 0; f < fields.size(); f++) {
+      TypeMirror fieldType = fields.get(f).asType();
+      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
+          fieldName(f),
+          CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(fieldType)),
+          JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) fields.get(f))),
+          typeName);
+    }
+    writer.endMethod();
+
+    writer.annotation(Override.class);
+    writer.beginMethod("void", "inject", PUBLIC);
+    for (int f = 0; f < fields.size(); f++) {
+      writer.statement("%s.%s = %s.get()",
+          typeName,
+          fields.get(f).getSimpleName().toString(),
+          fieldName(f));
+    }
+    writer.endMethod();
+
+    writer.endType();
+    writer.close();
+  }
+
   private String fieldName(int index) {
     return "f" + index;
   }
@@ -280,11 +339,13 @@
 
   static class InjectedClass {
     final TypeElement type;
+    final List<Element> staticFields;
     final ExecutableElement constructor;
     final List<Element> fields;
 
-    InjectedClass(TypeElement type, ExecutableElement constructor, List<Element> fields) {
+    InjectedClass(TypeElement type, List<Element> staticFields, ExecutableElement constructor, List<Element> fields) {
       this.type = type;
+      this.staticFields = staticFields;
       this.constructor = constructor;
       this.fields = fields;
     }
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index ca61ac1..7064965 100644
--- a/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -203,11 +203,11 @@
       if (providerMethod.getAnnotation(OneOf.class) != null) {
         String key = GeneratorKeys.getElementKey(providerMethod);
         writer.statement("SetBinding.add(map, %s, new %s(module))", JavaWriter.stringLiteral(key),
-            providerMethod.getSimpleName().toString() + "Binding");
+            bindingClassName(providerMethod));
       } else {
         String key = GeneratorKeys.get(providerMethod);
         writer.statement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
-            providerMethod.getSimpleName().toString() + "Binding");
+            bindingClassName(providerMethod));
       }
     }
     writer.endMethod();
@@ -231,11 +231,18 @@
     writer.close();
   }
 
+  private String bindingClassName(ExecutableElement providerMethod) {
+    String methodName = providerMethod.getSimpleName().toString();
+    String uppercaseMethodName = Character.toUpperCase(methodName.charAt(0)) + methodName.substring(1);
+    String className = uppercaseMethodName + "Binding";
+    return className;
+  }
+
   private void writeBindingClass(JavaWriter writer, ExecutableElement providerMethod)
       throws IOException {
     String methodName = providerMethod.getSimpleName().toString();
     String moduleType = CodeGen.typeToString(providerMethod.getEnclosingElement().asType());
-    String className = providerMethod.getSimpleName() + "Binding";
+    String className = bindingClassName(providerMethod);
     String returnType = CodeGen.typeToString(providerMethod.getReturnType());
 
     writer.beginType(className, "class", PRIVATE | STATIC,
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/CodeGen.java b/core/src/main/java/dagger/internal/codegen/CodeGen.java
index 5649ced..3d50c9d 100644
--- a/core/src/main/java/dagger/internal/codegen/CodeGen.java
+++ b/core/src/main/java/dagger/internal/codegen/CodeGen.java
@@ -17,7 +17,6 @@
 
 import dagger.internal.Keys;
 import java.lang.reflect.Method;
-import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -184,15 +183,6 @@
           : annotation.getElementValues().entrySet()) {
         String name = e.getKey().getSimpleName().toString();
         Object value = e.getValue().accept(VALUE_EXTRACTOR, null);
-        Object defaultValue = result.get(name);
-        if (value.getClass() != defaultValue.getClass()) {
-          throw new IllegalStateException(String.format(
-              "Value class is %s but expected %s\n    value: %s\n    default: %s",
-              value.getClass().getName(),
-              defaultValue.getClass().getName(),
-              Arrays.deepToString(new Object[] {value}),
-              Arrays.deepToString(new Object[] {defaultValue})));
-        }
         result.put(name, value);
       }
       return result;
/Fim/
diff --git a/.travis.yml b/.travis.yml
index 33cbd1c..c15e4e6 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,4 +1,5 @@
 language: java
-
+install: mvn install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
+script: mvn verify
 notifications:
   email: false
/Fim/
diff --git a/core/src/main/java/dagger/internal/AtInjectBinding.java b/core/src/main/java/dagger/internal/AtInjectBinding.java
index d9d545d..cc6cd39 100644
--- a/core/src/main/java/dagger/internal/AtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/AtInjectBinding.java
@@ -159,7 +159,7 @@
     // constructor, use a default public constructor if the class has other
     // injections. Otherwise treat the class as non-injectable.
     Constructor<T> injectedConstructor = null;
-    for (Constructor<T> constructor : (Constructor<T>[]) type.getDeclaredConstructors()) {
+    for (Constructor<T> constructor : getConstructorsForType(type)) {
       if (!constructor.isAnnotationPresent(Inject.class)) {
         continue;
       }
@@ -215,4 +215,9 @@
         injectedFields.toArray(new Field[injectedFields.size()]), injectedConstructor,
         parameterCount, supertype, keys.toArray(new String[keys.size()]));
   }
+
+  @SuppressWarnings("unchecked") // type is Class<T> and can't have other than Constructor<T>
+  private static <T> Constructor<T>[] getConstructorsForType(Class<T> type) {
+    return (Constructor<T>[]) type.getDeclaredConstructors();
+  }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index b9a1952..8d9c7cb 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -74,7 +74,7 @@
    * creates JIT bindings as necessary to fill in the gaps.
    */
   public final void linkRequested() {
-    Binding binding;
+    Binding<?> binding;
     while ((binding = toLink.poll()) != null) {
       if (binding instanceof DeferredBinding) {
         DeferredBinding deferredBinding = (DeferredBinding) binding;
/Fim/
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index 45fb8a3..c30a5ec 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -77,7 +77,7 @@
       Class<?> c = Class.forName(adapter);
       Constructor<?> constructor = c.getConstructor();
       constructor.setAccessible(true);
-      result = (ModuleAdapter) constructor.newInstance();
+      result = (ModuleAdapter<T>) constructor.newInstance();
     } catch (Exception e) {
       LOGGER.log(Level.FINE, "No generated module for " + moduleClass.getName()
           + ". Falling back to reflection.", e);
@@ -85,7 +85,7 @@
       if (annotation == null) {
         throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
       }
-      result = (ModuleAdapter) new ReflectiveModuleAdapter(moduleClass, annotation);
+      result = (ModuleAdapter<T>) new ReflectiveModuleAdapter(moduleClass, annotation);
     }
     result.module = (module != null) ? module : result.newModule();
     return result;
@@ -94,7 +94,6 @@
   static class ReflectiveModuleAdapter extends ModuleAdapter<Object> {
     final Class<?> moduleClass;
 
-    @SuppressWarnings("deprecation") // explicitly handles deprecated case
     ReflectiveModuleAdapter(Class<?> moduleClass, Module annotation) {
       super(
           toKeys(annotation.entryPoints()),
/Fim/
diff --git a/core/src/main/java/dagger/internal/ProviderMethodBinding.java b/core/src/main/java/dagger/internal/ProviderMethodBinding.java
index 6c95705..c8f6e13 100644
--- a/core/src/main/java/dagger/internal/ProviderMethodBinding.java
+++ b/core/src/main/java/dagger/internal/ProviderMethodBinding.java
@@ -26,7 +26,7 @@
  * Invokes a method to provide a value. The method's parameters are injected.
  */
 final class ProviderMethodBinding<T> extends Binding<T> {
-  private Binding[] parameters;
+  private Binding<?>[] parameters;
   private final Method method;
   private final Object instance;
 
@@ -63,7 +63,7 @@
   }
 
   @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-    for (Binding binding : parameters) {
+    for (Binding<?> binding : parameters) {
       get.add(binding);
     }
   }
/Fim/
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index 86eb25f..daf8ce4 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -49,6 +49,7 @@
     }
   }
 
+  @SuppressWarnings("unchecked") // Bindings<T> are the only thing added to contributors.
   @Override public Set<T> get() {
     Set<T> result = new LinkedHashSet<T>(contributors.size());
     for (Binding<?> contributor : contributors) {
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/AtInjectBinding.java b/core/src/main/java/dagger/internal/codegen/AtInjectBinding.java
index 8af0e19..003afaf 100644
--- a/core/src/main/java/dagger/internal/codegen/AtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/codegen/AtInjectBinding.java
@@ -117,7 +117,7 @@
   }
 
   @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-    for (Binding binding : bindings) {
+    for (Binding<?> binding : bindings) {
       get.add(binding);
     }
   }
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index b44080a..3cc5a28 100644
--- a/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -170,7 +170,7 @@
     }
 
     @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-      for (Binding binding : parameters) {
+      for (Binding<?> binding : parameters) {
         get.add(binding);
       }
     }
/Fim/
diff --git a/core/src/test/java/dagger/InjectStaticsTest.java b/core/src/test/java/dagger/InjectStaticsTest.java
index e26122f..c0992ca 100644
--- a/core/src/test/java/dagger/InjectStaticsTest.java
+++ b/core/src/test/java/dagger/InjectStaticsTest.java
@@ -21,7 +21,6 @@
 
 import static org.fest.assertions.Assertions.assertThat;
 
-@SuppressWarnings("unused")
 public final class InjectStaticsTest {
   @Before public void setUp() {
     InjectsOneField.staticField = null;
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index 6de4fed..57166fe 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -31,7 +31,6 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
-@SuppressWarnings("unused")
 public final class InjectionTest {
   @Test public void basicInjection() {
     class TestEntryPoint {
@@ -397,7 +396,7 @@
 
   @Test public void noProvideBindingsForAbstractClasses() {
     class TestEntryPoint {
-      @Inject AbstractList abstractList;
+      @Inject AbstractList<?> abstractList;
     }
 
     @Module(entryPoints = TestEntryPoint.class)
/Fim/
diff --git a/core/src/test/java/dagger/MembersInjectorTest.java b/core/src/test/java/dagger/MembersInjectorTest.java
index 767bfd0..d659f1e 100644
--- a/core/src/test/java/dagger/MembersInjectorTest.java
+++ b/core/src/test/java/dagger/MembersInjectorTest.java
@@ -27,7 +27,6 @@
  * Tests MembersInjector injection, and how object graph features interact with
  * types unconstructable types (types that support members injection only).
  */
-@SuppressWarnings("unused")
 public final class MembersInjectorTest {
   @Test public void injectMembers() {
     class TestEntryPoint {
/Fim/
diff --git a/core/src/test/java/dagger/ModuleIncludesTest.java b/core/src/test/java/dagger/ModuleIncludesTest.java
index c608940..135cbf3 100644
--- a/core/src/test/java/dagger/ModuleIncludesTest.java
+++ b/core/src/test/java/dagger/ModuleIncludesTest.java
@@ -21,7 +21,6 @@
 import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
-@SuppressWarnings("unused")
 public final class ModuleIncludesTest {
   static class TestEntryPoint {
     @Inject String s;
/Fim/
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 1b2a751..13ef078 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -5,12 +5,31 @@
 forking the repository and sending a pull request.
 
 When submitting code, please make every effort to follow existing conventions
-and style in order to keep the code as readable as possible. Please also make
-sure your code compiles by running `mvn clean verify`. Checkstyle failures
-during compilation indicate errors in your style and can be viewed in the
-`checkstyle-result.xml` file.
+and style in order to keep the code as readable as possible.  
 
-Before your code can be accepted into the project you must also sign the
+Where appropriate, please provide unit tests or integration tests. Unit tests
+should be JUnit based tests and can use either standard JUnit assertions or
+FEST assertions and be added to `<project>/src/test/java`.  Changes to build-time
+behaviour (such as changes to code generation or graph validation) should go into
+small maven projects using the `maven-invoker-plugin`.  Examples of this are in
+`core/src/it` and can include bean-shell verification scripts and other
+facilities provided by `maven-invoker-plugin`.
+
+Please make sure your code compiles by running `mvn clean verify` which will
+execute both unit and integration test phases.  Additionally, consider using 
+http://travis-ci.org to validate your branches before you even put them into
+pull requests.  All pull requests will be validated by Travis-ci in any case
+and must pass before being merged.
+
+If you are adding or modifying files you may add your own copyright line, but
+please ensure that the form is consistent with the existing files, and please
+note that a Square, Inc. copyright line must appear in every copyright notice.
+All files are released with the Apache 2.0 license.
+
+Checkstyle failures during compilation indicate errors in your style and can be
+viewed in the `checkstyle-result.xml` file.
+
+Before your code can be accepted into the project you must sign the
 [Individual Contributor License Agreement (CLA)][1].
 
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index ed91ed8..88e61fd 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -59,6 +59,29 @@
                     <compilerArgument>-proc:none</compilerArgument>
                 </configuration>
             </plugin>
+            <plugin>
+                <artifactId>maven-invoker-plugin</artifactId>
+                <version>1.7</version>
+                <configuration>
+                    <addTestClassPath>true</addTestClassPath>
+                    <cloneProjectsTo>${project.build.directory}/it</cloneProjectsTo>
+                    <pomIncludes><pomInclude>*/pom.xml</pomInclude></pomIncludes>
+                    <localRepositoryPath>${project.build.directory}/local-repo</localRepositoryPath>
+                    <postBuildHookScript>verify</postBuildHookScript>
+		            <filterProperties>
+		              <dagger.version>${project.version}</dagger.version>
+		            </filterProperties>
+                </configuration>
+                <executions>
+                    <execution>
+                        <id>integration-test</id>
+                        <goals>
+                            <goal>install</goal>
+                            <goal>run</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
         </plugins>
     </build>
 </project>
/Fim/
diff --git a/core/src/it/missing-at-inject-constructor/invoker.properties b/core/src/it/missing-at-inject-constructor/invoker.properties
new file mode 100644
index 0000000..324b5fb
--- /dev/null
+++ b/core/src/it/missing-at-inject-constructor/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
\ No newline at end of file
/Fim/
diff --git a/core/src/it/missing-at-inject-constructor/pom.xml b/core/src/it/missing-at-inject-constructor/pom.xml
new file mode 100644
index 0000000..38786cb
--- /dev/null
+++ b/core/src/it/missing-at-inject-constructor/pom.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2012 Square, Inc.
+ Copyright (C) 2012 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.squareup.dagger.tests</groupId>
+  <version>@dagger.version@</version>
+  <packaging>jar</packaging>
+  <artifactId>missing-at-inject-constructor</artifactId>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/core/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java b/core/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..458bbbd
--- /dev/null
+++ b/core/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2012 Google, Inc.
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+
+import dagger.ObjectGraph;
+import javax.inject.Inject;
+
+class TestApp implements Runnable {
+  @Inject Dependency dep;
+
+  @Override public void run() {
+    dep.doit();
+  }
+
+  public static void main(String[] args) {
+    ObjectGraph.get(new TestModule()).getInstance(TestApp.class).run();
+  }
+  
+  static class Dependency {
+    // missing @Inject Dependency() {}
+    public void doit() { throw AssertionError(); };
+  }
+  
+  @Module(entryPoints = TestApp.class)
+  static class TestModule {
+    /* missing */ // @Provides Dependency a() { return new Dependency(); }
+  }
+}
/Fim/
diff --git a/core/src/it/missing-at-inject-constructor/verify.bsh b/core/src/it/missing-at-inject-constructor/verify.bsh
new file mode 100644
index 0000000..f1a4c76
--- /dev/null
+++ b/core/src/it/missing-at-inject-constructor/verify.bsh
@@ -0,0 +1,7 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "No injectable members on test.TestApp.Dependency.", 
+	"required by test.TestApp for test.TestApp.TestModule"});
/Fim/
diff --git a/core/src/it/simple-missing-dependency-failure/invoker.properties b/core/src/it/simple-missing-dependency-failure/invoker.properties
new file mode 100644
index 0000000..324b5fb
--- /dev/null
+++ b/core/src/it/simple-missing-dependency-failure/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
\ No newline at end of file
/Fim/
diff --git a/core/src/it/simple-missing-dependency-failure/pom.xml b/core/src/it/simple-missing-dependency-failure/pom.xml
new file mode 100644
index 0000000..b0bc89e
--- /dev/null
+++ b/core/src/it/simple-missing-dependency-failure/pom.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2012 Square, Inc.
+ Copyright (C) 2012 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.squareup.dagger.tests</groupId>
+  <artifactId>missing-dependency</artifactId>
+  <version>@dagger.version@</version>
+  <packaging>jar</packaging>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/core/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java b/core/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..ed29fea
--- /dev/null
+++ b/core/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2012 Google, Inc.
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+
+import dagger.ObjectGraph;
+import javax.inject.Inject;
+
+class TestApp implements Runnable {
+  @Inject Dependency dep;
+
+  @Override public void run() {
+    dep.doit();
+  }
+
+  public static void main(String[] args) {
+    ObjectGraph.get(new TestModule()).getInstance(TestApp.class).run();
+  }
+  
+  static interface Dependency {
+    void doit();
+  }
+  
+  @Module(entryPoints = TestApp.class)
+  static class TestModule {
+    /* missing */ // @Provides Dependency a() { return new Dependency(); }
+  }
+}
/Fim/
diff --git a/core/src/it/simple-missing-dependency-failure/verify.bsh b/core/src/it/simple-missing-dependency-failure/verify.bsh
new file mode 100644
index 0000000..fd4e2fd
--- /dev/null
+++ b/core/src/it/simple-missing-dependency-failure/verify.bsh
@@ -0,0 +1,7 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "No binding for test.TestApp$Dependency",
+    "required by test.TestApp for test.TestApp.TestModule"});
/Fim/
diff --git a/core/src/test/java/dagger/testing/it/BuildLogValidator.java b/core/src/test/java/dagger/testing/it/BuildLogValidator.java
new file mode 100644
index 0000000..6106061
--- /dev/null
+++ b/core/src/test/java/dagger/testing/it/BuildLogValidator.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2012 Google, Inc.
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.testing.it;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.nio.MappedByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.charset.Charset;
+
+public class BuildLogValidator {
+
+  /**
+   * Processes a log file, ensuring it has all the provided strings within it.
+   *
+   * @param buildLogfile a log file to be searched
+   * @param expectedStrings the strings that must be present in the log file for it to be valid
+   */
+  public void assertHasText(File buildLogfile, String ... expectedStrings) throws Throwable {
+    String buildOutput;
+    FileInputStream stream = new FileInputStream(buildLogfile);
+    try {
+      FileChannel fc = stream.getChannel();
+      MappedByteBuffer buf = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());
+      buildOutput = Charset.defaultCharset().decode(buf).toString();
+    } finally {
+      stream.close();
+    }
+    if (buildOutput == null) {
+      throw new Exception("Could not read build output");
+    }
+
+    StringBuilder sb = new StringBuilder("Build output did not contain expected error text:");
+    boolean missing = false;
+
+    for (String expected : expectedStrings) {
+      if (!buildOutput.contains(expected)) {
+        missing = true;
+        sb.append("\n    \"").append(expected).append("\"");
+      }
+    }
+    if (missing) {
+      sb.append("\n\nBuild Output:\n\n");
+      boolean containsError = false;
+      for(String line : buildOutput.split("\n")) {
+        if (line.contains("[ERROR]")) {
+          containsError = true;
+          sb.append("\n        ").append(line);
+        }
+      }
+      if (!containsError) {
+        sb.append("\nTEST BUILD SUCCEEDED.\n");
+      }
+      throw new Exception(sb.toString());
+    }
+  }
+
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/Binding.java b/core/src/main/java/dagger/internal/Binding.java
index e69bb66..53d2ef2 100644
--- a/core/src/main/java/dagger/internal/Binding.java
+++ b/core/src/main/java/dagger/internal/Binding.java
@@ -22,8 +22,12 @@
 /**
  * Injects a value of a specific type.
  */
-public class Binding<T> implements Provider<T>, MembersInjector<T> {
-  public static final Binding<Object> UNRESOLVED = new Binding<Object>(null, null, false, null);
+public abstract class Binding<T> implements Provider<T>, MembersInjector<T> {
+  public static final Binding<Object> UNRESOLVED = new Binding<Object>(null, null, false, null) {
+    @Override public void getDependencies(Set<Binding<?>> bindings, Set<Binding<?>> memBindings) {
+      // do nothing
+    }
+  };
 
   /** Set if the provided instance is always the same object. */
   private static final int SINGLETON = 1 << 0;
/Fim/
diff --git a/core/src/main/java/dagger/internal/GraphVisualizer.java b/core/src/main/java/dagger/internal/GraphVisualizer.java
index 636b751..eaa51b9 100644
--- a/core/src/main/java/dagger/internal/GraphVisualizer.java
+++ b/core/src/main/java/dagger/internal/GraphVisualizer.java
@@ -49,17 +49,11 @@
     for (Map.Entry<Binding<?>, String> entry : namesIndex.entrySet()) {
       Binding<?> sourceBinding = entry.getKey();
       String sourceName = entry.getValue();
-      try {
-        Set<Binding<?>> dependencies = new HashSet<Binding<?>>();
-        if (sourceBinding != Binding.UNRESOLVED) {
-          sourceBinding.getDependencies(dependencies, dependencies);
-        }
-        for (Binding<?> targetBinding : dependencies) {
-          String targetName = namesIndex.get(targetBinding);
-          writer.edge(sourceName, targetName);
-        }
-      } catch (Exception e) {
-        throw new IllegalStateException("Could not write binding: \"" + sourceBinding + "\"", e);
+      Set<Binding<?>> dependencies = new HashSet<Binding<?>>();
+      sourceBinding.getDependencies(dependencies, dependencies);
+      for (Binding<?> targetBinding : dependencies) {
+        String targetName = namesIndex.get(targetBinding);
+        writer.edge(sourceName, targetName);
       }
     }
     writer.endGraph();
/Fim/
diff --git a/README.md b/README.md
index 5e2aa27..d47d9c1 100644
--- a/README.md
+++ b/README.md
@@ -355,6 +355,39 @@
 For more substantial variations it's often simpler to use a different combination of modules.
 
 
+Using Dagger in your build
+==========================
+
+You will need to include the dagger-${dagger.version}.jar in your application's runtime.  In order to activate code generation you will need to include dagger-compiler-${dagger.version}.jar in your build at compile time. 
+
+In a Maven project, one would include the runtime in the dependencies section of your `pom.xml` (replacing ${dagger.version} with the appropriate current release), and the dagger-compiler artifact as a dependency of the compiler plugin: 
+
+```java
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${dagger.version}</version>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <dependencies>
+          <dependency>
+            <groupId>com.squareup</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>${dagger.version}</version>
+          </dependency>
+        </dependencies>
+      </plugin>
+    </plugins>
+  </build>
+```
+
+
+
 Upgrading from Guice
 ====================
 
/Fim/
diff --git a/androidmanifest/pom.xml b/androidmanifest/pom.xml
index 201423f..3916e36 100644
--- a/androidmanifest/pom.xml
+++ b/androidmanifest/pom.xml
@@ -33,11 +33,16 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
       <groupId>org.apache.maven</groupId>
       <artifactId>maven-core</artifactId>
     </dependency>
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
new file mode 100644
index 0000000..91b4efb
--- /dev/null
+++ b/compiler/pom.xml
@@ -0,0 +1,95 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2012 Square, Inc.
+ Copyright (C) 2012 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup</groupId>
+    <artifactId>dagger-parent</artifactId>
+    <version>1.0-SNAPSHOT</version>
+    <relativePath>../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>dagger-compiler</artifactId>
+  <name>Dagger Compiler</name>
+  <description>
+    Tools to generate Dagger injection and module adapters from annotated code and validate them.
+  </description>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.easytesting</groupId>
+      <artifactId>fest-assert</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+  
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>2.5</version>
+        <configuration>
+          <source>${java.version}</source>
+          <target>${java.version}</target>
+          <compilerArgument>-proc:none</compilerArgument>
+        </configuration>
+      </plugin>
+      <plugin>
+        <artifactId>maven-invoker-plugin</artifactId>
+        <version>1.7</version>
+        <configuration>
+          <addTestClassPath>true</addTestClassPath>
+          <cloneProjectsTo>${project.build.directory}/it</cloneProjectsTo>
+          <pomIncludes>
+            <pomInclude>*/pom.xml</pomInclude>
+          </pomIncludes>
+          <localRepositoryPath>${project.build.directory}/local-repo</localRepositoryPath>
+          <postBuildHookScript>verify</postBuildHookScript>
+          <filterProperties>
+            <dagger.version>${project.version}</dagger.version>
+          </filterProperties>
+        </configuration>
+        <executions>
+          <execution>
+            <id>integration-test</id>
+            <goals>
+              <goal>install</goal>
+              <goal>run</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/core/src/it/missing-at-inject-constructor/invoker.properties b/compiler/src/it/missing-at-inject-constructor/invoker.properties
similarity index 100%
rename from core/src/it/missing-at-inject-constructor/invoker.properties
rename to compiler/src/it/missing-at-inject-constructor/invoker.properties
/Fim/
diff --git a/core/src/it/missing-at-inject-constructor/pom.xml b/compiler/src/it/missing-at-inject-constructor/pom.xml
similarity index 88%
rename from core/src/it/missing-at-inject-constructor/pom.xml
rename to compiler/src/it/missing-at-inject-constructor/pom.xml
index 38786cb..b0def46 100644
--- a/core/src/it/missing-at-inject-constructor/pom.xml
+++ b/compiler/src/it/missing-at-inject-constructor/pom.xml
@@ -31,6 +31,12 @@
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <scope>provided</scope>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
/Fim/
diff --git a/core/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java b/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
similarity index 100%
rename from core/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
rename to compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
/Fim/
diff --git a/core/src/it/missing-at-inject-constructor/verify.bsh b/compiler/src/it/missing-at-inject-constructor/verify.bsh
similarity index 100%
rename from core/src/it/missing-at-inject-constructor/verify.bsh
rename to compiler/src/it/missing-at-inject-constructor/verify.bsh
/Fim/
diff --git a/core/src/it/simple-missing-dependency-failure/invoker.properties b/compiler/src/it/simple-missing-dependency-failure/invoker.properties
similarity index 100%
rename from core/src/it/simple-missing-dependency-failure/invoker.properties
rename to compiler/src/it/simple-missing-dependency-failure/invoker.properties
/Fim/
diff --git a/core/src/it/simple-missing-dependency-failure/pom.xml b/compiler/src/it/simple-missing-dependency-failure/pom.xml
similarity index 88%
rename from core/src/it/simple-missing-dependency-failure/pom.xml
rename to compiler/src/it/simple-missing-dependency-failure/pom.xml
index b0bc89e..35e3d5d 100644
--- a/core/src/it/simple-missing-dependency-failure/pom.xml
+++ b/compiler/src/it/simple-missing-dependency-failure/pom.xml
@@ -31,6 +31,12 @@
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <scope>provided</scope>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
/Fim/
diff --git a/core/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java b/compiler/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java
similarity index 100%
rename from core/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java
rename to compiler/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java
/Fim/
diff --git a/core/src/it/simple-missing-dependency-failure/verify.bsh b/compiler/src/it/simple-missing-dependency-failure/verify.bsh
similarity index 100%
rename from core/src/it/simple-missing-dependency-failure/verify.bsh
rename to compiler/src/it/simple-missing-dependency-failure/verify.bsh
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/AtInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
similarity index 100%
rename from core/src/main/java/dagger/internal/codegen/AtInjectBinding.java
rename to compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/CodeGen.java b/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
similarity index 100%
rename from core/src/main/java/dagger/internal/codegen/CodeGen.java
rename to compiler/src/main/java/dagger/internal/codegen/CodeGen.java
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/BuildTimeLinker.java b/compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java
similarity index 62%
rename from core/src/main/java/dagger/internal/codegen/BuildTimeLinker.java
rename to compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java
index a0c7808..5702f15 100644
--- a/core/src/main/java/dagger/internal/codegen/BuildTimeLinker.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CompileTimePlugin.java
@@ -16,30 +16,29 @@
 package dagger.internal.codegen;
 
 import dagger.internal.Binding;
-import dagger.internal.Linker;
-import java.util.List;
+import dagger.internal.ModuleAdapter;
+import dagger.internal.Plugin;
+import dagger.internal.StaticInjection;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.TypeElement;
-import javax.tools.Diagnostic;
 
 /**
- * Linker suitable for tool use at build time. The bindings created by this
- * linker have the correct dependency graph, but do not implement {@link
- * Binding#get} or {@link Binding#injectMembers} methods. They are only suitable
+ * A {@code Binding.Resolver} suitable for tool use at build time. The bindings created by
+ * this {@code Binding.Resolver} have the correct dependency graph, but do not implement
+ * {@link Binding#get} or {@link Binding#injectMembers} methods. They are only suitable
  * for graph analysis and error detection.
  */
-final class BuildTimeLinker extends Linker {
-  private final ProcessingEnvironment processingEnv;
-  private final String moduleName;
+public final class CompileTimePlugin implements Plugin {
 
-  BuildTimeLinker(ProcessingEnvironment processingEnv, String moduleName) {
+  private final ProcessingEnvironment processingEnv;
+
+  public CompileTimePlugin(ProcessingEnvironment processingEnv) {
     this.processingEnv = processingEnv;
-    this.moduleName = moduleName;
   }
 
-  @Override protected Binding<?> createAtInjectBinding(
-      String key, String className, boolean mustBeInjectable) {
+  @Override public Binding<?> getAtInjectBinding(String key, String className,
+      boolean mustBeInjectable) throws ClassNotFoundException {
     String sourceClassName = className.replace('$', '.');
     TypeElement type = processingEnv.getElementUtils().getTypeElement(sourceClassName);
     if (type == null) {
@@ -55,9 +54,11 @@
     return AtInjectBinding.create(type, mustBeInjectable);
   }
 
-  @Override protected void reportErrors(List<String> errors) {
-    for (String error : errors) {
-      processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, error + " for " + moduleName);
-    }
+  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
+    throw new UnsupportedOperationException();
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/DotWriter.java b/compiler/src/main/java/dagger/internal/codegen/DotWriter.java
similarity index 100%
rename from core/src/main/java/dagger/internal/codegen/DotWriter.java
rename to compiler/src/main/java/dagger/internal/codegen/DotWriter.java
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
similarity index 97%
rename from core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
rename to compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 3cc5a28..e358b73 100644
--- a/core/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -19,7 +19,6 @@
 import dagger.OneOf;
 import dagger.Provides;
 import dagger.internal.Binding;
-import dagger.internal.GraphVisualizer;
 import dagger.internal.Linker;
 import dagger.internal.SetBinding;
 import java.io.IOException;
@@ -79,7 +78,8 @@
     Map<String, TypeElement> allModules = new LinkedHashMap<String, TypeElement>();
     collectIncludesRecursively(rootModule, allModules);
 
-    Linker linker = new BuildTimeLinker(processingEnv, rootModule.getQualifiedName().toString());
+    Linker linker = new Linker(new CompileTimePlugin(processingEnv),
+        new ReportingErrorHandler(processingEnv, rootModule.getQualifiedName().toString()));
     Map<String, Binding<?>> baseBindings = new LinkedHashMap<String, Binding<?>>();
     Map<String, Binding<?>> overrideBindings = new LinkedHashMap<String, Binding<?>>();
     for (TypeElement module : allModules.values()) {
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/GeneratorKeys.java b/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
similarity index 99%
rename from core/src/main/java/dagger/internal/codegen/GeneratorKeys.java
rename to compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
index ced0a48..f93220c 100644
--- a/core/src/main/java/dagger/internal/codegen/GeneratorKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
@@ -18,7 +18,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
/Fim/
diff --git a/core/src/main/java/dagger/internal/GraphVisualizer.java b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
similarity index 97%
rename from core/src/main/java/dagger/internal/GraphVisualizer.java
rename to compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
index eaa51b9..1a24d06 100644
--- a/core/src/main/java/dagger/internal/GraphVisualizer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal;
+package dagger.internal.codegen;
 
-import dagger.internal.codegen.DotWriter;
+import dagger.internal.Binding;
 import java.io.IOException;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
similarity index 97%
rename from core/src/main/java/dagger/internal/codegen/InjectProcessor.java
rename to compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index c4421c6..97330c1 100644
--- a/core/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -40,6 +40,8 @@
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
+import static dagger.internal.plugins.loading.ClassloadingPlugin.INJECT_ADAPTER_SUFFIX;
+import static dagger.internal.plugins.loading.ClassloadingPlugin.STATIC_INJECTION_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
 import static java.lang.reflect.Modifier.PRIVATE;
 import static java.lang.reflect.Modifier.PUBLIC;
@@ -157,7 +159,7 @@
       List<Element> fields) throws IOException {
     String typeName = type.getQualifiedName().toString();
     TypeMirror supertype = CodeGen.getApplicationSupertype(type);
-    String adapterName = CodeGen.adapterName(type, "$InjectAdapter");
+    String adapterName = CodeGen.adapterName(type, INJECT_ADAPTER_SUFFIX);
     JavaFileObject sourceFile = processingEnv.getFiler()
         .createSourceFile(adapterName, type);
     JavaWriter writer = new JavaWriter(sourceFile.openWriter());
@@ -285,7 +287,7 @@
    */
   private void writeStaticInjection(TypeElement type, List<Element> fields) throws IOException {
     String typeName = type.getQualifiedName().toString();
-    String adapterName = CodeGen.adapterName(type, "$StaticInjection");
+    String adapterName = CodeGen.adapterName(type, STATIC_INJECTION_SUFFIX);
     JavaFileObject sourceFile = processingEnv.getFiler()
         .createSourceFile(adapterName, type);
     JavaWriter writer = new JavaWriter(sourceFile.openWriter());
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
similarity index 100%
rename from core/src/main/java/dagger/internal/codegen/JavaWriter.java
rename to compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
/Fim/
diff --git a/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
similarity index 98%
rename from core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
rename to compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 7d9ae82..16416b4 100644
--- a/core/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -45,6 +45,7 @@
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
+import static dagger.internal.plugins.loading.ClassloadingPlugin.MODULE_ADAPTER_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
 import static java.lang.reflect.Modifier.PRIVATE;
 import static java.lang.reflect.Modifier.PROTECTED;
@@ -144,7 +145,7 @@
     boolean overrides = (Boolean) module.get("overrides");
     boolean complete = (Boolean) module.get("complete");
 
-    String adapterName = CodeGen.adapterName(type, "$ModuleAdapter");
+    String adapterName = CodeGen.adapterName(type, MODULE_ADAPTER_SUFFIX);
     JavaFileObject sourceFile = processingEnv.getFiler()
         .createSourceFile(adapterName, type);
     JavaWriter writer = new JavaWriter(sourceFile.openWriter());
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ReportingErrorHandler.java b/compiler/src/main/java/dagger/internal/codegen/ReportingErrorHandler.java
new file mode 100644
index 0000000..7bac1d3
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ReportingErrorHandler.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import dagger.internal.Linker;
+import java.util.List;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.tools.Diagnostic;
+
+/**
+ * A {@code Linker.ErrorHandler} which gathers errors and reports them via a processing
+ * environment.
+ */
+final class ReportingErrorHandler implements Linker.ErrorHandler {
+  private final ProcessingEnvironment processingEnv;
+  private final String moduleName;
+
+  ReportingErrorHandler(ProcessingEnvironment processingEnv, String moduleName) {
+    this.processingEnv = processingEnv;
+    this.moduleName = moduleName;
+  }
+
+  @Override public void handleErrors(List<String> errors) {
+    for (String error : errors) {
+      processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, error + " for " + moduleName);
+    }
+  }
+}
/Fim/
diff --git a/core/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/compiler/src/main/resources/META-INF/services/javax.annotation.processing.Processor
similarity index 100%
rename from core/src/main/resources/META-INF/services/javax.annotation.processing.Processor
rename to compiler/src/main/resources/META-INF/services/javax.annotation.processing.Processor
/Fim/
diff --git a/core/src/test/java/dagger/internal/codegen/DotWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java
similarity index 100%
rename from core/src/test/java/dagger/internal/codegen/DotWriterTest.java
rename to compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java
/Fim/
diff --git a/core/src/test/java/dagger/internal/GraphVisualizerTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
similarity index 97%
rename from core/src/test/java/dagger/internal/GraphVisualizerTest.java
rename to compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
index 46832be..8f0a135 100644
--- a/core/src/test/java/dagger/internal/GraphVisualizerTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
@@ -13,8 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal;
+package dagger.internal.codegen;
 
+import dagger.internal.Keys;
 import java.lang.reflect.Field;
 import java.util.Map;
 import java.util.Set;
/Fim/
diff --git a/core/src/test/java/dagger/internal/codegen/JavaWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/JavaWriterTest.java
similarity index 100%
rename from core/src/test/java/dagger/internal/codegen/JavaWriterTest.java
rename to compiler/src/test/java/dagger/internal/codegen/JavaWriterTest.java
/Fim/
diff --git a/core/src/test/java/dagger/testing/it/BuildLogValidator.java b/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java
similarity index 100%
rename from core/src/test/java/dagger/testing/it/BuildLogValidator.java
rename to compiler/src/test/java/dagger/testing/it/BuildLogValidator.java
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 55eddcd..4598aa1 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -51,41 +51,6 @@
 
   <build>
     <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>2.5</version>
-        <configuration>
-          <source>${java.version}</source>
-          <target>${java.version}</target>
-          <compilerArgument>-proc:none</compilerArgument>
-        </configuration>
-      </plugin>
-      <plugin>
-        <artifactId>maven-invoker-plugin</artifactId>
-        <version>1.7</version>
-        <configuration>
-          <addTestClassPath>true</addTestClassPath>
-          <cloneProjectsTo>${project.build.directory}/it</cloneProjectsTo>
-          <pomIncludes>
-            <pomInclude>*/pom.xml</pomInclude>
-          </pomIncludes>
-          <localRepositoryPath>${project.build.directory}/local-repo</localRepositoryPath>
-          <postBuildHookScript>verify</postBuildHookScript>
-          <filterProperties>
-            <dagger.version>${project.version}</dagger.version>
-          </filterProperties>
-        </configuration>
-        <executions>
-          <execution>
-            <id>integration-test</id>
-            <goals>
-              <goal>install</goal>
-              <goal>run</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
     </plugins>
   </build>
 </project>
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 7a3fe30..c3a2891 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,10 +20,14 @@
 import dagger.internal.Keys;
 import dagger.internal.Linker;
 import dagger.internal.ModuleAdapter;
+import dagger.internal.Plugin;
 import dagger.internal.ProblemDetector;
-import dagger.internal.RuntimeLinker;
+import dagger.internal.RuntimeAggregatingPlugin;
 import dagger.internal.StaticInjection;
+import dagger.internal.ThrowingErrorHandler;
 import dagger.internal.UniqueMap;
+import dagger.internal.plugins.loading.ClassloadingPlugin;
+import dagger.internal.plugins.reflect.ReflectivePlugin;
 import java.util.LinkedHashMap;
 import java.util.Map;
 
@@ -57,10 +62,14 @@
   private final Linker linker;
   private final Map<Class<?>, StaticInjection> staticInjections;
   private final Map<String, Class<?>> entryPoints;
+  private final Plugin plugin;
 
-  private ObjectGraph(Linker linker, Map<Class<?>, StaticInjection> staticInjections,
+  ObjectGraph(Linker linker,
+      Plugin plugin,
+      Map<Class<?>, StaticInjection> staticInjections,
       Map<String, Class<?>> entryPoints) {
     this.linker = linker;
+    this.plugin = plugin;
     this.staticInjections = staticInjections;
     this.entryPoints = entryPoints;
   }
@@ -78,7 +87,11 @@
    * the graph at runtime.
    */
   public static ObjectGraph get(Object... modules) {
-    ModuleAdapter<?>[] moduleAdapters = getAllModuleAdapters(modules);
+
+    RuntimeAggregatingPlugin plugin = new RuntimeAggregatingPlugin(
+        new ClassloadingPlugin(), new ReflectivePlugin());
+
+    ModuleAdapter<?>[] moduleAdapters = plugin.getAllModuleAdapters(modules);
 
     Map<String, Class<?>> entryPoints = new LinkedHashMap<String, Class<?>>();
     Map<Class<?>, StaticInjection> staticInjections
@@ -99,65 +112,19 @@
       adapter.getBindings(addTo);
     }
 
-    // Create a linker and install all of the user's bindings.
-    Linker linker = new RuntimeLinker();
+    // Create a linker and install all of the user's bindings
+    Linker linker = new Linker(plugin, new ThrowingErrorHandler());
     linker.installBindings(baseBindings);
     linker.installBindings(overrideBindings);
 
-    return new ObjectGraph(linker, staticInjections, entryPoints);
-  }
-
-  /**
-   * Returns a full set of module adapters, including module adapters for included
-   * modules.
-   */
-  private static ModuleAdapter<?>[] getAllModuleAdapters(Object[] seedModules) {
-    // Create a module adapter for each seed module.
-    ModuleAdapter<?>[] seedAdapters = new ModuleAdapter<?>[seedModules.length];
-    int s = 0;
-    for (Object module : seedModules) {
-      seedAdapters[s++] = ModuleAdapter.get(module.getClass(), module);
-    }
-
-    Map<Class<?>, ModuleAdapter<?>> adaptersByModuleType
-        = new LinkedHashMap<Class<?>, ModuleAdapter<?>>();
-
-    // Add the adapters that we have module instances for. This way we won't
-    // construct module objects when we have a user-supplied instance.
-    for (ModuleAdapter<?> adapter : seedAdapters) {
-      adaptersByModuleType.put(adapter.getModule().getClass(), adapter);
-    }
-
-    // Next add adapters for the modules that we need to construct. This creates
-    // instances of modules as necessary.
-    for (ModuleAdapter<?> adapter : seedAdapters) {
-      collectIncludedModulesRecursively(adapter, adaptersByModuleType);
-    }
-
-    return adaptersByModuleType.values().toArray(
-        new ModuleAdapter<?>[adaptersByModuleType.size()]);
-  }
-
-  /**
-   * Fills {@code result} with the module adapters for the includes of {@code
-   * adapter}, and their includes recursively.
-   */
-  private static void collectIncludedModulesRecursively(ModuleAdapter<?> adapter,
-      Map<Class<?>, ModuleAdapter<?>> result) {
-    for (Class<?> include : adapter.includes) {
-      if (!result.containsKey(include)) {
-        ModuleAdapter<Object> includedModuleAdapter = ModuleAdapter.get(include, null);
-        result.put(include, includedModuleAdapter);
-        collectIncludedModulesRecursively(includedModuleAdapter, result);
-      }
-    }
+    return new ObjectGraph(linker, plugin, staticInjections, entryPoints);
   }
 
   private void linkStaticInjections() {
     for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
       StaticInjection staticInjection = entry.getValue();
       if (staticInjection == null) {
-        staticInjection = StaticInjection.get(entry.getKey());
+        staticInjection = plugin.getStaticInjection(entry.getKey());
         entry.setValue(staticInjection);
       }
       staticInjection.attach(linker);
/Fim/
diff --git a/core/src/main/java/dagger/internal/Binding.java b/core/src/main/java/dagger/internal/Binding.java
index 53d2ef2..d77e25e 100644
--- a/core/src/main/java/dagger/internal/Binding.java
+++ b/core/src/main/java/dagger/internal/Binding.java
@@ -120,6 +120,8 @@
   }
 
   @Override public String toString() {
-    return "Binding[provideKey=\"" + provideKey + "\", memberskey=\"" + membersKey + "\"]";
+    return getClass().getSimpleName()
+            + "[provideKey=\"" + provideKey + "\", memberskey=\"" + membersKey + "\"]";
   }
+
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 8d9c7cb..096ceca 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -26,7 +26,7 @@
 /**
  * Links bindings to their dependencies.
  */
-public abstract class Linker {
+public final class Linker {
   private static final Object UNINITIALIZED = new Object();
 
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
@@ -41,12 +41,21 @@
   /** All of the object graph's bindings. This may contain unlinked bindings. */
   private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
 
+  private final Plugin plugin;
+
+  private final ErrorHandler errorHandler;
+
+  public Linker(Plugin plugin, ErrorHandler errorHandler) {
+    this.plugin = plugin;
+    this.errorHandler = errorHandler;
+  }
+
   /**
    * Adds all bindings in {@code toInstall}. The caller must call either {@link
    * #linkAll} or {@link #requestBinding} and {@link #linkRequested} before the
    * bindings can be used.
    */
-  public final void installBindings(Map<String, ? extends Binding<?>> toInstall) {
+  public void installBindings(Map<String, ? extends Binding<?>> toInstall) {
     for (Map.Entry<String, ? extends Binding<?>> entry : toInstall.entrySet()) {
       bindings.put(entry.getKey(), scope(entry.getValue()));
     }
@@ -59,7 +68,7 @@
    *
    * @return all bindings known by this linker, which will all be linked.
    */
-  public final Map<String, Binding<?>> linkAll() {
+  public Map<String, Binding<?>> linkAll() {
     for (Binding<?> binding : bindings.values()) {
       if (!binding.isLinked()) {
         toLink.add(binding);
@@ -73,7 +82,7 @@
    * Links all requested bindings plus their transitive dependencies. This
    * creates JIT bindings as necessary to fill in the gaps.
    */
-  public final void linkRequested() {
+  public void linkRequested() {
     Binding<?> binding;
     while ((binding = toLink.poll()) != null) {
       if (binding instanceof DeferredBinding) {
@@ -111,7 +120,7 @@
     }
 
     try {
-      reportErrors(errors);
+      errorHandler.handleErrors(errors);
     } finally {
       errors.clear();
     }
@@ -140,7 +149,7 @@
 
     String className = Keys.getClassName(key);
     if (className != null && !Keys.isAnnotated(key)) {
-      Binding<?> atInjectBinding = createAtInjectBinding(key, className, mustBeInjectable);
+      Binding<?> atInjectBinding = plugin.getAtInjectBinding(key, className, mustBeInjectable);
       if (atInjectBinding != null) {
         return atInjectBinding;
       }
@@ -149,19 +158,13 @@
     throw new IllegalArgumentException("No binding for " + key);
   }
 
-  /**
-   * Returns a binding that uses {@code @Inject} annotations, or null if no such
-   * binding can be created.
-   */
-  protected abstract Binding<?> createAtInjectBinding(
-      String key, String className, boolean mustBeInjectable) throws ClassNotFoundException;
 
   /**
    * Returns the binding if it exists immediately. Otherwise this returns
    * null. If the returned binding didn't exist or was unlinked, it will be
    * enqueued to be linked.
    */
-  public final Binding<?> requestBinding(String key, Object requiredBy) {
+  public Binding<?> requestBinding(String key, Object requiredBy) {
     return requestBinding(key, true, requiredBy);
   }
 
@@ -171,7 +174,7 @@
    * inject arbitrary entry points (like JUnit test cases or Android activities)
    * without concern for whether the specific entry point is injectable.
    */
-  public final Binding<?> requestEntryPoint(String key, Class<?> requiredByModule) {
+  public Binding<?> requestEntryPoint(String key, Class<?> requiredByModule) {
     return requestBinding(key, false, requiredByModule);
   }
 
@@ -234,15 +237,6 @@
   }
 
   /**
-   * Fail if any errors have been enqueued and clear the list of errors.
-   * Implementations may throw exceptions or report the errors through another
-   * channel.
-   *
-   * @param errors a potentially empty list of error messages.
-   */
-  protected abstract void reportErrors(List<String> errors);
-
-  /**
    * A Binding that implements singleton behaviour around an existing binding.
    */
   private static class SingletonBinding<T> extends Binding<T> {
@@ -280,6 +274,18 @@
     }
   }
 
+  /** Handles linker errors appropriately. */
+  public interface ErrorHandler {
+    /**
+     * Fail if any errors have been enqueued.
+     * Implementations may throw exceptions or report the errors through another
+     * channel.  Callers are responsible for clearing enqueued errors.
+     *
+     * @param errors a potentially empty list of error messages.
+     */
+    void handleErrors(List<String> errors);
+  }
+
   private static class DeferredBinding extends Binding<Object> {
     final String deferredKey;
     final boolean mustBeInjectable;
@@ -289,4 +295,5 @@
       this.mustBeInjectable = mustBeInjectable;
     }
   }
+
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index c30a5ec..f59175c 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -17,21 +17,12 @@
 package dagger.internal;
 
 
-import dagger.Module;
-import dagger.ObjectGraph;
-import dagger.OneOf;
-import dagger.Provides;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
 import java.util.Map;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 /**
  * Extracts bindings from an {@code @Module}-annotated class.
  */
 public abstract class ModuleAdapter<T> {
-  private static final Logger LOGGER = Logger.getLogger(ObjectGraph.class.getName());
 
   public final String[] entryPoints;
   public final Class<?>[] staticInjections;
@@ -65,87 +56,5 @@
     return module;
   }
 
-  /**
-   * Returns a module adapter for {@code module}, preferring a code-generated
-   * implementation and falling back to a reflective implementation.
-   */
-  @SuppressWarnings("unchecked") // Runtime checks validate that the result type matches 'T'.
-  public static <T> ModuleAdapter<T> get(Class<? extends T> moduleClass, T module) {
-    ModuleAdapter<T> result;
-    try {
-      String adapter = moduleClass.getName() + "$ModuleAdapter";
-      Class<?> c = Class.forName(adapter);
-      Constructor<?> constructor = c.getConstructor();
-      constructor.setAccessible(true);
-      result = (ModuleAdapter<T>) constructor.newInstance();
-    } catch (Exception e) {
-      LOGGER.log(Level.FINE, "No generated module for " + moduleClass.getName()
-          + ". Falling back to reflection.", e);
-      Module annotation = moduleClass.getAnnotation(Module.class);
-      if (annotation == null) {
-        throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
-      }
-      result = (ModuleAdapter<T>) new ReflectiveModuleAdapter(moduleClass, annotation);
-    }
-    result.module = (module != null) ? module : result.newModule();
-    return result;
-  }
 
-  static class ReflectiveModuleAdapter extends ModuleAdapter<Object> {
-    final Class<?> moduleClass;
-
-    ReflectiveModuleAdapter(Class<?> moduleClass, Module annotation) {
-      super(
-          toKeys(annotation.entryPoints()),
-          annotation.staticInjections(),
-          annotation.overrides(),
-          annotation.includes(),
-          annotation.complete());
-      this.moduleClass = moduleClass;
-    }
-
-    private static String[] toKeys(Class<?>[] entryPoints) {
-      String[] result = new String[entryPoints.length];
-      for (int i = 0; i < entryPoints.length; i++) {
-        result[i] = Keys.get(entryPoints[i]);
-      }
-      return result;
-    }
-
-    @Override public void getBindings(Map<String, Binding<?>> bindings) {
-      // Fall back to runtime reflection.
-      for (Class<?> c = moduleClass; c != Object.class; c = c.getSuperclass()) {
-        for (Method method : c.getDeclaredMethods()) {
-          if (method.isAnnotationPresent(Provides.class)) {
-            String key = Keys.get(method.getGenericReturnType(), method.getAnnotations(), method);
-            if (method.isAnnotationPresent(OneOf.class)) {
-              handleSetBindings(bindings, method, key);
-            } else {
-              handleBindings(bindings, method, key);
-            }
-          }
-        }
-      }
-    }
-
-    private <T> void handleBindings(Map<String, Binding<?>> bindings, Method method, String key) {
-      bindings.put(key, new ProviderMethodBinding<T>(method, key, module));
-    }
-
-    private <T> void handleSetBindings(Map<String, Binding<?>> bindings, Method method, String key) {
-      String elementKey =
-          Keys.getElementKey(method.getGenericReturnType(), method.getAnnotations(), method);
-      SetBinding.<T>add(bindings, elementKey, new ProviderMethodBinding<T>(method, key, module));
-    }
-
-    @Override protected Object newModule() {
-      try {
-        Constructor<?> includeConstructor = moduleClass.getDeclaredConstructor();
-        includeConstructor.setAccessible(true);
-        return includeConstructor.newInstance();
-      } catch (Exception e) {
-        throw new IllegalArgumentException("Unable to instantiate " + moduleClass.getName(), e);
-      }
-    }
-  }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Plugin.java b/core/src/main/java/dagger/internal/Plugin.java
new file mode 100644
index 0000000..37963f6
--- /dev/null
+++ b/core/src/main/java/dagger/internal/Plugin.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+/**
+ * Provides a point of configuration of the basic resolving functions within Dagger, namely
+ * that of Module handling, injection binding creation, and static injection.  A plugin must
+ * provide all resolution methods
+ */
+public interface Plugin {
+
+  /**
+   * Returns a binding that uses {@code @Inject} annotations, or null if no such
+   * binding can be located or created.
+   */
+  Binding<?> getAtInjectBinding(String key, String className, boolean mustBeInjectable)
+      throws ClassNotFoundException;
+
+  /**
+   * Returns a module adapter for {@code module}.
+   */
+  <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module);
+
+  /**
+   * Returns the static injection for {@code injectedClass}.
+   */
+  StaticInjection getStaticInjection(Class<?> injectedClass);
+
+}
\ No newline at end of file
/Fim/
/Fim/
diff --git a/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java b/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
new file mode 100644
index 0000000..d234e29
--- /dev/null
+++ b/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+/**
+ * Aggregates provided plugins and delegates its operations to them in order.  Also provides some
+ * specific runtime facilities needed by the runtime.
+ */
+public class RuntimeAggregatingPlugin implements Plugin {
+
+  /** A list of {@code Linker.Plugin}s which will be consulted in-order to resolve requests. */
+  private final Plugin[] plugins;
+
+  public RuntimeAggregatingPlugin(Plugin ... plugins) {
+    if (plugins == null || plugins.length == 0) {
+      throw new IllegalArgumentException("Must provide at least one plugin.");
+    }
+    this.plugins = plugins;
+  }
+
+  /**
+   * Returns a full set of module adapters, including module adapters for included
+   * modules.
+   */
+  public ModuleAdapter<?>[] getAllModuleAdapters(Object[] seedModules) {
+    // Create a module adapter for each seed module.
+    ModuleAdapter<?>[] seedAdapters = new ModuleAdapter<?>[seedModules.length];
+    int s = 0;
+    for (Object module : seedModules) {
+      seedAdapters[s++] = getModuleAdapter(module.getClass(), module);
+    }
+
+    Map<Class<?>, ModuleAdapter<?>> adaptersByModuleType
+        = new LinkedHashMap<Class<?>, ModuleAdapter<?>>();
+
+    // Add the adapters that we have module instances for. This way we won't
+    // construct module objects when we have a user-supplied instance.
+    for (ModuleAdapter<?> adapter : seedAdapters) {
+      adaptersByModuleType.put(adapter.getModule().getClass(), adapter);
+    }
+
+    // Next add adapters for the modules that we need to construct. This creates
+    // instances of modules as necessary.
+    for (ModuleAdapter<?> adapter : seedAdapters) {
+      collectIncludedModulesRecursively(adapter, adaptersByModuleType);
+    }
+
+    return adaptersByModuleType.values().toArray(
+        new ModuleAdapter<?>[adaptersByModuleType.size()]);
+  }
+
+  /**
+   * Fills {@code result} with the module adapters for the includes of {@code
+   * adapter}, and their includes recursively.
+   */
+  private void collectIncludedModulesRecursively(ModuleAdapter<?> adapter,
+      Map<Class<?>, ModuleAdapter<?>> result) {
+    for (Class<?> include : adapter.includes) {
+      if (!result.containsKey(include)) {
+        ModuleAdapter<Object> includedModuleAdapter = getModuleAdapter(include, null);
+        result.put(include, includedModuleAdapter);
+        collectIncludedModulesRecursively(includedModuleAdapter, result);
+      }
+    }
+  }
+
+  /**
+   * Obtains a module adapter for {@code module} from the first responding resolver.
+   */
+  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
+    for (Plugin plugin : plugins) {
+      ModuleAdapter<T> result = plugin.getModuleAdapter(moduleClass, module);
+      if (result != null) {
+        result.module = (module != null) ? module : result.newModule();
+        return result;
+      }
+    }
+    throw new IllegalStateException("Could not find any valid ModuleAdapter for "
+        + ((module != null) ? module.getClass().getName() : moduleClass.getName()));
+  }
+
+  @Override public Binding<?> getAtInjectBinding(String key, String className,
+      boolean mustBeInjectable) {
+    for (Plugin plugin : plugins) {
+      try {
+        Binding<?> binding = plugin.getAtInjectBinding(key, className, mustBeInjectable);
+        if (binding != null) {
+          return binding;
+        }
+      } catch (Exception e) {
+        // Let later resolvers try to fulfill this.
+      }
+    }
+    throw new IllegalStateException("No available @Inject handlers could be found "
+        + "for key " + key + " in class " + className);
+  }
+
+  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
+    for (Plugin plugin : plugins) {
+      StaticInjection injection = plugin.getStaticInjection(injectedClass);
+      if (injection != null) {
+        return injection;
+      }
+    }
+    throw new IllegalStateException("No available static injection handlers could be found "
+        + "for requested class " + injectedClass.getName());
+  }
+}
/Fim/
/Fim/
diff --git a/core/src/main/java/dagger/internal/StaticInjection.java b/core/src/main/java/dagger/internal/StaticInjection.java
index 7f57380..85e3cbb 100644
--- a/core/src/main/java/dagger/internal/StaticInjection.java
+++ b/core/src/main/java/dagger/internal/StaticInjection.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2012 Square Inc.
+ * Copyright (C) 2012 Google Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,15 +16,6 @@
  */
 package dagger.internal;
 
-import dagger.ObjectGraph;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import javax.inject.Inject;
 
 /**
  * Injects the static fields of a class.
@@ -31,66 +23,9 @@
  * @author Jesse Wilson
  */
 public abstract class StaticInjection {
-  private static final Logger LOGGER = Logger.getLogger(ObjectGraph.class.getName());
 
   public abstract void attach(Linker linker);
 
   public abstract void inject();
 
-  public static StaticInjection get(Class<?> injectedClass) {
-    try {
-      String adapter = injectedClass.getName() + "$StaticInjection";
-      Class<?> c = Class.forName(adapter);
-      Constructor<?> constructor = c.getConstructor();
-      constructor.setAccessible(true);
-      return (StaticInjection) constructor.newInstance();
-    } catch (Exception e) {
-      LOGGER.log(Level.FINE, "No generated static injection for " + injectedClass.getName()
-          + ". Falling back to reflection.", e);
-    }
-
-    List<Field> fields = new ArrayList<Field>();
-    for (Field field : injectedClass.getDeclaredFields()) {
-      if (field.getAnnotation(Inject.class) == null
-          || !Modifier.isStatic(field.getModifiers())) {
-        continue;
-      }
-      field.setAccessible(true);
-      fields.add(field);
-    }
-    if (fields.isEmpty()) {
-      throw new IllegalArgumentException("No static injections: " + injectedClass.getName());
-    }
-    return new ReflectiveStaticInjection(fields.toArray(new Field[fields.size()]));
-  }
-
-  static class ReflectiveStaticInjection extends StaticInjection {
-    private final Field[] fields;
-    private Binding<?>[] bindings;
-
-    private ReflectiveStaticInjection(Field[] fields) {
-      this.fields = fields;
-    }
-
-    @Override
-    public void attach(Linker linker) {
-      bindings = new Binding<?>[fields.length];
-      for (int i = 0; i < fields.length; i++) {
-        Field field = fields[i];
-        String key = Keys.get(field.getGenericType(), field.getAnnotations(), field);
-        bindings[i] = linker.requestBinding(key, field);
-      }
-    }
-
-    @Override
-    public void inject() {
-      try {
-        for (int f = 0; f < fields.length; f++) {
-          fields[f].set(null, bindings[f].get());
-        }
-      } catch (IllegalAccessException e) {
-        throw new AssertionError(e);
-      }
-    }
-  }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/ThrowingErrorHandler.java b/core/src/main/java/dagger/internal/ThrowingErrorHandler.java
new file mode 100644
index 0000000..d17ae7a
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ThrowingErrorHandler.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.List;
+
+/**
+ * Handles errors by throwing an exception containing all the available errors.
+ */
+public final class ThrowingErrorHandler implements Linker.ErrorHandler {
+
+  @Override public void handleErrors(List<String> errors) {
+    if (errors.isEmpty()) {
+      return;
+    }
+    StringBuilder message = new StringBuilder();
+    message.append("Errors creating object graph:");
+    for (String error : errors) {
+      message.append("\n  ").append(error);
+    }
+    throw new IllegalStateException(message.toString());
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java b/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java
new file mode 100644
index 0000000..b9ba40d
--- /dev/null
+++ b/core/src/main/java/dagger/internal/plugins/loading/ClassloadingPlugin.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.plugins.loading;
+
+import dagger.ObjectGraph;
+import dagger.internal.Binding;
+import dagger.internal.ModuleAdapter;
+import dagger.internal.Plugin;
+import dagger.internal.StaticInjection;
+import java.lang.reflect.Constructor;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * A run-time {@code Binding.Resolver} which finds bindings by loading appropriately named adapter
+ * classes.
+ */
+public final class ClassloadingPlugin implements Plugin {
+  private static final Logger LOGGER = Logger.getLogger(ObjectGraph.class.getName());
+
+  public static final String INJECT_ADAPTER_SUFFIX = "$InjectAdapter";
+  public static final String MODULE_ADAPTER_SUFFIX = "$ModuleAdapter";
+  public static final String STATIC_INJECTION_SUFFIX = "$StaticInjection";
+
+  /**
+   * Returns a module adapter loaded from the appropriately named class.
+   */
+  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
+    return instantiate(moduleClass.getName(), MODULE_ADAPTER_SUFFIX, "module");
+  }
+
+  /**
+   * Returns an {@code @Inject} binding loaded from the appropriately named class.
+   */
+  @Override public Binding<?> getAtInjectBinding(String key, String className,
+      boolean mustBeInjectable) throws ClassNotFoundException {
+    return instantiate(className, INJECT_ADAPTER_SUFFIX, "@Inject");
+  }
+
+  /**
+   * Returns a {@code StaticInjection} binding loaded from the appropriately named class.
+   */
+  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
+    return instantiate(injectedClass.getName(), STATIC_INJECTION_SUFFIX, "static injection");
+  }
+
+  private <T> T instantiate(String className, String suffix, String kind) {
+    try {
+      Class<?> c = Class.forName(className + suffix);
+      Constructor<?> constructor = c.getConstructor();
+      constructor.setAccessible(true);
+      return (T) constructor.newInstance();
+    } catch (Exception e) {
+      LOGGER.log(Level.FINE, String.format("No %s adapter for %s found.", kind, className), e);
+      return null;
+    }
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/AtInjectBinding.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
similarity index 92%
rename from core/src/main/java/dagger/internal/AtInjectBinding.java
rename to core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
index cc6cd39..6593e74 100644
--- a/core/src/main/java/dagger/internal/AtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal;
+package dagger.internal.plugins.reflect;
 
+import dagger.internal.Binding;
+import dagger.internal.Keys;
+import dagger.internal.Linker;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
@@ -30,13 +33,13 @@
 /**
  * A runtime binding that injects the constructor and fields of a class.
  */
-final class AtInjectBinding<T> extends Binding<T> {
+public final class ReflectiveAtInjectBinding<T> extends Binding<T> {
   private final Field[] fields;
   private final Constructor<T> constructor;
   private final Class<?> supertype;
   private final String[] keys;
-  private Binding<?>[] fieldBindings;
-  private Binding<?>[] parameterBindings;
+  private final Binding<?>[] fieldBindings;
+  private final Binding<?>[] parameterBindings;
   private Binding<? super T> supertypeBinding;
 
   /**
@@ -47,7 +50,7 @@
    *     supports members injection only.
    * @param supertype the injectable supertype, or null if the supertype is a
    */
-  private AtInjectBinding(String provideKey, String membersKey, boolean singleton, Class<?> type,
+  private ReflectiveAtInjectBinding(String provideKey, String membersKey, boolean singleton, Class<?> type,
       Field[] fields, Constructor<T> constructor, int parameterCount, Class<?> supertype,
       String[] keys) {
     super(provideKey, membersKey, singleton, type);
@@ -59,7 +62,6 @@
     this.fieldBindings = new Binding<?>[fields.length];
   }
 
-  @SuppressWarnings("unchecked") // The linker promises it's safe to cast to Binding<? super T>.
   @Override public void attach(Linker linker) {
     int k = 0;
     for (int i = 0; i < fields.length; i++) {
@@ -211,12 +213,11 @@
     }
 
     String membersKey = Keys.getMembersKey(type);
-    return new AtInjectBinding<T>(provideKey, membersKey, singleton, type,
+    return new ReflectiveAtInjectBinding<T>(provideKey, membersKey, singleton, type,
         injectedFields.toArray(new Field[injectedFields.size()]), injectedConstructor,
         parameterCount, supertype, keys.toArray(new String[keys.size()]));
   }
 
-  @SuppressWarnings("unchecked") // type is Class<T> and can't have other than Constructor<T>
   private static <T> Constructor<T>[] getConstructorsForType(Class<T> type) {
     return (Constructor<T>[]) type.getDeclaredConstructors();
   }
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
new file mode 100644
index 0000000..567e6b8
--- /dev/null
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.plugins.reflect;
+
+import dagger.Module;
+import dagger.OneOf;
+import dagger.Provides;
+import dagger.internal.Binding;
+import dagger.internal.Keys;
+import dagger.internal.Linker;
+import dagger.internal.ModuleAdapter;
+import dagger.internal.SetBinding;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Singleton;
+
+public class ReflectiveModuleAdapter extends ModuleAdapter<Object> {
+  final Class<?> moduleClass;
+
+  public ReflectiveModuleAdapter(Class<?> moduleClass, Module annotation) {
+    super(
+        toKeys(annotation.entryPoints()),
+        annotation.staticInjections(),
+        annotation.overrides(),
+        annotation.includes(),
+        annotation.complete());
+    this.moduleClass = moduleClass;
+  }
+
+  private static String[] toKeys(Class<?>[] entryPoints) {
+    String[] result = new String[entryPoints.length];
+    for (int i = 0; i < entryPoints.length; i++) {
+      result[i] = Keys.get(entryPoints[i]);
+    }
+    return result;
+  }
+
+  @Override public void getBindings(Map<String, Binding<?>> bindings) {
+    // Fall back to runtime reflection.
+    for (Class<?> c = moduleClass; c != Object.class; c = c.getSuperclass()) {
+      for (Method method : c.getDeclaredMethods()) {
+        if (method.isAnnotationPresent(Provides.class)) {
+          String key = Keys.get(method.getGenericReturnType(), method.getAnnotations(), method);
+          if (method.isAnnotationPresent(OneOf.class)) {
+            handleSetBindings(bindings, method, key);
+          } else {
+            handleBindings(bindings, method, key);
+          }
+        }
+      }
+    }
+  }
+
+  private <T> void handleBindings(Map<String, Binding<?>> bindings, Method method, String key) {
+    bindings.put(key, new ProviderMethodBinding<T>(method, key, module));
+  }
+
+  private <T> void handleSetBindings(Map<String, Binding<?>> bindings, Method method, String key) {
+    String elementKey =
+        Keys.getElementKey(method.getGenericReturnType(), method.getAnnotations(), method);
+    SetBinding.<T>add(bindings, elementKey, new ProviderMethodBinding<T>(method, key, module));
+  }
+
+  @Override protected Object newModule() {
+    try {
+      Constructor<?> includeConstructor = moduleClass.getDeclaredConstructor();
+      includeConstructor.setAccessible(true);
+      return includeConstructor.newInstance();
+    } catch (Exception e) {
+      throw new IllegalArgumentException("Unable to instantiate " + moduleClass.getName(), e);
+    }
+  }
+
+  /**
+   * Invokes a method to provide a value. The method's parameters are injected.
+   */
+  private final class ProviderMethodBinding<T> extends Binding<T> {
+    private Binding<?>[] parameters;
+    private final Method method;
+    private final Object instance;
+
+    public ProviderMethodBinding(Method method, String key, Object instance) {
+      super(key, null, method.isAnnotationPresent(Singleton.class), method);
+      this.method = method;
+      this.instance = instance;
+      method.setAccessible(true);
+    }
+
+    @Override public void attach(Linker linker) {
+      Type[] types = method.getGenericParameterTypes();
+      Annotation[][] annotations = method.getParameterAnnotations();
+      parameters = new Binding[types.length];
+      for (int i = 0; i < parameters.length; i++) {
+        String key = Keys.get(types[i], annotations[i], method + " parameter " + i);
+        parameters[i] = linker.requestBinding(key, method);
+      }
+    }
+
+    @Override public T get() {
+      Object[] args = new Object[parameters.length];
+      for (int i = 0; i < parameters.length; i++) {
+        args[i] = parameters[i].get();
+      }
+      try {
+        return (T) method.invoke(instance, args);
+      } catch (IllegalAccessException e) {
+        throw new RuntimeException(e);
+      } catch (InvocationTargetException e) {
+        throw new RuntimeException(e.getCause());
+      }
+    }
+
+    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+      for (Binding<?> binding : parameters) {
+        get.add(binding);
+      }
+    }
+
+    @Override public String toString() {
+      return method.toString();
+    }
+  }
+}
\ No newline at end of file
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
new file mode 100644
index 0000000..e70d4ea
--- /dev/null
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectivePlugin.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.plugins.reflect;
+
+import dagger.Module;
+import dagger.internal.Binding;
+import dagger.internal.ModuleAdapter;
+import dagger.internal.Plugin;
+import dagger.internal.StaticInjection;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.List;
+import javax.inject.Inject;
+
+/**
+ * Resolves a {@code ModuleAdapter<T>} for a given module T
+ */
+public class ReflectivePlugin implements Plugin {
+
+  @Override
+  public Binding<?> getAtInjectBinding(String key, String className, boolean mustBeInjectable)
+      throws ClassNotFoundException {
+    try {
+      Class<?> c = Class.forName(className);
+      if (c.isInterface()) {
+        return null;
+      }
+      return ReflectiveAtInjectBinding.create(c, mustBeInjectable);
+    } catch (Exception ignored) {
+      return null;
+    }
+  }
+
+  /**
+   * Returns a module adapter that processes modules via reflection.
+   */
+  @Override
+  @SuppressWarnings("unchecked") // Runtime checks validate that the result type matches 'T'.
+  public <T> ModuleAdapter<T> getModuleAdapter(Class<? extends T> moduleClass, T module) {
+    Module annotation = moduleClass.getAnnotation(Module.class);
+    if (annotation == null) {
+      // TODO(cgruber): Should we throw, or just return no module adapter?
+      throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
+    }
+    return (ModuleAdapter<T>) new ReflectiveModuleAdapter(moduleClass, annotation);
+  }
+
+  @Override
+  public StaticInjection getStaticInjection(Class<?> injectedClass) {
+    List<Field> fields = new ArrayList<Field>();
+    for (Field field : injectedClass.getDeclaredFields()) {
+      if (field.getAnnotation(Inject.class) == null
+          || !Modifier.isStatic(field.getModifiers())) {
+        continue;
+      }
+      field.setAccessible(true);
+      fields.add(field);
+    }
+    if (fields.isEmpty()) {
+      throw new IllegalArgumentException("No static injections: " + injectedClass.getName());
+    }
+    return new ReflectiveStaticInjection(fields.toArray(new Field[fields.size()]));
+  }
+}
\ No newline at end of file
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveStaticInjection.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveStaticInjection.java
new file mode 100644
index 0000000..0cdb02b
--- /dev/null
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveStaticInjection.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.plugins.reflect;
+
+import dagger.internal.Binding;
+import dagger.internal.Keys;
+import dagger.internal.Linker;
+import dagger.internal.StaticInjection;
+import java.lang.reflect.Field;
+
+/** Performs static injection on a class by means of reflection. */
+public  class ReflectiveStaticInjection extends StaticInjection {
+  private final Field[] fields;
+  private Binding<?>[] bindings;
+
+  public ReflectiveStaticInjection(Field[] fields) {
+    this.fields = fields;
+  }
+
+  @Override public void attach(Linker linker) {
+    bindings = new Binding<?>[fields.length];
+    for (int i = 0; i < fields.length; i++) {
+      Field field = fields[i];
+      String key = Keys.get(field.getGenericType(), field.getAnnotations(), field);
+      bindings[i] = linker.requestBinding(key, field);
+    }
+  }
+
+  @Override public void inject() {
+    try {
+      for (int f = 0; f < fields.length; f++) {
+        fields[f].set(null, bindings[f].get());
+      }
+    } catch (IllegalAccessException e) {
+      throw new AssertionError(e);
+    }
+  }
+}
\ No newline at end of file
/Fim/
diff --git a/example/pom.xml b/example/pom.xml
index 9ad2390..480bbed 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -33,9 +33,24 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
   </dependencies>
+  
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <dependencies>
+          <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>${project.version}</version>
+          </dependency>
+        </dependencies>
+      </plugin>
+    </plugins>
+  </build>
 </project>
/Fim/
diff --git a/pom.xml b/pom.xml
index 3a2920d..81edc56 100644
--- a/pom.xml
+++ b/pom.xml
@@ -38,6 +38,7 @@
     <module>core</module>
     <module>androidmanifest</module>
     <module>example</module>
+    <module>compiler</module>
   </modules>
 
   <properties>
/Fim/
diff --git a/README.md b/README.md
index d47d9c1..bc561df 100644
--- a/README.md
+++ b/README.md
@@ -96,10 +96,10 @@
 
 ### Building the Graph
 
-The `@Inject` and `@Provides`-annotated classes form a graph of objects, linked by their dependencies. Obtain this graph by calling `ObjectGraph.get()`, which accepts one or more modules:
+The `@Inject` and `@Provides`-annotated classes form a graph of objects, linked by their dependencies. Obtain this graph by calling `ObjectGraph.create()`, which accepts one or more modules:
 
 ```java
-ObjectGraph objectGraph = ObjectGraph.get(new DripCoffeeModule());
+ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());
 ```
 
 In order to put the graph to use we need to create an **entry point**. This is usually the main class that starts the application. In this example, the `CoffeeApp` class serves as the entry point. We ask the graph to provide an injected instance of this type:
@@ -113,8 +113,8 @@
   }
 
   public static void main(String[] args) {
-    ObjectGraph objectGraph = ObjectGraph.get(new DripCoffeeModule());
-    CoffeeApp coffeeApp = objectGraph.getInstance(CoffeeApp.class);
+    ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());
+    CoffeeApp coffeeApp = objectGraph.get(CoffeeApp.class);
     ...
   }
 }
@@ -257,7 +257,7 @@
 Use `ObjectGraph.injectStatics()` to populate these static fields with their injected values:
 
 ```java
-ObjectGraph objectGraph = ObjectGraph.get(new LegacyModule());
+ObjectGraph objectGraph = ObjectGraph.create(new LegacyModule());
 objectGraph.injectStatics();
 ```
 
@@ -324,7 +324,7 @@
   @Inject Heater heater;
 
   @Before public void setUp() {
-    ObjectGraph.get(new TestModule()).inject(this);
+    ObjectGraph.create(new TestModule()).inject(this);
   }
 
   @Module(
/Fim/
diff --git a/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java b/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
index 458bbbd..6cd5948 100644
--- a/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
+++ b/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
@@ -29,7 +29,7 @@
   }
 
   public static void main(String[] args) {
-    ObjectGraph.get(new TestModule()).getInstance(TestApp.class).run();
+    ObjectGraph.create(new TestModule()).get(TestApp.class).run();
   }
   
   static class Dependency {
/Fim/
diff --git a/compiler/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java b/compiler/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java
index ed29fea..4723bcc 100644
--- a/compiler/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java
+++ b/compiler/src/it/simple-missing-dependency-failure/src/main/java/test/TestApp.java
@@ -29,7 +29,7 @@
   }
 
   public static void main(String[] args) {
-    ObjectGraph.get(new TestModule()).getInstance(TestApp.class).run();
+    ObjectGraph.create(new TestModule()).get(TestApp.class).run();
   }
   
   static interface Dependency {
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index c3a2891..aea407c 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -86,7 +86,7 @@
    * tools for graph validation, or call {@link #validate} to find problems in
    * the graph at runtime.
    */
-  public static ObjectGraph get(Object... modules) {
+  public static ObjectGraph create(Object... modules) {
 
     RuntimeAggregatingPlugin plugin = new RuntimeAggregatingPlugin(
         new ClassloadingPlugin(), new ReflectivePlugin());
@@ -175,7 +175,7 @@
    * @throws IllegalArgumentException if {@code type} is not one of this object
    *     graph's entry point types.
    */
-  public <T> T getInstance(Class<T> type) {
+  public <T> T get(Class<T> type) {
     String key = Keys.get(type);
     @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
     Binding<T> binding = (Binding<T>) getEntryPointBinding(key, key);
/Fim/
diff --git a/core/src/test/java/dagger/InjectStaticsTest.java b/core/src/test/java/dagger/InjectStaticsTest.java
index c0992ca..18d685a 100644
--- a/core/src/test/java/dagger/InjectStaticsTest.java
+++ b/core/src/test/java/dagger/InjectStaticsTest.java
@@ -44,7 +44,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
     assertThat(InjectsOneField.staticField).isNull();
     graph.injectStatics();
     assertThat(InjectsOneField.staticField).isEqualTo("static");
@@ -63,7 +63,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
     assertThat(InjectsStaticAndNonStatic.staticField).isNull();
     graph.injectStatics();
     assertThat(InjectsStaticAndNonStatic.staticField).isEqualTo("static");
@@ -82,7 +82,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
     assertThat(InjectsStaticAndNonStatic.staticField).isNull();
     InjectsStaticAndNonStatic object = new InjectsStaticAndNonStatic();
     graph.inject(object);
/Fim/
diff --git a/core/src/test/java/dagger/InjectionOfLazyTest.java b/core/src/test/java/dagger/InjectionOfLazyTest.java
index d969b21..5a6c72e 100644
--- a/core/src/test/java/dagger/InjectionOfLazyTest.java
+++ b/core/src/test/java/dagger/InjectionOfLazyTest.java
@@ -125,7 +125,7 @@
 
   private <T> T injectWithModule(T ep, Object ... modules) {
     // TODO(cgruber): Make og.inject(foo) return foo properly.
-    ObjectGraph og = ObjectGraph.get(modules);
+    ObjectGraph og = ObjectGraph.create(modules);
     og.inject(ep);
     return ep;
   }
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index 57166fe..2349045 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -48,7 +48,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    ObjectGraph.create(new TestModule()).inject(entryPoint);
     G g = entryPoint.gProvider.get();
     assertThat(g.a).isNotNull();
     assertThat(g.b).isNotNull();
@@ -107,7 +107,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    ObjectGraph.create(new TestModule()).inject(entryPoint);
 
     assertThat(entryPoint.aProvider.get()).isNotNull();
     assertThat(entryPoint.aProvider.get()).isNotNull();
@@ -129,7 +129,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    ObjectGraph.create(new TestModule()).inject(entryPoint);
     assertThat(entryPoint.fProvider.get()).isSameAs(entryPoint.fProvider.get());
     assertThat(entryPoint.iProvider.get()).isSameAs(entryPoint.iProvider.get());
   }
@@ -160,7 +160,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    ObjectGraph.create(new TestModule()).inject(entryPoint);
     assertThat(entryPoint.a).isNotNull();
     assertThat(one).isSameAs(entryPoint.aOne);
     assertThat(two).isSameAs(entryPoint.aTwo);
@@ -185,7 +185,7 @@
 
     TestEntryPoint entryPoint = new TestEntryPoint();
     TestModule module = new TestModule();
-    ObjectGraph.get(module).inject(entryPoint);
+    ObjectGraph.create(module).inject(entryPoint);
     entryPoint.lProvider.get();
 
     assertThat(module.a1).isNotNull();
@@ -216,7 +216,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    ObjectGraph.create(new TestModule()).inject(entryPoint);
 
     assertThat(entryPoint.f1).isSameAs(entryPoint.f2);
     assertThat(entryPoint.f1).isSameAs(entryPoint.n1.f1);
@@ -242,7 +242,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
     try {
       graph.validate();
       fail();
@@ -263,7 +263,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    ObjectGraph.create(new TestModule()).inject(entryPoint);
     assertThat(entryPoint.q.f).isNotNull();
   }
 
@@ -297,7 +297,7 @@
     R.injected = false;
     TestEntryPoint entryPoint = new TestEntryPoint();
     TestModule module = new TestModule();
-    ObjectGraph.get(module).inject(entryPoint);
+    ObjectGraph.create(module).inject(entryPoint);
 
     assertThat(R.injected).isFalse();
     assertThat(module.sInjected).isFalse();
@@ -325,7 +325,7 @@
     }
 
     try {
-      ObjectGraph.get(new TestModule());
+      ObjectGraph.create(new TestModule());
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -344,7 +344,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    ObjectGraph.create(new TestModule()).inject(entryPoint);
     assertThat(entryPoint.aProvider.get()).isSameAs(entryPoint.aProvider.get());
   }
 
@@ -371,7 +371,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.get(new BaseModule(), new OverridesModule()).inject(entryPoint);
+    ObjectGraph.create(new BaseModule(), new OverridesModule()).inject(entryPoint);
     E e = entryPoint.eProvider.get();
     assertThat(e).isNotNull();
     assertThat(e.f).isNotNull();
@@ -386,7 +386,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
     try {
       graph.validate();
       fail();
@@ -403,7 +403,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
     try {
       graph.validate();
       fail();
@@ -438,7 +438,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    ObjectGraph.create(new TestModule()).inject(entryPoint);
     assertThat(entryPoint.extendsParameterizedType.string).isEqualTo("injected");
   }
 
@@ -455,7 +455,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    ObjectGraph.create(new TestModule()).inject(entryPoint);
     assertThat(entryPoint.listOfStrings).isEqualTo(Arrays.asList("a", "b"));
   }
 
@@ -472,7 +472,7 @@
     }
 
     try {
-      ObjectGraph.get(new TestModule());
+      ObjectGraph.create(new TestModule());
       fail();
     } catch (UnsupportedOperationException expected) {
     }
@@ -494,7 +494,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
     try {
       graph.validate();
       fail();
@@ -507,7 +507,7 @@
     class TestModule {
     }
 
-    ObjectGraph.get(new TestModule());
+    ObjectGraph.create(new TestModule());
   }
 
   @Test public void getInstance() {
@@ -520,9 +520,9 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
-    assertEquals(0, (int) graph.getInstance(Integer.class));
-    assertEquals(1, (int) graph.getInstance(Integer.class));
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    assertEquals(0, (int) graph.get(Integer.class));
+    assertEquals(1, (int) graph.get(Integer.class));
   }
 
   @Test public void getInstanceRequiresEntryPoint() {
@@ -533,9 +533,9 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
     try {
-      graph.getInstance(Integer.class);
+      graph.get(Integer.class);
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -549,8 +549,8 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
-    assertEquals(1, (int) graph.getInstance(int.class));
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    assertEquals(1, (int) graph.get(int.class));
   }
 
   @Test public void getInstanceOfArray() {
@@ -561,8 +561,8 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
-    assertEquals("[1, 2, 3]", Arrays.toString(graph.getInstance(int[].class)));
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    assertEquals("[1, 2, 3]", Arrays.toString(graph.get(int[].class)));
   }
 
   @Test public void getInstanceAndInjectMembersUseDifferentKeys() {
@@ -584,8 +584,8 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
-    BoundTwoWays provided = graph.getInstance(BoundTwoWays.class);
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    BoundTwoWays provided = graph.get(BoundTwoWays.class);
     assertEquals("Pepsi", provided.s);
 
     BoundTwoWays membersInjected = new BoundTwoWays();
@@ -601,7 +601,7 @@
     class TestModule {
     }
 
-    ObjectGraph.get(new TestModule()).validate();
+    ObjectGraph.create(new TestModule()).validate();
   }
 
   @Test public void nonEntryPointNeedsInjectAnnotation() {
@@ -612,7 +612,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
     try {
       graph.validate();
       fail();
/Fim/
diff --git a/core/src/test/java/dagger/LazyInjectionTest.java b/core/src/test/java/dagger/LazyInjectionTest.java
index a16e1a9..c5a3a42 100644
--- a/core/src/test/java/dagger/LazyInjectionTest.java
+++ b/core/src/test/java/dagger/LazyInjectionTest.java
@@ -26,7 +26,7 @@
     class TestModule {
     }
 
-    ObjectGraph.get(new TestModule());
+    ObjectGraph.create(new TestModule());
     assertThat(lazyEntryPointLoaded).isFalse();
   }
 
@@ -45,7 +45,7 @@
       }
     }
 
-    ObjectGraph.get(new TestModule());
+    ObjectGraph.create(new TestModule());
     assertThat(lazyProvidesParameterLoaded).isFalse();
   }
 
@@ -64,7 +64,7 @@
       }
     }
 
-    ObjectGraph.get(new TestModule());
+    ObjectGraph.create(new TestModule());
     assertThat(lazyProvidesResultLoaded).isFalse();
   }
 
@@ -80,7 +80,7 @@
     class TestModule {
     }
 
-    ObjectGraph.get(new TestModule());
+    ObjectGraph.create(new TestModule());
     assertThat(LazyInjectStaticsLoaded).isFalse();
   }
 
@@ -106,7 +106,7 @@
       }
     }
 
-    ObjectGraph objectGraph = ObjectGraph.get(new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
     TestEntryPoint entryPoint = new TestEntryPoint();
     objectGraph.inject(entryPoint);
     assertThat(entryPoint.injected).isEqualTo("5");
/Fim/
diff --git a/core/src/test/java/dagger/MembersInjectorTest.java b/core/src/test/java/dagger/MembersInjectorTest.java
index d659f1e..59f2883 100644
--- a/core/src/test/java/dagger/MembersInjectorTest.java
+++ b/core/src/test/java/dagger/MembersInjectorTest.java
@@ -41,7 +41,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.get(new StringModule()).inject(entryPoint);
+    ObjectGraph.create(new StringModule()).inject(entryPoint);
     Injectable injectable = new Injectable();
     entryPoint.membersInjector.injectMembers(injectable);
     assertThat(injectable.injected).isEqualTo("injected");
@@ -72,7 +72,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.get(new StringModule()).inject(entryPoint);
+    ObjectGraph.create(new StringModule()).inject(entryPoint);
     Unconstructable object = new Unconstructable("constructor");
     entryPoint.membersInjector.injectMembers(object);
     assertThat(object.constructor).isEqualTo("constructor");
@@ -89,9 +89,9 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
     try {
-      graph.getInstance(TestEntryPoint.class);
+      graph.get(TestEntryPoint.class);
       fail();
     } catch (IllegalStateException expected) {
     }
@@ -106,9 +106,9 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
     try {
-      graph.getInstance(TestEntryPoint.class);
+      graph.get(TestEntryPoint.class);
       fail();
     } catch (IllegalStateException expected) {
     }
@@ -123,9 +123,9 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
     try {
-      graph.getInstance(TestEntryPoint.class);
+      graph.get(TestEntryPoint.class);
       fail();
     } catch (IllegalStateException expected) {
     }
@@ -157,7 +157,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    ObjectGraph.create(new TestModule()).inject(entryPoint);
     NonStaticInner nonStaticInner = new NonStaticInner();
     entryPoint.membersInjector.injectMembers(nonStaticInner);
     assertThat(nonStaticInner.injected).isEqualTo("injected");
@@ -172,9 +172,9 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
     try {
-      graph.getInstance(TestEntryPoint.class);
+      graph.get(TestEntryPoint.class);
       fail();
     } catch (IllegalStateException expected) {
     }
@@ -203,7 +203,7 @@
     }
 
     TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.get(new TestModule()).inject(entryPoint);
+    ObjectGraph.create(new TestModule()).inject(entryPoint);
 
     InjectsString provided = entryPoint.provider.get();
     assertThat(provided.value).isEqualTo("provides");
/Fim/
diff --git a/core/src/test/java/dagger/ModuleIncludesTest.java b/core/src/test/java/dagger/ModuleIncludesTest.java
index 135cbf3..2ed6ea7 100644
--- a/core/src/test/java/dagger/ModuleIncludesTest.java
+++ b/core/src/test/java/dagger/ModuleIncludesTest.java
@@ -38,8 +38,8 @@
       }
     }
 
-    ObjectGraph objectGraph = ObjectGraph.get(new TestModule());
-    TestEntryPoint entryPoint = objectGraph.getInstance(TestEntryPoint.class);
+    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
+    TestEntryPoint entryPoint = objectGraph.get(TestEntryPoint.class);
     assertThat(entryPoint.s).isEqualTo("injected");
   }
 
@@ -59,7 +59,7 @@
       }
     }
 
-    ObjectGraph objectGraph = ObjectGraph.get(new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
     TestStaticInjection.s = null;
     objectGraph.injectStatics();
     assertThat(TestStaticInjection.s).isEqualTo("injected");
@@ -84,7 +84,7 @@
     class TestModule {
     }
 
-    ObjectGraph objectGraph = ObjectGraph.get(new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
     TestEntryPoint entryPoint = new TestEntryPoint();
     objectGraph.inject(entryPoint);
     assertThat(entryPoint.s).isEqualTo("injected");
@@ -106,7 +106,7 @@
     class TestModule {
     }
 
-    ObjectGraph objectGraph = ObjectGraph.get(new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.create(new TestModule());
     TestEntryPoint entryPoint = new TestEntryPoint();
     objectGraph.inject(entryPoint);
     assertThat(entryPoint.s).isEqualTo("injected");
@@ -131,7 +131,7 @@
     }
 
     try {
-      ObjectGraph.get(new TestModule());
+      ObjectGraph.create(new TestModule());
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -149,7 +149,7 @@
     class TestModule {
     }
 
-    ObjectGraph objectGraph = ObjectGraph.get(new ModuleWithConstructor("a"), new TestModule());
+    ObjectGraph objectGraph = ObjectGraph.create(new ModuleWithConstructor("a"), new TestModule());
     TestEntryPoint entryPoint = new TestEntryPoint();
     objectGraph.inject(entryPoint);
     assertThat(entryPoint.s).isEqualTo("a");
/Fim/
diff --git a/core/src/test/java/dagger/ProblemDetectorTest.java b/core/src/test/java/dagger/ProblemDetectorTest.java
index 003f2f9..2bd7585 100644
--- a/core/src/test/java/dagger/ProblemDetectorTest.java
+++ b/core/src/test/java/dagger/ProblemDetectorTest.java
@@ -30,7 +30,7 @@
     class TestModule {
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
     try {
       graph.validate();
       fail();
@@ -49,7 +49,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
     try {
       graph.validate();
       fail();
@@ -68,7 +68,7 @@
       }
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
     graph.validate();
   }
 
/Fim/
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index 4d07c82..d6accc3 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -104,7 +104,7 @@
       @Provides @OneOf Integer b() { return defaultCounter.getAndIncrement(); }
     }
 
-    ObjectGraph graph = ObjectGraph.get(new TestModule());
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
     TestEntryPoint1 ep1 = new TestEntryPoint1();
     graph.inject(ep1);
     TestEntryPoint2 ep2 = new TestEntryPoint2();
@@ -196,7 +196,7 @@
 
   private <T> T injectWithModule(T ep, Object ... modules) {
     // TODO(cgruber): Make og.inject(foo) return foo properly.
-    ObjectGraph og = ObjectGraph.get(modules);
+    ObjectGraph og = ObjectGraph.create(modules);
     og.inject(ep);
     return ep;
   }
/Fim/
diff --git a/example/src/main/java/coffee/CoffeeApp.java b/example/src/main/java/coffee/CoffeeApp.java
index 0553308..4e23e3c 100644
--- a/example/src/main/java/coffee/CoffeeApp.java
+++ b/example/src/main/java/coffee/CoffeeApp.java
@@ -1,8 +1,9 @@
 package coffee;
 
-import dagger.ObjectGraph;
 import javax.inject.Inject;
 
+import dagger.ObjectGraph;
+
 class CoffeeApp implements Runnable {
   @Inject CoffeeMaker coffeeMaker;
 
@@ -11,8 +12,8 @@
   }
 
   public static void main(String[] args) {
-    ObjectGraph objectGraph = ObjectGraph.get(new DripCoffeeModule());
-    CoffeeApp coffeeApp = objectGraph.getInstance(CoffeeApp.class);
+    ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());
+    CoffeeApp coffeeApp = objectGraph.get(CoffeeApp.class);
     coffeeApp.run();
   }
 }
/Fim/
diff --git a/README.md b/README.md
index bc561df..4879bc9 100644
--- a/README.md
+++ b/README.md
@@ -163,7 +163,7 @@
 
 ### Lazy injections
 
-Sometimes you need to make a dependency lazily created.  For any binding `T`, you can create a `Lazy<T>` which defers instantiation until the first call to `Lazy<T>`'s `get()` method. If `T` is a singleton, then `Lazy<T>` will be the same instance for all injections within the ObjectGraph.  Otherwise, each injection site will get its own `Lazy<T>` instance.  Regardless, subsequent calls to any given instance of `Lazy<T>` will return the same underlying instance of `T`.
+Sometimes you need an object to be instantiated lazily.  For any binding `T`, you can create a `Lazy<T>` which defers instantiation until the first call to `Lazy<T>`'s `get()` method. If `T` is a singleton, then `Lazy<T>` will be the same instance for all injections within the `ObjectGraph`.  Otherwise, each injection site will get its own `Lazy<T>` instance.  Regardless, subsequent calls to any given instance of `Lazy<T>` will return the same underlying instance of `T`.
 
 ```java
 class GridingCoffeeMaker {
@@ -216,7 +216,7 @@
 }
 ```
 
-Create your own qualifier annotations just use `@Named`. Apply qualifiers by annotating the field or parameter of interest. The type and qualifier annotation will both be used to identify the dependency.
+You can create your own qualifier annotations, or just use `@Named`. Apply qualifiers by annotating the field or parameter of interest. The type and qualifier annotation will both be used to identify the dependency.
 
 ```java
 class ExpensiveCoffeeMaker {
@@ -282,7 +282,7 @@
                required by provideHeater(java.util.concurrent.Executor)
 ```
 
-Fix the problem either by adding the an `@Provides`-annotated method for `Executor`, or by marking the module as incomplete. Incomplete modules are permitted to have missing dependencies.
+Fix the problem either by adding an `@Provides`-annotated method for `Executor`, or by marking the module as incomplete. Incomplete modules are permitted to have missing dependencies.
 
 ```java
 @Module(complete = false)
@@ -358,7 +358,7 @@
 Using Dagger in your build
 ==========================
 
-You will need to include the dagger-${dagger.version}.jar in your application's runtime.  In order to activate code generation you will need to include dagger-compiler-${dagger.version}.jar in your build at compile time. 
+You will need to include the `dagger-${dagger.version}.jar` in your application's runtime.  In order to activate code generation you will need to include `dagger-compiler-${dagger.version}.jar` in your build at compile time. 
 
 In a Maven project, one would include the runtime in the dependencies section of your `pom.xml` (replacing ${dagger.version} with the appropriate current release), and the dagger-compiler artifact as a dependency of the compiler plugin: 
 
/Fim/
diff --git a/compiler/src/it/extension-graph/pom.xml b/compiler/src/it/extension-graph/pom.xml
new file mode 100644
index 0000000..e3327b5
--- /dev/null
+++ b/compiler/src/it/extension-graph/pom.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2012 Square, Inc.
+ Copyright (C) 2012 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.squareup.dagger.tests</groupId>
+  <artifactId>extension-graph</artifactId>
+  <version>@dagger.version@</version>
+  <packaging>jar</packaging>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <scope>provided</scope>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/extension-graph/src/main/java/test/TestApp.java b/compiler/src/it/extension-graph/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..ddebdfe
--- /dev/null
+++ b/compiler/src/it/extension-graph/src/main/java/test/TestApp.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2012 Google, Inc.
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.ObjectGraph;
+import dagger.Module;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+class TestApp implements Runnable {
+  @Inject C c;
+
+  @Override public void run() {
+    c.doit();
+  }
+
+  public static void main(String[] args) {
+    ObjectGraph root = ObjectGraph.create(new RootModule());
+    ObjectGraph extension = root.extend(new ExtensionModule());
+    extension.get(TestApp.class).run();
+  }
+  
+  @Module(entryPoints = { A.class, B.class })
+  static class RootModule { }
+
+  @Module(augments=RootModule.class, entryPoints = { C.class, TestApp.class })
+  static class ExtensionModule { }
+
+  @Singleton
+  static class A {
+    @Inject A() {}
+  }
+
+  static class B {
+    @Inject A a;
+    @Inject B() {}
+  }
+
+  static class C {
+    @Inject A a;
+    @Inject B b;
+    @Inject C() {}
+    public void doit() {};
+  }
+}
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index e358b73..11640d2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -23,7 +23,10 @@
 import dagger.internal.SetBinding;
 import java.io.IOException;
 import java.io.Writer;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
@@ -78,7 +81,7 @@
     Map<String, TypeElement> allModules = new LinkedHashMap<String, TypeElement>();
     collectIncludesRecursively(rootModule, allModules);
 
-    Linker linker = new Linker(new CompileTimePlugin(processingEnv),
+    Linker linker = new Linker(null, new CompileTimePlugin(processingEnv),
         new ReportingErrorHandler(processingEnv, rootModule.getQualifiedName().toString()));
     Map<String, Binding<?>> baseBindings = new LinkedHashMap<String, Binding<?>>();
     Map<String, Binding<?>> overrideBindings = new LinkedHashMap<String, Binding<?>>();
@@ -139,8 +142,10 @@
     // Recurse for each included module.
     Types typeUtils = processingEnv.getTypeUtils();
     Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
-    Object[] includes = (Object[]) annotation.get("includes");
-    for (Object include : includes) {
+    List<Object> seedModules = new ArrayList<Object>();
+    seedModules.addAll(Arrays.asList((Object[]) annotation.get("includes")));
+    if (!annotation.get("augments").equals(Void.class)) seedModules.add(annotation.get("augments"));
+    for (Object include : seedModules) {
       if (!(include instanceof TypeMirror)) {
         processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
             "Unexpected value for include: " + include + " in " + module);
/Fim/
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
index 05292d0..4263481 100644
--- a/core/src/main/java/dagger/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -46,10 +46,18 @@
   Class<?>[] includes() default { };
 
   /**
+   * An optional, {@code @Module}-annotated class whose abstract object graph
+   * this module extends.  At run-time, this module should be supplied to an
+   * existing graph to extend it with {@link ObjectGraph#extend(Object...)}
+   */
+  Class<?> augments() default Void.class;
+
+  /**
    * True if all of the bindings required by this module can also be satisfied
    * by this module. If a module is complete it is eligible for additional
    * static checking: tools can detect if required bindings are not available.
    * Modules that have external dependencies must use {@code complete = false}.
    */
   boolean complete() default true;
+
 }
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index aea407c..d837d31 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -31,6 +31,8 @@
 import java.util.LinkedHashMap;
 import java.util.Map;
 
+import static dagger.internal.RuntimeAggregatingPlugin.getAllModuleAdapters;
+
 /**
  * A graph of objects linked by their dependencies.
  *
@@ -59,15 +61,23 @@
  * </ul>
  */
 public final class ObjectGraph {
+  private final ObjectGraph augmented;
   private final Linker linker;
   private final Map<Class<?>, StaticInjection> staticInjections;
   private final Map<String, Class<?>> entryPoints;
   private final Plugin plugin;
 
-  ObjectGraph(Linker linker,
+  ObjectGraph(ObjectGraph augmented,
+      Linker linker,
       Plugin plugin,
       Map<Class<?>, StaticInjection> staticInjections,
       Map<String, Class<?>> entryPoints) {
+    if (linker == null) throw new NullPointerException("linker");
+    if (plugin == null) throw new NullPointerException("plugin");
+    if (staticInjections == null) throw new NullPointerException("staticInjections");
+    if (entryPoints == null) throw new NullPointerException("entryPoints");
+
+    this.augmented = augmented;
     this.linker = linker;
     this.plugin = plugin;
     this.staticInjections = staticInjections;
@@ -79,19 +89,21 @@
    * Module}-annotated modules.
    *
    * <p>This <strong>does not</strong> inject any members. Most applications
-   * should call {@link #injectStatics} to inject static members and/or {@link
-   * #inject} to inject instance members when this method has returned.
+   * should call {@link #injectStatics} to inject static members and {@link
+   * #inject} or get {@link #get(Class)} to inject instance members when this
+   * method has returned.
    *
    * <p>This <strong>does not</strong> validate the graph. Rely on build time
    * tools for graph validation, or call {@link #validate} to find problems in
    * the graph at runtime.
    */
   public static ObjectGraph create(Object... modules) {
-
     RuntimeAggregatingPlugin plugin = new RuntimeAggregatingPlugin(
-        new ClassloadingPlugin(), new ReflectivePlugin());
+            new ClassloadingPlugin(), new ReflectivePlugin());
+    return makeGraph(null, plugin, modules);
+  }
 
-    ModuleAdapter<?>[] moduleAdapters = plugin.getAllModuleAdapters(modules);
+  private static ObjectGraph makeGraph(ObjectGraph root, Plugin plugin, Object... modules) {
 
     Map<String, Class<?>> entryPoints = new LinkedHashMap<String, Class<?>>();
     Map<Class<?>, StaticInjection> staticInjections
@@ -101,25 +113,42 @@
     // duplicates are permitted.
     Map<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>();
     Map<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>();
-    for (ModuleAdapter<?> adapter : moduleAdapters) {
-      for (String key : adapter.entryPoints) {
-        entryPoints.put(key, adapter.getModule().getClass());
+    for (ModuleAdapter<?> moduleAdapter : getAllModuleAdapters(plugin, modules).values()) {
+      for (String key : moduleAdapter.entryPoints) {
+        entryPoints.put(key, moduleAdapter.getModule().getClass());
       }
-      for (Class<?> c : adapter.staticInjections) {
+      for (Class<?> c : moduleAdapter.staticInjections) {
         staticInjections.put(c, null);
       }
-      Map<String, Binding<?>> addTo = adapter.overrides ? overrideBindings : baseBindings;
-      adapter.getBindings(addTo);
+      Map<String, Binding<?>> addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
+      moduleAdapter.getBindings(addTo);
     }
 
     // Create a linker and install all of the user's bindings
-    Linker linker = new Linker(plugin, new ThrowingErrorHandler());
+    Linker linker = new Linker((root != null) ? root.linker : null, plugin,
+        new ThrowingErrorHandler());
     linker.installBindings(baseBindings);
     linker.installBindings(overrideBindings);
 
-    return new ObjectGraph(linker, plugin, staticInjections, entryPoints);
+    return new ObjectGraph(root, linker, plugin, staticInjections, entryPoints);
   }
 
+  /**
+   * Returns a new object graph which delegates any dependency satisfaction that
+   * it cannot perform to the graph it extends, based on supplied
+   * {@code @Module} annotated objects.
+   *
+   * <p>
+   * This <strong>does not</strong> validate the graph. Rely on build time tools
+   * for graph validation, or call {@link #validate} to find problems in the
+   * graph at runtime.
+   */
+  public ObjectGraph extend(Object... modules) {
+    linker.linkAll();
+    return makeGraph(this, plugin, modules);
+  }
+
+
   private void linkStaticInjections() {
     for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
       StaticInjection staticInjection = entry.getValue();
@@ -204,7 +233,10 @@
    *     regular (provider) key or a members key.
    */
   private Binding<?> getEntryPointBinding(String entryPointKey, String key) {
-    Class<?> moduleClass = entryPoints.get(entryPointKey);
+    Class<?> moduleClass = null;
+    for (ObjectGraph node = this; moduleClass == null && node != null; node = node.augmented) {
+      moduleClass = node.entryPoints.get(entryPointKey);
+    }
     if (moduleClass == null) {
       throw new IllegalArgumentException("No entry point for " + entryPointKey
           + ". You must explicitly add an entry point to one of your modules.");
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 096ceca..4d125f3 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -29,6 +29,13 @@
 public final class Linker {
   private static final Object UNINITIALIZED = new Object();
 
+  /**
+   * The root {@code Linker} which will be consulted to satisfy bindings not
+   * otherwise satisfiable from this {@code Linker}. The top-most {@code Linker}
+   * in a chain will have a null root linker.
+   */
+  private final Linker root;
+
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
   private final Queue<Binding<?>> toLink = new LinkedList<Binding<?>>();
 
@@ -45,7 +52,11 @@
 
   private final ErrorHandler errorHandler;
 
-  public Linker(Plugin plugin, ErrorHandler errorHandler) {
+  public Linker(Linker root, Plugin plugin, ErrorHandler errorHandler) {
+    if (plugin == null) throw new NullPointerException("plugin");
+    if (errorHandler == null) throw new NullPointerException("errorHandler");
+
+    this.root = root;
     this.plugin = plugin;
     this.errorHandler = errorHandler;
   }
@@ -179,7 +190,10 @@
   }
 
   private Binding<?> requestBinding(String key, boolean mustBeInjectable, Object requiredBy) {
-    Binding<?> binding = bindings.get(key);
+    Binding<?> binding = null;
+    for (Linker node = this; binding == null && node != null; node = node.root) {
+      binding = node.bindings.get(key);
+    }
     if (binding == null) {
       // We can't satisfy this binding. Make sure it'll work next time!
       Binding<?> deferredBinding = new DeferredBinding(key, requiredBy, mustBeInjectable);
/Fim/
diff --git a/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java b/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
index d234e29..4de098d 100644
--- a/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
+++ b/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
@@ -39,12 +39,12 @@
    * Returns a full set of module adapters, including module adapters for included
    * modules.
    */
-  public ModuleAdapter<?>[] getAllModuleAdapters(Object[] seedModules) {
+  public static Map<Class<?>, ModuleAdapter<?>> getAllModuleAdapters(Plugin plugin, Object[] seedModules) {
     // Create a module adapter for each seed module.
     ModuleAdapter<?>[] seedAdapters = new ModuleAdapter<?>[seedModules.length];
     int s = 0;
     for (Object module : seedModules) {
-      seedAdapters[s++] = getModuleAdapter(module.getClass(), module);
+      seedAdapters[s++] = plugin.getModuleAdapter(module.getClass(), module);
     }
 
     Map<Class<?>, ModuleAdapter<?>> adaptersByModuleType
@@ -59,24 +59,23 @@
     // Next add adapters for the modules that we need to construct. This creates
     // instances of modules as necessary.
     for (ModuleAdapter<?> adapter : seedAdapters) {
-      collectIncludedModulesRecursively(adapter, adaptersByModuleType);
+      collectIncludedModulesRecursively(plugin, adapter, adaptersByModuleType);
     }
 
-    return adaptersByModuleType.values().toArray(
-        new ModuleAdapter<?>[adaptersByModuleType.size()]);
+    return adaptersByModuleType;
   }
 
   /**
    * Fills {@code result} with the module adapters for the includes of {@code
    * adapter}, and their includes recursively.
    */
-  private void collectIncludedModulesRecursively(ModuleAdapter<?> adapter,
+  private static void collectIncludedModulesRecursively(Plugin plugin, ModuleAdapter<?> adapter,
       Map<Class<?>, ModuleAdapter<?>> result) {
     for (Class<?> include : adapter.includes) {
       if (!result.containsKey(include)) {
-        ModuleAdapter<Object> includedModuleAdapter = getModuleAdapter(include, null);
+        ModuleAdapter<Object> includedModuleAdapter = plugin.getModuleAdapter(include, null);
         result.put(include, includedModuleAdapter);
-        collectIncludedModulesRecursively(includedModuleAdapter, result);
+        collectIncludedModulesRecursively(plugin, includedModuleAdapter, result);
       }
     }
   }
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
index 567e6b8..ee38ce4 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
@@ -80,10 +80,17 @@
   }
 
   @Override protected Object newModule() {
+    if (moduleClass.isInterface()) {
+      throw new IllegalStateException(moduleClass.getSimpleName() + " is an interface.");
+    }
     try {
-      Constructor<?> includeConstructor = moduleClass.getDeclaredConstructor();
-      includeConstructor.setAccessible(true);
-      return includeConstructor.newInstance();
+      try {
+        Constructor<?> includeConstructor = moduleClass.getDeclaredConstructor();
+        includeConstructor.setAccessible(true);
+        return includeConstructor.newInstance();
+      } catch (NoSuchMethodException e) {
+        return moduleClass.newInstance();
+      }
     } catch (Exception e) {
       throw new IllegalArgumentException("Unable to instantiate " + moduleClass.getName(), e);
     }
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionTest.java b/core/src/test/java/dagger/ExtensionTest.java
new file mode 100644
index 0000000..24c65ad
--- /dev/null
+++ b/core/src/test/java/dagger/ExtensionTest.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2012 Google Inc.
+ * Copyright (C) 2012 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import java.util.Arrays;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+import static org.junit.Assert.assertNotNull;
+
+public final class ExtensionTest {
+  @Singleton
+  static class A {
+    @Inject A() {}
+  }
+
+  static class B {
+    @Inject A a;
+  }
+
+  @Singleton
+  static class C {
+    @Inject A a;
+    @Inject B b;
+  }
+
+  static class D {
+    @Inject A a;
+    @Inject B b;
+    @Inject C c;
+  }
+
+  @Module(entryPoints = { A.class, B.class }) static class RootModule { }
+
+  @Module(augments = RootModule.class, entryPoints = { C.class, D.class })
+  static class ExtensionModule { }
+
+  @Test public void basicExtension() {
+    assertNotNull(ObjectGraph.create(new RootModule()).extend(new ExtensionModule()));
+  }
+
+  @Test public void basicInjection() {
+    ObjectGraph root = ObjectGraph.create(new RootModule());
+    assertThat(root.get(A.class)).isNotNull();
+    assertThat(root.get(A.class)).isSameAs(root.get(A.class)); // Present and Singleton.
+    assertThat(root.get(B.class)).isNotSameAs(root.get(B.class)); // Not singleton.
+    assertFailNoEntryPoint(root, C.class); // Not declared in RootModule.
+    assertFailNoEntryPoint(root, D.class); // Not declared in RootModule.
+
+    // Extension graph behaves as the root graph would for root-ish things.
+    ObjectGraph extension = root.extend(new ExtensionModule());
+    assertThat(root.get(A.class)).isSameAs(extension.get(A.class));
+    assertThat(root.get(B.class)).isNotSameAs(extension.get(B.class));
+    assertThat(root.get(B.class).a).isSameAs(extension.get(B.class).a);
+
+    assertThat(extension.get(C.class).a).isNotNull();
+    assertThat(extension.get(D.class).c).isNotNull();
+  }
+
+  @Test public void scopedGraphs() {
+    ObjectGraph app = ObjectGraph.create(new RootModule());
+    assertThat(app.get(A.class)).isNotNull();
+    assertThat(app.get(A.class)).isSameAs(app.get(A.class));
+    assertThat(app.get(B.class)).isNotSameAs(app.get(B.class));
+    assertFailNoEntryPoint(app, C.class);
+    assertFailNoEntryPoint(app, D.class);
+
+    ObjectGraph request1 = app.extend(new ExtensionModule());
+    ObjectGraph request2 = app.extend(new ExtensionModule());
+    for (ObjectGraph request : Arrays.asList(request1, request2)) {
+      assertThat(request.get(A.class)).isNotNull();
+      assertThat(request.get(A.class)).isSameAs(request.get(A.class));
+      assertThat(request.get(B.class)).isNotSameAs(request.get(B.class));
+      assertThat(request.get(C.class)).isNotNull();
+      assertThat(request.get(C.class)).isSameAs(request.get(C.class));
+      assertThat(request.get(D.class)).isNotSameAs(request.get(D.class));
+    }
+
+    // Singletons are one-per-graph-instance where they are declared.
+    assertThat(request1.get(C.class)).isNotSameAs(request2.get(C.class));
+    // Singletons that come from common roots should be one-per-common-graph-instance.
+    assertThat(request1.get(C.class).a).isSameAs(request2.get(C.class).a);
+  }
+
+  private void assertFailNoEntryPoint(ObjectGraph graph, Class<?> clazz) {
+    try {
+      assertThat(graph.get(clazz)).isNull();
+    } catch (IllegalArgumentException e) {
+      assertThat(e.getMessage()).contains("No entry point");
+    }
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java b/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
index 4de098d..886f39b 100644
--- a/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
+++ b/core/src/main/java/dagger/internal/RuntimeAggregatingPlugin.java
@@ -39,12 +39,17 @@
    * Returns a full set of module adapters, including module adapters for included
    * modules.
    */
-  public static Map<Class<?>, ModuleAdapter<?>> getAllModuleAdapters(Plugin plugin, Object[] seedModules) {
+  public static Map<Class<?>, ModuleAdapter<?>> getAllModuleAdapters(Plugin plugin,
+      Object[] seedModules) {
     // Create a module adapter for each seed module.
     ModuleAdapter<?>[] seedAdapters = new ModuleAdapter<?>[seedModules.length];
     int s = 0;
     for (Object module : seedModules) {
-      seedAdapters[s++] = plugin.getModuleAdapter(module.getClass(), module);
+      if (module instanceof Class) {
+        seedAdapters[s++] = plugin.getModuleAdapter((Class<?>) module, null); // Plugin constructs.
+      } else {
+        seedAdapters[s++] = plugin.getModuleAdapter(module.getClass(), module);
+      }
     }
 
     Map<Class<?>, ModuleAdapter<?>> adaptersByModuleType
/Fim/
diff --git a/core/src/test/java/dagger/ModuleIncludesTest.java b/core/src/test/java/dagger/ModuleIncludesTest.java
index 2ed6ea7..b72f2e9 100644
--- a/core/src/test/java/dagger/ModuleIncludesTest.java
+++ b/core/src/test/java/dagger/ModuleIncludesTest.java
@@ -154,4 +154,27 @@
     objectGraph.inject(entryPoint);
     assertThat(entryPoint.s).isEqualTo("a");
   }
+
+  static class A {}
+
+  static class B { @Inject A a; }
+
+  @Module(entryPoints = A.class) public static class TestModuleA {
+    @Provides A a() { return new A(); }
+  }
+
+  @Module(includes = TestModuleA.class, entryPoints = B.class) public static class TestModuleB {}
+
+  @Test public void autoInstantiationOfModules() {
+    // Have to make these non-method-scoped or instantiation errors occur.
+    ObjectGraph objectGraph = ObjectGraph.create(TestModuleA.class);
+    assertThat(objectGraph.get(A.class)).isNotNull();
+  }
+
+  @Test public void autoInstantiationOfIncludedModules() {
+    // Have to make these non-method-scoped or instantiation errors occur.
+    ObjectGraph objectGraph = ObjectGraph.create(new TestModuleB()); // TestModuleA auto-created.
+    assertThat(objectGraph.get(A.class)).isNotNull();
+    assertThat(objectGraph.get(B.class).a).isNotNull();
+  }
 }
/Fim/
diff --git a/compiler/src/it/same-provides-method-name/invoker.properties b/compiler/src/it/same-provides-method-name/invoker.properties
new file mode 100644
index 0000000..039b1ae
--- /dev/null
+++ b/compiler/src/it/same-provides-method-name/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=success
\ No newline at end of file
/Fim/
diff --git a/compiler/src/it/same-provides-method-name/pom.xml b/compiler/src/it/same-provides-method-name/pom.xml
new file mode 100644
index 0000000..abbe33d
--- /dev/null
+++ b/compiler/src/it/same-provides-method-name/pom.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2012 Square, Inc.
+ Copyright (C) 2012 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.squareup.dagger.tests</groupId>
+  <artifactId>same-provides-method-name</artifactId>
+  <version>@dagger.version@</version>
+  <packaging>jar</packaging>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <scope>provided</scope>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/same-provides-method-name/src/main/java/test/TestApp.java b/compiler/src/it/same-provides-method-name/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..200b3d2
--- /dev/null
+++ b/compiler/src/it/same-provides-method-name/src/main/java/test/TestApp.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2012 Google, Inc.
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+
+import dagger.ObjectGraph;
+import dagger.Provides;
+
+import javax.inject.Inject;
+import java.lang.Override;
+
+class TestApp implements Runnable {
+
+  @Inject Foo foo;
+
+  @Override public void run() {
+    // Yay! \o/
+  }
+
+  public static void main(String[] args) {
+    ObjectGraph.create(new TestModule()).get(TestApp.class).run();
+  }
+
+  static class Foo {
+  }
+
+  static class MyFoo extends Foo {
+  }
+
+  @Module(entryPoints = TestApp.class)
+  static class TestModule {
+
+    @Provides Foo providesFoo(MyFoo foo) {
+      return foo;
+    }
+
+    @Provides MyFoo providesFoo() {
+      return new MyFoo();
+    }
+  }
+}
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 16416b4..a0a404a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -22,13 +22,7 @@
 import dagger.internal.Linker;
 import dagger.internal.ModuleAdapter;
 import dagger.internal.SetBinding;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
+
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
@@ -44,6 +38,15 @@
 import javax.lang.model.type.TypeMirror;
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import static dagger.internal.plugins.loading.ClassloadingPlugin.MODULE_ADAPTER_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
@@ -200,15 +203,19 @@
 
     writer.annotation(Override.class);
     writer.beginMethod("void", "getBindings", PUBLIC, BINDINGS_MAP, "map");
+
+    Map<ExecutableElement, String> methodToClassName
+        = new LinkedHashMap<ExecutableElement, String>();
+    Map<String, AtomicInteger> methodNameToNextId = new LinkedHashMap<String, AtomicInteger>();
     for (ExecutableElement providerMethod : providerMethods) {
       if (providerMethod.getAnnotation(OneOf.class) != null) {
         String key = GeneratorKeys.getElementKey(providerMethod);
         writer.statement("SetBinding.add(map, %s, new %s(module))", JavaWriter.stringLiteral(key),
-            bindingClassName(providerMethod));
+            bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
       } else {
         String key = GeneratorKeys.get(providerMethod);
         writer.statement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
-            bindingClassName(providerMethod));
+            bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
       }
     }
     writer.endMethod();
@@ -225,25 +232,42 @@
     writer.endMethod();
 
     for (ExecutableElement providerMethod : providerMethods) {
-      writeBindingClass(writer, providerMethod);
+      writeBindingClass(writer, providerMethod, methodToClassName, methodNameToNextId);
     }
 
     writer.endType();
     writer.close();
   }
 
-  private String bindingClassName(ExecutableElement providerMethod) {
+  private String bindingClassName(ExecutableElement providerMethod,
+      Map<ExecutableElement, String> methodToClassName,
+      Map<String, AtomicInteger> methodNameToNextId) {
+    String className = methodToClassName.get(providerMethod);
+    if (className != null) return className;
+
     String methodName = providerMethod.getSimpleName().toString();
-    String uppercaseMethodName = Character.toUpperCase(methodName.charAt(0)) + methodName.substring(1);
-    String className = uppercaseMethodName + "Binding";
+    String suffix = "";
+    AtomicInteger id = methodNameToNextId.get(methodName);
+    if (id == null) {
+      methodNameToNextId.put(methodName, new AtomicInteger(2));
+    } else {
+      suffix = id.toString();
+      id.incrementAndGet();
+    }
+    String uppercaseMethodName = Character.toUpperCase(methodName.charAt(0))
+        + methodName.substring(1);
+    className = uppercaseMethodName + "Binding" + suffix;
+    methodToClassName.put(providerMethod, className);
     return className;
   }
 
-  private void writeBindingClass(JavaWriter writer, ExecutableElement providerMethod)
+  private void writeBindingClass(JavaWriter writer, ExecutableElement providerMethod,
+      Map<ExecutableElement, String> methodToClassName,
+      Map<String, AtomicInteger> methodNameToNextId)
       throws IOException {
     String methodName = providerMethod.getSimpleName().toString();
     String moduleType = CodeGen.typeToString(providerMethod.getEnclosingElement().asType());
-    String className = bindingClassName(providerMethod);
+    String className = bindingClassName(providerMethod, methodToClassName, methodNameToNextId);
     String returnType = CodeGen.typeToString(providerMethod.getReturnType());
 
     writer.beginType(className, "class", PRIVATE | STATIC,
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 6780fdd..dc93bf1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -83,51 +83,56 @@
 
     Linker linker = new Linker(null, new CompileTimePlugin(processingEnv),
         new ReportingErrorHandler(processingEnv, rootModule.getQualifiedName().toString()));
-    Map<String, Binding<?>> baseBindings = new LinkedHashMap<String, Binding<?>>();
-    Map<String, Binding<?>> overrideBindings = new LinkedHashMap<String, Binding<?>>();
-    for (TypeElement module : allModules.values()) {
-      Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
-      boolean overrides = (Boolean) annotation.get("overrides");
-      Map<String, Binding<?>> addTo = overrides ? overrideBindings : baseBindings;
+    // Linker requires synchronization for calls to requestBinding and linkAll.
+    // We know statically that we're single threaded, but we synchronize anyway
+    // to make the linker happy.
+    synchronized (linker) {
+      Map<String, Binding<?>> baseBindings = new LinkedHashMap<String, Binding<?>>();
+      Map<String, Binding<?>> overrideBindings = new LinkedHashMap<String, Binding<?>>();
+      for (TypeElement module : allModules.values()) {
+        Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
+        boolean overrides = (Boolean) annotation.get("overrides");
+        Map<String, Binding<?>> addTo = overrides ? overrideBindings : baseBindings;
 
-      // Gather the entry points from the annotation.
-      for (Object entryPoint : (Object[]) annotation.get("entryPoints")) {
-        linker.requestBinding(GeneratorKeys.rawMembersKey((TypeMirror) entryPoint),
-            module.getQualifiedName().toString());
-      }
-
-      // Gather the static injections.
-      // TODO.
-
-      // Gather the enclosed @Provides methods.
-      for (Element enclosed : module.getEnclosedElements()) {
-        if (enclosed.getAnnotation(Provides.class) == null) {
-          continue;
+        // Gather the entry points from the annotation.
+        for (Object entryPoint : (Object[]) annotation.get("entryPoints")) {
+          linker.requestBinding(GeneratorKeys.rawMembersKey((TypeMirror) entryPoint),
+              module.getQualifiedName().toString());
         }
-        ExecutableElement providerMethod = (ExecutableElement) enclosed;
-        String key = GeneratorKeys.get(providerMethod);
-        ProviderMethodBinding binding = new ProviderMethodBinding(key, providerMethod);
-        if (providerMethod.getAnnotation(OneOf.class) != null) {
-          String elementKey = GeneratorKeys.getElementKey(providerMethod);
-          SetBinding.add(addTo, elementKey, binding);
-        } else {
-          ProviderMethodBinding clobbered = (ProviderMethodBinding) addTo.put(key, binding);
-          if (clobbered != null) {
-            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
-                "Duplicate bindings for " + key
-                    + ": " + shortMethodName(clobbered.method)
-                    + ", " + shortMethodName(binding.method));
+
+        // Gather the static injections.
+        // TODO.
+
+        // Gather the enclosed @Provides methods.
+        for (Element enclosed : module.getEnclosedElements()) {
+          if (enclosed.getAnnotation(Provides.class) == null) {
+            continue;
+          }
+          ExecutableElement providerMethod = (ExecutableElement) enclosed;
+          String key = GeneratorKeys.get(providerMethod);
+          ProviderMethodBinding binding = new ProviderMethodBinding(key, providerMethod);
+          if (providerMethod.getAnnotation(OneOf.class) != null) {
+            String elementKey = GeneratorKeys.getElementKey(providerMethod);
+            SetBinding.add(addTo, elementKey, binding);
+          } else {
+            ProviderMethodBinding clobbered = (ProviderMethodBinding) addTo.put(key, binding);
+            if (clobbered != null) {
+              processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
+                  "Duplicate bindings for " + key
+                      + ": " + shortMethodName(clobbered.method)
+                      + ", " + shortMethodName(binding.method));
+            }
           }
         }
       }
+
+      linker.installBindings(baseBindings);
+      linker.installBindings(overrideBindings);
+
+      // Link the bindings. This will traverse the dependency graph, and report
+      // errors if any dependencies are missing.
+      return linker.linkAll();
     }
-
-    linker.installBindings(baseBindings);
-    linker.installBindings(overrideBindings);
-
-    // Link the bindings. This will traverse the dependency graph, and report
-    // errors if any dependencies are missing.
-    return linker.linkAll();
   }
 
   private String shortMethodName(ExecutableElement method) {
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index e4f6f60..34a2f0b 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -175,9 +175,12 @@
    * @throws IllegalStateException if this graph has problems.
    */
   public void validate() {
-    linkStaticInjections();
-    linkEntryPoints();
-    Map<String, Binding<?>> allBindings = linker.linkAll();
+    Map<String, Binding<?>> allBindings;
+    synchronized (linker) {
+      linkStaticInjections();
+      linkEntryPoints();
+      allBindings = linker.linkAll();
+    }
     new ProblemDetector().detectProblems(allBindings.values());
   }
 
@@ -191,9 +194,11 @@
     // bindings it doesn't have. Then we ask the linker to link all of those
     // requested bindings. Finally we call linkStaticInjections() again: this
     // time the linker won't return null because everything has been linked.
-    linkStaticInjections();
-    linker.linkRequested();
-    linkStaticInjections();
+    synchronized (linker) {
+      linkStaticInjections();
+      linker.linkRequested();
+      linkStaticInjections();
+    }
 
     for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
       entry.getValue().inject();
@@ -244,11 +249,14 @@
       throw new IllegalArgumentException("No entry point for " + entryPointKey
           + ". You must explicitly add an entry point to one of your modules.");
     }
-    Binding<?> binding = linker.requestBinding(key, moduleClass);
-    if (binding == null || !binding.isLinked()) {
-      linker.linkRequested();
-      binding = linker.requestBinding(key, moduleClass);
+
+    synchronized (linker) {
+      Binding<?> binding = linker.requestBinding(key, moduleClass);
+      if (binding == null || !binding.isLinked()) {
+        linker.linkRequested();
+        binding = linker.requestBinding(key, moduleClass);
+      }
+      return binding;
     }
-    return binding;
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 2e00e15..ab7dae9 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -94,6 +94,8 @@
    * creates JIT bindings as necessary to fill in the gaps.
    */
   public void linkRequested() {
+    assertLockHeld();
+
     Binding<?> binding;
     while ((binding = toLink.poll()) != null) {
       if (binding instanceof DeferredBinding) {
@@ -138,6 +140,15 @@
   }
 
   /**
+   * Don't permit bindings to be linked without a lock. Callers should lock
+   * before requesting any bindings, link the requested bindings, retrieve
+   * the linked bindings, and then release the lock.
+   */
+  private void assertLockHeld() {
+    if (!Thread.holdsLock(this)) throw new AssertionError();
+  }
+
+  /**
    * Creates a just-in-time binding for the key in {@code deferred}. The type of binding
    * to be created depends on the key's type:
    * <ul>
@@ -190,6 +201,8 @@
   }
 
   private Binding<?> requestBinding(String key, boolean mustBeInjectable, Object requiredBy) {
+    assertLockHeld();
+
     Binding<?> binding = null;
     for (Linker linker = this; linker != null; linker = linker.base) {
       binding = linker.bindings.get(key);
/Fim/
diff --git a/README.md b/README.md
index 4879bc9..269cc98 100644
--- a/README.md
+++ b/README.md
@@ -3,366 +3,23 @@
 
 A fast dependency injector for Android and Java.
 
-### Introduction
+For more information please see [the website][1].
 
-The best classes in any application are the ones that do stuff: the `BarcodeDecoder`, the `KoopaPhysicsEngine`, and the `AudioStreamer`. These classes have dependencies; perhaps a `BarcodeCameraFinder`, `DefaultPhysicsEngine`, and an `HttpStreamer`.
 
-To contrast, the worst classes in any application are the ones that take up space without doing much at all: the `BarcodeDecoderFactory`, the `CameraServiceLoader`, and the `MutableContextWrapper`. These classes are the clumsy duct tape that wires the interesting stuff together.
 
-Dagger is a replacement for these `FactoryFactory` classes. It allows you to focus on the interesting classes. Declare dependencies, specify how to satisfy them, and ship your app.
+Download
+--------
 
-By building on standard [javax.inject][1] annotations (JSR-330), each class is **easy to test**. You don't need a bunch of boilerplate just to swap the `RpcCreditCardService` out for a `FakeCreditCardService`.
+You will need to include the `dagger-${dagger.version}.jar` in your
+application's runtime.  In order to activate code generation you will need to
+include `dagger-compiler-${dagger.version}.jar` in your build at compile time.
 
-Dependency injection isn't just for testing. It also makes it easy to create **reusable, interchangeable modules**. You can share the same `AuthenticationModule`  across all of your apps. And you can run `DevLoggingModule` during development and `ProdLoggingModule` in production to get the right behavior in each situation.
+In a Maven project, one would include the runtime in the dependencies section
+of your `pom.xml` (replacing `${dagger.version}` with the appropriate current
+release), and the `dagger-compiler` artifact as a dependency of the compiler
+plugin:
 
-### Declaring Dependencies
-
-Dagger constructs instances of your application classes and satisfies their dependencies. It uses the `javax.inject.Inject` annotation to identify which constructors and fields it is interested in.
-
-Use `@Inject` to annotate the constructor that Dagger should use to create instances of a class. When a new instance is requested, Dagger will obtain the required parameters values and invoke this constructor.
-
-```java
-class Thermosiphon implements Pump {
-  private final Heater heater;
-
-  @Inject
-  Thermosiphon(Heater heater) {
-    this.heater = heater;
-  }
-
-  ...
-}
-```
-
-Dagger can inject fields directly. In this example it obtains a `Heater` instance for the `heater` field and a `Pump` instance for the `pump` field.
-
-```java
-class CoffeeMaker {
-  @Inject Heater heater;
-  @Inject Pump pump;
-
-  ...
-}
-```
-
-If your class has `@Inject`-annotated fields but no `@Inject`-annotated constructor, Dagger will use a no-argument constructor if it exists. Classes that lack `@Inject` annotations cannot be constructed by Dagger.
-
-Dagger does not support method injection.
-
-### Satisfying Dependencies
-
-By default, Dagger satisfies each dependency by constructing an instance of the requested type as described above. When you request a `CoffeeMaker`, it'll obtain one by calling `new CoffeeMaker()` and setting its injectable fields.
-
-But `@Inject` doesn't work everywhere:
-
-* Interfaces can't be constructed.
-* Third-party classes can't be annotated.
-* Configurable objects must be configured!
-
-For these cases where `@Inject` is insufficient or awkward, use an `@Provides`-annotated method to satisfy a dependency. The method's return type defines which dependency it satisfies.
-
-For example, `provideHeater()` is invoked whenever a `Heater` is required:
-
-```java
-@Provides Heater provideHeater() {
-  return new ElectricHeater();
-}
-```
-
-It's possible for `@Provides` methods to have dependencies of their own. This one returns a `Thermosiphon` whenever a `Pump` is required:
-
-```java
-@Provides Pump providePump(Thermosiphon pump) {
-  return pump;
-}
-```
-
-All `@Provides` methods must belong to a module. These are just classes that have an `@Module` annotation.
-
-```java
-@Module
-class DripCoffeeModule {
-  @Provides Heater provideHeater() {
-    return new ElectricHeater();
-  }
-
-  @Provides Pump providePump(Thermosiphon pump) {
-    return pump;
-  }
-}
-```
-
-By convention, `@Provides` methods are named with a `provide` prefix and module classes are named with a `Module` suffix.
-
-### Building the Graph
-
-The `@Inject` and `@Provides`-annotated classes form a graph of objects, linked by their dependencies. Obtain this graph by calling `ObjectGraph.create()`, which accepts one or more modules:
-
-```java
-ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());
-```
-
-In order to put the graph to use we need to create an **entry point**. This is usually the main class that starts the application. In this example, the `CoffeeApp` class serves as the entry point. We ask the graph to provide an injected instance of this type:
-
-```java
-class CoffeeApp implements Runnable {
-  @Inject CoffeeMaker coffeeMaker;
-
-  @Override public void run() {
-    coffeeMaker.brew();
-  }
-
-  public static void main(String[] args) {
-    ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());
-    CoffeeApp coffeeApp = objectGraph.get(CoffeeApp.class);
-    ...
-  }
-}
-```
-
-The only thing that's missing is that the entry point class `CoffeeApp` isn't included in the graph. We need to explicitly register it as an entry point in the `@Module` annotation.
-
-```java
-@Module(
-    entryPoints = CoffeeApp.class
-)
-class DripCoffeeModule {
-  ...
-}
-```
-
-Entry points enable the complete graph to be validated **at compile time**. Detecting problems early speeds up development and takes some of the danger out of refactoring.
-
-Now that the graph is constructed and the entry point is injected, we run our coffee maker app. Fun.
-
-```
-$ java -cp ... coffee.CoffeeApp
-~ ~ ~ heating ~ ~ ~
-=> => pumping => =>
- [_]P coffee! [_]P
-```
-
-### Singletons
-
-Annotate an `@Provides` method or injectable class with `@Singleton`. The graph will use a single instance of the value for all of its clients.
-
-```java
-@Provides @Singleton Heater provideHeater() {
-  return new ElectricHeater();
-}
-```
-
-The `@Singleton` annotation on an injectable class also serves as documentation. It reminds potential maintainers that this class may be shared by multiple threads.
-
-```java
-@Singleton
-class CoffeeMaker {
-  ...
-}
-```
-
-### Lazy injections
-
-Sometimes you need an object to be instantiated lazily.  For any binding `T`, you can create a `Lazy<T>` which defers instantiation until the first call to `Lazy<T>`'s `get()` method. If `T` is a singleton, then `Lazy<T>` will be the same instance for all injections within the `ObjectGraph`.  Otherwise, each injection site will get its own `Lazy<T>` instance.  Regardless, subsequent calls to any given instance of `Lazy<T>` will return the same underlying instance of `T`.
-
-```java
-class GridingCoffeeMaker {
-  @Inject Lazy<Grinder> lazyGrinder;
-
-  public void brew() {
-    while (needsGrinding()) {
-      // Grinder created once on first call to .get() and cached.
-      lazyGrinder.get().grind();
-    }
-  }
-}
-```
-
-### Provider injections
-
-Sometimes you need multiple instances to be returned instead of just injecting a single value.  While you have several options (Factories, Builders, etc.)   one option is to inject a `Provider<T>` instead of just `T`.  A `Provider<T>` creates a new instance of `T` each time `.get()` is called.
-
-```java
-
-class BigCoffeeMaker {
-  @Inject Provider<Filter> filterProvider;
-
-  public void brew(int numberOfPots) {
-	...
-    for (int p = 0; p < numberOfPots; p++) {
-      maker.addFilter(filterProvider.get()); //new filter every time.
-      maker.addCoffee(...);
-      maker.percolate();
-      ...
-    }
-  }
-}
-```
-
-***Note:*** *Injecting `Provider<T>` has the possibility of creating confusing code, and may be a design smell of mis-scoped or mis-structured objects in your graph.  Often you will want to use a `Factory<T>` or a `Lazy<T>` or re-organize the lifetimes and structure of your code to be able to just inject a `T`.  Injecting `Provider<T>` can, however, be a life saver in some cases.  A common use is when you must use a legacy architecture that doesn't line up with your object's natural lifetimes (e.g. servlets are singletons by design, but only are valid in the context of request-specfic data).*
-
-### Qualifiers
-
-Sometimes the type alone is insufficient to identify a dependency. For example, a sophisticated coffee maker app may want separate heaters for the water and the hot plate.
-
-In this case, we add a **qualifier annotation**. This is any annotation that itself has a `@Qualifier` annotation. Here's the declaration of `@Named`, a qualifier annotation included in `javax.inject`:
-
-```java
-@Qualifier
-@Documented
-@Retention(RUNTIME)
-public @interface Named {
-  String value() default "";
-}
-```
-
-You can create your own qualifier annotations, or just use `@Named`. Apply qualifiers by annotating the field or parameter of interest. The type and qualifier annotation will both be used to identify the dependency.
-
-```java
-class ExpensiveCoffeeMaker {
-  @Inject @Named("water") Heater waterHeater;
-  @Inject @Named("hot plate") Heater hotPlateHeater;
-  ...
-}
-```
-
-Supply qualified values by annotating the corresponding `@Provides` method.
-
-```java
-@Provides @Named("hot plate") Heater provideHotPlateHeater() {
-  return new ElectricHeater(70);
-}
-
-@Provides @Named("water") Heater provideWaterHeater() {
-  return new ElectricHeater(93);
-}
-```
-
-Dependencies may not have multiple qualifier annotations.
-
-### Static Injection
-
-**Warning:** This feature should be used sparingly because static dependencies are difficult to test and reuse.
-
-Dagger can inject static fields. Classes that declare static fields with `@Inject` annotations must be listed as `staticInjections` in a module annotation.
-
-```java
-@Module(
-    staticInjections = LegacyCoffeeUtils.class
-)
-class LegacyModule {
-}
-```
-
-Use `ObjectGraph.injectStatics()` to populate these static fields with their injected values:
-
-```java
-ObjectGraph objectGraph = ObjectGraph.create(new LegacyModule());
-objectGraph.injectStatics();
-```
-
-### Compile-time Validation
-
-Dagger includes an [annotation processor][2] that validates modules and injections. This processor is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is missing a binding for `Executor`:
-
-```java
-@Module
-class DripCoffeeModule {
-  @Provides Heater provideHeater(Executor executor) {
-    return new CpuHeater(executor);
-  }
-}
-```
-
-When compiling it, `javac` rejects the missing binding:
-
-```
-[ERROR] COMPILATION ERROR :
-[ERROR] error: No binding for java.util.concurrent.Executor
-               required by provideHeater(java.util.concurrent.Executor)
-```
-
-Fix the problem either by adding an `@Provides`-annotated method for `Executor`, or by marking the module as incomplete. Incomplete modules are permitted to have missing dependencies.
-
-```java
-@Module(complete = false)
-class DripCoffeeModule {
-  @Provides Heater provideHeater(Executor executor) {
-    return new CpuHeater(executor);
-  }
-}
-```
-
-To get the most out of compile-time validation, create a module that includes all of your application's modules as children. The annotation processor will detect problems across the modules and report them.
-
-```java
-@Module(
-    children = {
-        DripCoffeeModule.class,
-        ExecutorModule.class
-    }
-)
-public class CoffeeAppModule {
-}
-```
-
-The annotation processor is enabled automatically when you include Dagger's jar file on your compile classpath.
-
-### Compile-time Code Generation
-
-Dagger's annotation processor may also generate source files with names like `CoffeeMaker$InjectAdapter.java` or `DripCoffeeModule$ModuleAdapter`. These files are Dagger implementation details. You shouldn't need to use them directly, though they can be handy when step-debugging through an injection.
-
-### Module overrides
-
-Dagger will fail with an error if there are multiple competing `@Provides` methods for the same dependency. But sometimes it's necessary to replace production code with a substitute for development or testing. Using `overrides = true` in a module annotation lets you take precedence over the bindings of other modules.
-
-This JUnit test overrides `DripCoffeeModule`'s binding for `Heater` with a mock object from [Mockito][3]. The mock gets injected into the `CoffeeMaker` and also into the test.
-
-```java
-public class CoffeeMakerTest {
-  @Inject CoffeeMaker coffeeMaker;
-  @Inject Heater heater;
-
-  @Before public void setUp() {
-    ObjectGraph.create(new TestModule()).inject(this);
-  }
-
-  @Module(
-      children = DripCoffeeModule.class,
-      entryPoints = CoffeeMakerTest.class,
-      overrides = true
-  )
-  static class TestModule {
-    @Provides @Singleton Heater provideHeater() {
-      return Mockito.mock(Heater.class);
-    }
-  }
-
-  @Test public void testHeaterIsTurnedOnAndThenOff() {
-    Mockito.when(heater.isHot()).thenReturn(true);
-    coffeeMaker.brew();
-    Mockito.verify(heater, Mockito.times(1)).on();
-    Mockito.verify(heater, Mockito.times(1)).off();
-  }
-}
-```
-
-Overrides are best suited for small variations on the application:
-
-* Replacing the real implementation with a mock for unit tests.
-* Replacing LDAP authentication with fake authentication for development.
-
-For more substantial variations it's often simpler to use a different combination of modules.
-
-
-Using Dagger in your build
-==========================
-
-You will need to include the `dagger-${dagger.version}.jar` in your application's runtime.  In order to activate code generation you will need to include `dagger-compiler-${dagger.version}.jar` in your build at compile time. 
-
-In a Maven project, one would include the runtime in the dependencies section of your `pom.xml` (replacing ${dagger.version} with the appropriate current release), and the dagger-compiler artifact as a dependency of the compiler plugin: 
-
-```java
+```xml
   <dependencies>
     <dependency>
       <groupId>com.squareup</groupId>
@@ -386,21 +43,12 @@
   </build>
 ```
 
+You can also find downloadable .jars on the [GitHub download page][2].
 
 
-Upgrading from Guice
-====================
-
-Some notable Guice features that Dagger doesn't support:
-
-* Injecting `final` fields and `private` members. For best performance Dagger generates code. Work around this by using constructor injection.
-* Eager singletons. Work around this by creating an `EagerSingletons` class that declares static fields for each eager singleton.
-* Method injection.
-* Classes that lack `@Inject` annotations cannot be constructed by Dagger, even if they have a no-argument constructor.
-
 
 License
-=======
+-------
 
     Copyright 2012 Square, Inc.
 
@@ -416,6 +64,7 @@
     See the License for the specific language governing permissions and
     limitations under the License.
 
- [1]: http://atinject.googlecode.com/svn/trunk/javadoc/javax/inject/package-summary.html
- [2]: http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html
- [3]: http://mockito.googlecode.com/
+
+
+ [1]: http://square.github.com/dagger/
+ [2]: http://github.com/square/dagger/downloads
\ No newline at end of file
/Fim/
diff --git a/deploy_website.sh b/deploy_website.sh
new file mode 100755
index 0000000..7dd9d89
--- /dev/null
+++ b/deploy_website.sh
@@ -0,0 +1,38 @@
+#!/bin/bash
+#
+# Deploys the current Dagger website to the gh-pages branch of the GitHub
+# repository. To test the site locally before deploying run `jekyll --server`
+# in the website/ directory.
+
+set -ex
+
+DIR=temp-dagger-clone
+
+# Delete any existing temporary website clone
+rm -rf $DIR
+
+# Clone the current repo into temp folder
+git clone git@git.squareup.com:square/dagger.git $DIR
+
+# Move working directory into temp folder
+cd $DIR
+
+# Checkout and track the gh-pages branch
+git checkout -t origin/gh-pages
+
+# Delete everything
+git rm -rf * .*
+
+# Copy website files from real repo
+cp -R ../website/* .
+
+# Stage all files in git and create a commit
+git add .
+git commit -m "Website at ${date}"
+
+# Push the new files up to GitHub
+git push origin gh-pages
+
+# Delete our temp folder
+cd ..
+rm -rf $DIR
/Fim/
diff --git a/website/.gitignore b/website/.gitignore
new file mode 100644
index 0000000..2f71f5d
--- /dev/null
+++ b/website/.gitignore
@@ -0,0 +1,2 @@
+_site
+_cache
/Fim/
diff --git a/website/_config.yml b/website/_config.yml
new file mode 100644
index 0000000..3120c33
--- /dev/null
+++ b/website/_config.yml
@@ -0,0 +1,6 @@
+auto: true
+url: "http://square.github.com/dagger/"
+
+markdown: redcarpet2
+redcarpet:
+  extensions: ["no_intra_emphasis", "fenced_code_blocks", "autolink", "tables", "with_toc_data"]
/Fim/
diff --git a/website/_layouts/default.html b/website/_layouts/default.html
new file mode 100644
index 0000000..7572fcc
--- /dev/null
+++ b/website/_layouts/default.html
@@ -0,0 +1,33 @@
+<!DOCTYPE html>
+
+<html lang="en">
+<head>
+    <meta charset="utf-8">
+    <title>Dagger &#x2020; A fast dependency injector for Android and Java.</title>
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <meta name="description" content="A fast dependency injector for Android and Java." />
+    <link href="/static/bootstrap.min.css" rel="stylesheet">
+    <link href="/static/bootstrap-responsive.min.css" rel="stylesheet">
+    <link href="/static/prettify.css" rel="stylesheet">
+    <link href="/static/app.css" rel="stylesheet">
+</head>
+<body>
+<div class="container">
+    <div class="row">
+        <div class="span4 side">
+            <h1><img src="/static/logo.png" alt="Dagger"></h1>
+            <h3>A fast dependency injector for Android and Java.</h3>
+            <p><a href="https://squareup.com/"><img src="static/square.png" alt="by Square, Inc."></a></p>
+      </div>
+        <div class="offset4 span8 main"><div class="main-inner">
+
+{{ content }}
+
+            <a id="ribbon" href="https://github.com/square/dagger"><img src="/static/ribbon.png" alt="Fork me on GitHub"></a>
+        </div></div>
+    </div>
+</div>
+<script src="/static/prettify.js"></script>
+<script> prettyPrint(); </script>
+</body>
+</html>
/Fim/
diff --git a/website/_plugins/redcarpet2_markdown.rb b/website/_plugins/redcarpet2_markdown.rb
new file mode 100644
index 0000000..445d4a0
--- /dev/null
+++ b/website/_plugins/redcarpet2_markdown.rb
@@ -0,0 +1,52 @@
+require 'fileutils'
+require 'digest/md5'
+require 'redcarpet'
+require 'albino'
+
+PYGMENTS_CACHE_DIR = File.expand_path('../../_cache', __FILE__)
+FileUtils.mkdir_p(PYGMENTS_CACHE_DIR)
+
+class Redcarpet2Markdown < Redcarpet::Render::HTML
+  def block_code(code, lang)
+    lang = lang || "text"
+    path = File.join(PYGMENTS_CACHE_DIR, "#{lang}-#{Digest::MD5.hexdigest code}.html")
+    cache(path) do
+      colorized = Albino.colorize(code, lang.downcase)
+      add_code_tags(colorized, lang)
+    end
+  end
+
+  def add_code_tags(code, lang)
+    if lang != 'text'
+      code.sub(/<pre>/, "<pre class=\"prettyprint\">").
+           sub(/<\/pre>/, "</pre>")
+    else
+      code
+    end
+  end
+
+  def cache(path)
+    if File.exist?(path)
+      File.read(path)
+    else
+      content = yield
+      File.open(path, 'w') {|f| f.print(content) }
+      content
+    end
+  end
+end
+
+class Jekyll::MarkdownConverter
+  def extensions
+    Hash[ *@config['redcarpet']['extensions'].map {|e| [e.to_sym, true] }.flatten ]
+  end
+
+  def markdown
+    @markdown ||= Redcarpet::Markdown.new(Redcarpet2Markdown.new(extensions), extensions)
+  end
+
+  def convert(content)
+    return super unless @config['markdown'] == 'redcarpet2'
+    markdown.render(content)
+  end
+end
\ No newline at end of file
/Fim/
diff --git a/website/index.md b/website/index.md
new file mode 100644
index 0000000..576f49b
--- /dev/null
+++ b/website/index.md
@@ -0,0 +1,419 @@
+---
+layout: default
+---
+
+### Introduction
+
+The best classes in any application are the ones that do stuff: the `BarcodeDecoder`, the `KoopaPhysicsEngine`, and the `AudioStreamer`. These classes have dependencies; perhaps a `BarcodeCameraFinder`, `DefaultPhysicsEngine`, and an `HttpStreamer`.
+
+To contrast, the worst classes in any application are the ones that take up space without doing much at all: the `BarcodeDecoderFactory`, the `CameraServiceLoader`, and the `MutableContextWrapper`. These classes are the clumsy duct tape that wires the interesting stuff together.
+
+Dagger is a replacement for these `FactoryFactory` classes. It allows you to focus on the interesting classes. Declare dependencies, specify how to satisfy them, and ship your app.
+
+By building on standard [javax.inject][1] annotations (JSR-330), each class is **easy to test**. You don't need a bunch of boilerplate just to swap the `RpcCreditCardService` out for a `FakeCreditCardService`.
+
+Dependency injection isn't just for testing. It also makes it easy to create **reusable, interchangeable modules**. You can share the same `AuthenticationModule`  across all of your apps. And you can run `DevLoggingModule` during development and `ProdLoggingModule` in production to get the right behavior in each situation.
+
+#### Declaring Dependencies
+
+Dagger constructs instances of your application classes and satisfies their dependencies. It uses the `javax.inject.Inject` annotation to identify which constructors and fields it is interested in.
+
+Use `@Inject` to annotate the constructor that Dagger should use to create instances of a class. When a new instance is requested, Dagger will obtain the required parameters values and invoke this constructor.
+
+```java
+class Thermosiphon implements Pump {
+  private final Heater heater;
+
+  @Inject
+  Thermosiphon(Heater heater) {
+    this.heater = heater;
+  }
+
+  ...
+}
+```
+
+Dagger can inject fields directly. In this example it obtains a `Heater` instance for the `heater` field and a `Pump` instance for the `pump` field.
+
+```java
+class CoffeeMaker {
+  @Inject Heater heater;
+  @Inject Pump pump;
+
+  ...
+}
+```
+
+If your class has `@Inject`-annotated fields but no `@Inject`-annotated constructor, Dagger will use a no-argument constructor if it exists. Classes that lack `@Inject` annotations cannot be constructed by Dagger.
+
+Dagger does not support method injection.
+
+#### Satisfying Dependencies
+
+By default, Dagger satisfies each dependency by constructing an instance of the requested type as described above. When you request a `CoffeeMaker`, it'll obtain one by calling `new CoffeeMaker()` and setting its injectable fields.
+
+But `@Inject` doesn't work everywhere:
+
+* Interfaces can't be constructed.
+* Third-party classes can't be annotated.
+* Configurable objects must be configured!
+
+For these cases where `@Inject` is insufficient or awkward, use an `@Provides`-annotated method to satisfy a dependency. The method's return type defines which dependency it satisfies.
+
+For example, `provideHeater()` is invoked whenever a `Heater` is required:
+
+```java
+@Provides Heater provideHeater() {
+  return new ElectricHeater();
+}
+```
+
+It's possible for `@Provides` methods to have dependencies of their own. This one returns a `Thermosiphon` whenever a `Pump` is required:
+
+```java
+@Provides Pump providePump(Thermosiphon pump) {
+  return pump;
+}
+```
+
+All `@Provides` methods must belong to a module. These are just classes that have an `@Module` annotation.
+
+```java
+@Module
+class DripCoffeeModule {
+  @Provides Heater provideHeater() {
+    return new ElectricHeater();
+  }
+
+  @Provides Pump providePump(Thermosiphon pump) {
+    return pump;
+  }
+}
+```
+
+By convention, `@Provides` methods are named with a `provide` prefix and module classes are named with a `Module` suffix.
+
+#### Building the Graph
+
+The `@Inject` and `@Provides`-annotated classes form a graph of objects, linked by their dependencies. Obtain this graph by calling `ObjectGraph.create()`, which accepts one or more modules:
+
+```java
+ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());
+```
+
+In order to put the graph to use we need to create an **entry point**. This is usually the main class that starts the application. In this example, the `CoffeeApp` class serves as the entry point. We ask the graph to provide an injected instance of this type:
+
+```java
+class CoffeeApp implements Runnable {
+  @Inject CoffeeMaker coffeeMaker;
+
+  @Override public void run() {
+    coffeeMaker.brew();
+  }
+
+  public static void main(String[] args) {
+    ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());
+    CoffeeApp coffeeApp = objectGraph.get(CoffeeApp.class);
+    ...
+  }
+}
+```
+
+The only thing that's missing is that the entry point class `CoffeeApp` isn't included in the graph. We need to explicitly register it as an entry point in the `@Module` annotation.
+
+```java
+@Module(
+    entryPoints = CoffeeApp.class
+)
+class DripCoffeeModule {
+  ...
+}
+```
+
+Entry points enable the complete graph to be validated **at compile time**. Detecting problems early speeds up development and takes some of the danger out of refactoring.
+
+Now that the graph is constructed and the entry point is injected, we run our coffee maker app. Fun.
+
+```
+$ java -cp ... coffee.CoffeeApp
+~ ~ ~ heating ~ ~ ~
+=> => pumping => =>
+ [_]P coffee! [_]P
+```
+
+#### Singletons
+
+Annotate an `@Provides` method or injectable class with `@Singleton`. The graph will use a single instance of the value for all of its clients.
+
+```java
+@Provides @Singleton Heater provideHeater() {
+  return new ElectricHeater();
+}
+```
+
+The `@Singleton` annotation on an injectable class also serves as documentation. It reminds potential maintainers that this class may be shared by multiple threads.
+
+```java
+@Singleton
+class CoffeeMaker {
+  ...
+}
+```
+
+#### Lazy injections
+
+Sometimes you need an object to be instantiated lazily.  For any binding `T`, you can create a `Lazy<T>` which defers instantiation until the first call to `Lazy<T>`'s `get()` method. If `T` is a singleton, then `Lazy<T>` will be the same instance for all injections within the `ObjectGraph`.  Otherwise, each injection site will get its own `Lazy<T>` instance.  Regardless, subsequent calls to any given instance of `Lazy<T>` will return the same underlying instance of `T`.
+
+```java
+class GridingCoffeeMaker {
+  @Inject Lazy<Grinder> lazyGrinder;
+
+  public void brew() {
+    while (needsGrinding()) {
+      // Grinder created once on first call to .get() and cached.
+      lazyGrinder.get().grind();
+    }
+  }
+}
+```
+
+#### Provider injections
+
+Sometimes you need multiple instances to be returned instead of just injecting a single value.  While you have several options (Factories, Builders, etc.)   one option is to inject a `Provider<T>` instead of just `T`.  A `Provider<T>` creates a new instance of `T` each time `.get()` is called.
+
+```java
+
+class BigCoffeeMaker {
+  @Inject Provider<Filter> filterProvider;
+
+  public void brew(int numberOfPots) {
+	...
+    for (int p = 0; p < numberOfPots; p++) {
+      maker.addFilter(filterProvider.get()); //new filter every time.
+      maker.addCoffee(...);
+      maker.percolate();
+      ...
+    }
+  }
+}
+```
+
+***Note:*** *Injecting `Provider<T>` has the possibility of creating confusing code, and may be a design smell of mis-scoped or mis-structured objects in your graph.  Often you will want to use a `Factory<T>` or a `Lazy<T>` or re-organize the lifetimes and structure of your code to be able to just inject a `T`.  Injecting `Provider<T>` can, however, be a life saver in some cases.  A common use is when you must use a legacy architecture that doesn't line up with your object's natural lifetimes (e.g. servlets are singletons by design, but only are valid in the context of request-specfic data).*
+
+#### Qualifiers
+
+Sometimes the type alone is insufficient to identify a dependency. For example, a sophisticated coffee maker app may want separate heaters for the water and the hot plate.
+
+In this case, we add a **qualifier annotation**. This is any annotation that itself has a `@Qualifier` annotation. Here's the declaration of `@Named`, a qualifier annotation included in `javax.inject`:
+
+```java
+@Qualifier
+@Documented
+@Retention(RUNTIME)
+public @interface Named {
+  String value() default "";
+}
+```
+
+You can create your own qualifier annotations, or just use `@Named`. Apply qualifiers by annotating the field or parameter of interest. The type and qualifier annotation will both be used to identify the dependency.
+
+```java
+class ExpensiveCoffeeMaker {
+  @Inject @Named("water") Heater waterHeater;
+  @Inject @Named("hot plate") Heater hotPlateHeater;
+  ...
+}
+```
+
+Supply qualified values by annotating the corresponding `@Provides` method.
+
+```java
+@Provides @Named("hot plate") Heater provideHotPlateHeater() {
+  return new ElectricHeater(70);
+}
+
+@Provides @Named("water") Heater provideWaterHeater() {
+  return new ElectricHeater(93);
+}
+```
+
+Dependencies may not have multiple qualifier annotations.
+
+#### Static Injection
+
+**Warning:** This feature should be used sparingly because static dependencies are difficult to test and reuse.
+
+Dagger can inject static fields. Classes that declare static fields with `@Inject` annotations must be listed as `staticInjections` in a module annotation.
+
+```java
+@Module(
+    staticInjections = LegacyCoffeeUtils.class
+)
+class LegacyModule {
+}
+```
+
+Use `ObjectGraph.injectStatics()` to populate these static fields with their injected values:
+
+```java
+ObjectGraph objectGraph = ObjectGraph.create(new LegacyModule());
+objectGraph.injectStatics();
+```
+
+#### Compile-time Validation
+
+Dagger includes an [annotation processor][2] that validates modules and injections. This processor is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is missing a binding for `Executor`:
+
+```java
+@Module
+class DripCoffeeModule {
+  @Provides Heater provideHeater(Executor executor) {
+    return new CpuHeater(executor);
+  }
+}
+```
+
+When compiling it, `javac` rejects the missing binding:
+
+```
+[ERROR] COMPILATION ERROR :
+[ERROR] error: No binding for java.util.concurrent.Executor
+               required by provideHeater(java.util.concurrent.Executor)
+```
+
+Fix the problem either by adding an `@Provides`-annotated method for `Executor`, or by marking the module as incomplete. Incomplete modules are permitted to have missing dependencies.
+
+```java
+@Module(complete = false)
+class DripCoffeeModule {
+  @Provides Heater provideHeater(Executor executor) {
+    return new CpuHeater(executor);
+  }
+}
+```
+
+To get the most out of compile-time validation, create a module that includes all of your application's modules as children. The annotation processor will detect problems across the modules and report them.
+
+```java
+@Module(
+    children = {
+        DripCoffeeModule.class,
+        ExecutorModule.class
+    }
+)
+public class CoffeeAppModule {
+}
+```
+
+The annotation processor is enabled automatically when you include Dagger's jar file on your compile classpath.
+
+#### Compile-time Code Generation
+
+Dagger's annotation processor may also generate source files with names like `CoffeeMaker$InjectAdapter.java` or `DripCoffeeModule$ModuleAdapter`. These files are Dagger implementation details. You shouldn't need to use them directly, though they can be handy when step-debugging through an injection.
+
+#### Module overrides
+
+Dagger will fail with an error if there are multiple competing `@Provides` methods for the same dependency. But sometimes it's necessary to replace production code with a substitute for development or testing. Using `overrides = true` in a module annotation lets you take precedence over the bindings of other modules.
+
+This JUnit test overrides `DripCoffeeModule`'s binding for `Heater` with a mock object from [Mockito][3]. The mock gets injected into the `CoffeeMaker` and also into the test.
+
+```java
+public class CoffeeMakerTest {
+  @Inject CoffeeMaker coffeeMaker;
+  @Inject Heater heater;
+
+  @Before public void setUp() {
+    ObjectGraph.create(new TestModule()).inject(this);
+  }
+
+  @Module(
+      children = DripCoffeeModule.class,
+      entryPoints = CoffeeMakerTest.class,
+      overrides = true
+  )
+  static class TestModule {
+    @Provides @Singleton Heater provideHeater() {
+      return Mockito.mock(Heater.class);
+    }
+  }
+
+  @Test public void testHeaterIsTurnedOnAndThenOff() {
+    Mockito.when(heater.isHot()).thenReturn(true);
+    coffeeMaker.brew();
+    Mockito.verify(heater, Mockito.times(1)).on();
+    Mockito.verify(heater, Mockito.times(1)).off();
+  }
+}
+```
+
+Overrides are best suited for small variations on the application:
+
+* Replacing the real implementation with a mock for unit tests.
+* Replacing LDAP authentication with fake authentication for development.
+
+For more substantial variations it's often simpler to use a different combination of modules.
+
+
+### Using Dagger In Your Build
+
+You will need to include the `dagger-${dagger.version}.jar` in your application's runtime.  In order to activate code generation you will need to include `dagger-compiler-${dagger.version}.jar` in your build at compile time.
+
+In a Maven project, one would include the runtime in the dependencies section of your `pom.xml` (replacing `${dagger.version}` with the appropriate current release), and the `dagger-compiler` artifact as a dependency of the compiler plugin:
+
+```xml
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${dagger.version}</version>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <dependencies>
+          <dependency>
+            <groupId>com.squareup</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>${dagger.version}</version>
+          </dependency>
+        </dependencies>
+      </plugin>
+    </plugins>
+  </build>
+```
+
+
+
+### Upgrading from Guice
+
+Some notable Guice features that Dagger doesn't support:
+
+* Injecting `final` fields and `private` members. For best performance Dagger generates code. Work around this by using constructor injection.
+* Eager singletons. Work around this by creating an `EagerSingletons` class that declares static fields for each eager singleton.
+* Method injection.
+* Classes that lack `@Inject` annotations cannot be constructed by Dagger, even if they have a no-argument constructor.
+
+
+### License
+
+    Copyright 2012 Square, Inc.
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+
+
+ [1]: http://atinject.googlecode.com/svn/trunk/javadoc/javax/inject/package-summary.html
+ [2]: http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html
+ [3]: http://mockito.googlecode.com/
/Fim/
diff --git a/website/static/app.css b/website/static/app.css
new file mode 100644
index 0000000..3c3f53a
--- /dev/null
+++ b/website/static/app.css
@@ -0,0 +1,99 @@
+body {
+    background: #212121 url('debut_dark.png') fixed repeat;
+    margin-top: 40px;
+    color: #c6c6c6;
+    text-shadow: 1px 0px 1px black;
+    line-height: 20px;
+}
+
+code, pre {
+    color: #bbb;
+    background: none;
+    border: none;
+}
+pre {
+    font-size: 10px;
+}
+code {
+    white-space: nowrap;
+}
+
+.side h1 {
+    font-weight: normal;
+    font-size: 90px;
+    line-height: 90px;
+    margin-bottom: 25px;
+    color: #f0f0f0;
+}
+.side h3 {
+    font-weight: normal;
+    margin-bottom: 40px;
+    color: #aaa;
+}
+.side ul {
+    margin-bottom: 30px;
+}
+
+.main {
+    padding-top: 40px;
+    padding-bottom: 40px;
+}
+.main h3 {
+    padding-top: 40px;
+    margin-top: 0;
+    margin-bottom: 10px;
+}
+.main h4 {
+    padding-top: 30px;
+    margin-top: 0;
+    margin-bottom: 8px;
+    text-transform: uppercase;
+}
+.main h4:first-child, .main h3:first-child {
+    padding-top: 0;
+}
+.main h5 {
+    font-size: 12px;
+    margin-top: 14px;
+    margin-bottom: 4px;
+    color: #666;
+    text-transform: uppercase;
+}
+
+#ribbon img {
+    position: absolute;
+    top: 0;
+    right: 0;
+    border: 0;
+}
+
+a:link, a:visited, a:active, a:hover {
+    color: #72A4B4;
+}
+a:hover {
+    text-decoration: underline;
+}
+
+@media(min-width:768px) {
+    body {
+        margin-top: 60px;
+    }
+    .side {
+        text-align: right;
+        position: fixed;
+    }
+    .side ul {
+        margin-bottom: 60px;
+    }
+    .main {
+        padding-top: 28px;
+        padding-bottom: 100px;
+    }
+    .main-inner {
+        margin-left: 25px;
+    }
+
+    #ribbon img {
+        position: fixed;
+    }
+}
\ No newline at end of file
/Fim/
diff --git a/website/static/bootstrap-responsive.min.css b/website/static/bootstrap-responsive.min.css
new file mode 100644
index 0000000..515b2d0
--- /dev/null
+++ b/website/static/bootstrap-responsive.min.css
@@ -0,0 +1,10 @@
+/*!
+ * Bootstrap Responsive v2.0.4
+ *
+ * Copyright 2012 Twitter, Inc
+ * Licensed under the Apache License v2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Designed and built with all the love in the world @twitter by @mdo and @fat.
+ */.clearfix{*zoom:1}.clearfix:before,.clearfix:after{display:table;content:""}.clearfix:after{clear:both}.hide-text{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.input-block-level{display:block;width:100%;min-height:28px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;box-sizing:border-box}.hidden{display:none;visibility:hidden}.visible-phone{display:none!important}.visible-tablet{display:none!important}.hidden-desktop{display:none!important}@media(max-width:767px){.visible-phone{display:inherit!important}.hidden-phone{display:none!important}.hidden-desktop{display:inherit!important}.visible-desktop{display:none!important}}@media(min-width:768px) and (max-width:979px){.visible-tablet{display:inherit!important}.hidden-tablet{display:none!important}.hidden-desktop{display:inherit!important}.visible-desktop{display:none!important}}@media(max-width:480px){.nav-collapse{-webkit-transform:translate3d(0,0,0)}.page-header h1 small{display:block;line-height:18px}input[type="checkbox"],input[type="radio"]{border:1px solid #ccc}.form-horizontal .control-group>label{float:none;width:auto;padding-top:0;text-align:left}.form-horizontal .controls{margin-left:0}.form-horizontal .control-list{padding-top:0}.form-horizontal .form-actions{padding-right:10px;padding-left:10px}.modal{position:fixed;top:10px;right:10px;left:10px;width:auto;margin:0}.modal.fade.in{top:auto}.modal-header .close{padding:10px;margin:-10px}.carousel-caption{position:static}}@media(max-width:767px){body{padding-right:20px;padding-left:20px}.navbar-fixed-top,.navbar-fixed-bottom{margin-right:-20px;margin-left:-20px}.container-fluid{padding:0}.dl-horizontal dt{float:none;width:auto;clear:none;text-align:left}.dl-horizontal dd{margin-left:0}.container{width:auto}.row-fluid{width:100%}.row,.thumbnails{margin-left:0}[class*="span"],.row-fluid [class*="span"]{display:block;float:none;width:auto;margin-left:0}.input-large,.input-xlarge,.input-xxlarge,input[class*="span"],select[class*="span"],textarea[class*="span"],.uneditable-input{display:block;width:100%;min-height:28px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;box-sizing:border-box}.input-prepend input,.input-append input,.input-prepend input[class*="span"],.input-append input[class*="span"]{display:inline-block;width:auto}}@media(min-width:768px) and (max-width:979px){.row{margin-left:-20px;*zoom:1}.row:before,.row:after{display:table;content:""}.row:after{clear:both}[class*="span"]{float:left;margin-left:20px}.container,.navbar-fixed-top .container,.navbar-fixed-bottom .container{width:724px}.span12{width:724px}.span11{width:662px}.span10{width:600px}.span9{width:538px}.span8{width:476px}.span7{width:414px}.span6{width:352px}.span5{width:290px}.span4{width:228px}.span3{width:166px}.span2{width:104px}.span1{width:42px}.offset12{margin-left:764px}.offset11{margin-left:702px}.offset10{margin-left:640px}.offset9{margin-left:578px}.offset8{margin-left:516px}.offset7{margin-left:454px}.offset6{margin-left:392px}.offset5{margin-left:330px}.offset4{margin-left:268px}.offset3{margin-left:206px}.offset2{margin-left:144px}.offset1{margin-left:82px}.row-fluid{width:100%;*zoom:1}.row-fluid:before,.row-fluid:after{display:table;content:""}.row-fluid:after{clear:both}.row-fluid [class*="span"]{display:block;float:left;width:100%;min-height:28px;margin-left:2.762430939%;*margin-left:2.709239449638298%;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;box-sizing:border-box}.row-fluid [class*="span"]:first-child{margin-left:0}.row-fluid .span12{width:99.999999993%;*width:99.9468085036383%}.row-fluid .span11{width:91.436464082%;*width:91.38327259263829%}.row-fluid .span10{width:82.87292817100001%;*width:82.8197366816383%}.row-fluid .span9{width:74.30939226%;*width:74.25620077063829%}.row-fluid .span8{width:65.74585634900001%;*width:65.6926648596383%}.row-fluid .span7{width:57.182320438000005%;*width:57.129128948638304%}.row-fluid .span6{width:48.618784527%;*width:48.5655930376383%}.row-fluid .span5{width:40.055248616%;*width:40.0020571266383%}.row-fluid .span4{width:31.491712705%;*width:31.4385212156383%}.row-fluid .span3{width:22.928176794%;*width:22.874985304638297%}.row-fluid .span2{width:14.364640883%;*width:14.311449393638298%}.row-fluid .span1{width:5.801104972%;*width:5.747913482638298%}.row-fluid .offset12{margin-left:105.524861871%;*margin-left:105.41847889227658%}.row-fluid .offset12:first-child{margin-left:102.762430932%;*margin-left:102.65604795327658%}.row-fluid .offset11{margin-left:96.96132596%;*margin-left:96.85494298127658%}.row-fluid .offset11:first-child{margin-left:94.198895021%;*margin-left:94.09251204227658%}.row-fluid .offset10{margin-left:88.39779004900001%;*margin-left:88.29140707027659%}.row-fluid .offset10:first-child{margin-left:85.63535911000001%;*margin-left:85.5289761312766%}.row-fluid .offset9{margin-left:79.83425413799999%;*margin-left:79.72787115927657%}.row-fluid .offset9:first-child{margin-left:77.071823199%;*margin-left:76.96544022027658%}.row-fluid .offset8{margin-left:71.270718227%;*margin-left:71.16433524827659%}.row-fluid .offset8:first-child{margin-left:68.508287288%;*margin-left:68.40190430927659%}.row-fluid .offset7{margin-left:62.70718231600001%;*margin-left:62.600799337276605%}.row-fluid .offset7:first-child{margin-left:59.944751377%;*margin-left:59.8383683982766%}.row-fluid .offset6{margin-left:54.143646405000005%;*margin-left:54.0372634262766%}.row-fluid .offset6:first-child{margin-left:51.381215466%;*margin-left:51.2748324872766%}.row-fluid .offset5{margin-left:45.580110494%;*margin-left:45.4737275152766%}.row-fluid .offset5:first-child{margin-left:42.817679555%;*margin-left:42.711296576276595%}.row-fluid .offset4{margin-left:37.016574583%;*margin-left:36.9101916042766%}.row-fluid .offset4:first-child{margin-left:34.254143644%;*margin-left:34.1477606652766%}.row-fluid .offset3{margin-left:28.453038671999998%;*margin-left:28.346655693276595%}.row-fluid .offset3:first-child{margin-left:25.690607733%;*margin-left:25.584224754276597%}.row-fluid .offset2{margin-left:19.889502761%;*margin-left:19.783119782276597%}.row-fluid .offset2:first-child{margin-left:17.127071822%;*margin-left:17.0206888432766%}.row-fluid .offset1{margin-left:11.32596685%;*margin-left:11.219583871276598%}.row-fluid .offset1:first-child{margin-left:8.563535911%;*margin-left:8.457152932276596%}input,textarea,.uneditable-input{margin-left:0}input.span12,textarea.span12,.uneditable-input.span12{width:714px}input.span11,textarea.span11,.uneditable-input.span11{width:652px}input.span10,textarea.span10,.uneditable-input.span10{width:590px}input.span9,textarea.span9,.uneditable-input.span9{width:528px}input.span8,textarea.span8,.uneditable-input.span8{width:466px}input.span7,textarea.span7,.uneditable-input.span7{width:404px}input.span6,textarea.span6,.uneditable-input.span6{width:342px}input.span5,textarea.span5,.uneditable-input.span5{width:280px}input.span4,textarea.span4,.uneditable-input.span4{width:218px}input.span3,textarea.span3,.uneditable-input.span3{width:156px}input.span2,textarea.span2,.uneditable-input.span2{width:94px}input.span1,textarea.span1,.uneditable-input.span1{width:32px}}@media(max-width:979px){body{padding-top:0}.navbar-fixed-top,.navbar-fixed-bottom{position:static}.navbar-fixed-top{margin-bottom:18px}.navbar-fixed-bottom{margin-top:18px}.navbar-fixed-top .navbar-inner,.navbar-fixed-bottom .navbar-inner{padding:5px}.navbar .container{width:auto;padding:0}.navbar .brand{padding-right:10px;padding-left:10px;margin:0 0 0 -5px}.nav-collapse{clear:both}.nav-collapse .nav{float:none;margin:0 0 9px}.nav-collapse .nav>li{float:none}.nav-collapse .nav>li>a{margin-bottom:2px}.nav-collapse .nav>.divider-vertical{display:none}.nav-collapse .nav .nav-header{color:#999;text-shadow:none}.nav-collapse .nav>li>a,.nav-collapse .dropdown-menu a{padding:6px 15px;font-weight:bold;color:#999;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.nav-collapse .btn{padding:4px 10px 4px;font-weight:normal;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.nav-collapse .dropdown-menu li+li a{margin-bottom:2px}.nav-collapse .nav>li>a:hover,.nav-collapse .dropdown-menu a:hover{background-color:#222}.nav-collapse.in .btn-group{padding:0;margin-top:5px}.nav-collapse .dropdown-menu{position:static;top:auto;left:auto;display:block;float:none;max-width:none;padding:0;margin:0 15px;background-color:transparent;border:0;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none}.nav-collapse .dropdown-menu:before,.nav-collapse .dropdown-menu:after{display:none}.nav-collapse .dropdown-menu .divider{display:none}.nav-collapse .navbar-form,.nav-collapse .navbar-search{float:none;padding:9px 15px;margin:9px 0;border-top:1px solid #222;border-bottom:1px solid #222;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.1);-moz-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.1);box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.1)}.navbar .nav-collapse .nav.pull-right{float:none;margin-left:0}.nav-collapse,.nav-collapse.collapse{height:0;overflow:hidden}.navbar .btn-navbar{display:block}.navbar-static .navbar-inner{padding-right:10px;padding-left:10px}}
+/* Modified to remove 976px+ expansion. */
\ No newline at end of file
/Fim/
diff --git a/website/static/bootstrap.min.css b/website/static/bootstrap.min.css
new file mode 100644
index 0000000..3916580
--- /dev/null
+++ b/website/static/bootstrap.min.css
@@ -0,0 +1,9 @@
+/*!
+ * Bootstrap v2.0.4
+ *
+ * Copyright 2012 Twitter, Inc
+ * Licensed under the Apache License v2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Designed and built with all the love in the world @twitter by @mdo and @fat.
+ */article,aside,details,figcaption,figure,footer,header,hgroup,nav,section{display:block}audio,canvas,video{display:inline-block;*display:inline;*zoom:1}audio:not([controls]){display:none}html{font-size:100%;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}a:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}a:hover,a:active{outline:0}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{max-width:100%;vertical-align:middle;border:0;-ms-interpolation-mode:bicubic}#map_canvas img{max-width:none}button,input,select,textarea{margin:0;font-size:100%;vertical-align:middle}button,input{*overflow:visible;line-height:normal}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}button,input[type="button"],input[type="reset"],input[type="submit"]{cursor:pointer;-webkit-appearance:button}input[type="search"]{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;-webkit-appearance:textfield}input[type="search"]::-webkit-search-decoration,input[type="search"]::-webkit-search-cancel-button{-webkit-appearance:none}textarea{overflow:auto;vertical-align:top}.clearfix{*zoom:1}.clearfix:before,.clearfix:after{display:table;content:""}.clearfix:after{clear:both}.hide-text{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.input-block-level{display:block;width:100%;min-height:28px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;box-sizing:border-box}body{margin:0;font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:13px;line-height:18px;color:#333;background-color:#fff}a{color:#08c;text-decoration:none}a:hover{color:#005580;text-decoration:underline}.row{margin-left:-20px;*zoom:1}.row:before,.row:after{display:table;content:""}.row:after{clear:both}[class*="span"]{float:left;margin-left:20px}.container,.navbar-fixed-top .container,.navbar-fixed-bottom .container{width:940px}.span12{width:940px}.span11{width:860px}.span10{width:780px}.span9{width:700px}.span8{width:620px}.span7{width:540px}.span6{width:460px}.span5{width:380px}.span4{width:300px}.span3{width:220px}.span2{width:140px}.span1{width:60px}.offset12{margin-left:980px}.offset11{margin-left:900px}.offset10{margin-left:820px}.offset9{margin-left:740px}.offset8{margin-left:660px}.offset7{margin-left:580px}.offset6{margin-left:500px}.offset5{margin-left:420px}.offset4{margin-left:340px}.offset3{margin-left:260px}.offset2{margin-left:180px}.offset1{margin-left:100px}.row-fluid{width:100%;*zoom:1}.row-fluid:before,.row-fluid:after{display:table;content:""}.row-fluid:after{clear:both}.row-fluid [class*="span"]{display:block;float:left;width:100%;min-height:28px;margin-left:2.127659574%;*margin-left:2.0744680846382977%;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;box-sizing:border-box}.row-fluid [class*="span"]:first-child{margin-left:0}.row-fluid .span12{width:99.99999998999999%;*width:99.94680850063828%}.row-fluid .span11{width:91.489361693%;*width:91.4361702036383%}.row-fluid .span10{width:82.97872339599999%;*width:82.92553190663828%}.row-fluid .span9{width:74.468085099%;*width:74.4148936096383%}.row-fluid .span8{width:65.95744680199999%;*width:65.90425531263828%}.row-fluid .span7{width:57.446808505%;*width:57.3936170156383%}.row-fluid .span6{width:48.93617020799999%;*width:48.88297871863829%}.row-fluid .span5{width:40.425531911%;*width:40.3723404216383%}.row-fluid .span4{width:31.914893614%;*width:31.8617021246383%}.row-fluid .span3{width:23.404255317%;*width:23.3510638276383%}.row-fluid .span2{width:14.89361702%;*width:14.8404255306383%}.row-fluid .span1{width:6.382978723%;*width:6.329787233638298%}.row-fluid .offset12{margin-left:104.25531913799999%;*margin-left:104.14893615927657%}.row-fluid .offset12:first-child{margin-left:102.127659564%;*margin-left:102.02127658527658%}.row-fluid .offset11{margin-left:95.744680841%;*margin-left:95.63829786227659%}.row-fluid .offset11:first-child{margin-left:93.61702126700001%;*margin-left:93.5106382882766%}.row-fluid .offset10{margin-left:87.23404254399999%;*margin-left:87.12765956527657%}.row-fluid .offset10:first-child{margin-left:85.10638297%;*margin-left:84.99999999127658%}.row-fluid .offset9{margin-left:78.723404247%;*margin-left:78.61702126827659%}.row-fluid .offset9:first-child{margin-left:76.59574467300001%;*margin-left:76.4893616942766%}.row-fluid .offset8{margin-left:70.21276594999999%;*margin-left:70.10638297127657%}.row-fluid .offset8:first-child{margin-left:68.085106376%;*margin-left:67.97872339727658%}.row-fluid .offset7{margin-left:61.702127653%;*margin-left:61.595744674276595%}.row-fluid .offset7:first-child{margin-left:59.574468079%;*margin-left:59.468085100276596%}.row-fluid .offset6{margin-left:53.19148935599999%;*margin-left:53.08510637727659%}.row-fluid .offset6:first-child{margin-left:51.06382978199999%;*margin-left:50.95744680327659%}.row-fluid .offset5{margin-left:44.680851059%;*margin-left:44.574468080276596%}.row-fluid .offset5:first-child{margin-left:42.553191485%;*margin-left:42.4468085062766%}.row-fluid .offset4{margin-left:36.170212762%;*margin-left:36.063829783276596%}.row-fluid .offset4:first-child{margin-left:34.042553188%;*margin-left:33.9361702092766%}.row-fluid .offset3{margin-left:27.659574465%;*margin-left:27.553191486276596%}.row-fluid .offset3:first-child{margin-left:25.531914891%;*margin-left:25.425531912276597%}.row-fluid .offset2{margin-left:19.148936168%;*margin-left:19.042553189276596%}.row-fluid .offset2:first-child{margin-left:17.021276594%;*margin-left:16.914893615276597%}.row-fluid .offset1{margin-left:10.638297870999999%;*margin-left:10.531914892276596%}.row-fluid .offset1:first-child{margin-left:8.510638297%;*margin-left:8.404255318276597%}.container{margin-right:auto;margin-left:auto;*zoom:1}.container:before,.container:after{display:table;content:""}.container:after{clear:both}.container-fluid{padding-right:20px;padding-left:20px;*zoom:1}.container-fluid:before,.container-fluid:after{display:table;content:""}.container-fluid:after{clear:both}p{margin:0 0 9px}p small{font-size:11px;color:#999}.lead{margin-bottom:18px;font-size:20px;font-weight:200;line-height:27px}h1,h2,h3,h4,h5,h6{margin:0;font-family:inherit;font-weight:bold;color:inherit;text-rendering:optimizelegibility}h1 small,h2 small,h3 small,h4 small,h5 small,h6 small{font-weight:normal;color:#999}h1{font-size:30px;line-height:36px}h1 small{font-size:18px}h2{font-size:24px;line-height:36px}h2 small{font-size:18px}h3{font-size:18px;line-height:27px}h3 small{font-size:14px}h4,h5,h6{line-height:18px}h4{font-size:14px}h4 small{font-size:12px}h5{font-size:12px}h6{font-size:11px;color:#999;text-transform:uppercase}.page-header{padding-bottom:17px;margin:18px 0;border-bottom:1px solid #eee}.page-header h1{line-height:1}ul,ol{padding:0;margin:0 0 9px 25px}ul ul,ul ol,ol ol,ol ul{margin-bottom:0}ul{list-style:disc}ol{list-style:decimal}li{line-height:18px}ul.unstyled,ol.unstyled{margin-left:0;list-style:none}dl{margin-bottom:18px}dt,dd{line-height:18px}dt{font-weight:bold;line-height:17px}dd{margin-left:9px}.dl-horizontal dt{float:left;width:120px;overflow:hidden;clear:left;text-align:right;text-overflow:ellipsis;white-space:nowrap}.dl-horizontal dd{margin-left:130px}hr{margin:18px 0;border:0;border-top:1px solid #eee;border-bottom:1px solid #fff}strong{font-weight:bold}em{font-style:italic}.muted{color:#999}abbr[title]{cursor:help;border-bottom:1px dotted #999}abbr.initialism{font-size:90%;text-transform:uppercase}blockquote{padding:0 0 0 15px;margin:0 0 18px;border-left:5px solid #eee}blockquote p{margin-bottom:0;font-size:16px;font-weight:300;line-height:22.5px}blockquote small{display:block;line-height:18px;color:#999}blockquote small:before{content:'\2014 \00A0'}blockquote.pull-right{float:right;padding-right:15px;padding-left:0;border-right:5px solid #eee;border-left:0}blockquote.pull-right p,blockquote.pull-right small{text-align:right}q:before,q:after,blockquote:before,blockquote:after{content:""}address{display:block;margin-bottom:18px;font-style:normal;line-height:18px}small{font-size:100%}cite{font-style:normal}code,pre{padding:0 3px 2px;font-family:Menlo,Monaco,Consolas,"Courier New",monospace;font-size:12px;color:#333;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}code{padding:2px 4px;color:#d14;background-color:#f7f7f9;border:1px solid #e1e1e8}pre{display:block;padding:8.5px;margin:0 0 9px;font-size:12.025px;line-height:18px;word-break:break-all;word-wrap:break-word;white-space:pre;white-space:pre-wrap;background-color:#f5f5f5;border:1px solid #ccc;border:1px solid rgba(0,0,0,0.15);-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}pre.prettyprint{margin-bottom:18px}pre code{padding:0;color:inherit;background-color:transparent;border:0}.pre-scrollable{max-height:340px;overflow-y:scroll}form{margin:0 0 18px}fieldset{padding:0;margin:0;border:0}legend{display:block;width:100%;padding:0;margin-bottom:27px;font-size:19.5px;line-height:36px;color:#333;border:0;border-bottom:1px solid #e5e5e5}legend small{font-size:13.5px;color:#999}label,input,button,select,textarea{font-size:13px;font-weight:normal;line-height:18px}input,button,select,textarea{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif}label{display:block;margin-bottom:5px}select,textarea,input[type="text"],input[type="password"],input[type="datetime"],input[type="datetime-local"],input[type="date"],input[type="month"],input[type="time"],input[type="week"],input[type="number"],input[type="email"],input[type="url"],input[type="search"],input[type="tel"],input[type="color"],.uneditable-input{display:inline-block;height:18px;padding:4px;margin-bottom:9px;font-size:13px;line-height:18px;color:#555;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}input,textarea{width:210px}textarea{height:auto}textarea,input[type="text"],input[type="password"],input[type="datetime"],input[type="datetime-local"],input[type="date"],input[type="month"],input[type="time"],input[type="week"],input[type="number"],input[type="email"],input[type="url"],input[type="search"],input[type="tel"],input[type="color"],.uneditable-input{background-color:#fff;border:1px solid #ccc;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-webkit-transition:border linear .2s,box-shadow linear .2s;-moz-transition:border linear .2s,box-shadow linear .2s;-ms-transition:border linear .2s,box-shadow linear .2s;-o-transition:border linear .2s,box-shadow linear .2s;transition:border linear .2s,box-shadow linear .2s}textarea:focus,input[type="text"]:focus,input[type="password"]:focus,input[type="datetime"]:focus,input[type="datetime-local"]:focus,input[type="date"]:focus,input[type="month"]:focus,input[type="time"]:focus,input[type="week"]:focus,input[type="number"]:focus,input[type="email"]:focus,input[type="url"]:focus,input[type="search"]:focus,input[type="tel"]:focus,input[type="color"]:focus,.uneditable-input:focus{border-color:rgba(82,168,236,0.8);outline:0;outline:thin dotted \9;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(82,168,236,0.6);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(82,168,236,0.6);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(82,168,236,0.6)}input[type="radio"],input[type="checkbox"]{margin:3px 0;*margin-top:0;line-height:normal;cursor:pointer}input[type="image"],input[type="submit"],input[type="reset"],input[type="button"],input[type="radio"],input[type="checkbox"]{width:auto}.uneditable-textarea{width:auto;height:auto}select,input[type="file"]{height:28px;*margin-top:4px;line-height:28px}select{width:220px;border:1px solid #bbb}select[multiple],select[size]{height:auto}select:focus,input[type="file"]:focus,input[type="radio"]:focus,input[type="checkbox"]:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.radio,.checkbox{min-height:18px;padding-left:18px}.radio input[type="radio"],.checkbox input[type="checkbox"]{float:left;margin-left:-18px}.controls>.radio:first-child,.controls>.checkbox:first-child{padding-top:5px}.radio.inline,.checkbox.inline{display:inline-block;padding-top:5px;margin-bottom:0;vertical-align:middle}.radio.inline+.radio.inline,.checkbox.inline+.checkbox.inline{margin-left:10px}.input-mini{width:60px}.input-small{width:90px}.input-medium{width:150px}.input-large{width:210px}.input-xlarge{width:270px}.input-xxlarge{width:530px}input[class*="span"],select[class*="span"],textarea[class*="span"],.uneditable-input[class*="span"],.row-fluid input[class*="span"],.row-fluid select[class*="span"],.row-fluid textarea[class*="span"],.row-fluid .uneditable-input[class*="span"]{float:none;margin-left:0}.input-append input[class*="span"],.input-append .uneditable-input[class*="span"],.input-prepend input[class*="span"],.input-prepend .uneditable-input[class*="span"],.row-fluid .input-prepend [class*="span"],.row-fluid .input-append [class*="span"]{display:inline-block}input,textarea,.uneditable-input{margin-left:0}input.span12,textarea.span12,.uneditable-input.span12{width:930px}input.span11,textarea.span11,.uneditable-input.span11{width:850px}input.span10,textarea.span10,.uneditable-input.span10{width:770px}input.span9,textarea.span9,.uneditable-input.span9{width:690px}input.span8,textarea.span8,.uneditable-input.span8{width:610px}input.span7,textarea.span7,.uneditable-input.span7{width:530px}input.span6,textarea.span6,.uneditable-input.span6{width:450px}input.span5,textarea.span5,.uneditable-input.span5{width:370px}input.span4,textarea.span4,.uneditable-input.span4{width:290px}input.span3,textarea.span3,.uneditable-input.span3{width:210px}input.span2,textarea.span2,.uneditable-input.span2{width:130px}input.span1,textarea.span1,.uneditable-input.span1{width:50px}input[disabled],select[disabled],textarea[disabled],input[readonly],select[readonly],textarea[readonly]{cursor:not-allowed;background-color:#eee;border-color:#ddd}input[type="radio"][disabled],input[type="checkbox"][disabled],input[type="radio"][readonly],input[type="checkbox"][readonly]{background-color:transparent}.control-group.warning>label,.control-group.warning .help-block,.control-group.warning .help-inline{color:#c09853}.control-group.warning .checkbox,.control-group.warning .radio,.control-group.warning input,.control-group.warning select,.control-group.warning textarea{color:#c09853;border-color:#c09853}.control-group.warning .checkbox:focus,.control-group.warning .radio:focus,.control-group.warning input:focus,.control-group.warning select:focus,.control-group.warning textarea:focus{border-color:#a47e3c;-webkit-box-shadow:0 0 6px #dbc59e;-moz-box-shadow:0 0 6px #dbc59e;box-shadow:0 0 6px #dbc59e}.control-group.warning .input-prepend .add-on,.control-group.warning .input-append .add-on{color:#c09853;background-color:#fcf8e3;border-color:#c09853}.control-group.error>label,.control-group.error .help-block,.control-group.error .help-inline{color:#b94a48}.control-group.error .checkbox,.control-group.error .radio,.control-group.error input,.control-group.error select,.control-group.error textarea{color:#b94a48;border-color:#b94a48}.control-group.error .checkbox:focus,.control-group.error .radio:focus,.control-group.error input:focus,.control-group.error select:focus,.control-group.error textarea:focus{border-color:#953b39;-webkit-box-shadow:0 0 6px #d59392;-moz-box-shadow:0 0 6px #d59392;box-shadow:0 0 6px #d59392}.control-group.error .input-prepend .add-on,.control-group.error .input-append .add-on{color:#b94a48;background-color:#f2dede;border-color:#b94a48}.control-group.success>label,.control-group.success .help-block,.control-group.success .help-inline{color:#468847}.control-group.success .checkbox,.control-group.success .radio,.control-group.success input,.control-group.success select,.control-group.success textarea{color:#468847;border-color:#468847}.control-group.success .checkbox:focus,.control-group.success .radio:focus,.control-group.success input:focus,.control-group.success select:focus,.control-group.success textarea:focus{border-color:#356635;-webkit-box-shadow:0 0 6px #7aba7b;-moz-box-shadow:0 0 6px #7aba7b;box-shadow:0 0 6px #7aba7b}.control-group.success .input-prepend .add-on,.control-group.success .input-append .add-on{color:#468847;background-color:#dff0d8;border-color:#468847}input:focus:required:invalid,textarea:focus:required:invalid,select:focus:required:invalid{color:#b94a48;border-color:#ee5f5b}input:focus:required:invalid:focus,textarea:focus:required:invalid:focus,select:focus:required:invalid:focus{border-color:#e9322d;-webkit-box-shadow:0 0 6px #f8b9b7;-moz-box-shadow:0 0 6px #f8b9b7;box-shadow:0 0 6px #f8b9b7}.form-actions{padding:17px 20px 18px;margin-top:18px;margin-bottom:18px;background-color:#f5f5f5;border-top:1px solid #e5e5e5;*zoom:1}.form-actions:before,.form-actions:after{display:table;content:""}.form-actions:after{clear:both}.uneditable-input{overflow:hidden;white-space:nowrap;cursor:not-allowed;background-color:#fff;border-color:#eee;-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.025);-moz-box-shadow:inset 0 1px 2px rgba(0,0,0,0.025);box-shadow:inset 0 1px 2px rgba(0,0,0,0.025)}input:-moz-placeholder,textarea:-moz-placeholder{color:#999}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#999}input::-webkit-input-placeholder,textarea::-webkit-input-placeholder{color:#999}.help-block,.help-inline{color:#555}.help-block{display:block;margin-bottom:9px}.help-inline{display:inline-block;*display:inline;padding-left:5px;vertical-align:middle;*zoom:1}.input-prepend,.input-append{margin-bottom:5px;font-size:0}.input-prepend input,.input-append input,.input-prepend select,.input-append select,.input-prepend .uneditable-input,.input-append .uneditable-input{position:relative;margin-bottom:0;*margin-left:0;font-size:13px;vertical-align:middle;-webkit-border-radius:0 3px 3px 0;-moz-border-radius:0 3px 3px 0;border-radius:0 3px 3px 0}.input-prepend input:focus,.input-append input:focus,.input-prepend select:focus,.input-append select:focus,.input-prepend .uneditable-input:focus,.input-append .uneditable-input:focus{z-index:2}.input-prepend .uneditable-input,.input-append .uneditable-input{border-left-color:#ccc}.input-prepend .add-on,.input-append .add-on{display:inline-block;width:auto;height:18px;min-width:16px;padding:4px 5px;font-size:13px;font-weight:normal;line-height:18px;text-align:center;text-shadow:0 1px 0 #fff;vertical-align:middle;background-color:#eee;border:1px solid #ccc}.input-prepend .add-on,.input-append .add-on,.input-prepend .btn,.input-append .btn{margin-left:-1px;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.input-prepend .active,.input-append .active{background-color:#a9dba9;border-color:#46a546}.input-prepend .add-on,.input-prepend .btn{margin-right:-1px}.input-prepend .add-on:first-child,.input-prepend .btn:first-child{-webkit-border-radius:3px 0 0 3px;-moz-border-radius:3px 0 0 3px;border-radius:3px 0 0 3px}.input-append input,.input-append select,.input-append .uneditable-input{-webkit-border-radius:3px 0 0 3px;-moz-border-radius:3px 0 0 3px;border-radius:3px 0 0 3px}.input-append .uneditable-input{border-right-color:#ccc;border-left-color:#eee}.input-append .add-on:last-child,.input-append .btn:last-child{-webkit-border-radius:0 3px 3px 0;-moz-border-radius:0 3px 3px 0;border-radius:0 3px 3px 0}.input-prepend.input-append input,.input-prepend.input-append select,.input-prepend.input-append .uneditable-input{-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.input-prepend.input-append .add-on:first-child,.input-prepend.input-append .btn:first-child{margin-right:-1px;-webkit-border-radius:3px 0 0 3px;-moz-border-radius:3px 0 0 3px;border-radius:3px 0 0 3px}.input-prepend.input-append .add-on:last-child,.input-prepend.input-append .btn:last-child{margin-left:-1px;-webkit-border-radius:0 3px 3px 0;-moz-border-radius:0 3px 3px 0;border-radius:0 3px 3px 0}input.search-query{padding-right:14px;padding-right:4px \9;padding-left:14px;padding-left:4px \9;margin-bottom:0;-webkit-border-radius:14px;-moz-border-radius:14px;border-radius:14px}.form-search input,.form-inline input,.form-horizontal input,.form-search textarea,.form-inline textarea,.form-horizontal textarea,.form-search select,.form-inline select,.form-horizontal select,.form-search .help-inline,.form-inline .help-inline,.form-horizontal .help-inline,.form-search .uneditable-input,.form-inline .uneditable-input,.form-horizontal .uneditable-input,.form-search .input-prepend,.form-inline .input-prepend,.form-horizontal .input-prepend,.form-search .input-append,.form-inline .input-append,.form-horizontal .input-append{display:inline-block;*display:inline;margin-bottom:0;*zoom:1}.form-search .hide,.form-inline .hide,.form-horizontal .hide{display:none}.form-search label,.form-inline label{display:inline-block}.form-search .input-append,.form-inline .input-append,.form-search .input-prepend,.form-inline .input-prepend{margin-bottom:0}.form-search .radio,.form-search .checkbox,.form-inline .radio,.form-inline .checkbox{padding-left:0;margin-bottom:0;vertical-align:middle}.form-search .radio input[type="radio"],.form-search .checkbox input[type="checkbox"],.form-inline .radio input[type="radio"],.form-inline .checkbox input[type="checkbox"]{float:left;margin-right:3px;margin-left:0}.control-group{margin-bottom:9px}legend+.control-group{margin-top:18px;-webkit-margin-top-collapse:separate}.form-horizontal .control-group{margin-bottom:18px;*zoom:1}.form-horizontal .control-group:before,.form-horizontal .control-group:after{display:table;content:""}.form-horizontal .control-group:after{clear:both}.form-horizontal .control-label{float:left;width:140px;padding-top:5px;text-align:right}.form-horizontal .controls{*display:inline-block;*padding-left:20px;margin-left:160px;*margin-left:0}.form-horizontal .controls:first-child{*padding-left:160px}.form-horizontal .help-block{margin-top:9px;margin-bottom:0}.form-horizontal .form-actions{padding-left:160px}table{max-width:100%;background-color:transparent;border-collapse:collapse;border-spacing:0}.table{width:100%;margin-bottom:18px}.table th,.table td{padding:8px;line-height:18px;text-align:left;vertical-align:top;border-top:1px solid #ddd}.table th{font-weight:bold}.table thead th{vertical-align:bottom}.table caption+thead tr:first-child th,.table caption+thead tr:first-child td,.table colgroup+thead tr:first-child th,.table colgroup+thead tr:first-child td,.table thead:first-child tr:first-child th,.table thead:first-child tr:first-child td{border-top:0}.table tbody+tbody{border-top:2px solid #ddd}.table-condensed th,.table-condensed td{padding:4px 5px}.table-bordered{border:1px solid #ddd;border-collapse:separate;*border-collapse:collapsed;border-left:0;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.table-bordered th,.table-bordered td{border-left:1px solid #ddd}.table-bordered caption+thead tr:first-child th,.table-bordered caption+tbody tr:first-child th,.table-bordered caption+tbody tr:first-child td,.table-bordered colgroup+thead tr:first-child th,.table-bordered colgroup+tbody tr:first-child th,.table-bordered colgroup+tbody tr:first-child td,.table-bordered thead:first-child tr:first-child th,.table-bordered tbody:first-child tr:first-child th,.table-bordered tbody:first-child tr:first-child td{border-top:0}.table-bordered thead:first-child tr:first-child th:first-child,.table-bordered tbody:first-child tr:first-child td:first-child{-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-topleft:4px}.table-bordered thead:first-child tr:first-child th:last-child,.table-bordered tbody:first-child tr:first-child td:last-child{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-moz-border-radius-topright:4px}.table-bordered thead:last-child tr:last-child th:first-child,.table-bordered tbody:last-child tr:last-child td:first-child{-webkit-border-radius:0 0 0 4px;-moz-border-radius:0 0 0 4px;border-radius:0 0 0 4px;-webkit-border-bottom-left-radius:4px;border-bottom-left-radius:4px;-moz-border-radius-bottomleft:4px}.table-bordered thead:last-child tr:last-child th:last-child,.table-bordered tbody:last-child tr:last-child td:last-child{-webkit-border-bottom-right-radius:4px;border-bottom-right-radius:4px;-moz-border-radius-bottomright:4px}.table-striped tbody tr:nth-child(odd) td,.table-striped tbody tr:nth-child(odd) th{background-color:#f9f9f9}.table tbody tr:hover td,.table tbody tr:hover th{background-color:#f5f5f5}table .span1{float:none;width:44px;margin-left:0}table .span2{float:none;width:124px;margin-left:0}table .span3{float:none;width:204px;margin-left:0}table .span4{float:none;width:284px;margin-left:0}table .span5{float:none;width:364px;margin-left:0}table .span6{float:none;width:444px;margin-left:0}table .span7{float:none;width:524px;margin-left:0}table .span8{float:none;width:604px;margin-left:0}table .span9{float:none;width:684px;margin-left:0}table .span10{float:none;width:764px;margin-left:0}table .span11{float:none;width:844px;margin-left:0}table .span12{float:none;width:924px;margin-left:0}table .span13{float:none;width:1004px;margin-left:0}table .span14{float:none;width:1084px;margin-left:0}table .span15{float:none;width:1164px;margin-left:0}table .span16{float:none;width:1244px;margin-left:0}table .span17{float:none;width:1324px;margin-left:0}table .span18{float:none;width:1404px;margin-left:0}table .span19{float:none;width:1484px;margin-left:0}table .span20{float:none;width:1564px;margin-left:0}table .span21{float:none;width:1644px;margin-left:0}table .span22{float:none;width:1724px;margin-left:0}table .span23{float:none;width:1804px;margin-left:0}table .span24{float:none;width:1884px;margin-left:0}[class^="icon-"],[class*=" icon-"]{display:inline-block;width:14px;height:14px;*margin-right:.3em;line-height:14px;vertical-align:text-top;background-image:url("../img/glyphicons-halflings.png");background-position:14px 14px;background-repeat:no-repeat}[class^="icon-"]:last-child,[class*=" icon-"]:last-child{*margin-left:0}.icon-white{background-image:url("../img/glyphicons-halflings-white.png")}.icon-glass{background-position:0 0}.icon-music{background-position:-24px 0}.icon-search{background-position:-48px 0}.icon-envelope{background-position:-72px 0}.icon-heart{background-position:-96px 0}.icon-star{background-position:-120px 0}.icon-star-empty{background-position:-144px 0}.icon-user{background-position:-168px 0}.icon-film{background-position:-192px 0}.icon-th-large{background-position:-216px 0}.icon-th{background-position:-240px 0}.icon-th-list{background-position:-264px 0}.icon-ok{background-position:-288px 0}.icon-remove{background-position:-312px 0}.icon-zoom-in{background-position:-336px 0}.icon-zoom-out{background-position:-360px 0}.icon-off{background-position:-384px 0}.icon-signal{background-position:-408px 0}.icon-cog{background-position:-432px 0}.icon-trash{background-position:-456px 0}.icon-home{background-position:0 -24px}.icon-file{background-position:-24px -24px}.icon-time{background-position:-48px -24px}.icon-road{background-position:-72px -24px}.icon-download-alt{background-position:-96px -24px}.icon-download{background-position:-120px -24px}.icon-upload{background-position:-144px -24px}.icon-inbox{background-position:-168px -24px}.icon-play-circle{background-position:-192px -24px}.icon-repeat{background-position:-216px -24px}.icon-refresh{background-position:-240px -24px}.icon-list-alt{background-position:-264px -24px}.icon-lock{background-position:-287px -24px}.icon-flag{background-position:-312px -24px}.icon-headphones{background-position:-336px -24px}.icon-volume-off{background-position:-360px -24px}.icon-volume-down{background-position:-384px -24px}.icon-volume-up{background-position:-408px -24px}.icon-qrcode{background-position:-432px -24px}.icon-barcode{background-position:-456px -24px}.icon-tag{background-position:0 -48px}.icon-tags{background-position:-25px -48px}.icon-book{background-position:-48px -48px}.icon-bookmark{background-position:-72px -48px}.icon-print{background-position:-96px -48px}.icon-camera{background-position:-120px -48px}.icon-font{background-position:-144px -48px}.icon-bold{background-position:-167px -48px}.icon-italic{background-position:-192px -48px}.icon-text-height{background-position:-216px -48px}.icon-text-width{background-position:-240px -48px}.icon-align-left{background-position:-264px -48px}.icon-align-center{background-position:-288px -48px}.icon-align-right{background-position:-312px -48px}.icon-align-justify{background-position:-336px -48px}.icon-list{background-position:-360px -48px}.icon-indent-left{background-position:-384px -48px}.icon-indent-right{background-position:-408px -48px}.icon-facetime-video{background-position:-432px -48px}.icon-picture{background-position:-456px -48px}.icon-pencil{background-position:0 -72px}.icon-map-marker{background-position:-24px -72px}.icon-adjust{background-position:-48px -72px}.icon-tint{background-position:-72px -72px}.icon-edit{background-position:-96px -72px}.icon-share{background-position:-120px -72px}.icon-check{background-position:-144px -72px}.icon-move{background-position:-168px -72px}.icon-step-backward{background-position:-192px -72px}.icon-fast-backward{background-position:-216px -72px}.icon-backward{background-position:-240px -72px}.icon-play{background-position:-264px -72px}.icon-pause{background-position:-288px -72px}.icon-stop{background-position:-312px -72px}.icon-forward{background-position:-336px -72px}.icon-fast-forward{background-position:-360px -72px}.icon-step-forward{background-position:-384px -72px}.icon-eject{background-position:-408px -72px}.icon-chevron-left{background-position:-432px -72px}.icon-chevron-right{background-position:-456px -72px}.icon-plus-sign{background-position:0 -96px}.icon-minus-sign{background-position:-24px -96px}.icon-remove-sign{background-position:-48px -96px}.icon-ok-sign{background-position:-72px -96px}.icon-question-sign{background-position:-96px -96px}.icon-info-sign{background-position:-120px -96px}.icon-screenshot{background-position:-144px -96px}.icon-remove-circle{background-position:-168px -96px}.icon-ok-circle{background-position:-192px -96px}.icon-ban-circle{background-position:-216px -96px}.icon-arrow-left{background-position:-240px -96px}.icon-arrow-right{background-position:-264px -96px}.icon-arrow-up{background-position:-289px -96px}.icon-arrow-down{background-position:-312px -96px}.icon-share-alt{background-position:-336px -96px}.icon-resize-full{background-position:-360px -96px}.icon-resize-small{background-position:-384px -96px}.icon-plus{background-position:-408px -96px}.icon-minus{background-position:-433px -96px}.icon-asterisk{background-position:-456px -96px}.icon-exclamation-sign{background-position:0 -120px}.icon-gift{background-position:-24px -120px}.icon-leaf{background-position:-48px -120px}.icon-fire{background-position:-72px -120px}.icon-eye-open{background-position:-96px -120px}.icon-eye-close{background-position:-120px -120px}.icon-warning-sign{background-position:-144px -120px}.icon-plane{background-position:-168px -120px}.icon-calendar{background-position:-192px -120px}.icon-random{width:16px;background-position:-216px -120px}.icon-comment{background-position:-240px -120px}.icon-magnet{background-position:-264px -120px}.icon-chevron-up{background-position:-288px -120px}.icon-chevron-down{background-position:-313px -119px}.icon-retweet{background-position:-336px -120px}.icon-shopping-cart{background-position:-360px -120px}.icon-folder-close{background-position:-384px -120px}.icon-folder-open{width:16px;background-position:-408px -120px}.icon-resize-vertical{background-position:-432px -119px}.icon-resize-horizontal{background-position:-456px -118px}.icon-hdd{background-position:0 -144px}.icon-bullhorn{background-position:-24px -144px}.icon-bell{background-position:-48px -144px}.icon-certificate{background-position:-72px -144px}.icon-thumbs-up{background-position:-96px -144px}.icon-thumbs-down{background-position:-120px -144px}.icon-hand-right{background-position:-144px -144px}.icon-hand-left{background-position:-168px -144px}.icon-hand-up{background-position:-192px -144px}.icon-hand-down{background-position:-216px -144px}.icon-circle-arrow-right{background-position:-240px -144px}.icon-circle-arrow-left{background-position:-264px -144px}.icon-circle-arrow-up{background-position:-288px -144px}.icon-circle-arrow-down{background-position:-312px -144px}.icon-globe{background-position:-336px -144px}.icon-wrench{background-position:-360px -144px}.icon-tasks{background-position:-384px -144px}.icon-filter{background-position:-408px -144px}.icon-briefcase{background-position:-432px -144px}.icon-fullscreen{background-position:-456px -144px}.dropup,.dropdown{position:relative}.dropdown-toggle{*margin-bottom:-3px}.dropdown-toggle:active,.open .dropdown-toggle{outline:0}.caret{display:inline-block;width:0;height:0;vertical-align:top;border-top:4px solid #000;border-right:4px solid transparent;border-left:4px solid transparent;content:"";opacity:.3;filter:alpha(opacity=30)}.dropdown .caret{margin-top:8px;margin-left:2px}.dropdown a:focus .caret,.dropdown a:hover .caret,.open .caret{opacity:1;filter:alpha(opacity=100)}.navbar .nav .open>a{color:#fff}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:160px;padding:5px 0;margin:1px 0 0;list-style:none;background-color:#fff;border:1px solid #ccc;border:1px solid rgba(0,0,0,0.2);*border-right-width:2px;*border-bottom-width:2px;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;-webkit-box-shadow:0 5px 10px rgba(0,0,0,0.2);-moz-box-shadow:0 5px 10px rgba(0,0,0,0.2);box-shadow:0 5px 10px rgba(0,0,0,0.2);-webkit-background-clip:padding-box;-moz-background-clip:padding;background-clip:padding-box}.dropdown-menu.pull-right{right:0;left:auto}.dropdown-menu .divider{*width:100%;height:1px;margin:8px 1px;*margin:-5px 0 5px;overflow:hidden;background-color:#e5e5e5;border-bottom:1px solid #fff}.dropdown-menu a{display:block;padding:3px 15px;clear:both;font-weight:normal;line-height:18px;color:#333;white-space:nowrap}.dropdown-menu li>a:hover,.dropdown-menu li>a:focus{color:#333;text-decoration:none;background-color:#eee}.dropdown-menu .active>a,.dropdown-menu .active>a:hover{color:#fff;text-decoration:none;background-color:#08c;outline:0}.dropdown-menu .disabled>a,.dropdown-menu .disabled>a:hover{color:#999}.dropdown-menu .disabled>a:hover{text-decoration:none;cursor:default;background-color:transparent}.open{*z-index:1000}.open>.dropdown-menu{display:block}.pull-right>.dropdown-menu{right:0;left:auto}.dropup .caret,.navbar-fixed-bottom .dropdown .caret{border-top:0;border-bottom:4px solid #000;content:"\2191"}.dropup .dropdown-menu,.navbar-fixed-bottom .dropdown .dropdown-menu{top:auto;bottom:100%;margin-bottom:1px}.typeahead{margin-top:2px;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.well{min-height:20px;padding:19px;margin-bottom:20px;background-color:#f5f5f5;border:1px solid #eee;border:1px solid rgba(0,0,0,0.05);-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.05);box-shadow:inset 0 1px 1px rgba(0,0,0,0.05)}.well blockquote{border-color:#ddd;border-color:rgba(0,0,0,0.15)}.well-large{padding:24px;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.well-small{padding:9px;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.fade{opacity:0;-webkit-transition:opacity .15s linear;-moz-transition:opacity .15s linear;-ms-transition:opacity .15s linear;-o-transition:opacity .15s linear;transition:opacity .15s linear}.fade.in{opacity:1}.collapse{position:relative;height:0;overflow:hidden;-webkit-transition:height .35s ease;-moz-transition:height .35s ease;-ms-transition:height .35s ease;-o-transition:height .35s ease;transition:height .35s ease}.collapse.in{height:auto}.close{float:right;font-size:20px;font-weight:bold;line-height:18px;color:#000;text-shadow:0 1px 0 #fff;opacity:.2;filter:alpha(opacity=20)}.close:hover{color:#000;text-decoration:none;cursor:pointer;opacity:.4;filter:alpha(opacity=40)}button.close{padding:0;cursor:pointer;background:transparent;border:0;-webkit-appearance:none}.btn{display:inline-block;*display:inline;padding:4px 10px 4px;margin-bottom:0;*margin-left:.3em;font-size:13px;line-height:18px;*line-height:20px;color:#333;text-align:center;text-shadow:0 1px 1px rgba(255,255,255,0.75);vertical-align:middle;cursor:pointer;background-color:#f5f5f5;*background-color:#e6e6e6;background-image:-ms-linear-gradient(top,#fff,#e6e6e6);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fff),to(#e6e6e6));background-image:-webkit-linear-gradient(top,#fff,#e6e6e6);background-image:-o-linear-gradient(top,#fff,#e6e6e6);background-image:linear-gradient(top,#fff,#e6e6e6);background-image:-moz-linear-gradient(top,#fff,#e6e6e6);background-repeat:repeat-x;border:1px solid #ccc;*border:0;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);border-color:#e6e6e6 #e6e6e6 #bfbfbf;border-bottom-color:#b3b3b3;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ffffffff',endColorstr='#ffe6e6e6',GradientType=0);filter:progid:dximagetransform.microsoft.gradient(enabled=false);*zoom:1;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05)}.btn:hover,.btn:active,.btn.active,.btn.disabled,.btn[disabled]{background-color:#e6e6e6;*background-color:#d9d9d9}.btn:active,.btn.active{background-color:#ccc \9}.btn:first-child{*margin-left:0}.btn:hover{color:#333;text-decoration:none;background-color:#e6e6e6;*background-color:#d9d9d9;background-position:0 -15px;-webkit-transition:background-position .1s linear;-moz-transition:background-position .1s linear;-ms-transition:background-position .1s linear;-o-transition:background-position .1s linear;transition:background-position .1s linear}.btn:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn.active,.btn:active{background-color:#e6e6e6;background-color:#d9d9d9 \9;background-image:none;outline:0;-webkit-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05)}.btn.disabled,.btn[disabled]{cursor:default;background-color:#e6e6e6;background-image:none;opacity:.65;filter:alpha(opacity=65);-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none}.btn-large{padding:9px 14px;font-size:15px;line-height:normal;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px}.btn-large [class^="icon-"]{margin-top:1px}.btn-small{padding:5px 9px;font-size:11px;line-height:16px}.btn-small [class^="icon-"]{margin-top:-1px}.btn-mini{padding:2px 6px;font-size:11px;line-height:14px}.btn-primary,.btn-primary:hover,.btn-warning,.btn-warning:hover,.btn-danger,.btn-danger:hover,.btn-success,.btn-success:hover,.btn-info,.btn-info:hover,.btn-inverse,.btn-inverse:hover{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25)}.btn-primary.active,.btn-warning.active,.btn-danger.active,.btn-success.active,.btn-info.active,.btn-inverse.active{color:rgba(255,255,255,0.75)}.btn{border-color:#ccc;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25)}.btn-primary{background-color:#0074cc;*background-color:#05c;background-image:-ms-linear-gradient(top,#08c,#05c);background-image:-webkit-gradient(linear,0 0,0 100%,from(#08c),to(#05c));background-image:-webkit-linear-gradient(top,#08c,#05c);background-image:-o-linear-gradient(top,#08c,#05c);background-image:-moz-linear-gradient(top,#08c,#05c);background-image:linear-gradient(top,#08c,#05c);background-repeat:repeat-x;border-color:#05c #05c #003580;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ff0088cc',endColorstr='#ff0055cc',GradientType=0);filter:progid:dximagetransform.microsoft.gradient(enabled=false)}.btn-primary:hover,.btn-primary:active,.btn-primary.active,.btn-primary.disabled,.btn-primary[disabled]{background-color:#05c;*background-color:#004ab3}.btn-primary:active,.btn-primary.active{background-color:#004099 \9}.btn-warning{background-color:#faa732;*background-color:#f89406;background-image:-ms-linear-gradient(top,#fbb450,#f89406);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fbb450),to(#f89406));background-image:-webkit-linear-gradient(top,#fbb450,#f89406);background-image:-o-linear-gradient(top,#fbb450,#f89406);background-image:-moz-linear-gradient(top,#fbb450,#f89406);background-image:linear-gradient(top,#fbb450,#f89406);background-repeat:repeat-x;border-color:#f89406 #f89406 #ad6704;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:dximagetransform.microsoft.gradient(startColorstr='#fffbb450',endColorstr='#fff89406',GradientType=0);filter:progid:dximagetransform.microsoft.gradient(enabled=false)}.btn-warning:hover,.btn-warning:active,.btn-warning.active,.btn-warning.disabled,.btn-warning[disabled]{background-color:#f89406;*background-color:#df8505}.btn-warning:active,.btn-warning.active{background-color:#c67605 \9}.btn-danger{background-color:#da4f49;*background-color:#bd362f;background-image:-ms-linear-gradient(top,#ee5f5b,#bd362f);background-image:-webkit-gradient(linear,0 0,0 100%,from(#ee5f5b),to(#bd362f));background-image:-webkit-linear-gradient(top,#ee5f5b,#bd362f);background-image:-o-linear-gradient(top,#ee5f5b,#bd362f);background-image:-moz-linear-gradient(top,#ee5f5b,#bd362f);background-image:linear-gradient(top,#ee5f5b,#bd362f);background-repeat:repeat-x;border-color:#bd362f #bd362f #802420;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ffee5f5b',endColorstr='#ffbd362f',GradientType=0);filter:progid:dximagetransform.microsoft.gradient(enabled=false)}.btn-danger:hover,.btn-danger:active,.btn-danger.active,.btn-danger.disabled,.btn-danger[disabled]{background-color:#bd362f;*background-color:#a9302a}.btn-danger:active,.btn-danger.active{background-color:#942a25 \9}.btn-success{background-color:#5bb75b;*background-color:#51a351;background-image:-ms-linear-gradient(top,#62c462,#51a351);background-image:-webkit-gradient(linear,0 0,0 100%,from(#62c462),to(#51a351));background-image:-webkit-linear-gradient(top,#62c462,#51a351);background-image:-o-linear-gradient(top,#62c462,#51a351);background-image:-moz-linear-gradient(top,#62c462,#51a351);background-image:linear-gradient(top,#62c462,#51a351);background-repeat:repeat-x;border-color:#51a351 #51a351 #387038;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ff62c462',endColorstr='#ff51a351',GradientType=0);filter:progid:dximagetransform.microsoft.gradient(enabled=false)}.btn-success:hover,.btn-success:active,.btn-success.active,.btn-success.disabled,.btn-success[disabled]{background-color:#51a351;*background-color:#499249}.btn-success:active,.btn-success.active{background-color:#408140 \9}.btn-info{background-color:#49afcd;*background-color:#2f96b4;background-image:-ms-linear-gradient(top,#5bc0de,#2f96b4);background-image:-webkit-gradient(linear,0 0,0 100%,from(#5bc0de),to(#2f96b4));background-image:-webkit-linear-gradient(top,#5bc0de,#2f96b4);background-image:-o-linear-gradient(top,#5bc0de,#2f96b4);background-image:-moz-linear-gradient(top,#5bc0de,#2f96b4);background-image:linear-gradient(top,#5bc0de,#2f96b4);background-repeat:repeat-x;border-color:#2f96b4 #2f96b4 #1f6377;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ff5bc0de',endColorstr='#ff2f96b4',GradientType=0);filter:progid:dximagetransform.microsoft.gradient(enabled=false)}.btn-info:hover,.btn-info:active,.btn-info.active,.btn-info.disabled,.btn-info[disabled]{background-color:#2f96b4;*background-color:#2a85a0}.btn-info:active,.btn-info.active{background-color:#24748c \9}.btn-inverse{background-color:#414141;*background-color:#222;background-image:-ms-linear-gradient(top,#555,#222);background-image:-webkit-gradient(linear,0 0,0 100%,from(#555),to(#222));background-image:-webkit-linear-gradient(top,#555,#222);background-image:-o-linear-gradient(top,#555,#222);background-image:-moz-linear-gradient(top,#555,#222);background-image:linear-gradient(top,#555,#222);background-repeat:repeat-x;border-color:#222 #222 #000;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ff555555',endColorstr='#ff222222',GradientType=0);filter:progid:dximagetransform.microsoft.gradient(enabled=false)}.btn-inverse:hover,.btn-inverse:active,.btn-inverse.active,.btn-inverse.disabled,.btn-inverse[disabled]{background-color:#222;*background-color:#151515}.btn-inverse:active,.btn-inverse.active{background-color:#080808 \9}button.btn,input[type="submit"].btn{*padding-top:2px;*padding-bottom:2px}button.btn::-moz-focus-inner,input[type="submit"].btn::-moz-focus-inner{padding:0;border:0}button.btn.btn-large,input[type="submit"].btn.btn-large{*padding-top:7px;*padding-bottom:7px}button.btn.btn-small,input[type="submit"].btn.btn-small{*padding-top:3px;*padding-bottom:3px}button.btn.btn-mini,input[type="submit"].btn.btn-mini{*padding-top:1px;*padding-bottom:1px}.btn-group{position:relative;*margin-left:.3em;*zoom:1}.btn-group:before,.btn-group:after{display:table;content:""}.btn-group:after{clear:both}.btn-group:first-child{*margin-left:0}.btn-group+.btn-group{margin-left:5px}.btn-toolbar{margin-top:9px;margin-bottom:9px}.btn-toolbar .btn-group{display:inline-block;*display:inline;*zoom:1}.btn-group>.btn{position:relative;float:left;margin-left:-1px;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.btn-group>.btn:first-child{margin-left:0;-webkit-border-bottom-left-radius:4px;border-bottom-left-radius:4px;-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-bottomleft:4px;-moz-border-radius-topleft:4px}.btn-group>.btn:last-child,.btn-group>.dropdown-toggle{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-webkit-border-bottom-right-radius:4px;border-bottom-right-radius:4px;-moz-border-radius-topright:4px;-moz-border-radius-bottomright:4px}.btn-group>.btn.large:first-child{margin-left:0;-webkit-border-bottom-left-radius:6px;border-bottom-left-radius:6px;-webkit-border-top-left-radius:6px;border-top-left-radius:6px;-moz-border-radius-bottomleft:6px;-moz-border-radius-topleft:6px}.btn-group>.btn.large:last-child,.btn-group>.large.dropdown-toggle{-webkit-border-top-right-radius:6px;border-top-right-radius:6px;-webkit-border-bottom-right-radius:6px;border-bottom-right-radius:6px;-moz-border-radius-topright:6px;-moz-border-radius-bottomright:6px}.btn-group>.btn:hover,.btn-group>.btn:focus,.btn-group>.btn:active,.btn-group>.btn.active{z-index:2}.btn-group .dropdown-toggle:active,.btn-group.open .dropdown-toggle{outline:0}.btn-group>.dropdown-toggle{*padding-top:4px;padding-right:8px;*padding-bottom:4px;padding-left:8px;-webkit-box-shadow:inset 1px 0 0 rgba(255,255,255,0.125),inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 1px 0 0 rgba(255,255,255,0.125),inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 1px 0 0 rgba(255,255,255,0.125),inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05)}.btn-group>.btn-mini.dropdown-toggle{padding-right:5px;padding-left:5px}.btn-group>.btn-small.dropdown-toggle{*padding-top:4px;*padding-bottom:4px}.btn-group>.btn-large.dropdown-toggle{padding-right:12px;padding-left:12px}.btn-group.open .dropdown-toggle{background-image:none;-webkit-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05)}.btn-group.open .btn.dropdown-toggle{background-color:#e6e6e6}.btn-group.open .btn-primary.dropdown-toggle{background-color:#05c}.btn-group.open .btn-warning.dropdown-toggle{background-color:#f89406}.btn-group.open .btn-danger.dropdown-toggle{background-color:#bd362f}.btn-group.open .btn-success.dropdown-toggle{background-color:#51a351}.btn-group.open .btn-info.dropdown-toggle{background-color:#2f96b4}.btn-group.open .btn-inverse.dropdown-toggle{background-color:#222}.btn .caret{margin-top:7px;margin-left:0}.btn:hover .caret,.open.btn-group .caret{opacity:1;filter:alpha(opacity=100)}.btn-mini .caret{margin-top:5px}.btn-small .caret{margin-top:6px}.btn-large .caret{margin-top:6px;border-top-width:5px;border-right-width:5px;border-left-width:5px}.dropup .btn-large .caret{border-top:0;border-bottom:5px solid #000}.btn-primary .caret,.btn-warning .caret,.btn-danger .caret,.btn-info .caret,.btn-success .caret,.btn-inverse .caret{border-top-color:#fff;border-bottom-color:#fff;opacity:.75;filter:alpha(opacity=75)}.btn-group-vertical{display:inline-block}.btn-group-vertical .btn{display:block;float:none;width:100%;margin-left:0;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.btn-group-vertical .btn+.btn{margin-top:-1px}.btn-group-vertical .btn:first-child{-webkit-border-radius:4px 4px 0 0;-moz-border-radius:4px 4px 0 0;border-radius:4px 4px 0 0}.btn-group-vertical .btn:last-child{-webkit-border-radius:0 0 4px 4px;-moz-border-radius:0 0 4px 4px;border-radius:0 0 4px 4px}.btn-group-vertical .btn-large:first-child{-webkit-border-radius:6px 6px 0 0;-moz-border-radius:6px 6px 0 0;border-radius:6px 6px 0 0}.btn-group-vertical .btn-large:last-child{-webkit-border-radius:0 0 6px 6px;-moz-border-radius:0 0 6px 6px;border-radius:0 0 6px 6px}.alert{padding:8px 35px 8px 14px;margin-bottom:18px;color:#c09853;text-shadow:0 1px 0 rgba(255,255,255,0.5);background-color:#fcf8e3;border:1px solid #fbeed5;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.alert .close{position:relative;top:-2px;right:-21px;line-height:18px}.alert-success{color:#468847;background-color:#dff0d8;border-color:#d6e9c6}.alert-danger,.alert-error{color:#b94a48;background-color:#f2dede;border-color:#eed3d7}.alert-info{color:#3a87ad;background-color:#d9edf7;border-color:#bce8f1}.alert-block{padding-top:14px;padding-bottom:14px}.alert-block>p,.alert-block>ul{margin-bottom:0}.alert-block p+p{margin-top:5px}.nav{margin-bottom:18px;margin-left:0;list-style:none}.nav>li>a{display:block}.nav>li>a:hover{text-decoration:none;background-color:#eee}.nav>.pull-right{float:right}.nav .nav-header{display:block;padding:3px 15px;font-size:11px;font-weight:bold;line-height:18px;color:#999;text-shadow:0 1px 0 rgba(255,255,255,0.5);text-transform:uppercase}.nav li+.nav-header{margin-top:9px}.nav-list{padding-right:15px;padding-left:15px;margin-bottom:0}.nav-list>li>a,.nav-list .nav-header{margin-right:-15px;margin-left:-15px;text-shadow:0 1px 0 rgba(255,255,255,0.5)}.nav-list>li>a{padding:3px 15px}.nav-list>.active>a,.nav-list>.active>a:hover{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.2);background-color:#08c}.nav-list [class^="icon-"]{margin-right:2px}.nav-list .divider{*width:100%;height:1px;margin:8px 1px;*margin:-5px 0 5px;overflow:hidden;background-color:#e5e5e5;border-bottom:1px solid #fff}.nav-tabs,.nav-pills{*zoom:1}.nav-tabs:before,.nav-pills:before,.nav-tabs:after,.nav-pills:after{display:table;content:""}.nav-tabs:after,.nav-pills:after{clear:both}.nav-tabs>li,.nav-pills>li{float:left}.nav-tabs>li>a,.nav-pills>li>a{padding-right:12px;padding-left:12px;margin-right:2px;line-height:14px}.nav-tabs{border-bottom:1px solid #ddd}.nav-tabs>li{margin-bottom:-1px}.nav-tabs>li>a{padding-top:8px;padding-bottom:8px;line-height:18px;border:1px solid transparent;-webkit-border-radius:4px 4px 0 0;-moz-border-radius:4px 4px 0 0;border-radius:4px 4px 0 0}.nav-tabs>li>a:hover{border-color:#eee #eee #ddd}.nav-tabs>.active>a,.nav-tabs>.active>a:hover{color:#555;cursor:default;background-color:#fff;border:1px solid #ddd;border-bottom-color:transparent}.nav-pills>li>a{padding-top:8px;padding-bottom:8px;margin-top:2px;margin-bottom:2px;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px}.nav-pills>.active>a,.nav-pills>.active>a:hover{color:#fff;background-color:#08c}.nav-stacked>li{float:none}.nav-stacked>li>a{margin-right:0}.nav-tabs.nav-stacked{border-bottom:0}.nav-tabs.nav-stacked>li>a{border:1px solid #ddd;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.nav-tabs.nav-stacked>li:first-child>a{-webkit-border-radius:4px 4px 0 0;-moz-border-radius:4px 4px 0 0;border-radius:4px 4px 0 0}.nav-tabs.nav-stacked>li:last-child>a{-webkit-border-radius:0 0 4px 4px;-moz-border-radius:0 0 4px 4px;border-radius:0 0 4px 4px}.nav-tabs.nav-stacked>li>a:hover{z-index:2;border-color:#ddd}.nav-pills.nav-stacked>li>a{margin-bottom:3px}.nav-pills.nav-stacked>li:last-child>a{margin-bottom:1px}.nav-tabs .dropdown-menu{-webkit-border-radius:0 0 6px 6px;-moz-border-radius:0 0 6px 6px;border-radius:0 0 6px 6px}.nav-pills .dropdown-menu{-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.nav .dropdown-toggle .caret{margin-top:6px;border-top-color:#08c;border-bottom-color:#08c}.nav .dropdown-toggle:hover .caret{border-top-color:#005580;border-bottom-color:#005580}.nav .active .dropdown-toggle .caret{border-top-color:#fff;border-bottom-color:#fff}.nav>.dropdown.active>a:hover{color:#fff;cursor:pointer}.nav-tabs .open .dropdown-toggle,.nav-pills .open .dropdown-toggle,.nav>li.dropdown.open.active>a:hover{color:#fff;background-color:#999;border-color:#999}.nav li.dropdown.open .caret,.nav li.dropdown.open.active .caret,.nav li.dropdown.open a:hover .caret{border-top-color:#fff;border-bottom-color:#fff;opacity:1;filter:alpha(opacity=100)}.tabs-stacked .open>a:hover{border-color:#999}.tabbable{*zoom:1}.tabbable:before,.tabbable:after{display:table;content:""}.tabbable:after{clear:both}.tab-content{overflow:auto}.tabs-below>.nav-tabs,.tabs-right>.nav-tabs,.tabs-left>.nav-tabs{border-bottom:0}.tab-content>.tab-pane,.pill-content>.pill-pane{display:none}.tab-content>.active,.pill-content>.active{display:block}.tabs-below>.nav-tabs{border-top:1px solid #ddd}.tabs-below>.nav-tabs>li{margin-top:-1px;margin-bottom:0}.tabs-below>.nav-tabs>li>a{-webkit-border-radius:0 0 4px 4px;-moz-border-radius:0 0 4px 4px;border-radius:0 0 4px 4px}.tabs-below>.nav-tabs>li>a:hover{border-top-color:#ddd;border-bottom-color:transparent}.tabs-below>.nav-tabs>.active>a,.tabs-below>.nav-tabs>.active>a:hover{border-color:transparent #ddd #ddd #ddd}.tabs-left>.nav-tabs>li,.tabs-right>.nav-tabs>li{float:none}.tabs-left>.nav-tabs>li>a,.tabs-right>.nav-tabs>li>a{min-width:74px;margin-right:0;margin-bottom:3px}.tabs-left>.nav-tabs{float:left;margin-right:19px;border-right:1px solid #ddd}.tabs-left>.nav-tabs>li>a{margin-right:-1px;-webkit-border-radius:4px 0 0 4px;-moz-border-radius:4px 0 0 4px;border-radius:4px 0 0 4px}.tabs-left>.nav-tabs>li>a:hover{border-color:#eee #ddd #eee #eee}.tabs-left>.nav-tabs .active>a,.tabs-left>.nav-tabs .active>a:hover{border-color:#ddd transparent #ddd #ddd;*border-right-color:#fff}.tabs-right>.nav-tabs{float:right;margin-left:19px;border-left:1px solid #ddd}.tabs-right>.nav-tabs>li>a{margin-left:-1px;-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.tabs-right>.nav-tabs>li>a:hover{border-color:#eee #eee #eee #ddd}.tabs-right>.nav-tabs .active>a,.tabs-right>.nav-tabs .active>a:hover{border-color:#ddd #ddd #ddd transparent;*border-left-color:#fff}.nav>.disabled>a{color:#999}.nav>.disabled>a:hover{text-decoration:none;cursor:default;background-color:transparent}.navbar{*position:relative;*z-index:2;margin-bottom:18px;overflow:visible}.navbar-inner{min-height:40px;padding-right:20px;padding-left:20px;background-color:#2c2c2c;background-image:-moz-linear-gradient(top,#333,#222);background-image:-ms-linear-gradient(top,#333,#222);background-image:-webkit-gradient(linear,0 0,0 100%,from(#333),to(#222));background-image:-webkit-linear-gradient(top,#333,#222);background-image:-o-linear-gradient(top,#333,#222);background-image:linear-gradient(top,#333,#222);background-repeat:repeat-x;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ff333333',endColorstr='#ff222222',GradientType=0);-webkit-box-shadow:0 1px 3px rgba(0,0,0,0.25),inset 0 -1px 0 rgba(0,0,0,0.1);-moz-box-shadow:0 1px 3px rgba(0,0,0,0.25),inset 0 -1px 0 rgba(0,0,0,0.1);box-shadow:0 1px 3px rgba(0,0,0,0.25),inset 0 -1px 0 rgba(0,0,0,0.1)}.navbar .container{width:auto}.nav-collapse.collapse{height:auto}.navbar{color:#999}.navbar .brand:hover{text-decoration:none}.navbar .brand{display:block;float:left;padding:8px 20px 12px;margin-left:-20px;font-size:20px;font-weight:200;line-height:1;color:#999}.navbar .navbar-text{margin-bottom:0;line-height:40px}.navbar .navbar-link{color:#999}.navbar .navbar-link:hover{color:#fff}.navbar .btn,.navbar .btn-group{margin-top:5px}.navbar .btn-group .btn{margin:0}.navbar-form{margin-bottom:0;*zoom:1}.navbar-form:before,.navbar-form:after{display:table;content:""}.navbar-form:after{clear:both}.navbar-form input,.navbar-form select,.navbar-form .radio,.navbar-form .checkbox{margin-top:5px}.navbar-form input,.navbar-form select{display:inline-block;margin-bottom:0}.navbar-form input[type="image"],.navbar-form input[type="checkbox"],.navbar-form input[type="radio"]{margin-top:3px}.navbar-form .input-append,.navbar-form .input-prepend{margin-top:6px;white-space:nowrap}.navbar-form .input-append input,.navbar-form .input-prepend input{margin-top:0}.navbar-search{position:relative;float:left;margin-top:6px;margin-bottom:0}.navbar-search .search-query{padding:4px 9px;font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:13px;font-weight:normal;line-height:1;color:#fff;background-color:#626262;border:1px solid #151515;-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1),0 1px 0 rgba(255,255,255,0.15);-moz-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1),0 1px 0 rgba(255,255,255,0.15);box-shadow:inset 0 1px 2px rgba(0,0,0,0.1),0 1px 0 rgba(255,255,255,0.15);-webkit-transition:none;-moz-transition:none;-ms-transition:none;-o-transition:none;transition:none}.navbar-search .search-query:-moz-placeholder{color:#ccc}.navbar-search .search-query:-ms-input-placeholder{color:#ccc}.navbar-search .search-query::-webkit-input-placeholder{color:#ccc}.navbar-search .search-query:focus,.navbar-search .search-query.focused{padding:5px 10px;color:#333;text-shadow:0 1px 0 #fff;background-color:#fff;border:0;outline:0;-webkit-box-shadow:0 0 3px rgba(0,0,0,0.15);-moz-box-shadow:0 0 3px rgba(0,0,0,0.15);box-shadow:0 0 3px rgba(0,0,0,0.15)}.navbar-fixed-top,.navbar-fixed-bottom{position:fixed;right:0;left:0;z-index:1030;margin-bottom:0}.navbar-fixed-top .navbar-inner,.navbar-fixed-bottom .navbar-inner{padding-right:0;padding-left:0;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.navbar-fixed-top .container,.navbar-fixed-bottom .container{width:940px}.navbar-fixed-top{top:0}.navbar-fixed-bottom{bottom:0}.navbar .nav{position:relative;left:0;display:block;float:left;margin:0 10px 0 0}.navbar .nav.pull-right{float:right}.navbar .nav>li{float:left}.navbar .nav>li>a{float:none;padding:9px 12px 11px;line-height:19px;color:#999;text-decoration:none;text-shadow:0 -1px 0 rgba(0,0,0,0.25)}.navbar .nav .dropdown-toggle .caret{margin-top:8px}.navbar .btn{display:inline-block;padding:4px 10px 4px;margin:5px 5px 6px;line-height:18px}.navbar .btn-group{padding:5px 5px 6px;margin:0}.navbar .nav>li>a:focus,.navbar .nav>li>a:hover{color:#fff;text-decoration:none;background-color:transparent}.navbar .nav .active>a,.navbar .nav .active>a:hover,.navbar .nav .active>a:focus{color:#fff;text-decoration:none;background-color:#222}.navbar .divider-vertical{width:1px;height:40px;margin:0 9px;overflow:hidden;background-color:#222;border-right:1px solid #333}.navbar .nav.pull-right{margin-right:0;margin-left:10px}.navbar .btn-navbar{display:none;float:right;padding:7px 10px;margin-right:5px;margin-left:5px;background-color:#1f1f1f;*background-color:#151515;background-image:-ms-linear-gradient(top,#262626,#151515);background-image:-webkit-gradient(linear,0 0,0 100%,from(#262626),to(#151515));background-image:-webkit-linear-gradient(top,#262626,#151515);background-image:-o-linear-gradient(top,#262626,#151515);background-image:linear-gradient(top,#262626,#151515);background-image:-moz-linear-gradient(top,#262626,#151515);background-repeat:repeat-x;border-color:#151515 #151515 #000;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ff262626',endColorstr='#ff151515',GradientType=0);filter:progid:dximagetransform.microsoft.gradient(enabled=false);-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.075);-moz-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.075);box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.075)}.navbar .btn-navbar:hover,.navbar .btn-navbar:active,.navbar .btn-navbar.active,.navbar .btn-navbar.disabled,.navbar .btn-navbar[disabled]{background-color:#151515;*background-color:#080808}.navbar .btn-navbar:active,.navbar .btn-navbar.active{background-color:#000 \9}.navbar .btn-navbar .icon-bar{display:block;width:18px;height:2px;background-color:#f5f5f5;-webkit-border-radius:1px;-moz-border-radius:1px;border-radius:1px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,0.25);-moz-box-shadow:0 1px 0 rgba(0,0,0,0.25);box-shadow:0 1px 0 rgba(0,0,0,0.25)}.btn-navbar .icon-bar+.icon-bar{margin-top:3px}.navbar .dropdown-menu:before{position:absolute;top:-7px;left:9px;display:inline-block;border-right:7px solid transparent;border-bottom:7px solid #ccc;border-left:7px solid transparent;border-bottom-color:rgba(0,0,0,0.2);content:''}.navbar .dropdown-menu:after{position:absolute;top:-6px;left:10px;display:inline-block;border-right:6px solid transparent;border-bottom:6px solid #fff;border-left:6px solid transparent;content:''}.navbar-fixed-bottom .dropdown-menu:before{top:auto;bottom:-7px;border-top:7px solid #ccc;border-bottom:0;border-top-color:rgba(0,0,0,0.2)}.navbar-fixed-bottom .dropdown-menu:after{top:auto;bottom:-6px;border-top:6px solid #fff;border-bottom:0}.navbar .nav li.dropdown .dropdown-toggle .caret,.navbar .nav li.dropdown.open .caret{border-top-color:#fff;border-bottom-color:#fff}.navbar .nav li.dropdown.active .caret{opacity:1;filter:alpha(opacity=100)}.navbar .nav li.dropdown.open>.dropdown-toggle,.navbar .nav li.dropdown.active>.dropdown-toggle,.navbar .nav li.dropdown.open.active>.dropdown-toggle{background-color:transparent}.navbar .nav li.dropdown.active>.dropdown-toggle:focus,.navbar .nav li.dropdown.active>.dropdown-toggle:hover{color:#fff}.navbar .pull-right .dropdown-menu,.navbar .dropdown-menu.pull-right{right:0;left:auto}.navbar .pull-right .dropdown-menu:before,.navbar .dropdown-menu.pull-right:before{right:12px;left:auto}.navbar .pull-right .dropdown-menu:after,.navbar .dropdown-menu.pull-right:after{right:13px;left:auto}.navbar-subnav{height:36px}.navbar-subnav .navbar-inner{min-height:36px;padding:0;background-color:#f5f5f5;background-image:-moz-linear-gradient(top,#f9f9f9,#eee);background-image:-ms-linear-gradient(top,#f9f9f9,#eee);background-image:-webkit-gradient(linear,0 0,0 100%,from(#f9f9f9),to(#eee));background-image:-webkit-linear-gradient(top,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#f9f9f9,#eee);background-image:linear-gradient(top,#f9f9f9,#eee);background-repeat:repeat-x;border:1px solid #e5e5e5;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#fff9f9f9',endColorstr='#ffeeeeee',GradientType=0);-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none}.navbar-subnav .nav>li>a{color:#08c;text-shadow:0 1px 0 rgba(255,255,255,0.5)}.navbar-subnav .nav>li>a:hover{color:#005580}.navbar-subnav .nav li.dropdown .dropdown-toggle .caret,.navbar-subnav .nav li.dropdown.open .caret{border-top-color:#08c;border-bottom-color:#08c}.navbar-subnav .nav .open>a{color:#005580}.breadcrumb{padding:7px 14px;margin:0 0 18px;list-style:none;background-color:#fbfbfb;background-image:-moz-linear-gradient(top,#fff,#f5f5f5);background-image:-ms-linear-gradient(top,#fff,#f5f5f5);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fff),to(#f5f5f5));background-image:-webkit-linear-gradient(top,#fff,#f5f5f5);background-image:-o-linear-gradient(top,#fff,#f5f5f5);background-image:linear-gradient(top,#fff,#f5f5f5);background-repeat:repeat-x;border:1px solid #ddd;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ffffffff',endColorstr='#fff5f5f5',GradientType=0);-webkit-box-shadow:inset 0 1px 0 #fff;-moz-box-shadow:inset 0 1px 0 #fff;box-shadow:inset 0 1px 0 #fff}.breadcrumb li{display:inline-block;*display:inline;text-shadow:0 1px 0 #fff;*zoom:1}.breadcrumb .divider{padding:0 5px;color:#999}.breadcrumb .active a{color:#333}.pagination{height:36px;margin:18px 0}.pagination ul{display:inline-block;*display:inline;margin-bottom:0;margin-left:0;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px;*zoom:1;-webkit-box-shadow:0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:0 1px 2px rgba(0,0,0,0.05);box-shadow:0 1px 2px rgba(0,0,0,0.05)}.pagination li{display:inline}.pagination a,.pagination span{float:left;padding:0 14px;line-height:34px;text-decoration:none;border:1px solid #ddd;border-left-width:0}.pagination a:hover,.pagination .active a,.pagination .active span{background-color:#f5f5f5}.pagination .active a,.pagination .active span{color:#999;cursor:default}.pagination .disabled span,.pagination .disabled a,.pagination .disabled a:hover{color:#999;cursor:default;background-color:transparent}.pagination li:first-child a,.pagination li:first-child span{border-left-width:1px;-webkit-border-radius:3px 0 0 3px;-moz-border-radius:3px 0 0 3px;border-radius:3px 0 0 3px}.pagination li:last-child a,.pagination li:last-child span{-webkit-border-radius:0 3px 3px 0;-moz-border-radius:0 3px 3px 0;border-radius:0 3px 3px 0}.pagination-centered{text-align:center}.pagination-right{text-align:right}.pager{margin-bottom:18px;margin-left:0;text-align:center;list-style:none;*zoom:1}.pager:before,.pager:after{display:table;content:""}.pager:after{clear:both}.pager li{display:inline}.pager a{display:inline-block;padding:5px 14px;background-color:#fff;border:1px solid #ddd;-webkit-border-radius:15px;-moz-border-radius:15px;border-radius:15px}.pager a:hover{text-decoration:none;background-color:#f5f5f5}.pager .next a{float:right}.pager .previous a{float:left}.pager .disabled a,.pager .disabled a:hover{color:#999;cursor:default;background-color:#fff}.modal-open .dropdown-menu{z-index:2050}.modal-open .dropdown.open{*z-index:2050}.modal-open .popover{z-index:2060}.modal-open .tooltip{z-index:2070}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{opacity:0}.modal-backdrop,.modal-backdrop.fade.in{opacity:.8;filter:alpha(opacity=80)}.modal{position:fixed;top:50%;left:50%;z-index:1050;width:560px;margin:-250px 0 0 -280px;overflow:auto;background-color:#fff;border:1px solid #999;border:1px solid rgba(0,0,0,0.3);*border:1px solid #999;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;-webkit-box-shadow:0 3px 7px rgba(0,0,0,0.3);-moz-box-shadow:0 3px 7px rgba(0,0,0,0.3);box-shadow:0 3px 7px rgba(0,0,0,0.3);-webkit-background-clip:padding-box;-moz-background-clip:padding-box;background-clip:padding-box}.modal.fade{top:-25%;-webkit-transition:opacity .3s linear,top .3s ease-out;-moz-transition:opacity .3s linear,top .3s ease-out;-ms-transition:opacity .3s linear,top .3s ease-out;-o-transition:opacity .3s linear,top .3s ease-out;transition:opacity .3s linear,top .3s ease-out}.modal.fade.in{top:50%}.modal-header{padding:9px 15px;border-bottom:1px solid #eee}.modal-header .close{margin-top:2px}.modal-body{max-height:400px;padding:15px;overflow-y:auto}.modal-form{margin-bottom:0}.modal-footer{padding:14px 15px 15px;margin-bottom:0;text-align:right;background-color:#f5f5f5;border-top:1px solid #ddd;-webkit-border-radius:0 0 6px 6px;-moz-border-radius:0 0 6px 6px;border-radius:0 0 6px 6px;*zoom:1;-webkit-box-shadow:inset 0 1px 0 #fff;-moz-box-shadow:inset 0 1px 0 #fff;box-shadow:inset 0 1px 0 #fff}.modal-footer:before,.modal-footer:after{display:table;content:""}.modal-footer:after{clear:both}.modal-footer .btn+.btn{margin-bottom:0;margin-left:5px}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.tooltip{position:absolute;z-index:1020;display:block;padding:5px;font-size:11px;opacity:0;filter:alpha(opacity=0);visibility:visible}.tooltip.in{opacity:.8;filter:alpha(opacity=80)}.tooltip.top{margin-top:-2px}.tooltip.right{margin-left:2px}.tooltip.bottom{margin-top:2px}.tooltip.left{margin-left:-2px}.tooltip.top .tooltip-arrow{bottom:0;left:50%;margin-left:-5px;border-top:5px solid #000;border-right:5px solid transparent;border-left:5px solid transparent}.tooltip.left .tooltip-arrow{top:50%;right:0;margin-top:-5px;border-top:5px solid transparent;border-bottom:5px solid transparent;border-left:5px solid #000}.tooltip.bottom .tooltip-arrow{top:0;left:50%;margin-left:-5px;border-right:5px solid transparent;border-bottom:5px solid #000;border-left:5px solid transparent}.tooltip.right .tooltip-arrow{top:50%;left:0;margin-top:-5px;border-top:5px solid transparent;border-right:5px solid #000;border-bottom:5px solid transparent}.tooltip-inner{max-width:200px;padding:3px 8px;color:#fff;text-align:center;text-decoration:none;background-color:#000;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.tooltip-arrow{position:absolute;width:0;height:0}.popover{position:absolute;top:0;left:0;z-index:1010;display:none;padding:5px}.popover.top{margin-top:-5px}.popover.right{margin-left:5px}.popover.bottom{margin-top:5px}.popover.left{margin-left:-5px}.popover.top .arrow{bottom:0;left:50%;margin-left:-5px;border-top:5px solid #000;border-right:5px solid transparent;border-left:5px solid transparent}.popover.right .arrow{top:50%;left:0;margin-top:-5px;border-top:5px solid transparent;border-right:5px solid #000;border-bottom:5px solid transparent}.popover.bottom .arrow{top:0;left:50%;margin-left:-5px;border-right:5px solid transparent;border-bottom:5px solid #000;border-left:5px solid transparent}.popover.left .arrow{top:50%;right:0;margin-top:-5px;border-top:5px solid transparent;border-bottom:5px solid transparent;border-left:5px solid #000}.popover .arrow{position:absolute;width:0;height:0}.popover-inner{width:280px;padding:3px;overflow:hidden;background:#000;background:rgba(0,0,0,0.8);-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;-webkit-box-shadow:0 3px 7px rgba(0,0,0,0.3);-moz-box-shadow:0 3px 7px rgba(0,0,0,0.3);box-shadow:0 3px 7px rgba(0,0,0,0.3)}.popover-title{padding:9px 15px;line-height:1;background-color:#f5f5f5;border-bottom:1px solid #eee;-webkit-border-radius:3px 3px 0 0;-moz-border-radius:3px 3px 0 0;border-radius:3px 3px 0 0}.popover-content{padding:14px;background-color:#fff;-webkit-border-radius:0 0 3px 3px;-moz-border-radius:0 0 3px 3px;border-radius:0 0 3px 3px;-webkit-background-clip:padding-box;-moz-background-clip:padding-box;background-clip:padding-box}.popover-content p,.popover-content ul,.popover-content ol{margin-bottom:0}.thumbnails{margin-left:-20px;list-style:none;*zoom:1}.thumbnails:before,.thumbnails:after{display:table;content:""}.thumbnails:after{clear:both}.row-fluid .thumbnails{margin-left:0}.thumbnails>li{float:left;margin-bottom:18px;margin-left:20px}.thumbnail{display:block;padding:4px;line-height:1;border:1px solid #ddd;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;-webkit-box-shadow:0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:0 1px 1px rgba(0,0,0,0.075);box-shadow:0 1px 1px rgba(0,0,0,0.075)}a.thumbnail:hover{border-color:#08c;-webkit-box-shadow:0 1px 4px rgba(0,105,214,0.25);-moz-box-shadow:0 1px 4px rgba(0,105,214,0.25);box-shadow:0 1px 4px rgba(0,105,214,0.25)}.thumbnail>img{display:block;max-width:100%;margin-right:auto;margin-left:auto}.thumbnail .caption{padding:9px}.label,.badge{font-size:10.998px;font-weight:bold;line-height:14px;color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);white-space:nowrap;vertical-align:baseline;background-color:#999}.label{padding:1px 4px 2px;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.badge{padding:1px 9px 2px;-webkit-border-radius:9px;-moz-border-radius:9px;border-radius:9px}a.label:hover,a.badge:hover{color:#fff;text-decoration:none;cursor:pointer}.label-important,.badge-important{background-color:#b94a48}.label-important[href],.badge-important[href]{background-color:#953b39}.label-warning,.badge-warning{background-color:#f89406}.label-warning[href],.badge-warning[href]{background-color:#c67605}.label-success,.badge-success{background-color:#468847}.label-success[href],.badge-success[href]{background-color:#356635}.label-info,.badge-info{background-color:#3a87ad}.label-info[href],.badge-info[href]{background-color:#2d6987}.label-inverse,.badge-inverse{background-color:#333}.label-inverse[href],.badge-inverse[href]{background-color:#1a1a1a}@-webkit-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-moz-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-ms-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-o-keyframes progress-bar-stripes{from{background-position:0 0}to{background-position:40px 0}}@keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}.progress{height:18px;margin-bottom:18px;overflow:hidden;background-color:#f7f7f7;background-image:-moz-linear-gradient(top,#f5f5f5,#f9f9f9);background-image:-ms-linear-gradient(top,#f5f5f5,#f9f9f9);background-image:-webkit-gradient(linear,0 0,0 100%,from(#f5f5f5),to(#f9f9f9));background-image:-webkit-linear-gradient(top,#f5f5f5,#f9f9f9);background-image:-o-linear-gradient(top,#f5f5f5,#f9f9f9);background-image:linear-gradient(top,#f5f5f5,#f9f9f9);background-repeat:repeat-x;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#fff5f5f5',endColorstr='#fff9f9f9',GradientType=0);-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);-moz-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);box-shadow:inset 0 1px 2px rgba(0,0,0,0.1)}.progress .bar{width:0;height:18px;font-size:12px;color:#fff;text-align:center;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#0e90d2;background-image:-moz-linear-gradient(top,#149bdf,#0480be);background-image:-webkit-gradient(linear,0 0,0 100%,from(#149bdf),to(#0480be));background-image:-webkit-linear-gradient(top,#149bdf,#0480be);background-image:-o-linear-gradient(top,#149bdf,#0480be);background-image:linear-gradient(top,#149bdf,#0480be);background-image:-ms-linear-gradient(top,#149bdf,#0480be);background-repeat:repeat-x;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ff149bdf',endColorstr='#ff0480be',GradientType=0);-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);-moz-box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-ms-box-sizing:border-box;box-sizing:border-box;-webkit-transition:width .6s ease;-moz-transition:width .6s ease;-ms-transition:width .6s ease;-o-transition:width .6s ease;transition:width .6s ease}.progress-striped .bar{background-color:#149bdf;background-image:-o-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-webkit-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-ms-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);-webkit-background-size:40px 40px;-moz-background-size:40px 40px;-o-background-size:40px 40px;background-size:40px 40px}.progress.active .bar{-webkit-animation:progress-bar-stripes 2s linear infinite;-moz-animation:progress-bar-stripes 2s linear infinite;-ms-animation:progress-bar-stripes 2s linear infinite;-o-animation:progress-bar-stripes 2s linear infinite;animation:progress-bar-stripes 2s linear infinite}.progress-danger .bar{background-color:#dd514c;background-image:-moz-linear-gradient(top,#ee5f5b,#c43c35);background-image:-ms-linear-gradient(top,#ee5f5b,#c43c35);background-image:-webkit-gradient(linear,0 0,0 100%,from(#ee5f5b),to(#c43c35));background-image:-webkit-linear-gradient(top,#ee5f5b,#c43c35);background-image:-o-linear-gradient(top,#ee5f5b,#c43c35);background-image:linear-gradient(top,#ee5f5b,#c43c35);background-repeat:repeat-x;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ffee5f5b',endColorstr='#ffc43c35',GradientType=0)}.progress-danger.progress-striped .bar{background-color:#ee5f5b;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-ms-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.progress-success .bar{background-color:#5eb95e;background-image:-moz-linear-gradient(top,#62c462,#57a957);background-image:-ms-linear-gradient(top,#62c462,#57a957);background-image:-webkit-gradient(linear,0 0,0 100%,from(#62c462),to(#57a957));background-image:-webkit-linear-gradient(top,#62c462,#57a957);background-image:-o-linear-gradient(top,#62c462,#57a957);background-image:linear-gradient(top,#62c462,#57a957);background-repeat:repeat-x;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ff62c462',endColorstr='#ff57a957',GradientType=0)}.progress-success.progress-striped .bar{background-color:#62c462;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-ms-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.progress-info .bar{background-color:#4bb1cf;background-image:-moz-linear-gradient(top,#5bc0de,#339bb9);background-image:-ms-linear-gradient(top,#5bc0de,#339bb9);background-image:-webkit-gradient(linear,0 0,0 100%,from(#5bc0de),to(#339bb9));background-image:-webkit-linear-gradient(top,#5bc0de,#339bb9);background-image:-o-linear-gradient(top,#5bc0de,#339bb9);background-image:linear-gradient(top,#5bc0de,#339bb9);background-repeat:repeat-x;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#ff5bc0de',endColorstr='#ff339bb9',GradientType=0)}.progress-info.progress-striped .bar{background-color:#5bc0de;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-ms-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.progress-warning .bar{background-color:#faa732;background-image:-moz-linear-gradient(top,#fbb450,#f89406);background-image:-ms-linear-gradient(top,#fbb450,#f89406);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fbb450),to(#f89406));background-image:-webkit-linear-gradient(top,#fbb450,#f89406);background-image:-o-linear-gradient(top,#fbb450,#f89406);background-image:linear-gradient(top,#fbb450,#f89406);background-repeat:repeat-x;filter:progid:dximagetransform.microsoft.gradient(startColorstr='#fffbb450',endColorstr='#fff89406',GradientType=0)}.progress-warning.progress-striped .bar{background-color:#fbb450;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-ms-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(-45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.accordion{margin-bottom:18px}.accordion-group{margin-bottom:2px;border:1px solid #e5e5e5;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.accordion-heading{border-bottom:0}.accordion-heading .accordion-toggle{display:block;padding:8px 15px}.accordion-toggle{cursor:pointer}.accordion-inner{padding:9px 15px;border-top:1px solid #e5e5e5}.carousel{position:relative;margin-bottom:18px;line-height:1}.carousel-inner{position:relative;width:100%;overflow:hidden}.carousel .item{position:relative;display:none;-webkit-transition:.6s ease-in-out left;-moz-transition:.6s ease-in-out left;-ms-transition:.6s ease-in-out left;-o-transition:.6s ease-in-out left;transition:.6s ease-in-out left}.carousel .item>img{display:block;line-height:1}.carousel .active,.carousel .next,.carousel .prev{display:block}.carousel .active{left:0}.carousel .next,.carousel .prev{position:absolute;top:0;width:100%}.carousel .next{left:100%}.carousel .prev{left:-100%}.carousel .next.left,.carousel .prev.right{left:0}.carousel .active.left{left:-100%}.carousel .active.right{left:100%}.carousel-control{position:absolute;top:40%;left:15px;width:40px;height:40px;margin-top:-20px;font-size:60px;font-weight:100;line-height:30px;color:#fff;text-align:center;background:#222;border:3px solid #fff;-webkit-border-radius:23px;-moz-border-radius:23px;border-radius:23px;opacity:.5;filter:alpha(opacity=50)}.carousel-control.right{right:15px;left:auto}.carousel-control:hover{color:#fff;text-decoration:none;opacity:.9;filter:alpha(opacity=90)}.carousel-caption{position:absolute;right:0;bottom:0;left:0;padding:10px 15px 5px;background:#333;background:rgba(0,0,0,0.75)}.carousel-caption h4,.carousel-caption p{color:#fff}.hero-unit{padding:60px;margin-bottom:30px;background-color:#eee;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.hero-unit h1{margin-bottom:0;font-size:60px;line-height:1;letter-spacing:-1px;color:inherit}.hero-unit p{font-size:18px;font-weight:200;line-height:27px;color:inherit}.pull-right{float:right}.pull-left{float:left}.hide{display:none}.show{display:block}.invisible{visibility:hidden}
/Fim/
diff --git a/website/static/debut_dark.png b/website/static/debut_dark.png
new file mode 100644
index 0000000..17a4d6b
--- /dev/null
+++ b/website/static/debut_dark.png
Binary files differ
/Fim/
diff --git a/website/static/logo.png b/website/static/logo.png
new file mode 100644
index 0000000..e2bd44d
--- /dev/null
+++ b/website/static/logo.png
Binary files differ
/Fim/
diff --git a/website/static/logo.psd b/website/static/logo.psd
new file mode 100644
index 0000000..2228481
--- /dev/null
+++ b/website/static/logo.psd
Binary files differ
/Fim/
diff --git a/website/static/prettify.css b/website/static/prettify.css
new file mode 100644
index 0000000..093f2f9
--- /dev/null
+++ b/website/static/prettify.css
@@ -0,0 +1,47 @@
+/*.com { color: #93a1a1; }
+.lit { color: #195f91; }
+.pun, .opn, .clo { color: #93a1a1; }
+.fun { color: #dc322f; }
+.str, .atv { color: #edd400; }
+.kwd, .linenums, .tag { color: #1e347b; }
+.typ, .atn, .dec, .var { color: teal; }
+.pln { color: #48484c; }*/
+
+pre .str, code .str { color: #c6c6c6; } /* string  - white */
+pre .kwd, code .kwd { color: #E28964; } /* keyword - dark pink */
+pre .com, code .com { color: #AEAEAE; font-style: italic; } /* comment - gray */
+pre .typ, code .typ { color: #89bdff; } /* type - light blue */
+pre .lit, code .lit { color: #3387CC; } /* literal - blue */
+pre .pun, code .pun { color: #c6c6c6; } /* punctuation - white */
+pre .pln, code .pln { color: #c6c6c6; } /* plaintext - white */
+pre .tag, code .tag { color: #89bdff; } /* html/xml tag    - light blue */
+pre .atn, code .atn { color: #bdb76b; } /* html/xml attribute name  - khaki */
+pre .atv, code .atv { color: #65B042; } /* html/xml attribute value - green */
+pre .dec, code .dec { color: #3387CC; } /* decimal - blue */
+
+
+.prettyprint {
+  padding: 8px;
+  background-color: #212121;
+  background-color: rgba(31, 31, 31, 0.25);
+  border: 0;
+  text-shadow: none;
+  font-size: 12px;
+}
+.prettyprint.linenums {
+  -webkit-box-shadow: inset 40px 0 0 #fbfbfc, inset 41px 0 0 #ececf0;
+     -moz-box-shadow: inset 40px 0 0 #fbfbfc, inset 41px 0 0 #ececf0;
+          box-shadow: inset 40px 0 0 #fbfbfc, inset 41px 0 0 #ececf0;
+}
+
+/* Specify class=linenums on a pre to get line numbering */
+ol.linenums {
+  margin: 0 0 0 33px; /* IE indents via margin-left */
+}
+ol.linenums li {
+  padding-left: 12px;
+  color: #bebec5;
+  line-height: 18px;
+  text-shadow: 0 1px 0 #fff;
+}
+
/Fim/
diff --git a/website/static/prettify.js b/website/static/prettify.js
new file mode 100644
index 0000000..eef5ad7
--- /dev/null
+++ b/website/static/prettify.js
@@ -0,0 +1,28 @@
+var q=null;window.PR_SHOULD_USE_CONTINUATION=!0;
+(function(){function L(a){function m(a){var f=a.charCodeAt(0);if(f!==92)return f;var b=a.charAt(1);return(f=r[b])?f:"0"<=b&&b<="7"?parseInt(a.substring(1),8):b==="u"||b==="x"?parseInt(a.substring(2),16):a.charCodeAt(1)}function e(a){if(a<32)return(a<16?"\\x0":"\\x")+a.toString(16);a=String.fromCharCode(a);if(a==="\\"||a==="-"||a==="["||a==="]")a="\\"+a;return a}function h(a){for(var f=a.substring(1,a.length-1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g),a=
+[],b=[],o=f[0]==="^",c=o?1:0,i=f.length;c<i;++c){var j=f[c];if(/\\[bdsw]/i.test(j))a.push(j);else{var j=m(j),d;c+2<i&&"-"===f[c+1]?(d=m(f[c+2]),c+=2):d=j;b.push([j,d]);d<65||j>122||(d<65||j>90||b.push([Math.max(65,j)|32,Math.min(d,90)|32]),d<97||j>122||b.push([Math.max(97,j)&-33,Math.min(d,122)&-33]))}}b.sort(function(a,f){return a[0]-f[0]||f[1]-a[1]});f=[];j=[NaN,NaN];for(c=0;c<b.length;++c)i=b[c],i[0]<=j[1]+1?j[1]=Math.max(j[1],i[1]):f.push(j=i);b=["["];o&&b.push("^");b.push.apply(b,a);for(c=0;c<
+f.length;++c)i=f[c],b.push(e(i[0])),i[1]>i[0]&&(i[1]+1>i[0]&&b.push("-"),b.push(e(i[1])));b.push("]");return b.join("")}function y(a){for(var f=a.source.match(/\[(?:[^\\\]]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g),b=f.length,d=[],c=0,i=0;c<b;++c){var j=f[c];j==="("?++i:"\\"===j.charAt(0)&&(j=+j.substring(1))&&j<=i&&(d[j]=-1)}for(c=1;c<d.length;++c)-1===d[c]&&(d[c]=++t);for(i=c=0;c<b;++c)j=f[c],j==="("?(++i,d[i]===void 0&&(f[c]="(?:")):"\\"===j.charAt(0)&&
+(j=+j.substring(1))&&j<=i&&(f[c]="\\"+d[i]);for(i=c=0;c<b;++c)"^"===f[c]&&"^"!==f[c+1]&&(f[c]="");if(a.ignoreCase&&s)for(c=0;c<b;++c)j=f[c],a=j.charAt(0),j.length>=2&&a==="["?f[c]=h(j):a!=="\\"&&(f[c]=j.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return f.join("")}for(var t=0,s=!1,l=!1,p=0,d=a.length;p<d;++p){var g=a[p];if(g.ignoreCase)l=!0;else if(/[a-z]/i.test(g.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi,""))){s=!0;l=!1;break}}for(var r=
+{b:8,t:9,n:10,v:11,f:12,r:13},n=[],p=0,d=a.length;p<d;++p){g=a[p];if(g.global||g.multiline)throw Error(""+g);n.push("(?:"+y(g)+")")}return RegExp(n.join("|"),l?"gi":"g")}function M(a){function m(a){switch(a.nodeType){case 1:if(e.test(a.className))break;for(var g=a.firstChild;g;g=g.nextSibling)m(g);g=a.nodeName;if("BR"===g||"LI"===g)h[s]="\n",t[s<<1]=y++,t[s++<<1|1]=a;break;case 3:case 4:g=a.nodeValue,g.length&&(g=p?g.replace(/\r\n?/g,"\n"):g.replace(/[\t\n\r ]+/g," "),h[s]=g,t[s<<1]=y,y+=g.length,
+t[s++<<1|1]=a)}}var e=/(?:^|\s)nocode(?:\s|$)/,h=[],y=0,t=[],s=0,l;a.currentStyle?l=a.currentStyle.whiteSpace:window.getComputedStyle&&(l=document.defaultView.getComputedStyle(a,q).getPropertyValue("white-space"));var p=l&&"pre"===l.substring(0,3);m(a);return{a:h.join("").replace(/\n$/,""),c:t}}function B(a,m,e,h){m&&(a={a:m,d:a},e(a),h.push.apply(h,a.e))}function x(a,m){function e(a){for(var l=a.d,p=[l,"pln"],d=0,g=a.a.match(y)||[],r={},n=0,z=g.length;n<z;++n){var f=g[n],b=r[f],o=void 0,c;if(typeof b===
+"string")c=!1;else{var i=h[f.charAt(0)];if(i)o=f.match(i[1]),b=i[0];else{for(c=0;c<t;++c)if(i=m[c],o=f.match(i[1])){b=i[0];break}o||(b="pln")}if((c=b.length>=5&&"lang-"===b.substring(0,5))&&!(o&&typeof o[1]==="string"))c=!1,b="src";c||(r[f]=b)}i=d;d+=f.length;if(c){c=o[1];var j=f.indexOf(c),k=j+c.length;o[2]&&(k=f.length-o[2].length,j=k-c.length);b=b.substring(5);B(l+i,f.substring(0,j),e,p);B(l+i+j,c,C(b,c),p);B(l+i+k,f.substring(k),e,p)}else p.push(l+i,b)}a.e=p}var h={},y;(function(){for(var e=a.concat(m),
+l=[],p={},d=0,g=e.length;d<g;++d){var r=e[d],n=r[3];if(n)for(var k=n.length;--k>=0;)h[n.charAt(k)]=r;r=r[1];n=""+r;p.hasOwnProperty(n)||(l.push(r),p[n]=q)}l.push(/[\S\s]/);y=L(l)})();var t=m.length;return e}function u(a){var m=[],e=[];a.tripleQuotedStrings?m.push(["str",/^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/,q,"'\""]):a.multiLineStrings?m.push(["str",/^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,
+q,"'\"`"]):m.push(["str",/^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/,q,"\"'"]);a.verbatimStrings&&e.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,q]);var h=a.hashComments;h&&(a.cStyleComments?(h>1?m.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,q,"#"]):m.push(["com",/^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\b|[^\n\r]*)/,q,"#"]),e.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h|[a-z]\w*)>/,q])):m.push(["com",/^#[^\n\r]*/,
+q,"#"]));a.cStyleComments&&(e.push(["com",/^\/\/[^\n\r]*/,q]),e.push(["com",/^\/\*[\S\s]*?(?:\*\/|$)/,q]));a.regexLiterals&&e.push(["lang-regex",/^(?:^^\.?|[!+-]|!=|!==|#|%|%=|&|&&|&&=|&=|\(|\*|\*=|\+=|,|-=|->|\/|\/=|:|::|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|[?@[^]|\^=|\^\^|\^\^=|{|\||\|=|\|\||\|\|=|~|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\s*(\/(?=[^*/])(?:[^/[\\]|\\[\S\s]|\[(?:[^\\\]]|\\[\S\s])*(?:]|$))+\/)/]);(h=a.types)&&e.push(["typ",h]);a=(""+a.keywords).replace(/^ | $/g,
+"");a.length&&e.push(["kwd",RegExp("^(?:"+a.replace(/[\s,]+/g,"|")+")\\b"),q]);m.push(["pln",/^\s+/,q," \r\n\t\xa0"]);e.push(["lit",/^@[$_a-z][\w$@]*/i,q],["typ",/^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/,q],["pln",/^[$_a-z][\w$@]*/i,q],["lit",/^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i,q,"0123456789"],["pln",/^\\[\S\s]?/,q],["pun",/^.[^\s\w"-$'./@\\`]*/,q]);return x(m,e)}function D(a,m){function e(a){switch(a.nodeType){case 1:if(k.test(a.className))break;if("BR"===a.nodeName)h(a),
+a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)e(a);break;case 3:case 4:if(p){var b=a.nodeValue,d=b.match(t);if(d){var c=b.substring(0,d.index);a.nodeValue=c;(b=b.substring(d.index+d[0].length))&&a.parentNode.insertBefore(s.createTextNode(b),a.nextSibling);h(a);c||a.parentNode.removeChild(a)}}}}function h(a){function b(a,d){var e=d?a.cloneNode(!1):a,f=a.parentNode;if(f){var f=b(f,1),g=a.nextSibling;f.appendChild(e);for(var h=g;h;h=g)g=h.nextSibling,f.appendChild(h)}return e}
+for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),e;(e=a.parentNode)&&e.nodeType===1;)a=e;d.push(a)}var k=/(?:^|\s)nocode(?:\s|$)/,t=/\r\n?|\n/,s=a.ownerDocument,l;a.currentStyle?l=a.currentStyle.whiteSpace:window.getComputedStyle&&(l=s.defaultView.getComputedStyle(a,q).getPropertyValue("white-space"));var p=l&&"pre"===l.substring(0,3);for(l=s.createElement("LI");a.firstChild;)l.appendChild(a.firstChild);for(var d=[l],g=0;g<d.length;++g)e(d[g]);m===(m|0)&&d[0].setAttribute("value",
+m);var r=s.createElement("OL");r.className="linenums";for(var n=Math.max(0,m-1|0)||0,g=0,z=d.length;g<z;++g)l=d[g],l.className="L"+(g+n)%10,l.firstChild||l.appendChild(s.createTextNode("\xa0")),r.appendChild(l);a.appendChild(r)}function k(a,m){for(var e=m.length;--e>=0;){var h=m[e];A.hasOwnProperty(h)?window.console&&console.warn("cannot override language handler %s",h):A[h]=a}}function C(a,m){if(!a||!A.hasOwnProperty(a))a=/^\s*</.test(m)?"default-markup":"default-code";return A[a]}function E(a){var m=
+a.g;try{var e=M(a.h),h=e.a;a.a=h;a.c=e.c;a.d=0;C(m,h)(a);var k=/\bMSIE\b/.test(navigator.userAgent),m=/\n/g,t=a.a,s=t.length,e=0,l=a.c,p=l.length,h=0,d=a.e,g=d.length,a=0;d[g]=s;var r,n;for(n=r=0;n<g;)d[n]!==d[n+2]?(d[r++]=d[n++],d[r++]=d[n++]):n+=2;g=r;for(n=r=0;n<g;){for(var z=d[n],f=d[n+1],b=n+2;b+2<=g&&d[b+1]===f;)b+=2;d[r++]=z;d[r++]=f;n=b}for(d.length=r;h<p;){var o=l[h+2]||s,c=d[a+2]||s,b=Math.min(o,c),i=l[h+1],j;if(i.nodeType!==1&&(j=t.substring(e,b))){k&&(j=j.replace(m,"\r"));i.nodeValue=
+j;var u=i.ownerDocument,v=u.createElement("SPAN");v.className=d[a+1];var x=i.parentNode;x.replaceChild(v,i);v.appendChild(i);e<o&&(l[h+1]=i=u.createTextNode(t.substring(b,o)),x.insertBefore(i,v.nextSibling))}e=b;e>=o&&(h+=2);e>=c&&(a+=2)}}catch(w){"console"in window&&console.log(w&&w.stack?w.stack:w)}}var v=["break,continue,do,else,for,if,return,while"],w=[[v,"auto,case,char,const,default,double,enum,extern,float,goto,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],
+"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],F=[w,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,dynamic_cast,explicit,export,friend,inline,late_check,mutable,namespace,nullptr,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],G=[w,"abstract,boolean,byte,extends,final,finally,implements,import,instanceof,null,native,package,strictfp,super,synchronized,throws,transient"],
+H=[G,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,interface,internal,into,is,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var"],w=[w,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],I=[v,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],
+J=[v,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],v=[v,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],K=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)/,N=/\S/,O=u({keywords:[F,H,w,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END"+
+I,J,v],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),A={};k(O,["default-code"]);k(x([],[["pln",/^[^<?]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\S\s]*?(?:--\>|$)/],["lang-",/^<\?([\S\s]+?)(?:\?>|$)/],["lang-",/^<%([\S\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",/^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i]]),
+["default-markup","htm","html","mxml","xhtml","xml","xsl"]);k(x([["pln",/^\s+/,q," \t\r\n"],["atv",/^(?:"[^"]*"?|'[^']*'?)/,q,"\"'"]],[["tag",/^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/],["pun",/^[/<->]+/],["lang-js",/^on\w+\s*=\s*"([^"]+)"/i],["lang-js",/^on\w+\s*=\s*'([^']+)'/i],["lang-js",/^on\w+\s*=\s*([^\s"'>]+)/i],["lang-css",/^style\s*=\s*"([^"]+)"/i],["lang-css",/^style\s*=\s*'([^']+)'/i],["lang-css",
+/^style\s*=\s*([^\s"'>]+)/i]]),["in.tag"]);k(x([],[["atv",/^[\S\s]+/]]),["uq.val"]);k(u({keywords:F,hashComments:!0,cStyleComments:!0,types:K}),["c","cc","cpp","cxx","cyc","m"]);k(u({keywords:"null,true,false"}),["json"]);k(u({keywords:H,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:K}),["cs"]);k(u({keywords:G,cStyleComments:!0}),["java"]);k(u({keywords:v,hashComments:!0,multiLineStrings:!0}),["bsh","csh","sh"]);k(u({keywords:I,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),
+["cv","py"]);k(u({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["perl","pl","pm"]);k(u({keywords:J,hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb"]);k(u({keywords:w,cStyleComments:!0,regexLiterals:!0}),["js"]);k(u({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,true,try,unless,until,when,while,yes",
+hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);k(x([],[["str",/^[\S\s]+/]]),["regex"]);window.prettyPrintOne=function(a,m,e){var h=document.createElement("PRE");h.innerHTML=a;e&&D(h,e);E({g:m,i:e,h:h});return h.innerHTML};window.prettyPrint=function(a){function m(){for(var e=window.PR_SHOULD_USE_CONTINUATION?l.now()+250:Infinity;p<h.length&&l.now()<e;p++){var n=h[p],k=n.className;if(k.indexOf("prettyprint")>=0){var k=k.match(g),f,b;if(b=
+!k){b=n;for(var o=void 0,c=b.firstChild;c;c=c.nextSibling)var i=c.nodeType,o=i===1?o?b:c:i===3?N.test(c.nodeValue)?b:o:o;b=(f=o===b?void 0:o)&&"CODE"===f.tagName}b&&(k=f.className.match(g));k&&(k=k[1]);b=!1;for(o=n.parentNode;o;o=o.parentNode)if((o.tagName==="pre"||o.tagName==="code"||o.tagName==="xmp")&&o.className&&o.className.indexOf("prettyprint")>=0){b=!0;break}b||((b=(b=n.className.match(/\blinenums\b(?::(\d+))?/))?b[1]&&b[1].length?+b[1]:!0:!1)&&D(n,b),d={g:k,h:n,i:b},E(d))}}p<h.length?setTimeout(m,
+250):a&&a()}for(var e=[document.getElementsByTagName("pre"),document.getElementsByTagName("code"),document.getElementsByTagName("xmp")],h=[],k=0;k<e.length;++k)for(var t=0,s=e[k].length;t<s;++t)h.push(e[k][t]);var e=q,l=Date;l.now||(l={now:function(){return+new Date}});var p=0,d,g=/\blang(?:uage)?-([\w.]+)(?!\S)/;m()};window.PR={createSimpleLexer:x,registerLangHandler:k,sourceDecorator:u,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",
+PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ"}})();
/Fim/
diff --git a/website/static/ribbon.png b/website/static/ribbon.png
new file mode 100644
index 0000000..8fe3a7e
--- /dev/null
+++ b/website/static/ribbon.png
Binary files differ
/Fim/
diff --git a/website/static/square.png b/website/static/square.png
new file mode 100644
index 0000000..bc1caf9
--- /dev/null
+++ b/website/static/square.png
Binary files differ
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 6cba084..efe994e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -16,7 +16,6 @@
 package dagger.internal.codegen;
 
 import dagger.Module;
-import dagger.OneOf;
 import dagger.Provides;
 import dagger.internal.Binding;
 import dagger.internal.Linker;
@@ -105,23 +104,31 @@
 
         // Gather the enclosed @Provides methods.
         for (Element enclosed : module.getEnclosedElements()) {
-          if (enclosed.getAnnotation(Provides.class) == null) {
+          Provides provides = enclosed.getAnnotation(Provides.class);
+          if (provides == null) {
             continue;
           }
           ExecutableElement providerMethod = (ExecutableElement) enclosed;
           String key = GeneratorKeys.get(providerMethod);
           ProviderMethodBinding binding = new ProviderMethodBinding(key, providerMethod);
-          if (providerMethod.getAnnotation(OneOf.class) != null) {
-            String elementKey = GeneratorKeys.getElementKey(providerMethod);
-            SetBinding.add(addTo, elementKey, binding);
-          } else {
-            ProviderMethodBinding clobbered = (ProviderMethodBinding) addTo.put(key, binding);
-            if (clobbered != null) {
-              processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
-                  "Duplicate bindings for " + key
-                      + ": " + shortMethodName(clobbered.method)
-                      + ", " + shortMethodName(binding.method));
-            }
+          switch (provides.type()) {
+            case UNIQUE:
+              ProviderMethodBinding clobbered = (ProviderMethodBinding) addTo.put(key, binding);
+              if (clobbered != null) {
+                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
+                    "Duplicate bindings for " + key
+                        + ": " + shortMethodName(clobbered.method)
+                        + ", " + shortMethodName(binding.method));
+              }
+              break;
+
+            case SET:
+              String elementKey = GeneratorKeys.getElementKey(providerMethod);
+              SetBinding.add(addTo, elementKey, binding);
+              break;
+
+            default:
+              throw new AssertionError("Unknown @Provides type " + provides.type());
           }
         }
       }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index c079f81..04cc804 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -16,7 +16,6 @@
 package dagger.internal.codegen;
 
 import dagger.Module;
-import dagger.OneOf;
 import dagger.Provides;
 import dagger.internal.Binding;
 import dagger.internal.Linker;
@@ -207,14 +206,22 @@
         = new LinkedHashMap<ExecutableElement, String>();
     Map<String, AtomicInteger> methodNameToNextId = new LinkedHashMap<String, AtomicInteger>();
     for (ExecutableElement providerMethod : providerMethods) {
-      if (providerMethod.getAnnotation(OneOf.class) != null) {
-        String key = GeneratorKeys.getElementKey(providerMethod);
-        writer.statement("SetBinding.add(map, %s, new %s(module))", JavaWriter.stringLiteral(key),
-            bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
-      } else {
-        String key = GeneratorKeys.get(providerMethod);
-        writer.statement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
-            bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
+      Provides provides = providerMethod.getAnnotation(Provides.class);
+      switch (provides.type()) {
+        case UNIQUE: {
+          String key = GeneratorKeys.get(providerMethod);
+          writer.statement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
+              bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
+          break;
+        }
+        case SET: {
+          String key = GeneratorKeys.getElementKey(providerMethod);
+          writer.statement("SetBinding.add(map, %s, new %s(module))", JavaWriter.stringLiteral(key),
+              bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
+          break;
+        }
+        default:
+          throw new AssertionError("Unknown @Provides type " + provides.type());
       }
     }
     writer.endMethod();
/Fim/
/Fim/
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index 629819b..f9f66ac 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -32,4 +32,22 @@
  */
 @Documented @Target(METHOD) @Retention(RUNTIME)
 public @interface Provides {
+  /** The type of binding into which the return type of the annotated method contributes. */
+  enum Type {
+    /**
+     * The method is the only one which can produce the value for the specified return type. This
+     * is the default behavior.
+     */
+    UNIQUE,
+
+    /**
+     * The method's return type forms the generic type argument of a {@code Set<T>}, and the
+     * returned value is contributed to the set. The object graph will pass dependencies to the
+     * method as parameters. The {@code Set<T>} produced from the accumulation of values will be
+     * immutable.
+     */
+    SET
+  }
+
+  Type type() default Type.UNIQUE;
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
index b0317bc..60d6bd0 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
@@ -16,7 +16,6 @@
 package dagger.internal.plugins.reflect;
 
 import dagger.Module;
-import dagger.OneOf;
 import dagger.Provides;
 import dagger.internal.Binding;
 import dagger.internal.Keys;
@@ -56,12 +55,18 @@
   @Override public void getBindings(Map<String, Binding<?>> bindings) {
     for (Class<?> c = moduleClass; c != Object.class; c = c.getSuperclass()) {
       for (Method method : c.getDeclaredMethods()) {
-        if (method.isAnnotationPresent(Provides.class)) {
+        Provides provides = method.getAnnotation(Provides.class);
+        if (provides != null) {
           String key = Keys.get(method.getGenericReturnType(), method.getAnnotations(), method);
-          if (method.isAnnotationPresent(OneOf.class)) {
-            handleSetBindings(bindings, method, key);
-          } else {
-            handleBindings(bindings, method, key);
+          switch (provides.type()) {
+            case UNIQUE:
+              handleBindings(bindings, method, key);
+              break;
+            case SET:
+              handleSetBindings(bindings, method, key);
+              break;
+            default:
+              throw new AssertionError("Unknown @Provides type " + provides.type());
           }
         }
       }
/Fim/
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index d6accc3..686cf3a 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -28,6 +28,7 @@
 import javax.inject.Singleton;
 import org.junit.Test;
 
+import static dagger.Provides.Type.SET;
 import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -41,8 +42,8 @@
 
     @Module(entryPoints = TestEntryPoint.class)
     class TestModule {
-      @Provides @OneOf String provideFirstString() { return "string1"; }
-      @Provides @OneOf String provideSecondString() { return "string2"; }
+      @Provides(type=SET) String provideFirstString() { return "string1"; }
+      @Provides(type=SET) String provideSecondString() { return "string2"; }
     }
 
     TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
@@ -56,12 +57,12 @@
 
     @Module
     class TestIncludesModule {
-      @Provides @OneOf String provideSecondString() { return "string2"; }
+      @Provides(type=SET) String provideSecondString() { return "string2"; }
     }
 
     @Module(entryPoints = TestEntryPoint.class, includes = TestIncludesModule.class)
     class TestModule {
-      @Provides @OneOf String provideFirstString() { return "string1"; }
+      @Provides(type=SET) String provideFirstString() { return "string1"; }
     }
 
     TestEntryPoint ep = injectWithModule(new TestEntryPoint(),
@@ -79,8 +80,8 @@
 
     @Module(entryPoints = TestEntryPoint.class)
     class TestModule {
-      @Provides @OneOf @Singleton Integer a() { return singletonCounter.getAndIncrement(); }
-      @Provides @OneOf Integer b() { return defaultCounter.getAndIncrement(); }
+      @Provides(type=SET) @Singleton Integer a() { return singletonCounter.getAndIncrement(); }
+      @Provides(type=SET) Integer b() { return defaultCounter.getAndIncrement(); }
     }
 
     TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
@@ -100,8 +101,8 @@
 
     @Module(entryPoints = { TestEntryPoint1.class, TestEntryPoint2.class })
     class TestModule {
-      @Provides @OneOf @Singleton Integer a() { return singletonCounter.getAndIncrement(); }
-      @Provides @OneOf Integer b() { return defaultCounter.getAndIncrement(); }
+      @Provides(type=SET) @Singleton Integer a() { return singletonCounter.getAndIncrement(); }
+      @Provides(type=SET) Integer b() { return defaultCounter.getAndIncrement(); }
     }
 
     ObjectGraph graph = ObjectGraph.create(new TestModule());
@@ -122,10 +123,10 @@
 
     @Module(entryPoints = TestEntryPoint.class)
     class TestModule {
-      @Provides @OneOf String provideString1() { return "string1"; }
-      @Provides @OneOf String provideString2() { return "string2"; }
-      @Provides @OneOf @Named("foo") String provideString3() { return "string3"; }
-      @Provides @OneOf @Named("foo") String provideString4() { return "string4"; }
+      @Provides(type=SET) String provideString1() { return "string1"; }
+      @Provides(type=SET) String provideString2() { return "string2"; }
+      @Provides(type=SET) @Named("foo") String provideString3() { return "string3"; }
+      @Provides(type=SET) @Named("foo") String provideString4() { return "string4"; }
     }
 
     TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
@@ -146,7 +147,7 @@
     final AtomicReference<String> logoutput = new AtomicReference<String>();
     @Module
     class LogModule {
-      @Provides @OneOf LogSink outputtingLogSink() {
+      @Provides(type=SET) LogSink outputtingLogSink() {
         return new LogSink() {
           @Override public void log(LogMessage message) {
             StringWriter sw = new StringWriter();
@@ -158,7 +159,7 @@
     }
     @Module(entryPoints = TestEntryPoint.class)
     class TestModule {
-      @Provides @OneOf LogSink nullLogger() {
+      @Provides(type=SET) LogSink nullLogger() {
         return new LogSink() { @Override public void log(LogMessage message) {} };
       }
     }
/Fim/
diff --git a/core/src/test/java/dagger/internal/KeysTest.java b/core/src/test/java/dagger/internal/KeysTest.java
index fe2b85f..d99158a 100644
--- a/core/src/test/java/dagger/internal/KeysTest.java
+++ b/core/src/test/java/dagger/internal/KeysTest.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal;
 
-import dagger.OneOf;
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.Provides;
@@ -27,6 +26,7 @@
 import javax.inject.Provider;
 import org.junit.Test;
 
+import static dagger.Provides.Type.SET;
 import static org.fest.assertions.Assertions.assertThat;
 
 public final class KeysTest {
@@ -125,7 +125,7 @@
     assertThat(Keys.getLazyKey(fieldKey("providerOfTypeAnnotated"))).isNull();
   }
 
-  @Provides @OneOf String elementProvides() { return "foo"; }
+  @Provides(type=SET) String elementProvides() { return "foo"; }
 
   @Test public void testGetElementKey_NoQualifier() throws NoSuchMethodException {
     Method method = KeysTest.class.getDeclaredMethod("elementProvides", new Class<?>[]{});
@@ -134,7 +134,7 @@
   }
 
   @Named("foo")
-  @Provides @OneOf String qualifiedElementProvides() { return "foo"; }
+  @Provides(type=SET) String qualifiedElementProvides() { return "foo"; }
 
   @Test public void testGetElementKey_WithQualifier() throws NoSuchMethodException {
     Method method = KeysTest.class.getDeclaredMethod("qualifiedElementProvides", new Class<?>[]{});
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 349213c..6bb906d 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -232,11 +232,12 @@
    * @throws IllegalArgumentException if the runtime type of {@code instance} is
    *     not one of this object graph's entry point types.
    */
-  public void inject(Object instance) {
+  public <T> T inject(T instance) {
     String membersKey = Keys.getMembersKey(instance.getClass());
     @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
     Binding<Object> binding = (Binding<Object>) getEntryPointBinding(membersKey, membersKey);
     binding.injectMembers(instance);
+    return instance;
   }
 
   /**
/Fim/
diff --git a/core/src/test/java/dagger/InjectionOfLazyTest.java b/core/src/test/java/dagger/InjectionOfLazyTest.java
index 5a6c72e..bb22100 100644
--- a/core/src/test/java/dagger/InjectionOfLazyTest.java
+++ b/core/src/test/java/dagger/InjectionOfLazyTest.java
@@ -124,10 +124,6 @@
   }
 
   private <T> T injectWithModule(T ep, Object ... modules) {
-    // TODO(cgruber): Make og.inject(foo) return foo properly.
-    ObjectGraph og = ObjectGraph.create(modules);
-    og.inject(ep);
-    return ep;
+    return ObjectGraph.create(modules).inject(ep);
   }
-
 }
/Fim/
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index 686cf3a..a69615f 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -106,10 +106,8 @@
     }
 
     ObjectGraph graph = ObjectGraph.create(new TestModule());
-    TestEntryPoint1 ep1 = new TestEntryPoint1();
-    graph.inject(ep1);
-    TestEntryPoint2 ep2 = new TestEntryPoint2();
-    graph.inject(ep2);
+    TestEntryPoint1 ep1 = graph.inject(new TestEntryPoint1());
+    TestEntryPoint2 ep2 = graph.inject(new TestEntryPoint2());
     assertEquals(set(100, 200), ep1.objects1);
     assertEquals(set(100, 201), ep2.objects2);
 
@@ -196,10 +194,7 @@
   }
 
   private <T> T injectWithModule(T ep, Object ... modules) {
-    // TODO(cgruber): Make og.inject(foo) return foo properly.
-    ObjectGraph og = ObjectGraph.create(modules);
-    og.inject(ep);
-    return ep;
+    return ObjectGraph.create(modules).inject(ep);
   }
 
   private <T> Set<T> set(T... ts) {
/Fim/
diff --git a/androidmanifest/README.md b/androidmanifest/README.md
index 3272569..5ec86a8 100644
--- a/androidmanifest/README.md
+++ b/androidmanifest/README.md
@@ -5,6 +5,16 @@
 designed to be used both in a standalone manner (such as with Ant) and as a
 Maven plugin.
 
+The module generated from this plugin is not automatically added to your
+object graph. You will need to explicitly include it during construction:
+
+```java
+ObjectGraph og = ObjectGraph.get(
+  new MyModule(),       // Your declared module.
+  new ManifestModule()  // Module generated from this plugin.
+);
+```
+
 
 Maven Usage
 -----------
@@ -28,7 +38,7 @@
 Optional configuration:
 
  * `androidManifest` - Path to the `AndroidManifest.xml` file.
- * `moduleName` - Class name
+ * `moduleName` - Class name. Defaults to `ManifestModule` in the package declared in your manifest.
  * `outputDirectory` - Generated source directory, automatically added to build path.
 
 
/Fim/
diff --git a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
index 4646c9e..6d7c757 100644
--- a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
+++ b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
@@ -218,8 +218,8 @@
   private static void printUsage() {
     System.out.println("Usage: ModuleGenerator manifest module out");
     System.out.println("  manifest: path to AndroidManifest.xml");
-    System.out.println("    module: name of the generated class, like 'ActivitiesModule'.");
-    System.out.println("            May be fully-qualified like 'com.squareup.ActivitiesModule'.");
+    System.out.println("    module: name of the generated class, like 'ManifestModule'.");
+    System.out.println("            May be fully-qualified like 'com.squareup.ManifestModule'.");
     System.out.println("       out: base directory for generated .java source files");
   }
 }
/Fim/
diff --git a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorMojo.java b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorMojo.java
index d4b35ed..6b63949 100644
--- a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorMojo.java
+++ b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorMojo.java
@@ -30,7 +30,7 @@
   /**
    * The {@code AndroidManifest.xml} file.
    *
-   * @parameter default-value="ActivitiesModule"
+   * @parameter default-value="ManifestModule"
    * @required
    */
   private String moduleName;
/Fim/
diff --git a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
index 6d7c757..e1adf93 100644
--- a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
+++ b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
@@ -39,8 +39,6 @@
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 
-// TODO: support relative class name references like ".FooActivity"
-
 /**
  * Generates an object graph module source file that has entry points for all
  * classes referenced in an {@code AndroidManifest.xml} file.
@@ -81,7 +79,7 @@
 
   public void generate(Document manifest, String moduleName, JavaWriter out) throws IOException {
     String packageName = packageName(manifest, moduleName);
-    List<String> nameReferences = getNameReferences(manifest);
+    List<String> nameReferences = getNameReferences(manifest, packageName);
     generate(packageName, nameReferences, moduleName, out);
   }
 
@@ -121,7 +119,7 @@
    * provider}, {@code receiver} and {@code service} tags within {@code
    * manifest}.
    */
-  List<String> getNameReferences(Document manifest) {
+  List<String> getNameReferences(Document manifest, String packageName) {
     List<String> result = new ArrayList<String>();
     Element root = manifest.getDocumentElement();
     if (!root.getTagName().equals("manifest")) {
@@ -145,7 +143,7 @@
           if (entryPointAttr != null && !Boolean.valueOf(entryPointAttr.getValue())) {
             continue;
           }
-          result.add(nameAttr.getValue());
+          result.add(cleanActivityName(packageName, nameAttr.getValue()));
         }
       }
     }
@@ -215,6 +213,19 @@
     out.close();
   }
 
+  static String cleanActivityName(String manifestPackage, String activityName) {
+    if (activityName.charAt(0) == '.') {
+      // Relative activity name (e.g., android:name=".ui.SomeClass").
+      return manifestPackage + activityName;
+    }
+    if (activityName.indexOf('.', 1) == -1) {
+      // Unqualified activity name (e.g., android:name="SomeClass").
+      return manifestPackage + "." + activityName;
+    }
+    // Fully-qualified activity name (e.g., "com.my.package.SomeClass").
+    return activityName;
+  }
+
   private static void printUsage() {
     System.out.println("Usage: ModuleGenerator manifest module out");
     System.out.println("  manifest: path to AndroidManifest.xml");
/Fim/
diff --git a/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java b/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
index ec1ff59..bdc1673 100644
--- a/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
+++ b/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
@@ -26,6 +26,7 @@
 import org.w3c.dom.Document;
 import org.xml.sax.InputSource;
 
+import static dagger.androidmanifest.ModuleGenerator.cleanActivityName;
 import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
@@ -94,8 +95,8 @@
         + "  </application>\n"
         + "</manifest>\n";
     Document document = document(manifestXml);
-    assertThat(generator.getNameReferences(document)).isEqualTo(Arrays.asList(
-        "result.a.Activity", "result.b.Provider", "result.c.Receiver", "result.d.Service"));
+    assertThat(generator.getNameReferences(document, "com.squareup.badhorse")).isEqualTo(
+        Arrays.asList("result.a.Activity", "result.b.Provider", "result.c.Receiver", "result.d.Service"));
   }
 
   @Test public void excludedEntryPointNames() throws Exception {
@@ -111,10 +112,23 @@
         + "  </application>\n"
         + "</manifest>\n";
     Document document = document(manifestXml);
-    assertThat(generator.getNameReferences(document))
+    assertThat(generator.getNameReferences(document, "com.squareup.badhorse"))
         .isEqualTo(Arrays.asList("true.Activity", "default.Activity"));
   }
 
+  @Test public void fullyQualifyEntryPointNames() throws Exception {
+    assertThat(cleanActivityName("com.squareup.badhorse", "Activity"))
+        .isEqualTo("com.squareup.badhorse.Activity");
+    assertThat(cleanActivityName("com.squareup.badhorse", "org.other.package.Activity"))
+        .isEqualTo("org.other.package.Activity");
+    assertThat(cleanActivityName("com.squareup.badhorse", ".Activity"))
+        .isEqualTo("com.squareup.badhorse.Activity");
+    assertThat(cleanActivityName("com.squareup.badhorse", ".ui.Activity"))
+        .isEqualTo("com.squareup.badhorse.ui.Activity");
+    assertThat(cleanActivityName("com.squareup.badhorse", "com.squareup.badhorse.Activity"))
+        .isEqualTo("com.squareup.badhorse.Activity");
+  }
+
   @Test public void generate() throws IOException {
     String packageName = "com.squareup.badhorse";
     List<String> nameReferences = Arrays.asList(
/Fim/
diff --git a/androidmanifest/README.md b/androidmanifest/README.md
index 5ec86a8..b463b40 100644
--- a/androidmanifest/README.md
+++ b/androidmanifest/README.md
@@ -38,7 +38,8 @@
 Optional configuration:
 
  * `androidManifest` - Path to the `AndroidManifest.xml` file.
- * `moduleName` - Class name. Defaults to `ManifestModule` in the package declared in your manifest.
+ * `moduleName` - Generated module class name. Defaults to `ManifestModule` in the package declared
+   in your manifest. May be a fully-qualified class name.
  * `outputDirectory` - Generated source directory, automatically added to build path.
 
 
@@ -47,18 +48,22 @@
 ---------
 
 ```xml
-<macrodef name="generate-dagger-module">
-  <attribute name="dir"/>
-  <attribute name="name"/>
+<taskdef name="dagger-manifest" classname="dagger.androidmanifest.ModuleGeneratorTask"/>
 
-  <sequential>
-    <mkdir dir="@{dir}/src"/>
-    <java classname="dagger.androidmanifest.ModuleGenerator"
-          classpath="${com.squareup:dagger:jar}:${com.squareup:dagger-androidmanifest-plugin:jar}">
-      <arg value="@{dir}/AndroidManifest.xml"/>
-      <arg value="@{name}"/>
-      <arg value="@{dir}/gen"/>
-    </java>
-  </sequential>
-</macrodef>
+<target name="-pre-build">
+  <dagger-manifest/>
+</target>
 ```
+
+Optional task arguments:
+
+ * `manifest` - Path to the `AndroidManifest.xml` file.
+ * `name` - Generated module class name. Defaults to `ManifestModule` in the package declared in
+   your manifest. May be a fully-qualified class name.
+ * `out` - Generated source directory. Defaults to `gen/`.
+
+For example,
+
+```xml
+<dagger-manifest name="com.other.pkg.ActivitiesModule"/>
+```
\ No newline at end of file
/Fim/
diff --git a/androidmanifest/pom.xml b/androidmanifest/pom.xml
index f253ac1..20d6ce8 100644
--- a/androidmanifest/pom.xml
+++ b/androidmanifest/pom.xml
@@ -42,6 +42,7 @@
       <artifactId>dagger-compiler</artifactId>
       <version>${project.version}</version>
     </dependency>
+
     <dependency>
       <groupId>org.apache.maven</groupId>
       <artifactId>maven-core</artifactId>
@@ -50,6 +51,11 @@
       <groupId>org.apache.maven</groupId>
       <artifactId>maven-plugin-api</artifactId>
     </dependency>
+    <dependency>
+      <groupId>org.apache.ant</groupId>
+      <artifactId>ant</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
/Fim/
diff --git a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorTask.java b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorTask.java
new file mode 100644
index 0000000..2d7fb80
--- /dev/null
+++ b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGeneratorTask.java
@@ -0,0 +1,39 @@
+package dagger.androidmanifest;
+
+import java.io.File;
+import java.io.IOException;
+import javax.xml.parsers.ParserConfigurationException;
+import org.apache.tools.ant.BuildException;
+import org.apache.tools.ant.Task;
+import org.xml.sax.SAXException;
+
+@SuppressWarnings("UnusedDeclaration") // Methods used implicitly by Ant.
+public class ModuleGeneratorTask extends Task {
+  private File manifestFile = new File("AndroidManifest.xml");
+  private String moduleName = "ManifestModule";
+  private File outputDirectory = new File("gen");
+
+  public void setManifest(File manifestFile) {
+    this.manifestFile = manifestFile;
+  }
+
+  public void setName(String moduleName) {
+    this.moduleName = moduleName;
+  }
+
+  public void setOut(File outputDirectory) {
+    this.outputDirectory = outputDirectory;
+  }
+
+  @Override public void execute() {
+    try {
+      ModuleGenerator.generate(manifestFile, moduleName, outputDirectory);
+    } catch (IOException e) {
+      throw new BuildException("Unable to generate module.", e);
+    } catch (SAXException e) {
+      throw new BuildException("Unable to generate module.", e);
+    } catch (ParserConfigurationException e) {
+      throw new BuildException("Unable to generate module.", e);
+    }
+  }
+}
/Fim/
diff --git a/androidmanifest/src/test/java/dagger/androidmanifest/AntTaskTest.java b/androidmanifest/src/test/java/dagger/androidmanifest/AntTaskTest.java
new file mode 100644
index 0000000..65f6eba
--- /dev/null
+++ b/androidmanifest/src/test/java/dagger/androidmanifest/AntTaskTest.java
@@ -0,0 +1,41 @@
+package dagger.androidmanifest;
+
+import java.io.File;
+import java.io.IOException;
+import org.apache.tools.ant.Project;
+import org.apache.tools.ant.ProjectHelper;
+import org.codehaus.plexus.util.FileUtils;
+import org.fest.util.Files;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+public class AntTaskTest {
+  @Test public void antTaskCreatesModule() throws IOException {
+    File baseDir = Files.newTemporaryFolder();
+
+    // Copy build.xml and AndroidManifest.xml to temporary directory.
+    File manifest = new File(getClass().getResource("/AndroidManifest.xml").getFile());
+    FileUtils.copyFile(manifest, new File(baseDir, "AndroidManifest.xml"));
+    File buildSrc = new File(getClass().getResource("/build.xml").getFile());
+    File buildDest = new File(baseDir, "build.xml");
+    FileUtils.copyFile(buildSrc, buildDest);
+
+    // Invoke build.xml's "test" target.
+    Project project = new Project();
+    ProjectHelper projectHelper = ProjectHelper.getProjectHelper();
+    project.setUserProperty("ant.file", buildDest.getAbsolutePath());
+    project.setProperty("maven.class.dir", System.getProperty("basedir") + "/target/classes/");
+    project.setProperty("temp.dir", baseDir.getAbsolutePath());
+    project.init();
+    project.addReference("ant.projectHelper", projectHelper);
+    projectHelper.parse(project, buildDest);
+    project.executeTarget("test");
+
+    // Verify generated ManifestModule.java
+    File generated = new File(baseDir, "gen");
+    assertThat(generated).exists().isDirectory();
+    File manifestModule = new File(generated, "com/squareup/badhorse/ManifestModule.java");
+    assertThat(manifestModule).exists().isFile();
+  }
+}
/Fim/
diff --git a/androidmanifest/src/test/resources/AndroidManifest.xml b/androidmanifest/src/test/resources/AndroidManifest.xml
new file mode 100644
index 0000000..74dab35
--- /dev/null
+++ b/androidmanifest/src/test/resources/AndroidManifest.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.badhorse"
+    android:versionCode="1"
+    android:versionName="1">
+</manifest>
\ No newline at end of file
/Fim/
diff --git a/androidmanifest/src/test/resources/build.xml b/androidmanifest/src/test/resources/build.xml
new file mode 100644
index 0000000..06d5343
--- /dev/null
+++ b/androidmanifest/src/test/resources/build.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project name="ant-test">
+
+  <path id="dagger.path">
+    <fileset dir="${maven.class.dir}" includes="**/*.class"/>
+  </path>
+
+  <taskdef name="dagger-manifest"
+      classpathref="dagger.path"
+      classname="dagger.androidmanifest.ModuleGeneratorTask"/>
+
+  <target name="test">
+    <dagger-manifest
+        manifest="${temp.dir}/AndroidManifest.xml"
+        out="${temp.dir}/gen/"/>
+  </target>
+
+</project>
/Fim/
diff --git a/pom.xml b/pom.xml
index 1fab4ac..108ca88 100644
--- a/pom.xml
+++ b/pom.xml
@@ -48,6 +48,7 @@
     <java.version>1.6</java.version>
     <javax.inject.version>1</javax.inject.version>
     <maven.version>2.0.6</maven.version>
+    <ant.version>1.8.2</ant.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
@@ -95,6 +96,11 @@
         <version>${maven.version}</version>
       </dependency>
       <dependency>
+        <groupId>org.apache.ant</groupId>
+        <artifactId>ant</artifactId>
+        <version>${ant.version}</version>
+      </dependency>
+      <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
         <version>${junit.version}</version>
/Fim/
diff --git a/website/index.html b/website/index.html
index 5f9b93a..c82aeb9 100644
--- a/website/index.html
+++ b/website/index.html
@@ -14,6 +14,9 @@
 
 <p>Dependency injection isn't just for testing. It also makes it easy to create <strong>reusable, interchangeable modules</strong>. You can share the same <code>AuthenticationModule</code>  across all of your apps. And you can run <code>DevLoggingModule</code> during development and <code>ProdLoggingModule</code> in production to get the right behavior in each situation.</p>
 
+<h3>Using Dagger</h3>
+<p>We'll demonstrate dependency injection and Dagger by building a coffee maker. For complete sample code that you can compile and run, see Dagger's <a href="https://github.com/square/dagger/tree/master/example/src/main/java/coffee">coffee example</a>.</p>
+
 <h4>Declaring Dependencies</h4>
 
 <p>Dagger constructs instances of your application classes and satisfies their dependencies. It uses the <code>javax.inject.Inject</code> annotation to identify which constructors and fields it is interested in.</p>
@@ -139,7 +142,7 @@
 <pre>
 $ java -cp ... coffee.CoffeeApp
 ~ ~ ~ heating ~ ~ ~
-=> => pumping => =>
+=&gt; =&gt; pumping =&gt; =&gt;
  [_]P coffee! [_]P
 </pre>
 
@@ -168,7 +171,7 @@
 
 <pre class="prettyprint">
 class GridingCoffeeMaker {
-  @Inject Lazy<Grinder> lazyGrinder;
+  @Inject Lazy&lt;Grinder&gt; lazyGrinder;
 
   public void brew() {
     while (needsGrinding()) {
@@ -186,11 +189,11 @@
 <pre class="prettyprint">
 
 class BigCoffeeMaker {
-  @Inject Provider<Filter> filterProvider;
+  @Inject Provider&lt;Filter&gt; filterProvider;
 
   public void brew(int numberOfPots) {
 	...
-    for (int p = 0; p < numberOfPots; p++) {
+    for (int p = 0; p &lt; numberOfPots; p++) {
       maker.addFilter(filterProvider.get()); //new filter every time.
       maker.addCoffee(...);
       maker.percolate();
/Fim/
diff --git a/README.md b/README.md
index 269cc98..1ba30bb 100644
--- a/README.md
+++ b/README.md
@@ -20,27 +20,28 @@
 plugin:
 
 ```xml
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>dagger</artifactId>
-      <version>${dagger.version}</version>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <dependencies>
-          <dependency>
-            <groupId>com.squareup</groupId>
-            <artifactId>dagger-compiler</artifactId>
-            <version>${dagger.version}</version>
-          </dependency>
-        </dependencies>
-      </plugin>
-    </plugins>
-  </build>
+<dependencies>
+  <dependency>
+    <groupId>com.squareup</groupId>
+    <artifactId>dagger</artifactId>
+    <version>${dagger.version}</version>
+  </dependency>
+</dependencies>
+
+<build>
+  <plugins>
+    <plugin>
+      <artifactId>maven-compiler-plugin</artifactId>
+      <dependencies>
+        <dependency>
+          <groupId>com.squareup</groupId>
+          <artifactId>dagger-compiler</artifactId>
+          <version>${dagger.version}</version>
+        </dependency>
+      </dependencies>
+    </plugin>
+  </plugins>
+</build>
 ```
 
 You can also find downloadable .jars on the [GitHub download page][2].
@@ -67,4 +68,4 @@
 
 
  [1]: http://square.github.com/dagger/
- [2]: http://github.com/square/dagger/downloads
\ No newline at end of file
+ [2]: http://github.com/square/dagger/downloads
/Fim/
diff --git a/compiler/src/it/default-package-injected-type/pom.xml b/compiler/src/it/default-package-injected-type/pom.xml
new file mode 100644
index 0000000..88110a4
--- /dev/null
+++ b/compiler/src/it/default-package-injected-type/pom.xml
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2012 Square, Inc.
+ Copyright (C) 2012 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.squareup.dagger.tests</groupId>
+  <artifactId>default-package-injected-type</artifactId>
+  <version>@dagger.version@</version>
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <scope>provided</scope>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/default-package-injected-type/src/main/java/TestApp.java b/compiler/src/it/default-package-injected-type/src/main/java/TestApp.java
new file mode 100644
index 0000000..3600ffd
--- /dev/null
+++ b/compiler/src/it/default-package-injected-type/src/main/java/TestApp.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2012 Google, Inc.
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import dagger.ObjectGraph;
+import dagger.Module;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+class TestApp implements Runnable {
+  @Inject A a;
+
+  @Override public void run() {
+    a.doit();
+  }
+
+  public static void main(String[] args) {
+    ObjectGraph.create(new TestModule()).get(TestApp.class).run();
+  }
+  
+  @Module(entryPoints = { TestApp.class })
+  static class TestModule {}
+
+  @Singleton
+  static class A {
+    @Inject A() {}
+    public void doit() {};
+  }
+}
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java b/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
index f941070..d22f12b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
@@ -224,10 +224,14 @@
       char innerClassSeparator) {
     String packageName = getPackage(type).getQualifiedName().toString();
     String qualifiedName = type.getQualifiedName().toString();
-    result.append(packageName);
-    result.append('.');
-    result.append(
-        qualifiedName.substring(packageName.length() + 1).replace('.', innerClassSeparator));
+    if (packageName.isEmpty()) {
+        result.append(qualifiedName.replace('.', innerClassSeparator));
+    } else {
+      result.append(packageName);
+      result.append('.');
+      result.append(
+          qualifiedName.substring(packageName.length() + 1).replace('.', innerClassSeparator));
+    }
   }
 
   private static Class<?> box(PrimitiveType primitiveType) {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
index 7c928ea..59aae6b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
@@ -59,10 +59,14 @@
     if (this.packagePrefix != null) {
       throw new IllegalStateException();
     }
-    out.write("package ");
-    out.write(packageName);
-    out.write(";\n");
-    this.packagePrefix = packageName + ".";
+    if (packageName.isEmpty()) {
+      this.packagePrefix = "";
+    } else {
+      out.write("package ");
+      out.write(packageName);
+      out.write(";\n");
+      this.packagePrefix = packageName + ".";
+    }
   }
 
   /**
/Fim/
/Fim/
/Fim/
/Fim/
diff --git a/androidmanifest/pom.xml b/androidmanifest/pom.xml
index c3d3ef7..b8696f8 100644
--- a/androidmanifest/pom.xml
+++ b/androidmanifest/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0-SNAPSHOT</version>
+    <version>0.9.1</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index b9e29a3..c6dcf65 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0-SNAPSHOT</version>
+    <version>0.9.1</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 209c49a..d5614f4 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0-SNAPSHOT</version>
+    <version>0.9.1</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/example/pom.xml b/example/pom.xml
index 1a63ca3..7ce719e 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.0-SNAPSHOT</version>
+    <version>0.9.1</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/pom.xml b/pom.xml
index 3bc8ecf..99afbfb 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.0-SNAPSHOT</version>
+  <version>0.9.1</version>
   <name>Dagger (Parent)</name>
   <description>A JSR-330 dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -56,7 +56,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>HEAD</tag>
+    <tag>dagger-parent-0.9.1</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/androidmanifest/pom.xml b/androidmanifest/pom.xml
index b8696f8..c3d3ef7 100644
--- a/androidmanifest/pom.xml
+++ b/androidmanifest/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>0.9.1</version>
+    <version>1.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index c6dcf65..b9e29a3 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>0.9.1</version>
+    <version>1.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index d5614f4..209c49a 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>0.9.1</version>
+    <version>1.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/example/pom.xml b/example/pom.xml
index 7ce719e..1a63ca3 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>0.9.1</version>
+    <version>1.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/pom.xml b/pom.xml
index 99afbfb..3bc8ecf 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>0.9.1</version>
+  <version>1.0-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
   <description>A JSR-330 dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -56,7 +56,7 @@
     <url>http://github.com/square/dagger/</url>
     <connection>scm:git:git://github.com/square/dagger.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/square/dagger.git</developerConnection>
-    <tag>dagger-parent-0.9.1</tag>
+    <tag>HEAD</tag>
   </scm>
 
   <issueManagement>
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index efe994e..c2da407 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -15,19 +15,16 @@
  */
 package dagger.internal.codegen;
 
-import dagger.Module;
-import dagger.Provides;
-import dagger.internal.Binding;
-import dagger.internal.Linker;
-import dagger.internal.SetBinding;
 import java.io.IOException;
 import java.io.Writer;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
@@ -45,19 +42,41 @@
 import javax.tools.JavaFileManager;
 import javax.tools.StandardLocation;
 
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.Binding;
+import dagger.internal.Linker;
+import dagger.internal.SetBinding;
+
 /**
  * Performs full graph analysis on a module.
  */
 @SupportedAnnotationTypes("dagger.Module")
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class FullGraphProcessor extends AbstractProcessor {
+  private final Set<String> delayedModuleNames = new LinkedHashSet<String>();
+
   /**
    * Perform full-graph analysis on complete modules. This checks that all of
    * the module's dependencies are satisfied.
    */
   @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
     try {
-      for (Element element : env.getElementsAnnotatedWith(Module.class)) {
+      if (!env.processingOver()) {
+        // Storing module names for later retrieval as the element instance is invalidated across
+        // passes.
+        for (Element e : env.getElementsAnnotatedWith(Module.class)) {
+          delayedModuleNames.add(e.asType().toString());
+        }
+        return true;
+      }
+
+      Set<Element> modules = new LinkedHashSet<Element>();
+      for (String moduleName : delayedModuleNames) {
+        modules.add(processingEnv.getElementUtils().getTypeElement(moduleName));
+      }
+
+      for (Element element : modules) {
         Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, element);
         if (!annotation.get("complete").equals(Boolean.TRUE)) {
           continue;
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 594e485..84cf40a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -15,14 +15,20 @@
  */
 package dagger.internal.codegen;
 
-import dagger.internal.Binding;
-import dagger.internal.Linker;
-import dagger.internal.StaticInjection;
+import static dagger.internal.plugins.loading.ClassloadingPlugin.INJECT_ADAPTER_SUFFIX;
+import static dagger.internal.plugins.loading.ClassloadingPlugin.STATIC_INJECTION_SUFFIX;
+import static java.lang.reflect.Modifier.FINAL;
+import static java.lang.reflect.Modifier.PRIVATE;
+import static java.lang.reflect.Modifier.PUBLIC;
+
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
+
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
@@ -36,15 +42,14 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
-import static dagger.internal.plugins.loading.ClassloadingPlugin.INJECT_ADAPTER_SUFFIX;
-import static dagger.internal.plugins.loading.ClassloadingPlugin.STATIC_INJECTION_SUFFIX;
-import static java.lang.reflect.Modifier.FINAL;
-import static java.lang.reflect.Modifier.PRIVATE;
-import static java.lang.reflect.Modifier.PUBLIC;
+import dagger.internal.Binding;
+import dagger.internal.Linker;
+import dagger.internal.StaticInjection;
 
 /**
  * Generates an implementation of {@link Binding} that injects the
@@ -53,42 +58,69 @@
 @SupportedAnnotationTypes("javax.inject.Inject")
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class InjectProcessor extends AbstractProcessor {
+  private final Set<String> remainingTypeNames = new LinkedHashSet<String>();
+
   @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
     try {
-      for (InjectedClass injectedClass : getInjectedClasses(env)) {
-        if (injectedClass.constructor != null || !injectedClass.fields.isEmpty()) {
-          writeInjectAdapter(injectedClass.type, injectedClass.constructor, injectedClass.fields);
-        }
-        if (!injectedClass.staticFields.isEmpty()) {
-          writeStaticInjection(injectedClass.type, injectedClass.staticFields);
+      remainingTypeNames.addAll(getInjectedClassNames(env));
+      for (Iterator<String> i = remainingTypeNames.iterator(); i.hasNext();) {
+        InjectedClass injectedClass = getInjectedClass(i.next());
+        // Verify that we have access to all types to be injected on this pass.
+        boolean missingDependentClasses =
+            !allTypesExist(injectedClass.fields)
+            || (injectedClass.constructor != null && !allTypesExist(injectedClass.constructor
+                .getParameters()))
+            || !allTypesExist(injectedClass.staticFields);
+        if (!missingDependentClasses) {
+          writeInjectionsForClass(injectedClass);
+          i.remove();
         }
       }
     } catch (IOException e) {
       error("Code gen failed: %s", e);
     }
+    if (env.processingOver() && !remainingTypeNames.isEmpty()) {
+      error("Could not find injection type required by %s!", remainingTypeNames);
+    }
     return true;
   }
 
-  private Set<InjectedClass> getInjectedClasses(RoundEnvironment env) {
-    // First gather the set of classes that have @Inject-annotated members.
-    Set<TypeElement> injectedTypes = new LinkedHashSet<TypeElement>();
-    for (Element element : env.getElementsAnnotatedWith(Inject.class)) {
-      injectedTypes.add((TypeElement) element.getEnclosingElement());
+  private void writeInjectionsForClass(InjectedClass injectedClass) throws IOException {
+    if (injectedClass.constructor != null || !injectedClass.fields.isEmpty()) {
+      writeInjectAdapter(injectedClass.type, injectedClass.constructor, injectedClass.fields);
     }
-
-    // Next get the InjectedClass for each of those.
-    Set<InjectedClass> result = new LinkedHashSet<InjectedClass>();
-    for (TypeElement type : injectedTypes) {
-      result.add(getInjectedClass(type));
+    if (!injectedClass.staticFields.isEmpty()) {
+      writeStaticInjection(injectedClass.type, injectedClass.staticFields);
     }
-
-    return result;
   }
 
   /**
-   * @param type a type with an @Inject-annotated member.
+   * Return true if all element types are currently available in this code
+   * generation pass. Unavailable types will be of kind {@link TypeKind#ERROR}.
    */
-  private InjectedClass getInjectedClass(TypeElement type) {
+  private boolean allTypesExist(Collection<? extends Element> elements) {
+    for (Element element : elements) {
+      if (element.asType().getKind() == TypeKind.ERROR) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  private Set<String> getInjectedClassNames(RoundEnvironment env) {
+    // First gather the set of classes that have @Inject-annotated members.
+    Set<String> injectedTypeNames = new LinkedHashSet<String>();
+    for (Element element : env.getElementsAnnotatedWith(Inject.class)) {
+      injectedTypeNames.add(element.getEnclosingElement().asType().toString());
+    }
+    return injectedTypeNames;
+  }
+
+  /**
+   * @param injectedClassName the name of a class with an @Inject-annotated member.
+   */
+  private InjectedClass getInjectedClass(String injectedClassName) {
+    TypeElement type = processingEnv.getElementUtils().getTypeElement(injectedClassName);
     boolean isAbstract = type.getModifiers().contains(Modifier.ABSTRACT);
     List<Element> staticFields = new ArrayList<Element>();
     ExecutableElement constructor = null;
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 04cc804..73ea3ed 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -15,21 +15,24 @@
  */
 package dagger.internal.codegen;
 
-import dagger.Module;
-import dagger.Provides;
-import dagger.internal.Binding;
-import dagger.internal.Linker;
-import dagger.internal.ModuleAdapter;
-import dagger.internal.SetBinding;
+import static dagger.internal.plugins.loading.ClassloadingPlugin.MODULE_ADAPTER_SUFFIX;
+import static java.lang.reflect.Modifier.FINAL;
+import static java.lang.reflect.Modifier.PRIVATE;
+import static java.lang.reflect.Modifier.PROTECTED;
+import static java.lang.reflect.Modifier.PUBLIC;
+import static java.lang.reflect.Modifier.STATIC;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
+
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
@@ -46,12 +49,12 @@
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
-import static dagger.internal.plugins.loading.ClassloadingPlugin.MODULE_ADAPTER_SUFFIX;
-import static java.lang.reflect.Modifier.FINAL;
-import static java.lang.reflect.Modifier.PRIVATE;
-import static java.lang.reflect.Modifier.PROTECTED;
-import static java.lang.reflect.Modifier.PUBLIC;
-import static java.lang.reflect.Modifier.STATIC;
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.Binding;
+import dagger.internal.Linker;
+import dagger.internal.ModuleAdapter;
+import dagger.internal.SetBinding;
 
 /**
  * Generates an implementation of {@link ModuleAdapter} that includes a binding
@@ -60,33 +63,49 @@
 @SupportedAnnotationTypes("dagger.Provides")
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class ProvidesProcessor extends AbstractProcessor {
+  private final LinkedHashMap<String, List<ExecutableElement>> remainingTypes =
+      new LinkedHashMap<String, List<ExecutableElement>>();
   private static final String BINDINGS_MAP = CodeGen.parameterizedType(
       Map.class, String.class.getName(), Binding.class.getName() + "<?>");
 
   // TODO: include @Provides methods from the superclass
-
   @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
     try {
-      Map<TypeElement, List<ExecutableElement>> providerMethods = providerMethodsByClass(env);
-      for (Map.Entry<TypeElement, List<ExecutableElement>> module : providerMethods.entrySet()) {
-        writeModuleAdapter(module.getKey(), module.getValue());
+      remainingTypes.putAll(providerMethodsByClass(env));
+      for (Iterator<String> i = remainingTypes.keySet().iterator(); i.hasNext();) {
+        String typeName = i.next();
+        TypeElement type = processingEnv.getElementUtils().getTypeElement(typeName);
+        List<ExecutableElement> providesTypes = remainingTypes.get(typeName);
+        try {
+          // Attempt to get the annotation. If types are missing, this will throw
+          // IllegalStateException.
+          Map<String, Object> parsedAnnotation = CodeGen.getAnnotation(Module.class, type);
+          writeModuleAdapter(type, parsedAnnotation, providesTypes);
+          i.remove();
+        } catch (IllegalStateException e) {
+          // a dependent type was not defined, we'll catch it on another pass
+        }
       }
     } catch (IOException e) {
       error("Code gen failed: " + e);
     }
+    if (env.processingOver() && remainingTypes.size() > 0) {
+      error("Could not find types required by provides methods for %s", remainingTypes.keySet()
+          .toString());
+    }
     return true;
   }
 
-  private void error(String message) {
-    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message);
+  private void error(String format, Object... args) {
+    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, String.format(format, args));
   }
 
   /**
    * Returns a map containing all {@code @Provides} methods, indexed by class.
    */
-  private Map<TypeElement, List<ExecutableElement>> providerMethodsByClass(RoundEnvironment env) {
-    Map<TypeElement, List<ExecutableElement>> result
-        = new HashMap<TypeElement, List<ExecutableElement>>();
+  private Map<String, List<ExecutableElement>> providerMethodsByClass(RoundEnvironment env) {
+    Map<String, List<ExecutableElement>> result
+        = new HashMap<String, List<ExecutableElement>>();
     for (Element providerMethod : providesMethods(env)) {
       TypeElement type = (TypeElement) providerMethod.getEnclosingElement();
       Set<Modifier> typeModifiers = type.getModifiers();
@@ -113,7 +132,7 @@
       List<ExecutableElement> methods = result.get(type);
       if (methods == null) {
         methods = new ArrayList<ExecutableElement>();
-        result.put(type, methods);
+        result.put(type.toString(), methods);
       }
       methods.add((ExecutableElement) providerMethod);
     }
@@ -131,9 +150,8 @@
    * Write a companion class for {@code type} that implements {@link
    * ModuleAdapter} to expose its provider methods.
    */
-  private void writeModuleAdapter(TypeElement type, List<ExecutableElement> providerMethods)
-      throws IOException {
-    Map<String, Object> module = CodeGen.getAnnotation(Module.class, type);
+  private void writeModuleAdapter(TypeElement type, Map<String, Object> module,
+      List<ExecutableElement> providerMethods) throws IOException {
     if (module == null) {
       error(type + " has @Provides methods but no @Module annotation");
       return;
/Fim/
diff --git a/website/index.html b/website/index.html
index c82aeb9..d8957e5 100644
--- a/website/index.html
+++ b/website/index.html
@@ -297,11 +297,11 @@
 }
 </pre>
 
-<p>To get the most out of compile-time validation, create a module that includes all of your application's modules as children. The annotation processor will detect problems across the modules and report them.</p>
+<p>To get the most out of compile-time validation, create a module that includes all of your application's modules. The annotation processor will detect problems across the modules and report them.</p>
 
 <pre class="prettyprint">
 @Module(
-    children = {
+    includes = {
         DripCoffeeModule.class,
         ExecutorModule.class
     }
@@ -332,7 +332,7 @@
   }
 
   @Module(
-      children = DripCoffeeModule.class,
+      includes = DripCoffeeModule.class,
       entryPoints = CoffeeMakerTest.class,
       overrides = true
   )
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
index 1a24d06..8d8070b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
@@ -53,6 +53,9 @@
       sourceBinding.getDependencies(dependencies, dependencies);
       for (Binding<?> targetBinding : dependencies) {
         String targetName = namesIndex.get(targetBinding);
+        if (targetName == null) {
+          targetName = "Unbound:" + targetBinding.provideKey;
+        }
         writer.edge(sourceName, targetName);
       }
     }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 84cf40a..03de771 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -15,12 +15,10 @@
  */
 package dagger.internal.codegen;
 
-import static dagger.internal.plugins.loading.ClassloadingPlugin.INJECT_ADAPTER_SUFFIX;
-import static dagger.internal.plugins.loading.ClassloadingPlugin.STATIC_INJECTION_SUFFIX;
-import static java.lang.reflect.Modifier.FINAL;
-import static java.lang.reflect.Modifier.PRIVATE;
-import static java.lang.reflect.Modifier.PUBLIC;
 
+import dagger.internal.Binding;
+import dagger.internal.Linker;
+import dagger.internal.StaticInjection;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -28,7 +26,6 @@
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
-
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
@@ -47,9 +44,11 @@
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
-import dagger.internal.Binding;
-import dagger.internal.Linker;
-import dagger.internal.StaticInjection;
+import static dagger.internal.plugins.loading.ClassloadingPlugin.INJECT_ADAPTER_SUFFIX;
+import static dagger.internal.plugins.loading.ClassloadingPlugin.STATIC_INJECTION_SUFFIX;
+import static java.lang.reflect.Modifier.FINAL;
+import static java.lang.reflect.Modifier.PRIVATE;
+import static java.lang.reflect.Modifier.PUBLIC;
 
 /**
  * Generates an implementation of {@link Binding} that injects the
@@ -171,7 +170,12 @@
       }
       ExecutableElement constructor = (ExecutableElement) element;
       if (constructor.getParameters().isEmpty()) {
-        return constructor;
+        Set<Modifier> modifiers = constructor.getModifiers();
+        if (modifiers.contains(Modifier.PRIVATE) || modifiers.contains(Modifier.PROTECTED)) {
+          return null;
+        } else {
+          return constructor;
+        }
       }
     }
     return null;
/Fim/
diff --git a/README.md b/README.md
index 1ba30bb..9f9d033 100644
--- a/README.md
+++ b/README.md
@@ -16,8 +16,7 @@
 
 In a Maven project, one would include the runtime in the dependencies section
 of your `pom.xml` (replacing `${dagger.version}` with the appropriate current
-release), and the `dagger-compiler` artifact as a dependency of the compiler
-plugin:
+release), and the `dagger-compiler` artifact as an "optional" dependency:
 
 ```xml
 <dependencies>
@@ -26,22 +25,13 @@
     <artifactId>dagger</artifactId>
     <version>${dagger.version}</version>
   </dependency>
+  <dependency>
+    <groupId>com.squareup</groupId>
+    <artifactId>dagger-compiler</artifactId>
+    <version>${dagger.version}</version>
+    <optional>true</optional>
+  </dependency>
 </dependencies>
-
-<build>
-  <plugins>
-    <plugin>
-      <artifactId>maven-compiler-plugin</artifactId>
-      <dependencies>
-        <dependency>
-          <groupId>com.squareup</groupId>
-          <artifactId>dagger-compiler</artifactId>
-          <version>${dagger.version}</version>
-        </dependency>
-      </dependencies>
-    </plugin>
-  </plugins>
-</build>
 ```
 
 You can also find downloadable .jars on the [GitHub download page][2].
/Fim/
diff --git a/compiler/src/it/default-package-injected-type/pom.xml b/compiler/src/it/default-package-injected-type/pom.xml
index 88110a4..a0f1ea2 100644
--- a/compiler/src/it/default-package-injected-type/pom.xml
+++ b/compiler/src/it/default-package-injected-type/pom.xml
@@ -33,7 +33,7 @@
       <groupId>com.squareup</groupId>
       <artifactId>dagger-compiler</artifactId>
       <version>${project.version}</version>
-      <scope>provided</scope>
+      <optional>true</optional>
     </dependency>
   </dependencies>
   <build>
/Fim/
diff --git a/compiler/src/it/extension-graph/pom.xml b/compiler/src/it/extension-graph/pom.xml
index e3327b5..ddd9b44 100644
--- a/compiler/src/it/extension-graph/pom.xml
+++ b/compiler/src/it/extension-graph/pom.xml
@@ -35,7 +35,7 @@
       <groupId>com.squareup</groupId>
       <artifactId>dagger-compiler</artifactId>
       <version>${project.version}</version>
-      <scope>provided</scope>
+      <optional>true</optional>
     </dependency>
   </dependencies>
   <build>
/Fim/
diff --git a/compiler/src/it/missing-at-inject-constructor/pom.xml b/compiler/src/it/missing-at-inject-constructor/pom.xml
index b0def46..6e15355 100644
--- a/compiler/src/it/missing-at-inject-constructor/pom.xml
+++ b/compiler/src/it/missing-at-inject-constructor/pom.xml
@@ -35,7 +35,7 @@
       <groupId>com.squareup</groupId>
       <artifactId>dagger-compiler</artifactId>
       <version>${project.version}</version>
-      <scope>provided</scope>
+      <optional>true</optional>
     </dependency>
   </dependencies>
   <build>
/Fim/
diff --git a/compiler/src/it/same-provides-method-name/pom.xml b/compiler/src/it/same-provides-method-name/pom.xml
index abbe33d..7a21a8b 100644
--- a/compiler/src/it/same-provides-method-name/pom.xml
+++ b/compiler/src/it/same-provides-method-name/pom.xml
@@ -35,7 +35,7 @@
       <groupId>com.squareup</groupId>
       <artifactId>dagger-compiler</artifactId>
       <version>${project.version}</version>
-      <scope>provided</scope>
+      <optional>true</optional>
     </dependency>
   </dependencies>
   <build>
/Fim/
diff --git a/compiler/src/it/simple-missing-dependency-failure/pom.xml b/compiler/src/it/simple-missing-dependency-failure/pom.xml
index 35e3d5d..92d27e8 100644
--- a/compiler/src/it/simple-missing-dependency-failure/pom.xml
+++ b/compiler/src/it/simple-missing-dependency-failure/pom.xml
@@ -35,7 +35,7 @@
       <groupId>com.squareup</groupId>
       <artifactId>dagger-compiler</artifactId>
       <version>${project.version}</version>
-      <scope>provided</scope>
+      <optional>true</optional>
     </dependency>
   </dependencies>
   <build>
/Fim/
diff --git a/compiler/src/it/uninjectable-supertype/pom.xml b/compiler/src/it/uninjectable-supertype/pom.xml
index ad161b5..a1440c6 100644
--- a/compiler/src/it/uninjectable-supertype/pom.xml
+++ b/compiler/src/it/uninjectable-supertype/pom.xml
@@ -35,7 +35,7 @@
       <groupId>com.squareup</groupId>
       <artifactId>dagger-compiler</artifactId>
       <version>${project.version}</version>
-      <scope>provided</scope>
+      <optional>true</optional>
     </dependency>
   </dependencies>
   <build>
/Fim/
diff --git a/example/pom.xml b/example/pom.xml
index 1a63ca3..4c1dc5a 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -34,21 +34,11 @@
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <dependencies>
-          <dependency>
-            <groupId>${project.groupId}</groupId>
-            <artifactId>dagger-compiler</artifactId>
-            <version>${project.version}</version>
-          </dependency>
-        </dependencies>
-      </plugin>
-    </plugins>
-  </build>
 </project>
/Fim/
diff --git a/compiler/src/it/multiple-provides-methods/pom.xml b/compiler/src/it/multiple-provides-methods/pom.xml
new file mode 100644
index 0000000..a796c6e
--- /dev/null
+++ b/compiler/src/it/multiple-provides-methods/pom.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2013 Square, Inc.
+ Copyright (C) 2013 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.squareup.dagger.tests</groupId>
+  <artifactId>multiple-provides-methods</artifactId>
+  <version>@dagger.version@</version>
+  <packaging>jar</packaging>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/multiple-provides-methods/src/main/java/test/TestApp.java b/compiler/src/it/multiple-provides-methods/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..d5f0771
--- /dev/null
+++ b/compiler/src/it/multiple-provides-methods/src/main/java/test/TestApp.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Inject;
+
+class TestApp {
+  static class NotInjectable {
+  }
+
+  static class InjectableSubclass extends NotInjectable {
+    @Inject String string;
+    @Inject Integer integer;
+  }
+
+  @Module(entryPoints = InjectableSubclass.class)
+  static class TestModule {
+    @Provides String string() {
+      return "string";
+    }
+    @Provides Integer integer() {
+      return 5;
+    }
+  }
+}
/Fim/
diff --git a/compiler/src/it/multiple-provides-methods/verify.bsh b/compiler/src/it/multiple-provides-methods/verify.bsh
new file mode 100644
index 0000000..065faf2
--- /dev/null
+++ b/compiler/src/it/multiple-provides-methods/verify.bsh
@@ -0,0 +1,12 @@
+import java.io.File;
+
+File classes = new File(basedir, "target/classes/test/");
+
+File moduleAdapter = new File(classes, "TestApp$TestModule$ModuleAdapter.class");
+if (!moduleAdapter.exists()) throw new Exception("No binding generated for module"); 
+
+File integerBinding = new File(classes, "TestApp$TestModule$ModuleAdapter$IntegerBinding.class");
+if (!integerBinding.exists()) throw new Exception("No binding generated for integer()"); 
+
+File stringBinding = new File(classes, "TestApp$TestModule$ModuleAdapter$StringBinding.class");
+if (!stringBinding.exists()) throw new Exception("No binding generated for string()"); 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 73ea3ed..e8ba3e0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -15,13 +15,12 @@
  */
 package dagger.internal.codegen;
 
-import static dagger.internal.plugins.loading.ClassloadingPlugin.MODULE_ADAPTER_SUFFIX;
-import static java.lang.reflect.Modifier.FINAL;
-import static java.lang.reflect.Modifier.PRIVATE;
-import static java.lang.reflect.Modifier.PROTECTED;
-import static java.lang.reflect.Modifier.PUBLIC;
-import static java.lang.reflect.Modifier.STATIC;
-
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.Binding;
+import dagger.internal.Linker;
+import dagger.internal.ModuleAdapter;
+import dagger.internal.SetBinding;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -32,7 +31,6 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
-
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
@@ -49,12 +47,12 @@
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
-import dagger.Module;
-import dagger.Provides;
-import dagger.internal.Binding;
-import dagger.internal.Linker;
-import dagger.internal.ModuleAdapter;
-import dagger.internal.SetBinding;
+import static dagger.internal.plugins.loading.ClassloadingPlugin.MODULE_ADAPTER_SUFFIX;
+import static java.lang.reflect.Modifier.FINAL;
+import static java.lang.reflect.Modifier.PRIVATE;
+import static java.lang.reflect.Modifier.PROTECTED;
+import static java.lang.reflect.Modifier.PUBLIC;
+import static java.lang.reflect.Modifier.STATIC;
 
 /**
  * Generates an implementation of {@link ModuleAdapter} that includes a binding
@@ -129,7 +127,7 @@
         continue;
       }
 
-      List<ExecutableElement> methods = result.get(type);
+      List<ExecutableElement> methods = result.get(type.toString());
       if (methods == null) {
         methods = new ArrayList<ExecutableElement>();
         result.put(type.toString(), methods);
/Fim/
diff --git a/example/pom.xml b/example/pom.xml
index 4c1dc5a..c6cd863 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -41,4 +41,16 @@
       <optional>true</optional>
     </dependency>
   </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration>
+          <compilerArgument>-Xlint:all</compilerArgument>
+          <showWarnings>true</showWarnings>
+          <showDeprecation>true</showDeprecation>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
/Fim/
diff --git a/pom.xml b/pom.xml
index 3bc8ecf..d9b59a8 100644
--- a/pom.xml
+++ b/pom.xml
@@ -120,6 +120,9 @@
         <configuration>
           <source>${java.version}</source>
           <target>${java.version}</target>
+          <compilerArgument>-Xlint:all</compilerArgument>
+          <showWarnings>true</showWarnings>
+          <showDeprecation>true</showDeprecation>
         </configuration>
       </plugin>
 
/Fim/
diff --git a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
index e1adf93..758f14b 100644
--- a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
+++ b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
@@ -24,6 +24,7 @@
 import java.io.OutputStreamWriter;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -88,8 +89,8 @@
     String className = moduleName.contains(".")
         ? moduleName
         : packageName + "." + moduleName;
-    out.addPackage(packageName);
-    out.addImport(Module.class);
+    out.emitPackage(packageName);
+    out.emitImports(Arrays.asList(Module.class.getName()));
 
     List<String> classLiterals = namesToClassLiterals(nameReferences);
     Collections.sort(classLiterals);
@@ -97,7 +98,7 @@
     attributes.put("entryPoints", classLiterals.toArray());
     attributes.put("complete", "false");
 
-    out.annotation(Module.class, attributes);
+    out.emitAnnotation(Module.class, attributes);
     out.beginType(className, "class", Modifier.PUBLIC | Modifier.FINAL);
     out.endType();
   }
/Fim/
diff --git a/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java b/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
index bdc1673..e7de2ac 100644
--- a/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
+++ b/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
@@ -31,8 +31,8 @@
 import static org.junit.Assert.fail;
 
 public final class ModuleGeneratorTest {
-  private ModuleGenerator generator = new ModuleGenerator();
-  private StringWriter stringWriter = new StringWriter();
+  private final ModuleGenerator generator = new ModuleGenerator();
+  private final StringWriter stringWriter = new StringWriter();
 
   @Test public void packageName() throws Exception {
     Document document = document(""
@@ -138,6 +138,7 @@
     assertCode(""
         + "package com.squareup.badhorse;\n"
         + "import dagger.Module;\n"
+        + "\n"
         + "@Module(\n"
         + "  entryPoints = {\n"
         + "    com.squareup.badhorse.LeagueOfEvilActivity.class,\n"
@@ -157,6 +158,7 @@
     assertCode(""
         + "package com.squareup.badhorse;\n"
         + "import dagger.Module;\n"
+        + "\n"
         + "@Module(\n"
         + "  entryPoints = {\n"
         + "  },\n"
/Fim/
diff --git a/compiler/src/it/multiple-provides-methods/verify.bsh b/compiler/src/it/multiple-provides-methods/verify.bsh
index 065faf2..2337e04 100644
--- a/compiler/src/it/multiple-provides-methods/verify.bsh
+++ b/compiler/src/it/multiple-provides-methods/verify.bsh
@@ -5,8 +5,8 @@
 File moduleAdapter = new File(classes, "TestApp$TestModule$ModuleAdapter.class");
 if (!moduleAdapter.exists()) throw new Exception("No binding generated for module"); 
 
-File integerBinding = new File(classes, "TestApp$TestModule$ModuleAdapter$IntegerBinding.class");
+File integerBinding = new File(classes, "TestApp$TestModule$ModuleAdapter$IntegerProvidesAdapter.class");
 if (!integerBinding.exists()) throw new Exception("No binding generated for integer()"); 
 
-File stringBinding = new File(classes, "TestApp$TestModule$ModuleAdapter$StringBinding.class");
+File stringBinding = new File(classes, "TestApp$TestModule$ModuleAdapter$StringProvidesAdapter.class");
 if (!stringBinding.exists()) throw new Exception("No binding generated for string()"); 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java b/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
index d22f12b..21444f6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
@@ -19,8 +19,10 @@
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.AnnotationValueVisitor;
@@ -289,4 +291,13 @@
     return type.getEnclosingElement().getKind() == ElementKind.PACKAGE
         || type.getModifiers().contains(Modifier.STATIC);
   }
+
+  /**
+   * Returns a set comprised of the given items
+   */
+  public static <T> Set<T> setOf(T ... items) {
+    Set<T> set = new LinkedHashSet<T>();
+    set.addAll(Arrays.asList(items));
+    return set;
+  }
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index c2da407..98c2573 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -15,6 +15,11 @@
  */
 package dagger.internal.codegen;
 
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.Binding;
+import dagger.internal.Linker;
+import dagger.internal.SetBinding;
 import java.io.IOException;
 import java.io.Writer;
 import java.util.ArrayList;
@@ -24,7 +29,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
@@ -42,12 +46,6 @@
 import javax.tools.JavaFileManager;
 import javax.tools.StandardLocation;
 
-import dagger.Module;
-import dagger.Provides;
-import dagger.internal.Binding;
-import dagger.internal.Linker;
-import dagger.internal.SetBinding;
-
 /**
  * Performs full graph analysis on a module.
  */
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 8982a4d..5842e9e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -15,7 +15,7 @@
  */
 package dagger.internal.codegen;
 
-
+import dagger.MembersInjector;
 import dagger.internal.Binding;
 import dagger.internal.Linker;
 import dagger.internal.StaticInjection;
@@ -31,6 +31,7 @@
 import javax.annotation.processing.SupportedAnnotationTypes;
 import javax.annotation.processing.SupportedSourceVersion;
 import javax.inject.Inject;
+import javax.inject.Provider;
 import javax.inject.Singleton;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
@@ -44,6 +45,7 @@
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
+import static dagger.internal.codegen.ProcessorJavadocs.binderTypeDocs;
 import static dagger.internal.plugins.loading.ClassloadingPlugin.INJECT_ADAPTER_SUFFIX;
 import static dagger.internal.plugins.loading.ClassloadingPlugin.STATIC_INJECTION_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
@@ -192,131 +194,180 @@
    */
   private void writeInjectAdapter(TypeElement type, ExecutableElement constructor,
       List<Element> fields) throws IOException {
-    String typeName = type.getQualifiedName().toString();
+    String packageName = CodeGen.getPackage(type).getQualifiedName().toString();
+    String strippedTypeName = strippedTypeName(type.getQualifiedName().toString(), packageName);
     TypeMirror supertype = CodeGen.getApplicationSupertype(type);
     String adapterName = CodeGen.adapterName(type, INJECT_ADAPTER_SUFFIX);
-    JavaFileObject sourceFile = processingEnv.getFiler()
-        .createSourceFile(adapterName, type);
+    JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(adapterName, type);
     JavaWriter writer = new JavaWriter(sourceFile.openWriter());
+    boolean isAbstract = type.getModifiers().contains(Modifier.ABSTRACT);
+    boolean injectMembers = !fields.isEmpty() || supertype != null;
+    boolean disambiguateFields = !fields.isEmpty()
+        && (constructor != null)
+        && !constructor.getParameters().isEmpty();
+    boolean dependent = injectMembers
+        || ((constructor != null) && !constructor.getParameters().isEmpty());
 
-    writer.addPackage(CodeGen.getPackage(type).getQualifiedName().toString());
-    writer.addImport(Binding.class);
-    writer.addImport(Linker.class);
-    writer.addImport(Set.class);
+    writer.emitEndOfLineComment(ProcessorJavadocs.GENERATED_BY_DAGGER);
+    writer.emitPackage(packageName);
+    writer.emitEmptyLine();
+    writer.emitImports(getImports(dependent, injectMembers, constructor != null));
 
-    writer.beginType(adapterName, "class", FINAL,
-        CodeGen.parameterizedType(Binding.class, typeName));
+    writer.emitEmptyLine();
+    writer.emitJavadoc(binderTypeDocs(strippedTypeName, isAbstract, injectMembers, dependent));
+    writer.beginType(adapterName, "class", PUBLIC | FINAL,
+        CodeGen.parameterizedType(Binding.class, strippedTypeName),
+        interfaces(strippedTypeName, injectMembers, constructor != null));
 
     if (constructor != null) {
-      List<? extends VariableElement> parameters = constructor.getParameters();
-      for (int p = 0; p < parameters.size(); p++) {
-        TypeMirror parameterType = parameters.get(p).asType();
-        writer.field(CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(parameterType)),
-            constructorParameterName(p), PRIVATE);
+      for (VariableElement parameter : constructor.getParameters()) {
+        writer.emitField(CodeGen.parameterizedType(Binding.class,
+            CodeGen.typeToString(parameter.asType())),
+            parameterName(disambiguateFields, parameter), PRIVATE);
       }
     }
-    for (int f = 0; f < fields.size(); f++) {
-      TypeMirror fieldType = fields.get(f).asType();
-      writer.field(CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(fieldType)),
-          fieldName(f), PRIVATE);
+    for (Element field : fields) {
+      writer.emitField(CodeGen.parameterizedType(Binding.class,
+          CodeGen.typeToString(field.asType())),
+          fieldName(disambiguateFields, field), PRIVATE);
     }
     if (supertype != null) {
-      writer.field(CodeGen.parameterizedType(Binding.class,
+      writer.emitField(CodeGen.parameterizedType(Binding.class,
           CodeGen.rawTypeToString(supertype, '.')), "supertype", PRIVATE);
     }
 
+    writer.emitEmptyLine();
     writer.beginMethod(null, adapterName, PUBLIC);
     String key = (constructor != null)
         ? JavaWriter.stringLiteral(GeneratorKeys.get(type.asType()))
         : null;
     String membersKey = JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(type.asType()));
     boolean singleton = type.getAnnotation(Singleton.class) != null;
-    writer.statement("super(%s, %s, %s /*singleton*/, %s.class)",
-        key, membersKey, singleton, typeName);
+    writer.emitStatement("super(%s, %s, %s, %s.class)",
+        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"), strippedTypeName);
     writer.endMethod();
-
-    writer.annotation(Override.class);
-    writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
-    if (constructor != null) {
-      for (int p = 0; p < constructor.getParameters().size(); p++) {
-        TypeMirror parameterType = constructor.getParameters().get(p).asType();
-        writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
-            constructorParameterName(p),
-            CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(parameterType)),
-            JavaWriter.stringLiteral(GeneratorKeys.get(constructor.getParameters().get(p))),
-            typeName);
-      }
-    }
-    for (int f = 0; f < fields.size(); f++) {
-      TypeMirror fieldType = fields.get(f).asType();
-      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
-          fieldName(f),
-          CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(fieldType)),
-          JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) fields.get(f))),
-          typeName);
-    }
-    if (supertype != null) {
-      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class, false)",
-          "supertype",
-          CodeGen.parameterizedType(Binding.class, CodeGen.rawTypeToString(supertype, '.')),
-          JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(supertype)),
-          typeName);
-    }
-    writer.endMethod();
-
-    writer.annotation(Override.class);
-    writer.beginMethod(typeName, "get", PUBLIC);
-    if (constructor != null) {
-      StringBuilder newInstance = new StringBuilder();
-      newInstance.append(typeName).append(" result = new ").append(typeName).append('(');
-      for (int p = 0; p < constructor.getParameters().size(); p++) {
-        if (p != 0) {
-          newInstance.append(", ");
+    if (dependent) {
+      writer.emitEmptyLine();
+      writer.emitJavadoc(ProcessorJavadocs.ATTACH_METHOD);
+      writer.emitAnnotation(Override.class);
+      writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
+      if (constructor != null) {
+        for (VariableElement parameter : constructor.getParameters()) {
+          writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
+              parameterName(disambiguateFields, parameter),
+              writer.compressType(CodeGen.parameterizedType(Binding.class,
+                  CodeGen.typeToString(parameter.asType()))),
+              JavaWriter.stringLiteral(GeneratorKeys.get(parameter)),
+              strippedTypeName);
         }
-        newInstance.append(constructorParameterName(p)).append(".get()");
+      }
+      for (Element field : fields) {
+        writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
+            fieldName(disambiguateFields, field),
+            writer.compressType(CodeGen.parameterizedType(Binding.class,
+                CodeGen.typeToString(field.asType()))),
+            JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) field)),
+            strippedTypeName);
+      }
+      if (supertype != null) {
+        writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class, false)",
+            "supertype",
+            writer.compressType(CodeGen.parameterizedType(Binding.class,
+                CodeGen.rawTypeToString(supertype, '.'))),
+            JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(supertype)),
+            strippedTypeName);
+      }
+      writer.endMethod();
+
+      writer.emitEmptyLine();
+      writer.emitJavadoc(ProcessorJavadocs.GET_DEPENDENCIES_METHOD);
+      writer.emitAnnotation(Override.class);
+      String setOfBindings = CodeGen.parameterizedType(Set.class, "Binding<?>");
+      writer.beginMethod("void", "getDependencies", PUBLIC, setOfBindings, "getBindings",
+          setOfBindings, "injectMembersBindings");
+      if (constructor != null) {
+        for (Element parameter : constructor.getParameters()) {
+          writer.emitStatement("getBindings.add(%s)", parameterName(disambiguateFields, parameter));
+        }
+      }
+      for (Element field : fields) {
+        writer.emitStatement("injectMembersBindings.add(%s)", fieldName(disambiguateFields, field));
+      }
+      if (supertype != null) {
+        writer.emitStatement("injectMembersBindings.add(%s)", "supertype");
+      }
+      writer.endMethod();
+    }
+
+    if (constructor != null) {
+      writer.emitEmptyLine();
+      writer.emitJavadoc(ProcessorJavadocs.GET_METHOD, strippedTypeName);
+      writer.emitAnnotation(Override.class);
+      writer.beginMethod(strippedTypeName, "get", PUBLIC);
+      StringBuilder newInstance = new StringBuilder();
+      newInstance.append(strippedTypeName).append(" result = new ");
+      newInstance.append(strippedTypeName).append('(');
+      boolean first = true;
+      for (VariableElement parameter : constructor.getParameters()) {
+        if (!first) newInstance.append(", ");
+        else first = false;
+        newInstance.append(parameterName(disambiguateFields, parameter)).append(".get()");
       }
       newInstance.append(')');
-      writer.statement(newInstance.toString());
-      writer.statement("injectMembers(result)");
-      writer.statement("return result");
-    } else {
-      writer.statement("throw new UnsupportedOperationException()");
-    }
-    writer.endMethod();
-
-    writer.annotation(Override.class);
-    writer.beginMethod("void", "injectMembers", PUBLIC, typeName, "object");
-    for (int f = 0; f < fields.size(); f++) {
-      writer.statement("object.%s = %s.get()",
-          fields.get(f).getSimpleName().toString(),
-          fieldName(f));
-    }
-    if (supertype != null) {
-      writer.statement("supertype.injectMembers(object)");
-    }
-    writer.endMethod();
-
-    writer.annotation(Override.class);
-    String setOfBindings = CodeGen.parameterizedType(Set.class, "Binding<?>");
-    writer.beginMethod("void", "getDependencies", PUBLIC, setOfBindings, "getBindings",
-        setOfBindings, "injectMembersBindings");
-    if (constructor != null) {
-      for (int p = 0; p < constructor.getParameters().size(); p++) {
-        writer.statement("getBindings.add(%s)", constructorParameterName(p));
+      writer.emitStatement(newInstance.toString());
+      if (injectMembers) {
+        writer.emitStatement("injectMembers(result)");
       }
+      writer.emitStatement("return result");
+      writer.endMethod();
     }
-    for (int f = 0; f < fields.size(); f++) {
-      writer.statement("injectMembersBindings.add(%s)", fieldName(f));
+
+    if (injectMembers) {
+      writer.emitEmptyLine();
+      writer.emitJavadoc(ProcessorJavadocs.MEMBERS_INJECT_METHOD, strippedTypeName);
+      writer.emitAnnotation(Override.class);
+      writer.beginMethod("void", "injectMembers", PUBLIC, strippedTypeName, "object");
+      for (Element field : fields) {
+        writer.emitStatement("object.%s = %s.get()", field.getSimpleName(),
+            fieldName(disambiguateFields, field));
+      }
+      if (supertype != null) {
+        writer.emitStatement("supertype.injectMembers(object)");
+      }
+      writer.endMethod();
     }
-    if (supertype != null) {
-      writer.statement("injectMembersBindings.add(%s)", "supertype");
-    }
-    writer.endMethod();
 
     writer.endType();
     writer.close();
   }
 
+  private String[] interfaces(String strippedTypeName, boolean hasFields, boolean isProvider) {
+    List<String> interfaces = new ArrayList<String>();
+    if (isProvider) {
+      interfaces.add(CodeGen.parameterizedType(Provider.class, strippedTypeName));
+    }
+    if (hasFields) {
+      interfaces.add(CodeGen.parameterizedType(MembersInjector.class, strippedTypeName));
+    }
+    return interfaces.toArray(new String[0]);
+  }
+
+  private Set<String> getImports(boolean dependent, boolean injectMembers, boolean isProvider) {
+    Set<String> imports = new LinkedHashSet<String>();
+    imports.add(Binding.class.getName());
+    if (dependent) {
+      imports.add(Linker.class.getName());
+      imports.add(Set.class.getName());
+    }
+    if (injectMembers) imports.add(MembersInjector.class.getName());
+    if (isProvider) imports.add(Provider.class.getName());
+    return imports;
+  }
+
+  private String strippedTypeName(String type, String packageName) {
+    return type.substring(packageName.isEmpty() ? 0 : packageName.length() + 1);
+  }
+
   /**
    * Write a companion class for {@code type} that extends {@link StaticInjection}.
    */
@@ -327,38 +378,49 @@
         .createSourceFile(adapterName, type);
     JavaWriter writer = new JavaWriter(sourceFile.openWriter());
 
-    writer.addPackage(CodeGen.getPackage(type).getQualifiedName().toString());
-    writer.addImport(StaticInjection.class);
-    writer.addImport(Binding.class);
-    writer.addImport(Linker.class);
+    writer.emitEndOfLineComment(ProcessorJavadocs.GENERATED_BY_DAGGER);
+    writer.emitPackage(CodeGen.getPackage(type).getQualifiedName().toString());
 
-    writer.beginType(adapterName, "class", PUBLIC | FINAL, StaticInjection.class.getName());
+    writer.emitEmptyLine();
+    writer.emitImports(CodeGen.setOf(
+        StaticInjection.class.getName(),
+        Binding.class.getName(),
+        Linker.class.getName()));
 
-    for (int f = 0; f < fields.size(); f++) {
-      TypeMirror fieldType = fields.get(f).asType();
-      writer.field(CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(fieldType)),
-          fieldName(f), PRIVATE);
+    writer.emitEmptyLine();
+
+    writer.emitJavadoc(ProcessorJavadocs.STATIC_INJECTION_TYPE, type.getSimpleName());
+    writer.beginType(adapterName, "class", PUBLIC | FINAL, StaticInjection.class.getSimpleName());
+
+    for (Element field : fields) {
+      writer.emitField(CodeGen.parameterizedType(Binding.class,
+          CodeGen.typeToString(field.asType())),
+          fieldName(false, field), PRIVATE);
     }
 
-    writer.annotation(Override.class);
+    writer.emitEmptyLine();
+    writer.emitJavadoc(ProcessorJavadocs.ATTACH_METHOD);
+    writer.emitAnnotation(Override.class);
     writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
-    for (int f = 0; f < fields.size(); f++) {
-      TypeMirror fieldType = fields.get(f).asType();
-      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
-          fieldName(f),
-          CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(fieldType)),
-          JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) fields.get(f))),
+    for (Element field : fields) {
+      writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
+          fieldName(false, field),
+          writer.compressType(CodeGen.parameterizedType(Binding.class,
+              CodeGen.typeToString(field.asType()))),
+          JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) field)),
           typeName);
     }
     writer.endMethod();
 
-    writer.annotation(Override.class);
+    writer.emitEmptyLine();
+    writer.emitJavadoc(ProcessorJavadocs.STATIC_INJECT_METHOD);
+    writer.emitAnnotation(Override.class);
     writer.beginMethod("void", "inject", PUBLIC);
-    for (int f = 0; f < fields.size(); f++) {
-      writer.statement("%s.%s = %s.get()",
-          typeName,
-          fields.get(f).getSimpleName().toString(),
-          fieldName(f));
+    for (Element field : fields) {
+      writer.emitStatement("%s.%s = %s.get()",
+          writer.compressType(typeName),
+          field.getSimpleName().toString(),
+          fieldName(false, field));
     }
     writer.endMethod();
 
@@ -366,12 +428,12 @@
     writer.close();
   }
 
-  private String fieldName(int index) {
-    return "f" + index;
+  private String fieldName(boolean disambiguateFields, Element field) {
+    return (disambiguateFields ? "field_" : "") + field.getSimpleName().toString();
   }
 
-  private String constructorParameterName(int index) {
-    return "c" + index;
+  private String parameterName(boolean disambiguateFields, Element parameter) {
+    return (disambiguateFields ? "parameter_" : "") + parameter.getSimpleName().toString();
   }
 
   static class InjectedClass {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
index 978f3f7..ed594ff 100644
--- a/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
@@ -21,10 +21,12 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.TreeSet;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -55,7 +57,7 @@
   /**
    * Emit a package declaration.
    */
-  public void addPackage(String packageName) throws IOException {
+  public void emitPackage(String packageName) throws IOException {
     if (this.packagePrefix != null) {
       throw new IllegalStateException();
     }
@@ -70,27 +72,24 @@
   }
 
   /**
-   * Equivalent to {@code addImport(type.getName())}.
+   * Emit an import for each {@code type} in the provided {@code Set}. For
+   * the duration of the file, all references to these classes will be
+   * automatically shortened.
    */
-  public void addImport(Class<?> type) throws IOException {
-    addImport(type.getName());
-  }
-
-  /**
-   * Emit an import for {@code type}. For the duration of the file, all
-   * references to this class will be automatically shortened.
-   */
-  public void addImport(String type) throws IOException {
-    Matcher matcher = TYPE_PATTERN.matcher(type);
-    if (!matcher.matches()) {
-      throw new IllegalArgumentException(type);
+  public void emitImports(Collection<String> types) throws IOException {
+    for (String type : new TreeSet<String>(types)) {
+      Matcher matcher = TYPE_PATTERN.matcher(type);
+      if (!matcher.matches()) {
+        throw new IllegalArgumentException(type);
+      }
+      if (importedTypes.put(type, matcher.group(1)) != null) {
+        throw new IllegalArgumentException(type);
+      }
+      out.write("import ");
+      out.write(type);
+      out.write(";\n");
     }
-    if (importedTypes.put(type, matcher.group(1)) != null) {
-      throw new IllegalArgumentException(type);
-    }
-    out.write("import ");
-    out.write(type);
-    out.write(";\n");
+    emitEmptyLine();
   }
 
   /**
@@ -98,7 +97,12 @@
    * java.util.List<java.lang.String>}, shorting it with imports if
    * possible.
    */
-  private void type(String type) throws IOException {
+  private void emitType(String type) throws IOException {
+    out.write(compressType(type));
+  }
+
+  String compressType(String type) {
+    StringBuffer sb = new StringBuffer();
     if (this.packagePrefix == null) {
       throw new IllegalStateException();
     }
@@ -110,7 +114,7 @@
 
       // copy non-matching characters like "<"
       int typeStart = found ? m.start() : type.length();
-      out.write(type, pos, typeStart - pos);
+      sb.append(type, pos, typeStart);
 
       if (!found) {
         break;
@@ -120,17 +124,31 @@
       String name = m.group(0);
       String imported;
       if ((imported = importedTypes.get(name)) != null) {
-        out.write(imported);
-      } else if (name.startsWith(packagePrefix)
-          && name.indexOf('.', packagePrefix.length()) == -1) {
-        out.write(name.substring(packagePrefix.length()));
+        sb.append(imported);
+      } else if (isClassInPackage(name)) {
+        sb.append(name.substring(packagePrefix.length()));
       } else if (name.startsWith("java.lang.")) {
-        out.write(name.substring("java.lang.".length()));
+        sb.append(name.substring("java.lang.".length()));
       } else {
-        out.write(name);
+        sb.append(name);
       }
       pos = m.end();
     }
+    String result = sb.toString();
+    return result;
+  }
+
+  private boolean isClassInPackage(String name) {
+    if (name.startsWith(packagePrefix)) {
+      if (name.indexOf('.', packagePrefix.length()) == -1) {
+        return true;
+      }
+      int index = name.indexOf('.');
+      if (name.substring(index + 1, index + 2).matches("[A-Z]")) {
+        return true;
+      }
+    }
+    return false;
   }
 
   /**
@@ -151,15 +169,13 @@
   public void beginType(String type, String kind, int modifiers,
       String extendsType, String... implementsTypes) throws IOException {
     indent();
-    modifiers(modifiers);
+    out.write(modifiers(modifiers).toString());
     out.write(kind);
     out.write(" ");
-    type(type);
+    emitType(type);
     if (extendsType != null) {
-      out.write("\n");
-      indent();
-      out.write("    extends ");
-      type(extendsType);
+      out.write(" extends ");
+      emitType(extendsType);
     }
     if (implementsTypes.length > 0) {
       out.write("\n");
@@ -169,7 +185,7 @@
         if (i != 0) {
           out.write(", ");
         }
-        type(implementsTypes[i]);
+        emitType(implementsTypes[i]);
       }
     }
     out.write(" {\n");
@@ -188,15 +204,15 @@
   /**
    * Emits a field declaration.
    */
-  public void field(String type, String name, int modifiers) throws IOException {
+  public void emitField(String type, String name, int modifiers) throws IOException {
     field(type, name, modifiers, null);
   }
 
   public void field(String type, String name, int modifiers, String initialValue)
       throws IOException {
     indent();
-    modifiers(modifiers);
-    type(type);
+    out.write(modifiers(modifiers).toString());
+    emitType(type);
     out.write(" ");
     out.write(name);
 
@@ -218,22 +234,22 @@
   public void beginMethod(String returnType, String name, int modifiers, String... parameters)
       throws IOException {
     indent();
-    modifiers(modifiers);
+    out.write(modifiers(modifiers).toString());
     if (returnType != null) {
-      type(returnType);
+      emitType(returnType);
       out.write(" ");
       out.write(name);
     } else {
-      type(name);
+      emitType(name);
     }
     out.write("(");
     for (int p = 0; p < parameters.length;) {
       if (p != 0) {
         out.write(", ");
       }
-      type(parameters[p++]);
+      emitType(parameters[p++]);
       out.write(" ");
-      type(parameters[p++]);
+      emitType(parameters[p++]);
     }
     out.write(")");
     if ((modifiers & Modifier.ABSTRACT) != 0) {
@@ -246,25 +262,55 @@
   }
 
   /**
+   * Emits some javadoc comments with line separated by {@code \n}.
+   */
+  public void emitJavadoc(String javadoc, Object ... params) throws IOException {
+    String formatted = (params.length == 0) ? javadoc : String.format(javadoc, params);
+    indent();
+    out.write("/**\n");
+    for (String line : formatted.split("\n")) {
+      indent();
+      out.write(" * ");
+      out.write(line);
+      out.write("\n");
+    }
+    indent();
+    out.write(" */\n");
+  }
+
+  /**
+   * Emits some javadoc comments.
+   */
+  public void emitEndOfLineComment(String comment) throws IOException {
+    out.write("// ");
+    out.write(comment);
+    out.write("\n");
+  }
+
+  public void emitEmptyLine() throws IOException {
+    out.write("\n");
+  }
+
+  /**
    * Equivalent to {@code annotation(annotation, emptyMap())}.
    */
-  public void annotation(String annotation) throws IOException {
-    annotation(annotation, Collections.<String, Object>emptyMap());
+  public void emitAnnotation(String annotation) throws IOException {
+    emitAnnotation(annotation, Collections.<String, Object>emptyMap());
   }
 
   /**
    * Equivalent to {@code annotation(annotationType.getName(), emptyMap())}.
    */
-  public void annotation(Class<? extends Annotation> annotationType) throws IOException {
-    annotation(annotationType.getName(), Collections.<String, Object>emptyMap());
+  public void emitAnnotation(Class<? extends Annotation> annotationType) throws IOException {
+    emitAnnotation(annotationType.getName(), Collections.<String, Object>emptyMap());
   }
 
   /**
    * Equivalent to {@code annotation(annotationType.getName(), attributes)}.
    */
-  public void annotation(Class<? extends Annotation> annotationType, Map<String, ?> attributes)
+  public void emitAnnotation(Class<? extends Annotation> annotationType, Map<String, ?> attributes)
       throws IOException {
-    annotation(annotationType.getName(), attributes);
+    emitAnnotation(annotationType.getName(), attributes);
   }
 
   /**
@@ -274,10 +320,10 @@
    *     Values are encoded using Object.toString(); use {@link #stringLiteral}
    *     for String values. Object arrays are written one element per line.
    */
-  public void annotation(String annotation, Map<String, ?> attributes) throws IOException {
+  public void emitAnnotation(String annotation, Map<String, ?> attributes) throws IOException {
     indent();
     out.write("@");
-    type(annotation);
+    emitType(annotation);
     if (!attributes.isEmpty()) {
       out.write("(");
       pushScope(Scope.ANNOTATION_ATTRIBUTE);
@@ -293,7 +339,7 @@
         out.write(entry.getKey());
         out.write(" = ");
         Object value = entry.getValue();
-        annotationValue(value);
+        emitAnnotationValue(value);
       }
       popScope(Scope.ANNOTATION_ATTRIBUTE);
       out.write("\n");
@@ -307,7 +353,7 @@
    * Writes a single annotation value. If the value is an array, each element in
    * the array will be written to its own line.
    */
-  private void annotationValue(Object value) throws IOException {
+  private void emitAnnotationValue(Object value) throws IOException {
     if (value instanceof Object[]) {
       out.write("{");
       boolean firstValue = true;
@@ -335,7 +381,7 @@
    * @param pattern a code pattern like "int i = %s". Shouldn't contain a
    * trailing semicolon or newline character.
    */
-  public void statement(String pattern, Object... args) throws IOException {
+  public void emitStatement(String pattern, Object... args) throws IOException {
     checkInMethod();
     indent();
     out.write(String.format(pattern, args));
@@ -446,34 +492,36 @@
   /**
    * Emit modifier names.
    */
-  private void modifiers(int modifiers) throws IOException {
+  static StringBuffer modifiers(int modifiers) {
+    StringBuffer out = new StringBuffer();
     if ((modifiers & Modifier.PUBLIC) != 0) {
-      out.write("public ");
+      out.append("public ");
     }
     if ((modifiers & Modifier.PRIVATE) != 0) {
-      out.write("private ");
+      out.append("private ");
     }
     if ((modifiers & Modifier.PROTECTED) != 0) {
-      out.write("protected ");
+      out.append("protected ");
     }
     if ((modifiers & Modifier.STATIC) != 0) {
-      out.write("static ");
+      out.append("static ");
     }
     if ((modifiers & Modifier.FINAL) != 0) {
-      out.write("final ");
+      out.append("final ");
     }
     if ((modifiers & Modifier.ABSTRACT) != 0) {
-      out.write("abstract ");
+      out.append("abstract ");
     }
     if ((modifiers & Modifier.SYNCHRONIZED) != 0) {
-      out.write("synchronized ");
+      out.append("synchronized ");
     }
     if ((modifiers & Modifier.TRANSIENT) != 0) {
-      out.write("transient ");
+      out.append("transient ");
     }
     if ((modifiers & Modifier.VOLATILE) != 0) {
-      out.write("volatile ");
+      out.append("volatile ");
     }
+    return out;
   }
 
   private void indent() throws IOException {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProcessorJavadocs.java b/compiler/src/main/java/dagger/internal/codegen/ProcessorJavadocs.java
new file mode 100644
index 0000000..51bc228
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProcessorJavadocs.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+/**
+ * Utility class providing some commonly used boilerplate between {@code InjectProcessor}
+ * and {@code ProvidesProcessor}.
+ */
+public final class ProcessorJavadocs {
+  static final String GENERATED_BY_DAGGER = "Code generated by dagger-compiler.  Do not edit.";
+  static final String MEMBERS_INJECT_METHOD = ""
+      + "Injects any {@code @Inject} annotated fields in the given instance,\n"
+      + "satisfying the contract for {@code Provider<%s>}.";
+  static final String GET_METHOD = ""
+      + "Returns the fully provisioned instance satisfying the contract for\n"
+      + "{@code Provider<%s>}.";
+  static final String GET_DEPENDENCIES_METHOD = ""
+      + "Used internally obtain dependency information, such as for cyclical\n"
+      + "graph detection.";
+  static final String ATTACH_METHOD = ""
+      + "Used internally to link bindings/providers together at run time\n"
+      + "according to their dependency graph.";
+  static final String STATIC_INJECT_METHOD = ""
+      + "Performs the injections of dependencies into static fields when requested by\n"
+      + "the {@code dagger.ObjectGraph}.";
+  static final String MODULE_TYPE = ""
+      + "A manager of modules and provides adapters allowing for proper linking and\n"
+      + "instance provision of types served by {@code @Provides} methods.";
+  static final String STATIC_INJECTION_TYPE = ""
+      + "A manager for {@code %s}'s injections into static fields.";
+
+  /** Creates an appropriate javadoc depending on aspects of the type in question. */
+  static String binderTypeDocs(String type, boolean abstrakt, boolean members, boolean dependent) {
+    StringBuffer sb = new StringBuffer();
+    sb.append("A {@code Binder<").append(type).append(">} implementation which satisfies\n");
+    sb.append("Dagger's infrastructure requirements including:");
+    if (dependent) {
+      sb.append("\n\n");
+      sb.append("Owning the dependency links between {@code " + type + "} and its\n");
+      sb.append("dependencies.");
+    }
+    if (!abstrakt) {
+      sb.append("\n\n");
+      sb.append("Being a {@code Provider<" + type + ">} and handling creation and\n");
+      sb.append("preparation of object instances.");
+    }
+    if (members) {
+      sb.append("\n\n");
+      sb.append("Being a {@code MembersInjector<" + type + ">} and handling injection\n");
+      sb.append("of annotated fields.");
+    }
+    return sb.toString();
+  }
+
+}
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index e8ba3e0..3378dcd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -35,6 +35,7 @@
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
 import javax.annotation.processing.SupportedSourceVersion;
+import javax.inject.Provider;
 import javax.inject.Singleton;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
@@ -47,6 +48,7 @@
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
+import static dagger.internal.codegen.ProcessorJavadocs.binderTypeDocs;
 import static dagger.internal.plugins.loading.ClassloadingPlugin.MODULE_ADAPTER_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
 import static java.lang.reflect.Modifier.PRIVATE;
@@ -167,14 +169,17 @@
         .createSourceFile(adapterName, type);
     JavaWriter writer = new JavaWriter(sourceFile.openWriter());
 
-    writer.addPackage(CodeGen.getPackage(type).getQualifiedName().toString());
-    writer.addImport(Binding.class);
-    writer.addImport(SetBinding.class);
-    writer.addImport(ModuleAdapter.class);
-    writer.addImport(Map.class);
-    writer.addImport(Linker.class);
+    boolean multibindings = checkForMultibindings(providerMethods);
+    boolean providerMethodDependencies = checkForDependencies(providerMethods);
+
+    writer.emitEndOfLineComment(ProcessorJavadocs.GENERATED_BY_DAGGER);
+    writer.emitPackage(CodeGen.getPackage(type).getQualifiedName().toString());
+    writer.emitEmptyLine();
+    writer.emitImports(getImports(multibindings, providerMethodDependencies));
 
     String typeName = type.getQualifiedName().toString();
+    writer.emitEmptyLine();
+    writer.emitJavadoc(ProcessorJavadocs.MODULE_TYPE);
     writer.beginType(adapterName, "class", PUBLIC | FINAL,
         CodeGen.parameterizedType(ModuleAdapter.class, typeName));
 
@@ -210,12 +215,15 @@
     includesField.append("}");
     writer.field("Class<?>[]", "INCLUDES", PRIVATE | STATIC | FINAL, includesField.toString());
 
+    writer.emitEmptyLine();
     writer.beginMethod(null, adapterName, PUBLIC);
-    writer.statement("super(ENTRY_POINTS, STATIC_INJECTIONS, %s /*overrides*/, "
+    writer.emitStatement("super(ENTRY_POINTS, STATIC_INJECTIONS, %s /*overrides*/, "
         + "INCLUDES, %s /*complete*/)", overrides, complete);
     writer.endMethod();
 
-    writer.annotation(Override.class);
+    writer.emitEmptyLine();
+    writer.emitJavadoc(ProcessorJavadocs.GET_DEPENDENCIES_METHOD);
+    writer.emitAnnotation(Override.class);
     writer.beginMethod("void", "getBindings", PUBLIC, BINDINGS_MAP, "map");
 
     Map<ExecutableElement, String> methodToClassName
@@ -226,13 +234,14 @@
       switch (provides.type()) {
         case UNIQUE: {
           String key = GeneratorKeys.get(providerMethod);
-          writer.statement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
+          writer.emitStatement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
               bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
           break;
         }
         case SET: {
           String key = GeneratorKeys.getElementKey(providerMethod);
-          writer.statement("SetBinding.add(map, %s, new %s(module))", JavaWriter.stringLiteral(key),
+          writer.emitStatement("SetBinding.add(map, %s, new %s(module))",
+              JavaWriter.stringLiteral(key),
               bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
           break;
         }
@@ -242,25 +251,60 @@
     }
     writer.endMethod();
 
-    writer.annotation(Override.class);
+    writer.emitEmptyLine();
+    writer.emitAnnotation(Override.class);
     writer.beginMethod(typeName, "newModule", PROTECTED);
     ExecutableElement noArgsConstructor = CodeGen.getNoArgsConstructor(type);
     if (noArgsConstructor != null && CodeGen.isCallableConstructor(noArgsConstructor)) {
-      writer.statement("return new %s()", typeName);
+      writer.emitStatement("return new %s()", typeName);
     } else {
-      writer.statement("throw new UnsupportedOperationException(%s)",
+      writer.emitStatement("throw new UnsupportedOperationException(%s)",
           JavaWriter.stringLiteral("No no-args constructor on " + type));
     }
     writer.endMethod();
 
     for (ExecutableElement providerMethod : providerMethods) {
-      writeBindingClass(writer, providerMethod, methodToClassName, methodNameToNextId);
+      writeProvidesAdapter(writer, providerMethod, methodToClassName, methodNameToNextId);
     }
 
     writer.endType();
     writer.close();
   }
 
+  private Set<String> getImports(boolean multibindings, boolean dependencies) {
+    Set<String> imports = new LinkedHashSet<String>();
+    imports.add(Binding.class.getName());
+    imports.add(Map.class.getName());
+    imports.add(Provider.class.getName());
+    imports.add(ModuleAdapter.class.getName());
+    if (dependencies) {
+      imports.add(Linker.class.getName());
+      imports.add(Set.class.getName());
+    }
+    if (multibindings) {
+      imports.add(SetBinding.class.getName());
+    }
+    return imports;
+  }
+
+  private boolean checkForDependencies(List<ExecutableElement> providerMethods) {
+    for (ExecutableElement element : providerMethods) {
+      if (!element.getParameters().isEmpty()) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private boolean checkForMultibindings(List<ExecutableElement> providerMethods) {
+    for (ExecutableElement element : providerMethods) {
+      if (element.getAnnotation(Provides.class).type() == Provides.Type.SET) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   private String bindingClassName(ExecutableElement providerMethod,
       Map<ExecutableElement, String> methodToClassName,
       Map<String, AtomicInteger> methodNameToNextId) {
@@ -278,12 +322,12 @@
     }
     String uppercaseMethodName = Character.toUpperCase(methodName.charAt(0))
         + methodName.substring(1);
-    className = uppercaseMethodName + "Binding" + suffix;
+    className = uppercaseMethodName + "ProvidesAdapter" + suffix;
     methodToClassName.put(providerMethod, className);
     return className;
   }
 
-  private void writeBindingClass(JavaWriter writer, ExecutableElement providerMethod,
+  private void writeProvidesAdapter(JavaWriter writer, ExecutableElement providerMethod,
       Map<ExecutableElement, String> methodToClassName,
       Map<String, AtomicInteger> methodNameToNextId)
       throws IOException {
@@ -291,63 +335,81 @@
     String moduleType = CodeGen.typeToString(providerMethod.getEnclosingElement().asType());
     String className = bindingClassName(providerMethod, methodToClassName, methodNameToNextId);
     String returnType = CodeGen.typeToString(providerMethod.getReturnType());
-
-    writer.beginType(className, "class", PRIVATE | STATIC,
-        CodeGen.parameterizedType(Binding.class, returnType));
-    writer.field(moduleType, "module", PRIVATE | FINAL);
     List<? extends VariableElement> parameters = providerMethod.getParameters();
-    for (int p = 0; p < parameters.size(); p++) {
-      TypeMirror parameterType = parameters.get(p).asType();
-      writer.field(CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(parameterType)),
-          parameterName(p), PRIVATE);
+    boolean dependent = !parameters.isEmpty();
+
+    writer.emitEmptyLine();
+    writer.emitJavadoc(binderTypeDocs(returnType, false, false, dependent));
+    writer.beginType(className, "class", PUBLIC | FINAL | STATIC,
+        CodeGen.parameterizedType(Binding.class, returnType),
+        CodeGen.parameterizedType(Provider.class, returnType));
+    writer.emitField(moduleType, "module", PRIVATE | FINAL);
+    for (Element parameter : parameters) {
+      TypeMirror parameterType = parameter.asType();
+      writer.emitField(CodeGen.parameterizedType(Binding.class,
+          CodeGen.typeToString(parameterType)),
+          parameterName(parameter), PRIVATE);
     }
 
+    writer.emitEmptyLine();
     writer.beginMethod(null, className, PUBLIC, moduleType, "module");
     boolean singleton = providerMethod.getAnnotation(Singleton.class) != null;
     String key = JavaWriter.stringLiteral(GeneratorKeys.get(providerMethod));
     String membersKey = null;
-    writer.statement("super(%s, %s, %s /*singleton*/, %s.class)",
-        key, membersKey, singleton, moduleType);
-    writer.statement("this.module = module");
+    writer.emitStatement("super(%s, %s, %s, %s.class)",
+        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"), moduleType);
+    writer.emitStatement("this.module = module");
     writer.endMethod();
 
-    writer.annotation(Override.class);
-    writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
-    for (int p = 0; p < parameters.size(); p++) {
-      VariableElement parameter = parameters.get(p);
-      String parameterKey = GeneratorKeys.get(parameter);
-      writer.statement("%s = (%s) linker.requestBinding(%s, %s.class)",
-          parameterName(p),
-          CodeGen.parameterizedType(Binding.class, CodeGen.typeToString(parameter.asType())),
-          JavaWriter.stringLiteral(parameterKey), moduleType);
+    if (dependent) {
+      writer.emitEmptyLine();
+      writer.emitJavadoc(ProcessorJavadocs.ATTACH_METHOD);
+      writer.emitAnnotation(Override.class);
+      writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
+      for (VariableElement parameter : parameters) {
+        String parameterKey = GeneratorKeys.get(parameter);
+        writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
+            parameterName(parameter),
+            writer.compressType(CodeGen.parameterizedType(Binding.class,
+                CodeGen.typeToString(parameter.asType()))),
+            JavaWriter.stringLiteral(parameterKey),
+            writer.compressType(moduleType));
+      }
+      writer.endMethod();
+
+      writer.emitEmptyLine();
+      writer.emitJavadoc(ProcessorJavadocs.GET_DEPENDENCIES_METHOD);
+      writer.emitAnnotation(Override.class);
+      String setOfBindings = CodeGen.parameterizedType(Set.class, "Binding<?>");
+      writer.beginMethod("void", "getDependencies", PUBLIC, setOfBindings, "getBindings",
+          setOfBindings, "injectMembersBindings");
+      for (Element parameter : parameters) {
+        writer.emitStatement("getBindings.add(%s)", parameter.getSimpleName().toString());
+      }
+      writer.endMethod();
     }
-    writer.endMethod();
 
-    writer.annotation(Override.class);
+    writer.emitEmptyLine();
+    writer.emitJavadoc(ProcessorJavadocs.GET_METHOD, returnType);
+    writer.emitAnnotation(Override.class);
     writer.beginMethod(returnType, "get", PUBLIC);
     StringBuilder args = new StringBuilder();
-    for (int p = 0; p < parameters.size(); p++) {
-      if (p != 0) {
-        args.append(", ");
-      }
-      args.append(String.format("%s.get()", parameterName(p)));
+    boolean first = true;
+    for (Element parameter : parameters) {
+      if (!first) args.append(", ");
+      else first = false;
+      args.append(String.format("%s.get()", parameter.getSimpleName().toString()));
     }
-    writer.statement("return module.%s(%s)", methodName, args.toString());
-    writer.endMethod();
-
-    writer.annotation(Override.class);
-    String setOfBindings = CodeGen.parameterizedType(Set.class, "Binding<?>");
-    writer.beginMethod("void", "getDependencies", PUBLIC, setOfBindings, "getBindings",
-        setOfBindings, "injectMembersBindings");
-    for (int p = 0; p < parameters.size(); p++) {
-      writer.statement("getBindings.add(%s)", parameterName(p));
-    }
+    writer.emitStatement("return module.%s(%s)", methodName, args.toString());
     writer.endMethod();
 
     writer.endType();
   }
 
-  private String parameterName(int index) {
-    return "p" + index;
+  private String parameterName(Element parameter) {
+    if (parameter.getSimpleName().equals("module")) {
+      return "parameter_" + parameter.getSimpleName().toString();
+    }
+    return parameter.getSimpleName().toString();
   }
 }
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/JavaWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/JavaWriterTest.java
index 5a10cfd..eb7f18f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/JavaWriterTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/JavaWriterTest.java
@@ -15,21 +15,25 @@
  */
 package dagger.internal.codegen;
 
+import dagger.internal.Binding;
 import java.io.IOException;
 import java.io.StringWriter;
 import java.lang.reflect.Modifier;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import java.util.Set;
 import org.junit.Test;
 
+import static dagger.internal.codegen.CodeGen.setOf;
 import static org.fest.assertions.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 
 public final class JavaWriterTest {
   private final StringWriter stringWriter = new StringWriter();
   private final JavaWriter javaWriter = new JavaWriter(stringWriter);
 
   @Test public void typeDeclaration() throws IOException {
-    javaWriter.addPackage("com.squareup");
+    javaWriter.emitPackage("com.squareup");
     javaWriter.beginType("com.squareup.Foo", "class", Modifier.PUBLIC | Modifier.FINAL);
     javaWriter.endType();
     assertCode(""
@@ -39,9 +43,9 @@
   }
 
   @Test public void fieldDeclaration() throws IOException {
-    javaWriter.addPackage("com.squareup");
+    javaWriter.emitPackage("com.squareup");
     javaWriter.beginType("com.squareup.Foo", "class", 0);
-    javaWriter.field("java.lang.String", "string", Modifier.PRIVATE | Modifier.STATIC);
+    javaWriter.emitField("java.lang.String", "string", Modifier.PRIVATE | Modifier.STATIC);
     javaWriter.endType();
     assertCode(""
         + "package com.squareup;\n"
@@ -51,7 +55,7 @@
   }
 
   @Test public void fieldDeclarationWithInitialValue() throws IOException {
-    javaWriter.addPackage("com.squareup");
+    javaWriter.emitPackage("com.squareup");
     javaWriter.beginType("com.squareup.Foo", "class", 0);
     javaWriter.field("java.lang.String", "string", 0, "\"bar\" + \"baz\"");
     javaWriter.endType();
@@ -63,7 +67,7 @@
   }
 
   @Test public void abstractMethodDeclaration() throws IOException {
-    javaWriter.addPackage("com.squareup");
+    javaWriter.emitPackage("com.squareup");
     javaWriter.beginType("com.squareup.Foo", "class", 0);
     javaWriter.beginMethod("java.lang.String", "foo", Modifier.ABSTRACT | Modifier.PUBLIC,
         "java.lang.Object", "object", "java.lang.String", "s");
@@ -77,7 +81,7 @@
   }
 
   @Test public void nonAbstractMethodDeclaration() throws IOException {
-    javaWriter.addPackage("com.squareup");
+    javaWriter.emitPackage("com.squareup");
     javaWriter.beginType("com.squareup.Foo", "class", 0);
     javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
     javaWriter.endMethod();
@@ -91,7 +95,7 @@
   }
 
   @Test public void constructorDeclaration() throws IOException {
-    javaWriter.addPackage("com.squareup");
+    javaWriter.emitPackage("com.squareup");
     javaWriter.beginType("com.squareup.Foo", "class", 0);
     javaWriter.beginMethod(null, "com.squareup.Foo", Modifier.PUBLIC, "java.lang.String", "s");
     javaWriter.endMethod();
@@ -105,10 +109,10 @@
   }
 
   @Test public void statement() throws IOException {
-    javaWriter.addPackage("com.squareup");
+    javaWriter.emitPackage("com.squareup");
     javaWriter.beginType("com.squareup.Foo", "class", 0);
     javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
-    javaWriter.statement("int j = s.length() + %s", 13);
+    javaWriter.emitStatement("int j = s.length() + %s", 13);
     javaWriter.endMethod();
     javaWriter.endType();
     assertCode(""
@@ -121,23 +125,24 @@
   }
 
   @Test public void addImport() throws IOException {
-    javaWriter.addPackage("com.squareup");
-    javaWriter.addImport("java.util.ArrayList");
+    javaWriter.emitPackage("com.squareup");
+    javaWriter.emitImports(setOf("java.util.ArrayList"));
     javaWriter.beginType("com.squareup.Foo", "class", Modifier.PUBLIC | Modifier.FINAL);
     javaWriter.field("java.util.ArrayList", "list", 0, "new java.util.ArrayList()");
     javaWriter.endType();
     assertCode(""
         + "package com.squareup;\n"
         + "import java.util.ArrayList;\n"
+        + "\n"
         + "public final class Foo {\n"
         + "  ArrayList list = new java.util.ArrayList();\n"
         + "}\n");
   }
 
   @Test public void addImportFromSubpackage() throws IOException {
-    javaWriter.addPackage("com.squareup");
+    javaWriter.emitPackage("com.squareup");
     javaWriter.beginType("com.squareup.Foo", "class", Modifier.PUBLIC | Modifier.FINAL);
-    javaWriter.field("com.squareup.bar.Baz", "baz", 0);
+    javaWriter.emitField("com.squareup.bar.Baz", "baz", 0);
     javaWriter.endType();
     assertCode(""
         + "package com.squareup;\n"
@@ -147,11 +152,11 @@
   }
 
   @Test public void ifControlFlow() throws IOException {
-    javaWriter.addPackage("com.squareup");
+    javaWriter.emitPackage("com.squareup");
     javaWriter.beginType("com.squareup.Foo", "class", 0);
     javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
     javaWriter.beginControlFlow("if (s.isEmpty())");
-    javaWriter.statement("int j = s.length() + %s", 13);
+    javaWriter.emitStatement("int j = s.length() + %s", 13);
     javaWriter.endControlFlow();
     javaWriter.endMethod();
     javaWriter.endType();
@@ -167,11 +172,11 @@
   }
 
   @Test public void doWhileControlFlow() throws IOException {
-    javaWriter.addPackage("com.squareup");
+    javaWriter.emitPackage("com.squareup");
     javaWriter.beginType("com.squareup.Foo", "class", 0);
     javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
     javaWriter.beginControlFlow("do");
-    javaWriter.statement("int j = s.length() + %s", 13);
+    javaWriter.emitStatement("int j = s.length() + %s", 13);
     javaWriter.endControlFlow("while (s.isEmpty())");
     javaWriter.endMethod();
     javaWriter.endType();
@@ -187,15 +192,15 @@
   }
 
   @Test public void tryCatchFinallyControlFlow() throws IOException {
-    javaWriter.addPackage("com.squareup");
+    javaWriter.emitPackage("com.squareup");
     javaWriter.beginType("com.squareup.Foo", "class", 0);
     javaWriter.beginMethod("int", "foo", 0, "java.lang.String", "s");
     javaWriter.beginControlFlow("try");
-    javaWriter.statement("int j = s.length() + %s", 13);
+    javaWriter.emitStatement("int j = s.length() + %s", 13);
     javaWriter.nextControlFlow("catch (RuntimeException e)");
-    javaWriter.statement("e.printStackTrace()");
+    javaWriter.emitStatement("e.printStackTrace()");
     javaWriter.nextControlFlow("finally");
-    javaWriter.statement("int k = %s", 13);
+    javaWriter.emitStatement("int k = %s", 13);
     javaWriter.endControlFlow();
     javaWriter.endMethod();
     javaWriter.endType();
@@ -215,24 +220,25 @@
   }
 
   @Test public void annotatedType() throws IOException {
-    javaWriter.addPackage("com.squareup");
-    javaWriter.addImport("javax.inject.Singleton");
-    javaWriter.annotation("javax.inject.Singleton");
+    javaWriter.emitPackage("com.squareup");
+    javaWriter.emitImports(setOf("javax.inject.Singleton"));
+    javaWriter.emitAnnotation("javax.inject.Singleton");
     javaWriter.beginType("com.squareup.Foo", "class", 0);
     javaWriter.endType();
     assertCode(""
         + "package com.squareup;\n"
         + "import javax.inject.Singleton;\n"
+        + "\n"
         + "@Singleton\n"
         + "class Foo {\n"
         + "}\n");
   }
 
   @Test public void annotatedMember() throws IOException {
-    javaWriter.addPackage("com.squareup");
+    javaWriter.emitPackage("com.squareup");
     javaWriter.beginType("com.squareup.Foo", "class", 0);
-    javaWriter.annotation(Deprecated.class);
-    javaWriter.field("java.lang.String", "s", 0);
+    javaWriter.emitAnnotation(Deprecated.class);
+    javaWriter.emitField("java.lang.String", "s", 0);
     javaWriter.endType();
     assertCode(""
         + "package com.squareup;\n"
@@ -248,8 +254,8 @@
     attributes.put("entryPoints", new Object[] { "entryPointA", "entryPointB", "entryPointC" });
     attributes.put("staticInjections", "com.squareup.Quux");
 
-    javaWriter.addPackage("com.squareup");
-    javaWriter.annotation("Module", attributes);
+    javaWriter.emitPackage("com.squareup");
+    javaWriter.emitAnnotation("Module", attributes);
     javaWriter.beginType("com.squareup.FooModule", "class", 0);
     javaWriter.endType();
     assertCode(""
@@ -268,21 +274,45 @@
   }
 
   @Test public void parameterizedType() throws IOException {
-    javaWriter.addPackage("com.squareup");
-    javaWriter.addImport("java.util.Map");
-    javaWriter.addImport("java.util.Date");
+    javaWriter.emitPackage("com.squareup");
+    javaWriter.emitImports(setOf("java.util.Map", "java.util.Date"));
     javaWriter.beginType("com.squareup.Foo", "class", 0);
-    javaWriter.field("java.util.Map<java.lang.String, java.util.Date>", "map", 0);
+    javaWriter.emitField("java.util.Map<java.lang.String, java.util.Date>", "map", 0);
     javaWriter.endType();
     assertCode(""
         + "package com.squareup;\n"
-        + "import java.util.Map;\n"
         + "import java.util.Date;\n"
+        + "import java.util.Map;\n"
+        + "\n"
         + "class Foo {\n"
         + "  Map<String, Date> map;\n"
         + "}\n");
   }
 
+  @Test public void eolComment() throws IOException {
+    javaWriter.emitEndOfLineComment("foo");
+    assertCode(""
+        + "// foo\n");
+  }
+
+  @Test public void javadoc() throws IOException {
+    javaWriter.emitJavadoc("foo");
+    assertCode(""
+        + "/**\n"
+        + " * foo\n"
+        + " */\n");
+  }
+
+  @Test public void multilineJavadoc() throws IOException {
+    javaWriter.emitJavadoc("0123456789 0123456789 0123456789 0123456789 0123456789 0123456789\n"
+        + "0123456789 0123456789 0123456789 0123456789");
+    assertCode(""
+        + "/**\n"
+        + " * 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789\n"
+        + " * 0123456789 0123456789 0123456789 0123456789\n"
+        + " */\n");
+  }
+
   @Test public void testStringLiteral() {
     assertThat(JavaWriter.stringLiteral("")).isEqualTo("\"\"");
     assertThat(JavaWriter.stringLiteral("JavaWriter")).isEqualTo("\"JavaWriter\"");
@@ -292,6 +322,20 @@
     assertThat(JavaWriter.stringLiteral("\n")).isEqualTo("\"\\\n\"");
   }
 
+  @Test public void compressType() throws IOException {
+    javaWriter.emitPackage("blah");
+    javaWriter.emitImports(setOf(Set.class.getName(), Binding.class.getName()));
+    String actual = javaWriter.compressType("java.util.Set<dagger.internal.Binding<blah.Foo.Blah>>");
+    assertEquals("Set<Binding<Foo.Blah>>", actual);
+  }
+
+  @Test public void compressDeeperType() throws IOException {
+    javaWriter.emitPackage("blah");
+    javaWriter.emitImports(setOf(Binding.class.getName()));
+    String actual = javaWriter.compressType("dagger.internal.Binding<blah.foo.Foo.Blah>");
+    assertEquals("Binding<blah.foo.Foo.Blah>", actual);
+  }
+
   private void assertCode(String expected) {
     assertThat(stringWriter.toString()).isEqualTo(expected);
   }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Binding.java b/core/src/main/java/dagger/internal/Binding.java
index d77e25e..6cd5b03 100644
--- a/core/src/main/java/dagger/internal/Binding.java
+++ b/core/src/main/java/dagger/internal/Binding.java
@@ -28,6 +28,8 @@
       // do nothing
     }
   };
+  protected static final boolean IS_SINGLETON = true;
+  protected static final boolean NOT_SINGLETON = false;
 
   /** Set if the provided instance is always the same object. */
   private static final int SINGLETON = 1 << 0;
@@ -69,11 +71,11 @@
   }
 
   @Override public void injectMembers(T t) {
-    throw new UnsupportedOperationException(getClass().getName());
+    throw new UnsupportedOperationException("No injectable members on " + getClass().getName());
   }
 
   @Override public T get() {
-    throw new UnsupportedOperationException(getClass().getName());
+    throw new UnsupportedOperationException("No injectable constructor on " + getClass().getName());
   }
 
   /**
/Fim/
diff --git a/.gitignore b/.gitignore
index 133735f..972ecd3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,4 +1,5 @@
 .classpath
+.factorypath
 .project
 .settings
 eclipsebin
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 5842e9e..9e285d7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -250,6 +250,7 @@
       writer.emitEmptyLine();
       writer.emitJavadoc(ProcessorJavadocs.ATTACH_METHOD);
       writer.emitAnnotation(Override.class);
+      writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
       writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
       if (constructor != null) {
         for (VariableElement parameter : constructor.getParameters()) {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
index ed594ff..a1ffc2f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
@@ -298,6 +298,7 @@
     emitAnnotation(annotation, Collections.<String, Object>emptyMap());
   }
 
+
   /**
    * Equivalent to {@code annotation(annotationType.getName(), emptyMap())}.
    */
@@ -306,6 +307,24 @@
   }
 
   /**
+   * Annotates the next element with {@code annotation} and a {@code value}.
+   *
+   * @param value an object used as the default (value) parameter of the annotation.
+   *     The value will be encoded using Object.toString(); use {@link #stringLiteral}
+   *     for String values. Object arrays are written one element per line.
+   */
+  public void emitAnnotation(Class<? extends Annotation> annotation, Object value)
+      throws IOException {
+    indent();
+    out.write("@");
+    emitType(annotation.getName());
+    out.write("(");
+    emitAnnotationValue(value);
+    out.write(")");
+    out.write("\n");
+  }
+
+  /**
    * Equivalent to {@code annotation(annotationType.getName(), attributes)}.
    */
   public void emitAnnotation(Class<? extends Annotation> annotationType, Map<String, ?> attributes)
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 3378dcd..8fcffce 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -365,6 +365,7 @@
       writer.emitEmptyLine();
       writer.emitJavadoc(ProcessorJavadocs.ATTACH_METHOD);
       writer.emitAnnotation(Override.class);
+      writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
       writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
       for (VariableElement parameter : parameters) {
         String parameterKey = GeneratorKeys.get(parameter);
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/JavaWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/JavaWriterTest.java
index eb7f18f..c487c89 100644
--- a/compiler/src/test/java/dagger/internal/codegen/JavaWriterTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/JavaWriterTest.java
@@ -223,6 +223,7 @@
     javaWriter.emitPackage("com.squareup");
     javaWriter.emitImports(setOf("javax.inject.Singleton"));
     javaWriter.emitAnnotation("javax.inject.Singleton");
+    javaWriter.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
     javaWriter.beginType("com.squareup.Foo", "class", 0);
     javaWriter.endType();
     assertCode(""
@@ -230,6 +231,7 @@
         + "import javax.inject.Singleton;\n"
         + "\n"
         + "@Singleton\n"
+        + "@SuppressWarnings(\"unchecked\")\n"
         + "class Foo {\n"
         + "}\n");
   }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Binding.java b/core/src/main/java/dagger/internal/Binding.java
index 6cd5b03..ee5873c 100644
--- a/core/src/main/java/dagger/internal/Binding.java
+++ b/core/src/main/java/dagger/internal/Binding.java
@@ -23,11 +23,7 @@
  * Injects a value of a specific type.
  */
 public abstract class Binding<T> implements Provider<T>, MembersInjector<T> {
-  public static final Binding<Object> UNRESOLVED = new Binding<Object>(null, null, false, null) {
-    @Override public void getDependencies(Set<Binding<?>> bindings, Set<Binding<?>> memBindings) {
-      // do nothing
-    }
-  };
+  public static final Binding<Object> UNRESOLVED = new Binding<Object>(null, null, false, null) { };
   protected static final boolean IS_SINGLETON = true;
   protected static final boolean NOT_SINGLETON = false;
 
@@ -90,7 +86,7 @@
    *     injectMembers} method.
    */
   public void getDependencies(Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
-    throw new UnsupportedOperationException(getClass().getName());
+    // Do nothing.  No override == no dependencies to contribute.
   }
 
   void setLinked() {
/Fim/
diff --git a/core/src/main/java/dagger/internal/BuiltInBinding.java b/core/src/main/java/dagger/internal/BuiltInBinding.java
index 8388190..d6787bc 100644
--- a/core/src/main/java/dagger/internal/BuiltInBinding.java
+++ b/core/src/main/java/dagger/internal/BuiltInBinding.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal;
 
-import java.util.Set;
 
 /**
  * Injects a Provider or a MembersInjector.
@@ -46,7 +45,6 @@
     return delegate;
   }
 
-  @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-    // We don't add 'delegate' because it isn't actually used by get() or injectMembers().
-  }
+  // public void getDependencies() not overridden.
+  // We don't add 'delegate' because it isn't actually used by get() or injectMembers().
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/LazyBinding.java b/core/src/main/java/dagger/internal/LazyBinding.java
index 1a9d6e7..a3bacc3 100644
--- a/core/src/main/java/dagger/internal/LazyBinding.java
+++ b/core/src/main/java/dagger/internal/LazyBinding.java
@@ -17,7 +17,6 @@
 package dagger.internal;
 
 import dagger.Lazy;
-import java.util.Set;
 
 /**
  * Injects a Lazy wrapper for a type T
@@ -57,8 +56,6 @@
     };
   }
 
-  @Override public void getDependencies(
-      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
-    // We don't add 'delegate' because it isn't actually used by get() or injectMembers().
-  }
+  // public void getDependencies() not overridden.
+  // We don't add 'delegate' because it isn't actually used by get() or injectMembers().
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index faad259..042dbbe 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -332,6 +332,9 @@
       this.deferredKey = deferredKey;
       this.mustBeInjectable = mustBeInjectable;
     }
+    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
+      throw new UnsupportedOperationException("Deferred bindings must resolve first.");
+    }
   }
 
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
index 5ffb5ce..e18cb91 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
@@ -122,6 +122,14 @@
     }
   }
 
+  @Override public Object get() {
+    throw new AssertionError("Compile-time binding should never be called to inject.");
+  }
+
+  @Override public void injectMembers(Object t) {
+    throw new AssertionError("Compile-time binding should never be called to inject.");
+  }
+
   @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
     for (Binding<?> binding : bindings) {
       get.add(binding);
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 98c2573..2c9c053 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -203,6 +203,14 @@
       }
     }
 
+    @Override public Object get() {
+      throw new AssertionError("Compile-time binding should never be called to inject.");
+    }
+
+    @Override public void injectMembers(Object t) {
+      throw new AssertionError("Compile-time binding should never be called to inject.");
+    }
+
     @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
       for (Binding<?> binding : parameters) {
         get.add(binding);
/Fim/
diff --git a/core/src/main/java/dagger/internal/Binding.java b/core/src/main/java/dagger/internal/Binding.java
index ee5873c..1fe88a6 100644
--- a/core/src/main/java/dagger/internal/Binding.java
+++ b/core/src/main/java/dagger/internal/Binding.java
@@ -23,7 +23,14 @@
  * Injects a value of a specific type.
  */
 public abstract class Binding<T> implements Provider<T>, MembersInjector<T> {
-  public static final Binding<Object> UNRESOLVED = new Binding<Object>(null, null, false, null) { };
+  public static final Binding<Object> UNRESOLVED = new Binding<Object>(null, null, false, null) {
+    @Override public Object get() {
+      throw new AssertionError("Unresolved binding should never be called to inject.");
+    }
+    @Override public void injectMembers(Object t) {
+      throw new AssertionError("Unresolved binding should never be called to inject.");
+    }
+  };
   protected static final boolean IS_SINGLETON = true;
   protected static final boolean NOT_SINGLETON = false;
 
@@ -67,7 +74,8 @@
   }
 
   @Override public void injectMembers(T t) {
-    throw new UnsupportedOperationException("No injectable members on " + getClass().getName());
+    // If no members to inject, no-op.  Some classes will have no injectable members even
+    // if their supertypes do.
   }
 
   @Override public T get() {
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 042dbbe..6a016eb 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -332,6 +332,9 @@
       this.deferredKey = deferredKey;
       this.mustBeInjectable = mustBeInjectable;
     }
+    @Override public void injectMembers(Object t) {
+      throw new UnsupportedOperationException("Deferred bindings must resolve first.");
+    }
     @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
       throw new UnsupportedOperationException("Deferred bindings must resolve first.");
     }
/Fim/
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index 9c47111..1536275 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -64,6 +64,10 @@
     getBindings.addAll(contributors);
   }
 
+  @Override public void injectMembers(Set<T> t) {
+    throw new UnsupportedOperationException("Cannot inject into a multi-binder Set");
+  }
+
   @Override public String toString() {
     return "SetBinding" + contributors;
   }
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
index 2d3efe8..ab1e8ec 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
@@ -148,6 +148,10 @@
       }
     }
 
+    @Override public void injectMembers(T t) {
+      throw new AssertionError("Provides method bindings are not MembersInjectors");
+    }
+
     @Override public String toString() {
       return method.toString();
     }
/Fim/
diff --git a/compiler/src/it/include-non-module/pom.xml b/compiler/src/it/include-non-module/pom.xml
new file mode 100644
index 0000000..4a0d2a9
--- /dev/null
+++ b/compiler/src/it/include-non-module/pom.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2013 Square, Inc.
+ Copyright (C) 2013 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.squareup.dagger.tests</groupId>
+  <artifactId>include-non-module</artifactId>
+  <version>@dagger.version@</version>
+  <packaging>jar</packaging>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/include-non-module/src/main/java/test/TestApp.java b/compiler/src/it/include-non-module/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..3b790a8
--- /dev/null
+++ b/compiler/src/it/include-non-module/src/main/java/test/TestApp.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import dagger.Provides;
+import javax.inject.Inject;
+import java.lang.String;
+
+class TestApp {
+  public static void main(String[] args) {
+    TestApp app = ObjectGraph.create(new TestModule()).get(TestApp.class);
+  }
+
+  @Inject String s;
+
+  @Module(
+      entryPoints = TestApp.class,
+      includes = TestApp.class)
+  static class TestModule {
+    @Provides String provideString() {
+      return "a";
+    }
+  }
+}
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 3c194c5..c83521a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -166,12 +166,18 @@
   }
 
   private void collectIncludesRecursively(TypeElement module, Map<String, TypeElement> result) {
+    Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
+    if (annotation == null) {
+      // TODO(tbroyer): pass annotation information
+      error("No @Module on " + module, module);
+      return;
+    }
+
     // Add the module.
     result.put(module.getQualifiedName().toString(), module);
 
     // Recurse for each included module.
     Types typeUtils = processingEnv.getTypeUtils();
-    Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
     List<Object> seedModules = new ArrayList<Object>();
     seedModules.addAll(Arrays.asList((Object[]) annotation.get("includes")));
     if (!annotation.get("addsTo").equals(Void.class)) seedModules.add(annotation.get("addsTo"));
/Fim/
diff --git a/core/src/test/java/dagger/ModuleIncludesTest.java b/core/src/test/java/dagger/ModuleIncludesTest.java
index b72f2e9..eec68bb 100644
--- a/core/src/test/java/dagger/ModuleIncludesTest.java
+++ b/core/src/test/java/dagger/ModuleIncludesTest.java
@@ -177,4 +177,14 @@
     assertThat(objectGraph.get(A.class)).isNotNull();
     assertThat(objectGraph.get(B.class).a).isNotNull();
   }
+
+  static class ModuleMissingModuleAnnotation {}
+
+  @Module(includes = ModuleMissingModuleAnnotation.class)
+  static class ChildModuleMissingModuleAnnotation {}
+
+  @Test(expected = IllegalArgumentException.class)
+  public void childModuleMissingModuleAnnotation() {
+    ObjectGraph.create(new ChildModuleMissingModuleAnnotation());
+  }
 }
/Fim/
diff --git a/compiler/src/it/include-non-module/invoker.properties b/compiler/src/it/include-non-module/invoker.properties
new file mode 100644
index 0000000..324b5fb
--- /dev/null
+++ b/compiler/src/it/include-non-module/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
\ No newline at end of file
/Fim/
diff --git a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
index 758f14b..eb05c40 100644
--- a/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
+++ b/androidmanifest/src/main/java/dagger/androidmanifest/ModuleGenerator.java
@@ -90,7 +90,7 @@
         ? moduleName
         : packageName + "." + moduleName;
     out.emitPackage(packageName);
-    out.emitImports(Arrays.asList(Module.class.getName()));
+    out.emitImports(Arrays.asList(Module.class.getCanonicalName()));
 
     List<String> classLiterals = namesToClassLiterals(nameReferences);
     Collections.sort(classLiterals);
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
index e18cb91..12e11e3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
@@ -18,6 +18,7 @@
 import dagger.internal.Binding;
 import dagger.internal.Linker;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 import javax.inject.Inject;
@@ -131,8 +132,6 @@
   }
 
   @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-    for (Binding<?> binding : bindings) {
-      get.add(binding);
-    }
+    Collections.addAll(get, bindings);
   }
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java b/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
index d4ab7df..06c2977 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
@@ -75,7 +75,7 @@
   /** Returns a string like {@code java.util.List<java.lang.String>}. */
   public static String parameterizedType(Class<?> raw, String... parameters) {
     StringBuilder result = new StringBuilder();
-    result.append(raw.getName());
+    result.append(raw.getCanonicalName());
     result.append("<");
     for (int i = 0; i < parameters.length; i++) {
       if (i != 0) {
@@ -143,7 +143,7 @@
         return null;
       }
       @Override public Void visitTypeVariable(TypeVariable typeVariable, Void v) {
-        result.append(typeVariable); // TypeVariable.toString() returns the name, like 'T'.
+        result.append(typeVariable.asElement().getSimpleName());
         return null;
       }
       @Override protected Void defaultAction(TypeMirror typeMirror, Void v) {
@@ -175,7 +175,8 @@
    */
   public static Map<String, Object> getAnnotation(Class<?> annotationType, Element element) {
     for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
-      if (!annotation.getAnnotationType().toString().equals(annotationType.getName())) {
+      if (!CodeGen.rawTypeToString(annotation.getAnnotationType(), '$')
+          .equals(annotationType.getName())) {
         continue;
       }
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index c83521a..ffc3489 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -24,6 +24,7 @@
 import java.io.Writer;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
@@ -220,9 +221,7 @@
     }
 
     @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-      for (Binding<?> binding : parameters) {
-        get.add(binding);
-      }
+      Collections.addAll(get, parameters);
     }
   }
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java b/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
index f93220c..0b51da3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
@@ -30,7 +30,7 @@
  * APIs not available on Android.
  */
 final class GeneratorKeys {
-  private static final String SET_PREFIX = Set.class.getName() + "<";
+  private static final String SET_PREFIX = Set.class.getCanonicalName() + "<";
 
   private GeneratorKeys() {
   }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 0fb56ff..0165fd9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -35,7 +35,6 @@
 import javax.inject.Singleton;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
@@ -160,32 +159,15 @@
     }
 
     if (constructor == null && !isAbstract) {
-      constructor = findNoArgsConstructor(type);
+      constructor = CodeGen.getNoArgsConstructor(type);
+      if (constructor != null && !CodeGen.isCallableConstructor(constructor)) {
+        constructor = null;
+      }
     }
 
     return new InjectedClass(type, staticFields, constructor, fields);
   }
 
-  /**
-   * Returns the no args constructor for {@code typeElement}, or null if no such
-   * constructor exists.
-   */
-  private ExecutableElement findNoArgsConstructor(TypeElement typeElement) {
-    for (Element element : typeElement.getEnclosedElements()) {
-      if (element.getKind() != ElementKind.CONSTRUCTOR) {
-        continue;
-      }
-      ExecutableElement constructor = (ExecutableElement) element;
-      if (constructor.getParameters().isEmpty()) {
-        if (constructor.getModifiers().contains(Modifier.PRIVATE)) {
-          return null;
-        } else {
-          return constructor;
-        }
-      }
-    }
-    return null;
-  }
 
   private void error(String msg, Element element) {
     processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg, element);
@@ -256,7 +238,7 @@
       writer.emitJavadoc(ProcessorJavadocs.ATTACH_METHOD);
       writer.emitAnnotation(Override.class);
       writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
-      writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
+      writer.beginMethod("void", "attach", PUBLIC, Linker.class.getCanonicalName(), "linker");
       if (constructor != null) {
         for (VariableElement parameter : constructor.getParameters()) {
           writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
@@ -355,18 +337,18 @@
     if (hasFields) {
       interfaces.add(CodeGen.parameterizedType(MembersInjector.class, strippedTypeName));
     }
-    return interfaces.toArray(new String[0]);
+    return interfaces.toArray(new String[interfaces.size()]);
   }
 
   private Set<String> getImports(boolean dependent, boolean injectMembers, boolean isProvider) {
     Set<String> imports = new LinkedHashSet<String>();
-    imports.add(Binding.class.getName());
+    imports.add(Binding.class.getCanonicalName());
     if (dependent) {
-      imports.add(Linker.class.getName());
-      imports.add(Set.class.getName());
+      imports.add(Linker.class.getCanonicalName());
+      imports.add(Set.class.getCanonicalName());
     }
-    if (injectMembers) imports.add(MembersInjector.class.getName());
-    if (isProvider) imports.add(Provider.class.getName());
+    if (injectMembers) imports.add(MembersInjector.class.getCanonicalName());
+    if (isProvider) imports.add(Provider.class.getCanonicalName());
     return imports;
   }
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
index a1ffc2f..98ea42e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/JavaWriter.java
@@ -102,7 +102,7 @@
   }
 
   String compressType(String type) {
-    StringBuffer sb = new StringBuffer();
+    StringBuilder sb = new StringBuilder();
     if (this.packagePrefix == null) {
       throw new IllegalStateException();
     }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index f4bf614..211845b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -66,7 +66,7 @@
   private final LinkedHashMap<String, List<ExecutableElement>> remainingTypes =
       new LinkedHashMap<String, List<ExecutableElement>>();
   private static final String BINDINGS_MAP = CodeGen.parameterizedType(
-      Map.class, String.class.getName(), Binding.class.getName() + "<?>");
+      Map.class, String.class.getCanonicalName(), Binding.class.getCanonicalName() + "<?>");
 
   // TODO: include @Provides methods from the superclass
   @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
@@ -130,10 +130,10 @@
         continue;
       }
 
-      List<ExecutableElement> methods = result.get(type.toString());
+      List<ExecutableElement> methods = result.get(type.getQualifiedName().toString());
       if (methods == null) {
         methods = new ArrayList<ExecutableElement>();
-        result.put(type.toString(), methods);
+        result.put(type.getQualifiedName().toString(), methods);
       }
       methods.add((ExecutableElement) providerMethod);
     }
@@ -275,16 +275,16 @@
 
   private Set<String> getImports(boolean multibindings, boolean dependencies) {
     Set<String> imports = new LinkedHashSet<String>();
-    imports.add(Binding.class.getName());
-    imports.add(Map.class.getName());
-    imports.add(Provider.class.getName());
-    imports.add(ModuleAdapter.class.getName());
+    imports.add(Binding.class.getCanonicalName());
+    imports.add(Map.class.getCanonicalName());
+    imports.add(Provider.class.getCanonicalName());
+    imports.add(ModuleAdapter.class.getCanonicalName());
     if (dependencies) {
-      imports.add(Linker.class.getName());
-      imports.add(Set.class.getName());
+      imports.add(Linker.class.getCanonicalName());
+      imports.add(Set.class.getCanonicalName());
     }
     if (multibindings) {
-      imports.add(SetBinding.class.getName());
+      imports.add(SetBinding.class.getCanonicalName());
     }
     return imports;
   }
@@ -368,7 +368,7 @@
       writer.emitJavadoc(ProcessorJavadocs.ATTACH_METHOD);
       writer.emitAnnotation(Override.class);
       writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
-      writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
+      writer.beginMethod("void", "attach", PUBLIC, Linker.class.getCanonicalName(), "linker");
       for (VariableElement parameter : parameters) {
         String parameterKey = GeneratorKeys.get(parameter);
         writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class)",
@@ -410,7 +410,7 @@
   }
 
   private String parameterName(Element parameter) {
-    if (parameter.getSimpleName().equals("module")) {
+    if (parameter.getSimpleName().contentEquals("module")) {
       return "parameter_" + parameter.getSimpleName().toString();
     }
     return parameter.getSimpleName().toString();
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/JavaWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/JavaWriterTest.java
index c487c89..c4737a1 100644
--- a/compiler/src/test/java/dagger/internal/codegen/JavaWriterTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/JavaWriterTest.java
@@ -326,14 +326,14 @@
 
   @Test public void compressType() throws IOException {
     javaWriter.emitPackage("blah");
-    javaWriter.emitImports(setOf(Set.class.getName(), Binding.class.getName()));
+    javaWriter.emitImports(setOf(Set.class.getCanonicalName(), Binding.class.getCanonicalName()));
     String actual = javaWriter.compressType("java.util.Set<dagger.internal.Binding<blah.Foo.Blah>>");
     assertEquals("Set<Binding<Foo.Blah>>", actual);
   }
 
   @Test public void compressDeeperType() throws IOException {
     javaWriter.emitPackage("blah");
-    javaWriter.emitImports(setOf(Binding.class.getName()));
+    javaWriter.emitImports(setOf(Binding.class.getCanonicalName()));
     String actual = javaWriter.compressType("dagger.internal.Binding<blah.foo.Foo.Blah>");
     assertEquals("Binding<blah.foo.Foo.Blah>", actual);
   }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
index 71fa9b2..f42f19e 100644
--- a/core/src/main/java/dagger/internal/Keys.java
+++ b/core/src/main/java/dagger/internal/Keys.java
@@ -40,10 +40,11 @@
  * and last types.
  */
 public final class Keys {
-  private static final String PROVIDER_PREFIX = Provider.class.getName() + "<";
-  private static final String MEMBERS_INJECTOR_PREFIX = MembersInjector.class.getName() + "<";
-  private static final String LAZY_PREFIX = Lazy.class.getName() + "<";
-  private static final String SET_PREFIX = Set.class.getName() + "<";
+  private static final String PROVIDER_PREFIX = Provider.class.getCanonicalName() + "<";
+  private static final String MEMBERS_INJECTOR_PREFIX =
+      MembersInjector.class.getCanonicalName() + "<";
+  private static final String LAZY_PREFIX = Lazy.class.getCanonicalName() + "<";
+  private static final String SET_PREFIX = Set.class.getCanonicalName() + "<";
 
   private static final LruCache<Class<? extends Annotation>, Boolean> IS_QUALIFIER_ANNOTATION
       = new LruCache<Class<? extends Annotation>, Boolean>(Integer.MAX_VALUE) {
/Fim/
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index 1536275..c7f66e4 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -30,6 +30,7 @@
 
   public static <T> void add(Map<String, Binding<?>> bindings, String elementKey,
       Binding<?> binding) {
+    @SuppressWarnings("unchecked")
     SetBinding<T> elementBinding = (SetBinding<T>) bindings.get(elementKey);
     if (elementBinding == null) {
       elementBinding = new SetBinding<T>(elementKey);
/Fim/
diff --git a/compiler/src/it/cyclic-deps/invoker.properties b/compiler/src/it/cyclic-deps/invoker.properties
new file mode 100644
index 0000000..324b5fb
--- /dev/null
+++ b/compiler/src/it/cyclic-deps/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
\ No newline at end of file
/Fim/
diff --git a/compiler/src/it/cyclic-deps/pom.xml b/compiler/src/it/cyclic-deps/pom.xml
new file mode 100644
index 0000000..c0d5ee7
--- /dev/null
+++ b/compiler/src/it/cyclic-deps/pom.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2013 Square, Inc.
+ Copyright (C) 2013 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.squareup.dagger.tests</groupId>
+  <version>@dagger.version@</version>
+  <packaging>jar</packaging>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
+      </plugin>
+    </plugins>
+  </build>
+  <artifactId>cyclic-deps</artifactId>
+</project>
/Fim/
diff --git a/compiler/src/it/cyclic-deps/src/main/java/test/TestApp.java b/compiler/src/it/cyclic-deps/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..82741d2
--- /dev/null
+++ b/compiler/src/it/cyclic-deps/src/main/java/test/TestApp.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import dagger.Provides;
+import javax.inject.Inject;
+
+class TestApp implements Runnable {
+  
+  static class Foo {
+    @Inject Foo(@SuppressWarnings("unused") Bar b) { }
+  }
+  
+  static class Bar {
+    @Inject Bar(@SuppressWarnings("unused") Blah b) { }
+  }
+  
+  static class Blah {
+    @Inject Blah(@SuppressWarnings("unused") Foo f) { }
+  }
+  
+  static class EntryPoint {
+    @Inject Foo f;
+  }
+
+  @Module(entryPoints = EntryPoint.class)
+  static class TestModule {
+    
+  }
+  
+  static class A { }
+  static class B { }
+  static class C { }
+  static class D { }
+  @Module(entryPoints = D.class)
+  static class CyclicModule {
+    @Provides A a(@SuppressWarnings("unused") D d) { }
+    @Provides B b(@SuppressWarnings("unused") A a) { }
+    @Provides C c(@SuppressWarnings("unused") B b) { }
+    @Provides D d(@SuppressWarnings("unused") C c) { }
+  }
+}
/Fim/
diff --git a/compiler/src/it/cyclic-deps/verify.bsh b/compiler/src/it/cyclic-deps/verify.bsh
new file mode 100644
index 0000000..b014da1
--- /dev/null
+++ b/compiler/src/it/cyclic-deps/verify.bsh
@@ -0,0 +1,9 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "TestApp.java:[43", "Graph validation", "Dependency cycle"});
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "TestApp.java:[52", "Graph validation", "Dependency cycle"});
+    
\ No newline at end of file
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index ffc3489..c3cbb3e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -19,6 +19,7 @@
 import dagger.Provides;
 import dagger.internal.Binding;
 import dagger.internal.Linker;
+import dagger.internal.ProblemDetector;
 import dagger.internal.SetBinding;
 import java.io.IOException;
 import java.io.Writer;
@@ -64,6 +65,10 @@
       // Storing module names for later retrieval as the element instance is invalidated across
       // passes.
       for (Element e : env.getElementsAnnotatedWith(Module.class)) {
+        if (!(e instanceof TypeElement)) {
+          error("@Module applies to a type, " + e.getSimpleName() + " is a " + e.getKind(), e);
+          continue;
+        }
         delayedModuleNames.add(((TypeElement) e).getQualifiedName().toString());
       }
       return true;
@@ -82,9 +87,15 @@
       TypeElement moduleType = (TypeElement) element;
       Map<String, Binding<?>> bindings = processCompleteModule(moduleType);
       try {
+        new ProblemDetector().detectProblems(bindings.values());
+      } catch (IllegalStateException e) {
+        error("Graph validation failed: " + e.getMessage(), moduleType);
+        continue;
+      }
+      try {
         writeDotFile(moduleType, bindings);
       } catch (IOException e) {
-        error("Graph processing failed: " + e, moduleType);
+        error("Graph visualization failed: " + e, moduleType);
       }
     }
     return true;
/Fim/
diff --git a/core/src/main/java/dagger/internal/ProblemDetector.java b/core/src/main/java/dagger/internal/ProblemDetector.java
index e58b51f..42323c9 100644
--- a/core/src/main/java/dagger/internal/ProblemDetector.java
+++ b/core/src/main/java/dagger/internal/ProblemDetector.java
@@ -62,7 +62,7 @@
   }
 
   static class ArraySet<T> extends AbstractSet<T> {
-    private ArrayList<T> list = new ArrayList<T>();
+    private final ArrayList<T> list = new ArrayList<T>();
 
     @Override public boolean add(T t) {
       list.add(t);
/Fim/
diff --git a/compiler/src/it/provides-method-with-throws-clause/invoker.properties b/compiler/src/it/provides-method-with-throws-clause/invoker.properties
new file mode 100644
index 0000000..324b5fb
--- /dev/null
+++ b/compiler/src/it/provides-method-with-throws-clause/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
\ No newline at end of file
/Fim/
diff --git a/compiler/src/it/provides-method-with-throws-clause/pom.xml b/compiler/src/it/provides-method-with-throws-clause/pom.xml
new file mode 100644
index 0000000..f175615
--- /dev/null
+++ b/compiler/src/it/provides-method-with-throws-clause/pom.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2013 Square, Inc.
+ Copyright (C) 2013 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.squareup.dagger.tests</groupId>
+  <artifactId>provides-method-with-throws-clause</artifactId>
+  <version>@dagger.version@</version>
+  <packaging>jar</packaging>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/provides-method-with-throws-clause/src/main/java/test/TestApp.java b/compiler/src/it/provides-method-with-throws-clause/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..60b9762
--- /dev/null
+++ b/compiler/src/it/provides-method-with-throws-clause/src/main/java/test/TestApp.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+
+import dagger.ObjectGraph;
+import dagger.Provides;
+
+import javax.inject.Inject;
+import java.io.IOException;
+import java.lang.Override;
+
+class TestApp implements Runnable {
+
+  @Inject String string;
+
+  @Override public void run() {
+    // Yay! \o/
+  }
+
+  public static void main(String[] args) {
+    ObjectGraph.create(new TestModule()).get(TestApp.class).run();
+  }
+
+  @Module(entryPoints = TestApp.class)
+  static class TestModule {
+
+    @Provides String string() throws IOException {
+      return "string";
+    }
+  }
+}
/Fim/
diff --git a/compiler/src/it/provides-method-with-throws-clause/verify.bsh b/compiler/src/it/provides-method-with-throws-clause/verify.bsh
new file mode 100644
index 0000000..ab61c03
--- /dev/null
+++ b/compiler/src/it/provides-method-with-throws-clause/verify.bsh
@@ -0,0 +1,6 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "@Provides methods must not have a throws clause"});
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 45f1ecc..1ebece3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -131,12 +131,19 @@
         continue;
       }
 
+      ExecutableElement providerMethodAsExecutable = (ExecutableElement) providerMethod;
+      if (!providerMethodAsExecutable.getThrownTypes().isEmpty()) {
+        error("@Provides methods must not have a throws clause: "
+            + type.getQualifiedName() + "." + providerMethod, providerMethod);
+        continue;
+      }
+
       List<ExecutableElement> methods = result.get(type.getQualifiedName().toString());
       if (methods == null) {
         methods = new ArrayList<ExecutableElement>();
         result.put(type.getQualifiedName().toString(), methods);
       }
-      methods.add((ExecutableElement) providerMethod);
+      methods.add(providerMethodAsExecutable);
     }
 
     return result;
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 6a016eb..fb6dc3b 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -307,6 +307,10 @@
       binding.getDependencies(get, injectMembers);
     }
 
+    @Override public boolean isLinked() {
+      return binding.isLinked();
+    }
+
     @Override public String toString() {
       return "@Singleton/" + binding.toString();
     }
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index abd6c6b..b497917 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -728,4 +728,22 @@
       assertThat(e.getMessage()).isEqualTo("foo");
     }
   }
+
+  static class SingletonLinkedFromExtension {
+    @Inject C c; // Singleton.
+  }
+
+  @Module(complete=false, entryPoints=C.class)
+  static class RootModule { }
+
+  @Module(addsTo=RootModule.class, entryPoints=SingletonLinkedFromExtension.class)
+  static class ExtensionModule { }
+
+  @Test public void testSingletonLinkingThroughExtensionGraph() {
+    ObjectGraph root = ObjectGraph.create(new RootModule());
+    // DO NOT CALL root.get(C.class)) HERE to get forced-linking behaviour from plus();
+    ObjectGraph extension = root.plus(new ExtensionModule());
+    assertThat(extension.get(SingletonLinkedFromExtension.class).c).isSameAs(root.get(C.class));
+  }
+
 }
/Fim/
diff --git a/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java b/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
index 3e1cf68..0e0d208 100644
--- a/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
+++ b/androidmanifest/src/test/java/dagger/androidmanifest/ModuleGeneratorTest.java
@@ -23,6 +23,8 @@
 import java.util.Collections;
 import java.util.List;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 import org.w3c.dom.Document;
 import org.xml.sax.InputSource;
 
@@ -30,6 +32,7 @@
 import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
+@RunWith(JUnit4.class)
 public final class ModuleGeneratorTest {
   private final ModuleGenerator generator = new ModuleGenerator();
   private final StringWriter stringWriter = new StringWriter();
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java
index f7a7c58..69a5be4 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/DotWriterTest.java
@@ -18,9 +18,12 @@
 import java.io.IOException;
 import java.io.StringWriter;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.fest.assertions.Assertions.assertThat;
 
+@RunWith(JUnit4.class)
 public final class DotWriterTest {
   private final StringWriter stringWriter = new StringWriter();
   private final DotWriter dotWriter = new DotWriter(stringWriter);
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
index 8f0a135..1a497a9 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
@@ -21,9 +21,12 @@
 import java.util.Set;
 import javax.inject.Named;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.fest.assertions.Assertions.assertThat;
 
+@RunWith(JUnit4.class)
 public final class GraphVisualizerTest {
   private final GraphVisualizer graphVisualizer = new GraphVisualizer();
 
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionTest.java b/core/src/test/java/dagger/ExtensionTest.java
index a4b9c97..b9bd652 100644
--- a/core/src/test/java/dagger/ExtensionTest.java
+++ b/core/src/test/java/dagger/ExtensionTest.java
@@ -20,10 +20,13 @@
 import javax.inject.Inject;
 import javax.inject.Singleton;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.assertNotNull;
 
+@RunWith(JUnit4.class)
 public final class ExtensionTest {
   @Singleton
   static class A {
/Fim/
diff --git a/core/src/test/java/dagger/InjectStaticsTest.java b/core/src/test/java/dagger/InjectStaticsTest.java
index 18d685a..47ad0f9 100644
--- a/core/src/test/java/dagger/InjectStaticsTest.java
+++ b/core/src/test/java/dagger/InjectStaticsTest.java
@@ -18,9 +18,12 @@
 import javax.inject.Inject;
 import org.junit.Before;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.fest.assertions.Assertions.assertThat;
 
+@RunWith(JUnit4.class)
 public final class InjectStaticsTest {
   @Before public void setUp() {
     InjectsOneField.staticField = null;
/Fim/
diff --git a/core/src/test/java/dagger/InjectionOfLazyTest.java b/core/src/test/java/dagger/InjectionOfLazyTest.java
index bb22100..84e208b 100644
--- a/core/src/test/java/dagger/InjectionOfLazyTest.java
+++ b/core/src/test/java/dagger/InjectionOfLazyTest.java
@@ -20,6 +20,8 @@
 import javax.inject.Inject;
 import javax.inject.Provider;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
@@ -27,6 +29,7 @@
 /**
  * Tests of injection of Lazy<T> bindings.
  */
+@RunWith(JUnit4.class)
 public final class InjectionOfLazyTest {
   @Test public void lazyValueCreation() {
     final AtomicInteger counter = new AtomicInteger();
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index b497917..af96bb8 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -26,11 +26,14 @@
 import javax.inject.Provider;
 import javax.inject.Singleton;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
+@RunWith(JUnit4.class)
 public final class InjectionTest {
   @Test public void basicInjection() {
     class TestEntryPoint {
@@ -497,11 +500,12 @@
     }
   }
 
-  @Test public void noConstructorInjectionsForClassesWithTypeParameters() {
-    class Parameterized<T> {
+  static class Parameterized<T> {
       @Inject String string;
     }
 
+  @Test public void noConstructorInjectionsForClassesWithTypeParameters() {
+
     class TestEntryPoint {
       @Inject Parameterized<Long> parameterized;
     }
/Fim/
diff --git a/core/src/test/java/dagger/LazyInjectionTest.java b/core/src/test/java/dagger/LazyInjectionTest.java
index c5a3a42..e80995d 100644
--- a/core/src/test/java/dagger/LazyInjectionTest.java
+++ b/core/src/test/java/dagger/LazyInjectionTest.java
@@ -17,9 +17,12 @@
 
 import javax.inject.Inject;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.fest.assertions.Assertions.assertThat;
 
+@RunWith(JUnit4.class)
 public final class LazyInjectionTest {
   @Test public void getLazyDoesNotCauseEntryPointsToBeLoaded() {
     @Module(entryPoints = LazyEntryPoint.class)
/Fim/
diff --git a/core/src/test/java/dagger/MembersInjectorTest.java b/core/src/test/java/dagger/MembersInjectorTest.java
index 59f2883..1707f17 100644
--- a/core/src/test/java/dagger/MembersInjectorTest.java
+++ b/core/src/test/java/dagger/MembersInjectorTest.java
@@ -19,6 +19,8 @@
 import javax.inject.Provider;
 import javax.inject.Singleton;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.fail;
@@ -27,6 +29,7 @@
  * Tests MembersInjector injection, and how object graph features interact with
  * types unconstructable types (types that support members injection only).
  */
+@RunWith(JUnit4.class)
 public final class MembersInjectorTest {
   @Test public void injectMembers() {
     class TestEntryPoint {
/Fim/
diff --git a/core/src/test/java/dagger/ModuleIncludesTest.java b/core/src/test/java/dagger/ModuleIncludesTest.java
index eec68bb..09d5ab6 100644
--- a/core/src/test/java/dagger/ModuleIncludesTest.java
+++ b/core/src/test/java/dagger/ModuleIncludesTest.java
@@ -17,10 +17,13 @@
 
 import javax.inject.Inject;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
+@RunWith(JUnit4.class)
 public final class ModuleIncludesTest {
   static class TestEntryPoint {
     @Inject String s;
@@ -73,9 +76,6 @@
   }
 
   @Test public void childModuleWithBinding() {
-    class TestEntryPoint {
-      @Inject String s;
-    }
 
     @Module(
         entryPoints = TestEntryPoint.class,
@@ -95,9 +95,6 @@
   }
 
   @Test public void childModuleWithChildModule() {
-    class TestEntryPoint {
-      @Inject String s;
-    }
 
     @Module(
         entryPoints = TestEntryPoint.class,
@@ -138,9 +135,6 @@
   }
 
   @Test public void childModuleWithManualConstruction() {
-    class TestEntryPoint {
-      @Inject String s;
-    }
 
     @Module(
         entryPoints = TestEntryPoint.class,
/Fim/
diff --git a/core/src/test/java/dagger/ProblemDetectorTest.java b/core/src/test/java/dagger/ProblemDetectorTest.java
index 2bd7585..6733698 100644
--- a/core/src/test/java/dagger/ProblemDetectorTest.java
+++ b/core/src/test/java/dagger/ProblemDetectorTest.java
@@ -17,9 +17,12 @@
 
 import javax.inject.Inject;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.junit.Assert.fail;
 
+@RunWith(JUnit4.class)
 public final class ProblemDetectorTest {
   @Test public void atInjectCircularDependenciesDetected() {
     class TestEntryPoint {
/Fim/
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index 7e39135..e837f42 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -27,6 +27,8 @@
 import javax.inject.Named;
 import javax.inject.Singleton;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static dagger.Provides.Type.SET;
 import static org.fest.assertions.Assertions.assertThat;
@@ -34,6 +36,7 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 
+@RunWith(JUnit4.class)
 public final class SetBindingTest {
   @Test public void multiValueBindings_SingleModule() {
     class TestEntryPoint {
/Fim/
diff --git a/core/src/test/java/dagger/internal/KeysTest.java b/core/src/test/java/dagger/internal/KeysTest.java
index d99158a..83c8aaa 100644
--- a/core/src/test/java/dagger/internal/KeysTest.java
+++ b/core/src/test/java/dagger/internal/KeysTest.java
@@ -25,10 +25,13 @@
 import javax.inject.Named;
 import javax.inject.Provider;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static dagger.Provides.Type.SET;
 import static org.fest.assertions.Assertions.assertThat;
 
+@RunWith(JUnit4.class)
 public final class KeysTest {
   int primitive;
   @Test public void lonePrimitiveGetsBoxed() throws NoSuchFieldException {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 1ebece3..ece3c52 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -61,7 +61,7 @@
  * Generates an implementation of {@link ModuleAdapter} that includes a binding
  * for each {@code @Provides} method of a target class.
  */
-@SupportedAnnotationTypes("dagger.Provides")
+@SupportedAnnotationTypes({ "dagger.Provides", "dagger.Module" })
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class ProvidesProcessor extends AbstractProcessor {
   private final LinkedHashMap<String, List<ExecutableElement>> remainingTypes =
@@ -94,7 +94,7 @@
       processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
           "Could not find types required by provides methods for " + remainingTypes.keySet());
     }
-    return true;
+    return false; // FullGraphProcessor needs an opportunity to process.
   }
 
   private void error(String msg, Element element) {
@@ -146,6 +146,15 @@
       methods.add(providerMethodAsExecutable);
     }
 
+    // Catch any stray modules without @Provides since their entry points
+    // should still be registered and a ModuleAdapter should still be written.
+    for (Element type : env.getElementsAnnotatedWith(Module.class)) {
+      if (type.getKind().equals(ElementKind.CLASS)) {
+        String moduleType = ((TypeElement) type).getQualifiedName().toString();
+        if (result.containsKey(moduleType)) continue;
+        result.put(moduleType, new ArrayList<ExecutableElement>());
+      }
+    }
     return result;
   }
 
@@ -184,7 +193,8 @@
     writer.emitEndOfLineComment(ProcessorJavadocs.GENERATED_BY_DAGGER);
     writer.emitPackage(CodeGen.getPackage(type).getQualifiedName().toString());
     writer.emitEmptyLine();
-    writer.emitImports(getImports(multibindings, providerMethodDependencies));
+    writer.emitImports(
+        getImports(multibindings, !providerMethods.isEmpty(), providerMethodDependencies));
 
     String typeName = type.getQualifiedName().toString();
     writer.emitEmptyLine();
@@ -231,47 +241,47 @@
         + "INCLUDES, %s /*complete*/)", overrides, complete);
     writer.endMethod();
 
-    writer.emitEmptyLine();
-    writer.emitJavadoc(ProcessorJavadocs.GET_DEPENDENCIES_METHOD);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod("void", "getBindings", PUBLIC, BINDINGS_MAP, "map");
-
+    ExecutableElement noArgsConstructor = CodeGen.getNoArgsConstructor(type);
+    if (noArgsConstructor != null && CodeGen.isCallableConstructor(noArgsConstructor)) {
+      writer.emitEmptyLine();
+      writer.emitAnnotation(Override.class);
+      writer.beginMethod(typeName, "newModule", PROTECTED);
+      writer.emitStatement("return new %s()", typeName);
+      writer.endMethod();
+    }
+    // caches
     Map<ExecutableElement, String> methodToClassName
         = new LinkedHashMap<ExecutableElement, String>();
     Map<String, AtomicInteger> methodNameToNextId = new LinkedHashMap<String, AtomicInteger>();
-    for (ExecutableElement providerMethod : providerMethods) {
-      Provides provides = providerMethod.getAnnotation(Provides.class);
-      switch (provides.type()) {
-        case UNIQUE: {
-          String key = GeneratorKeys.get(providerMethod);
-          writer.emitStatement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
-              bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
-          break;
-        }
-        case SET: {
-          String key = GeneratorKeys.getElementKey(providerMethod);
-          writer.emitStatement("SetBinding.add(map, %s, new %s(module))",
-              JavaWriter.stringLiteral(key),
-              bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
-          break;
-        }
-        default:
-          throw new AssertionError("Unknown @Provides type " + provides.type());
-      }
-    }
-    writer.endMethod();
 
-    writer.emitEmptyLine();
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod(typeName, "newModule", PROTECTED);
-    ExecutableElement noArgsConstructor = CodeGen.getNoArgsConstructor(type);
-    if (noArgsConstructor != null && CodeGen.isCallableConstructor(noArgsConstructor)) {
-      writer.emitStatement("return new %s()", typeName);
-    } else {
-      writer.emitStatement("throw new UnsupportedOperationException(%s)",
-          JavaWriter.stringLiteral("No no-args constructor on " + type));
+    if (!providerMethods.isEmpty()) {
+      writer.emitEmptyLine();
+      writer.emitJavadoc(ProcessorJavadocs.GET_DEPENDENCIES_METHOD);
+      writer.emitAnnotation(Override.class);
+      writer.beginMethod("void", "getBindings", PUBLIC, BINDINGS_MAP, "map");
+
+      for (ExecutableElement providerMethod : providerMethods) {
+        Provides provides = providerMethod.getAnnotation(Provides.class);
+        switch (provides.type()) {
+          case UNIQUE: {
+            String key = GeneratorKeys.get(providerMethod);
+            writer.emitStatement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
+                bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
+            break;
+          }
+          case SET: {
+            String key = GeneratorKeys.getElementKey(providerMethod);
+            writer.emitStatement("SetBinding.add(map, %s, new %s(module))",
+                JavaWriter.stringLiteral(key),
+                bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
+            break;
+          }
+          default:
+            throw new AssertionError("Unknown @Provides type " + provides.type());
+        }
+      }
+      writer.endMethod();
     }
-    writer.endMethod();
 
     for (ExecutableElement providerMethod : providerMethods) {
       writeProvidesAdapter(writer, providerMethod, methodToClassName, methodNameToNextId);
@@ -281,12 +291,14 @@
     writer.close();
   }
 
-  private Set<String> getImports(boolean multibindings, boolean dependencies) {
+  private Set<String> getImports(boolean multibindings, boolean providers, boolean dependencies) {
     Set<String> imports = new LinkedHashSet<String>();
-    imports.add(Binding.class.getCanonicalName());
-    imports.add(Map.class.getCanonicalName());
-    imports.add(Provider.class.getCanonicalName());
     imports.add(ModuleAdapter.class.getCanonicalName());
+    if (providers) {
+      imports.add(Binding.class.getCanonicalName());
+      imports.add(Map.class.getCanonicalName());
+      imports.add(Provider.class.getCanonicalName());
+    }
     if (dependencies) {
       imports.add(Linker.class.getCanonicalName());
       imports.add(Set.class.getCanonicalName());
/Fim/
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index d4eafb4..c516be1 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -43,13 +43,17 @@
    * Returns bindings for the {@code @Provides} methods of {@code module}. The
    * returned bindings must be linked before they can be used to inject values.
    */
-  public abstract void getBindings(Map<String, Binding<?>> map);
+  public void getBindings(@SuppressWarnings("unused") Map<String, Binding<?>> map) {
+    // no-op;
+  }
 
   /**
    * Returns a new instance of the module class created using a no-args
    * constructor. Only used when a manually-constructed module is not supplied.
    */
-  protected abstract T newModule();
+  protected T newModule() {
+    throw new UnsupportedOperationException("No no-args constructor on " + getClass().getName());
+  }
 
   public T getModule() {
     return module;
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
index ab1e8ec..5a95029 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
@@ -91,7 +91,9 @@
     } catch (InvocationTargetException e) {
       throw new IllegalArgumentException(e.getCause());
     } catch (NoSuchMethodException e) {
-      throw new IllegalArgumentException("Failed to construct " + moduleClass.getName(), e);
+      throw new IllegalArgumentException("Could not construct " + moduleClass.getName()
+          + " as it lacks an accessible no-args constructor. This module must be passed"
+          + " in as an instance, or an accessible no-args constructor must be added.", e);
     } catch (InstantiationException e) {
       throw new IllegalArgumentException("Failed to construct " + moduleClass.getName(), e);
     } catch (IllegalAccessException e) {
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionWithStateTest.java b/core/src/test/java/dagger/ExtensionWithStateTest.java
new file mode 100644
index 0000000..2c17f85
--- /dev/null
+++ b/core/src/test/java/dagger/ExtensionWithStateTest.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2013 Google Inc.
+ * Copyright (C) 2013 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import javax.inject.Inject;
+import org.junit.Test;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+public final class ExtensionWithStateTest {
+  static class A { }
+
+  static class B {
+    @Inject A a;
+  }
+
+  @Module(
+      entryPoints = A.class, // for testing
+      complete = false
+  )
+  static class RootModule {
+    final A a;
+    RootModule(A a) {
+      this.a = a;
+    }
+    @Provides A provideA() { return a; }
+  }
+
+  @Module(addsTo = RootModule.class, entryPoints = { B.class })
+  static class ExtensionModule { }
+
+  @Test public void basicInjectionWithExtension() {
+    A a = new A();
+    ObjectGraph root = ObjectGraph.create(new RootModule(a));
+    assertThat(root.get(A.class)).isSameAs(a);
+
+    // Extension graph behaves as the root graph would for root-ish things.
+    ObjectGraph extension = root.plus(new ExtensionModule());
+    assertThat(extension.get(A.class)).isSameAs(a);
+    assertThat(extension.get(B.class).a).isSameAs(a);
+  }
+
+}
/Fim/
diff --git a/core/src/test/java/dagger/ExtensionWithStateTest.java b/core/src/test/java/dagger/ExtensionWithStateTest.java
index 2c17f85..af485b3 100644
--- a/core/src/test/java/dagger/ExtensionWithStateTest.java
+++ b/core/src/test/java/dagger/ExtensionWithStateTest.java
@@ -18,9 +18,12 @@
 
 import javax.inject.Inject;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.fest.assertions.Assertions.assertThat;
 
+@RunWith(JUnit4.class)
 public final class ExtensionWithStateTest {
   static class A { }
 
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 6bb906d..df9860a 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -60,29 +60,53 @@
  *   <li>Circular dependencies.</li>
  * </ul>
  */
-public final class ObjectGraph {
-  private final ObjectGraph base;
-  private final Linker linker;
-  private final Map<Class<?>, StaticInjection> staticInjections;
-  private final Map<String, Class<?>> entryPoints;
-  private final Plugin plugin;
+public abstract class ObjectGraph {
 
-  ObjectGraph(ObjectGraph base,
-      Linker linker,
-      Plugin plugin,
-      Map<Class<?>, StaticInjection> staticInjections,
-      Map<String, Class<?>> entryPoints) {
-    if (linker == null) throw new NullPointerException("linker");
-    if (plugin == null) throw new NullPointerException("plugin");
-    if (staticInjections == null) throw new NullPointerException("staticInjections");
-    if (entryPoints == null) throw new NullPointerException("entryPoints");
+  /**
+   * Returns an instance of {@code type}.
+   *
+   * @throws IllegalArgumentException if {@code type} is not one of this object
+   *     graph's entry point types.
+   */
+  public abstract <T> T get(Class<T> type);
 
-    this.base = base;
-    this.linker = linker;
-    this.plugin = plugin;
-    this.staticInjections = staticInjections;
-    this.entryPoints = entryPoints;
-  }
+  /**
+   * Injects the members of {@code instance}, including injectable members
+   * inherited from its supertypes.
+   *
+   * @throws IllegalArgumentException if the runtime type of {@code instance} is
+   *     not one of this object graph's entry point types.
+   */
+  public abstract <T> T inject(T instance);
+
+  /**
+   * Returns a new object graph that includes all of the objects in this graph,
+   * plus additional objects in the {@literal @}{@link Module}-annotated
+   * modules. This graph is a subgraph of the returned graph.
+   *
+   * <p>The current graph is not modified by this operation: its objects and the
+   * dependency links between them are unchanged. But this graph's objects may
+   * be shared by both graphs. For example, the singletons of this graph may be
+   * injected and used by the returned graph.
+   *
+   * <p>This <strong>does not</strong> inject any members or validate the graph.
+   * See {@link #create} for guidance on injection and validation.
+   */
+  public abstract ObjectGraph plus(Object... modules);
+
+  /**
+   * Do runtime graph problem detection. For fastest graph creation, rely on
+   * build time tools for graph validation.
+   *
+   * @throws IllegalStateException if this graph has problems.
+   */
+  public abstract void validate();
+
+  /**
+   * Injects the static fields of the classes listed in the object graph's
+   * {@code staticInjections} property.
+   */
+  public abstract void injectStatics();
 
   /**
    * Returns a new dependency graph using the {@literal @}{@link
@@ -100,171 +124,162 @@
   public static ObjectGraph create(Object... modules) {
     RuntimeAggregatingPlugin plugin = new RuntimeAggregatingPlugin(
             new ClassloadingPlugin(), new ReflectivePlugin());
-    return makeGraph(null, plugin, modules);
+    return DaggerObjectGraph.makeGraph(null, plugin, modules);
   }
 
-  private static ObjectGraph makeGraph(ObjectGraph base, Plugin plugin, Object... modules) {
-    Map<String, Class<?>> entryPoints = new LinkedHashMap<String, Class<?>>();
-    Map<Class<?>, StaticInjection> staticInjections
-        = new LinkedHashMap<Class<?>, StaticInjection>();
+  static class DaggerObjectGraph extends ObjectGraph {
 
-    // Extract bindings in the 'base' and 'overrides' set. Within each set no
-    // duplicates are permitted.
-    Map<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>();
-    Map<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>();
-    for (ModuleAdapter<?> moduleAdapter : getAllModuleAdapters(plugin, modules).values()) {
-      for (String key : moduleAdapter.entryPoints) {
-        entryPoints.put(key, moduleAdapter.getModule().getClass());
+    private final DaggerObjectGraph base;
+    private final Linker linker;
+    private final Map<Class<?>, StaticInjection> staticInjections;
+    private final Map<String, Class<?>> entryPoints;
+    private final Plugin plugin;
+
+    DaggerObjectGraph(DaggerObjectGraph base,
+        Linker linker,
+        Plugin plugin,
+        Map<Class<?>, StaticInjection> staticInjections,
+        Map<String, Class<?>> entryPoints) {
+      if (linker == null) throw new NullPointerException("linker");
+      if (plugin == null) throw new NullPointerException("plugin");
+      if (staticInjections == null) throw new NullPointerException("staticInjections");
+      if (entryPoints == null) throw new NullPointerException("entryPoints");
+
+      this.base = base;
+      this.linker = linker;
+      this.plugin = plugin;
+      this.staticInjections = staticInjections;
+      this.entryPoints = entryPoints;
+    }
+
+    private static ObjectGraph makeGraph(DaggerObjectGraph base, Plugin plugin, Object... modules) {
+      Map<String, Class<?>> entryPoints = new LinkedHashMap<String, Class<?>>();
+      Map<Class<?>, StaticInjection> staticInjections
+          = new LinkedHashMap<Class<?>, StaticInjection>();
+
+      // Extract bindings in the 'base' and 'overrides' set. Within each set no
+      // duplicates are permitted.
+      Map<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>();
+      Map<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>();
+      for (ModuleAdapter<?> moduleAdapter : getAllModuleAdapters(plugin, modules).values()) {
+        for (String key : moduleAdapter.entryPoints) {
+          entryPoints.put(key, moduleAdapter.getModule().getClass());
+        }
+        for (Class<?> c : moduleAdapter.staticInjections) {
+          staticInjections.put(c, null);
+        }
+        Map<String, Binding<?>> addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
+        moduleAdapter.getBindings(addTo);
       }
-      for (Class<?> c : moduleAdapter.staticInjections) {
-        staticInjections.put(c, null);
+
+      // Create a linker and install all of the user's bindings
+      Linker linker = new Linker((base != null) ? base.linker : null, plugin,
+          new ThrowingErrorHandler());
+      linker.installBindings(baseBindings);
+      linker.installBindings(overrideBindings);
+
+      return new DaggerObjectGraph(base, linker, plugin, staticInjections, entryPoints);
+    }
+
+
+    @Override public ObjectGraph plus(Object... modules) {
+      linkEverything();
+      return makeGraph(this, plugin, modules);
+    }
+
+
+    private void linkStaticInjections() {
+      for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
+        StaticInjection staticInjection = entry.getValue();
+        if (staticInjection == null) {
+          staticInjection = plugin.getStaticInjection(entry.getKey());
+          entry.setValue(staticInjection);
+        }
+        staticInjection.attach(linker);
       }
-      Map<String, Binding<?>> addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
-      moduleAdapter.getBindings(addTo);
     }
 
-    // Create a linker and install all of the user's bindings
-    Linker linker = new Linker((base != null) ? base.linker : null, plugin,
-        new ThrowingErrorHandler());
-    linker.installBindings(baseBindings);
-    linker.installBindings(overrideBindings);
-
-    return new ObjectGraph(base, linker, plugin, staticInjections, entryPoints);
-  }
-
-  /**
-   * Returns a new object graph that includes all of the objects in this graph,
-   * plus additional objects in the {@literal @}{@link Module}-annotated
-   * modules. This graph is a subgraph of the returned graph.
-   *
-   * <p>The current graph is not modified by this operation: its objects and the
-   * dependency links between them are unchanged. But this graph's objects may
-   * be shared by both graphs. For example, the singletons of this graph may be
-   * injected and used by the returned graph.
-   *
-   * <p>This <strong>does not</strong> inject any members or validate the graph.
-   * See {@link #create} for guidance on injection and validation.
-   */
-  public ObjectGraph plus(Object... modules) {
-    linkEverything();
-    return makeGraph(this, plugin, modules);
-  }
-
-
-  private void linkStaticInjections() {
-    for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
-      StaticInjection staticInjection = entry.getValue();
-      if (staticInjection == null) {
-        staticInjection = plugin.getStaticInjection(entry.getKey());
-        entry.setValue(staticInjection);
+    private void linkEntryPoints() {
+      for (Map.Entry<String, Class<?>> entry : entryPoints.entrySet()) {
+        linker.requestBinding(entry.getKey(), entry.getValue(), false);
       }
-      staticInjection.attach(linker);
-    }
-  }
-
-  private void linkEntryPoints() {
-    for (Map.Entry<String, Class<?>> entry : entryPoints.entrySet()) {
-      linker.requestBinding(entry.getKey(), entry.getValue(), false);
-    }
-  }
-
-  /**
-   * Do runtime graph problem detection. For fastest graph creation, rely on
-   * build time tools for graph validation.
-   *
-   * @throws IllegalStateException if this graph has problems.
-   */
-  public void validate() {
-    Map<String, Binding<?>> allBindings = linkEverything();
-    new ProblemDetector().detectProblems(allBindings.values());
-  }
-
-  /**
-   * Links all bindings, entry points and static injections.
-   */
-  private Map<String, Binding<?>> linkEverything() {
-    synchronized (linker) {
-      linkStaticInjections();
-      linkEntryPoints();
-      return linker.linkAll();
-    }
-  }
-
-  /**
-   * Injects the static fields of the classes listed in the object graph's
-   * {@code staticInjections} property.
-   */
-  public void injectStatics() {
-    // We call linkStaticInjections() twice on purpose. The first time through
-    // we request all of the bindings we need. The linker returns null for
-    // bindings it doesn't have. Then we ask the linker to link all of those
-    // requested bindings. Finally we call linkStaticInjections() again: this
-    // time the linker won't return null because everything has been linked.
-    synchronized (linker) {
-      linkStaticInjections();
-      linker.linkRequested();
-      linkStaticInjections();
     }
 
-    for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
-      entry.getValue().inject();
-    }
-  }
-
-  /**
-   * Returns an instance of {@code type}.
-   *
-   * @throws IllegalArgumentException if {@code type} is not one of this object
-   *     graph's entry point types.
-   */
-  public <T> T get(Class<T> type) {
-    String key = Keys.get(type);
-    String entryPointKey = Keys.getMembersKey(type);
-    @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
-    Binding<T> binding = (Binding<T>) getEntryPointBinding(entryPointKey, key);
-    return binding.get();
-  }
-
-  /**
-   * Injects the members of {@code instance}, including injectable members
-   * inherited from its supertypes.
-   *
-   * @throws IllegalArgumentException if the runtime type of {@code instance} is
-   *     not one of this object graph's entry point types.
-   */
-  public <T> T inject(T instance) {
-    String membersKey = Keys.getMembersKey(instance.getClass());
-    @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
-    Binding<Object> binding = (Binding<Object>) getEntryPointBinding(membersKey, membersKey);
-    binding.injectMembers(instance);
-    return instance;
-  }
-
-  /**
-   * @param entryPointKey the key used to store the entry point. This is always
-   *     a members injection key because those keys can always be created, even
-   *     if the type has no injectable constructor.
-   * @param key the key to use when retrieving the binding. This may be a
-   *     regular (provider) key or a members key.
-   */
-  private Binding<?> getEntryPointBinding(String entryPointKey, String key) {
-    Class<?> moduleClass = null;
-    for (ObjectGraph graph = this; graph != null; graph = graph.base) {
-      moduleClass = graph.entryPoints.get(entryPointKey);
-      if (moduleClass != null) break;
-    }
-    if (moduleClass == null) {
-      throw new IllegalArgumentException("No entry point for " + entryPointKey
-          + ". You must explicitly add an entry point to one of your modules.");
+    @Override public void validate() {
+      Map<String, Binding<?>> allBindings = linkEverything();
+      new ProblemDetector().detectProblems(allBindings.values());
     }
 
-    synchronized (linker) {
-      Binding<?> binding = linker.requestBinding(key, moduleClass, false);
-      if (binding == null || !binding.isLinked()) {
+    /**
+     * Links all bindings, entry points and static injections.
+     */
+    private Map<String, Binding<?>> linkEverything() {
+      synchronized (linker) {
+        linkStaticInjections();
+        linkEntryPoints();
+        return linker.linkAll();
+      }
+    }
+
+    @Override public void injectStatics() {
+      // We call linkStaticInjections() twice on purpose. The first time through
+      // we request all of the bindings we need. The linker returns null for
+      // bindings it doesn't have. Then we ask the linker to link all of those
+      // requested bindings. Finally we call linkStaticInjections() again: this
+      // time the linker won't return null because everything has been linked.
+      synchronized (linker) {
+        linkStaticInjections();
         linker.linkRequested();
-        binding = linker.requestBinding(key, moduleClass, false);
+        linkStaticInjections();
       }
-      return binding;
+
+      for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
+        entry.getValue().inject();
+      }
+    }
+
+    @Override public <T> T get(Class<T> type) {
+      String key = Keys.get(type);
+      String entryPointKey = Keys.getMembersKey(type);
+      @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
+      Binding<T> binding = (Binding<T>) getEntryPointBinding(entryPointKey, key);
+      return binding.get();
+    }
+
+    @Override public <T> T inject(T instance) {
+      String membersKey = Keys.getMembersKey(instance.getClass());
+      @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
+      Binding<Object> binding = (Binding<Object>) getEntryPointBinding(membersKey, membersKey);
+      binding.injectMembers(instance);
+      return instance;
+    }
+
+    /**
+     * @param entryPointKey the key used to store the entry point. This is always
+     *     a members injection key because those keys can always be created, even
+     *     if the type has no injectable constructor.
+     * @param key the key to use when retrieving the binding. This may be a
+     *     regular (provider) key or a members key.
+     */
+    private Binding<?> getEntryPointBinding(String entryPointKey, String key) {
+      Class<?> moduleClass = null;
+      for (DaggerObjectGraph graph = this; graph != null; graph = graph.base) {
+        moduleClass = graph.entryPoints.get(entryPointKey);
+        if (moduleClass != null) break;
+      }
+      if (moduleClass == null) {
+        throw new IllegalArgumentException("No entry point for " + entryPointKey
+            + ". You must explicitly add an entry point to one of your modules.");
+      }
+
+      synchronized (linker) {
+        Binding<?> binding = linker.requestBinding(key, moduleClass, false);
+        if (binding == null || !binding.isLinked()) {
+          linker.linkRequested();
+          binding = linker.requestBinding(key, moduleClass, false);
+        }
+        return binding;
+      }
     }
   }
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index c3cbb3e..88dceac 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -34,7 +34,6 @@
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
-import javax.annotation.processing.SupportedSourceVersion;
 import javax.inject.Singleton;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
@@ -52,10 +51,13 @@
  * Performs full graph analysis on a module.
  */
 @SupportedAnnotationTypes("dagger.Module")
-@SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class FullGraphProcessor extends AbstractProcessor {
   private final Set<String> delayedModuleNames = new LinkedHashSet<String>();
 
+  @Override public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+
   /**
    * Perform full-graph analysis on complete modules. This checks that all of
    * the module's dependencies are satisfied.
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index e1d9046..530f39b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -30,7 +30,6 @@
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
-import javax.annotation.processing.SupportedSourceVersion;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.inject.Singleton;
@@ -58,10 +57,13 @@
  * {@literal @}{@code Inject}-annotated members of a class.
  */
 @SupportedAnnotationTypes("javax.inject.Inject")
-@SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class InjectProcessor extends AbstractProcessor {
   private final Set<String> remainingTypeNames = new LinkedHashSet<String>();
 
+  @Override public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+
   @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
     remainingTypeNames.addAll(getInjectedClassNames(env));
     for (Iterator<String> i = remainingTypeNames.iterator(); i.hasNext();) {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index ece3c52..77c52db 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -35,7 +35,6 @@
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
-import javax.annotation.processing.SupportedSourceVersion;
 import javax.inject.Provider;
 import javax.inject.Singleton;
 import javax.lang.model.SourceVersion;
@@ -62,13 +61,16 @@
  * for each {@code @Provides} method of a target class.
  */
 @SupportedAnnotationTypes({ "dagger.Provides", "dagger.Module" })
-@SupportedSourceVersion(SourceVersion.RELEASE_6)
 public final class ProvidesProcessor extends AbstractProcessor {
   private final LinkedHashMap<String, List<ExecutableElement>> remainingTypes =
       new LinkedHashMap<String, List<ExecutableElement>>();
   private static final String BINDINGS_MAP = JavaWriter.type(
       Map.class, String.class.getCanonicalName(), Binding.class.getCanonicalName() + "<?>");
 
+  @Override public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+
   // TODO: include @Provides methods from the superclass
   @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
     remainingTypes.putAll(providerMethodsByClass(env));
/Fim/
diff --git a/compiler/src/it/cyclic-deps/pom.xml b/compiler/src/it/cyclic-deps/pom.xml
index d213a7a..d95abc0 100644
--- a/compiler/src/it/cyclic-deps/pom.xml
+++ b/compiler/src/it/cyclic-deps/pom.xml
@@ -30,18 +30,25 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.0</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
+          <forceJavacCompilerUse>true</forceJavacCompilerUse>
+        </configuration>
+        <dependencies>
+          <dependency>
+            <groupId>@dagger.groupId@</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>@dagger.version@</version>
+          </dependency>
+        </dependencies>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/cyclic-deps/src/main/java/test/TestApp.java b/compiler/src/it/cyclic-deps/src/main/java/test/TestApp.java
index 82741d2..274d733 100644
--- a/compiler/src/it/cyclic-deps/src/main/java/test/TestApp.java
+++ b/compiler/src/it/cyclic-deps/src/main/java/test/TestApp.java
@@ -21,7 +21,7 @@
 import dagger.Provides;
 import javax.inject.Inject;
 
-class TestApp implements Runnable {
+class TestApp {
   
   static class Foo {
     @Inject Foo(@SuppressWarnings("unused") Bar b) { }
@@ -50,9 +50,9 @@
   static class D { }
   @Module(entryPoints = D.class)
   static class CyclicModule {
-    @Provides A a(@SuppressWarnings("unused") D d) { }
-    @Provides B b(@SuppressWarnings("unused") A a) { }
-    @Provides C c(@SuppressWarnings("unused") B b) { }
-    @Provides D d(@SuppressWarnings("unused") C c) { }
+    @Provides A a(@SuppressWarnings("unused") D d) { return null; }
+    @Provides B b(@SuppressWarnings("unused") A a) { return null; }
+    @Provides C c(@SuppressWarnings("unused") B b) { return null; }
+    @Provides D d(@SuppressWarnings("unused") C c) { return null; }
   }
 }
/Fim/
diff --git a/compiler/src/it/default-package-injected-type/pom.xml b/compiler/src/it/default-package-injected-type/pom.xml
index ee7e557..e340e06 100644
--- a/compiler/src/it/default-package-injected-type/pom.xml
+++ b/compiler/src/it/default-package-injected-type/pom.xml
@@ -30,18 +30,25 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.0</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
+          <forceJavacCompilerUse>true</forceJavacCompilerUse>
+        </configuration>
+        <dependencies>
+          <dependency>
+            <groupId>@dagger.groupId@</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>@dagger.version@</version>
+          </dependency>
+        </dependencies>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/extension-graph/pom.xml b/compiler/src/it/extension-graph/pom.xml
index 76bde1e..be602c6 100644
--- a/compiler/src/it/extension-graph/pom.xml
+++ b/compiler/src/it/extension-graph/pom.xml
@@ -30,18 +30,25 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.0</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
+          <forceJavacCompilerUse>true</forceJavacCompilerUse>
+        </configuration>
+        <dependencies>
+          <dependency>
+            <groupId>@dagger.groupId@</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>@dagger.version@</version>
+          </dependency>
+        </dependencies>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/include-non-module/pom.xml b/compiler/src/it/include-non-module/pom.xml
index 7d2993d..08ec774 100644
--- a/compiler/src/it/include-non-module/pom.xml
+++ b/compiler/src/it/include-non-module/pom.xml
@@ -30,18 +30,25 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.0</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
+          <forceJavacCompilerUse>true</forceJavacCompilerUse>
+        </configuration>
+        <dependencies>
+          <dependency>
+            <groupId>@dagger.groupId@</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>@dagger.version@</version>
+          </dependency>
+        </dependencies>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/inject-parameterized-type/pom.xml b/compiler/src/it/inject-parameterized-type/pom.xml
index 7b6bc48..ad37203 100644
--- a/compiler/src/it/inject-parameterized-type/pom.xml
+++ b/compiler/src/it/inject-parameterized-type/pom.xml
@@ -30,18 +30,25 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.0</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
+          <forceJavacCompilerUse>true</forceJavacCompilerUse>
+        </configuration>
+        <dependencies>
+          <dependency>
+            <groupId>@dagger.groupId@</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>@dagger.version@</version>
+          </dependency>
+        </dependencies>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/inner-classes-complaint-injection/pom.xml b/compiler/src/it/inner-classes-complaint-injection/pom.xml
index ff2dd01..ecaf63e 100644
--- a/compiler/src/it/inner-classes-complaint-injection/pom.xml
+++ b/compiler/src/it/inner-classes-complaint-injection/pom.xml
@@ -29,18 +29,25 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.0</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
+          <forceJavacCompilerUse>true</forceJavacCompilerUse>
+        </configuration>
+        <dependencies>
+          <dependency>
+            <groupId>@dagger.groupId@</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>@dagger.version@</version>
+          </dependency>
+        </dependencies>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/missing-at-inject-constructor/pom.xml b/compiler/src/it/missing-at-inject-constructor/pom.xml
index 4d9e947..063eb41 100644
--- a/compiler/src/it/missing-at-inject-constructor/pom.xml
+++ b/compiler/src/it/missing-at-inject-constructor/pom.xml
@@ -30,18 +30,25 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.0</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
+          <forceJavacCompilerUse>true</forceJavacCompilerUse>
+        </configuration>
+        <dependencies>
+          <dependency>
+            <groupId>@dagger.groupId@</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>@dagger.version@</version>
+          </dependency>
+        </dependencies>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/multiple-provides-methods/pom.xml b/compiler/src/it/multiple-provides-methods/pom.xml
index 45fcba0..ac580be 100644
--- a/compiler/src/it/multiple-provides-methods/pom.xml
+++ b/compiler/src/it/multiple-provides-methods/pom.xml
@@ -30,18 +30,25 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.0</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
+          <forceJavacCompilerUse>true</forceJavacCompilerUse>
+        </configuration>
+        <dependencies>
+          <dependency>
+            <groupId>@dagger.groupId@</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>@dagger.version@</version>
+          </dependency>
+        </dependencies>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/provides-method-with-throws-clause/pom.xml b/compiler/src/it/provides-method-with-throws-clause/pom.xml
index 7063ecc..c969dc8 100644
--- a/compiler/src/it/provides-method-with-throws-clause/pom.xml
+++ b/compiler/src/it/provides-method-with-throws-clause/pom.xml
@@ -30,18 +30,25 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.0</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
+          <forceJavacCompilerUse>true</forceJavacCompilerUse>
+        </configuration>
+        <dependencies>
+          <dependency>
+            <groupId>@dagger.groupId@</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>@dagger.version@</version>
+          </dependency>
+        </dependencies>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/same-provides-method-name/pom.xml b/compiler/src/it/same-provides-method-name/pom.xml
index 2c41239..28003fb 100644
--- a/compiler/src/it/same-provides-method-name/pom.xml
+++ b/compiler/src/it/same-provides-method-name/pom.xml
@@ -30,18 +30,25 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.0</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
+          <forceJavacCompilerUse>true</forceJavacCompilerUse>
+        </configuration>
+        <dependencies>
+          <dependency>
+            <groupId>@dagger.groupId@</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>@dagger.version@</version>
+          </dependency>
+        </dependencies>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/simple-missing-dependency-failure/pom.xml b/compiler/src/it/simple-missing-dependency-failure/pom.xml
index 1ec794d..1299081 100644
--- a/compiler/src/it/simple-missing-dependency-failure/pom.xml
+++ b/compiler/src/it/simple-missing-dependency-failure/pom.xml
@@ -29,20 +29,27 @@
     <dependency>
       <groupId>@dagger.groupId@</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
-      <optional>true</optional>
+      <version>@dagger.version@</version>
     </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.0</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
+          <forceJavacCompilerUse>true</forceJavacCompilerUse>
+        </configuration>
+        <dependencies>
+          <dependency>
+            <groupId>@dagger.groupId@</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>@dagger.version@</version>
+          </dependency>
+        </dependencies>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/uninjectable-supertype/pom.xml b/compiler/src/it/uninjectable-supertype/pom.xml
index 451108d..2ca553c 100644
--- a/compiler/src/it/uninjectable-supertype/pom.xml
+++ b/compiler/src/it/uninjectable-supertype/pom.xml
@@ -30,18 +30,25 @@
       <artifactId>dagger</artifactId>
       <version>@dagger.version@</version>
     </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
   </dependencies>
   <build>
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.0</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
+          <forceJavacCompilerUse>true</forceJavacCompilerUse>
+        </configuration>
+        <dependencies>
+          <dependency>
+            <groupId>@dagger.groupId@</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>@dagger.version@</version>
+          </dependency>
+        </dependencies>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 0a25a1a..b05e936 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -32,12 +32,6 @@
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
-    <dependency>
-      <groupId>com.squareup.dagger</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
-      <optional>true</optional>
-    </dependency>
   </dependencies>
   <build>
     <plugins>
@@ -47,7 +41,16 @@
           <compilerArgument>-Xlint:all</compilerArgument>
           <showWarnings>true</showWarnings>
           <showDeprecation>true</showDeprecation>
+          <!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
+          <forceJavacCompilerUse>true</forceJavacCompilerUse>
         </configuration>
+        <dependencies>
+          <dependency>
+            <groupId>com.squareup.dagger</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>${project.version}</version>
+          </dependency>
+        </dependencies>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/pom.xml b/pom.xml
index cdee511..ea3112a 100644
--- a/pom.xml
+++ b/pom.xml
@@ -122,7 +122,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
-        <version>2.5</version>
+        <version>3.0</version>
         <configuration>
           <source>${java.version}</source>
           <target>${java.version}</target>
/Fim/
diff --git a/website/index.html b/website/index.html
index 5aa5899..18fc39a 100644
--- a/website/index.html
+++ b/website/index.html
@@ -380,6 +380,11 @@
   &lt;plugins>
     &lt;plugin>
       &lt;artifactId>maven-compiler-plugin&lt;/artifactId>
+      &lt;version>3.0&lt;/version>
+      &lt;configuration>
+        &lt; workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->
+        &lt;forceJavacCompilerUse>true&lt;/forceJavacCompilerUse>
+      &lt;/configuration>
       &lt;dependencies>
         &lt;dependency>
           &lt;groupId>com.squareup&lt;/groupId>
/Fim/
diff --git a/checkstyle.xml b/checkstyle.xml
index 4f5575c..40c2b1c 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -100,7 +100,6 @@
         <!-- See http://checkstyle.sf.net/config_coding.html -->
         <!--module name="AvoidInlineConditionals"/-->
         <module name="CovariantEquals"/>
-        <module name="DoubleCheckedLocking"/>
         <module name="EmptyStatement"/>
         <!--<module name="EqualsAvoidNull"/>-->
         <module name="EqualsHashCode"/>
/Fim/
diff --git a/core/src/main/java/dagger/internal/LazyBinding.java b/core/src/main/java/dagger/internal/LazyBinding.java
index a3bacc3..0bcbc97 100644
--- a/core/src/main/java/dagger/internal/LazyBinding.java
+++ b/core/src/main/java/dagger/internal/LazyBinding.java
@@ -40,18 +40,25 @@
   }
 
   @Override public void injectMembers(Lazy<T> t) {
-    throw new UnsupportedOperationException(); // not a member injection binding.
+    throw new UnsupportedOperationException(); // Injecting into a custom Lazy not supported.
   }
 
   @Override
   public Lazy<T> get() {
     return new Lazy<T>() {
-      private Object cacheValue = NOT_PRESENT;
+      private volatile Object cacheValue = NOT_PRESENT;
 
       @SuppressWarnings("unchecked") // Delegate is of type T
       @Override
       public T get() {
-        return (T) ((cacheValue != NOT_PRESENT) ? cacheValue : (cacheValue = delegate.get()));
+        if (cacheValue == NOT_PRESENT) {
+          synchronized (this) {
+            if (cacheValue == NOT_PRESENT) {
+              cacheValue = delegate.get();
+            }
+          }
+        }
+        return (T) cacheValue;
       }
     };
   }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 18115ca..fe1be29 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -279,7 +279,7 @@
    */
   private static class SingletonBinding<T> extends Binding<T> {
     private final Binding<T> binding;
-    private Object onlyInstance = UNINITIALIZED;
+    private volatile Object onlyInstance = UNINITIALIZED;
 
     private SingletonBinding(Binding<T> binding) {
       super(binding.provideKey, binding.membersKey, true, binding.requiredBy);
@@ -296,9 +296,12 @@
 
     @SuppressWarnings("unchecked") // onlyInstance is either 'UNINITIALIZED' or a 'T'.
     @Override public T get() {
-      // TODO (cgruber): Fix concurrency risk.
       if (onlyInstance == UNINITIALIZED) {
-        onlyInstance = binding.get();
+        synchronized (this) {
+          if (onlyInstance == UNINITIALIZED) {
+            onlyInstance = binding.get();
+          }
+        }
       }
       return (T) onlyInstance;
     }
/Fim/
diff --git a/core/src/test/java/dagger/ThreadSafetyTest.java b/core/src/test/java/dagger/ThreadSafetyTest.java
new file mode 100644
index 0000000..c30a580
--- /dev/null
+++ b/core/src/test/java/dagger/ThreadSafetyTest.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2013 Google Inc.
+ * Copyright (C) 2013 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static org.fest.assertions.Assertions.assertThat;
+
+/**
+ * Test Singleton and Lazy bindings for thread-safety.
+ */
+@RunWith(JUnit4.class)
+public final class ThreadSafetyTest {
+  private static final Integer FIRST_VALUE = 0;
+  private static final int THREAD_COUNT = 100;
+
+  private final ExecutorService es = Executors.newFixedThreadPool(THREAD_COUNT);
+  private final CountDownLatch latch = new CountDownLatch(THREAD_COUNT + 1);
+
+
+  static class LazyEntryPoint {
+    @Inject Lazy<Integer> lazy;
+  }
+
+  @Module(entryPoints = { Long.class, LazyEntryPoint.class })
+  static class LatchingModule {
+    private final AtomicInteger count = new AtomicInteger(FIRST_VALUE);
+    private final CountDownLatch latch;
+    LatchingModule(CountDownLatch latch) {
+      this.latch = latch;
+    }
+
+    @Provides @Singleton Long provideLong() {
+      return Long.valueOf(provideInteger());
+    }
+
+    @Provides Integer provideInteger() {
+      try {
+        latch.await();
+      } catch (InterruptedException e) {
+        throw new AssertionError("Interrupted Thread!!");
+      }
+      return count.getAndIncrement();
+    }
+  }
+
+  @Test public void concurrentSingletonAccess() throws Exception {
+    final List<Future<Long>> futures = new ArrayList<Future<Long>>();
+    final ObjectGraph graph = ObjectGraph.create(new LatchingModule(latch));
+    for (int i = 0; i < THREAD_COUNT; i++) {
+      futures.add(es.submit(new Callable<Long>() {
+        @Override public Long call() {
+          latch.countDown();
+          return graph.get(Long.class);
+        }
+      }));
+    }
+    latch.countDown();
+    for (Future<Long> future : futures) {
+      assertThat(future.get(1, TimeUnit.SECONDS))
+          .overridingErrorMessage("Lock failure - count should never increment")
+          .isEqualTo(0);
+    }
+  }
+
+  @Test public void concurrentLazyAccess() throws Exception {
+    final List<Future<Integer>> futures = new ArrayList<Future<Integer>>();
+    final ObjectGraph graph = ObjectGraph.create(new LatchingModule(latch));
+    final LazyEntryPoint lep = graph.get(LazyEntryPoint.class);
+    for (int i = 0; i < THREAD_COUNT; i++) {
+      futures.add(es.submit(new Callable<Integer>() {
+        @Override public Integer call() {
+          latch.countDown();
+          return lep.lazy.get();
+        }
+      }));
+    }
+    latch.countDown();
+    for (Future<Integer> future : futures) {
+      assertThat(future.get(1, TimeUnit.SECONDS))
+          .overridingErrorMessage("Lock failure - count should never increment")
+          .isEqualTo(0);
+    }
+  }
+}
/Fim/
diff --git a/pom.xml b/pom.xml
index ea3112a..c97fc2d 100644
--- a/pom.xml
+++ b/pom.xml
@@ -144,7 +144,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.9.1</version>
+        <version>2.10</version>
         <configuration>
           <failsOnError>true</failsOnError>
           <consoleOutput>true</consoleOutput>
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 88dceac..1911fef 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -146,10 +146,13 @@
             case UNIQUE:
               ProviderMethodBinding clobbered = (ProviderMethodBinding) addTo.put(key, binding);
               if (clobbered != null) {
-                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
-                    "Duplicate bindings for " + key
-                        + ": " + shortMethodName(clobbered.method)
-                        + ", " + shortMethodName(binding.method),
+                String msg = "Duplicate bindings for " + key;
+                if (overrides) {
+                  msg += " in override module(s) - cannot override an override";
+                }
+                msg += ": " + shortMethodName(clobbered.method)
+                    + ", " + shortMethodName(binding.method);
+                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg,
                     binding.method);
               }
               break;
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 1911fef..b048f82 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -22,6 +22,8 @@
 import dagger.internal.ProblemDetector;
 import dagger.internal.SetBinding;
 import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
 import java.io.Writer;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -97,7 +99,11 @@
       try {
         writeDotFile(moduleType, bindings);
       } catch (IOException e) {
-        error("Graph visualization failed: " + e, moduleType);
+        StringWriter sw = new StringWriter();
+        e.printStackTrace(new PrintWriter(sw));
+        processingEnv.getMessager()
+            .printMessage(Diagnostic.Kind.WARNING,
+                "Graph visualization failed. Please report this as a bug.\n\n" + sw, moduleType);
       }
     }
     return true;
/Fim/
diff --git a/compiler/src/it/cyclic-module-includes/invoker.properties b/compiler/src/it/cyclic-module-includes/invoker.properties
new file mode 100644
index 0000000..324b5fb
--- /dev/null
+++ b/compiler/src/it/cyclic-module-includes/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
\ No newline at end of file
/Fim/
diff --git a/compiler/src/it/cyclic-module-includes/pom.xml b/compiler/src/it/cyclic-module-includes/pom.xml
new file mode 100644
index 0000000..21e1490
--- /dev/null
+++ b/compiler/src/it/cyclic-module-includes/pom.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2013 Square, Inc.
+ Copyright (C) 2013 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>cyclic-module-includes</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <name>Cyclic Dependencies</name>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/cyclic-module-includes/src/main/java/test/TestApp.java b/compiler/src/it/cyclic-module-includes/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..6c6f175
--- /dev/null
+++ b/compiler/src/it/cyclic-module-includes/src/main/java/test/TestApp.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+
+class TestApp {
+  
+  @Module(includes = SelfReferencingModule.class)
+  static class SelfReferencingModule { }
+
+  @Module(includes = Spock.class)
+  static class Rock {}
+
+  @Module(includes = Rock.class)
+  static class Paper {}
+
+  @Module(includes = Paper.class)
+  static class Scissors {}
+
+  @Module(includes = Scissors.class)
+  static class Lizard {}
+
+  @Module(includes = Lizard.class)
+  static class Spock {}
+
+}
/Fim/
diff --git a/compiler/src/it/cyclic-module-includes/verify.bsh b/compiler/src/it/cyclic-module-includes/verify.bsh
new file mode 100644
index 0000000..c6f5e89
--- /dev/null
+++ b/compiler/src/it/cyclic-module-includes/verify.bsh
@@ -0,0 +1,13 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Graph validation failed", 
+    "test.TestApp.SelfReferencingModule includes itself directly"});
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Graph validation failed", 
+    "Module Inclusion Cycle", 
+    "0. test.TestApp.Scissors included by test.TestApp.Lizard", 
+    "0. test.TestApp.Scissors"});
+    
\ No newline at end of file
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index b048f82..7bdff1f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -28,8 +28,10 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.Deque;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -89,9 +91,13 @@
         continue;
       }
       TypeElement moduleType = (TypeElement) element;
-      Map<String, Binding<?>> bindings = processCompleteModule(moduleType);
+      Map<String, Binding<?>> bindings = null;
       try {
+        bindings = processCompleteModule(moduleType);
         new ProblemDetector().detectProblems(bindings.values());
+      } catch (ModuleValidationException e) {
+        error("Graph validation failed: " + e.getMessage(), e.source);
+        continue;
       } catch (IllegalStateException e) {
         error("Graph validation failed: " + e.getMessage(), moduleType);
         continue;
@@ -115,7 +121,7 @@
 
   private Map<String, Binding<?>> processCompleteModule(TypeElement rootModule) {
     Map<String, TypeElement> allModules = new LinkedHashMap<String, TypeElement>();
-    collectIncludesRecursively(rootModule, allModules);
+    collectIncludesRecursively(rootModule, allModules, new LinkedList<String>());
 
     Linker linker = new Linker(null, new CompileTimePlugin(processingEnv),
         new ReportingErrorHandler(processingEnv, rootModule.getQualifiedName().toString()));
@@ -188,16 +194,34 @@
         + "." + method.getSimpleName() + "()";
   }
 
-  private void collectIncludesRecursively(TypeElement module, Map<String, TypeElement> result) {
+  void collectIncludesRecursively(
+      TypeElement module, Map<String, TypeElement> result, Deque<String> path) {
     Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
     if (annotation == null) {
       // TODO(tbroyer): pass annotation information
-      error("No @Module on " + module, module);
-      return;
+      throw new ModuleValidationException("No @Module on " + module, module);
     }
 
     // Add the module.
-    result.put(module.getQualifiedName().toString(), module);
+    String name = module.getQualifiedName().toString();
+    if (path.contains(name)) {
+      StringBuilder message = new StringBuilder("Module Inclusion Cycle: ");
+      if (path.size() == 1) {
+        message.append(name).append(" includes itself directly.");
+      } else {
+        String current = null;
+        String includer = name;
+        for (int i = 0; path.size() > 0; i++) {
+          current = includer;
+          includer = path.pop();
+          message.append("\n").append(i).append(". ")
+              .append(current).append(" included by ").append(includer);
+        }
+        message.append("\n0. ").append(name);
+      }
+      throw new ModuleValidationException(message.toString(), module);
+    }
+    result.put(name, module);
 
     // Recurse for each included module.
     Types typeUtils = processingEnv.getTypeUtils();
@@ -212,7 +236,9 @@
         continue;
       }
       TypeElement includedModule = (TypeElement) typeUtils.asElement((TypeMirror) include);
-      collectIncludesRecursively(includedModule, result);
+      path.push(name);
+      collectIncludesRecursively(includedModule, result, path);
+      path.pop();
     }
   }
 
@@ -258,4 +284,13 @@
     new GraphVisualizer().write(bindings, dotWriter);
     dotWriter.close();
   }
+
+  static class ModuleValidationException extends IllegalStateException {
+    final TypeElement source;
+
+    public ModuleValidationException(String message, TypeElement source) {
+      super(message);
+      this.source = source;
+    }
+  }
 }
/Fim/
diff --git a/compiler/src/it/provide-provider-or-lazy/invoker.properties b/compiler/src/it/provide-provider-or-lazy/invoker.properties
new file mode 100644
index 0000000..324b5fb
--- /dev/null
+++ b/compiler/src/it/provide-provider-or-lazy/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
\ No newline at end of file
/Fim/
diff --git a/compiler/src/it/provide-provider-or-lazy/pom.xml b/compiler/src/it/provide-provider-or-lazy/pom.xml
new file mode 100644
index 0000000..9b2d8be
--- /dev/null
+++ b/compiler/src/it/provide-provider-or-lazy/pom.xml
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>provide-provider-or-lazy</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration><source>1.5</source><target>1.5</target></configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/provide-provider-or-lazy/src/main/java/test/TestModule.java b/compiler/src/it/provide-provider-or-lazy/src/main/java/test/TestModule.java
new file mode 100644
index 0000000..0a80aee
--- /dev/null
+++ b/compiler/src/it/provide-provider-or-lazy/src/main/java/test/TestModule.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Lazy;
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Provider;
+
+@Module class TestModule {
+  @Provides Provider<Object> provideProvider() {
+    return null;
+  }
+
+  @Provides Provider provideRawProvider() {
+    return null;
+  }
+
+  @Provides Lazy<Object> provideLazy() {
+    return null;
+  }
+
+  @Provides Lazy provideRawLazy() {
+    return null;
+  }
+}
/Fim/
diff --git a/compiler/src/it/provide-provider-or-lazy/verify.bsh b/compiler/src/it/provide-provider-or-lazy/verify.bsh
new file mode 100644
index 0000000..08487dd
--- /dev/null
+++ b/compiler/src/it/provide-provider-or-lazy/verify.bsh
@@ -0,0 +1,12 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "@Provides method must not return Provider directly: test.TestModule.provideProvider"});
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "@Provides method must not return Provider directly: test.TestModule.provideRawProvider"});
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "@Provides method must not return Lazy directly: test.TestModule.provideLazy"});
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "@Provides method must not return Lazy directly: test.TestModule.provideRawLazy"});
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index b490e0f..08009fb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -46,6 +46,7 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
@@ -107,8 +108,15 @@
    * Returns a map containing all {@code @Provides} methods, indexed by class.
    */
   private Map<String, List<ExecutableElement>> providerMethodsByClass(RoundEnvironment env) {
-    Map<String, List<ExecutableElement>> result
-        = new HashMap<String, List<ExecutableElement>>();
+    Elements elementUtils = processingEnv.getElementUtils();
+    Types typeUtils = processingEnv.getTypeUtils();
+
+    TypeElement providerElement = elementUtils.getTypeElement("javax.inject.Provider");
+    TypeMirror providerType = typeUtils.erasure(providerElement.asType());
+    TypeElement lazyElement = elementUtils.getTypeElement("dagger.Lazy");
+    TypeMirror lazyType = typeUtils.erasure(lazyElement.asType());
+
+    Map<String, List<ExecutableElement>> result = new HashMap<String, List<ExecutableElement>>();
     for (Element providerMethod : providesMethods(env)) {
       TypeElement type = (TypeElement) providerMethod.getEnclosingElement();
       Set<Modifier> typeModifiers = type.getModifiers();
@@ -140,6 +148,22 @@
         continue;
       }
 
+      TypeMirror returnType = typeUtils.erasure(providerMethodAsExecutable.getReturnType());
+      if (typeUtils.isSameType(returnType, providerType)) {
+        error("@Provides method must not return Provider directly: "
+            + type.getQualifiedName()
+            + "."
+            + providerMethod, providerMethod);
+        continue;
+      }
+      if (typeUtils.isSameType(returnType, lazyType)) {
+        error("@Provides method must not return Lazy directly: "
+            + type.getQualifiedName()
+            + "."
+            + providerMethod, providerMethod);
+        continue;
+      }
+
       List<ExecutableElement> methods = result.get(type.getQualifiedName().toString());
       if (methods == null) {
         methods = new ArrayList<ExecutableElement>();
@@ -148,7 +172,6 @@
       methods.add(providerMethodAsExecutable);
     }
 
-    Elements elementUtils = processingEnv.getElementUtils();
     TypeMirror objectType = elementUtils.getTypeElement("java.lang.Object").asType();
 
     // Catch any stray modules without @Provides since their entry points
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
index 5a95029..0fb595b 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.plugins.reflect;
 
+import dagger.Lazy;
 import dagger.Module;
 import dagger.Provides;
 import dagger.internal.Binding;
@@ -26,9 +27,11 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.Map;
 import java.util.Set;
+import javax.inject.Provider;
 import javax.inject.Singleton;
 
 final class ReflectiveModuleAdapter extends ModuleAdapter<Object> {
@@ -57,7 +60,26 @@
       for (Method method : c.getDeclaredMethods()) {
         Provides provides = method.getAnnotation(Provides.class);
         if (provides != null) {
-          String key = Keys.get(method.getGenericReturnType(), method.getAnnotations(), method);
+          Type genericReturnType = method.getGenericReturnType();
+
+          Type typeToCheck = genericReturnType;
+          if (genericReturnType instanceof ParameterizedType) {
+            typeToCheck = ((ParameterizedType) genericReturnType).getRawType();
+          }
+          if (Provider.class.equals(typeToCheck)) {
+            throw new IllegalStateException("@Provides method must not return Provider directly: "
+                + c.getName()
+                + "."
+                + method.getName());
+          }
+          if (Lazy.class.equals(typeToCheck)) {
+            throw new IllegalStateException("@Provides method must not return Lazy directly: "
+                + c.getName()
+                + "."
+                + method.getName());
+          }
+
+          String key = Keys.get(genericReturnType, method.getAnnotations(), method);
           switch (provides.type()) {
             case UNIQUE:
               handleBindings(bindings, method, key);
@@ -158,4 +180,4 @@
       return method.toString();
     }
   }
-}
\ No newline at end of file
+}
/Fim/
diff --git a/core/src/test/java/dagger/ModuleTest.java b/core/src/test/java/dagger/ModuleTest.java
index 223c987..3d07fbe 100644
--- a/core/src/test/java/dagger/ModuleTest.java
+++ b/core/src/test/java/dagger/ModuleTest.java
@@ -16,6 +16,7 @@
 package dagger;
 
 import javax.inject.Inject;
+import javax.inject.Provider;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -193,4 +194,72 @@
       assertThat(e.getMessage()).startsWith("Modules must not extend from other classes: ");
     }
   }
+
+  @Test public void provideProviderFails() {
+    @Module
+    class ProvidesProviderModule {
+      @Provides Provider<Object> provideObject() {
+        return null;
+      }
+    }
+    try {
+      ObjectGraph.create(new ProvidesProviderModule());
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()) //
+          .startsWith("@Provides method must not return Provider directly: ")
+          .endsWith("ProvidesProviderModule.provideObject");
+    }
+  }
+
+  @Test public void provideRawProviderFails() {
+    @Module
+    class ProvidesRawProviderModule {
+      @Provides Provider provideObject() {
+        return null;
+      }
+    }
+    try {
+      ObjectGraph.create(new ProvidesRawProviderModule());
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()) //
+          .startsWith("@Provides method must not return Provider directly: ")
+          .endsWith("ProvidesRawProviderModule.provideObject");
+    }
+  }
+
+  @Test public void provideLazyFails() {
+    @Module
+    class ProvidesLazyModule {
+      @Provides Lazy<Object> provideObject() {
+        return null;
+      }
+    }
+    try {
+      ObjectGraph.create(new ProvidesLazyModule());
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()) //
+          .startsWith("@Provides method must not return Lazy directly: ")
+          .endsWith("ProvidesLazyModule.provideObject");
+    }
+  }
+
+  @Test public void provideRawLazyFails() {
+    @Module
+    class ProvidesRawLazyModule {
+      @Provides Lazy provideObject() {
+        return null;
+      }
+    }
+    try {
+      ObjectGraph.create(new ProvidesRawLazyModule());
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e.getMessage()) //
+          .startsWith("@Provides method must not return Lazy directly: ")
+          .endsWith("ProvidesRawLazyModule.provideObject");
+    }
+  }
 }
/Fim/
diff --git a/compiler/src/it/unused-provider-methods-fail-compilation/invoker.properties b/compiler/src/it/unused-provider-methods-fail-compilation/invoker.properties
new file mode 100644
index 0000000..324b5fb
--- /dev/null
+++ b/compiler/src/it/unused-provider-methods-fail-compilation/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
\ No newline at end of file
/Fim/
diff --git a/compiler/src/it/unused-provider-methods-fail-compilation/pom.xml b/compiler/src/it/unused-provider-methods-fail-compilation/pom.xml
new file mode 100644
index 0000000..a59cbc8
--- /dev/null
+++ b/compiler/src/it/unused-provider-methods-fail-compilation/pom.xml
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.squareup.dagger.tests</groupId>
+  <artifactId>unused-provider-methods-fail-compilation</artifactId>
+  <version>@dagger.version@</version>
+  <packaging>jar</packaging>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/unused-provider-methods-fail-compilation/src/main/java/test/TestModule.java b/compiler/src/it/unused-provider-methods-fail-compilation/src/main/java/test/TestModule.java
new file mode 100644
index 0000000..193c55b
--- /dev/null
+++ b/compiler/src/it/unused-provider-methods-fail-compilation/src/main/java/test/TestModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+
+import dagger.ObjectGraph;
+import dagger.Provides;
+
+import java.lang.Override;
+
+@Module
+class TestModule {
+  @Provides String string() {
+    return "string";
+  }
+}
/Fim/
diff --git a/compiler/src/it/unused-provider-methods-fail-compilation/verify.bsh b/compiler/src/it/unused-provider-methods-fail-compilation/verify.bsh
new file mode 100644
index 0000000..07591e1
--- /dev/null
+++ b/compiler/src/it/unused-provider-methods-fail-compilation/verify.bsh
@@ -0,0 +1,8 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "You have these unused @Provider methods! Set library=true in your module to disable this check.",
+    "test.TestModule.string()",
+    });
\ No newline at end of file
/Fim/
diff --git a/compiler/src/it/unused-provider-methods-pass-compilation-on-library-module/pom.xml b/compiler/src/it/unused-provider-methods-pass-compilation-on-library-module/pom.xml
new file mode 100644
index 0000000..1b9670f
--- /dev/null
+++ b/compiler/src/it/unused-provider-methods-pass-compilation-on-library-module/pom.xml
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.squareup.dagger.tests</groupId>
+  <artifactId>unused-provider-methods-pass-compilation-on-library-module</artifactId>
+  <version>@dagger.version@</version>
+  <packaging>jar</packaging>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/unused-provider-methods-pass-compilation-on-library-module/src/main/java/test/TestModule.java b/compiler/src/it/unused-provider-methods-pass-compilation-on-library-module/src/main/java/test/TestModule.java
new file mode 100644
index 0000000..48c7fe2
--- /dev/null
+++ b/compiler/src/it/unused-provider-methods-pass-compilation-on-library-module/src/main/java/test/TestModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+
+import dagger.ObjectGraph;
+import dagger.Provides;
+
+import java.lang.Override;
+
+@Module(library = true)
+class TestModule {
+  @Provides String string() {
+    return "string";
+  }
+}
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
index 12e11e3..07f8af4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AtInjectBinding.java
@@ -119,7 +119,7 @@
       bindings[i] = linker.requestBinding(keys.get(i), requiredBy);
     }
     if (supertypeKey != null) {
-      supertypeBinding = linker.requestBinding(supertypeKey, requiredBy, false);
+      supertypeBinding = linker.requestBinding(supertypeKey, requiredBy, false, true);
     }
   }
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 7bdff1f..120fd2f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -21,6 +21,7 @@
 import dagger.internal.Linker;
 import dagger.internal.ProblemDetector;
 import dagger.internal.SetBinding;
+import dagger.internal.plugins.AbstractProviderMethodBinding;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
@@ -87,29 +88,38 @@
 
     for (Element element : modules) {
       Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, element);
-      if (!annotation.get("complete").equals(Boolean.TRUE)) {
-        continue;
-      }
       TypeElement moduleType = (TypeElement) element;
-      Map<String, Binding<?>> bindings = null;
-      try {
-        bindings = processCompleteModule(moduleType);
-        new ProblemDetector().detectProblems(bindings.values());
-      } catch (ModuleValidationException e) {
-        error("Graph validation failed: " + e.getMessage(), e.source);
-        continue;
-      } catch (IllegalStateException e) {
-        error("Graph validation failed: " + e.getMessage(), moduleType);
-        continue;
+
+      if (annotation.get("complete").equals(Boolean.TRUE)) {
+        Map<String, Binding<?>> bindings;
+        try {
+          bindings = processCompleteModule(moduleType, false);
+          new ProblemDetector().detectCircularDependencies(bindings.values());
+        } catch (ModuleValidationException e) {
+          error("Graph validation failed: " + e.getMessage(), e.source);
+          continue;
+        } catch (IllegalStateException e) {
+          error("Graph validation failed: " + e.getMessage(), moduleType);
+          continue;
+        }
+        try {
+          writeDotFile(moduleType, bindings);
+        } catch (IOException e) {
+          StringWriter sw = new StringWriter();
+          e.printStackTrace(new PrintWriter(sw));
+          processingEnv.getMessager()
+              .printMessage(Diagnostic.Kind.WARNING,
+                  "Graph visualization failed. Please report this as a bug.\n\n" + sw, moduleType);
+        }
       }
-      try {
-        writeDotFile(moduleType, bindings);
-      } catch (IOException e) {
-        StringWriter sw = new StringWriter();
-        e.printStackTrace(new PrintWriter(sw));
-        processingEnv.getMessager()
-            .printMessage(Diagnostic.Kind.WARNING,
-                "Graph visualization failed. Please report this as a bug.\n\n" + sw, moduleType);
+
+      if (annotation.get("library").equals(Boolean.FALSE)) {
+        Map<String, Binding<?>> bindings = processCompleteModule(moduleType, true);
+        try {
+          new ProblemDetector().detectUnusedBinding(bindings.values());
+        } catch (IllegalStateException e) {
+          error("Graph validation failed: " + e.getMessage(), moduleType);
+        }
       }
     }
     return true;
@@ -119,12 +129,14 @@
     processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message, element);
   }
 
-  private Map<String, Binding<?>> processCompleteModule(TypeElement rootModule) {
+  private Map<String, Binding<?>> processCompleteModule(TypeElement rootModule,
+      boolean ignoreCompletenessErrors) {
     Map<String, TypeElement> allModules = new LinkedHashMap<String, TypeElement>();
     collectIncludesRecursively(rootModule, allModules, new LinkedList<String>());
 
-    Linker linker = new Linker(null, new CompileTimePlugin(processingEnv),
-        new ReportingErrorHandler(processingEnv, rootModule.getQualifiedName().toString()));
+    Linker.ErrorHandler errorHandler = ignoreCompletenessErrors ? Linker.ErrorHandler.NULL
+        : new ReportingErrorHandler(processingEnv, rootModule.getQualifiedName().toString());
+    Linker linker = new Linker(null, new CompileTimePlugin(processingEnv), errorHandler);
     // Linker requires synchronization for calls to requestBinding and linkAll.
     // We know statically that we're single threaded, but we synchronize anyway
     // to make the linker happy.
@@ -134,12 +146,13 @@
       for (TypeElement module : allModules.values()) {
         Map<String, Object> annotation = CodeGen.getAnnotation(Module.class, module);
         boolean overrides = (Boolean) annotation.get("overrides");
+        boolean library = (Boolean) annotation.get("library");
         Map<String, Binding<?>> addTo = overrides ? overrideBindings : baseBindings;
 
         // Gather the entry points from the annotation.
         for (Object entryPoint : (Object[]) annotation.get("entryPoints")) {
           linker.requestBinding(GeneratorKeys.rawMembersKey((TypeMirror) entryPoint),
-              module.getQualifiedName().toString(), false);
+              module.getQualifiedName().toString(), false, true);
         }
 
         // Gather the static injections.
@@ -153,7 +166,9 @@
           }
           ExecutableElement providerMethod = (ExecutableElement) enclosed;
           String key = GeneratorKeys.get(providerMethod);
-          ProviderMethodBinding binding = new ProviderMethodBinding(key, providerMethod);
+          ProviderMethodBinding binding = new ProviderMethodBinding(key, providerMethod, library);
+          binding.setModuleName(rootModule.getQualifiedName().toString());
+
           switch (provides.type()) {
             case UNIQUE:
               ProviderMethodBinding clobbered = (ProviderMethodBinding) addTo.put(key, binding);
@@ -242,14 +257,16 @@
     }
   }
 
-  static class ProviderMethodBinding extends Binding<Object> {
+  static class ProviderMethodBinding extends AbstractProviderMethodBinding<Object> {
     private final ExecutableElement method;
     private final Binding<?>[] parameters;
 
-    protected ProviderMethodBinding(String provideKey, ExecutableElement method) {
+    protected ProviderMethodBinding(String provideKey, ExecutableElement method, boolean library) {
       super(provideKey, null, method.getAnnotation(Singleton.class) != null, method.toString());
       this.method = method;
       this.parameters = new Binding[method.getParameters().size()];
+      setMethodName(method.getSimpleName().toString());
+      setLibrary(library);
     }
 
     @Override public void attach(Linker linker) {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index a604e7f..c8bebb5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -289,7 +289,7 @@
             strippedTypeName);
       }
       if (supertype != null) {
-        writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class, false)",
+        writer.emitStatement("%s = (%s) linker.requestBinding(%s, %s.class, false, true)",
             "supertype",
             writer.compressType(JavaWriter.type(Binding.class,
                 CodeGen.rawTypeToString(supertype, '.'))),
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 08009fb..57616de 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -219,6 +219,7 @@
 
     boolean overrides = (Boolean) module.get("overrides");
     boolean complete = (Boolean) module.get("complete");
+    boolean library = (Boolean) module.get("library");
 
     String adapterName = CodeGen.adapterName(type, MODULE_ADAPTER_SUFFIX);
     JavaFileObject sourceFile = processingEnv.getFiler()
@@ -276,7 +277,7 @@
     writer.emitEmptyLine();
     writer.beginMethod(null, adapterName, PUBLIC);
     writer.emitStatement("super(ENTRY_POINTS, STATIC_INJECTIONS, %s /*overrides*/, "
-        + "INCLUDES, %s /*complete*/)", overrides, complete);
+        + "INCLUDES, %s /*complete*/, %s /*library*/)", overrides, complete, library);
     writer.endMethod();
 
     ExecutableElement noArgsConstructor = CodeGen.getNoArgsConstructor(type);
@@ -322,7 +323,8 @@
     }
 
     for (ExecutableElement providerMethod : providerMethods) {
-      writeProvidesAdapter(writer, providerMethod, methodToClassName, methodNameToNextId);
+      writeProvidesAdapter(writer, providerMethod, methodToClassName, methodNameToNextId,
+          library);
     }
 
     writer.endType();
@@ -389,7 +391,7 @@
 
   private void writeProvidesAdapter(JavaWriter writer, ExecutableElement providerMethod,
       Map<ExecutableElement, String> methodToClassName,
-      Map<String, AtomicInteger> methodNameToNextId)
+      Map<String, AtomicInteger> methodNameToNextId, boolean library)
       throws IOException {
     String methodName = providerMethod.getSimpleName().toString();
     String moduleType = CodeGen.typeToString(providerMethod.getEnclosingElement().asType());
@@ -419,6 +421,7 @@
     writer.emitStatement("super(%s, %s, %s, %s.class)",
         key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"), moduleType);
     writer.emitStatement("this.module = module");
+    writer.emitStatement("setLibrary(%s)", library);
     writer.endMethod();
 
     if (dependent) {
/Fim/
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
index 075210d..8a5b34a 100644
--- a/core/src/main/java/dagger/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -60,4 +60,14 @@
    */
   boolean complete() default true;
 
+  /**
+   * False if all the included bindings in this module are necessary to satisfy
+   * all of its entry points. If a module is not a library module, it is eligible
+   * for additional static checking: tools can detect if included bindings are not
+   * necessary. If you provide bindings that are not used by this module's graph,
+   * then you must declare {@code library = true}.
+   * <p>
+   * This is intended to help you detect dead code.
+   */
+  boolean library() default false;
 }
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index df9860a..7769327 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -187,7 +187,6 @@
       return makeGraph(this, plugin, modules);
     }
 
-
     private void linkStaticInjections() {
       for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
         StaticInjection staticInjection = entry.getValue();
@@ -201,7 +200,7 @@
 
     private void linkEntryPoints() {
       for (Map.Entry<String, Class<?>> entry : entryPoints.entrySet()) {
-        linker.requestBinding(entry.getKey(), entry.getValue(), false);
+        linker.requestBinding(entry.getKey(), entry.getValue(), false, true);
       }
     }
 
@@ -273,10 +272,10 @@
       }
 
       synchronized (linker) {
-        Binding<?> binding = linker.requestBinding(key, moduleClass, false);
+        Binding<?> binding = linker.requestBinding(key, moduleClass, false, true);
         if (binding == null || !binding.isLinked()) {
           linker.linkRequested();
-          binding = linker.requestBinding(key, moduleClass, false);
+          binding = linker.requestBinding(key, moduleClass, false, true);
         }
         return binding;
       }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Binding.java b/core/src/main/java/dagger/internal/Binding.java
index 1fe88a6..776d8c9 100644
--- a/core/src/main/java/dagger/internal/Binding.java
+++ b/core/src/main/java/dagger/internal/Binding.java
@@ -46,6 +46,10 @@
   /** Set if {@link ProblemDetector} has confirmed this binding has no circular dependencies. */
   private static final int CYCLE_FREE = 1 << 3;
 
+  private static final int DEPENDED_ON = 1 << 4;
+
+  private static final int LIBRARY = 1 << 5;
+
   /** The key used to provide instances of 'T', or null if this binding cannot provide instances. */
   public final String provideKey;
 
@@ -63,8 +67,8 @@
     }
     this.provideKey = provideKey;
     this.membersKey = membersKey;
-    this.bits = (singleton ? SINGLETON : 0);
     this.requiredBy = requiredBy;
+    this.bits = (singleton ? SINGLETON : 0);
   }
 
   /**
@@ -125,9 +129,24 @@
     this.bits = cycleFree ? (bits | CYCLE_FREE) : (bits & ~CYCLE_FREE);
   }
 
+  public void setLibrary(boolean library) {
+    this.bits = library ? (bits | LIBRARY) : (bits & ~LIBRARY);
+  }
+
+  public boolean library() {
+    return (bits & LIBRARY) != 0;
+  }
+
+  public void setDependedOn(boolean dependedOn) {
+    this.bits = dependedOn ? (bits | DEPENDED_ON) : (bits & ~DEPENDED_ON);
+  }
+
+  public boolean dependedOn() {
+    return (bits & DEPENDED_ON) != 0;
+  }
+
   @Override public String toString() {
     return getClass().getSimpleName()
             + "[provideKey=\"" + provideKey + "\", memberskey=\"" + membersKey + "\"]";
   }
-
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index fe1be29..7574892 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -107,6 +107,8 @@
         }
         try {
           Binding<?> jitBinding = createJitBinding(key, binding.requiredBy, mustBeInjectable);
+          jitBinding.setLibrary(binding.library());
+          jitBinding.setDependedOn(binding.dependedOn());
           // Fail if the type of binding we got wasn't capable of what was requested.
           if (!key.equals(jitBinding.provideKey) && !key.equals(jitBinding.membersKey)) {
             throw new IllegalStateException("Unable to create binding for " + key);
@@ -187,14 +189,13 @@
     throw new IllegalArgumentException("No binding for " + key);
   }
 
-
   /**
    * Returns the binding if it exists immediately. Otherwise this returns
    * null. If the returned binding didn't exist or was unlinked, it will be
    * enqueued to be linked.
    */
   public Binding<?> requestBinding(String key, Object requiredBy) {
-    return requestBinding(key, requiredBy, true);
+    return requestBinding(key, requiredBy, true, true);
   }
 
   /**
@@ -207,7 +208,8 @@
    *     can inject arbitrary entry points like JUnit test cases or Android
    *     activities) and for supertypes.
    */
-  public Binding<?> requestBinding(String key, Object requiredBy, boolean mustBeInjectable) {
+  public Binding<?> requestBinding(String key, Object requiredBy, boolean mustBeInjectable,
+      boolean library) {
     assertLockHeld();
 
     Binding<?> binding = null;
@@ -222,6 +224,8 @@
     if (binding == null) {
       // We can't satisfy this binding. Make sure it'll work next time!
       Binding<?> deferredBinding = new DeferredBinding(key, requiredBy, mustBeInjectable);
+      deferredBinding.setLibrary(library);
+      deferredBinding.setDependedOn(true);
       toLink.add(deferredBinding);
       attachSuccess = false;
       return null;
@@ -231,6 +235,8 @@
       toLink.add(binding); // This binding was never linked; link it now!
     }
 
+    binding.setLibrary(library);
+    binding.setDependedOn(true);
     return binding;
   }
 
@@ -345,6 +351,11 @@
 
   /** Handles linker errors appropriately. */
   public interface ErrorHandler {
+    ErrorHandler NULL = new ErrorHandler() {
+      @Override public void handleErrors(List<String> errors) {
+      }
+    };
+
     /**
      * Fail if any errors have been enqueued.
      * Implementations may throw exceptions or report the errors through another
@@ -358,6 +369,7 @@
   private static class DeferredBinding extends Binding<Object> {
     final String deferredKey;
     final boolean mustBeInjectable;
+
     private DeferredBinding(String deferredKey, Object requiredBy, boolean mustBeInjectable) {
       super(null, null, false, requiredBy);
       this.deferredKey = deferredKey;
@@ -370,5 +382,4 @@
       throw new UnsupportedOperationException("Deferred bindings must resolve first.");
     }
   }
-
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index c516be1..92310cc 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -28,15 +28,17 @@
   public final boolean overrides;
   public final Class<?>[] includes;
   public final boolean complete;
+  public final boolean library;
   protected T module;
 
   protected ModuleAdapter(String[] entryPoints, Class<?>[] staticInjections, boolean overrides,
-      Class<?>[] includes, boolean complete) {
+      Class<?>[] includes, boolean complete, boolean library) {
     this.entryPoints = entryPoints;
     this.staticInjections = staticInjections;
     this.overrides = overrides;
     this.includes = includes;
     this.complete = complete;
+    this.library = library;
   }
 
   /**
@@ -58,6 +60,4 @@
   public T getModule() {
     return module;
   }
-
-
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/ProblemDetector.java b/core/src/main/java/dagger/internal/ProblemDetector.java
index 42323c9..76023b6 100644
--- a/core/src/main/java/dagger/internal/ProblemDetector.java
+++ b/core/src/main/java/dagger/internal/ProblemDetector.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal;
 
+import dagger.internal.plugins.AbstractProviderMethodBinding;
 import java.util.AbstractSet;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -25,11 +26,35 @@
  * Detects problems like cyclic dependencies.
  */
 public final class ProblemDetector {
-  public void detectProblems(Collection<Binding<?>> bindings) {
+  public void detectCircularDependencies(Collection<Binding<?>> bindings) {
     detectCircularDependencies(bindings, new ArrayList<Binding<?>>());
   }
 
-  public void detectCircularDependencies(Collection<Binding<?>> bindings, List<Binding<?>> path) {
+  public void detectUnusedBinding(Collection<Binding<?>> bindings) {
+    ArrayList<Binding> unusedBindings = new ArrayList<Binding>();
+    for (Binding<?> binding : bindings) {
+      if (!binding.library() && !binding.dependedOn()) {
+        unusedBindings.add(binding);
+      }
+    }
+    if (unusedBindings.size() > 0) {
+      StringBuilder builder = new StringBuilder();
+      builder.append("You have these unused @Provider methods! ");
+      builder.append("Set library=true in your module to disable this check.\n");
+      for (Binding<?> binding : unusedBindings) {
+        AbstractProviderMethodBinding<?> providerBinding =
+            (AbstractProviderMethodBinding<?>) binding;
+        builder.append(providerBinding.getModuleName())
+            .append(".")
+            .append(providerBinding.getMethodName())
+            .append("()\n");
+      }
+      throw new IllegalStateException(builder.toString());
+    }
+  }
+
+  private static void detectCircularDependencies(Collection<Binding<?>> bindings,
+      List<Binding<?>> path) {
     for (Binding<?> binding : bindings) {
       if (binding.isCycleFree()) {
         continue;
@@ -61,6 +86,11 @@
     }
   }
 
+  public void detectProblems(Collection<Binding<?>> values) {
+    detectCircularDependencies(values);
+    detectUnusedBinding(values);
+  }
+
   static class ArraySet<T> extends AbstractSet<T> {
     private final ArrayList<T> list = new ArrayList<T>();
 
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/AbstractProviderMethodBinding.java b/core/src/main/java/dagger/internal/plugins/AbstractProviderMethodBinding.java
new file mode 100644
index 0000000..a694474
--- /dev/null
+++ b/core/src/main/java/dagger/internal/plugins/AbstractProviderMethodBinding.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.plugins;
+
+import dagger.internal.Binding;
+
+public class AbstractProviderMethodBinding<T> extends Binding<T> {
+
+  private String moduleName;
+  private String methodName;
+
+  protected AbstractProviderMethodBinding(String provideKey, String membersKey, boolean singleton,
+      Object requiredBy) {
+    super(provideKey, membersKey, singleton, requiredBy);
+  }
+
+  public String getModuleName() {
+    return moduleName;
+  }
+
+  public void setModuleName(String moduleName) {
+    this.moduleName = moduleName;
+  }
+
+  public String getMethodName() {
+    return methodName;
+  }
+
+  public void setMethodName(String methodName) {
+    this.methodName = methodName;
+  }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
index c49aa12..78ea1ff 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveAtInjectBinding.java
@@ -25,6 +25,7 @@
 import java.lang.reflect.Modifier;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 import javax.inject.Inject;
@@ -81,7 +82,8 @@
       }
     }
     if (supertype != null && supertypeBinding == null) {
-      supertypeBinding = (Binding<? super T>) linker.requestBinding(keys[k], membersKey, false);
+      supertypeBinding =
+          (Binding<? super T>) linker.requestBinding(keys[k], membersKey, false, true);
     }
   }
 
@@ -125,13 +127,9 @@
 
   @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
     if (parameterBindings != null) {
-      for (Binding<?> binding : parameterBindings) {
-        get.add(binding);
-      }
+      Collections.addAll(get, parameterBindings);
     }
-    for (Binding<?> binding : fieldBindings) {
-      injectMembers.add(binding);
-    }
+    Collections.addAll(injectMembers, fieldBindings);
     if (supertypeBinding != null) {
       injectMembers.add(supertypeBinding);
     }
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
index 0fb595b..073a1fc 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
@@ -23,6 +23,7 @@
 import dagger.internal.Linker;
 import dagger.internal.ModuleAdapter;
 import dagger.internal.SetBinding;
+import dagger.internal.plugins.AbstractProviderMethodBinding;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
@@ -43,7 +44,8 @@
         annotation.staticInjections(),
         annotation.overrides(),
         annotation.includes(),
-        annotation.complete());
+        annotation.complete(),
+        annotation.library());
     this.moduleClass = moduleClass;
   }
 
@@ -82,10 +84,10 @@
           String key = Keys.get(genericReturnType, method.getAnnotations(), method);
           switch (provides.type()) {
             case UNIQUE:
-              handleBindings(bindings, method, key);
+              handleBindings(bindings, method, key, library);
               break;
             case SET:
-              handleSetBindings(bindings, method, key);
+              handleSetBindings(bindings, method, key, library);
               break;
             default:
               throw new AssertionError("Unknown @Provides type " + provides.type());
@@ -95,14 +97,17 @@
     }
   }
 
-  private <T> void handleBindings(Map<String, Binding<?>> bindings, Method method, String key) {
-    bindings.put(key, new ProviderMethodBinding<T>(method, key, module));
+  private <T> void handleBindings(Map<String, Binding<?>> bindings, Method method, String key,
+      boolean library) {
+    bindings.put(key, new ProviderMethodBinding<T>(method, key, module, library));
   }
 
-  private <T> void handleSetBindings(Map<String, Binding<?>> bindings, Method method, String key) {
+  private <T> void handleSetBindings(Map<String, Binding<?>> bindings, Method method, String key,
+      boolean library) {
     String elementKey =
         Keys.getElementKey(method.getGenericReturnType(), method.getAnnotations(), method);
-    SetBinding.<T>add(bindings, elementKey, new ProviderMethodBinding<T>(method, key, module));
+    SetBinding.<T>add(bindings, elementKey, new ProviderMethodBinding<T>(method, key, module,
+        library));
   }
 
   @Override protected Object newModule() {
@@ -126,16 +131,19 @@
   /**
    * Invokes a method to provide a value. The method's parameters are injected.
    */
-  private final class ProviderMethodBinding<T> extends Binding<T> {
+  private final class ProviderMethodBinding<T> extends AbstractProviderMethodBinding<T> {
     private Binding<?>[] parameters;
     private final Method method;
     private final Object instance;
 
-    public ProviderMethodBinding(Method method, String key, Object instance) {
+    public ProviderMethodBinding(Method method, String key, Object instance, boolean library) {
       super(key, null, method.isAnnotationPresent(Singleton.class), method);
       this.method = method;
       this.instance = instance;
       method.setAccessible(true);
+      setLibrary(library);
+      setModuleName(moduleClass.getName());
+      setMethodName(method.getName());
     }
 
     @Override public void attach(Linker linker) {
/Fim/
diff --git a/core/src/test/java/dagger/ProblemDetectorTest.java b/core/src/test/java/dagger/ProblemDetectorTest.java
index 6733698..d601edd 100644
--- a/core/src/test/java/dagger/ProblemDetectorTest.java
+++ b/core/src/test/java/dagger/ProblemDetectorTest.java
@@ -61,7 +61,7 @@
   }
 
   @Test public void validateLazy() {
-    @Module
+    @Module(library = true)
     class TestModule {
       @Provides Integer dependOnLazy(Lazy<String> lazyString) {
         throw new AssertionError();
/Fim/
diff --git a/core/src/test/java/dagger/UnusedProviderTest.java b/core/src/test/java/dagger/UnusedProviderTest.java
new file mode 100644
index 0000000..c0c0e94
--- /dev/null
+++ b/core/src/test/java/dagger/UnusedProviderTest.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2013 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import org.junit.Test;
+
+import static org.junit.Assert.fail;
+
+public class UnusedProviderTest {
+
+  @Test public void unusedProvidesMethod_whenModuleLibrary_passes() throws Exception {
+    class EntryPoint {
+    }
+    class BagOfMoney {
+    }
+    @Module(entryPoints = EntryPoint.class, library = true) class TestModule {
+      @Provides BagOfMoney providesMoney() {
+        return new BagOfMoney();
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    graph.validate();
+  }
+
+  @Test public void unusedProviderMethod_whenNotLibraryModule_fails() throws Exception {
+    class EntryPoint {
+    }
+    class BagOfMoney {
+    }
+
+    @Module(entryPoints = EntryPoint.class) class TestModule {
+      @Provides BagOfMoney providesMoney() {
+        return new BagOfMoney();
+      }
+    }
+
+    try {
+      ObjectGraph graph = ObjectGraph.create(new TestModule());
+      graph.validate();
+      fail("Validation should have exploded!");
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void whenLibraryModulePlussedToNecessaryModule_shouldNotFailOnUnusedLibraryModule()
+      throws Exception {
+    class EntryPoint {
+    }
+    class BagOfMoney {
+    }
+
+    @Module(entryPoints = EntryPoint.class, library = true) class ExampleLibraryModule {
+      @Provides BagOfMoney providesMoney() {
+        return new BagOfMoney();
+      }
+    }
+
+    @Module(entryPoints = EntryPoint.class) class TestModule {
+    }
+
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    graph = graph.plus(new ExampleLibraryModule());
+    graph.validate();
+  }
+}
/Fim/
diff --git a/examples/simple/src/main/java/coffee/PumpModule.java b/examples/simple/src/main/java/coffee/PumpModule.java
index 3324b84..b064cea 100644
--- a/examples/simple/src/main/java/coffee/PumpModule.java
+++ b/examples/simple/src/main/java/coffee/PumpModule.java
@@ -3,7 +3,7 @@
 import dagger.Module;
 import dagger.Provides;
 
-@Module(complete = false)
+@Module(complete = false, library = true)
 class PumpModule {
   @Provides Pump providePump(Thermosiphon pump) {
     return pump;
/Fim/
diff --git a/compiler/src/it/cyclic-deps/pom.xml b/compiler/src/it/cyclic-deps/pom.xml
index d213a7a..ee4db1f 100644
--- a/compiler/src/it/cyclic-deps/pom.xml
+++ b/compiler/src/it/cyclic-deps/pom.xml
@@ -41,7 +41,11 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/cyclic-module-includes/pom.xml b/compiler/src/it/cyclic-module-includes/pom.xml
index 21e1490..2a986f7 100644
--- a/compiler/src/it/cyclic-module-includes/pom.xml
+++ b/compiler/src/it/cyclic-module-includes/pom.xml
@@ -41,7 +41,11 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/default-package-injected-type/pom.xml b/compiler/src/it/default-package-injected-type/pom.xml
index ee7e557..eaab5f1 100644
--- a/compiler/src/it/default-package-injected-type/pom.xml
+++ b/compiler/src/it/default-package-injected-type/pom.xml
@@ -41,7 +41,11 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/extension-graph/pom.xml b/compiler/src/it/extension-graph/pom.xml
index 76bde1e..3c0190b 100644
--- a/compiler/src/it/extension-graph/pom.xml
+++ b/compiler/src/it/extension-graph/pom.xml
@@ -41,7 +41,11 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/include-non-module/pom.xml b/compiler/src/it/include-non-module/pom.xml
index 7d2993d..871f538 100644
--- a/compiler/src/it/include-non-module/pom.xml
+++ b/compiler/src/it/include-non-module/pom.xml
@@ -41,7 +41,11 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/inject-parameterized-type/pom.xml b/compiler/src/it/inject-parameterized-type/pom.xml
index 7b6bc48..0437e26 100644
--- a/compiler/src/it/inject-parameterized-type/pom.xml
+++ b/compiler/src/it/inject-parameterized-type/pom.xml
@@ -41,7 +41,11 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/inner-classes-complaint-injection/pom.xml b/compiler/src/it/inner-classes-complaint-injection/pom.xml
index ff2dd01..d8ceecb 100644
--- a/compiler/src/it/inner-classes-complaint-injection/pom.xml
+++ b/compiler/src/it/inner-classes-complaint-injection/pom.xml
@@ -40,7 +40,11 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/method-injection/pom.xml b/compiler/src/it/method-injection/pom.xml
index 3981dee..e0f80c4 100644
--- a/compiler/src/it/method-injection/pom.xml
+++ b/compiler/src/it/method-injection/pom.xml
@@ -39,6 +39,7 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
         <configuration>
           <source>1.5</source>
           <target>1.5</target>
/Fim/
diff --git a/compiler/src/it/missing-at-inject-constructor/pom.xml b/compiler/src/it/missing-at-inject-constructor/pom.xml
index 4d9e947..ea81347 100644
--- a/compiler/src/it/missing-at-inject-constructor/pom.xml
+++ b/compiler/src/it/missing-at-inject-constructor/pom.xml
@@ -41,7 +41,11 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/module-type-validation/pom.xml b/compiler/src/it/module-type-validation/pom.xml
index 186da06..cc510b2 100644
--- a/compiler/src/it/module-type-validation/pom.xml
+++ b/compiler/src/it/module-type-validation/pom.xml
@@ -39,6 +39,7 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
         <configuration>
           <source>1.5</source>
           <target>1.5</target>
/Fim/
diff --git a/compiler/src/it/multiple-provides-methods/pom.xml b/compiler/src/it/multiple-provides-methods/pom.xml
index 45fcba0..ea11d6e 100644
--- a/compiler/src/it/multiple-provides-methods/pom.xml
+++ b/compiler/src/it/multiple-provides-methods/pom.xml
@@ -41,7 +41,11 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/private-inject/pom.xml b/compiler/src/it/private-inject/pom.xml
index ecf04c5..cc5673e 100644
--- a/compiler/src/it/private-inject/pom.xml
+++ b/compiler/src/it/private-inject/pom.xml
@@ -39,6 +39,7 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
         <configuration>
           <source>1.5</source>
           <target>1.5</target>
/Fim/
diff --git a/compiler/src/it/provide-provider-or-lazy/pom.xml b/compiler/src/it/provide-provider-or-lazy/pom.xml
index 9b2d8be..40b7600 100644
--- a/compiler/src/it/provide-provider-or-lazy/pom.xml
+++ b/compiler/src/it/provide-provider-or-lazy/pom.xml
@@ -39,7 +39,11 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/provides-method-with-throws-clause/pom.xml b/compiler/src/it/provides-method-with-throws-clause/pom.xml
index 7063ecc..7e268d3 100644
--- a/compiler/src/it/provides-method-with-throws-clause/pom.xml
+++ b/compiler/src/it/provides-method-with-throws-clause/pom.xml
@@ -41,7 +41,11 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/same-provides-method-name/pom.xml b/compiler/src/it/same-provides-method-name/pom.xml
index 2c41239..938165e 100644
--- a/compiler/src/it/same-provides-method-name/pom.xml
+++ b/compiler/src/it/same-provides-method-name/pom.xml
@@ -41,7 +41,11 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/simple-missing-dependency-failure/pom.xml b/compiler/src/it/simple-missing-dependency-failure/pom.xml
index 1ec794d..2757fdc 100644
--- a/compiler/src/it/simple-missing-dependency-failure/pom.xml
+++ b/compiler/src/it/simple-missing-dependency-failure/pom.xml
@@ -42,7 +42,11 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/uninjectable-supertype/pom.xml b/compiler/src/it/uninjectable-supertype/pom.xml
index 451108d..84f323f 100644
--- a/compiler/src/it/uninjectable-supertype/pom.xml
+++ b/compiler/src/it/uninjectable-supertype/pom.xml
@@ -41,7 +41,11 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
-        <configuration><source>1.5</source><target>1.5</target></configuration>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
       </plugin>
     </plugins>
   </build>
/Fim/
diff --git a/compiler/src/it/unused-provider-methods-fail-compilation/pom.xml b/compiler/src/it/unused-provider-methods-fail-compilation/pom.xml
index a59cbc8..de9e363 100644
--- a/compiler/src/it/unused-provider-methods-fail-compilation/pom.xml
+++ b/compiler/src/it/unused-provider-methods-fail-compilation/pom.xml
@@ -41,6 +41,7 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
         <configuration>
           <source>1.5</source>
           <target>1.5</target>
/Fim/
diff --git a/compiler/src/it/unused-provider-methods-pass-compilation-on-library-module/pom.xml b/compiler/src/it/unused-provider-methods-pass-compilation-on-library-module/pom.xml
index 1b9670f..e0ead64 100644
--- a/compiler/src/it/unused-provider-methods-pass-compilation-on-library-module/pom.xml
+++ b/compiler/src/it/unused-provider-methods-pass-compilation-on-library-module/pom.xml
@@ -41,6 +41,7 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
         <configuration>
           <source>1.5</source>
           <target>1.5</target>
/Fim/
diff --git a/compiler/src/it/unused-provider-methods-fail-compilation/verify.bsh b/compiler/src/it/unused-provider-methods-fail-compilation/verify.bsh
index 07591e1..f32569d 100644
--- a/compiler/src/it/unused-provider-methods-fail-compilation/verify.bsh
+++ b/compiler/src/it/unused-provider-methods-fail-compilation/verify.bsh
@@ -3,6 +3,7 @@
 
 File buildLog = new File(basedir, "build.log");
 new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "You have these unused @Provider methods! Set library=true in your module to disable this check.",
-    "test.TestModule.string()",
+    "You have these unused @Provider methods:",
+    "0. test.TestModule.string()",
+    "Set library=true in your module to disable this check."
     });
\ No newline at end of file
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java b/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
index ac4e4a5..e0050d9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeGen.java
@@ -287,4 +287,13 @@
     set.addAll(Arrays.asList(items));
     return set;
   }
+
+  /**
+   * Returns a user-presentable string like {@code
+   * coffee.CoffeeModule#provideHeater()}.
+   */
+  public static String methodName(ExecutableElement method) {
+    return ((TypeElement) method.getEnclosingElement()).getQualifiedName()
+        + "." + method.getSimpleName() + "()";
+  }
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
index 120fd2f..5d220d8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FullGraphProcessor.java
@@ -21,7 +21,6 @@
 import dagger.internal.Linker;
 import dagger.internal.ProblemDetector;
 import dagger.internal.SetBinding;
-import dagger.internal.plugins.AbstractProviderMethodBinding;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
@@ -166,27 +165,30 @@
           }
           ExecutableElement providerMethod = (ExecutableElement) enclosed;
           String key = GeneratorKeys.get(providerMethod);
-          ProviderMethodBinding binding = new ProviderMethodBinding(key, providerMethod, library);
-          binding.setModuleName(rootModule.getQualifiedName().toString());
+          Binding binding = new ProviderMethodBinding(key, providerMethod, library);
+
+          Binding previous = addTo.get(key);
+          if (previous != null) {
+            if (provides.type() == Provides.Type.SET && previous instanceof SetBinding) {
+              // No duplicate bindings error if both bindings are set bindings.
+            } else {
+              String message = "Duplicate bindings for " + key;
+              if (overrides) {
+                message += " in override module(s) - cannot override an override";
+              }
+              message += ":\n    " + previous.requiredBy + "\n    " + binding.requiredBy;
+              error(message, providerMethod);
+            }
+          }
 
           switch (provides.type()) {
             case UNIQUE:
-              ProviderMethodBinding clobbered = (ProviderMethodBinding) addTo.put(key, binding);
-              if (clobbered != null) {
-                String msg = "Duplicate bindings for " + key;
-                if (overrides) {
-                  msg += " in override module(s) - cannot override an override";
-                }
-                msg += ": " + shortMethodName(clobbered.method)
-                    + ", " + shortMethodName(binding.method);
-                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg,
-                    binding.method);
-              }
+              addTo.put(key, binding);
               break;
 
             case SET:
-              String elementKey = GeneratorKeys.getElementKey(providerMethod);
-              SetBinding.add(addTo, elementKey, binding);
+              String setKey = GeneratorKeys.getSetKey(providerMethod);
+              SetBinding.add(addTo, setKey, binding);
               break;
 
             default:
@@ -257,15 +259,15 @@
     }
   }
 
-  static class ProviderMethodBinding extends AbstractProviderMethodBinding<Object> {
+  static class ProviderMethodBinding extends Binding<Object> {
     private final ExecutableElement method;
     private final Binding<?>[] parameters;
 
     protected ProviderMethodBinding(String provideKey, ExecutableElement method, boolean library) {
-      super(provideKey, null, method.getAnnotation(Singleton.class) != null, method.toString());
+      super(provideKey, null, method.getAnnotation(Singleton.class) != null,
+          CodeGen.methodName(method));
       this.method = method;
       this.parameters = new Binding[method.getParameters().size()];
-      setMethodName(method.getSimpleName().toString());
       setLibrary(library);
     }
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java b/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
index 0b51da3..75c9e7f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
@@ -63,7 +63,7 @@
   }
 
   /** Returns the provided key for {@code method} wrapped by {@code Set}. */
-  public static String getElementKey(ExecutableElement method) {
+  public static String getSetKey(ExecutableElement method) {
     StringBuilder result = new StringBuilder();
     AnnotationMirror qualifier = getQualifier(method.getAnnotationMirrors(), method);
     if (qualifier != null) {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
index 57616de..be46839 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesProcessor.java
@@ -309,7 +309,7 @@
             break;
           }
           case SET: {
-            String key = GeneratorKeys.getElementKey(providerMethod);
+            String key = GeneratorKeys.getSetKey(providerMethod);
             writer.emitStatement("SetBinding.add(map, %s, new %s(module))",
                 JavaWriter.stringLiteral(key),
                 bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
/Fim/
diff --git a/core/src/main/java/dagger/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
index f42f19e..3df9877 100644
--- a/core/src/main/java/dagger/internal/Keys.java
+++ b/core/src/main/java/dagger/internal/Keys.java
@@ -88,7 +88,7 @@
    * @param annotations the annotations on a single method, field or parameter.
    *     This array may contain at most one qualifier annotation.
    */
-  public static String getElementKey(Type type, Annotation[] annotations, Object subject) {
+  public static String getSetKey(Type type, Annotation[] annotations, Object subject) {
     Annotation qualifier = extractQualifier(annotations, subject);
     type = boxIfPrimitive(type);
     StringBuilder result = new StringBuilder();
/Fim/
diff --git a/core/src/main/java/dagger/internal/ProblemDetector.java b/core/src/main/java/dagger/internal/ProblemDetector.java
index 76023b6..a2a9ff5 100644
--- a/core/src/main/java/dagger/internal/ProblemDetector.java
+++ b/core/src/main/java/dagger/internal/ProblemDetector.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal;
 
-import dagger.internal.plugins.AbstractProviderMethodBinding;
 import java.util.AbstractSet;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -31,24 +30,19 @@
   }
 
   public void detectUnusedBinding(Collection<Binding<?>> bindings) {
-    ArrayList<Binding> unusedBindings = new ArrayList<Binding>();
+    List<Binding> unusedBindings = new ArrayList<Binding>();
     for (Binding<?> binding : bindings) {
       if (!binding.library() && !binding.dependedOn()) {
         unusedBindings.add(binding);
       }
     }
-    if (unusedBindings.size() > 0) {
+    if (!unusedBindings.isEmpty()) {
       StringBuilder builder = new StringBuilder();
-      builder.append("You have these unused @Provider methods! ");
-      builder.append("Set library=true in your module to disable this check.\n");
-      for (Binding<?> binding : unusedBindings) {
-        AbstractProviderMethodBinding<?> providerBinding =
-            (AbstractProviderMethodBinding<?>) binding;
-        builder.append(providerBinding.getModuleName())
-            .append(".")
-            .append(providerBinding.getMethodName())
-            .append("()\n");
+      builder.append("You have these unused @Provider methods:");
+      for (int i = 0; i < unusedBindings.size(); i++) {
+        builder.append("\n    ").append(i).append(". ").append(unusedBindings.get(i).requiredBy);
       }
+      builder.append("\n    Set library=true in your module to disable this check.");
       throw new IllegalStateException(builder.toString());
     }
   }
/Fim/
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index c7f66e4..efd821f 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -28,21 +28,25 @@
  */
 public final class SetBinding<T> extends Binding<Set<T>> {
 
-  public static <T> void add(Map<String, Binding<?>> bindings, String elementKey,
-      Binding<?> binding) {
-    @SuppressWarnings("unchecked")
-    SetBinding<T> elementBinding = (SetBinding<T>) bindings.get(elementKey);
-    if (elementBinding == null) {
-      elementBinding = new SetBinding<T>(elementKey);
-      bindings.put(elementBinding.provideKey, elementBinding);
+  @SuppressWarnings("unchecked")
+  public static <T> void add(Map<String, Binding<?>> bindings, String setKey, Binding<?> binding) {
+    Binding<?> previous = bindings.get(setKey);
+    SetBinding<T> setBinding;
+    if (previous instanceof SetBinding) {
+      setBinding = (SetBinding) previous;
+    } else if (previous != null) {
+      throw new IllegalArgumentException("Duplicate:\n    " + previous + "\n    " + binding);
+    } else {
+      setBinding = new SetBinding<T>(setKey, binding.requiredBy);
+      bindings.put(setKey, setBinding);
     }
-    elementBinding.contributors.add(Linker.scope(binding));
+    setBinding.contributors.add(Linker.scope(binding));
   }
 
   private final Set<Binding<?>> contributors = new LinkedHashSet<Binding<?>>();
 
-  public SetBinding(String key) {
-    super(key, null, false, null);
+  public SetBinding(String key, Object requiredBy) {
+    super(key, null, false, requiredBy);
   }
 
   @Override public void attach(Linker linker) {
@@ -66,7 +70,7 @@
   }
 
   @Override public void injectMembers(Set<T> t) {
-    throw new UnsupportedOperationException("Cannot inject into a multi-binder Set");
+    throw new UnsupportedOperationException("Cannot inject into a Set binding");
   }
 
   @Override public String toString() {
/Fim/
/Fim/
diff --git a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
index 073a1fc..6d00ca0 100644
--- a/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/plugins/reflect/ReflectiveModuleAdapter.java
@@ -23,7 +23,6 @@
 import dagger.internal.Linker;
 import dagger.internal.ModuleAdapter;
 import dagger.internal.SetBinding;
-import dagger.internal.plugins.AbstractProviderMethodBinding;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
@@ -104,9 +103,8 @@
 
   private <T> void handleSetBindings(Map<String, Binding<?>> bindings, Method method, String key,
       boolean library) {
-    String elementKey =
-        Keys.getElementKey(method.getGenericReturnType(), method.getAnnotations(), method);
-    SetBinding.<T>add(bindings, elementKey, new ProviderMethodBinding<T>(method, key, module,
+    String setKey = Keys.getSetKey(method.getGenericReturnType(), method.getAnnotations(), method);
+    SetBinding.<T>add(bindings, setKey, new ProviderMethodBinding<T>(method, key, module,
         library));
   }
 
@@ -131,19 +129,18 @@
   /**
    * Invokes a method to provide a value. The method's parameters are injected.
    */
-  private final class ProviderMethodBinding<T> extends AbstractProviderMethodBinding<T> {
+  private final class ProviderMethodBinding<T> extends Binding<T> {
     private Binding<?>[] parameters;
     private final Method method;
     private final Object instance;
 
     public ProviderMethodBinding(Method method, String key, Object instance, boolean library) {
-      super(key, null, method.isAnnotationPresent(Singleton.class), method);
+      super(key, null, method.isAnnotationPresent(Singleton.class),
+          moduleClass.getName() + "." + method.getName() + "()");
       this.method = method;
       this.instance = instance;
       method.setAccessible(true);
       setLibrary(library);
-      setModuleName(moduleClass.getName());
-      setMethodName(method.getName());
     }
 
     @Override public void attach(Linker linker) {
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index 5ecb004..3538444 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -20,6 +20,7 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.RandomAccess;
+import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
 import javax.inject.Inject;
 import javax.inject.Named;
@@ -353,6 +354,24 @@
     }
   }
 
+  @Test public void providerMethodsConflictWithSet() {
+    @Module
+    class TestModule {
+      @Provides(type = Provides.Type.SET) A provideSetElement() {
+        throw new AssertionError();
+      }
+      @Provides Set<A> provideSet() {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      ObjectGraph.create(new TestModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   @Test public void singletonsInjectedOnlyIntoProviders() {
     class TestEntryPoint {
       @Inject Provider<A> aProvider;
/Fim/
diff --git a/core/src/test/java/dagger/UnusedProviderTest.java b/core/src/test/java/dagger/UnusedProviderTest.java
index c0c0e94..37f12cb 100644
--- a/core/src/test/java/dagger/UnusedProviderTest.java
+++ b/core/src/test/java/dagger/UnusedProviderTest.java
@@ -76,4 +76,20 @@
     graph = graph.plus(new ExampleLibraryModule());
     graph.validate();
   }
+
+  @Test public void unusedSetBinding() throws Exception {
+    @Module
+    class TestModule {
+      @Provides(type = Provides.Type.SET) String provideA() {
+        throw new AssertionError();
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.create(new TestModule());
+    try {
+      graph.validate();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
 }
/Fim/
diff --git a/core/src/test/java/dagger/internal/KeysTest.java b/core/src/test/java/dagger/internal/KeysTest.java
index 83c8aaa..d012560 100644
--- a/core/src/test/java/dagger/internal/KeysTest.java
+++ b/core/src/test/java/dagger/internal/KeysTest.java
@@ -132,7 +132,7 @@
 
   @Test public void testGetElementKey_NoQualifier() throws NoSuchMethodException {
     Method method = KeysTest.class.getDeclaredMethod("elementProvides", new Class<?>[]{});
-    assertThat(Keys.getElementKey(method.getGenericReturnType(), method.getAnnotations(), method))
+    assertThat(Keys.getSetKey(method.getGenericReturnType(), method.getAnnotations(), method))
         .isEqualTo("java.util.Set<java.lang.String>");
   }
 
@@ -141,7 +141,7 @@
 
   @Test public void testGetElementKey_WithQualifier() throws NoSuchMethodException {
     Method method = KeysTest.class.getDeclaredMethod("qualifiedElementProvides", new Class<?>[]{});
-    assertThat(Keys.getElementKey(method.getGenericReturnType(), method.getAnnotations(), method))
+    assertThat(Keys.getSetKey(method.getGenericReturnType(), method.getAnnotations(), method))
         .isEqualTo("@javax.inject.Named(value=foo)/java.util.Set<java.lang.String>");
   }
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 039db61..0965c90 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -44,4 +44,17 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.9</version>
+        <configuration>
+          <excludePackageNames>dagger.internal:dagger.internal.*</excludePackageNames>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
/Fim/
diff --git a/pom.xml b/pom.xml
index cfb0355..aec8bdb 100644
--- a/pom.xml
+++ b/pom.xml
@@ -156,14 +156,6 @@
           </execution>
         </executions>
       </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.9</version>
-        <configuration>
-          <excludePackageNames>dagger.internal:dagger.internal.*</excludePackageNames>
-        </configuration>
-      </plugin>
     </plugins>
   </build>
 </project>
/Fim/
diff --git a/examples/android-activity-graphs/README.md b/examples/android-activity-graphs/README.md
index efdc038..c763b92 100644
--- a/examples/android-activity-graphs/README.md
+++ b/examples/android-activity-graphs/README.md
@@ -15,3 +15,6 @@
 potential for other useful scopes that can be used. For example, having a dedicated object graph
 for the current user session is a great way to manage data that is tied to the currently logged-in
 user.
+
+_Note: The app does not actually do anything when it is run. It is only to show how you can
+ structure Dagger within an Android app_
/Fim/
diff --git a/examples/android-simple/AndroidManifest.xml b/examples/android-simple/AndroidManifest.xml
index 8f0fce3..cdf2399 100644
--- a/examples/android-simple/AndroidManifest.xml
+++ b/examples/android-simple/AndroidManifest.xml
@@ -7,7 +7,9 @@
 
   <uses-sdk android:minSdkVersion="4" android:targetSdkVersion="17"/>
 
-  <application android:label="@string/app_name">
+  <application
+      android:label="@string/app_name"
+      android:name=".DemoApplication">
     <activity
         android:label="@string/app_name"
         android:name=".ui.HomeActivity">
/Fim/
diff --git a/pom.xml b/pom.xml
index aec8bdb..a9c84dd 100644
--- a/pom.xml
+++ b/pom.xml
@@ -43,7 +43,7 @@
     <!-- Compilation -->
     <java.version>1.6</java.version>
     <javax.inject.version>1</javax.inject.version>
-    <javawriter.version>1.0.2</javawriter.version>
+    <javawriter.version>1.0.5</javawriter.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
/Fim/
diff --git a/compiler/src/it/provide-provider-or-lazy/verify.bsh b/compiler/src/it/provide-provider-or-lazy/verify.bsh
index 08487dd..7a5cfd0 100644
--- a/compiler/src/it/provide-provider-or-lazy/verify.bsh
+++ b/compiler/src/it/provide-provider-or-lazy/verify.bsh
@@ -3,10 +3,10 @@
 
 File buildLog = new File(basedir, "build.log");
 new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "@Provides method must not return Provider directly: test.TestModule.provideProvider"});
+    "@Provides method must not return javax.inject.Provider directly: test.TestModule.provideProvider"});
 new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "@Provides method must not return Provider directly: test.TestModule.provideRawProvider"});
+    "@Provides method must not return javax.inject.Provider directly: test.TestModule.provideRawProvider"});
 new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "@Provides method must not return Lazy directly: test.TestModule.provideLazy"});
+    "@Provides method must not return dagger.Lazy directly: test.TestModule.provideLazy"});
 new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "@Provides method must not return Lazy directly: test.TestModule.provideRawLazy"});
+    "@Provides method must not return dagger.Lazy directly: test.TestModule.provideRawLazy"});
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 66e18c4..420388d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -24,6 +24,7 @@
 import dagger.internal.SetBinding;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
@@ -68,7 +69,7 @@
  * Generates an implementation of {@link ModuleAdapter} that includes a binding
  * for each {@code @Provides} method of a target class.
  */
-@SupportedAnnotationTypes({ "dagger.Provides", "dagger.Module" })
+@SupportedAnnotationTypes({ "*" })
 public final class ModuleAdapterProcessor extends AbstractProcessor {
   private final LinkedHashMap<String, List<ExecutableElement>> remainingTypes =
       new LinkedHashMap<String, List<ExecutableElement>>();
@@ -117,11 +118,6 @@
     Elements elementUtils = processingEnv.getElementUtils();
     Types types = processingEnv.getTypeUtils();
 
-    TypeElement providerElement = elementUtils.getTypeElement("javax.inject.Provider");
-    TypeMirror providerType = types.erasure(providerElement.asType());
-    TypeElement lazyElement = elementUtils.getTypeElement("dagger.Lazy");
-    TypeMirror lazyType = types.erasure(lazyElement.asType());
-
     Map<String, List<ExecutableElement>> result = new HashMap<String, List<ExecutableElement>>();
     for (Element providerMethod : providesMethods(env)) {
       switch (providerMethod.getEnclosingElement().getKind()) {
@@ -157,20 +153,17 @@
         continue;
       }
 
+      // Invalidate return types.
       TypeMirror returnType = types.erasure(providerMethodAsExecutable.getReturnType());
-      if (types.isSameType(returnType, providerType)) {
-        error("@Provides method must not return Provider directly: "
-            + type.getQualifiedName()
-            + "."
-            + providerMethod, providerMethod);
-        continue;
-      }
-      if (types.isSameType(returnType, lazyType)) {
-        error("@Provides method must not return Lazy directly: "
-            + type.getQualifiedName()
-            + "."
-            + providerMethod, providerMethod);
-        continue;
+      for (String invalidTypeName : Arrays.asList("javax.inject.Provider", "dagger.Lazy")) {
+        TypeElement invalidTypeElement = elementUtils.getTypeElement(invalidTypeName);
+        if (invalidTypeElement != null) {
+          if (types.isSameType(returnType, types.erasure(invalidTypeElement.asType()))) {
+            error(String.format("@Provides method must not return %s directly: %s.%s",
+                invalidTypeElement, type.getQualifiedName(), providerMethod), providerMethod);
+            continue; // skip to next provides method.
+          }
+        }
       }
 
       List<ExecutableElement> methods = result.get(type.getQualifiedName().toString());
/Fim/
diff --git a/CHANGELOG.md b/CHANGELOG.md
index ff5ba9c..cac577d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,12 @@
 Change Log
 ==========
 
+Version 1.1.0 *(TBD)*
+----------------------------
+
+ * Allow multiple contributions to Set binding via `Provides.Type.SET_VALUES`
+
+
 Version 1.0.1 *(2013-06-03)*
 ----------------------------
 
/Fim/
diff --git a/compiler/src/it/extension-graph-setvalues/pom.xml b/compiler/src/it/extension-graph-setvalues/pom.xml
new file mode 100644
index 0000000..3d308ca
--- /dev/null
+++ b/compiler/src/it/extension-graph-setvalues/pom.xml
@@ -0,0 +1,52 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2013 Square, Inc.
+ Copyright (C) 2013 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>extension-graph-setvalues</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/extension-graph-setvalues/src/main/java/test/TestApp.java b/compiler/src/it/extension-graph-setvalues/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..9ad18af
--- /dev/null
+++ b/compiler/src/it/extension-graph-setvalues/src/main/java/test/TestApp.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.ObjectGraph;
+import dagger.Module;
+import dagger.Provides;
+import java.util.HashSet;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Singleton;
+
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
+
+/**
+ * Contributions to {@code SET_VALUES} binding do not affect Set of providers.
+ */
+class TestApp implements Runnable {
+  @Inject Set<Provider<String>> providers;
+  @Inject Set<String> strings;
+
+  @Override public void run() {
+    System.out.println(strings);
+  }
+
+  public static void main(String[] args) {
+    ObjectGraph root = ObjectGraph.create(new RootModule());
+    ObjectGraph extension = root.plus(new ExtensionModule());
+    extension.get(TestApp.class).run();
+  }
+  
+  @Module(injects = TestApp.class)
+  static class RootModule {
+    @Provides Set<Provider<String>> providers() {
+      return new HashSet<Provider<String>>();
+    }
+    @Provides(type = SET_VALUES) Set<String> strings() {
+      return new HashSet<String>();
+    }
+  }
+
+  @Module(addsTo = RootModule.class, injects = TestApp.class)
+  static class ExtensionModule {
+    @Provides(type = SET) String addToSet() {
+      return "contributed";
+    }
+  }
+}
/Fim/
diff --git a/compiler/src/it/multiple-modules-setvalues/pom.xml b/compiler/src/it/multiple-modules-setvalues/pom.xml
new file mode 100644
index 0000000..bb49416
--- /dev/null
+++ b/compiler/src/it/multiple-modules-setvalues/pom.xml
@@ -0,0 +1,52 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2013 Square, Inc.
+ Copyright (C) 2013 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>multiple-modules-setvalues</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/multiple-modules-setvalues/src/main/java/test/TestApp.java b/compiler/src/it/multiple-modules-setvalues/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..edeeae0
--- /dev/null
+++ b/compiler/src/it/multiple-modules-setvalues/src/main/java/test/TestApp.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.ObjectGraph;
+import dagger.Module;
+import dagger.Provides;
+import java.util.HashSet;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Singleton;
+
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
+
+/**
+ * Contributions to {@code SET_VALUES} binding do not affect Set of providers.
+ */
+class TestApp implements Runnable {
+  @Inject Set<Provider<String>> providers;
+  @Inject Set<String> strings;
+
+  @Override public void run() {
+    System.out.println(strings);
+  }
+
+  public static void main(String[] args) {
+    ObjectGraph root = ObjectGraph.create(new RootModule(), new ContributingModule());
+    root.get(TestApp.class).run();
+  }
+  
+  @Module(injects = TestApp.class)
+  static class RootModule {
+    @Provides Set<Provider<String>> providers() {
+      return new HashSet<Provider<String>>();
+    }
+    @Provides(type = SET_VALUES) Set<String> strings() {
+      return new HashSet<String>();
+    }
+  }
+
+  @Module(injects = TestApp.class, complete = false)
+  static class ContributingModule {
+    @Provides(type = SET) String addToSet() {
+      return "contributed";
+    }
+  }
+}
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index 0c70f96..cd8206b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -51,6 +51,8 @@
 import javax.tools.JavaFileManager;
 import javax.tools.StandardLocation;
 
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
 import static dagger.internal.codegen.TypeUtils.getAnnotation;
 import static dagger.internal.codegen.TypeUtils.getPackage;
 import static dagger.internal.codegen.TypeUtils.isInterface;
@@ -184,7 +186,8 @@
 
           Binding previous = addTo.get(key);
           if (previous != null) {
-            if (provides.type() == Provides.Type.SET && previous instanceof SetBinding) {
+            if ((provides.type() == SET || provides.type() == SET_VALUES)
+                && previous instanceof SetBinding) {
               // No duplicate bindings error if both bindings are set bindings.
             } else {
               String message = "Duplicate bindings for " + key;
@@ -206,6 +209,10 @@
               SetBinding.add(addTo, setKey, binding);
               break;
 
+            case SET_VALUES:
+              SetBinding.add(addTo, key, binding);
+              break;
+
             default:
               throw new AssertionError("Unknown @Provides type " + provides.type());
           }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 1a81463..d7d5962 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -51,6 +51,8 @@
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
 import static dagger.internal.codegen.AdapterJavadocs.binderTypeDocs;
 import static dagger.internal.codegen.TypeUtils.adapterName;
 import static dagger.internal.codegen.TypeUtils.getAnnotation;
@@ -319,6 +321,13 @@
                 bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
             break;
           }
+          case SET_VALUES: {
+            String key = GeneratorKeys.get(providerMethod);
+            writer.emitStatement("SetBinding.add(map, %s, new %s(module))",
+                JavaWriter.stringLiteral(key),
+                bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
+            break;
+          }
           default:
             throw new AssertionError("Unknown @Provides type " + provides.type());
         }
@@ -364,7 +373,8 @@
 
   private boolean checkForMultibindings(List<ExecutableElement> providerMethods) {
     for (ExecutableElement element : providerMethods) {
-      if (element.getAnnotation(Provides.class).type() == Provides.Type.SET) {
+      Provides.Type providesType = element.getAnnotation(Provides.class).type();
+      if (providesType == SET || providesType == SET_VALUES) {
         return true;
       }
     }
/Fim/
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index f9f66ac..d799002 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -46,7 +46,14 @@
      * method as parameters. The {@code Set<T>} produced from the accumulation of values will be
      * immutable.
      */
-    SET
+    SET,
+
+    /**
+     * Like {@link #SET}, except the method's return type is {@code Set<T>}, where any values are
+     * contributed to the set. An example use is to provide a default empty set binding, which is
+     * otherwise not possible using {@link #SET}.
+     */
+    SET_VALUES;
   }
 
   Type type() default Type.UNIQUE;
/Fim/
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index efd821f..9b94c78 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -55,11 +55,16 @@
     }
   }
 
-  @SuppressWarnings("unchecked") // Bindings<T> are the only thing added to contributors.
+  @SuppressWarnings("unchecked") // Only Binding<T> and Set<T> are added to contributors.
   @Override public Set<T> get() {
     Set<T> result = new LinkedHashSet<T>(contributors.size());
     for (Binding<?> contributor : contributors) {
-      result.add((T) contributor.get()); // Let runtime exceptions through.
+      Object contribution = contributor.get(); // Let runtime exceptions through.
+      if (contributor.provideKey.equals(provideKey)) {
+        result.addAll((Set<T>) contribution);
+      } else {
+        result.add((T) contribution);
+      }
     }
     return Collections.unmodifiableSet(result);
   }
/Fim/
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index 7fdb609..09a5e58 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -20,6 +20,7 @@
 import java.util.AbstractList;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.RandomAccess;
 import java.util.Set;
@@ -338,6 +339,50 @@
     }
   }
 
+  @Test public void providesSet() {
+    final Set<A> set = Collections.emptySet();
+
+    class TestEntryPoint {
+      @Inject Set<A> set;
+    }
+
+    @Module(injects = TestEntryPoint.class)
+    class TestModule {
+      @Provides Set<A> provideSet() {
+        return set;
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    TestModule module = new TestModule();
+    ObjectGraph.createWith(new TestingLoader(), module).inject(entryPoint);
+
+    assertThat(entryPoint.set).isSameAs(set);
+  }
+
+  @Test public void providesSetValues() {
+    final Set<A> set = Collections.emptySet();
+
+    class TestEntryPoint {
+      @Inject Set<A> set;
+    }
+
+    @Module(injects = TestEntryPoint.class)
+    class TestModule {
+      @Provides(type = Provides.Type.SET_VALUES) Set<A> provideSet() {
+        return set;
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    TestModule module = new TestModule();
+    ObjectGraph.createWith(new TestingLoader(), module).inject(entryPoint);
+
+    // copies into immutable collection
+    assertThat(entryPoint.set).isNotSameAs(set);
+    assertThat(entryPoint.set).isEqualTo(set);
+  }
+
   @Test public void providerMethodsConflict() {
     @Module
     class TestModule {
@@ -356,7 +401,7 @@
     }
   }
 
-  @Test public void providerMethodsConflictWithSet() {
+  @Test public void providesSetConflictsWithProvidesTypeSet() {
     @Module
     class TestModule {
       @Provides(type = Provides.Type.SET) A provideSetElement() {
@@ -374,6 +419,53 @@
     }
   }
 
+  @Test public void providesSetConflictsWithProvidesTypeSetValues() {
+    @Module
+    class TestModule {
+      @Provides(type = Provides.Type.SET_VALUES) Set<A> provideSetContribution() {
+        throw new AssertionError();
+      }
+      @Provides Set<A> provideSet() {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      ObjectGraph.createWith(new TestingLoader(), new TestModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void providesSetOfProvidersIsDifferentThanProvidesTypeSetValues() {
+    final Set<A> set = Collections.emptySet();
+    final Set<Provider<A>> providers = Collections.emptySet();
+
+    class TestEntryPoint {
+      @Inject Set<A> set;
+      @Inject Set<Provider<A>> providers;
+    }
+
+    @Module(injects = TestEntryPoint.class)
+    class TestModule {
+      @Provides(type = Provides.Type.SET_VALUES) Set<A> provideSetContribution() {
+        return set;
+      }
+      @Provides Set<Provider<A>> provideProviders() {
+        return providers;
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    TestModule module = new TestModule();
+    ObjectGraph.createWith(new TestingLoader(), module).inject(entryPoint);
+
+    // copies into immutable collection
+    assertThat(entryPoint.set).isNotSameAs(set);
+    assertThat(entryPoint.set).isEqualTo(set);
+    assertThat(entryPoint.providers).isSameAs(providers);
+  }
+
   @Test public void singletonsInjectedOnlyIntoProviders() {
     class TestEntryPoint {
       @Inject Provider<A> aProvider;
/Fim/
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index 1393ecc..3960157 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -32,6 +32,8 @@
 import org.junit.runners.JUnit4;
 
 import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
+import static java.util.Collections.emptySet;
 import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -67,6 +69,10 @@
     @Module(injects = TestEntryPoint.class, includes = TestIncludesModule.class)
     class TestModule {
       @Provides(type=SET) String provideFirstString() { return "string1"; }
+
+      @Provides(type=SET_VALUES) Set<String> provideDefaultStrings() {
+        return emptySet();
+      }
     }
 
     TestEntryPoint ep = injectWithModule(new TestEntryPoint(),
@@ -74,6 +80,30 @@
     assertEquals(set("string1", "string2"), ep.strings);
   }
 
+  @Test public void multiValueBindings_MultiModule_NestedSet() {
+    class TestEntryPoint {
+      @Inject Set<Set<String>> stringses;
+    }
+
+    @Module
+    class TestIncludesModule {
+      @Provides(type=SET) Set<String> provideSecondStrings() { return set("string2"); }
+    }
+
+    @Module(injects = TestEntryPoint.class, includes = TestIncludesModule.class)
+    class TestModule {
+      @Provides(type=SET) Set<String> provideFirstStrings() { return set("string1"); }
+
+      @Provides(type=SET_VALUES) Set<Set<String>> provideDefaultStringeses() {
+        return set(set("string3"));
+      }
+    }
+
+    TestEntryPoint ep = injectWithModule(new TestEntryPoint(),
+        new TestModule(), new TestIncludesModule());
+    assertEquals(set(set("string1"),set("string2"), set("string3")), ep.stringses);
+  }
+
   @Test public void multiValueBindings_WithSingletonAndDefaultValues() {
     final AtomicInteger singletonCounter = new AtomicInteger(100);
     final AtomicInteger defaultCounter = new AtomicInteger(200);
@@ -125,10 +155,14 @@
 
     @Module(injects = TestEntryPoint.class)
     class TestModule {
-      @Provides(type=SET) String provideString1() { return "string1"; }
+      @Provides(type=SET_VALUES) Set<String> provideString1() {
+        return set("string1");
+      }
       @Provides(type=SET) String provideString2() { return "string2"; }
       @Provides(type=SET) @Named("foo") String provideString3() { return "string3"; }
-      @Provides(type=SET) @Named("foo") String provideString4() { return "string4"; }
+      @Provides(type=SET_VALUES) @Named("foo") Set<String> provideString4() {
+        return set("string4");
+      }
     }
 
     TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
@@ -189,6 +223,22 @@
     graph.validate();
   }
 
+  @Test public void validateEmptySetBinding() {
+    class TestEntryPoint {
+      @Inject Set<String> strings;
+    }
+
+    @Module(injects = TestEntryPoint.class)
+    class TestModule {
+      @Provides(type=SET_VALUES) Set<String> provideDefault() {
+        return emptySet();
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
+    graph.validate();
+  }
+
   static class Logger {
     @Inject Set<LogSink> loggers;
     public void log(String text, Throwable error) {
/Fim/
diff --git a/core/src/test/java/dagger/UnusedProviderTest.java b/core/src/test/java/dagger/UnusedProviderTest.java
index 683c6dc..7fa59d9 100644
--- a/core/src/test/java/dagger/UnusedProviderTest.java
+++ b/core/src/test/java/dagger/UnusedProviderTest.java
@@ -20,6 +20,8 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import java.util.Set;
+
 import static org.junit.Assert.fail;
 
 @RunWith(JUnit4.class)
@@ -96,4 +98,20 @@
     } catch (IllegalStateException expected) {
     }
   }
+
+  @Test public void unusedSetValuesBinding() throws Exception {
+    @Module
+    class TestModule {
+      @Provides(type = Provides.Type.SET_VALUES) Set<String> provideA() {
+        throw new AssertionError();
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
+    try {
+      graph.validate();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
 }
/Fim/
diff --git a/core/src/test/java/dagger/internal/TestingModuleAdapter.java b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
index d1cf36d..2819a5e 100644
--- a/core/src/test/java/dagger/internal/TestingModuleAdapter.java
+++ b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
@@ -85,7 +85,12 @@
               handleBindings(bindings, method, key, library);
               break;
             case SET:
-              handleSetBindings(bindings, method, key, library);
+              String setKey = Keys.getSetKey(method.getGenericReturnType(),
+                  method.getAnnotations(), method);
+              handleSetBindings(bindings, method, setKey, key, library);
+              break;
+            case SET_VALUES:
+              handleSetBindings(bindings, method, key, key, library);
               break;
             default:
               throw new AssertionError("Unknown @Provides type " + provides.type());
@@ -100,11 +105,9 @@
     bindings.put(key, new ProviderMethodBinding<M>(method, key, module, library));
   }
 
-  private void handleSetBindings(Map<String, Binding<?>> bindings, Method method, String key,
-      boolean library) {
-    String setKey = Keys.getSetKey(method.getGenericReturnType(), method.getAnnotations(), method);
-    SetBinding.<M>add(bindings, setKey, new ProviderMethodBinding<M>(method, key, module,
-        library));
+  private void handleSetBindings(Map<String, Binding<?>> bindings, Method method, String setKey,
+      String providerKey, boolean library) {
+    SetBinding.<M>add(bindings, setKey, new ProviderMethodBinding<M>(method, providerKey, module, library));
   }
 
   @Override public M newModule() {
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 3a5ca8a..7244949 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -79,6 +79,7 @@
             <goals><goal>testCompile</goal></goals>
             <configuration>
               <annotationProcessors>
+                <annotationProcessor>dagger.internal.codegen.ValidationProcessor</annotationProcessor>
                 <annotationProcessor>dagger.internal.codegen.InjectAdapterProcessor</annotationProcessor>
                 <annotationProcessor>dagger.internal.codegen.ModuleAdapterProcessor</annotationProcessor>
                 <annotationProcessor>dagger.internal.codegen.GraphAnalysisProcessor</annotationProcessor>
/Fim/
diff --git a/compiler/src/it/final-field-inject/invoker.properties b/compiler/src/it/final-field-inject/invoker.properties
new file mode 100644
index 0000000..fdd3d20
--- /dev/null
+++ b/compiler/src/it/final-field-inject/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
/Fim/
diff --git a/compiler/src/it/final-field-inject/pom.xml b/compiler/src/it/final-field-inject/pom.xml
new file mode 100644
index 0000000..83aa81f
--- /dev/null
+++ b/compiler/src/it/final-field-inject/pom.xml
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Google, Inc.
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>final-field-inject</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/final-field-inject/src/main/java/test/TestApp.java b/compiler/src/it/final-field-inject/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..fd955fc
--- /dev/null
+++ b/compiler/src/it/final-field-inject/src/main/java/test/TestApp.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Inject;
+
+class TestApp {
+  @Inject final Object nope;
+}
/Fim/
diff --git a/compiler/src/it/final-field-inject/verify.bsh b/compiler/src/it/final-field-inject/verify.bsh
new file mode 100644
index 0000000..1c30652
--- /dev/null
+++ b/compiler/src/it/final-field-inject/verify.bsh
@@ -0,0 +1,6 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Can't inject a final field: test.TestApp.nope"});
/Fim/
diff --git a/compiler/src/it/multiple-qualifiers/invoker.properties b/compiler/src/it/multiple-qualifiers/invoker.properties
new file mode 100644
index 0000000..fdd3d20
--- /dev/null
+++ b/compiler/src/it/multiple-qualifiers/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
/Fim/
diff --git a/compiler/src/it/multiple-qualifiers/pom.xml b/compiler/src/it/multiple-qualifiers/pom.xml
new file mode 100644
index 0000000..655be00
--- /dev/null
+++ b/compiler/src/it/multiple-qualifiers/pom.xml
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Google, Inc.
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>multiple-qualifiers</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/multiple-qualifiers/src/main/java/test/TestApp.java b/compiler/src/it/multiple-qualifiers/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..55a51f4
--- /dev/null
+++ b/compiler/src/it/multiple-qualifiers/src/main/java/test/TestApp.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import java.lang.annotation.Retention;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+class TestApp {
+  static class TestClass1 {
+    @Inject
+    @MyQualifier1
+    @MyQualifier2
+    String field;
+  }
+
+  static class TestClass2 {
+    String string;
+
+    public TestClass2(@MyQualifier1 @MyQualifier2 String constructorParam) {
+      this.string = string;
+    }
+  }
+
+  @Module(injects = TestClass1.class)
+  static class TestModule {
+    @MyQualifier1
+    @MyQualifier2
+    @Provides
+    String providesString() {
+      return "string";
+    }
+  }
+ 
+  @Qualifier
+  @Retention(value = RUNTIME)
+  @interface MyQualifier1 {}
+ 
+  @Qualifier
+  @Retention(value = RUNTIME)
+  @interface MyQualifier2 {}
+}
/Fim/
diff --git a/compiler/src/it/multiple-qualifiers/verify.bsh b/compiler/src/it/multiple-qualifiers/verify.bsh
new file mode 100644
index 0000000..b3fc2a8
--- /dev/null
+++ b/compiler/src/it/multiple-qualifiers/verify.bsh
@@ -0,0 +1,10 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Only one qualifier annotation is allowed per element: test.TestApp.TestClass1.field"});
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Only one qualifier annotation is allowed per element: constructorParam"});   
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Only one qualifier annotation is allowed per element: test.TestApp.TestModule.providesString()"});
/Fim/
diff --git a/compiler/src/it/multiple-scopes/invoker.properties b/compiler/src/it/multiple-scopes/invoker.properties
new file mode 100644
index 0000000..fdd3d20
--- /dev/null
+++ b/compiler/src/it/multiple-scopes/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
/Fim/
diff --git a/compiler/src/it/multiple-scopes/pom.xml b/compiler/src/it/multiple-scopes/pom.xml
new file mode 100644
index 0000000..a45735a
--- /dev/null
+++ b/compiler/src/it/multiple-scopes/pom.xml
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Google, Inc.
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>multiple-scopes</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/multiple-scopes/src/main/java/test/TestApp.java b/compiler/src/it/multiple-scopes/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..06b36a6
--- /dev/null
+++ b/compiler/src/it/multiple-scopes/src/main/java/test/TestApp.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import java.lang.annotation.Retention;
+import javax.inject.Inject;
+import javax.inject.Scope;
+import javax.inject.Singleton;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;;
+
+class TestApp {
+
+  @Singleton
+  @CustomScope
+  static class InjectableClass {
+    @Inject
+    String string;
+  }
+
+  @Module(injects = InjectableClass.class)
+  static class TestModule {
+    @Singleton
+    @CustomScope
+    @Provides
+    String string() {
+      return "string";
+    }
+  }
+
+  @Scope
+  @Retention(value = RUNTIME)
+  public @interface CustomScope {
+  }
+}
/Fim/
diff --git a/compiler/src/it/multiple-scopes/verify.bsh b/compiler/src/it/multiple-scopes/verify.bsh
new file mode 100644
index 0000000..78491d5
--- /dev/null
+++ b/compiler/src/it/multiple-scopes/verify.bsh
@@ -0,0 +1,8 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Only one scoping annotation is allowed per element: test.TestApp.InjectableClass"});
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Only one scoping annotation is allowed per element: test.TestApp.TestModule.string()"});
/Fim/
diff --git a/compiler/src/it/private-inject/verify.bsh b/compiler/src/it/private-inject/verify.bsh
index 0adb8d2..c327478 100644
--- a/compiler/src/it/private-inject/verify.bsh
+++ b/compiler/src/it/private-inject/verify.bsh
@@ -3,6 +3,6 @@
 
 File buildLog = new File(basedir, "build.log");
 new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Can't inject a private field or constructor: test.TestApp.nope"});
+    "Can't inject a private field: test.TestApp.nope"});
 new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Can't inject a private field or constructor: test.TestFoo.TestFoo()"});
+    "Can't inject a private constructor: test.TestFoo.TestFoo()"});
/Fim/
diff --git a/compiler/src/it/provides-method-not-in-module/invoker.properties b/compiler/src/it/provides-method-not-in-module/invoker.properties
new file mode 100644
index 0000000..fdd3d20
--- /dev/null
+++ b/compiler/src/it/provides-method-not-in-module/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
/Fim/
diff --git a/compiler/src/it/provides-method-not-in-module/pom.xml b/compiler/src/it/provides-method-not-in-module/pom.xml
new file mode 100644
index 0000000..89f527d
--- /dev/null
+++ b/compiler/src/it/provides-method-not-in-module/pom.xml
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Google, Inc.
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>provides-method-not-in-module</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/provides-method-not-in-module/src/main/java/test/TestApp.java b/compiler/src/it/provides-method-not-in-module/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..8748d37
--- /dev/null
+++ b/compiler/src/it/provides-method-not-in-module/src/main/java/test/TestApp.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Provides;
+
+class TestApp {
+
+  @Provides
+  String providesString() {
+    return "string";
+  }
+}
/Fim/
diff --git a/compiler/src/it/provides-method-not-in-module/verify.bsh b/compiler/src/it/provides-method-not-in-module/verify.bsh
new file mode 100644
index 0000000..22cdec5
--- /dev/null
+++ b/compiler/src/it/provides-method-not-in-module/verify.bsh
@@ -0,0 +1,6 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "@Provides methods must be declared in modules: test.TestApp.providesString()"});
/Fim/
diff --git a/compiler/src/it/qualifiers-on-invalid-elements-errors/invoker.properties b/compiler/src/it/qualifiers-on-invalid-elements-errors/invoker.properties
new file mode 100644
index 0000000..fdd3d20
--- /dev/null
+++ b/compiler/src/it/qualifiers-on-invalid-elements-errors/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
/Fim/
diff --git a/compiler/src/it/qualifiers-on-invalid-elements-errors/pom.xml b/compiler/src/it/qualifiers-on-invalid-elements-errors/pom.xml
new file mode 100644
index 0000000..adb65c2
--- /dev/null
+++ b/compiler/src/it/qualifiers-on-invalid-elements-errors/pom.xml
@@ -0,0 +1,52 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Google, Inc.
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>qualifiers-on-invalid-elements-errors</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+          <showWarnings>true</showWarnings>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/qualifiers-on-invalid-elements-errors/src/main/java/test/TestApp.java b/compiler/src/it/qualifiers-on-invalid-elements-errors/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..b423221
--- /dev/null
+++ b/compiler/src/it/qualifiers-on-invalid-elements-errors/src/main/java/test/TestApp.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import java.lang.annotation.Retention;
+import javax.inject.Inject;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+class TestApp {
+
+  @MyQualifier
+  static class TestClass1 {
+    
+    @MyQualifier // qualfier on non-injectable constructor
+    public TestClass1(String constructorParam) {}
+  }
+  
+  static class TestClass2 {
+    String string;
+    
+    @Inject
+    @MyQualifier // qualifier on injectable constructor
+    public TestClass2(String injectableConstructorParam) {
+      this.string = string;
+    }  
+  }
+  
+  @Qualifier
+  @Retention(value = RUNTIME)
+  @interface MyQualifier {}
+}
/Fim/
diff --git a/compiler/src/it/qualifiers-on-invalid-elements-errors/verify.bsh b/compiler/src/it/qualifiers-on-invalid-elements-errors/verify.bsh
new file mode 100644
index 0000000..814ff8b
--- /dev/null
+++ b/compiler/src/it/qualifiers-on-invalid-elements-errors/verify.bsh
@@ -0,0 +1,10 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Qualifier annotations are only allowed on fields, methods, and parameters: test.TestApp.TestClass1"});   
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Qualifier annotations are only allowed on fields, methods, and parameters: test.TestApp.TestClass1.TestClass1(java.lang.String)"});   
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Qualifier annotations are only allowed on fields, methods, and parameters: test.TestApp.TestClass2.TestClass2(java.lang.String)"});
/Fim/
diff --git a/compiler/src/it/qualifiers-on-invalid-elements-warnings/pom.xml b/compiler/src/it/qualifiers-on-invalid-elements-warnings/pom.xml
new file mode 100644
index 0000000..ca4cb32
--- /dev/null
+++ b/compiler/src/it/qualifiers-on-invalid-elements-warnings/pom.xml
@@ -0,0 +1,52 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Google, Inc.
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>qualifiers-on-invalid-elements-warnings</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+          <showWarnings>true</showWarnings>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/qualifiers-on-invalid-elements-warnings/src/main/java/test/TestApp.java b/compiler/src/it/qualifiers-on-invalid-elements-warnings/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..4b2c746
--- /dev/null
+++ b/compiler/src/it/qualifiers-on-invalid-elements-warnings/src/main/java/test/TestApp.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import java.lang.annotation.Retention;
+import javax.inject.Inject;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+class TestApp {
+
+  static class TestClass {
+    @MyQualifier int field1; // non-injectable field
+    
+    @SuppressWarnings("some string other than 'qualifiers'")
+    @MyQualifier 
+    int field2;
+    
+    @SuppressWarnings("qualifiers")
+    @MyQualifier 
+    int fieldWithWarningSuppressed1;
+    
+    @SuppressWarnings({"foo", "qualifiers", "bar"})
+    @MyQualifier 
+    int fieldWithWarningSuppressed2;
+    
+    // qualfier on non-injectable constructor parameter
+    public TestClass(@MyQualifier String constructorParam) {}
+    
+    @MyQualifier 
+    void nonProvidesMethod(@MyQualifier String methodParam) {}
+  }
+  
+  @Qualifier
+  @Retention(value = RUNTIME)
+  @interface MyQualifier {}
+}
/Fim/
diff --git a/compiler/src/it/qualifiers-on-invalid-elements-warnings/verify.bsh b/compiler/src/it/qualifiers-on-invalid-elements-warnings/verify.bsh
new file mode 100644
index 0000000..82afe08
--- /dev/null
+++ b/compiler/src/it/qualifiers-on-invalid-elements-warnings/verify.bsh
@@ -0,0 +1,18 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Dagger will ignore qualifier annotations on fields that are not annotated with @Inject: test.TestApp.TestClass.field1"});   
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Dagger will ignore qualifier annotations on fields that are not annotated with @Inject: test.TestApp.TestClass.field2"});   
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Dagger will ignore qualifier annotations on methods that are not @Provides methods: test.TestApp.TestClass.nonProvidesMethod(java.lang.String)"});  
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Dagger will ignore qualifier annotations on parameters that are not @Inject constructor parameters or @Provides method parameters: methodParam"});  
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Dagger will ignore qualifier annotations on parameters that are not @Inject constructor parameters or @Provides method parameters: constructorParam"});
+new BuildLogValidator().assertDoesNotHaveText(buildLog, new String[]{
+    "Dagger will ignore qualifier annotations on fields that are not annotated with @Inject: test.TestApp.TestClass.fieldWithWarningSuppressed1"});
+new BuildLogValidator().assertDoesNotHaveText(buildLog, new String[]{
+    "Dagger will ignore qualifier annotations on fields that are not annotated with @Inject: test.TestApp.TestClass.fieldWithWarningSuppressed2"});
/Fim/
diff --git a/compiler/src/it/scope-on-abstract/invoker.properties b/compiler/src/it/scope-on-abstract/invoker.properties
new file mode 100644
index 0000000..fdd3d20
--- /dev/null
+++ b/compiler/src/it/scope-on-abstract/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
/Fim/
diff --git a/compiler/src/it/scope-on-abstract/pom.xml b/compiler/src/it/scope-on-abstract/pom.xml
new file mode 100644
index 0000000..b0555da
--- /dev/null
+++ b/compiler/src/it/scope-on-abstract/pom.xml
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Google, Inc.
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>scope-on-abstract</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/scope-on-abstract/src/main/java/test/TestApp.java b/compiler/src/it/scope-on-abstract/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..52aeea6
--- /dev/null
+++ b/compiler/src/it/scope-on-abstract/src/main/java/test/TestApp.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Singleton;
+
+class TestApp {
+  
+  @Singleton
+  abstract class AbstractClass {}
+
+  @Singleton
+  interface Interface {}
+}
/Fim/
diff --git a/compiler/src/it/scope-on-abstract/verify.bsh b/compiler/src/it/scope-on-abstract/verify.bsh
new file mode 100644
index 0000000..0cf3b58
--- /dev/null
+++ b/compiler/src/it/scope-on-abstract/verify.bsh
@@ -0,0 +1,8 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Scoping annotations are only allowed on concrete types and @Provides methods: test.TestApp.AbstractClass"});
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Scoping annotations are only allowed on concrete types and @Provides methods: test.TestApp.Interface"});
/Fim/
diff --git a/compiler/src/it/scopes-on-invalid-elements-errors/invoker.properties b/compiler/src/it/scopes-on-invalid-elements-errors/invoker.properties
new file mode 100644
index 0000000..fdd3d20
--- /dev/null
+++ b/compiler/src/it/scopes-on-invalid-elements-errors/invoker.properties
@@ -0,0 +1 @@
+invoker.buildResult=failure
/Fim/
diff --git a/compiler/src/it/scopes-on-invalid-elements-errors/pom.xml b/compiler/src/it/scopes-on-invalid-elements-errors/pom.xml
new file mode 100644
index 0000000..7f89ff1
--- /dev/null
+++ b/compiler/src/it/scopes-on-invalid-elements-errors/pom.xml
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Google, Inc.
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>scopes-on-invalid-elements-errors</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/scopes-on-invalid-elements-errors/src/main/java/test/TestApp.java b/compiler/src/it/scopes-on-invalid-elements-errors/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..15962a4
--- /dev/null
+++ b/compiler/src/it/scopes-on-invalid-elements-errors/src/main/java/test/TestApp.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+class TestApp {
+
+  static class TestClass1 {
+    // Scoped Injectable field
+    @Inject
+    @Singleton
+    Integer field;
+
+    // method with a scoped parameter
+    void method(@Singleton int param) {}
+  }
+
+  static class TestClass2 {
+    // Scoped non-injectable field
+    @Singleton
+    String string;
+  }
+
+  @Module(complete = false, library = true)
+  static class TestModule {
+    
+    // Even though it's a @Provides method, its parameters cannot be scoped
+    @Provides
+    Integer integer(@Singleton int myInt) {
+      return myInt;
+    }
+  }
+}
/Fim/
diff --git a/compiler/src/it/scopes-on-invalid-elements-errors/verify.bsh b/compiler/src/it/scopes-on-invalid-elements-errors/verify.bsh
new file mode 100644
index 0000000..ce74a94
--- /dev/null
+++ b/compiler/src/it/scopes-on-invalid-elements-errors/verify.bsh
@@ -0,0 +1,12 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Scoping annotations are only allowed on concrete types and @Provides methods: test.TestApp.TestClass1.field"});   
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Scoping annotations are only allowed on concrete types and @Provides methods: param"});   
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Scoping annotations are only allowed on concrete types and @Provides methods: test.TestApp.TestClass2.string"});   
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Scoping annotations are only allowed on concrete types and @Provides methods: myInt"});
/Fim/
diff --git a/compiler/src/it/scopes-on-invalid-elements-warnings/pom.xml b/compiler/src/it/scopes-on-invalid-elements-warnings/pom.xml
new file mode 100644
index 0000000..c5825cd
--- /dev/null
+++ b/compiler/src/it/scopes-on-invalid-elements-warnings/pom.xml
@@ -0,0 +1,52 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright (C) 2013 Google, Inc.
+  Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>scopes-on-invalid-elements-warnings</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+         <showWarnings>true</showWarnings>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/scopes-on-invalid-elements-warnings/src/main/java/test/TestApp.java b/compiler/src/it/scopes-on-invalid-elements-warnings/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..1a7b8ff
--- /dev/null
+++ b/compiler/src/it/scopes-on-invalid-elements-warnings/src/main/java/test/TestApp.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import javax.inject.Singleton;
+
+class TestApp {
+   
+    // Scoped non @Provides method
+    @Singleton
+    void method1() {}
+    
+    @SuppressWarnings("some string other than 'scoping'")
+    @Singleton
+    void method2() {}
+    
+    @SuppressWarnings("scoping")
+    @Singleton
+    void methodWithWarningSupressed1() {}
+    
+    @SuppressWarnings({"foo", "scoping", "bar"})
+    @Singleton
+    void methodWithWarningSupressed2() {}
+}
/Fim/
diff --git a/compiler/src/it/scopes-on-invalid-elements-warnings/verify.bsh b/compiler/src/it/scopes-on-invalid-elements-warnings/verify.bsh
new file mode 100644
index 0000000..325304b
--- /dev/null
+++ b/compiler/src/it/scopes-on-invalid-elements-warnings/verify.bsh
@@ -0,0 +1,12 @@
+import dagger.testing.it.BuildLogValidator;
+import java.io.File;
+
+File buildLog = new File(basedir, "build.log");
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Dagger will ignore scoping annotations on methods that are not @Provides methods: test.TestApp.method1()"});
+new BuildLogValidator().assertHasText(buildLog, new String[]{
+    "Dagger will ignore scoping annotations on methods that are not @Provides methods: test.TestApp.method2()"});
+new BuildLogValidator().assertDoesNotHaveText(buildLog, new String[]{
+    "Dagger will ignore scoping annotations on methods that are not @Provides methods: test.TestApp.methodWithWarningSupressed1()"});
+new BuildLogValidator().assertDoesNotHaveText(buildLog, new String[]{
+    "Dagger will ignore scoping annotations on methods that are not @Provides methods: test.TestApp.methodWithWarningSupressed2()"});
/Fim/
diff --git a/compiler/src/it/valid-scoping/pom.xml b/compiler/src/it/valid-scoping/pom.xml
new file mode 100644
index 0000000..159908c
--- /dev/null
+++ b/compiler/src/it/valid-scoping/pom.xml
@@ -0,0 +1,52 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2013 Google, Inc.
+ Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>valid-scoping</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/valid-scoping/src/main/java/test/TestApp.java b/compiler/src/it/valid-scoping/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..5ae5adf
--- /dev/null
+++ b/compiler/src/it/valid-scoping/src/main/java/test/TestApp.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+class TestApp {
+  
+  @Singleton
+  static class InjectableClass {
+    @Inject String string;
+  }
+
+  @Module(injects = InjectableClass.class)
+  static class TestModule {
+    
+    @Singleton
+    @Provides 
+    String string() {
+      return "string";
+    }
+  }
+}
/Fim/
diff --git a/compiler/src/it/valid-use-of-qualifiers/pom.xml b/compiler/src/it/valid-use-of-qualifiers/pom.xml
new file mode 100644
index 0000000..50bac37
--- /dev/null
+++ b/compiler/src/it/valid-use-of-qualifiers/pom.xml
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2013 Google, Inc.
+ Copyright (C) 2013 Square, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <groupId>com.example.dagger.tests</groupId>
+  <artifactId>valid-use-ofqualifiers</artifactId>
+  <version>HEAD-SNAPSHOT</version>
+  <name>Dagger Integration Test Basic</name>
+  <dependencies>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger</artifactId>
+      <version>@dagger.version@</version>
+    </dependency>
+    <dependency>
+      <groupId>@dagger.groupId@</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>@dagger.version@</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.5</source>
+          <target>1.5</target>
+          <showWarnings>true</showWarnings>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
/Fim/
diff --git a/compiler/src/it/valid-use-of-qualifiers/src/main/java/test/TestApp.java b/compiler/src/it/valid-use-of-qualifiers/src/main/java/test/TestApp.java
new file mode 100644
index 0000000..da21df5
--- /dev/null
+++ b/compiler/src/it/valid-use-of-qualifiers/src/main/java/test/TestApp.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import java.lang.annotation.Retention;
+import javax.inject.Inject;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+class TestApp {
+  static class TestClass1 {
+    @Inject @MyQualifier1 String field;
+  }
+  
+  static class TestClass2 {
+    String string;
+    
+    @Inject
+    public TestClass2(@MyQualifier1 String constructorParam) {
+      this.string = string;
+    }
+  }
+
+  @Module(injects = TestClass1.class)
+  static class TestModule {
+
+    @Provides
+    @MyQualifier1
+    String providesString(@MyQualifier2 String providesMethodParam) {
+      return providesMethodParam + "foo";
+    }
+    
+    @Provides
+    @MyQualifier2
+    String providesString() {
+      return "foo";
+    }
+  }
+  @Qualifier
+  @Retention(value = RUNTIME)
+  @interface MyQualifier1 {}
+  
+  @Qualifier
+  @Retention(value = RUNTIME)
+  @interface MyQualifier2 {}
+}
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java b/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
index 838fa9c..17f1800 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GeneratorKeys.java
@@ -25,8 +25,8 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
 
-import static dagger.internal.codegen.TypeUtils.rawTypeToString;
-import static dagger.internal.codegen.TypeUtils.typeToString;
+import static dagger.internal.codegen.Util.rawTypeToString;
+import static dagger.internal.codegen.Util.typeToString;
 
 /**
  * Creates keys using javac's mirror APIs. Unlike {@code Keys}, this class uses
@@ -57,7 +57,7 @@
   /** Returns the provided key for {@code method}. */
   public static String get(ExecutableElement method) {
     StringBuilder result = new StringBuilder();
-    AnnotationMirror qualifier = getQualifier(method.getAnnotationMirrors(), method);
+    AnnotationMirror qualifier = getQualifier(method.getAnnotationMirrors());
     if (qualifier != null) {
       qualifierToString(qualifier, result);
     }
@@ -68,7 +68,7 @@
   /** Returns the provided key for {@code method} wrapped by {@code Set}. */
   public static String getSetKey(ExecutableElement method) {
     StringBuilder result = new StringBuilder();
-    AnnotationMirror qualifier = getQualifier(method.getAnnotationMirrors(), method);
+    AnnotationMirror qualifier = getQualifier(method.getAnnotationMirrors());
     if (qualifier != null) {
       qualifierToString(qualifier, result);
     }
@@ -81,7 +81,7 @@
   /** Returns the provider key for {@code variable}. */
   public static String get(VariableElement variable) {
     StringBuilder result = new StringBuilder();
-    AnnotationMirror qualifier = getQualifier(variable.getAnnotationMirrors(), variable);
+    AnnotationMirror qualifier = getQualifier(variable.getAnnotationMirrors());
     if (qualifier != null) {
       qualifierToString(qualifier, result);
     }
@@ -103,16 +103,14 @@
     result.append(")/");
   }
 
+  /** Does not test for multiple qualifiers. This is tested in {@code ValidationProcessor}.  */
   private static AnnotationMirror getQualifier(
-      List<? extends AnnotationMirror> annotations, Object member) {
+      List<? extends AnnotationMirror> annotations) {
     AnnotationMirror qualifier = null;
     for (AnnotationMirror annotation : annotations) {
       if (annotation.getAnnotationType().asElement().getAnnotation(Qualifier.class) == null) {
         continue;
       }
-      if (qualifier != null) {
-        throw new IllegalArgumentException("Too many qualifier annotations on " + member);
-      }
       qualifier = annotation;
     }
     return qualifier;
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
index aafa6c7..2d83501 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisInjectBinding.java
@@ -30,7 +30,7 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
 
-import static dagger.internal.codegen.TypeUtils.getApplicationSupertype;
+import static dagger.internal.codegen.Util.getApplicationSupertype;
 
 /**
  * A build time binding that injects the constructor and fields of a class.
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index b3df601..bb55063 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -53,10 +53,10 @@
 
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
-import static dagger.internal.codegen.TypeUtils.getAnnotation;
-import static dagger.internal.codegen.TypeUtils.getPackage;
-import static dagger.internal.codegen.TypeUtils.isInterface;
-import static dagger.internal.codegen.TypeUtils.methodName;
+import static dagger.internal.codegen.Util.getAnnotation;
+import static dagger.internal.codegen.Util.getPackage;
+import static dagger.internal.codegen.Util.isInterface;
+import static dagger.internal.codegen.Util.methodName;
 
 /**
  * Performs full graph analysis on a module.
@@ -84,7 +84,7 @@
         }
         delayedModuleNames.add(((TypeElement) e).getQualifiedName().toString());
       }
-      return true;
+      return false;
     }
 
     Set<Element> modules = new LinkedHashSet<Element>();
@@ -132,7 +132,7 @@
         }
       }
     }
-    return true;
+    return false;
   }
 
   private void error(String message, Element element) {
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisStaticInjection.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisStaticInjection.java
index 5f4b96a..dee4376 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisStaticInjection.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisStaticInjection.java
@@ -20,7 +20,7 @@
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 
-import static dagger.internal.codegen.TypeUtils.isStatic;
+import static dagger.internal.codegen.Util.isStatic;
 
 public final class GraphAnalysisStaticInjection extends StaticInjection {
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
index cb47831..a037642 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -47,13 +48,14 @@
 import javax.tools.JavaFileObject;
 
 import static dagger.internal.codegen.AdapterJavadocs.binderTypeDocs;
-import static dagger.internal.codegen.TypeUtils.adapterName;
-import static dagger.internal.codegen.TypeUtils.getApplicationSupertype;
-import static dagger.internal.codegen.TypeUtils.getNoArgsConstructor;
-import static dagger.internal.codegen.TypeUtils.getPackage;
-import static dagger.internal.codegen.TypeUtils.isCallableConstructor;
-import static dagger.internal.codegen.TypeUtils.rawTypeToString;
-import static dagger.internal.codegen.TypeUtils.typeToString;
+import static dagger.internal.codegen.Util.adapterName;
+import static dagger.internal.codegen.Util.elementToString;
+import static dagger.internal.codegen.Util.getApplicationSupertype;
+import static dagger.internal.codegen.Util.getNoArgsConstructor;
+import static dagger.internal.codegen.Util.getPackage;
+import static dagger.internal.codegen.Util.isCallableConstructor;
+import static dagger.internal.codegen.Util.rawTypeToString;
+import static dagger.internal.codegen.Util.typeToString;
 import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
 import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
@@ -95,7 +97,7 @@
       processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
           "Could not find injection type required by " + remainingTypeNames);
     }
-    return true;
+    return false;
   }
 
   private void writeInjectionsForClass(InjectedClass injectedClass) throws IOException {
@@ -136,17 +138,30 @@
     Element injectableType = injectable.getEnclosingElement();
 
     if (injectable.getKind() == ElementKind.CLASS) {
-      error("@Inject is not valid on a class: " + injectable, injectable);
+      error("@Inject is not valid on a class: " + elementToString(injectable), injectable);
       return false;
     }
 
     if (injectable.getKind() == ElementKind.METHOD) {
-      error("Method injection is not supported: " + injectableType + "." + injectable, injectable);
+      error("Method injection is not supported: " + elementToString(injectable), injectable);
       return false;
     }
-    if (injectable.getModifiers().contains(Modifier.PRIVATE)) {
-      error("Can't inject a private field or constructor: " + injectableType + "." + injectable,
-          injectable);
+
+    if (injectable.getKind() == ElementKind.FIELD
+        && injectable.getModifiers().contains(Modifier.FINAL)) {
+      error("Can't inject a final field: " + elementToString(injectable), injectable);
+      return false;
+    }
+
+    if (injectable.getKind() == ElementKind.FIELD
+        && injectable.getModifiers().contains(Modifier.PRIVATE)) {
+      error("Can't inject a private field: " + elementToString(injectable), injectable);
+      return false;
+    }
+
+    if (injectable.getKind() == ElementKind.CONSTRUCTOR
+        && injectable.getModifiers().contains(Modifier.PRIVATE)) {
+      error("Can't inject a private constructor: " + elementToString(injectable), injectable);
       return false;
     }
 
@@ -155,7 +170,8 @@
     boolean isStatic = injectableType.getModifiers().contains(Modifier.STATIC);
 
     if (isClassOrInterface && !isStatic) {
-      error("Can't inject a non-static inner class: " + injectableType, injectableType);
+      error("Can't inject a non-static inner class: " + elementToString(injectable),
+          injectableType);
       return false;
     }
 
@@ -197,7 +213,7 @@
           break;
         default:
           // TODO(tbroyer): pass annotation information
-          error("Cannot inject " + member, member);
+          error("Cannot inject " + elementToString(member), member);
           break;
       }
     }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 1f5c7fc..4760104 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -55,13 +55,14 @@
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
 import static dagger.internal.codegen.AdapterJavadocs.binderTypeDocs;
-import static dagger.internal.codegen.TypeUtils.adapterName;
-import static dagger.internal.codegen.TypeUtils.getAnnotation;
-import static dagger.internal.codegen.TypeUtils.getNoArgsConstructor;
-import static dagger.internal.codegen.TypeUtils.getPackage;
-import static dagger.internal.codegen.TypeUtils.isCallableConstructor;
-import static dagger.internal.codegen.TypeUtils.isInterface;
-import static dagger.internal.codegen.TypeUtils.typeToString;
+import static dagger.internal.codegen.Util.adapterName;
+import static dagger.internal.codegen.Util.elementToString;
+import static dagger.internal.codegen.Util.getAnnotation;
+import static dagger.internal.codegen.Util.getNoArgsConstructor;
+import static dagger.internal.codegen.Util.getPackage;
+import static dagger.internal.codegen.Util.isCallableConstructor;
+import static dagger.internal.codegen.Util.isInterface;
+import static dagger.internal.codegen.Util.typeToString;
 import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
 import static java.lang.reflect.Modifier.FINAL;
 import static java.lang.reflect.Modifier.PRIVATE;
@@ -130,7 +131,7 @@
           break; // valid, move along
         default:
           // TODO(tbroyer): pass annotation information
-          error("Unexpected @Provides on " + providerMethod, providerMethod);
+          error("Unexpected @Provides on " + elementToString(providerMethod), providerMethod);
           continue;
       }
       TypeElement type = (TypeElement) providerMethod.getEnclosingElement();
@@ -185,7 +186,7 @@
     // should still be registered and a ModuleAdapter should still be written.
     for (Element module : env.getElementsAnnotatedWith(Module.class)) {
       if (!module.getKind().equals(ElementKind.CLASS)) {
-        error("Modules must be classes: " + module, module);
+        error("Modules must be classes: " + elementToString(module), module);
         continue;
       }
 
@@ -193,7 +194,7 @@
 
       // Verify that all modules do not extend from non-Object types.
       if (!moduleType.getSuperclass().equals(objectType)) {
-        error("Modules must not extend from other classes: " + module, module);
+        error("Modules must not extend from other classes: " + elementToString(module), module);
       }
 
       String moduleName = moduleType.getQualifiedName().toString();
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
similarity index 96%
rename from compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
rename to compiler/src/main/java/dagger/internal/codegen/Util.java
index 86ee6e5..0826adf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeUtils.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -43,8 +43,8 @@
 /**
  * Utilities for handling types in annotation processors
  */
-final class TypeUtils {
-  private TypeUtils() {
+final class Util {
+  private Util() {
   }
 
   public static PackageElement getPackage(Element type) {
@@ -221,6 +221,20 @@
     }
   }
 
+  // TODO(sgoldfed): better format for other types of elements?
+  static String elementToString(Element element) {
+    switch (element.getKind()) {
+      case FIELD:
+      // fall through
+      case CONSTRUCTOR:
+      // fall through
+      case METHOD:
+        return element.getEnclosingElement() + "." + element;
+      default:
+        return element.toString();
+    }
+  }
+
   static void rawTypeToString(StringBuilder result, TypeElement type,
       char innerClassSeparator) {
     String packageName = getPackage(type).getQualifiedName().toString();
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java
new file mode 100644
index 0000000..3bbac71
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationProcessor.java
@@ -0,0 +1,212 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.annotation.processing.SupportedAnnotationTypes;
+import javax.inject.Inject;
+import javax.inject.Qualifier;
+import javax.inject.Scope;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.tools.Diagnostic;
+
+import static dagger.internal.codegen.Util.elementToString;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static javax.lang.model.element.ElementKind.METHOD;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+/**
+ * Checks for errors that are not directly related to modules and
+ *  {@code @Inject} annotated elements.
+ *
+ *  <p> Warnings for invalid use of qualifier annotations can be suppressed
+ *  with @SuppressWarnings("qualifiers")
+ *
+ *  <p> Warnings for invalid use of scoping annotations can be suppressed
+ *  with @SuppressWarnings("scoping")
+ */
+@SupportedAnnotationTypes({ "*" })
+public final class ValidationProcessor extends AbstractProcessor {
+
+  @Override public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+
+  @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
+    List<Element> allElements = new ArrayList<Element>();
+    Map<Element, Element> parametersToTheirMethods = new LinkedHashMap<Element, Element>();
+    getAllElements(env, allElements, parametersToTheirMethods);
+    for (Element element : allElements) {
+        validateProvides(element);
+        validateScoping(element);
+        validateQualifiers(element, parametersToTheirMethods);
+    }
+    return false;
+  }
+
+  private void validateProvides(Element element) {
+    if (element.getAnnotation(Provides.class) != null
+        && element.getEnclosingElement().getAnnotation(Module.class) == null) {
+      error("@Provides methods must be declared in modules: " + elementToString(element), element);
+    }
+  }
+
+  private void validateQualifiers(Element element, Map<Element, Element> parametersToTheirMethods) {
+    boolean suppressWarnings =
+        element.getAnnotation(SuppressWarnings.class) != null && Arrays.asList(
+            element.getAnnotation(SuppressWarnings.class).value()).contains("qualifiers");
+    int numberOfQualifiersOnElement = 0;
+    for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
+      if (annotation.getAnnotationType().asElement().getAnnotation(Qualifier.class) == null) {
+       continue;
+      }
+      switch (element.getKind()) {
+        case FIELD:
+          numberOfQualifiersOnElement++;
+          if (element.getAnnotation(Inject.class) == null && !suppressWarnings) {
+            warning("Dagger will ignore qualifier annotations on fields that are not "
+                + "annotated with @Inject: " + elementToString(element), element);
+          }
+          break;
+        case METHOD:
+          numberOfQualifiersOnElement++;
+          if (!isProvidesMethod(element) && !suppressWarnings) {
+            warning("Dagger will ignore qualifier annotations on methods that are not "
+                + "@Provides methods: " + elementToString(element), element);
+          }
+          break;
+        case PARAMETER:
+          numberOfQualifiersOnElement++;
+          if (!isInjectableConstructorParameter(element, parametersToTheirMethods)
+              && !isProvidesMethodParameter(element, parametersToTheirMethods)
+              && !suppressWarnings) {
+            warning("Dagger will ignore qualifier annotations on parameters that are not "
+                + "@Inject constructor parameters or @Provides method parameters: "
+                + elementToString(element), element);
+          }
+          break;
+        default:
+          error("Qualifier annotations are only allowed on fields, methods, and parameters: "
+              + elementToString(element), element);
+      }
+    }
+    if (numberOfQualifiersOnElement > 1) {
+      error("Only one qualifier annotation is allowed per element: " + elementToString(element),
+          element);
+    }
+  }
+
+  private void validateScoping(Element element) {
+    boolean suppressWarnings =
+        element.getAnnotation(SuppressWarnings.class) != null && Arrays.asList(
+            element.getAnnotation(SuppressWarnings.class).value()).contains("scoping");
+    int numberOfScopingAnnotationsOnElement = 0;
+    for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
+      if (annotation.getAnnotationType().asElement().getAnnotation(Scope.class) == null) {
+        continue;
+      }
+      switch (element.getKind()) {
+        case METHOD:
+          numberOfScopingAnnotationsOnElement++;
+          if (!isProvidesMethod(element) && !suppressWarnings) {
+            warning("Dagger will ignore scoping annotations on methods that are not "
+                + "@Provides methods: " + elementToString(element), element);
+          }
+          break;
+        case CLASS:
+          if (!element.getModifiers().contains(ABSTRACT)) {
+            numberOfScopingAnnotationsOnElement++;
+            break;
+          }
+        // fall through if abstract
+        default:
+          error("Scoping annotations are only allowed on concrete types and @Provides methods: "
+              + elementToString(element), element);
+      }
+    }
+    if (numberOfScopingAnnotationsOnElement > 1) {
+      error("Only one scoping annotation is allowed per element: " + elementToString(element),
+          element);
+    }
+  }
+
+  private void getAllElements(
+      RoundEnvironment env, List<Element> result, Map<Element, Element> parametersToTheirMethods) {
+    for (Element element : env.getRootElements()) {
+      addAllEnclosed(element, result, parametersToTheirMethods);
+    }
+  }
+
+  private void addAllEnclosed(
+      Element element, List<Element> result, Map<Element, Element> parametersToTheirMethods) {
+    result.add(element);
+    for (Element enclosed : element.getEnclosedElements()) {
+      addAllEnclosed(enclosed, result, parametersToTheirMethods);
+      if (enclosed.getKind() == METHOD || enclosed.getKind() == CONSTRUCTOR) {
+        for (Element parameter : ((ExecutableElement) enclosed).getParameters()) {
+          result.add(parameter);
+          parametersToTheirMethods.put(parameter, enclosed);
+        }
+      }
+    }
+  }
+
+  private boolean isProvidesMethod(Element element) {
+    return element.getKind() == METHOD && element.getAnnotation(Provides.class) != null;
+  }
+
+  /**
+   * @param parameter an {@code Element} whose {@code Kind} is parameter. The {@code Kind} is not
+   *        tested here.
+   */
+  private boolean isProvidesMethodParameter(
+      Element parameter, Map<Element, Element> parametersToTheirMethods) {
+    return parametersToTheirMethods.get(parameter).getAnnotation(Provides.class) != null;
+  }
+
+  /**
+   * @param parameter an {@code Element} whose {@code Kind} is parameter. The {@code Kind} is not
+   *        tested here.
+   */
+  private boolean isInjectableConstructorParameter(
+      Element parameter, Map<Element, Element> parametersToTheirMethods) {
+    return parametersToTheirMethods.get(parameter).getKind() == CONSTRUCTOR
+        && parametersToTheirMethods.get(parameter).getAnnotation(Inject.class) != null;
+  }
+
+  private void error(String msg, Element element) {
+    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg, element);
+  }
+
+  private void warning(String msg, Element element) {
+    processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING, msg, element);
+  }
+
+}
/Fim/
diff --git a/compiler/src/main/resources/META-INF/services/javax.annotation.processing.Processor b/compiler/src/main/resources/META-INF/services/javax.annotation.processing.Processor
index dce5a84..97f5f14 100644
--- a/compiler/src/main/resources/META-INF/services/javax.annotation.processing.Processor
+++ b/compiler/src/main/resources/META-INF/services/javax.annotation.processing.Processor
@@ -1,3 +1,4 @@
+dagger.internal.codegen.ValidationProcessor
 dagger.internal.codegen.InjectAdapterProcessor
 dagger.internal.codegen.ModuleAdapterProcessor
-dagger.internal.codegen.GraphAnalysisProcessor
\ No newline at end of file
+dagger.internal.codegen.GraphAnalysisProcessor
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
index 1a497a9..e511c65 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphVisualizerTest.java
@@ -36,12 +36,14 @@
     assertThat(graphVisualizer.shortName(key)).isEqualTo("String");
   }
 
+  @SuppressWarnings("qualifiers")
   @Named String annotatedKey;
   @Test public void testAnnotatedKey() throws Exception {
     String key = fieldKey("annotatedKey");
     assertThat(graphVisualizer.shortName(key)).isEqualTo("@Named String");
   }
 
+  @SuppressWarnings("qualifiers")
   @Named("/@<>[]()") String annotatedKeyWithParameters;
   @Test public void testAnnotatedKeyWithParameters() throws Exception {
     String key = fieldKey("annotatedKeyWithParameters");
@@ -62,6 +64,7 @@
         .isEqualTo("Map<java.lang.String, java.util.Set<java.lang.Object>>");
   }
 
+  @SuppressWarnings("qualifiers")
   @Named("/@<>[]()") Map<String, Set<Object>>[] everythingKey;
   @Test public void testEverythingKey() throws Exception {
     String key = fieldKey("everythingKey");
/Fim/
diff --git a/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java b/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java
index 6106061..9eb15cf 100644
--- a/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java
+++ b/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java
@@ -31,6 +31,50 @@
    * @param expectedStrings the strings that must be present in the log file for it to be valid
    */
   public void assertHasText(File buildLogfile, String ... expectedStrings) throws Throwable {
+    String buildOutput = getBuildOutput(buildLogfile);
+
+    StringBuilder sb = new StringBuilder("Build output did not contain expected error text:");
+    boolean missing = false;
+
+    for (String expected : expectedStrings) {
+      if (!buildOutput.contains(expected)) {
+        missing = true;
+        sb.append("\n    \"").append(expected).append("\"");
+      }
+    }
+    if (missing) {
+      appendBuildStatus(sb, buildOutput);
+      throw new Exception(sb.toString());
+    }
+  }
+
+  /**
+   * Processes a log file, ensuring it does not contain any of the provided strings within it.
+   *
+   * @param buildLogfile a log file to be searched
+   * @param unexpectedStrings the strings that must not be present in the log file for it to be
+   *        valid
+   */
+  public void assertDoesNotHaveText(File buildLogfile, String... unexpectedStrings)
+      throws Throwable {
+    String buildOutput = getBuildOutput(buildLogfile);
+
+    StringBuilder sb = new StringBuilder("Build output contained unexpected text:");
+    boolean found = false;
+
+    for (String unexpected : unexpectedStrings) {
+      if (buildOutput.contains(unexpected)) {
+        found = true;
+        sb.append("\n    \"").append(unexpected).append("\"");
+      }
+    }
+    if (found) {
+      appendBuildStatus(sb, buildOutput);
+      throw new Exception(sb.toString());
+    }
+  }
+
+  private String getBuildOutput(File buildLogfile) throws Throwable {
     String buildOutput;
     FileInputStream stream = new FileInputStream(buildLogfile);
     try {
@@ -43,29 +87,20 @@
     if (buildOutput == null) {
       throw new Exception("Could not read build output");
     }
+    return buildOutput;
+  }
 
-    StringBuilder sb = new StringBuilder("Build output did not contain expected error text:");
-    boolean missing = false;
-
-    for (String expected : expectedStrings) {
-      if (!buildOutput.contains(expected)) {
-        missing = true;
-        sb.append("\n    \"").append(expected).append("\"");
+  private void appendBuildStatus(StringBuilder sb, String buildOutput) {
+    sb.append("\n\nBuild Output:\n\n");
+    boolean containsError = false;
+    for(String line : buildOutput.split("\n")) {
+      if (line.contains("[ERROR]")) {
+        containsError = true;
+        sb.append("\n        ").append(line);
       }
     }
-    if (missing) {
-      sb.append("\n\nBuild Output:\n\n");
-      boolean containsError = false;
-      for(String line : buildOutput.split("\n")) {
-        if (line.contains("[ERROR]")) {
-          containsError = true;
-          sb.append("\n        ").append(line);
-        }
-      }
-      if (!containsError) {
-        sb.append("\nTEST BUILD SUCCEEDED.\n");
-      }
-      throw new Exception(sb.toString());
+    if (!containsError) {
+      sb.append("\nTEST BUILD SUCCEEDED.\n");
     }
   }
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java b/compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java
index 3312f1e..c525ea3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AdapterJavadocs.java
@@ -43,9 +43,9 @@
       + "A manager for {@code %s}'s injections into static fields.";
 
   /** Creates an appropriate javadoc depending on aspects of the type in question. */
-  static String binderTypeDocs(String type, boolean abstrakt, boolean members, boolean dependent) {
+  static String bindingTypeDocs(String type, boolean abstrakt, boolean members, boolean dependent) {
     StringBuffer sb = new StringBuffer();
-    sb.append("A {@code Binder<").append(type).append(">} implementation which satisfies\n");
+    sb.append("A {@code Binding<").append(type).append(">} implementation which satisfies\n");
     sb.append("Dagger's infrastructure requirements including:");
     if (dependent) {
       sb.append("\n\n");
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
index a037642..39ebc4f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
@@ -47,7 +47,7 @@
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
 
-import static dagger.internal.codegen.AdapterJavadocs.binderTypeDocs;
+import static dagger.internal.codegen.AdapterJavadocs.bindingTypeDocs;
 import static dagger.internal.codegen.Util.adapterName;
 import static dagger.internal.codegen.Util.elementToString;
 import static dagger.internal.codegen.Util.getApplicationSupertype;
@@ -75,9 +75,9 @@
   }
 
   @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
-    remainingTypeNames.addAll(getInjectedClassNames(env));
+    remainingTypeNames.addAll(findInjectedClassNames(env));
     for (Iterator<String> i = remainingTypeNames.iterator(); i.hasNext();) {
-      InjectedClass injectedClass = getInjectedClass(i.next());
+      InjectedClass injectedClass = createInjectedClass(i.next());
       // Verify that we have access to all types to be injected on this pass.
       boolean missingDependentClasses =
           !allTypesExist(injectedClass.fields)
@@ -86,7 +86,7 @@
           || !allTypesExist(injectedClass.staticFields);
       if (!missingDependentClasses) {
         try {
-          writeInjectionsForClass(injectedClass);
+          generateInjectionsForClass(injectedClass);
         } catch (IOException e) {
           error("Code gen failed: " + e, injectedClass.type);
         }
@@ -100,12 +100,12 @@
     return false;
   }
 
-  private void writeInjectionsForClass(InjectedClass injectedClass) throws IOException {
+  private void generateInjectionsForClass(InjectedClass injectedClass) throws IOException {
     if (injectedClass.constructor != null || !injectedClass.fields.isEmpty()) {
-      writeInjectAdapter(injectedClass.type, injectedClass.constructor, injectedClass.fields);
+      generateInjectAdapter(injectedClass.type, injectedClass.constructor, injectedClass.fields);
     }
     if (!injectedClass.staticFields.isEmpty()) {
-      writeStaticInjection(injectedClass.type, injectedClass.staticFields);
+      generateStaticInjection(injectedClass.type, injectedClass.staticFields);
     }
   }
 
@@ -122,7 +122,7 @@
     return true;
   }
 
-  private Set<String> getInjectedClassNames(RoundEnvironment env) {
+  private Set<String> findInjectedClassNames(RoundEnvironment env) {
     // First gather the set of classes that have @Inject-annotated members.
     Set<String> injectedTypeNames = new LinkedHashSet<String>();
     for (Element element : env.getElementsAnnotatedWith(Inject.class)) {
@@ -181,7 +181,7 @@
   /**
    * @param injectedClassName the name of a class with an @Inject-annotated member.
    */
-  private InjectedClass getInjectedClass(String injectedClassName) {
+  private InjectedClass createInjectedClass(String injectedClassName) {
     TypeElement type = processingEnv.getElementUtils().getTypeElement(injectedClassName);
     boolean isAbstract = type.getModifiers().contains(Modifier.ABSTRACT);
     List<Element> staticFields = new ArrayList<Element>();
@@ -228,21 +228,17 @@
     return new InjectedClass(type, staticFields, constructor, fields);
   }
 
-
-  private void error(String msg, Element element) {
-    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg, element);
-  }
-
   /**
    * Write a companion class for {@code type} that extends {@link Binding}.
    *
    * @param constructor the injectable constructor, or null if this binding
    *     supports members injection only.
    */
-  private void writeInjectAdapter(TypeElement type, ExecutableElement constructor,
+  private void generateInjectAdapter(TypeElement type, ExecutableElement constructor,
       List<Element> fields) throws IOException {
     String packageName = getPackage(type).getQualifiedName().toString();
-    String strippedTypeName = strippedTypeName(type.getQualifiedName().toString(), packageName);
+    String strippedTypeName =
+        strippedTypeName(type.getQualifiedName().toString(), packageName);
     TypeMirror supertype = getApplicationSupertype(type);
     String adapterName = adapterName(type, INJECT_ADAPTER_SUFFIX);
     JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(adapterName, type);
@@ -257,33 +253,89 @@
 
     writer.emitSingleLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
     writer.emitPackage(packageName);
+    writer.emitImports(findImports(dependent, injectMembers, constructor != null));
     writer.emitEmptyLine();
-    writer.emitImports(getImports(dependent, injectMembers, constructor != null));
-
-    writer.emitEmptyLine();
-    writer.emitJavadoc(binderTypeDocs(strippedTypeName, isAbstract, injectMembers, dependent));
+    writer.emitJavadoc(bindingTypeDocs(strippedTypeName, isAbstract, injectMembers, dependent));
     writer.beginType(adapterName, "class", PUBLIC | FINAL,
         JavaWriter.type(Binding.class, strippedTypeName),
-        interfaces(strippedTypeName, injectMembers, constructor != null));
-
+        implementedInterfaces(strippedTypeName, injectMembers, constructor != null));
+    writeMemberBindingsFields(writer, fields, disambiguateFields);
     if (constructor != null) {
-      for (VariableElement parameter : constructor.getParameters()) {
-        writer.emitField(JavaWriter.type(Binding.class,
-            typeToString(parameter.asType())),
-            parameterName(disambiguateFields, parameter), PRIVATE);
-      }
+      writeParameterBindingsFields(writer, constructor, disambiguateFields);
+     }
+    if (supertype != null) {
+      writeSupertypeInjectorField(writer, supertype);
     }
+    writer.emitEmptyLine();
+    writeInjectAdapterConstructor(writer, constructor, type, strippedTypeName, adapterName);
+    if (dependent) {
+      writeAttachMethod(writer, constructor, fields, disambiguateFields, strippedTypeName,
+          supertype, true);
+      writeGetDependenciesMethod(writer, constructor, fields, disambiguateFields, supertype, true);
+    }
+    if (constructor != null) {
+      writeGetMethod(writer, constructor, disambiguateFields, injectMembers, strippedTypeName);
+    }
+    if (injectMembers) {
+      writeMembersInjectMethod(writer, fields, disambiguateFields, strippedTypeName, supertype);
+    }
+    writer.endType();
+    writer.close();
+  }
+
+  /**
+   * Write a companion class for {@code type} that extends {@link StaticInjection}.
+   */
+  private void generateStaticInjection(TypeElement type, List<Element> fields) throws IOException {
+    String typeName = type.getQualifiedName().toString();
+    String adapterName = adapterName(type, STATIC_INJECTION_SUFFIX);
+    JavaFileObject sourceFile = processingEnv.getFiler()
+        .createSourceFile(adapterName, type);
+    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
+
+    writer.emitSingleLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
+    writer.emitPackage(getPackage(type).getQualifiedName().toString());
+    writer.emitImports(Arrays.asList(
+        StaticInjection.class.getName(),
+        Binding.class.getName(),
+        Linker.class.getName()));
+    writer.emitEmptyLine();
+    writer.emitJavadoc(AdapterJavadocs.STATIC_INJECTION_TYPE, type.getSimpleName());
+    writer.beginType(adapterName, "class", PUBLIC | FINAL, StaticInjection.class.getSimpleName());
+    writeMemberBindingsFields(writer, fields, false);
+    writer.emitEmptyLine();
+    writeAttachMethod(writer, null, fields, false, typeName, null, true);
+    writeStaticInjectMethod(writer, fields, typeName);
+    writer.endType();
+    writer.close();
+  }
+
+  private void writeMemberBindingsFields(
+      JavaWriter writer, List<Element> fields, boolean disambiguateFields) throws IOException {
     for (Element field : fields) {
-      writer.emitField(JavaWriter.type(Binding.class,
-          typeToString(field.asType())),
+      writer.emitField(JavaWriter.type(Binding.class, typeToString(field.asType())),
           fieldName(disambiguateFields, field), PRIVATE);
     }
-    if (supertype != null) {
-      writer.emitField(JavaWriter.type(Binding.class,
-          rawTypeToString(supertype, '.')), "supertype", PRIVATE);
-    }
+  }
 
-    writer.emitEmptyLine();
+  private void writeParameterBindingsFields(
+      JavaWriter writer, ExecutableElement constructor, boolean disambiguateFields)
+      throws IOException {
+    for (VariableElement parameter : constructor.getParameters()) {
+      writer.emitField(JavaWriter.type(Binding.class,
+          typeToString(parameter.asType())),
+          parameterName(disambiguateFields, parameter), PRIVATE);
+    }
+  }
+
+  private void writeSupertypeInjectorField(JavaWriter writer, TypeMirror supertype)
+      throws IOException {
+    writer.emitField(
+        JavaWriter.type(Binding.class, rawTypeToString(supertype, '.')), "supertype", PRIVATE);
+  }
+
+  private void writeInjectAdapterConstructor(JavaWriter writer, ExecutableElement constructor,
+      TypeElement type, String strippedTypeName, String adapterName) throws IOException {
     writer.beginMethod(null, adapterName, PUBLIC);
     String key = (constructor != null)
         ? JavaWriter.stringLiteral(GeneratorKeys.get(type.asType()))
@@ -293,173 +345,116 @@
     writer.emitStatement("super(%s, %s, %s, %s.class)",
         key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"), strippedTypeName);
     writer.endMethod();
-    if (dependent) {
-      writer.emitEmptyLine();
-      writer.emitJavadoc(AdapterJavadocs.ATTACH_METHOD);
+    writer.emitEmptyLine();
+  }
+
+  private void writeAttachMethod(JavaWriter writer, ExecutableElement constructor,
+      List<Element> fields, boolean disambiguateFields, String typeName, TypeMirror supertype,
+      boolean extendsBinding) throws IOException {
+    writer.emitJavadoc(AdapterJavadocs.ATTACH_METHOD);
+    if (extendsBinding) {
       writer.emitAnnotation(Override.class);
-      writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
-      writer.beginMethod("void", "attach", PUBLIC, Linker.class.getCanonicalName(), "linker");
-      if (constructor != null) {
-        for (VariableElement parameter : constructor.getParameters()) {
-          writer.emitStatement(
-              "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
-              parameterName(disambiguateFields, parameter),
-              writer.compressType(JavaWriter.type(Binding.class, typeToString(parameter.asType()))),
-              JavaWriter.stringLiteral(GeneratorKeys.get(parameter)),
-              strippedTypeName);
-        }
-      }
-      for (Element field : fields) {
+    }
+    writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
+    writer.beginMethod("void", "attach", PUBLIC, Linker.class.getCanonicalName(), "linker");
+    if (constructor != null) {
+      for (VariableElement parameter : constructor.getParameters()) {
         writer.emitStatement(
             "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
-            fieldName(disambiguateFields, field),
-            writer.compressType(JavaWriter.type(Binding.class, typeToString(field.asType()))),
-            JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) field)),
-            strippedTypeName);
+            parameterName(disambiguateFields, parameter),
+            writer.compressType(JavaWriter.type(Binding.class, typeToString(parameter.asType()))),
+            JavaWriter.stringLiteral(GeneratorKeys.get(parameter)), typeName);
       }
-      if (supertype != null) {
-        writer.emitStatement(
-            "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader()"
-                + ", false, true)", // Yep.  This is a dumb line-length violation otherwise.
-            "supertype",
-            writer.compressType(JavaWriter.type(Binding.class, rawTypeToString(supertype, '.'))),
-            JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(supertype)),
-            strippedTypeName);
-      }
-      writer.endMethod();
-
-      writer.emitEmptyLine();
-      writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
-      writer.emitAnnotation(Override.class);
-      String setOfBindings = JavaWriter.type(Set.class, "Binding<?>");
-      writer.beginMethod("void", "getDependencies", PUBLIC, setOfBindings, "getBindings",
-          setOfBindings, "injectMembersBindings");
-      if (constructor != null) {
-        for (Element parameter : constructor.getParameters()) {
-          writer.emitStatement("getBindings.add(%s)", parameterName(disambiguateFields, parameter));
-        }
-      }
-      for (Element field : fields) {
-        writer.emitStatement("injectMembersBindings.add(%s)", fieldName(disambiguateFields, field));
-      }
-      if (supertype != null) {
-        writer.emitStatement("injectMembersBindings.add(%s)", "supertype");
-      }
-      writer.endMethod();
     }
-
-    if (constructor != null) {
-      writer.emitEmptyLine();
-      writer.emitJavadoc(AdapterJavadocs.GET_METHOD, strippedTypeName);
-      writer.emitAnnotation(Override.class);
-      writer.beginMethod(strippedTypeName, "get", PUBLIC);
-      StringBuilder newInstance = new StringBuilder();
-      newInstance.append(strippedTypeName).append(" result = new ");
-      newInstance.append(strippedTypeName).append('(');
-      boolean first = true;
-      for (VariableElement parameter : constructor.getParameters()) {
-        if (!first) newInstance.append(", ");
-        else first = false;
-        newInstance.append(parameterName(disambiguateFields, parameter)).append(".get()");
-      }
-      newInstance.append(')');
-      writer.emitStatement(newInstance.toString());
-      if (injectMembers) {
-        writer.emitStatement("injectMembers(result)");
-      }
-      writer.emitStatement("return result");
-      writer.endMethod();
-    }
-
-    if (injectMembers) {
-      writer.emitEmptyLine();
-      writer.emitJavadoc(AdapterJavadocs.MEMBERS_INJECT_METHOD, strippedTypeName);
-      writer.emitAnnotation(Override.class);
-      writer.beginMethod("void", "injectMembers", PUBLIC, strippedTypeName, "object");
-      for (Element field : fields) {
-        writer.emitStatement("object.%s = %s.get()", field.getSimpleName(),
-            fieldName(disambiguateFields, field));
-      }
-      if (supertype != null) {
-        writer.emitStatement("supertype.injectMembers(object)");
-      }
-      writer.endMethod();
-    }
-
-    writer.endType();
-    writer.close();
-  }
-
-  private String[] interfaces(String strippedTypeName, boolean hasFields, boolean isProvider) {
-    List<String> interfaces = new ArrayList<String>();
-    if (isProvider) {
-      interfaces.add(JavaWriter.type(Provider.class, strippedTypeName));
-    }
-    if (hasFields) {
-      interfaces.add(JavaWriter.type(MembersInjector.class, strippedTypeName));
-    }
-    return interfaces.toArray(new String[interfaces.size()]);
-  }
-
-  private Set<String> getImports(boolean dependent, boolean injectMembers, boolean isProvider) {
-    Set<String> imports = new LinkedHashSet<String>();
-    imports.add(Binding.class.getCanonicalName());
-    if (dependent) {
-      imports.add(Linker.class.getCanonicalName());
-      imports.add(Set.class.getCanonicalName());
-    }
-    if (injectMembers) imports.add(MembersInjector.class.getCanonicalName());
-    if (isProvider) imports.add(Provider.class.getCanonicalName());
-    return imports;
-  }
-
-  private String strippedTypeName(String type, String packageName) {
-    return type.substring(packageName.isEmpty() ? 0 : packageName.length() + 1);
-  }
-
-  /**
-   * Write a companion class for {@code type} that extends {@link StaticInjection}.
-   */
-  private void writeStaticInjection(TypeElement type, List<Element> fields) throws IOException {
-    String typeName = type.getQualifiedName().toString();
-    String adapterName = adapterName(type, STATIC_INJECTION_SUFFIX);
-    JavaFileObject sourceFile = processingEnv.getFiler()
-        .createSourceFile(adapterName, type);
-    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
-
-    writer.emitSingleLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
-    writer.emitPackage(getPackage(type).getQualifiedName().toString());
-
-    writer.emitEmptyLine();
-    writer.emitImports(Arrays.asList(
-        StaticInjection.class.getName(),
-        Binding.class.getName(),
-        Linker.class.getName()));
-
-    writer.emitEmptyLine();
-
-    writer.emitJavadoc(AdapterJavadocs.STATIC_INJECTION_TYPE, type.getSimpleName());
-    writer.beginType(adapterName, "class", PUBLIC | FINAL, StaticInjection.class.getSimpleName());
-
-    for (Element field : fields) {
-      writer.emitField(JavaWriter.type(Binding.class, typeToString(field.asType())),
-          fieldName(false, field), PRIVATE);
-    }
-
-    writer.emitEmptyLine();
-    writer.emitJavadoc(AdapterJavadocs.ATTACH_METHOD);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod("void", "attach", PUBLIC, Linker.class.getName(), "linker");
     for (Element field : fields) {
       writer.emitStatement(
           "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
-          fieldName(false, field),
+          fieldName(disambiguateFields, field),
           writer.compressType(JavaWriter.type(Binding.class, typeToString(field.asType()))),
-          JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) field)),
-          typeName);
+          JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) field)), typeName);
+    }
+    if (supertype != null) {
+      writer.emitStatement(
+          "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader()"
+              + ", false, true)",
+          "supertype",
+          writer.compressType(JavaWriter.type(Binding.class, rawTypeToString(supertype, '.'))),
+          JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(supertype)), typeName);
     }
     writer.endMethod();
+    writer.emitEmptyLine();
+  }
 
+  private void writeGetDependenciesMethod(JavaWriter writer, ExecutableElement constructor,
+      List<Element> fields, boolean disambiguateFields, TypeMirror supertype,
+      boolean extendsBinding) throws IOException {
+    writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
+    if (extendsBinding) {
+      writer.emitAnnotation(Override.class);
+    }
+    String setOfBindings = JavaWriter.type(Set.class, "Binding<?>");
+    writer.beginMethod("void", "getDependencies", PUBLIC, setOfBindings, "getBindings",
+        setOfBindings, "injectMembersBindings");
+    if (constructor != null) {
+      for (Element parameter : constructor.getParameters()) {
+        writer.emitStatement("getBindings.add(%s)", parameterName(disambiguateFields, parameter));
+      }
+    }
+    for (Element field : fields) {
+      writer.emitStatement("injectMembersBindings.add(%s)", fieldName(disambiguateFields, field));
+    }
+    if (supertype != null) {
+      writer.emitStatement("injectMembersBindings.add(%s)", "supertype");
+    }
+    writer.endMethod();
+    writer.emitEmptyLine();
+  }
+
+  private void writeGetMethod(JavaWriter writer, ExecutableElement constructor,
+      boolean disambiguateFields, boolean injectMembers, String strippedTypeName)
+      throws IOException {
+    writer.emitJavadoc(AdapterJavadocs.GET_METHOD, strippedTypeName);
+    writer.emitAnnotation(Override.class);
+    writer.beginMethod(strippedTypeName, "get", PUBLIC);
+    StringBuilder newInstance = new StringBuilder();
+    newInstance.append(strippedTypeName).append(" result = new ");
+    newInstance.append(strippedTypeName).append('(');
+    boolean first = true;
+    for (VariableElement parameter : constructor.getParameters()) {
+      if (!first) newInstance.append(", ");
+      else first = false;
+      newInstance.append(parameterName(disambiguateFields, parameter)).append(".get()");
+    }
+    newInstance.append(')');
+    writer.emitStatement(newInstance.toString());
+    if (injectMembers) {
+      writer.emitStatement("injectMembers(result)");
+    }
+    writer.emitStatement("return result");
+    writer.endMethod();
+    writer.emitEmptyLine();
+  }
+
+  private void writeMembersInjectMethod(JavaWriter writer, List<Element> fields,
+      boolean disambiguateFields, String strippedTypeName, TypeMirror supertype)
+      throws IOException {
+    writer.emitJavadoc(AdapterJavadocs.MEMBERS_INJECT_METHOD, strippedTypeName);
+    writer.emitAnnotation(Override.class);
+    writer.beginMethod("void", "injectMembers", PUBLIC, strippedTypeName, "object");
+    for (Element field : fields) {
+      writer.emitStatement("object.%s = %s.get()",
+          field.getSimpleName(),
+          fieldName(disambiguateFields, field));
+    }
+    if (supertype != null) {
+      writer.emitStatement("supertype.injectMembers(object)");
+    }
+    writer.endMethod();
+    writer.emitEmptyLine();
+  }
+
+  private void writeStaticInjectMethod(JavaWriter writer, List<Element> fields, String typeName)
+      throws IOException {
     writer.emitEmptyLine();
     writer.emitJavadoc(AdapterJavadocs.STATIC_INJECT_METHOD);
     writer.emitAnnotation(Override.class);
@@ -471,9 +466,35 @@
           fieldName(false, field));
     }
     writer.endMethod();
+    writer.emitEmptyLine();
+  }
 
-    writer.endType();
-    writer.close();
+  private Set<String> findImports(boolean dependent, boolean injectMembers, boolean isProvider) {
+    Set<String> imports = new LinkedHashSet<String>();
+    imports.add(Binding.class.getCanonicalName());
+    if (dependent) {
+      imports.add(Linker.class.getCanonicalName());
+      imports.add(Set.class.getCanonicalName());
+    }
+    if (injectMembers) imports.add(MembersInjector.class.getCanonicalName());
+    if (isProvider) imports.add(Provider.class.getCanonicalName());
+    return imports;
+  }
+
+  private String[] implementedInterfaces(
+      String strippedTypeName, boolean hasFields, boolean isProvider) {
+    List<String> interfaces = new ArrayList<String>();
+    if (isProvider) {
+      interfaces.add(JavaWriter.type(Provider.class, strippedTypeName));
+    }
+    if (hasFields) {
+      interfaces.add(JavaWriter.type(MembersInjector.class, strippedTypeName));
+    }
+    return interfaces.toArray(new String[interfaces.size()]);
+  }
+
+  private String strippedTypeName(String type, String packageName) {
+    return type.substring(packageName.isEmpty() ? 0 : packageName.length() + 1);
   }
 
   private String fieldName(boolean disambiguateFields, Element field) {
@@ -484,6 +505,10 @@
     return (disambiguateFields ? "parameter_" : "") + parameter.getSimpleName().toString();
   }
 
+  private void error(String msg, Element element) {
+    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg, element);
+  }
+
   static class InjectedClass {
     final TypeElement type;
     final List<Element> staticFields;
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 4760104..3770361 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -54,7 +54,7 @@
 
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
-import static dagger.internal.codegen.AdapterJavadocs.binderTypeDocs;
+import static dagger.internal.codegen.AdapterJavadocs.bindingTypeDocs;
 import static dagger.internal.codegen.Util.adapterName;
 import static dagger.internal.codegen.Util.elementToString;
 import static dagger.internal.codegen.Util.getAnnotation;
@@ -95,7 +95,7 @@
         // IllegalStateException.
         Map<String, Object> parsedAnnotation = getAnnotation(Module.class, type);
         try {
-          writeModuleAdapter(type, parsedAnnotation, providesTypes);
+          generateModuleAdapter(type, parsedAnnotation, providesTypes);
         } catch (IOException e) {
           error("Code gen failed: " + e, type);
         }
@@ -125,7 +125,7 @@
     Map<String, List<ExecutableElement>> result = new HashMap<String, List<ExecutableElement>>();
 
     provides:
-    for (Element providerMethod : providesMethods(env)) {
+    for (Element providerMethod : findProvidesMethods(env)) {
       switch (providerMethod.getEnclosingElement().getKind()) {
         case CLASS:
           break; // valid, move along
@@ -204,7 +204,7 @@
     return result;
   }
 
-  private Set<? extends Element> providesMethods(RoundEnvironment env) {
+  private Set<? extends Element> findProvidesMethods(RoundEnvironment env) {
     Set<Element> result = new LinkedHashSet<Element>();
     result.addAll(env.getElementsAnnotatedWith(Provides.class));
     return result;
@@ -214,7 +214,7 @@
    * Write a companion class for {@code type} that implements {@link
    * ModuleAdapter} to expose its provider methods.
    */
-  private void writeModuleAdapter(TypeElement type, Map<String, Object> module,
+  private void generateModuleAdapter(TypeElement type, Map<String, Object> module,
       List<ExecutableElement> providerMethods) throws IOException {
     if (module == null) {
       error(type + " has @Provides methods but no @Module annotation", type);
@@ -239,9 +239,8 @@
 
     writer.emitSingleLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
     writer.emitPackage(getPackage(type).getQualifiedName().toString());
-    writer.emitEmptyLine();
     writer.emitImports(
-        getImports(multibindings, !providerMethods.isEmpty(), providerMethodDependencies));
+        findImports(multibindings, !providerMethods.isEmpty(), providerMethodDependencies));
 
     String typeName = type.getQualifiedName().toString();
     writer.emitEmptyLine();
@@ -340,7 +339,7 @@
     }
 
     for (ExecutableElement providerMethod : providerMethods) {
-      writeProvidesAdapter(writer, providerMethod, methodToClassName, methodNameToNextId,
+      generateProvidesAdapter(writer, providerMethod, methodToClassName, methodNameToNextId,
           library);
     }
 
@@ -348,7 +347,7 @@
     writer.close();
   }
 
-  private Set<String> getImports(boolean multibindings, boolean providers, boolean dependencies) {
+  private Set<String> findImports(boolean multibindings, boolean providers, boolean dependencies) {
     Set<String> imports = new LinkedHashSet<String>();
     imports.add(ModuleAdapter.class.getCanonicalName());
     if (providers) {
@@ -407,19 +406,20 @@
     return className;
   }
 
-  private void writeProvidesAdapter(JavaWriter writer, ExecutableElement providerMethod,
+  private void generateProvidesAdapter(JavaWriter writer, ExecutableElement providerMethod,
       Map<ExecutableElement, String> methodToClassName,
       Map<String, AtomicInteger> methodNameToNextId, boolean library)
       throws IOException {
     String methodName = providerMethod.getSimpleName().toString();
     String moduleType = typeToString(providerMethod.getEnclosingElement().asType());
-    String className = bindingClassName(providerMethod, methodToClassName, methodNameToNextId);
+    String className =
+        bindingClassName(providerMethod, methodToClassName, methodNameToNextId);
     String returnType = typeToString(providerMethod.getReturnType());
     List<? extends VariableElement> parameters = providerMethod.getParameters();
     boolean dependent = !parameters.isEmpty();
 
     writer.emitEmptyLine();
-    writer.emitJavadoc(binderTypeDocs(returnType, false, false, dependent));
+    writer.emitJavadoc(bindingTypeDocs(returnType, false, false, dependent));
     writer.beginType(className, "class", PUBLIC | FINAL | STATIC,
         JavaWriter.type(Binding.class, returnType),
         JavaWriter.type(Provider.class, returnType));
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
index 39ebc4f..dca009d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
@@ -25,6 +25,7 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
+import java.util.EnumSet;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.List;
@@ -39,7 +40,6 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeKind;
@@ -58,9 +58,11 @@
 import static dagger.internal.codegen.Util.typeToString;
 import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
 import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
-import static java.lang.reflect.Modifier.FINAL;
-import static java.lang.reflect.Modifier.PRIVATE;
-import static java.lang.reflect.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Generates an implementation of {@link Binding} that injects the
@@ -148,26 +150,26 @@
     }
 
     if (injectable.getKind() == ElementKind.FIELD
-        && injectable.getModifiers().contains(Modifier.FINAL)) {
+        && injectable.getModifiers().contains(FINAL)) {
       error("Can't inject a final field: " + elementToString(injectable), injectable);
       return false;
     }
 
     if (injectable.getKind() == ElementKind.FIELD
-        && injectable.getModifiers().contains(Modifier.PRIVATE)) {
+        && injectable.getModifiers().contains(PRIVATE)) {
       error("Can't inject a private field: " + elementToString(injectable), injectable);
       return false;
     }
 
     if (injectable.getKind() == ElementKind.CONSTRUCTOR
-        && injectable.getModifiers().contains(Modifier.PRIVATE)) {
+        && injectable.getModifiers().contains(PRIVATE)) {
       error("Can't inject a private constructor: " + elementToString(injectable), injectable);
       return false;
     }
 
     ElementKind elementKind = injectableType.getEnclosingElement().getKind();
     boolean isClassOrInterface = elementKind.isClass() || elementKind.isInterface();
-    boolean isStatic = injectableType.getModifiers().contains(Modifier.STATIC);
+    boolean isStatic = injectableType.getModifiers().contains(STATIC);
 
     if (isClassOrInterface && !isStatic) {
       error("Can't inject a non-static inner class: " + elementToString(injectable),
@@ -183,7 +185,7 @@
    */
   private InjectedClass createInjectedClass(String injectedClassName) {
     TypeElement type = processingEnv.getElementUtils().getTypeElement(injectedClassName);
-    boolean isAbstract = type.getModifiers().contains(Modifier.ABSTRACT);
+    boolean isAbstract = type.getModifiers().contains(ABSTRACT);
     List<Element> staticFields = new ArrayList<Element>();
     ExecutableElement constructor = null;
     List<Element> fields = new ArrayList<Element>();
@@ -194,7 +196,7 @@
 
       switch (member.getKind()) {
         case FIELD:
-          if (member.getModifiers().contains(Modifier.STATIC)) {
+          if (member.getModifiers().contains(STATIC)) {
             staticFields.add(member);
           } else {
             fields.add(member);
@@ -243,7 +245,7 @@
     String adapterName = adapterName(type, INJECT_ADAPTER_SUFFIX);
     JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(adapterName, type);
     JavaWriter writer = new JavaWriter(sourceFile.openWriter());
-    boolean isAbstract = type.getModifiers().contains(Modifier.ABSTRACT);
+    boolean isAbstract = type.getModifiers().contains(ABSTRACT);
     boolean injectMembers = !fields.isEmpty() || supertype != null;
     boolean disambiguateFields = !fields.isEmpty()
         && (constructor != null)
@@ -256,7 +258,7 @@
     writer.emitImports(findImports(dependent, injectMembers, constructor != null));
     writer.emitEmptyLine();
     writer.emitJavadoc(bindingTypeDocs(strippedTypeName, isAbstract, injectMembers, dependent));
-    writer.beginType(adapterName, "class", PUBLIC | FINAL,
+    writer.beginType(adapterName, "class", EnumSet.of(PUBLIC, FINAL),
         JavaWriter.type(Binding.class, strippedTypeName),
         implementedInterfaces(strippedTypeName, injectMembers, constructor != null));
     writeMemberBindingsFields(writer, fields, disambiguateFields);
@@ -301,7 +303,8 @@
         Linker.class.getName()));
     writer.emitEmptyLine();
     writer.emitJavadoc(AdapterJavadocs.STATIC_INJECTION_TYPE, type.getSimpleName());
-    writer.beginType(adapterName, "class", PUBLIC | FINAL, StaticInjection.class.getSimpleName());
+    writer.beginType(
+        adapterName, "class", EnumSet.of(PUBLIC, FINAL), StaticInjection.class.getSimpleName());
     writeMemberBindingsFields(writer, fields, false);
     writer.emitEmptyLine();
     writeAttachMethod(writer, null, fields, false, typeName, null, true);
@@ -314,7 +317,7 @@
       JavaWriter writer, List<Element> fields, boolean disambiguateFields) throws IOException {
     for (Element field : fields) {
       writer.emitField(JavaWriter.type(Binding.class, typeToString(field.asType())),
-          fieldName(disambiguateFields, field), PRIVATE);
+          fieldName(disambiguateFields, field), EnumSet.of(PRIVATE));
     }
   }
 
@@ -324,19 +327,19 @@
     for (VariableElement parameter : constructor.getParameters()) {
       writer.emitField(JavaWriter.type(Binding.class,
           typeToString(parameter.asType())),
-          parameterName(disambiguateFields, parameter), PRIVATE);
+          parameterName(disambiguateFields, parameter), EnumSet.of(PRIVATE));
     }
   }
 
   private void writeSupertypeInjectorField(JavaWriter writer, TypeMirror supertype)
       throws IOException {
-    writer.emitField(
-        JavaWriter.type(Binding.class, rawTypeToString(supertype, '.')), "supertype", PRIVATE);
+    writer.emitField(JavaWriter.type(Binding.class, rawTypeToString(supertype, '.')), "supertype",
+        EnumSet.of(PRIVATE));
   }
 
   private void writeInjectAdapterConstructor(JavaWriter writer, ExecutableElement constructor,
       TypeElement type, String strippedTypeName, String adapterName) throws IOException {
-    writer.beginMethod(null, adapterName, PUBLIC);
+    writer.beginMethod(null, adapterName, EnumSet.of(PUBLIC));
     String key = (constructor != null)
         ? JavaWriter.stringLiteral(GeneratorKeys.get(type.asType()))
         : null;
@@ -356,7 +359,8 @@
       writer.emitAnnotation(Override.class);
     }
     writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
-    writer.beginMethod("void", "attach", PUBLIC, Linker.class.getCanonicalName(), "linker");
+    writer.beginMethod(
+        "void", "attach", EnumSet.of(PUBLIC), Linker.class.getCanonicalName(), "linker");
     if (constructor != null) {
       for (VariableElement parameter : constructor.getParameters()) {
         writer.emitStatement(
@@ -393,7 +397,7 @@
       writer.emitAnnotation(Override.class);
     }
     String setOfBindings = JavaWriter.type(Set.class, "Binding<?>");
-    writer.beginMethod("void", "getDependencies", PUBLIC, setOfBindings, "getBindings",
+    writer.beginMethod("void", "getDependencies", EnumSet.of(PUBLIC), setOfBindings, "getBindings",
         setOfBindings, "injectMembersBindings");
     if (constructor != null) {
       for (Element parameter : constructor.getParameters()) {
@@ -415,7 +419,7 @@
       throws IOException {
     writer.emitJavadoc(AdapterJavadocs.GET_METHOD, strippedTypeName);
     writer.emitAnnotation(Override.class);
-    writer.beginMethod(strippedTypeName, "get", PUBLIC);
+    writer.beginMethod(strippedTypeName, "get", EnumSet.of(PUBLIC));
     StringBuilder newInstance = new StringBuilder();
     newInstance.append(strippedTypeName).append(" result = new ");
     newInstance.append(strippedTypeName).append('(');
@@ -440,7 +444,7 @@
       throws IOException {
     writer.emitJavadoc(AdapterJavadocs.MEMBERS_INJECT_METHOD, strippedTypeName);
     writer.emitAnnotation(Override.class);
-    writer.beginMethod("void", "injectMembers", PUBLIC, strippedTypeName, "object");
+    writer.beginMethod("void", "injectMembers", EnumSet.of(PUBLIC), strippedTypeName, "object");
     for (Element field : fields) {
       writer.emitStatement("object.%s = %s.get()",
           field.getSimpleName(),
@@ -458,7 +462,7 @@
     writer.emitEmptyLine();
     writer.emitJavadoc(AdapterJavadocs.STATIC_INJECT_METHOD);
     writer.emitAnnotation(Override.class);
-    writer.beginMethod("void", "inject", PUBLIC);
+    writer.beginMethod("void", "inject", EnumSet.of(PUBLIC));
     for (Element field : fields) {
       writer.emitStatement("%s.%s = %s.get()",
           writer.compressType(typeName),
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 3770361..a5ca6a5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -26,6 +26,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
@@ -64,10 +65,11 @@
 import static dagger.internal.codegen.Util.isInterface;
 import static dagger.internal.codegen.Util.typeToString;
 import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
-import static java.lang.reflect.Modifier.FINAL;
-import static java.lang.reflect.Modifier.PRIVATE;
-import static java.lang.reflect.Modifier.PUBLIC;
-import static java.lang.reflect.Modifier.STATIC;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Generates an implementation of {@link ModuleAdapter} that includes a binding
@@ -136,17 +138,17 @@
       }
       TypeElement type = (TypeElement) providerMethod.getEnclosingElement();
       Set<Modifier> typeModifiers = type.getModifiers();
-      if (typeModifiers.contains(Modifier.PRIVATE)
-          || typeModifiers.contains(Modifier.ABSTRACT)) {
+      if (typeModifiers.contains(PRIVATE)
+          || typeModifiers.contains(ABSTRACT)) {
         error("Classes declaring @Provides methods must not be private or abstract: "
                 + type.getQualifiedName(), type);
         continue;
       }
 
       Set<Modifier> methodModifiers = providerMethod.getModifiers();
-      if (methodModifiers.contains(Modifier.PRIVATE)
-          || methodModifiers.contains(Modifier.ABSTRACT)
-          || methodModifiers.contains(Modifier.STATIC)) {
+      if (methodModifiers.contains(PRIVATE)
+          || methodModifiers.contains(ABSTRACT)
+          || methodModifiers.contains(STATIC)) {
         error("@Provides methods must not be private, abstract or static: "
                 + type.getQualifiedName() + "." + providerMethod, providerMethod);
         continue;
@@ -245,7 +247,7 @@
     String typeName = type.getQualifiedName().toString();
     writer.emitEmptyLine();
     writer.emitJavadoc(AdapterJavadocs.MODULE_TYPE);
-    writer.beginType(adapterName, "class", PUBLIC | FINAL,
+    writer.beginType(adapterName, "class", EnumSet.of(PUBLIC, FINAL),
         JavaWriter.type(ModuleAdapter.class, typeName));
 
     StringBuilder injectsField = new StringBuilder().append("{ ");
@@ -257,7 +259,7 @@
       injectsField.append(JavaWriter.stringLiteral(key)).append(", ");
     }
     injectsField.append("}");
-    writer.emitField("String[]", "INJECTS", PRIVATE | STATIC | FINAL,
+    writer.emitField("String[]", "INJECTS", EnumSet.of(PRIVATE, STATIC, FINAL),
         injectsField.toString());
 
     StringBuilder staticInjectionsField = new StringBuilder().append("{ ");
@@ -266,7 +268,7 @@
       staticInjectionsField.append(typeToString(typeMirror)).append(".class, ");
     }
     staticInjectionsField.append("}");
-    writer.emitField("Class<?>[]", "STATIC_INJECTIONS", PRIVATE | STATIC | FINAL,
+    writer.emitField("Class<?>[]", "STATIC_INJECTIONS", EnumSet.of(PRIVATE, STATIC, FINAL),
         staticInjectionsField.toString());
 
     StringBuilder includesField = new StringBuilder().append("{ ");
@@ -281,10 +283,11 @@
       includesField.append(typeToString(typeMirror)).append(".class, ");
     }
     includesField.append("}");
-    writer.emitField("Class<?>[]", "INCLUDES", PRIVATE | STATIC | FINAL, includesField.toString());
+    writer.emitField(
+        "Class<?>[]", "INCLUDES", EnumSet.of(PRIVATE, STATIC, FINAL), includesField.toString());
 
     writer.emitEmptyLine();
-    writer.beginMethod(null, adapterName, PUBLIC);
+    writer.beginMethod(null, adapterName, EnumSet.of(PUBLIC));
     writer.emitStatement("super(INJECTS, STATIC_INJECTIONS, %s /*overrides*/, "
         + "INCLUDES, %s /*complete*/, %s /*library*/)", overrides, complete, library);
     writer.endMethod();
@@ -293,7 +296,7 @@
     if (noArgsConstructor != null && isCallableConstructor(noArgsConstructor)) {
       writer.emitEmptyLine();
       writer.emitAnnotation(Override.class);
-      writer.beginMethod(typeName, "newModule", PUBLIC);
+      writer.beginMethod(typeName, "newModule", EnumSet.of(PUBLIC));
       writer.emitStatement("return new %s()", typeName);
       writer.endMethod();
     }
@@ -306,7 +309,7 @@
       writer.emitEmptyLine();
       writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
       writer.emitAnnotation(Override.class);
-      writer.beginMethod("void", "getBindings", PUBLIC, BINDINGS_MAP, "map");
+      writer.beginMethod("void", "getBindings", EnumSet.of(PUBLIC), BINDINGS_MAP, "map");
 
       for (ExecutableElement providerMethod : providerMethods) {
         Provides provides = providerMethod.getAnnotation(Provides.class);
@@ -420,18 +423,18 @@
 
     writer.emitEmptyLine();
     writer.emitJavadoc(bindingTypeDocs(returnType, false, false, dependent));
-    writer.beginType(className, "class", PUBLIC | FINAL | STATIC,
+    writer.beginType(className, "class", EnumSet.of(PUBLIC, STATIC, FINAL),
         JavaWriter.type(Binding.class, returnType),
         JavaWriter.type(Provider.class, returnType));
-    writer.emitField(moduleType, "module", PRIVATE | FINAL);
+    writer.emitField(moduleType, "module", EnumSet.of(PRIVATE, FINAL));
     for (Element parameter : parameters) {
       TypeMirror parameterType = parameter.asType();
       writer.emitField(JavaWriter.type(Binding.class, typeToString(parameterType)),
-          parameterName(parameter), PRIVATE);
+          parameterName(parameter), EnumSet.of(PRIVATE));
     }
 
     writer.emitEmptyLine();
-    writer.beginMethod(null, className, PUBLIC, moduleType, "module");
+    writer.beginMethod(null, className, EnumSet.of(PUBLIC), moduleType, "module");
     boolean singleton = providerMethod.getAnnotation(Singleton.class) != null;
     String key = JavaWriter.stringLiteral(GeneratorKeys.get(providerMethod));
     String membersKey = null;
@@ -447,7 +450,8 @@
       writer.emitJavadoc(AdapterJavadocs.ATTACH_METHOD);
       writer.emitAnnotation(Override.class);
       writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
-      writer.beginMethod("void", "attach", PUBLIC, Linker.class.getCanonicalName(), "linker");
+      writer.beginMethod(
+          "void", "attach", EnumSet.of(PUBLIC), Linker.class.getCanonicalName(), "linker");
       for (VariableElement parameter : parameters) {
         String parameterKey = GeneratorKeys.get(parameter);
         writer.emitStatement(
@@ -463,8 +467,8 @@
       writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
       writer.emitAnnotation(Override.class);
       String setOfBindings = JavaWriter.type(Set.class, "Binding<?>");
-      writer.beginMethod("void", "getDependencies", PUBLIC, setOfBindings, "getBindings",
-          setOfBindings, "injectMembersBindings");
+      writer.beginMethod("void", "getDependencies", EnumSet.of(PUBLIC), setOfBindings,
+          "getBindings", setOfBindings, "injectMembersBindings");
       for (Element parameter : parameters) {
         writer.emitStatement("getBindings.add(%s)", parameter.getSimpleName().toString());
       }
@@ -474,7 +478,7 @@
     writer.emitEmptyLine();
     writer.emitJavadoc(AdapterJavadocs.GET_METHOD, returnType);
     writer.emitAnnotation(Override.class);
-    writer.beginMethod(returnType, "get", PUBLIC);
+    writer.beginMethod(returnType, "get", EnumSet.of(PUBLIC));
     StringBuilder args = new StringBuilder();
     boolean first = true;
     for (Element parameter : parameters) {
/Fim/
diff --git a/checkstyle.xml b/checkstyle.xml
index 7dfd69c..830f252 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -1,134 +1,134 @@
-<?xml version="1.0"?>
-<!DOCTYPE module PUBLIC
-    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
-    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
-
-<module name="Checker">
-    <!--module name="NewlineAtEndOfFile"/-->
-    <module name="FileLength"/>
-    <module name="FileTabCharacter"/>
-
-    <!-- Trailing spaces -->
-    <module name="RegexpSingleline">
-        <property name="format" value="\s+$"/>
-        <property name="message" value="Line has trailing spaces."/>
-    </module>
-
-    <!-- Space after 'for' and 'if' -->
-    <module name="RegexpSingleline">
-        <property name="format" value="^\s*(for|if)[^ ]"/>
-        <property name="message" value="Space needed before opening parenthesis."/>
-    </module>
-
-    <!-- For each spacing -->
-    <module name="RegexpSingleline">
-        <property name="format" value="^\s*for \(.*?([^ ]:|:[^ ])"/>
-        <property name="message" value="Space needed around ':' character."/>
-    </module>
-
-    <module name="TreeWalker">
-        <property name="cacheFile" value="${checkstyle.cache.file}"/>
-
-        <!-- Checks for Javadoc comments.                     -->
-        <!-- See http://checkstyle.sf.net/config_javadoc.html -->
-        <!--module name="JavadocMethod"/-->
-        <!--module name="JavadocType"/-->
-        <!--module name="JavadocVariable"/-->
-        <!--module name="JavadocStyle"/-->
-
-
-        <!-- Checks for Naming Conventions.                  -->
-        <!-- See http://checkstyle.sf.net/config_naming.html -->
-        <!--<module name="ConstantName"/>-->
-        <module name="LocalFinalVariableName"/>
-        <module name="LocalVariableName"/>
-        <module name="MemberName"/>
-        <module name="MethodName"/>
-        <module name="PackageName"/>
-        <module name="ParameterName"/>
-        <module name="StaticVariableName"/>
-        <module name="TypeName"/>
-
-
-        <!-- Checks for imports                              -->
-        <!-- See http://checkstyle.sf.net/config_import.html -->
-        <module name="AvoidStarImport"/>
-        <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
-        <module name="RedundantImport"/>
-        <module name="UnusedImports"/>
-
-
-        <!-- Checks for Size Violations.                    -->
-        <!-- See http://checkstyle.sf.net/config_sizes.html -->
-        <module name="LineLength">
-            <property name="max" value="100"/>
-        </module>
-        <module name="MethodLength">
-            <property name="max" value="200"/>
-        </module>
-            
-        <!--module name="ParameterNumber"/-->
-
-
-        <!-- Checks for whitespace                               -->
-        <!-- See http://checkstyle.sf.net/config_whitespace.html -->
-        <module name="GenericWhitespace"/>
-        <module name="EmptyForIteratorPad"/>
-        <module name="MethodParamPad"/>
-        <module name="NoWhitespaceAfter"/>
-        <module name="NoWhitespaceBefore"/>
-        <module name="OperatorWrap"/>
-        <module name="ParenPad"/>
-        <module name="TypecastParenPad"/>
-        <module name="WhitespaceAfter"/>
-        <module name="WhitespaceAround"/>
-
-
-        <!-- Modifier Checks                                    -->
-        <!-- See http://checkstyle.sf.net/config_modifiers.html -->
-        <!--module name="ModifierOrder"/-->
-        <module name="RedundantModifier"/>
-
-
-        <!-- Checks for blocks. You know, those {}'s         -->
-        <!-- See http://checkstyle.sf.net/config_blocks.html -->
-        <!--module name="AvoidNestedBlocks"/-->
-        <!--module name="EmptyBlock"/-->
-        <module name="LeftCurly"/>
-        <!--module name="NeedBraces"/-->
-        <module name="RightCurly"/>
-
-
-        <!-- Checks for common coding problems               -->
-        <!-- See http://checkstyle.sf.net/config_coding.html -->
-        <!--module name="AvoidInlineConditionals"/-->
-        <module name="CovariantEquals"/>
-        <module name="EmptyStatement"/>
-        <!--<module name="EqualsAvoidNull"/>-->
-        <module name="EqualsHashCode"/>
-        <!--module name="HiddenField"/-->
-        <module name="IllegalInstantiation"/>
-        <!--<module name="InnerAssignment"/>-->
-        <!--module name="MagicNumber"/-->
-        <module name="MissingSwitchDefault"/>
-        <module name="RedundantThrows"/>
-        <module name="SimplifyBooleanExpression"/>
-        <module name="SimplifyBooleanReturn"/>
-
-        <!-- Checks for class design                         -->
-        <!-- See http://checkstyle.sf.net/config_design.html -->
-        <!--module name="DesignForExtension"/-->
-        <!--module name="FinalClass"/-->
-        <!--module name="HideUtilityClassConstructor"/-->
-        <!--module name="InterfaceIsType"/-->
-        <!--module name="VisibilityModifier"/-->
-
-
-        <!-- Miscellaneous other checks.                   -->
-        <!-- See http://checkstyle.sf.net/config_misc.html -->
-        <!--module name="ArrayTypeStyle"/-->
-        <!--module name="FinalParameters"/-->
-        <!--module name="TodoComment"/-->
-        <module name="UpperEll"/>
-    </module>
-</module>
+<?xml version="1.0"?>
+<!DOCTYPE module PUBLIC
+    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
+    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
+
+<module name="Checker">
+    <!--module name="NewlineAtEndOfFile"/-->
+    <module name="FileLength"/>
+    <module name="FileTabCharacter"/>
+
+    <!-- Trailing spaces -->
+    <module name="RegexpSingleline">
+        <property name="format" value="\s+$"/>
+        <property name="message" value="Line has trailing spaces."/>
+    </module>
+
+    <!-- Space after 'for' and 'if' -->
+    <module name="RegexpSingleline">
+        <property name="format" value="^\s*(for|if)[^ ]"/>
+        <property name="message" value="Space needed before opening parenthesis."/>
+    </module>
+
+    <!-- For each spacing -->
+    <module name="RegexpSingleline">
+        <property name="format" value="^\s*for \(.*?([^ ]:|:[^ ])"/>
+        <property name="message" value="Space needed around ':' character."/>
+    </module>
+
+    <module name="TreeWalker">
+        <property name="cacheFile" value="${checkstyle.cache.file}"/>
+
+        <!-- Checks for Javadoc comments.                     -->
+        <!-- See http://checkstyle.sf.net/config_javadoc.html -->
+        <!--module name="JavadocMethod"/-->
+        <!--module name="JavadocType"/-->
+        <!--module name="JavadocVariable"/-->
+        <!--module name="JavadocStyle"/-->
+
+
+        <!-- Checks for Naming Conventions.                  -->
+        <!-- See http://checkstyle.sf.net/config_naming.html -->
+        <!--<module name="ConstantName"/>-->
+        <module name="LocalFinalVariableName"/>
+        <module name="LocalVariableName"/>
+        <module name="MemberName"/>
+        <module name="MethodName"/>
+        <module name="PackageName"/>
+        <module name="ParameterName"/>
+        <module name="StaticVariableName"/>
+        <module name="TypeName"/>
+
+
+        <!-- Checks for imports                              -->
+        <!-- See http://checkstyle.sf.net/config_import.html -->
+        <module name="AvoidStarImport"/>
+        <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
+        <module name="RedundantImport"/>
+        <module name="UnusedImports"/>
+
+
+        <!-- Checks for Size Violations.                    -->
+        <!-- See http://checkstyle.sf.net/config_sizes.html -->
+        <module name="LineLength">
+            <property name="max" value="100"/>
+        </module>
+        <module name="MethodLength">
+            <property name="max" value="200"/>
+        </module>
+            
+        <!--module name="ParameterNumber"/-->
+
+
+        <!-- Checks for whitespace                               -->
+        <!-- See http://checkstyle.sf.net/config_whitespace.html -->
+        <module name="GenericWhitespace"/>
+        <module name="EmptyForIteratorPad"/>
+        <module name="MethodParamPad"/>
+        <module name="NoWhitespaceAfter"/>
+        <module name="NoWhitespaceBefore"/>
+        <module name="OperatorWrap"/>
+        <module name="ParenPad"/>
+        <module name="TypecastParenPad"/>
+        <module name="WhitespaceAfter"/>
+        <module name="WhitespaceAround"/>
+
+
+        <!-- Modifier Checks                                    -->
+        <!-- See http://checkstyle.sf.net/config_modifiers.html -->
+        <!--module name="ModifierOrder"/-->
+        <module name="RedundantModifier"/>
+
+
+        <!-- Checks for blocks. You know, those {}'s         -->
+        <!-- See http://checkstyle.sf.net/config_blocks.html -->
+        <!--module name="AvoidNestedBlocks"/-->
+        <!--module name="EmptyBlock"/-->
+        <module name="LeftCurly"/>
+        <!--module name="NeedBraces"/-->
+        <module name="RightCurly"/>
+
+
+        <!-- Checks for common coding problems               -->
+        <!-- See http://checkstyle.sf.net/config_coding.html -->
+        <!--module name="AvoidInlineConditionals"/-->
+        <module name="CovariantEquals"/>
+        <module name="EmptyStatement"/>
+        <!--<module name="EqualsAvoidNull"/>-->
+        <module name="EqualsHashCode"/>
+        <!--module name="HiddenField"/-->
+        <module name="IllegalInstantiation"/>
+        <!--<module name="InnerAssignment"/>-->
+        <!--module name="MagicNumber"/-->
+        <module name="MissingSwitchDefault"/>
+        <module name="RedundantThrows"/>
+        <module name="SimplifyBooleanExpression"/>
+        <module name="SimplifyBooleanReturn"/>
+
+        <!-- Checks for class design                         -->
+        <!-- See http://checkstyle.sf.net/config_design.html -->
+        <!--module name="DesignForExtension"/-->
+        <!--module name="FinalClass"/-->
+        <!--module name="HideUtilityClassConstructor"/-->
+        <!--module name="InterfaceIsType"/-->
+        <!--module name="VisibilityModifier"/-->
+
+
+        <!-- Miscellaneous other checks.                   -->
+        <!-- See http://checkstyle.sf.net/config_misc.html -->
+        <!--module name="ArrayTypeStyle"/-->
+        <!--module name="FinalParameters"/-->
+        <!--module name="TodoComment"/-->
+        <module name="UpperEll"/>
+    </module>
+</module>
/Fim/
diff --git a/core/src/test/java/dagger/internal/SingletonBindingTest.java b/core/src/test/java/dagger/internal/SingletonBindingTest.java
index 8c6154c..515a2eb 100644
--- a/core/src/test/java/dagger/internal/SingletonBindingTest.java
+++ b/core/src/test/java/dagger/internal/SingletonBindingTest.java
@@ -1,76 +1,76 @@
-/**
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import static org.fest.assertions.Assertions.assertThat;
-
-@RunWith(JUnit4.class)
-public final class SingletonBindingTest {
-  private Binding<String> wrappedBinding;
-  private Binding<String> singletonBinding;
-
-  @Before public void setUp() {
-    wrappedBinding = new StringBinding();
-    singletonBinding = Linker.scope(wrappedBinding);
-  }
-
-  @Test public void testSingletonBindingIsSingleton() {
-    assertThat(singletonBinding.isSingleton()).isTrue();
-  }
-
-  // This next batch of tests validates that SingletonBinding consistently delegates to the wrapped binding for state.
-  @Test public void testSingletonBindingDelegatesSetLinked() {
-    singletonBinding.setLinked();
-    assertThat(wrappedBinding.isLinked()).isTrue();
-  }
-
-  @Test public void testSingletonBindingDelegatesIsLinked() {
-    wrappedBinding.setLinked();
-    assertThat(singletonBinding.isLinked()).isTrue();
-  }
-
-  @Test public void testSingletonBindingDelegatesSetVisiting() {
-    singletonBinding.setVisiting(true);
-    assertThat(wrappedBinding.isVisiting()).isTrue();
-  }
-
-  @Test public void testSingletonBindingDelegatesIsVisiting() {
-    wrappedBinding.setVisiting(true);
-    assertThat(singletonBinding.isVisiting()).isTrue();
-  }
-
-  @Test public void testSingletonBindingDelegatesSetCycleFree() {
-    singletonBinding.setCycleFree(true);
-    assertThat(wrappedBinding.isCycleFree()).isTrue();
-  }
-
-  @Test public void testSingletonBindingDelegatesIsCycleFree() {
-    wrappedBinding.setCycleFree(true);
-    assertThat(singletonBinding.isCycleFree()).isTrue();
-  }
-
-  private static class StringBinding extends Binding<String> {
-    private StringBinding() {
-      super("dummy", "dummy", true, "dummy"); // 3rd arg true => singleton
-    }
-
-  }
-}
+/**
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import static org.fest.assertions.Assertions.assertThat;
+
+@RunWith(JUnit4.class)
+public final class SingletonBindingTest {
+  private Binding<String> wrappedBinding;
+  private Binding<String> singletonBinding;
+
+  @Before public void setUp() {
+    wrappedBinding = new StringBinding();
+    singletonBinding = Linker.scope(wrappedBinding);
+  }
+
+  @Test public void testSingletonBindingIsSingleton() {
+    assertThat(singletonBinding.isSingleton()).isTrue();
+  }
+
+  // This next batch of tests validates that SingletonBinding consistently delegates to the wrapped binding for state.
+  @Test public void testSingletonBindingDelegatesSetLinked() {
+    singletonBinding.setLinked();
+    assertThat(wrappedBinding.isLinked()).isTrue();
+  }
+
+  @Test public void testSingletonBindingDelegatesIsLinked() {
+    wrappedBinding.setLinked();
+    assertThat(singletonBinding.isLinked()).isTrue();
+  }
+
+  @Test public void testSingletonBindingDelegatesSetVisiting() {
+    singletonBinding.setVisiting(true);
+    assertThat(wrappedBinding.isVisiting()).isTrue();
+  }
+
+  @Test public void testSingletonBindingDelegatesIsVisiting() {
+    wrappedBinding.setVisiting(true);
+    assertThat(singletonBinding.isVisiting()).isTrue();
+  }
+
+  @Test public void testSingletonBindingDelegatesSetCycleFree() {
+    singletonBinding.setCycleFree(true);
+    assertThat(wrappedBinding.isCycleFree()).isTrue();
+  }
+
+  @Test public void testSingletonBindingDelegatesIsCycleFree() {
+    wrappedBinding.setCycleFree(true);
+    assertThat(singletonBinding.isCycleFree()).isTrue();
+  }
+
+  private static class StringBinding extends Binding<String> {
+    private StringBinding() {
+      super("dummy", "dummy", true, "dummy"); // 3rd arg true => singleton
+    }
+
+  }
+}
/Fim/
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
index 2f9587c..6fd695c 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
@@ -25,7 +25,7 @@
 
 /**
  * This module represents objects which exist only for the scope of a single activity. We can
- * safely create singletons using the activity instance because ths entire object graph will only
+ * safely create singletons using the activity instance because the entire object graph will only
  * ever exist inside of that activity.
  */
 @Module(
/Fim/
diff --git a/pom.xml b/pom.xml
index d242f68..27cd3f4 100644
--- a/pom.xml
+++ b/pom.xml
@@ -43,7 +43,7 @@
     <!-- Compilation -->
     <java.version>1.6</java.version>
     <javax.inject.version>1</javax.inject.version>
-    <javawriter.version>2.3.0</javawriter.version>
+    <javawriter.version>2.5.0</javawriter.version>
     <guava.version>15.0</guava.version>
 
     <!-- Test Dependencies -->
/Fim/
diff --git a/deploy_website.sh b/deploy_website.sh
index 1fde1bd..2f609c9 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -31,7 +31,7 @@
 cp -R ../website/* .
 
 # Download the latest javadoc
-curl -L "http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
+curl -L "https://search.maven.org/remote_content?g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
 mkdir javadoc
 unzip javadoc.zip -d javadoc
 rm javadoc.zip
/Fim/
diff --git a/website/index.html b/website/index.html
index f29a511..8406b47 100644
--- a/website/index.html
+++ b/website/index.html
@@ -391,7 +391,7 @@
             <p>For more substantial variations it's often simpler to use a different combination of modules.</p>
 
             <h3 id="download">Download</h3>
-            <p><a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.dagger&a=dagger&v=LATEST" class="dl core-version-href">&darr; <span class="version-tag">Latest</span> JAR</a> <a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.dagger&a=dagger-compiler&v=LATEST" class="dl compiler-version-href">&darr; <span class="version-tag">Latest</span> Compiler JAR</a></p>
+            <p><a href="https://search.maven.org/remote_content?g=com.squareup.dagger&a=dagger&v=LATEST" class="dl core-version-href">&darr; <span class="version-tag">Latest</span> JAR</a> <a href="https://search.maven.org/remote_content?g=com.squareup.dagger&a=dagger-compiler&v=LATEST" class="dl compiler-version-href">&darr; <span class="version-tag">Latest</span> Compiler JAR</a></p>
             <p>You will need to include the Dagger JAR in your application's runtime.  In order to activate code generation you will need to include the compiler JAR in your build at compile time.</p>
             <p>The source code to the Dagger, its samples, and this website is <a href="http://github.com/square/dagger">available on GitHub</a>.</p>
 
/Fim/
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
index 1e28f4f..c23ed53 100644
--- a/core/src/main/java/dagger/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -28,8 +28,10 @@
 public @interface Module {
   /**
    * Returns classes that object graphs created with this module must be able to
-   * inject. This includes both classes passed to {@link ObjectGraph#get} and
-   * the types of instances passed {@link ObjectGraph#inject}.
+   * inject. This includes both classes passed to {@link ObjectGraph#get}, 
+   * the types of instances passed {@link ObjectGraph#inject} and 
+   * {@link javax.inject.Inject} annotated classes that need to be scoped to the 
+   * resulting object graphs.
    *
    * <p>It is an error to call {@link ObjectGraph#get} or {@link
    * ObjectGraph#inject} with a type that isn't listed in the {@code injects}
/Fim/
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
index c23ed53..893a543 100644
--- a/core/src/main/java/dagger/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -28,9 +28,9 @@
 public @interface Module {
   /**
    * Returns classes that object graphs created with this module must be able to
-   * inject. This includes both classes passed to {@link ObjectGraph#get}, 
-   * the types of instances passed {@link ObjectGraph#inject} and 
-   * {@link javax.inject.Inject} annotated classes that need to be scoped to the 
+   * inject. This includes both classes passed to {@link ObjectGraph#get},
+   * the types of instances passed {@link ObjectGraph#inject} and
+   * {@link javax.inject.Inject} annotated classes that need to be scoped to the
    * resulting object graphs.
    *
    * <p>It is an error to call {@link ObjectGraph#get} or {@link
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 0bc2598..9b239b0 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -54,7 +54,7 @@
   <build>
     <plugins>
       <plugin>
-        <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+        <groupId>com.simpligility.maven.plugins</groupId>
         <artifactId>android-maven-plugin</artifactId>
         <extensions>true</extensions>
       </plugin>
/Fim/
diff --git a/examples/android-activity-graphs/AndroidManifest.xml b/examples/android-activity-graphs/src/main/AndroidManifest.xml
similarity index 100%
rename from examples/android-activity-graphs/AndroidManifest.xml
rename to examples/android-activity-graphs/src/main/AndroidManifest.xml
/Fim/
diff --git a/examples/android-activity-graphs/res/values/strings.xml b/examples/android-activity-graphs/src/main/res/values/strings.xml
similarity index 100%
rename from examples/android-activity-graphs/res/values/strings.xml
rename to examples/android-activity-graphs/src/main/res/values/strings.xml
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index f99b22d..0cc0591 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -50,7 +50,7 @@
   <build>
     <plugins>
       <plugin>
-        <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+        <groupId>com.simpligility.maven.plugins</groupId>
         <artifactId>android-maven-plugin</artifactId>
         <extensions>true</extensions>
       </plugin>
/Fim/
diff --git a/examples/android-simple/AndroidManifest.xml b/examples/android-simple/src/main/AndroidManifest.xml
similarity index 100%
rename from examples/android-simple/AndroidManifest.xml
rename to examples/android-simple/src/main/AndroidManifest.xml
/Fim/
diff --git a/examples/android-simple/res/values/strings.xml b/examples/android-simple/src/main/res/values/strings.xml
similarity index 100%
rename from examples/android-simple/res/values/strings.xml
rename to examples/android-simple/src/main/res/values/strings.xml
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index 0b9b984..a0fe83b 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -68,9 +68,9 @@
     <pluginManagement>
       <plugins>
         <plugin>
-          <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+          <groupId>com.simpligility.maven.plugins</groupId>
           <artifactId>android-maven-plugin</artifactId>
-          <version>3.8.2</version>
+          <version>4.1.1</version>
           <configuration>
             <sdk>
               <platform>16</platform>
/Fim/
diff --git a/deploy_website.sh b/deploy_website.sh
index 2f609c9..b0005fd 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -7,9 +7,6 @@
 set -ex
 
 REPO="git@github.com:square/dagger.git"
-GROUP_ID="com.squareup.dagger"
-ARTIFACT_ID="dagger"
-
 DIR=temp-dagger-clone
 
 # Delete any existing temporary website clone
@@ -24,18 +21,12 @@
 # Checkout and track the gh-pages branch
 git checkout -t origin/gh-pages
 
-# Delete everything
-rm -rf *
+# Delete everything that isn't versioned (1.x, 2.x)
+ls | grep -E -v '^\d+\.x$' | xargs rm -rf
 
 # Copy website files from real repo
 cp -R ../website/* .
 
-# Download the latest javadoc
-curl -L "https://search.maven.org/remote_content?g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
-mkdir javadoc
-unzip javadoc.zip -d javadoc
-rm javadoc.zip
-
 # Stage all files in git and create a commit
 git add .
 git add -u
/Fim/
diff --git a/website/index.html b/website/index.html
index 8406b47..815e9be 100644
--- a/website/index.html
+++ b/website/index.html
@@ -449,7 +449,7 @@
                 <li><a href="#license">License</a></li>
               </ul>
               <ul class="nav nav-pills nav-stacked secondary">
-                <li><a href="javadoc/index.html">Javadoc</a></li>
+                <li><a href="1.x/dagger/">Javadoc</a></li>
                 <li><a href="https://groups.google.com/forum/#!forum/dagger-discuss">dagger-discuss@</a></li>
                 <li><a href="http://stackoverflow.com/questions/tagged/dagger?sort=active">StackOverflow</a></li>
               </ul>
/Fim/
diff --git a/pom.xml b/pom.xml
index 7d08bed..c4706b5 100644
--- a/pom.xml
+++ b/pom.xml
@@ -43,7 +43,7 @@
     <!-- Compilation -->
     <java.version>1.6</java.version>
     <javax.inject.version>1</javax.inject.version>
-    <javapoet.version>1.0.0</javapoet.version>
+    <javapoet.version>1.4.0</javapoet.version>
     <guava.version>18.0</guava.version>
 
     <!-- Test Dependencies -->
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 8810067..942afe3 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -52,6 +52,11 @@
       <scope>test</scope>
     </dependency>
     <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
       <groupId>org.easytesting</groupId>
       <artifactId>fest-assert</artifactId>
       <scope>test</scope>
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
index c3cd022..fe81458 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.annotations.VisibleForTesting;
 import dagger.internal.Binding;
 import dagger.internal.Loader;
 import dagger.internal.ModuleAdapter;
@@ -22,6 +23,7 @@
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
 
 /**
  * A {@code Binding.Resolver} suitable for tool use at build time. The bindings created by
@@ -39,8 +41,7 @@
 
   @Override public Binding<?> getAtInjectBinding(
       String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
-    String sourceClassName = className.replace('$', '.');
-    TypeElement type = processingEnv.getElementUtils().getTypeElement(sourceClassName);
+    TypeElement type = resolveType(processingEnv.getElementUtils(), className);
     if (type == null) {
       // We've encountered a type that the compiler can't introspect. If this
       // causes problems in practice (due to incremental compiles, etc.) we
@@ -54,6 +55,85 @@
     return GraphAnalysisInjectBinding.create(type, mustHaveInjections);
   }
 
+  /**
+   * Resolves the given class name into a {@link TypeElement}. The class name is a binary name, but
+   * {@link Elements#getTypeElement(CharSequence)} wants a canonical name. So this method searches
+   * the space of possible canonical names, starting with the most likely (since '$' is rarely used
+   * in canonical class names).
+   */
+  @VisibleForTesting static TypeElement resolveType(Elements elements, String className) {
+    int index = nextDollar(className, className, 0);
+    if (index == -1) {
+      return getTypeElement(elements, className);
+    }
+    // have to test various possibilities of replacing '$' with '.' since '.' in a canonical name
+    // of a nested type is replaced with '$' in the binary name.
+    StringBuilder sb = new StringBuilder(className);
+    return resolveType(elements, className, sb, index);
+  }
+
+  /**
+   * Recursively explores the space of possible canonical names for a given binary class name.
+   *
+   * @param elements used to resolve a name into a {@link TypeElement}
+   * @param className binary class name
+   * @param sb the current permutation of canonical name to attempt to resolve
+   * @param index the index of a {@code '$'} which may be changed to {@code '.'} in a canonical name
+   */
+  private static TypeElement resolveType(Elements elements, String className, StringBuilder sb,
+      final int index) {
+
+    // We assume '$' should be converted to '.'. So we search for classes with dots first.
+    sb.setCharAt(index, '.');
+    int nextIndex = nextDollar(className, sb, index + 1);
+    TypeElement type = nextIndex == -1
+        ? getTypeElement(elements, sb)
+        : resolveType(elements, className, sb, nextIndex);
+    if (type != null) {
+      return type;
+    }
+
+    // if not found, change back to dollar and search.
+    sb.setCharAt(index, '$');
+    nextIndex = nextDollar(className, sb, index + 1);
+    return nextIndex == -1
+        ? getTypeElement(elements, sb)
+        : resolveType(elements, className, sb, nextIndex);
+  }
+
+  /**
+   * Finds the next {@code '$'} in a class name which can be changed to a {@code '.'} when computing
+   * a canonical class name.
+   */
+  private static int nextDollar(String className, CharSequence current, int searchStart) {
+    while (true) {
+      int index = className.indexOf('$', searchStart);
+      if (index == -1) {
+        return -1;
+      }
+      // We'll never have two dots nor will a type name end or begin with dot. So no need to
+      // consider dollars at the beginning, end, or adjacent to dots.
+      if (index == 0 || index == className.length() - 1
+          || current.charAt(index - 1) == '.' || current.charAt(index + 1) == '.') {
+        searchStart = index + 1;
+        continue;
+      }
+      return index;
+    }
+  }
+
+  private static TypeElement getTypeElement(Elements elements, CharSequence className) {
+    try {
+      return elements.getTypeElement(className);
+    } catch (ClassCastException e) {
+      // work-around issue in javac in Java 7 where querying for non-existent type can
+      // throw a ClassCastException
+      // TODO(jh): refer to Oracle Bug ID if/when one is assigned to bug report
+      // (Review ID: JI-9027367)
+      return null;
+    }
+  }
+
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<T> moduleClass) {
     throw new UnsupportedOperationException();
   }
/Fim/
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphAnalysisLoaderTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphAnalysisLoaderTest.java
new file mode 100644
index 0000000..4a258bd
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphAnalysisLoaderTest.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2015 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import java.util.ArrayList;
+import java.util.List;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mockito;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+@RunWith(JUnit4.class)
+public class GraphAnalysisLoaderTest {
+  @Test public void resolveType() {
+    final List<String> resolveAttempts = new ArrayList<String>();
+    Elements elements = mock(Elements.class);
+    when(elements.getTypeElement(any(CharSequence.class))).then(new Answer<TypeElement>() {
+      @Override public TypeElement answer(InvocationOnMock invocationOnMock) throws Throwable {
+        resolveAttempts.add(invocationOnMock.getArguments()[0].toString());
+        return null;
+      }
+    });
+
+    assertNull(GraphAnalysisLoader.resolveType(elements, "blah.blah.Foo$Bar$Baz"));
+    List<String> expectedAttempts = ImmutableList.<String>builder()
+        .add("blah.blah.Foo.Bar.Baz")
+        .add("blah.blah.Foo.Bar$Baz")
+        .add("blah.blah.Foo$Bar.Baz")
+        .add("blah.blah.Foo$Bar$Baz")
+        .build();
+    assertEquals(expectedAttempts, resolveAttempts);
+
+    resolveAttempts.clear();
+    assertNull(GraphAnalysisLoader.resolveType(elements, "$$Foo$$Bar$$Baz$$"));
+    expectedAttempts = ImmutableList.<String>builder()
+        .add("$.Foo.$Bar.$Baz.$")
+        .add("$.Foo.$Bar.$Baz$$")
+        .add("$.Foo.$Bar$.Baz.$")
+        .add("$.Foo.$Bar$.Baz$$")
+        .add("$.Foo.$Bar$$Baz.$")
+        .add("$.Foo.$Bar$$Baz$$")
+        .add("$.Foo$.Bar.$Baz.$")
+        .add("$.Foo$.Bar.$Baz$$")
+        .add("$.Foo$.Bar$.Baz.$")
+        .add("$.Foo$.Bar$.Baz$$")
+        .add("$.Foo$.Bar$$Baz.$")
+        .add("$.Foo$.Bar$$Baz$$")
+        .add("$.Foo$$Bar.$Baz.$")
+        .add("$.Foo$$Bar.$Baz$$")
+        .add("$.Foo$$Bar$.Baz.$")
+        .add("$.Foo$$Bar$.Baz$$")
+        .add("$.Foo$$Bar$$Baz.$")
+        .add("$.Foo$$Bar$$Baz$$")
+        .add("$$Foo.$Bar.$Baz.$")
+        .add("$$Foo.$Bar.$Baz$$")
+        .add("$$Foo.$Bar$.Baz.$")
+        .add("$$Foo.$Bar$.Baz$$")
+        .add("$$Foo.$Bar$$Baz.$")
+        .add("$$Foo.$Bar$$Baz$$")
+        .add("$$Foo$.Bar.$Baz.$")
+        .add("$$Foo$.Bar.$Baz$$")
+        .add("$$Foo$.Bar$.Baz.$")
+        .add("$$Foo$.Bar$.Baz$$")
+        .add("$$Foo$.Bar$$Baz.$")
+        .add("$$Foo$.Bar$$Baz$$")
+        .add("$$Foo$$Bar.$Baz.$")
+        .add("$$Foo$$Bar.$Baz$$")
+        .add("$$Foo$$Bar$.Baz.$")
+        .add("$$Foo$$Bar$.Baz$$")
+        .add("$$Foo$$Bar$$Baz.$")
+        .add("$$Foo$$Bar$$Baz$$")
+        .build();
+    assertEquals(expectedAttempts, resolveAttempts);
+
+    Mockito.validateMockitoUsage();
+  }
+
+  
+}
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index fb2e566..621b7ca 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -35,7 +35,11 @@
         "import javax.inject.Inject;",
         "class Basic {",
         "  static class A { @Inject A() { } }",
-        "  @Module(injects = A.class)",
+        "  static class Foo$Bar {",
+        "    @Inject Foo$Bar() { }",
+        "    static class Baz { @Inject Baz() { } }",
+        "  }",
+        "  @Module(injects = { A.class, Foo$Bar.class, Foo$Bar.Baz.class })",
         "  static class AModule { }",
         "}"));
 
@@ -47,7 +51,8 @@
             "import java.lang.String;",
             "public final class Basic$AModule$$ModuleAdapter",
             "    extends ModuleAdapter<Basic.AModule> {",
-            "  private static final String[] INJECTS = {\"members/Basic$A\"};",
+            "  private static final String[] INJECTS = {",
+            "      \"members/Basic$A\", \"members/Basic$Foo$Bar\", \"members/Basic$Foo$Bar$Baz\"};",
             "  private static final Class<?>[] STATIC_INJECTIONS = {};",
             "  private static final Class<?>[] INCLUDES = {};",
             "  public Basic$AModule$$ModuleAdapter() {",
@@ -59,7 +64,7 @@
             "  }",
             "}"));
 
-    JavaFileObject expectedInjectAdapter =
+    JavaFileObject expectedInjectAdapterA =
         JavaFileObjects.forSourceString("Basic$A$$InjectAdapter", Joiner.on("\n").join(
             "import dagger.internal.Binding;",
             "import java.lang.Override;",
@@ -75,9 +80,44 @@
             "  }",
             "}"));
 
+    JavaFileObject expectedInjectAdapterFooBar =
+        JavaFileObjects.forSourceString("Basic$Foo$Bar$$InjectAdapter", Joiner.on("\n").join(
+            "import dagger.internal.Binding;",
+            "import java.lang.Override;",
+            "import javax.inject.Provider;",
+            "public final class Basic$Foo$Bar$$InjectAdapter",
+            "    extends Binding<Basic.Foo$Bar> implements Provider<Basic.Foo$Bar> {",
+            "  public Basic$Foo$Bar$$InjectAdapter() {",
+            "    super(\"Basic$Foo$Bar\", \"members/Basic$Foo$Bar\",",
+            "        NOT_SINGLETON, Basic.Foo$Bar.class);",
+            "  }",
+            "  @Override public Basic.Foo$Bar get() {",
+            "    Basic.Foo$Bar result = new Basic.Foo$Bar();",
+            "    return result;",
+            "  }",
+            "}"));
+
+    JavaFileObject expectedInjectAdapterFooBarBaz =
+        JavaFileObjects.forSourceString("Basic$Foo$Bar$Baz$$InjectAdapter", Joiner.on("\n").join(
+            "import dagger.internal.Binding;",
+            "import java.lang.Override;",
+            "import javax.inject.Provider;",
+            "public final class Basic$Foo$Bar$Baz$$InjectAdapter",
+            "    extends Binding<Basic.Foo$Bar.Baz> implements Provider<Basic.Foo$Bar.Baz> {",
+            "  public Basic$Foo$Bar$Baz$$InjectAdapter() {",
+            "    super(\"Basic$Foo$Bar$Baz\", \"members/Basic$Foo$Bar$Baz\",",
+            "        NOT_SINGLETON, Basic.Foo$Bar.Baz.class);",
+            "  }",
+            "  @Override public Basic.Foo$Bar.Baz get() {",
+            "    Basic.Foo$Bar.Baz result = new Basic.Foo$Bar.Baz();",
+            "    return result;",
+            "  }",
+            "}"));
+
     ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
         .compilesWithoutError().and()
-        .generatesSources(expectedModuleAdapter, expectedInjectAdapter);
+        .generatesSources(expectedModuleAdapter, expectedInjectAdapterA,
+            expectedInjectAdapterFooBar, expectedInjectAdapterFooBarBaz);
 
   }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Memoizer.java b/core/src/main/java/dagger/internal/Memoizer.java
index 04cdc10..a168aab 100644
--- a/core/src/main/java/dagger/internal/Memoizer.java
+++ b/core/src/main/java/dagger/internal/Memoizer.java
@@ -22,7 +22,9 @@
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 /**
- * Represents an operation to be
+ * Represents an operation whose results are memoized. Results returned by invocations of
+ * {@link #create(Object)} are memoized so that the same object is returned for multiple invocations
+ * of {@link #get(Object)} for the same key.
  */
 abstract class Memoizer<K, V> {
   private final Map<K, V> map;
/Fim/
diff --git a/core/src/test/java/dagger/internal/FailoverLoaderTest.java b/core/src/test/java/dagger/internal/FailoverLoaderTest.java
index cb17ef6..5cde6a6 100644
--- a/core/src/test/java/dagger/internal/FailoverLoaderTest.java
+++ b/core/src/test/java/dagger/internal/FailoverLoaderTest.java
@@ -33,7 +33,7 @@
 @RunWith(JUnit4.class)
 public final class FailoverLoaderTest {
 
-  @Module(injects = EntryPoint.class)
+  @Module(injects = Entry$Point.class)
   static class TestModule {
     @Provides String aString() { return "a"; }
   }
@@ -45,12 +45,12 @@
     }
   }
 
-  static class EntryPoint {
+  static class Entry$Point {
     @Inject String a;
   }
 
   @Test public void simpleInjectionWithUnGeneratedCode() {
-    EntryPoint entryPoint = new EntryPoint();
+    Entry$Point entryPoint = new Entry$Point();
     ObjectGraph.create(new TestModule()).inject(entryPoint);
     assertThat(entryPoint.a).isEqualTo("a");
   }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index b432093..112fb8d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -314,7 +314,7 @@
     }
   }
 
-  private static TypeName box(PrimitiveType primitiveType) {
+  static TypeName box(PrimitiveType primitiveType) {
     switch (primitiveType.getKind()) {
       case BYTE:
         return ClassName.get(Byte.class);
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index a1736d2..d8b8f5a 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -163,7 +163,7 @@
       return object;
     }
 
-    private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Object... modules) {
+    static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Object... modules) {
       Map<String, Class<?>> injectableTypes = new LinkedHashMap<String, Class<?>>();
       Map<Class<?>, StaticInjection> staticInjections
           = new LinkedHashMap<Class<?>, StaticInjection>();
/Fim/
diff --git a/core/src/main/java/dagger/internal/LazyBinding.java b/core/src/main/java/dagger/internal/LazyBinding.java
index c1e1c71..bac8fb4 100644
--- a/core/src/main/java/dagger/internal/LazyBinding.java
+++ b/core/src/main/java/dagger/internal/LazyBinding.java
@@ -23,13 +23,13 @@
  */
 final class LazyBinding<T> extends Binding<Lazy<T>> {
 
-  private final static Object NOT_PRESENT = new Object();
+  final static Object NOT_PRESENT = new Object();
 
   private final String lazyKey;
   private final ClassLoader loader;
-  private Binding<T> delegate;
+  Binding<T> delegate;
 
-  public LazyBinding(String key, Object requiredBy, ClassLoader loader, String lazyKey) {
+  LazyBinding(String key, Object requiredBy, ClassLoader loader, String lazyKey) {
     super(key, null, false, requiredBy);
     this.loader = loader;
     this.lazyKey = lazyKey;
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index e9cf9f4..b5cf55e 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -28,7 +28,7 @@
  * Links bindings to their dependencies.
  */
 public final class Linker {
-  private static final Object UNINITIALIZED = new Object();
+  static final Object UNINITIALIZED = new Object();
 
   /**
    * The base {@code Linker} which will be consulted to satisfy bindings not
@@ -348,7 +348,7 @@
     private final Binding<T> binding;
     private volatile Object onlyInstance = UNINITIALIZED;
 
-    private SingletonBinding(Binding<T> binding) {
+    SingletonBinding(Binding<T> binding) {
       super(binding.provideKey, binding.membersKey, true, binding.requiredBy);
       this.binding = binding;
     }
@@ -449,7 +449,7 @@
     final String deferredKey;
     final boolean mustHaveInjections;
 
-    private DeferredBinding(String deferredKey, ClassLoader classLoader, Object requiredBy,
+    DeferredBinding(String deferredKey, ClassLoader classLoader, Object requiredBy,
         boolean mustHaveInjections) {
       super(null, null, false, requiredBy);
       this.deferredKey = deferredKey;
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
index e06002e..5248663 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
@@ -22,7 +22,6 @@
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeSpec;
-import dagger.MembersInjector;
 import dagger.ObjectGraph;
 import dagger.internal.Binding;
 import dagger.internal.Linker;
@@ -38,7 +37,6 @@
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
 import javax.inject.Inject;
-import javax.inject.Provider;
 import javax.inject.Singleton;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
@@ -263,15 +261,6 @@
         .addJavadoc("$L", bindingTypeDocs(injectableType(type.asType()), isAbstract,
             injectMembers, dependent).toString());
 
-    if (constructor != null) {
-      result.addSuperinterface(ParameterizedTypeName.get(
-          ClassName.get(Provider.class), injectedClassName));
-    }
-    if (injectMembers) {
-      result.addSuperinterface(ParameterizedTypeName.get(
-          ClassName.get(MembersInjector.class), injectedClassName));
-    }
-
     for (Element field : fields) {
       result.addField(memberBindingField(disambiguateFields, field));
     }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index e83a1e9..13e53b9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -410,8 +410,7 @@
     TypeSpec.Builder result = TypeSpec.classBuilder(className.simpleName())
         .addJavadoc("$L", bindingTypeDocs(returnType, false, false, dependent))
         .addModifiers(PUBLIC, STATIC, FINAL)
-        .superclass(ParameterizedTypeName.get(ClassName.get(ProvidesBinding.class), returnType))
-        .addSuperinterface(ParameterizedTypeName.get(ClassName.get(Provider.class), returnType));
+        .superclass(ParameterizedTypeName.get(ClassName.get(ProvidesBinding.class), returnType));
 
     result.addField(moduleClassName, "module", PRIVATE, FINAL);
     for (Element parameter : parameters) {
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index 621b7ca..7d43857 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -68,9 +68,8 @@
         JavaFileObjects.forSourceString("Basic$A$$InjectAdapter", Joiner.on("\n").join(
             "import dagger.internal.Binding;",
             "import java.lang.Override;",
-            "import javax.inject.Provider;",
             "public final class Basic$A$$InjectAdapter",
-            "    extends Binding<Basic.A> implements Provider<Basic.A> {",
+            "    extends Binding<Basic.A> {",
             "  public Basic$A$$InjectAdapter() {",
             "    super(\"Basic$A\", \"members/Basic$A\", NOT_SINGLETON, Basic.A.class);",
             "  }",
@@ -84,9 +83,8 @@
         JavaFileObjects.forSourceString("Basic$Foo$Bar$$InjectAdapter", Joiner.on("\n").join(
             "import dagger.internal.Binding;",
             "import java.lang.Override;",
-            "import javax.inject.Provider;",
             "public final class Basic$Foo$Bar$$InjectAdapter",
-            "    extends Binding<Basic.Foo$Bar> implements Provider<Basic.Foo$Bar> {",
+            "    extends Binding<Basic.Foo$Bar> {",
             "  public Basic$Foo$Bar$$InjectAdapter() {",
             "    super(\"Basic$Foo$Bar\", \"members/Basic$Foo$Bar\",",
             "        NOT_SINGLETON, Basic.Foo$Bar.class);",
@@ -101,9 +99,8 @@
         JavaFileObjects.forSourceString("Basic$Foo$Bar$Baz$$InjectAdapter", Joiner.on("\n").join(
             "import dagger.internal.Binding;",
             "import java.lang.Override;",
-            "import javax.inject.Provider;",
             "public final class Basic$Foo$Bar$Baz$$InjectAdapter",
-            "    extends Binding<Basic.Foo$Bar.Baz> implements Provider<Basic.Foo$Bar.Baz> {",
+            "    extends Binding<Basic.Foo$Bar.Baz> {",
             "  public Basic$Foo$Bar$Baz$$InjectAdapter() {",
             "    super(\"Basic$Foo$Bar$Baz\", \"members/Basic$Foo$Bar$Baz\",",
             "        NOT_SINGLETON, Basic.Foo$Bar.Baz.class);",
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
index add10ec..5dd73f3 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
@@ -65,7 +65,6 @@
         "import java.lang.Class;",
         "import java.lang.Override;",
         "import java.lang.String;",
-        "import javax.inject.Provider;",
         "public final class Field$AModule$$ModuleAdapter",
         "    extends ModuleAdapter<Field.AModule> {",
         "  private static final String[] INJECTS = ",
@@ -83,7 +82,7 @@
         "        new NameProvidesAdapter(module));", // eager new!
         "  }",
         "  public static final class NameProvidesAdapter", // corresponds to method name
-        "      extends ProvidesBinding<String> implements Provider<String> {",
+        "      extends ProvidesBinding<String> {",
         "    private final Field.AModule module;",
         "    public NameProvidesAdapter(Field.AModule module) {",
         "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");",
@@ -104,9 +103,8 @@
             "import java.lang.String;",
             "import java.lang.SuppressWarnings;",
             "import java.util.Set;",
-            "import javax.inject.Provider;",
             "public final class Field$A$$InjectAdapter",
-            "    extends Binding<Field.A> implements Provider<Field.A> {",
+            "    extends Binding<Field.A> {",
             "  private Binding<String> name;", // for ctor
             "  public Field$A$$InjectAdapter() {",
             "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
@@ -153,7 +151,6 @@
         "import java.lang.Class;",
         "import java.lang.Override;",
         "import java.lang.String;",
-        "import javax.inject.Provider;",
         "public final class Field$AModule$$ModuleAdapter extends ModuleAdapter<Field.AModule> {",
         "  private static final String[] INJECTS = ",
         "      {\"members/Field$A\", \"members/java.lang.String\", \"members/Field$B\"};",
@@ -170,7 +167,7 @@
         "        new NameProvidesAdapter(module));", // eager new!
         "  }",
         "  public static final class NameProvidesAdapter", // corresponds to method name
-        "      extends ProvidesBinding<String> implements Provider<String> {",
+        "      extends ProvidesBinding<String> {",
         "    private final Field.AModule module;",
         "    public NameProvidesAdapter(Field.AModule module) {",
         "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");",
@@ -191,9 +188,8 @@
             "import java.lang.String;",
             "import java.lang.SuppressWarnings;",
             "import java.util.Set;",
-            "import javax.inject.Provider;",
             "public final class Field$A$$InjectAdapter",
-            "    extends Binding<Field.A> implements Provider<Field.A> {",
+            "    extends Binding<Field.A> {",
             "  private Binding<String> name;", // For Constructor.
             "  public Field$A$$InjectAdapter() {",
             "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
@@ -215,16 +211,14 @@
 
     JavaFileObject expectedInjectAdapterB =
         JavaFileObjects.forSourceString("Field$B$$InjectAdapter", Joiner.on("\n").join(
-            "import dagger.MembersInjector;",
             "import dagger.internal.Binding;",
             "import dagger.internal.Linker;",
             "import java.lang.Override;",
             "import java.lang.String;",
             "import java.lang.SuppressWarnings;",
             "import java.util.Set;",
-            "import javax.inject.Provider;",
             "public final class Field$B$$InjectAdapter",
-            "    extends Binding<Field.B> implements Provider<Field.B>, MembersInjector<Field.B> {",
+            "    extends Binding<Field.B> {",
             "  private Binding<String> name;", // For field.
             "  public Field$B$$InjectAdapter() {",
             "    super(\"Field$B\", \"members/Field$B\", NOT_SINGLETON, Field.B.class);",
/Fim/
/Fim/
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index d009f75..13878c9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -164,8 +164,6 @@
       boolean ignoreCompletenessErrors) {
     Map<String, TypeElement> allModules = new LinkedHashMap<String, TypeElement>();
     collectIncludesRecursively(rootModule, allModules, new LinkedList<String>());
-    ArrayList<GraphAnalysisStaticInjection> staticInjections =
-        new ArrayList<GraphAnalysisStaticInjection>();
 
     Linker.ErrorHandler errorHandler = ignoreCompletenessErrors ? Linker.ErrorHandler.NULL
         : new GraphAnalysisErrorHandler(processingEnv, rootModule.getQualifiedName().toString());
@@ -203,13 +201,6 @@
               getClass().getClassLoader(), false, true);
         }
 
-        // Gather the static injections.
-        for (Object staticInjection : (Object[]) annotation.get("staticInjections")) {
-          TypeMirror staticInjectionTypeMirror = (TypeMirror) staticInjection;
-          Element element = processingEnv.getTypeUtils().asElement(staticInjectionTypeMirror);
-          staticInjections.add(new GraphAnalysisStaticInjection(element));
-        }
-
         // Gather the enclosed @Provides methods.
         for (Element enclosed : module.getEnclosedElements()) {
           Provides provides = enclosed.getAnnotation(Provides.class);
@@ -264,9 +255,6 @@
 
       linker.installBindings(baseBindings);
       linker.installBindings(overrideBindings);
-      for (GraphAnalysisStaticInjection staticInjection : staticInjections) {
-        staticInjection.attach(linker);
-      }
 
       // Link the bindings. This will traverse the dependency graph, and report
       // errors if any dependencies are missing.
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
index 5248663..442d493 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
@@ -22,10 +22,8 @@
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeSpec;
-import dagger.ObjectGraph;
 import dagger.internal.Binding;
 import dagger.internal.Linker;
-import dagger.internal.StaticInjection;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -60,7 +58,6 @@
 import static dagger.internal.codegen.Util.isCallableConstructor;
 import static dagger.internal.codegen.Util.rawTypeToString;
 import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
-import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -87,8 +84,7 @@
       boolean missingDependentClasses =
           !allTypesExist(injectedClass.fields)
           || (injectedClass.constructor != null && !allTypesExist(injectedClass.constructor
-              .getParameters()))
-          || !allTypesExist(injectedClass.staticFields);
+              .getParameters()));
       if (!missingDependentClasses) {
         try {
           generateInjectionsForClass(injectedClass);
@@ -109,9 +105,6 @@
     if (injectedClass.constructor != null || !injectedClass.fields.isEmpty()) {
       generateInjectAdapter(injectedClass.type, injectedClass.constructor, injectedClass.fields);
     }
-    if (!injectedClass.staticFields.isEmpty()) {
-      generateStaticInjection(injectedClass.type, injectedClass.staticFields);
-    }
   }
 
   /**
@@ -189,7 +182,6 @@
   private InjectedClass createInjectedClass(String injectedClassName) {
     TypeElement type = processingEnv.getElementUtils().getTypeElement(injectedClassName);
     boolean isAbstract = type.getModifiers().contains(ABSTRACT);
-    List<Element> staticFields = new ArrayList<Element>();
     ExecutableElement constructor = null;
     List<Element> fields = new ArrayList<Element>();
     for (Element member : type.getEnclosedElements()) {
@@ -200,7 +192,7 @@
       switch (member.getKind()) {
         case FIELD:
           if (member.getModifiers().contains(STATIC)) {
-            staticFields.add(member);
+            error("@Inject not supported on static field " + type.getQualifiedName(), member);
           } else {
             fields.add(member);
           }
@@ -230,7 +222,7 @@
       }
     }
 
-    return new InjectedClass(type, staticFields, constructor, fields);
+    return new InjectedClass(type, constructor, fields);
   }
 
   /**
@@ -295,31 +287,6 @@
     javaFile.writeTo(processingEnv.getFiler());
   }
 
-  /**
-   * Write a companion class for {@code type} that extends {@link StaticInjection}.
-   */
-  private void generateStaticInjection(TypeElement type, List<Element> fields) throws IOException {
-    ClassName typeName = ClassName.get(type);
-    ClassName adapterClassName = adapterName(ClassName.get(type), STATIC_INJECTION_SUFFIX);
-
-    TypeSpec.Builder result = TypeSpec.classBuilder(adapterClassName.simpleName())
-        .addOriginatingElement(type)
-        .addJavadoc(AdapterJavadocs.STATIC_INJECTION_TYPE, type)
-        .addModifiers(PUBLIC, FINAL)
-        .superclass(StaticInjection.class);
-    for (Element field : fields) {
-      result.addField(memberBindingField(false, field));
-    }
-    result.addMethod(attachMethod(null, fields, false, typeName, null, true));
-    result.addMethod(staticInjectMethod(fields, typeName));
-
-    String packageName = getPackage(type).getQualifiedName().toString();
-    JavaFile javaFile = JavaFile.builder(packageName, result.build())
-        .addFileComment(AdapterJavadocs.GENERATED_BY_DAGGER)
-        .build();
-    javaFile.writeTo(processingEnv.getFiler());
-  }
-
   private FieldSpec memberBindingField(boolean disambiguateFields, Element field) {
     return FieldSpec.builder(bindingOf(field.asType()), fieldName(disambiguateFields, field),
         PRIVATE).build();
@@ -453,20 +420,6 @@
     return result.build();
   }
 
-  private MethodSpec staticInjectMethod(List<Element> fields, ClassName typeName) {
-    MethodSpec.Builder result = MethodSpec.methodBuilder("inject")
-        .addJavadoc(AdapterJavadocs.STATIC_INJECT_METHOD, ObjectGraph.class)
-        .addAnnotation(Override.class)
-        .addModifiers(PUBLIC);
-    for (Element field : fields) {
-      result.addStatement("$T.$N = $N.get()",
-          typeName,
-          field.getSimpleName().toString(),
-          fieldName(false, field));
-    }
-    return result.build();
-  }
-
   private String fieldName(boolean disambiguateFields, Element field) {
     return (disambiguateFields ? "field_" : "") + field.getSimpleName().toString();
   }
@@ -481,14 +434,11 @@
 
   static class InjectedClass {
     final TypeElement type;
-    final List<Element> staticFields;
     final ExecutableElement constructor;
     final List<Element> fields;
 
-    InjectedClass(TypeElement type, List<Element> staticFields, ExecutableElement constructor,
-        List<Element> fields) {
+    InjectedClass(TypeElement type, ExecutableElement constructor, List<Element> fields) {
       this.type = type;
-      this.staticFields = staticFields;
       this.constructor = constructor;
       this.fields = fields;
     }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 13e53b9..2dc3cb4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -232,7 +232,6 @@
    */
   private JavaFile generateModuleAdapter(TypeElement type,
       Map<String, Object> module, List<ExecutableElement> providerMethods) {
-    Object[] staticInjections = (Object[]) module.get("staticInjections");
     Object[] injects = (Object[]) module.get("injects");
     Object[] includes = (Object[]) module.get("includes");
     boolean overrides = (Boolean) module.get("overrides");
@@ -252,17 +251,13 @@
         .addModifiers(PRIVATE, STATIC, FINAL)
         .initializer("$L", injectsInitializer(injects))
         .build());
-    adapterBuilder.addField(FieldSpec.builder(ARRAY_OF_CLASS, "STATIC_INJECTIONS")
-        .addModifiers(PRIVATE, STATIC, FINAL)
-        .initializer("$L", staticInjectionsInitializer(staticInjections))
-        .build());
     adapterBuilder.addField(FieldSpec.builder(ARRAY_OF_CLASS, "INCLUDES")
         .addModifiers(PRIVATE, STATIC, FINAL)
         .initializer("$L", includesInitializer(type, includes))
         .build());
     adapterBuilder.addMethod(MethodSpec.constructorBuilder()
         .addModifiers(PUBLIC)
-        .addStatement("super($T.class, INJECTS, STATIC_INJECTIONS, $L /*overrides*/, "
+        .addStatement("super($T.class, INJECTS, $L /*overrides*/, "
                 + "INCLUDES, $L /*complete*/, $L /*library*/)",
             type.asType(), overrides, complete, library)
         .build());
@@ -347,16 +342,6 @@
     return result.build();
   }
 
-  private CodeBlock staticInjectionsInitializer(Object[] staticInjections) {
-    CodeBlock.Builder result = CodeBlock.builder()
-        .add("{ ");
-    for (Object staticInjection : staticInjections) {
-      result.add("$T.class, ", staticInjection);
-    }
-    result.add("}");
-    return result.build();
-  }
-
   private CodeBlock includesInitializer(TypeElement type, Object[] includes) {
     CodeBlock.Builder result = CodeBlock.builder();
     result.add("{ ");
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index 7d43857..c4f07eb 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -53,10 +53,9 @@
             "    extends ModuleAdapter<Basic.AModule> {",
             "  private static final String[] INJECTS = {",
             "      \"members/Basic$A\", \"members/Basic$Foo$Bar\", \"members/Basic$Foo$Bar$Baz\"};",
-            "  private static final Class<?>[] STATIC_INJECTIONS = {};",
             "  private static final Class<?>[] INCLUDES = {};",
             "  public Basic$AModule$$ModuleAdapter() {",
-            "    super(Basic.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES,",
+            "    super(Basic.AModule.class, INJECTS, false, INCLUDES,",
             "      true, false);",
             "  }",
             "  @Override public Basic.AModule newModule() {",
@@ -117,4 +116,22 @@
             expectedInjectAdapterFooBar, expectedInjectAdapterFooBarBaz);
 
   }
+
+  @Test public void injectStaticFails() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Basic", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import javax.inject.Inject;",
+        "class Basic {",
+        "  static class A { @Inject A() { } }",
+        "  static class B { @Inject static A a; }",
+        "  @Module(injects = B.class)",
+        "  static class AModule { }",
+        "}"));
+
+    ASSERT.about(javaSource()).that(sourceFile)
+        .processedWith(daggerProcessors())
+        .failsToCompile()
+        .withErrorContaining("@Inject not supported on static field Basic.B")
+        .in(sourceFile).onLine(5);
+  }
 }
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
index 5dd73f3..657ddaa 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
@@ -69,10 +69,9 @@
         "    extends ModuleAdapter<Field.AModule> {",
         "  private static final String[] INJECTS = ",
         "      {\"members/Field$A\", \"members/java.lang.String\"};",
-        "  private static final Class<?>[] STATIC_INJECTIONS = {};",
         "  private static final Class<?>[] INCLUDES = {};",
         "  public Field$AModule$$ModuleAdapter() {",
-        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
+        "    super(Field.AModule.class, INJECTS, false, INCLUDES, true, false);",
         "  }",
         "  @Override public Field.AModule newModule() {",
         "    return new Field.AModule();",
@@ -154,10 +153,9 @@
         "public final class Field$AModule$$ModuleAdapter extends ModuleAdapter<Field.AModule> {",
         "  private static final String[] INJECTS = ",
         "      {\"members/Field$A\", \"members/java.lang.String\", \"members/Field$B\"};",
-        "  private static final Class<?>[] STATIC_INJECTIONS = {};",
         "  private static final Class<?>[] INCLUDES = {};",
         "  public Field$AModule$$ModuleAdapter() {",
-        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
+        "    super(Field.AModule.class, INJECTS, false, INCLUDES, true, false);",
         "  }",
         "  @Override public Field.AModule newModule() {",
         "    return new Field.AModule();",
/Fim/
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
index 893a543..f2c560a 100644
--- a/core/src/main/java/dagger/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -51,7 +51,6 @@
    * </ul>
    */
   Class<?>[] injects() default { };
-  Class<?>[] staticInjections() default { };
 
   /**
    * True if {@code @Provides} methods from this module are permitted to
/Fim/
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index d8b8f5a..36077e2 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -26,7 +26,6 @@
 import dagger.internal.Modules;
 import dagger.internal.ProblemDetector;
 import dagger.internal.SetBinding;
-import dagger.internal.StaticInjection;
 import dagger.internal.ThrowingErrorHandler;
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
@@ -107,18 +106,11 @@
   public abstract void validate();
 
   /**
-   * Injects the static fields of the classes listed in the object graph's
-   * {@code staticInjections} property.
-   */
-  public abstract void injectStatics();
-
-  /**
    * Returns a new dependency graph using the {@literal @}{@link
    * Module}-annotated modules.
    *
    * <p>This <strong>does not</strong> inject any members. Most applications
-   * should call {@link #injectStatics} to inject static members and {@link
-   * #inject} or get {@link #get(Class)} to inject instance members when this
+   * should call {@link #inject} or get {@link #get(Class)} to inject instance members when this
    * method has returned.
    *
    * <p>This <strong>does not</strong> validate the graph. Rely on build time
@@ -139,21 +131,18 @@
     private final DaggerObjectGraph base;
     private final Linker linker;
     private final Loader plugin;
-    private final Map<Class<?>, StaticInjection> staticInjections;
     private final Map<String, Class<?>> injectableTypes;
     private final List<SetBinding<?>> setBindings;
 
     DaggerObjectGraph(DaggerObjectGraph base,
         Linker linker,
         Loader plugin,
-        Map<Class<?>, StaticInjection> staticInjections,
         Map<String, Class<?>> injectableTypes,
         List<SetBinding<?>> setBindings) {
 
       this.base = base;
       this.linker = checkNotNull(linker, "linker");
       this.plugin = checkNotNull(plugin, "plugin");
-      this.staticInjections = checkNotNull(staticInjections, "staticInjections");
       this.injectableTypes = checkNotNull(injectableTypes, "injectableTypes");
       this.setBindings = checkNotNull(setBindings, "setBindings");
     }
@@ -165,8 +154,6 @@
 
     static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Object... modules) {
       Map<String, Class<?>> injectableTypes = new LinkedHashMap<String, Class<?>>();
-      Map<Class<?>, StaticInjection> staticInjections
-          = new LinkedHashMap<Class<?>, StaticInjection>();
       StandardBindings baseBindings =
           (base == null) ? new StandardBindings() : new StandardBindings(base.setBindings);
       BindingsGroup overrideBindings = new OverridesBindings();
@@ -177,9 +164,6 @@
         for (int i = 0; i < moduleAdapter.injectableTypes.length; i++) {
           injectableTypes.put(moduleAdapter.injectableTypes[i], moduleAdapter.moduleClass);
         }
-        for (int i = 0; i < moduleAdapter.staticInjections.length; i++) {
-          staticInjections.put(moduleAdapter.staticInjections[i], null);
-        }
         try {
           BindingsGroup addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
           moduleAdapter.getBindings(addTo, loadedModule.getValue());
@@ -196,7 +180,7 @@
       linker.installBindings(overrideBindings);
 
       return new DaggerObjectGraph(
-          base, linker, plugin, staticInjections, injectableTypes, baseBindings.setBindings);
+          base, linker, plugin, injectableTypes, baseBindings.setBindings);
     }
 
     @Override public ObjectGraph plus(Object... modules) {
@@ -204,17 +188,6 @@
       return makeGraph(this, plugin, modules);
     }
 
-    private void linkStaticInjections() {
-      for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
-        StaticInjection staticInjection = entry.getValue();
-        if (staticInjection == null) {
-          staticInjection = plugin.getStaticInjection(entry.getKey());
-          entry.setValue(staticInjection);
-        }
-        staticInjection.attach(linker);
-      }
-    }
-
     private void linkInjectableTypes() {
       for (Map.Entry<String, Class<?>> entry : injectableTypes.entrySet()) {
         linker.requestBinding(entry.getKey(), entry.getValue(), entry.getValue().getClassLoader(),
@@ -239,29 +212,11 @@
         if ((bindings = linker.fullyLinkedBindings()) != null) {
           return bindings;
         }
-        linkStaticInjections();
         linkInjectableTypes();
         return linker.linkAll(); // Linker.linkAll() implicitly does Linker.linkRequested().
       }
     }
 
-    @Override public void injectStatics() {
-      // We call linkStaticInjections() twice on purpose. The first time through
-      // we request all of the bindings we need. The linker returns null for
-      // bindings it doesn't have. Then we ask the linker to link all of those
-      // requested bindings. Finally we call linkStaticInjections() again: this
-      // time the linker won't return null because everything has been linked.
-      synchronized (linker) {
-        linkStaticInjections();
-        linker.linkRequested();
-        linkStaticInjections();
-      }
-
-      for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
-        entry.getValue().inject();
-      }
-    }
-
     @Override public <T> T get(Class<T> type) {
       String key = Keys.get(type);
       String injectableTypeKey = type.isInterface() ? key : Keys.getMembersKey(type);
/Fim/
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index 2986ad6..e7f7dd3 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -23,18 +23,16 @@
 public abstract class ModuleAdapter<T> {
   public final Class<T> moduleClass;
   public final String[] injectableTypes;
-  public final Class<?>[] staticInjections;
   public final boolean overrides;
   public final Class<?>[] includes;
   public final boolean complete;
   public final boolean library;
 
   protected ModuleAdapter(Class<T> moduleClass, String[] injectableTypes,
-      Class<?>[] staticInjections, boolean overrides, Class<?>[] includes, boolean complete,
+      boolean overrides, Class<?>[] includes, boolean complete,
       boolean library) {
     this.moduleClass = moduleClass;
     this.injectableTypes = injectableTypes;
-    this.staticInjections = staticInjections;
     this.overrides = overrides;
     this.includes = includes;
     this.complete = complete;
/Fim/
/Fim/
diff --git a/core/src/test/java/dagger/LazyInjectionTest.java b/core/src/test/java/dagger/LazyInjectionTest.java
index 849a431..ee6f6f6 100644
--- a/core/src/test/java/dagger/LazyInjectionTest.java
+++ b/core/src/test/java/dagger/LazyInjectionTest.java
@@ -79,22 +79,6 @@
     }
   }
 
-  @Test public void getLazyDoesNotCauseStaticsToBeLoaded() {
-    @Module(staticInjections = LazyInjectStatics.class)
-    class TestModule {
-    }
-
-    ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    assertThat(LazyInjectStaticsLoaded).isFalse();
-  }
-
-  private static boolean LazyInjectStaticsLoaded = false;
-  static class LazyInjectStatics {
-    static {
-      LazyInjectStaticsLoaded = true;
-    }
-  }
-
   @Test public void lazyInjectionRequiresProvidesMethod() {
     class TestEntryPoint {
       @Inject String injected;
/Fim/
diff --git a/core/src/test/java/dagger/ModuleTest.java b/core/src/test/java/dagger/ModuleTest.java
index ffe818a..19ec9eb 100644
--- a/core/src/test/java/dagger/ModuleTest.java
+++ b/core/src/test/java/dagger/ModuleTest.java
@@ -54,24 +54,6 @@
     @Inject static String s;
   }
 
-  @Module(staticInjections = TestStaticInjection.class)
-  static class ModuleWithStaticInjection {
-  }
-
-  @Test public void childModuleWithStaticInjection() {
-    @Module(includes = ModuleWithStaticInjection.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    TestStaticInjection.s = null;
-    objectGraph.injectStatics();
-    assertThat(TestStaticInjection.s).isEqualTo("injected");
-  }
-
   @Module
   static class ModuleWithBinding {
     @Provides String provideString() {
/Fim/
diff --git a/core/src/test/java/dagger/internal/TestingModuleAdapter.java b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
index b5d54f0..188b6ee 100644
--- a/core/src/test/java/dagger/internal/TestingModuleAdapter.java
+++ b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
@@ -34,7 +34,6 @@
     super(
         moduleClass,
         injectableTypesToKeys(annotation.injects()),
-        annotation.staticInjections(),
         annotation.overrides(),
         annotation.includes(),
         annotation.complete(),
/Fim/
diff --git a/website/index.html b/website/index.html
index 815e9be..2e0b696 100644
--- a/website/index.html
+++ b/website/index.html
@@ -253,25 +253,6 @@
 
             <p>Dependencies may not have multiple qualifier annotations.</p>
 
-            <h4>Static Injection</h4>
-
-            <p><span class="label label-important">Warning:</span> This feature should be used sparingly because static dependencies are difficult to test and reuse.</p>
-
-            <p>Dagger can inject static fields. Classes that declare static fields with <code>@Inject</code> annotations must be listed as <code>staticInjections</code> in a module annotation.</p>
-
-            <pre class="prettyprint">@Module(
-    staticInjections = LegacyCoffeeUtils.class
-)
-class LegacyModule {
-}</pre>
-
-            <p>Use <code>ObjectGraph.injectStatics()</code> to populate these static fields with their injected values:</p>
-
-            <pre class="prettyprint">ObjectGraph objectGraph = ObjectGraph.create(new LegacyModule());
-objectGraph.injectStatics();</pre>
-
-            <p><span class="label">Note:</span> <em>Static injection only operates for modules in the immediate graph. If you call <code>injectStatics()</code> on a graph created from a call to <code>plus()</code>, static injections on modules in the extended graph will not be performed.</em></p>
-
             <h4>Compile-time Validation</h4>
 
             <p>Dagger includes an <a href="http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html">annotation processor</a> that validates modules and injections. This processor is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is missing a binding for <code>Executor</code>:</p>
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
index fe81458..5724447 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
@@ -19,7 +19,6 @@
 import dagger.internal.Binding;
 import dagger.internal.Loader;
 import dagger.internal.ModuleAdapter;
-import dagger.internal.StaticInjection;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.TypeElement;
@@ -137,8 +136,4 @@
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<T> moduleClass) {
     throw new UnsupportedOperationException();
   }
-
-  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    throw new UnsupportedOperationException();
-  }
 }
/Fim/
/Fim/
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
index a9fb260..ce96078 100644
--- a/core/src/main/java/dagger/internal/FailoverLoader.java
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -18,11 +18,9 @@
 
 
 import dagger.internal.loaders.ReflectiveAtInjectBinding;
-import dagger.internal.loaders.ReflectiveStaticInjection;
 
 import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
 import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
-import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
 
 /**
  * Handles loading/finding of modules, injection bindings, and static injections by use of a
@@ -73,13 +71,4 @@
     }
     return ReflectiveAtInjectBinding.create(type, mustHaveInjections);
   }
-
-  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    StaticInjection result = instantiate(
-          injectedClass.getName().concat(STATIC_INJECTION_SUFFIX), injectedClass.getClassLoader());
-    if (result != null) {
-      return result;
-    }
-    return ReflectiveStaticInjection.create(injectedClass);
-  }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Loader.java b/core/src/main/java/dagger/internal/Loader.java
index 35b5e67..d656357 100644
--- a/core/src/main/java/dagger/internal/Loader.java
+++ b/core/src/main/java/dagger/internal/Loader.java
@@ -54,11 +54,6 @@
   public abstract <T> ModuleAdapter<T> getModuleAdapter(Class<T> moduleClass);
 
   /**
-   * Returns the static injection for {@code injectedClass}.
-   */
-  public abstract StaticInjection getStaticInjection(Class<?> injectedClass);
-
-  /**
    * Loads a class from a {@code ClassLoader}-specific cache if it's already there, or
    * loads it from the given {@code ClassLoader} and caching it for future requests.  Failures
    * to load are also cached using the Void.class type.  A null {@code ClassLoader} is assumed
@@ -90,4 +85,4 @@
     }
   }
 
-}
\ No newline at end of file
+}
/Fim/
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
index 72a825a..2a85062 100644
--- a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
+++ b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
@@ -24,7 +24,6 @@
   private static final String SEPARATOR = "$$";
   public static final String INJECT_ADAPTER_SUFFIX = SEPARATOR + "InjectAdapter";
   public static final String MODULE_ADAPTER_SUFFIX = SEPARATOR + "ModuleAdapter";
-  public static final String STATIC_INJECTION_SUFFIX = SEPARATOR + "StaticInjection";
 
   private GeneratedAdapters() { }
 }
/Fim/
/Fim/
diff --git a/core/src/test/java/dagger/internal/TestingLoader.java b/core/src/test/java/dagger/internal/TestingLoader.java
index b364cde..9ac50c9 100644
--- a/core/src/test/java/dagger/internal/TestingLoader.java
+++ b/core/src/test/java/dagger/internal/TestingLoader.java
@@ -18,7 +18,6 @@
 
 
 import dagger.internal.loaders.ReflectiveAtInjectBinding;
-import dagger.internal.loaders.ReflectiveStaticInjection;
 
 /**
  * A test-only loader that merely uses reflection to test internals.
@@ -43,8 +42,4 @@
           String.format("Could not find %s needed for binding %s", className, key), e);
     }
   }
-
-  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    return ReflectiveStaticInjection.create(injectedClass);
-  }
 }
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 942afe3..e1bdfb1 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.3-SNAPSHOT</version>
+    <version>1.3.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index c61aeb7..1b24640 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.3-SNAPSHOT</version>
+    <version>1.3.0-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 9b239b0..ff785ab 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.3-SNAPSHOT</version>
+    <version>1.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 0cc0591..f2eb769 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.3-SNAPSHOT</version>
+    <version>1.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index a0fe83b..b2376a2 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.2.3-SNAPSHOT</version>
+    <version>1.3.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 54ba98e..767bce3 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.2.3-SNAPSHOT</version>
+    <version>1.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index c4706b5..a65dd3f 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.2.3-SNAPSHOT</version>
+  <version>1.3.0-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
/Fim/
diff --git a/core/src/main/java/dagger/internal/Binding.java b/core/src/main/java/dagger/internal/Binding.java
index 893dd95..7fb062d 100644
--- a/core/src/main/java/dagger/internal/Binding.java
+++ b/core/src/main/java/dagger/internal/Binding.java
@@ -159,10 +159,5 @@
       super(error);
       this.type = type;
     }
-
-    public InvalidBindingException(String type, String error, Throwable cause) {
-      super("Binding for " + type + " was invalid: " + error, cause);
-      this.type = type;
-    }
   }
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 2dc3cb4..6cd8ed8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -238,6 +238,15 @@
     boolean complete = (Boolean) module.get("complete");
     boolean library = (Boolean) module.get("library");
 
+    List<Object> duplicateInjects = extractDuplicates(injects);
+    if (!duplicateInjects.isEmpty()) {
+      error("'injects' list contains duplicate entries: " + duplicateInjects, type);
+    }
+    List<Object> duplicateIncludes = extractDuplicates(includes);
+    if (!duplicateIncludes.isEmpty()) {
+      error("'includes' list contains duplicate entries: " + duplicateIncludes, type);
+    }
+
     ClassName moduleClassName = ClassName.get(type);
     ClassName adapterClassName = Util.adapterName(moduleClassName, MODULE_ADAPTER_SUFFIX);
 
@@ -328,6 +337,15 @@
         .build();
   }
 
+  private static List<Object> extractDuplicates(Object[] items) {
+    List<Object> itemsList = Arrays.asList(items);
+    List<Object> duplicateItems = new ArrayList<Object>(itemsList);
+    for (Object item : new LinkedHashSet<Object>(itemsList)) {
+      duplicateItems.remove(item); // Not using removeAll since we only want one element removed.
+    }
+    return duplicateItems;
+  }
+
   private CodeBlock injectsInitializer(Object[] injects) {
     CodeBlock.Builder result = CodeBlock.builder()
         .add("{ ");
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
index 657ddaa..351388c 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
@@ -245,7 +245,6 @@
         .generatesSources(expectedModuleAdapter, expectedInjectAdapterA, expectedInjectAdapterB);
   }
 
-
   @Test public void providesHasParameterNamedModule() {
     JavaFileObject a = JavaFileObjects.forSourceString("A", Joiner.on("\n").join(
         "import javax.inject.Inject;",
@@ -265,4 +264,38 @@
         .compilesWithoutError();
   }
 
+  @Test public void duplicateInjectsFails() {
+    JavaFileObject module = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "class A {}",
+        "@Module(injects = { A.class, A.class })",
+        "class BModule { }"));
+
+    ASSERT.about(javaSource())
+        .that(module)
+        .processedWith(daggerProcessors())
+        .failsToCompile()
+        .withErrorContaining("'injects' list contains duplicate entries: [A]")
+        .in(module).onLine(6);
+  }
+
+  @Test public void duplicateIncludesFails() {
+    JavaFileObject module = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "@Module",
+        "class AModule {}",
+        "@Module(includes = { AModule.class, AModule.class })",
+        "class BModule { }"));
+
+    ASSERT.about(javaSource())
+        .that(module)
+        .processedWith(daggerProcessors())
+        .failsToCompile()
+        .withErrorContaining("'includes' list contains duplicate entries: [AModule]")
+        .in(module).onLine(7);
+  }
 }
/Fim/
diff --git a/compiler/src/it/qualifiers-on-invalid-elements-errors/src/main/java/test/TestApp.java b/compiler/src/it/qualifiers-on-invalid-elements-errors/src/main/java/test/TestApp.java
index b423221..ae7caf1 100644
--- a/compiler/src/it/qualifiers-on-invalid-elements-errors/src/main/java/test/TestApp.java
+++ b/compiler/src/it/qualifiers-on-invalid-elements-errors/src/main/java/test/TestApp.java
@@ -29,7 +29,7 @@
   @MyQualifier
   static class TestClass1 {
     
-    @MyQualifier // qualfier on non-injectable constructor
+    @MyQualifier // qualifier on non-injectable constructor
     public TestClass1(String constructorParam) {}
   }
   
/Fim/
diff --git a/compiler/src/it/qualifiers-on-invalid-elements-warnings/src/main/java/test/TestApp.java b/compiler/src/it/qualifiers-on-invalid-elements-warnings/src/main/java/test/TestApp.java
index 4b2c746..83ffa30 100644
--- a/compiler/src/it/qualifiers-on-invalid-elements-warnings/src/main/java/test/TestApp.java
+++ b/compiler/src/it/qualifiers-on-invalid-elements-warnings/src/main/java/test/TestApp.java
@@ -41,7 +41,7 @@
     @MyQualifier 
     int fieldWithWarningSuppressed2;
     
-    // qualfier on non-injectable constructor parameter
+    // qualifier on non-injectable constructor parameter
     public TestClass(@MyQualifier String constructorParam) {}
     
     @MyQualifier 
/Fim/
diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
index 53601b2..a399279 100755
--- a/.buildscript/deploy_snapshot.sh
+++ b/.buildscript/deploy_snapshot.sh
@@ -21,6 +21,6 @@
   echo "Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'."
 else
   echo "Deploying snapshot..."
-  mvn clean source:jar javadoc:jar deploy --settings=".buildscript/settings.xml" -Dmaven.test.skip=true
+  mvn clean source:jar javadoc:jar deploy --settings=".buildscript/settings.xml" -Dmaven.test.skip=true -Dinvoker.skip=true
   echo "Snapshot deployed!"
 fi
/Fim/
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 3545ffb..385428d 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.3.0-SNAPSHOT</version>
+    <version>1.2.3-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
index 5724447..fe81458 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisLoader.java
@@ -19,6 +19,7 @@
 import dagger.internal.Binding;
 import dagger.internal.Loader;
 import dagger.internal.ModuleAdapter;
+import dagger.internal.StaticInjection;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.TypeElement;
@@ -136,4 +137,8 @@
   @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<T> moduleClass) {
     throw new UnsupportedOperationException();
   }
+
+  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
+    throw new UnsupportedOperationException();
+  }
 }
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisStaticInjection.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisStaticInjection.java
new file mode 100644
index 0000000..dee4376
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisStaticInjection.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import dagger.internal.Linker;
+import dagger.internal.StaticInjection;
+import javax.inject.Inject;
+import javax.lang.model.element.Element;
+
+import static dagger.internal.codegen.Util.isStatic;
+
+public final class GraphAnalysisStaticInjection extends StaticInjection {
+
+  private final Element enclosingClass;
+
+  public GraphAnalysisStaticInjection(Element enclosingClass) {
+    this.enclosingClass = enclosingClass;
+  }
+
+  @Override public void attach(Linker linker) {
+    for (Element enclosedElement : enclosingClass.getEnclosedElements()) {
+      if (enclosedElement.getKind().isField() && isStatic(enclosedElement)) {
+        Inject injectAnnotation = enclosedElement.getAnnotation(Inject.class);
+        if (injectAnnotation != null) {
+          String key = GeneratorKeys.get(enclosedElement.asType());
+          linker.requestBinding(key, enclosingClass.toString(),
+              getClass().getClassLoader());
+        }
+      }
+    }
+  }
+
+  @Override public void inject() {
+    throw new UnsupportedOperationException();
+  }
+}
\ No newline at end of file
/Fim/
diff --git a/core/pom.xml b/core/pom.xml
index 2321d59..18a15ce 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.3.0-SNAPSHOT</version>
+    <version>1.2.3-SNAPSHOT</version>
     <relativePath>../pom.xml</relativePath>
   </parent>
 
@@ -48,6 +48,24 @@
   <build>
     <plugins>
       <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>1.8</version><!-- 1.9+ requires JDK7 -->
+        <executions>
+          <execution>
+            <id>sniff-api</id>
+            <goals><goal>check</goal></goals>
+          </execution>
+        </executions>
+        <configuration>
+          <signature>
+            <groupId>org.codehaus.mojo.signature</groupId>
+            <artifactId>java15</artifactId>
+            <version>1.0</version>
+          </signature>
+        </configuration>
+      </plugin>
+      <plugin>
         <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
           <excludePackageNames>dagger.internal:dagger.internal.*</excludePackageNames>
/Fim/
diff --git a/core/src/main/java/dagger/internal/ArrayQueue.java b/core/src/main/java/dagger/internal/ArrayQueue.java
new file mode 100644
index 0000000..690b6d9
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ArrayQueue.java
@@ -0,0 +1,607 @@
+/*
+ * Written by Josh Bloch of Google Inc. and released to the public domain,
+ * as explained at http://creativecommons.org/publicdomain/zero/1.0/.
+ *
+ * Adapted from https://android.googlesource.com/platform/libcore/+
+ *     android-4.2.2_r1/luni/src/main/java/java/util/ArrayDeque.java
+ */
+package dagger.internal;
+
+import java.lang.reflect.Array;
+import java.util.AbstractCollection;
+import java.util.Collection;
+import java.util.ConcurrentModificationException;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.Queue;
+
+/**
+ * Resizable-array implementation of the {@link Queue} interface.  Array
+ * queues have no capacity restrictions; they grow as necessary to support
+ * usage.  They are not thread-safe; in the absence of external
+ * synchronization, they do not support concurrent access by multiple threads.
+ * Null elements are prohibited.  This class is likely to be faster than
+ * {@link LinkedList} when used as a queue.
+ *
+ * <p>Most <tt>ArrayBackedQueue</tt> operations run in amortized constant time.
+ * Exceptions include {@link #remove(Object) remove}, {@link
+ * #removeFirstOccurrence removeFirstOccurrence}, {@link #contains contains},
+ * {@link #iterator iterator.remove()}, and the bulk operations, all of which
+ * run in linear time.
+ *
+ * <p>The iterators returned by this class's <tt>iterator</tt> method are
+ * <i>fail-fast</i>: If the queue is modified at any time after the iterator
+ * is created, in any way except through the iterator's own <tt>remove</tt>
+ * method, the iterator will generally throw a {@link
+ * ConcurrentModificationException}.  Thus, in the face of concurrent
+ * modification, the iterator fails quickly and cleanly, rather than risking
+ * arbitrary, non-deterministic behavior at an undetermined time in the
+ * future.
+ *
+ * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed
+ * as it is, generally speaking, impossible to make any hard guarantees in the
+ * presence of unsynchronized concurrent modification.  Fail-fast iterators
+ * throw <tt>ConcurrentModificationException</tt> on a best-effort basis.
+ * Therefore, it would be wrong to write a program that depended on this
+ * exception for its correctness: <i>the fail-fast behavior of iterators
+ * should be used only to detect bugs.</i>
+ *
+ * <p>This class and its iterator implement all of the
+ * <em>optional</em> methods of the {@link Collection} and {@link
+ * Iterator} interfaces.
+ *
+ * @author  Josh Bloch and Doug Lea
+ * @param <E> the type of elements held in this collection
+ */
+public class ArrayQueue<E> extends AbstractCollection<E>
+                           implements Queue<E>, Cloneable, java.io.Serializable {
+    /**
+     * The array in which the elements of the queue are stored.
+     * The capacity of the queue is the length of this array, which is
+     * always a power of two. The array is never allowed to become
+     * full, except transiently within an addX method where it is
+     * resized (see doubleCapacity) immediately upon becoming full,
+     * thus avoiding head and tail wrapping around to equal each
+     * other.  We also guarantee that all array cells not holding
+     * queue elements are always null.
+     */
+    private transient Object[] elements;
+
+    /**
+     * The index of the element at the head of the queue (which is the
+     * element that would be removed by remove() or pop()); or an
+     * arbitrary number equal to tail if the queue is empty.
+     */
+    private transient int head;
+
+    /**
+     * The index at which the next element would be added to the tail
+     * of the queue (via addLast(E), add(E), or push(E)).
+     */
+    private transient int tail;
+
+    /**
+     * The minimum capacity that we'll use for a newly created queue.
+     * Must be a power of 2.
+     */
+    private static final int MIN_INITIAL_CAPACITY = 8;
+
+    // ******  Array allocation and resizing utilities ******
+
+    /**
+     * Allocate empty array to hold the given number of elements.
+     *
+     * @param numElements  the number of elements to hold
+     */
+    private void allocateElements(int numElements) {
+        int initialCapacity = MIN_INITIAL_CAPACITY;
+        // Find the best power of two to hold elements.
+        // Tests "<=" because arrays aren't kept full.
+        if (numElements >= initialCapacity) {
+            initialCapacity = numElements;
+            initialCapacity |= (initialCapacity >>>  1);
+            initialCapacity |= (initialCapacity >>>  2);
+            initialCapacity |= (initialCapacity >>>  4);
+            initialCapacity |= (initialCapacity >>>  8);
+            initialCapacity |= (initialCapacity >>> 16);
+            initialCapacity++;
+
+            if (initialCapacity < 0)   // Too many elements, must back off
+                initialCapacity >>>= 1; // Good luck allocating 2 ^ 30 elements
+        }
+        elements = new Object[initialCapacity];
+    }
+
+    /**
+     * Double the capacity of this queue.  Call only when full, i.e.,
+     * when head and tail have wrapped around to become equal.
+     */
+    private void doubleCapacity() {
+        // assert head == tail;
+        int p = head;
+        int n = elements.length;
+        int r = n - p; // number of elements to the right of p
+        int newCapacity = n << 1;
+        if (newCapacity < 0)
+            throw new IllegalStateException("Sorry, queue too big");
+        Object[] a = new Object[newCapacity];
+        System.arraycopy(elements, p, a, 0, r);
+        System.arraycopy(elements, 0, a, r, p);
+        elements = a;
+        head = 0;
+        tail = n;
+    }
+
+    /**
+     * Constructs an empty array queue with an initial capacity
+     * sufficient to hold 16 elements.
+     */
+    public ArrayQueue() {
+        elements = new Object[16];
+    }
+
+    /**
+     * Constructs an empty array queue with an initial capacity
+     * sufficient to hold the specified number of elements.
+     *
+     * @param numElements  lower bound on initial capacity of the queue
+     */
+    public ArrayQueue(int numElements) {
+        allocateElements(numElements);
+    }
+
+    /**
+     * Constructs a queue containing the elements of the specified
+     * collection, in the order they are returned by the collection's
+     * iterator.  (The first element returned by the collection's
+     * iterator becomes the first element, or <i>front</i> of the
+     * queue.)
+     *
+     * @param c the collection whose elements are to be placed into the queue
+     * @throws NullPointerException if the specified collection is null
+     */
+    public ArrayQueue(Collection<? extends E> c) {
+        allocateElements(c.size());
+        addAll(c);
+    }
+
+    /**
+     * Inserts the specified element at the end of this queue.
+     *
+     * <p>This method is equivalent to {@link #offer}.
+     *
+     * @param e the element to add
+     * @return <tt>true</tt> (as specified by {@link Collection#add})
+     * @throws NullPointerException if the specified element is null
+     */
+    @Override
+    public boolean add(E e) {
+        if (e == null)
+            throw new NullPointerException("e == null");
+        elements[tail] = e;
+        if ((tail = (tail + 1) & (elements.length - 1)) == head)
+            doubleCapacity();
+        return true;
+    }
+
+    /**
+     * Inserts the specified element at the end of this queue.
+     *
+     * @param e the element to add
+     * @return <tt>true</tt> (as specified by {@link Queue#offer})
+     * @throws NullPointerException if the specified element is null
+     */
+    @Override
+    public boolean offer(E e) {
+        return add(e);
+    }
+
+    /**
+     * Retrieves and removes the head of the queue represented by this queue.
+     *
+     * This method differs from {@link #poll poll} only in that it throws an
+     * exception if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue
+     * @throws NoSuchElementException {@inheritDoc}
+     */
+    @Override
+    public E remove() {
+        E x = poll();
+        if (x == null)
+            throw new NoSuchElementException();
+        return x;
+    }
+
+    /**
+     * Retrieves and removes the head of the queue represented by this queue
+     * (in other words, the first element of this queue), or returns
+     * <tt>null</tt> if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue, or
+     *         <tt>null</tt> if this queue is empty
+     */
+    @Override
+    public E poll() {
+        int h = head;
+        @SuppressWarnings("unchecked") E result = (E) elements[h];
+        // Element is null if queue empty
+        if (result == null)
+            return null;
+        elements[h] = null;     // Must null out slot
+        head = (h + 1) & (elements.length - 1);
+        return result;
+    }
+
+    /**
+     * Retrieves, but does not remove, the head of the queue represented by
+     * this queue.  This method differs from {@link #peek peek} only in
+     * that it throws an exception if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue
+     * @throws NoSuchElementException {@inheritDoc}
+     */
+    @Override
+    public E element() {
+        @SuppressWarnings("unchecked") E result = (E) elements[head];
+        if (result == null)
+            throw new NoSuchElementException();
+        return result;
+    }
+
+    /**
+     * Retrieves, but does not remove, the head of the queue represented by
+     * this queue, or returns <tt>null</tt> if this queue is empty.
+     *
+     * @return the head of the queue represented by this queue, or
+     *         <tt>null</tt> if this queue is empty
+     */
+    @Override
+    public E peek() {
+        @SuppressWarnings("unchecked") E result = (E) elements[head];
+        // elements[head] is null if queue empty
+        return result;
+    }
+
+    /**
+     * Removes the element at the specified position in the elements array,
+     * adjusting head and tail as necessary.  This can result in motion of
+     * elements backwards or forwards in the array.
+     *
+     * <p>This method is called delete rather than remove to emphasize
+     * that its semantics differ from those of {@link List#remove(int)}.
+     *
+     * @return true if elements moved backwards
+     */
+    private boolean delete(int i) {
+        //checkInvariants();
+        final Object[] elements = this.elements;
+        final int mask = elements.length - 1;
+        final int h = head;
+        final int t = tail;
+        final int front = (i - h) & mask;
+        final int back  = (t - i) & mask;
+
+        // Invariant: head <= i < tail mod circularity
+        if (front >= ((t - h) & mask))
+            throw new ConcurrentModificationException();
+
+        // Optimize for least element motion
+        if (front < back) {
+            if (h <= i) {
+                System.arraycopy(elements, h, elements, h + 1, front);
+            } else { // Wrap around
+                System.arraycopy(elements, 0, elements, 1, i);
+                elements[0] = elements[mask];
+                System.arraycopy(elements, h, elements, h + 1, mask - h);
+            }
+            elements[h] = null;
+            head = (h + 1) & mask;
+            return false;
+        } else {
+            if (i < t) { // Copy the null tail as well
+                System.arraycopy(elements, i + 1, elements, i, back);
+                tail = t - 1;
+            } else { // Wrap around
+                System.arraycopy(elements, i + 1, elements, i, mask - i);
+                elements[mask] = elements[0];
+                System.arraycopy(elements, 1, elements, 0, t);
+                tail = (t - 1) & mask;
+            }
+            return true;
+        }
+    }
+
+    // *** Collection Methods ***
+
+    /**
+     * Returns the number of elements in this queue.
+     *
+     * @return the number of elements in this queue
+     */
+    @Override
+    public int size() {
+        return (tail - head) & (elements.length - 1);
+    }
+
+    /**
+     * Returns <tt>true</tt> if this queue contains no elements.
+     *
+     * @return <tt>true</tt> if this queue contains no elements
+     */
+    @Override
+    public boolean isEmpty() {
+        return head == tail;
+    }
+
+    /**
+     * Returns an iterator over the elements in this queue.  The elements
+     * will be ordered from first (head) to last (tail).  This is the same
+     * order that elements would be queueued (via successive calls to
+     * {@link #remove} or popped (via successive calls to {@link #pop}).
+     *
+     * @return an iterator over the elements in this queue
+     */
+    @Override
+    public Iterator<E> iterator() {
+        return new QueueIterator();
+    }
+
+
+    private class QueueIterator implements Iterator<E> {
+        /**
+         * Index of element to be returned by subsequent call to next.
+         */
+        private int cursor = head;
+
+        /**
+         * Tail recorded at construction (also in remove), to stop
+         * iterator and also to check for comodification.
+         */
+        private int fence = tail;
+
+        /**
+         * Index of element returned by most recent call to next.
+         * Reset to -1 if element is deleted by a call to remove.
+         */
+        private int lastRet = -1;
+
+        @Override
+        public boolean hasNext() {
+            return cursor != fence;
+        }
+
+        @Override
+        public E next() {
+            if (cursor == fence)
+                throw new NoSuchElementException();
+            @SuppressWarnings("unchecked") E result = (E) elements[cursor];
+            // This check doesn't catch all possible comodifications,
+            // but does catch the ones that corrupt traversal
+            if (tail != fence || result == null)
+                throw new ConcurrentModificationException();
+            lastRet = cursor;
+            cursor = (cursor + 1) & (elements.length - 1);
+            return result;
+        }
+
+        @Override
+        public void remove() {
+            if (lastRet < 0)
+                throw new IllegalStateException();
+            if (delete(lastRet)) { // if left-shifted, undo increment in next()
+                cursor = (cursor - 1) & (elements.length - 1);
+                fence = tail;
+            }
+            lastRet = -1;
+        }
+    }
+
+    /**
+     * Returns <tt>true</tt> if this queue contains the specified element.
+     * More formally, returns <tt>true</tt> if and only if this queue contains
+     * at least one element <tt>e</tt> such that <tt>o.equals(e)</tt>.
+     *
+     * @param o object to be checked for containment in this queue
+     * @return <tt>true</tt> if this queue contains the specified element
+     */
+    @Override
+    public boolean contains(Object o) {
+        if (o == null)
+            return false;
+        int mask = elements.length - 1;
+        int i = head;
+        Object x;
+        while ((x = elements[i]) != null) {
+            if (o.equals(x))
+                return true;
+            i = (i + 1) & mask;
+        }
+        return false;
+    }
+
+    /**
+     * Removes a single instance of the specified element from this queue.
+     * If the queue does not contain the element, it is unchanged.
+     * More formally, removes the first element <tt>e</tt> such that
+     * <tt>o.equals(e)</tt> (if such an element exists).
+     * Returns <tt>true</tt> if this queue contained the specified element
+     * (or equivalently, if this queue changed as a result of the call).
+     *
+     * @param o element to be removed from this queue, if present
+     * @return <tt>true</tt> if this queue contained the specified element
+     */
+    @Override
+    public boolean remove(Object o) {
+        if (o == null)
+            return false;
+        int mask = elements.length - 1;
+        int i = head;
+        Object x;
+        while ((x = elements[i]) != null) {
+            if (o.equals(x)) {
+                delete(i);
+                return true;
+            }
+            i = (i + 1) & mask;
+        }
+        return false;
+    }
+
+    /**
+     * Removes all of the elements from this queue.
+     * The queue will be empty after this call returns.
+     */
+    @Override
+    public void clear() {
+        int h = head;
+        int t = tail;
+        if (h != t) { // clear all cells
+            head = tail = 0;
+            int i = h;
+            int mask = elements.length - 1;
+            do {
+                elements[i] = null;
+                i = (i + 1) & mask;
+            } while (i != t);
+        }
+    }
+
+    /**
+     * Returns an array containing all of the elements in this queue
+     * in proper sequence (from first to last element).
+     *
+     * <p>The returned array will be "safe" in that no references to it are
+     * maintained by this queue.  (In other words, this method must allocate
+     * a new array).  The caller is thus free to modify the returned array.
+     *
+     * <p>This method acts as bridge between array-based and collection-based
+     * APIs.
+     *
+     * @return an array containing all of the elements in this queue
+     */
+    @Override
+    public Object[] toArray() {
+        return toArray(new Object[size()]);
+    }
+
+    /**
+     * Returns an array containing all of the elements in this queue in
+     * proper sequence (from first to last element); the runtime type of the
+     * returned array is that of the specified array.  If the queue fits in
+     * the specified array, it is returned therein.  Otherwise, a new array
+     * is allocated with the runtime type of the specified array and the
+     * size of this queue.
+     *
+     * <p>If this queue fits in the specified array with room to spare
+     * (i.e., the array has more elements than this queue), the element in
+     * the array immediately following the end of the queue is set to
+     * <tt>null</tt>.
+     *
+     * <p>Like the {@link #toArray()} method, this method acts as bridge between
+     * array-based and collection-based APIs.  Further, this method allows
+     * precise control over the runtime type of the output array, and may,
+     * under certain circumstances, be used to save allocation costs.
+     *
+     * <p>Suppose <tt>x</tt> is a queue known to contain only strings.
+     * The following code can be used to dump the queue into a newly
+     * allocated array of <tt>String</tt>:
+     *
+     *  <pre> {@code String[] y = x.toArray(new String[0]);}</pre>
+     *
+     * Note that <tt>toArray(new Object[0])</tt> is identical in function to
+     * <tt>toArray()</tt>.
+     *
+     * @param a the array into which the elements of the queue are to
+     *          be stored, if it is big enough; otherwise, a new array of the
+     *          same runtime type is allocated for this purpose
+     * @return an array containing all of the elements in this queue
+     * @throws ArrayStoreException if the runtime type of the specified array
+     *         is not a supertype of the runtime type of every element in
+     *         this queue
+     * @throws NullPointerException if the specified array is null
+     */
+    @Override
+    public <T> T[] toArray(T[] a) {
+        int size = size();
+        if (a.length < size)
+            a = (T[]) java.lang.reflect.Array.newInstance(
+                    a.getClass().getComponentType(), size);
+        if (head < tail) {
+            System.arraycopy(elements, head, a, 0, size());
+        } else if (head > tail) {
+            int headPortionLen = elements.length - head;
+            System.arraycopy(elements, head, a, 0, headPortionLen);
+            System.arraycopy(elements, 0, a, headPortionLen, tail);
+        }
+        if (a.length > size)
+            a[size] = null;
+        return a;
+    }
+
+    // *** Object methods ***
+
+    /**
+     * Returns a copy of this queue.
+     *
+     * @return a copy of this queue
+     */
+    @Override
+    public ArrayQueue<E> clone() {
+        try {
+            ArrayQueue<E> result = (ArrayQueue<E>) super.clone();
+            E[] newElements = (E[]) Array.newInstance(elements.getClass().getComponentType(),
+                elements.length);
+            System.arraycopy(elements, 0, newElements, 0, elements.length);
+            result.elements = newElements;
+            return result;
+        } catch (CloneNotSupportedException e) {
+            throw new AssertionError();
+        }
+    }
+
+    /**
+     * Appease the serialization gods.
+     */
+    private static final long serialVersionUID = 2340985798034038923L;
+
+    /**
+     * Serialize this queue.
+     *
+     * @serialData The current size (<tt>int</tt>) of the queue,
+     * followed by all of its elements (each an object reference) in
+     * first-to-last order.
+     */
+    private void writeObject(java.io.ObjectOutputStream s)
+            throws java.io.IOException {
+        s.defaultWriteObject();
+
+        // Write out size
+        s.writeInt(size());
+
+        // Write out elements in order.
+        int mask = elements.length - 1;
+        for (int i = head; i != tail; i = (i + 1) & mask)
+            s.writeObject(elements[i]);
+    }
+
+    /**
+     * Deserialize this queue.
+     */
+    private void readObject(java.io.ObjectInputStream s)
+            throws java.io.IOException, ClassNotFoundException {
+        s.defaultReadObject();
+
+        // Read in size and allocate array
+        int size = s.readInt();
+        allocateElements(size);
+        head = 0;
+        tail = size;
+
+        // Read in all elements in the proper order.
+        for (int i = 0; i < size; i++)
+            elements[i] = s.readObject();
+    }
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
index ce96078..a9fb260 100644
--- a/core/src/main/java/dagger/internal/FailoverLoader.java
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -18,9 +18,11 @@
 
 
 import dagger.internal.loaders.ReflectiveAtInjectBinding;
+import dagger.internal.loaders.ReflectiveStaticInjection;
 
 import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
 import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
+import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
 
 /**
  * Handles loading/finding of modules, injection bindings, and static injections by use of a
@@ -71,4 +73,13 @@
     }
     return ReflectiveAtInjectBinding.create(type, mustHaveInjections);
   }
+
+  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
+    StaticInjection result = instantiate(
+          injectedClass.getName().concat(STATIC_INJECTION_SUFFIX), injectedClass.getClassLoader());
+    if (result != null) {
+      return result;
+    }
+    return ReflectiveStaticInjection.create(injectedClass);
+  }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index e88ffce..b5cf55e 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -16,13 +16,12 @@
 package dagger.internal;
 
 import dagger.internal.Binding.InvalidBindingException;
-import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Deque;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
 import java.util.Set;
 
 /**
@@ -39,7 +38,7 @@
   private final Linker base;
 
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
-  private final Deque<Binding<?>> toLink = new ArrayDeque<Binding<?>>();
+  private final Queue<Binding<?>> toLink = new ArrayQueue<Binding<?>>();
 
   /** True unless calls to requestBinding() were unable to satisfy the binding. */
   private boolean attachSuccess = true;
/Fim/
diff --git a/core/src/main/java/dagger/internal/Loader.java b/core/src/main/java/dagger/internal/Loader.java
index d656357..35b5e67 100644
--- a/core/src/main/java/dagger/internal/Loader.java
+++ b/core/src/main/java/dagger/internal/Loader.java
@@ -54,6 +54,11 @@
   public abstract <T> ModuleAdapter<T> getModuleAdapter(Class<T> moduleClass);
 
   /**
+   * Returns the static injection for {@code injectedClass}.
+   */
+  public abstract StaticInjection getStaticInjection(Class<?> injectedClass);
+
+  /**
    * Loads a class from a {@code ClassLoader}-specific cache if it's already there, or
    * loads it from the given {@code ClassLoader} and caching it for future requests.  Failures
    * to load are also cached using the Void.class type.  A null {@code ClassLoader} is assumed
@@ -85,4 +90,4 @@
     }
   }
 
-}
+}
\ No newline at end of file
/Fim/
diff --git a/core/src/main/java/dagger/internal/StaticInjection.java b/core/src/main/java/dagger/internal/StaticInjection.java
new file mode 100644
index 0000000..92a73a4
--- /dev/null
+++ b/core/src/main/java/dagger/internal/StaticInjection.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2012 Square Inc.
+ * Copyright (C) 2012 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+
+/**
+ * Injects the static fields of a class.
+ */
+public abstract class StaticInjection {
+
+  public abstract void attach(Linker linker);
+
+  public abstract void inject();
+
+}
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
index 2a85062..72a825a 100644
--- a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
+++ b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
@@ -24,6 +24,7 @@
   private static final String SEPARATOR = "$$";
   public static final String INJECT_ADAPTER_SUFFIX = SEPARATOR + "InjectAdapter";
   public static final String MODULE_ADAPTER_SUFFIX = SEPARATOR + "ModuleAdapter";
+  public static final String STATIC_INJECTION_SUFFIX = SEPARATOR + "StaticInjection";
 
   private GeneratedAdapters() { }
 }
/Fim/
diff --git a/core/src/main/java/dagger/internal/loaders/ReflectiveStaticInjection.java b/core/src/main/java/dagger/internal/loaders/ReflectiveStaticInjection.java
new file mode 100644
index 0000000..1150eed
--- /dev/null
+++ b/core/src/main/java/dagger/internal/loaders/ReflectiveStaticInjection.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.loaders;
+
+import dagger.internal.Binding;
+import dagger.internal.Keys;
+import dagger.internal.Linker;
+import dagger.internal.StaticInjection;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.List;
+import javax.inject.Inject;
+
+/**
+ * Uses reflection to inject the static fields of a class.
+ */
+public final class ReflectiveStaticInjection extends StaticInjection {
+  private final ClassLoader loader;
+  private final Field[] fields;
+  private Binding<?>[] bindings;
+
+  private ReflectiveStaticInjection(ClassLoader loader, Field[] fields) {
+    this.fields = fields;
+    this.loader = loader;
+  }
+
+  @Override public void attach(Linker linker) {
+    bindings = new Binding<?>[fields.length];
+    for (int i = 0; i < fields.length; i++) {
+      Field field = fields[i];
+      String key = Keys.get(field.getGenericType(), field.getAnnotations(), field);
+      bindings[i] = linker.requestBinding(key, field, loader);
+    }
+  }
+
+  @Override public void inject() {
+    try {
+      for (int f = 0; f < fields.length; f++) {
+        fields[f].set(null, bindings[f].get());
+      }
+    } catch (IllegalAccessException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  public static StaticInjection create(Class<?> injectedClass) {
+    List<Field> fields = new ArrayList<Field>();
+    for (Field field : injectedClass.getDeclaredFields()) {
+      if (Modifier.isStatic(field.getModifiers()) && field.isAnnotationPresent(Inject.class)) {
+        field.setAccessible(true);
+        fields.add(field);
+      }
+    }
+    if (fields.isEmpty()) {
+      throw new IllegalArgumentException("No static injections: " + injectedClass.getName());
+    }
+    return new ReflectiveStaticInjection(injectedClass.getClassLoader(),
+        fields.toArray(new Field[fields.size()]));
+  }
+}
\ No newline at end of file
/Fim/
diff --git a/core/src/test/java/dagger/internal/TestingLoader.java b/core/src/test/java/dagger/internal/TestingLoader.java
index 9ac50c9..b364cde 100644
--- a/core/src/test/java/dagger/internal/TestingLoader.java
+++ b/core/src/test/java/dagger/internal/TestingLoader.java
@@ -18,6 +18,7 @@
 
 
 import dagger.internal.loaders.ReflectiveAtInjectBinding;
+import dagger.internal.loaders.ReflectiveStaticInjection;
 
 /**
  * A test-only loader that merely uses reflection to test internals.
@@ -42,4 +43,8 @@
           String.format("Could not find %s needed for binding %s", className, key), e);
     }
   }
+
+  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
+    return ReflectiveStaticInjection.create(injectedClass);
+  }
 }
/Fim/
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index ff785ab..9b239b0 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.3.0-SNAPSHOT</version>
+    <version>1.2.3-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
/Fim/
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index f2eb769..0cc0591 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.3.0-SNAPSHOT</version>
+    <version>1.2.3-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
/Fim/
diff --git a/examples/pom.xml b/examples/pom.xml
index b2376a2..a0fe83b 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.squareup.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>1.3.0-SNAPSHOT</version>
+    <version>1.2.3-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.dagger.example</groupId>
/Fim/
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 767bce3..54ba98e 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.squareup.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>1.3.0-SNAPSHOT</version>
+    <version>1.2.3-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple</artifactId>
/Fim/
diff --git a/pom.xml b/pom.xml
index 855e4a3..cea95f3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.squareup.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>1.3.0-SNAPSHOT</version>
+  <version>1.2.3-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
/Fim/
diff --git a/pom.xml b/pom.xml
index cea95f3..4c1ee48 100644
--- a/pom.xml
+++ b/pom.xml
@@ -43,7 +43,7 @@
     <!-- Compilation -->
     <java.version>1.6</java.version>
     <javax.inject.version>1</javax.inject.version>
-    <javapoet.version>1.4.0</javapoet.version>
+    <javapoet.version>1.7.0</javapoet.version>
     <guava.version>19.0</guava.version>
 
     <!-- Test Dependencies -->
/Fim/
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
index 5248663..320ef87 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectAdapterProcessor.java
@@ -243,6 +243,9 @@
       List<Element> fields) throws IOException {
     String packageName = getPackage(type).getQualifiedName().toString();
     TypeMirror supertype = getApplicationSupertype(type);
+    if (supertype != null) {
+      supertype = processingEnv.getTypeUtils().erasure(supertype);
+    }
     ClassName injectedClassName = ClassName.get(type);
     ClassName adapterClassName = adapterName(injectedClassName, INJECT_ADAPTER_SUFFIX);
 
/Fim/
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/GenericInjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/GenericInjectAdapterGenerationTest.java
new file mode 100644
index 0000000..90e85c6
--- /dev/null
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/GenericInjectAdapterGenerationTest.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2013 Google Inc.
+ * Copyright (C) 2016 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.tests.integration.codegen;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
+@RunWith(JUnit4.class)
+public final class GenericInjectAdapterGenerationTest {
+
+  @Test public void basicInjectAdapter() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Basic", ""
+        + "import dagger.Module;\n"
+        + "import javax.inject.Inject;\n"
+        + "class Basic {\n"
+        + "  static class Simple {\n"
+        + "    @Inject Simple() { }\n"
+        + "  }\n"
+        + "  static class A<T> { }\n"
+        + "  static class B<T extends CharSequence> extends A<T> {\n"
+        + "    @Inject Simple simple;\n"
+        + "  }\n"
+        + "  static class C extends B<String> { \n"
+        + "    @Inject C() { }\n"
+        + "  }\n"
+        + "  @Module(injects = { C.class })\n"
+        + "  static class AModule { }\n"
+        + "}\n"
+    );
+
+    JavaFileObject expectedInjectAdapterC =
+        JavaFileObjects.forSourceString("Basic$B$$InjectAdapter", ""
+            + "import dagger.internal.Binding;\n"
+            + "import dagger.internal.Linker;\n"
+            + "import java.lang.Override;\n"
+            + "import java.lang.SuppressWarnings;\n"
+            + "import java.util.Set;\n"
+            + "public final class Basic$B$$InjectAdapter extends Binding<Basic.B> {\n"
+            + "  private Binding<Basic.Simple> simple;\n"
+            + "  private Binding<Basic.A> supertype;\n"
+            + "  public Basic$B$$InjectAdapter() {\n"
+            + "    super(\"Basic$B<T>\", \"members/Basic$B\", NOT_SINGLETON, Basic.B.class);\n"
+            + "  }\n"
+            + "  @Override\n"
+            + "  @SuppressWarnings(\"unchecked\")\n"
+            + "  public void attach(Linker linker) {\n"
+            + "    simple = (Binding<Basic.Simple>) linker.requestBinding(\"Basic$Simple\", Basic.B.class, getClass().getClassLoader());\n"
+            + "    supertype = (Binding<Basic.A>) linker.requestBinding(\"members/Basic$A\", Basic.B.class, getClass().getClassLoader(), false, true);\n"
+            + "  }\n"
+            + "  @Override\n"
+            + "  public void getDependencies(Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {\n"
+            + "    injectMembersBindings.add(simple);\n"
+            + "    injectMembersBindings.add(supertype);\n"
+            + "  }\n"
+            + "  @Override\n"
+            + "  public Basic.B get() {\n"
+            + "    Basic.B result = new Basic.B();\n"
+            + "    injectMembers(result);\n"
+            + "    return result;\n"
+            + "  }\n"
+            + "  @Override\n"
+            + "  public void injectMembers(Basic.B object) {\n"
+            + "    object.simple = simple.get();\n"
+            + "    supertype.injectMembers(object);\n"
+            + "  }\n"
+            + "}"
+        );
+
+    assertAbout(javaSource())
+        .that(sourceFile)
+        .processedWith(daggerProcessors())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expectedInjectAdapterC);
+  }
+}
/Fim/
diff --git a/website/index.html b/website/index.html
index 815e9be..30d6a6f 100644
--- a/website/index.html
+++ b/website/index.html
@@ -42,6 +42,10 @@
       <div class="container">
         <div class="row">
           <div class="span9">
+            <h3 id="dagger2">Deprecated  Please upgrade to Dagger 2</h3>
+            <p>Square's Dagger 1.x is deprecated in favor of <a href="https://github.com/google/dagger">Google's Dagger 2</a>.
+            Please see <a href="http://google.github.io/dagger/dagger-1-migration.html">the migration guide</a> for helpwith the upgrade.
+
             <h3 id="introduction">Introduction</h3>
 
             <p>The best classes in any application are the ones that do stuff: the <code>BarcodeDecoder</code>, the <code>KoopaPhysicsEngine</code>, and the <code>AudioStreamer</code>. These classes have dependencies; perhaps a <code>BarcodeCameraFinder</code>, <code>DefaultPhysicsEngine</code>, and an <code>HttpStreamer</code>.</p>
/Fim/
diff --git a/README.md b/README.md
index 2178773..0cdd8a6 100644
--- a/README.md
+++ b/README.md
@@ -8,7 +8,7 @@
 ---------------------------------------
 
 Square's Dagger 1.x is deprecated in favor of [Google's Dagger 2](https://github.com/google/dagger).
-Please see [the migration guide](http://google.github.io/dagger/dagger-1-migration.html) for help
+Please see [the migration guide](https://google.github.io/dagger/dagger-1-migration.html) for help
 with the upgrade.
 
 
/Fim/
diff --git a/website/index.html b/website/index.html
index 30d6a6f..0d45fda 100644
--- a/website/index.html
+++ b/website/index.html
@@ -44,7 +44,7 @@
           <div class="span9">
             <h3 id="dagger2">Deprecated  Please upgrade to Dagger 2</h3>
             <p>Square's Dagger 1.x is deprecated in favor of <a href="https://github.com/google/dagger">Google's Dagger 2</a>.
-            Please see <a href="http://google.github.io/dagger/dagger-1-migration.html">the migration guide</a> for helpwith the upgrade.
+            Please see <a href="https://google.github.io/dagger/dagger-1-migration.html">the migration guide</a> for help with the upgrade.
 
             <h3 id="introduction">Introduction</h3>
 
/Fim/
